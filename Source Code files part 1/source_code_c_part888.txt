t points[4];
    REAL width = 4;     // Pen width


    WCHAR filename[256];
    wcscpy(filename, L"../data/brick.jpg");
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 0;
    copyRect.Y = 0;
    copyRect.Width = 40;
    copyRect.Height = 30;

    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                         copyRect.Width, copyRect.Height,
                                         PixelFormat32bppARGB);
 
    if(copiedBitmap)
    {
        // Create a texture brush.
                          
        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        //copiedBitmap->Dispose();
        
        // Create a radial gradient pen.

        Color redColor(255, 0, 0);

        SolidBrush redBrush(redColor);
        Pen redPen(&redBrush, width);

        GraphicsPath *path;

        points[0].X = 100;
        points[0].Y = 60;
        points[1].X = -50;
        points[1].Y = 60;
        points[2].X = 150;
        points[2].Y = 250;
        points[3].X = 200;
        points[3].Y = 120;
        path = new GraphicsPath(FillModeAlternate);
        path->AddBeziers(points, 4);    
        g->FillPath(&textureBrush, path);
        g->DrawPath(&redPen, path);

        delete path;
        delete copiedBitmap;
    }

    delete bitmap;

    PointF destPoints[3];

    destPoints[0].X = 300;
    destPoints[0].Y = 50;
    destPoints[1].X = 450;
    destPoints[1].Y = 50;
    destPoints[2].X = 240;
    destPoints[2].Y = 200;
 
    Matrix mat;
    mat.Translate(0, 100);
    mat.TransformPoints(&destPoints[0], 3);
    wcscpy(filename, L"../data/apple1.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;

    destPoints[0].X = 30;
    destPoints[0].Y = 200;
    destPoints[1].X = 200;
    destPoints[1].Y = 200;
    destPoints[2].X = 200;
    destPoints[2].Y = 420;

    wcscpy(filename, L"../data/dog2.png");
    bitmap = new Bitmap(filename);
    g->DrawImage(bitmap, &destPoints[0], 3);
 
    delete bitmap;

    Color color(100, 128, 255, 0);

    SolidBrush brush(color);

    Point pts[10];
    INT count = 4;

    pts[0].X = 150;
    pts[0].Y = 60;
    pts[1].X = 100;
    pts[1].Y = 230;
    pts[2].X = 250;
    pts[2].Y = 260;
    pts[3].X = 350;
    pts[3].Y = 100;

    g->FillClosedCurve(&brush, pts, count);

    wcscpy(filename, L"../data/ballmer.jpg");
    bitmap = new Bitmap(filename);
    RectF destRect(220, 50, 180, 120);
    RectF srcRect;
    srcRect.X = 100;
    srcRect.Y = 40;
    srcRect.Width = 200;
    srcRect.Height = 200;
    g->DrawImage(bitmap, destRect, srcRect.X, srcRect.Y,
        srcRect.Width, srcRect.Height, UnitPixel);
    delete bitmap;
}

/**************************************************************************\
* TestPrimitives
*
* A test for ellipse, arc, pie, curve, and closed curve.
*
\**************************************************************************/

VOID
TestPrimitives(
    Graphics* g
    )
{
    RectF rect;

    rect.X = 250;
    rect.Y = 230;
    rect.Width = 150;
    rect.Height = 100;

    Color color(128, 128, 255, 0);

    SolidBrush brush(color);

    REAL width = 1;

    Color blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen pen(&blackBrush, width);

//    g->FillEllipse(&brush, rect);
//    g->DrawEllipse(&pen, rect);
    REAL startAngle = 0;
    REAL sweepAngle = 240;
    g->FillPie(&brush, rect, startAngle, sweepAngle);
    g->DrawPie(&pen, rect, startAngle, sweepAngle);

    PointF pts[10];
    INT count = 4;

    pts[0].X = 200;
    pts[0].Y = 160;
    pts[1].X = 150;
    pts[1].Y = 230;
    pts[2].X = 200;
    pts[2].Y = 260;
    pts[3].X = 300;
    pts[3].Y = 200;

    g->FillClosedCurve(&brush, pts, count);
    g->DrawClosedCurve(&pen, pts, count);
}


/**************************************************************************\
* TestMixedObjects
*
* A test for different brushes and pens.
*
\**************************************************************************/

VOID TestMixedObjects(Graphics* g)
{
    Point points[10];
    REAL width = 4;     // Pen width

    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.

    RectI copyRect;
    copyRect.X = 60;
    copyRect.Y = 60;
    copyRect.Width = 80;
    copyRect.Height = 60;
    Bitmap *copiedBitmap = bitmap->Clone(copyRect.X, copyRect.Y,
                                            copyRect.Width, copyRect.Height,
                                            PixelFormat32bppPARGB);

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);
    Color colors[4] = {
       Color(255, 255, 255, 255),
       Color(255, 255, 0, 0),
       Color(255, 0, 255, 0),
       Color(255, 0, 0, 255)
    };
// !! No longer supported
//    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);
    width = 8;
//    Pen gradPen(&rectGrad, width);

    if(copiedBitmap)
    {
        // Create a texture brush.

        TextureBrush textureBrush(copiedBitmap, WrapModeTile);

        //copiedBitmap->Dispose();
        
        // Create a radial gradient pen.

        points[3].X = 50;
        points[3].Y = 300;
        points[2].X = 100;
        points[2].Y = 300;
        points[1].X = 120;
        points[1].Y = 370;
        points[0].X = 50;
        points[0].Y = 350;

//        gradPen.SetLineJoin(LineJoinMiter);
        g->FillPolygon(&textureBrush, points, 4); 
//        g->DrawPolygon(&gradPen, points, 4);
    }

    delete copiedBitmap;
    delete bitmap;
}

/**************************************************************************\
* TestTexts
*
* A test for drawing texts.
*
\**************************************************************************/

VOID TestTexts(Graphics *g)
{
    //Font font(L"Arial", 60);

    FontFamily  ff(L"Arial");
    RectF     rectf(20, 0, 300, 200);
    GraphicsPath  path;

    // Solid color text.

    Color color(128, 100, 0, 200);
    SolidBrush brush(color);
    path.AddString(L"Color", 5, &ff, 0, 60,  rectf, NULL);
    g->FillPath(&brush, &path);

    // Texture text.

    WCHAR filename[256];
    wcscpy(filename, L"../data/marble1.jpg");
    Bitmap *bitmap = new Bitmap(filename);                          
    TextureBrush textureBrush(bitmap, WrapModeTile);
    path.Reset();
    rectf.X = 200;
    rectf.Y = 20;
    path.AddString(L"Texture", 7, &ff, 0, 60, rectf, NULL);
    g->FillPath(&textureBrush, &path);
    delete bitmap;

    // Gradient text.

    rectf.X = 40;
    rectf.Y = 80;
    path.Reset();
    path.AddString(L"Gradient", 8, &ff, 0, 60, rectf, NULL);
    Color color1(255, 255, 0, 0);
    Color color2(255, 0, 255, 0);
    LinearGradientBrush lineGrad(rectf, color1, color2, 0.0f);
    g->FillPath(&lineGrad, &path);

    // Shadow test

    REAL charHeight = 60;
    REAL topMargin = - 5;
    rectf.X = 0;
    rectf.Y = - charHeight - topMargin; // Make y-coord of the base line
                                        // of the characters to be 0.

    path.Reset();
    path.AddString(L"Shadow", 6, &ff, 0, charHeight, rectf, NULL);
    GraphicsPath* clonePath = path.Clone();

    Color redColor(255, 0, 0);
    Color grayColor(128, 0, 0, 0);
    SolidBrush redBrush(redColor);
    SolidBrush grayBrush(grayColor);

    // Shadow part.

    REAL tx = 180, ty = 200;
    Matrix skew;
    skew.Scale(1.0, 0.5);
    skew.Shear(-2.0, 0, MatrixOrderAppend);
    skew.Translate(tx, ty, MatrixOrderAppend);
    clonePath->Transform(&skew);
    g->FillPath(&grayBrush, clonePath);
    delete clonePath;

    // Front part.

    Matrix trans1;
    trans1.Translate(tx, ty);
    path.Transform(&trans1);
    g->FillPath(&redBrush, &path);


    return;
/*
    REAL x = 200, y = 150;

    RectF brushRect(x, y, 150, 32);
    Color colors[4] = {
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0),
       Color(180, 255, 0, 0),
       Color(180, 0, 255, 0)
    };
    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors, WrapModeTile);

    g->DrawString(L"GDI+", &font, &rectGrad, x, y);


    // And now with DrawText

    RectF rect(400, 200, 400, 400);

    g->DrawText(
        DrawTextDisplay,
        L"A few words powered by GDI+: \
\x3c3\x3bb\x3b1\x3b4 \
\x627\x644\x633\x644\x627\x645 \
\x5e9\x5dc\x5d5\x5dd \
\xe2d\xe4d\xe01\xe29\xe23\xe44\xe17\xe22 \
\x110\x068\x0ea\x300\x103",
       &font,           // Initial font
       &rectGrad,       // Initial brush (ignored for the time being)
        LANG_NEUTRAL,   // Initial language
       &rect            // Formatting rectangle
    );
*/

}

VOID TestTextAlongPath(Graphics *g)
{
    Point points[4];

    points[3].X = 100;
    points[3].Y = 10;
    points[2].X = -50;
    points[2].Y = 50;
    points[1].X = 150;
    points[1].Y = 200;
    points[0].X = 200;
    points[0].Y = 70;

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);

    path->Transform(&matrix);

    Color textColor(180, 200, 0, 200);
    SolidBrush textBrush(textColor);

    WCHAR text[] = L"Windows 2000";

    REAL offset = 60;

//    g->DrawString(text, 12, NULL, path, NULL, &textBrush, offset);

    delete path;
}

/**************************************************************************\
* TestDerive
*
* Test 
* A test for derivation support.
*
\**************************************************************************/

VOID 
TestDerive(
    HWND hwnd
    )
{
    HDC hdcScreen = GetDC(hwnd);
    HRGN hrgn = CreateEllipticRgn(10, 10, 300, 300);

    SetMapMode(hdcScreen, MM_TWIPS);
    SelectClipRgn(hdcScreen, hrgn);
    HBRUSH hbrushRed = CreateSolidBrush(RGB(255, 0, 0));
    SelectObject(hdcScreen, hbrushRed);
    Rectangle(hdcScreen, 0, 0, 3000, -3000);

    {
        Graphics g(hdcScreen);                                     
        SolidBrush solidBrush(Color(0, 255, 0));
        g.FillRectangle(&solidBrush, 0, -3000, 3000, 3000);
    }

    HBITMAP hbmBitmap = CreateCompatibleBitmap(hdcScreen, 50, 50);
    HDC hdcBitmap = CreateCompatibleDC(hdcScreen);
    SelectObject(hdcBitmap, hbmBitmap);
    SetWindowOrgEx(hdcBitmap, 40, 80, NULL);

    SelectObject(hdcBitmap, hbrushRed);
    Rectangle(hdcBitmap, 40, 80, 50, 50);

    {
        Graphics g(hdcBitmap);
        SolidBrush solidBrush(Color(0, 0, 255));
        g.FillRectangle(&solidBrush, 40, 80, 90, 130);

#if 0

        // The DC that we get back should have the same transform set
        // as that which we originally passed in:

        HDC hdcGet = g.GetHdc();
        point.x = 0;
        point.y = 0;
        DPtoLP(hdcGet, &point, 1);

        // !!! BAD on Alpha box
        // if ((hdcGet == NULL) || (point.x != 40) || (point.y != 80)) _asm int 3;

        g.ReleaseHdc(hdcGet);

#endif

    }

    // The DC should have beeen returned to the top save level:

    INT saveLevel = SaveDC(hdcBitmap);

    // !!! BAD on Alpha box
    // if (saveLevel != 1) _asm int 3;

    // The DC should have had its transform restored:

    POINT oldPoint;
    SetWindowOrgEx(hdcBitmap, 0, 0, &oldPoint);

    // !!! BAD on Alpha box
    // if ((oldPoint.x != 40) || (oldPoint.y != 80)) _asm int 3;

    // Blt the (hopefully) blue square to the screen.  But first,
    // reset our transform on 'hdcScreen' the lazy way:

    ReleaseDC(hwnd, hdcScreen);
    hdcScreen = GetDC(hwnd);
    BitBlt(hdcScreen, 0, 0, 50, 50, hdcBitmap, 0, 0, SRCCOPY);
    ReleaseDC(hwnd, hdcScreen);
}

/**************************************************************************\
* TestImaging
*
* A test for imaging and DrawImage.
*
\**************************************************************************/

BOOL CALLBACK MyDrawImageAbort(VOID* data)
{
    UINT *count = (UINT*) data;

    *count += 1;

    //LBprintf("MyDrawImageAbort: %ld", *count);

    return FALSE;
}

VOID TestImaging(Graphics* g)
{
    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";
    Image *image = new Image(filename);

    // Get information on the image.

    Image *imageThumb = image->GetThumbnailImage(32, 32);

    // Try to save thumbnail

    WCHAR *thumbfile = L"thumb256.bmp";

    CLSID _BmpCodecClsID_ =
    {
        0x557cf400,
        0x1a04,
        0x11d3,
        {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
    };

    if (imageThumb->Save(thumbfile, &_BmpCodecClsID_, NULL) == Ok)
        LBprintf("thumbnail save OK");
    else
        LBprintf("thumbnail save failed");

    RectF srcRect;
    srcRect.X = 20;
    srcRect.Y = 20;
    srcRect.Width = 180;
    srcRect.Height = 180;

    PointF points[4];

    PointF destPoints[3];

    destPoints[0].X = 300;
    destPoints[0].Y = 50;
    destPoints[1].X = 450;
    destPoints[1].Y = 50;
    destPoints[2].X = 240;
    destPoints[2].Y = 200;
    //g->DrawImage(image, &destPoints[0], 3);

    RectF thumbRect(220, 50, (REAL) imageThumb->GetWidth(), (REAL) imageThumb->GetHeight());
    
    //g->DrawImage(imageThumb, thumbRect);

    UINT abortCount = 0;

    ImageAttributes imgAttrib;

    Rect destRect(50, 10, 100, 100);

    // Make near-white to white transparent

    Color c1(200, 200, 200);
    Color c2(255, 255, 255);
    imgAttrib.SetColorKey(c1, c2);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    ColorMatrix darkMatrix = {.75, 0, 0, 0, 0,
                              0, .75, 0, 0, 0,
                              0, 0, .75, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    ColorMatrix greyMatrix = {.25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              .25, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              (REAL).1, (REAL).1, (REAL).1, 0, 1};

    ColorMatrix pinkMatrix = {(REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              (REAL).33, .25, .25, 0, 0,
                              0, 0, 0, 1, 0,
                              0, 0, 0, 0, 1};

    // red->blue, green->red, blue->green, alpha = 0.75
    ColorMatrix swapMatrix = {0, 0, 1, 0, 0,
                              1, 0, 0, 0, 0,
                              0, 1, 0, 0, 0,
                              0, 0, 0, .75, 0,
                              0, 0, 0, 0, 1};

    // red->blue, green->red, blue->green, alpha = 0.9
    ColorMatrix swapMatrix2 = {0, 0, 1, 0, 0,
                               1, 0, 0, 0, 0,
                               0, 1, 0, 0, 0,
                               0, 0, 0, 0, 0,
                               0, 0, 0, (REAL).9, 1};

    imgAttrib.ClearColorKey();
    imgAttrib.SetColorMatrix(&greyMatrix);

    destRect.Y += destRect.Height;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&pinkMatrix, ColorMatrixFlagsSkipGrays);

    destRect.Y += destRect.Height;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&darkMatrix);

    destRect.X += destRect.Width;
    destRect.Y = 10;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.ClearColorMatrix();
    imgAttrib.SetGamma(3.0);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.SetThreshold(0.5);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    imgAttrib.SetColorMatrix(&swapMatrix);
    imgAttrib.ClearGamma();
    imgAttrib.ClearThreshold();

    destRect.X += destRect.Width;
    destRect.Y = 10;

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    destRect.Y += destRect.Height;

    imgAttrib.SetNoOp();
    imgAttrib.SetColorMatrix(&swapMatrix2);

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);
    destRect.Y += destRect.Height;

    imgAttrib.ClearNoOp();

    g->DrawImage(image, destRect, 0, 0, 180, 180, UnitPixel, &imgAttrib,
                 MyDrawImageAbort, (VOID*)&abortCount);

    delete image;
    delete imageThumb;
}

VOID TestBitmapGraphics(Graphics* g)
{
    INT bitmapSize = 500;

    Bitmap* bitmap = new Bitmap(bitmapSize, bitmapSize, g);

    if (!bitmap)
        LBprintf("Bitmap creation failed");
    else
    {
        LBprintf("ImageInfo: %ld x %ld", bitmap->GetWidth(), bitmap->GetHeight());
    }

    Graphics *bitmapGraphics = Graphics::FromImage(bitmap);

    if (!bitmapGraphics)
        LBprintf("Bitmap.GetGraphics() failed");

    TestContainerClip(bitmapGraphics);
    TestContainer(bitmapGraphics);
    TestPolygons(bitmapGraphics);
    TestPaths(bitmapGraphics);
    TestRegions(bitmapGraphics);
    TestGradients(bitmapGraphics);
    TestHatches(bitmapGraphics);
    TestBitmaps(bitmapGraphics);
    TestPrimitives(bitmapGraphics);
    TestMixedObjects(bitmapGraphics);
    TestTexts(bitmapGraphics);
    TestImaging(bitmapGraphics);

    delete bitmapGraphics;

    Rect destRect(100, 100, bitmapSize, bitmapSize);

    g->DrawImage(bitmap, destRect, 0, 0, bitmapSize, bitmapSize, UnitPixel);

    delete bitmap;
}

/**************************************************************************\
* TestCompoundLines
*
* A test for compound lines.
*
\**************************************************************************/

VOID TestCompoundLines(Graphics *g)
{
    REAL width = 4;         // Pen width
    PointF points[4];

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellowColor(128, 255, 255, 0);
    SolidBrush yellowBrush(yellowColor);

    GraphicsPath* path = new GraphicsPath(FillModeAlternate);
    path->AddBeziers(points, 4);

    points[0].X = 260;
    points[0].Y = 20;
    path->AddLines(points, 1);
    Matrix matrix;
    matrix.Scale(1.5, 1.5);
    matrix.Translate(0, 30);

    // If you wanto to flatten the path before rendering,
    // Flatten() can be called.

    BOOL flattenFirst = FALSE;

    if(!flattenFirst)
    {
        // Don't flatten and keep the original path.
        // FillPath or DrawPath will flatten the path automatically
        // without modifying the original path.

        path->Transform(&matrix);
    }
    else
    {
        // Flatten this path.  The resultant path is made of line
        // segments.  The original path information is lost.

        path->Flatten(&matrix);
    }

    Color blackColor(0, 0, 0);

    SolidBrush blackBrush(blackColor);
    // Set the pen width in inch.
    width = (REAL) 0.2;
    Pen blackPen(&blackBrush, width);

    REAL* compoundArray = new REAL[6];
    compoundArray[0] = 0.0f;
    compoundArray[1] = 0.2f;
    compoundArray[2] = 0.4f;
    compoundArray[3] = 0.6f;
    compoundArray[4] = 0.8f;
    compoundArray[5] = 1.0f;
    blackPen.SetCompoundArray(&compoundArray[0], 6);
    blackPen.SetDashStyle(DashStyleDash);

    blackPen.SetStartCap(LineCapDiamondAnchor);    
    blackPen.SetEndCap(LineCapArrowAnchor);

    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    
    delete [] compoundArray;
    delete path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\moo\moo.cxx ===
#include <stdio.h>
#include <math.h>
#include <windows.h>
#include <objbase.h>
#include <gdiplus.h>
#include "..\gpinit.inc"

#define or )
#define moo (
#define a
#define o 1
#define oo moo o + o or
#define m oo*
#define MOO m m moo m m m m oo - moo m oo + oo + o ))
#define M m MOO ,
#define O o*MOO ,
#define GotMilk *O M MOO
#define The Graphics
#define with a GetDC
#define goes a
#define to ;
#define fun to float
#define holy fun *
#define fly goes MOO or
#define the GraphicsPath goes
#define JumpOver AddLines
#define and or to
#define Follow(moo) Draw##moo
#define Say Follow(Ellipse)
#define mooo Pen
        
void __cdecl main() 
{
    using namespace Gdiplus;
    
    The cow goes moo with a moo o-o or and mooo mooo moo Color 
    moo M(m o-o or, oo*m moo oo -o-o), m MOO or , m m m m o+oo and cow.
    Say moo &mooo, moo m o+o or 
    * O m O O m MOO and cow. 
    Say moo & mooo, (m o+oo+o or GotMilk?
    MOO: !moo a moo oo) 
    or + MOO - O m MOO or fun 
    ooo[(m o+o or*moo
    o+m o or+o] holy Cow = ooo;* moo Cow++) = moo MOO and*moo Cow 
    ++or = m M*moo Cow++ or = moo MOO and*moo Cow ++or = M*moo Cow++ 
    or = MOO + moo m m o+o or*moo m m 
    m o+oo and *(Cow++ or = MOO + MOO + M * moo Cow++)= 
    MOO + O * (Cow++ or = moo MOO + MOO); *
    moo Cow++ or = M*moo Cow++ or = m moo MOO+
    fly to the moon; moon.JumpOver 
    (moo PointF*or ooo, m o+o+oo and cow. 
    Follow(Path) moo &mooo, &moon );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\multithread\multithread.cpp ===
// This is a dual threaded test app designed to expose a weakness in 
// GDI+. The CreateDCA("DISPLAY", NULL, NULL, NULL) used to create our
// Globals::DesktopDc during GdiplusStartup has thread affinity (as opposed
// to other inputs to CreateDCA) and therefore when the creation thread
// is terminated, the global DC goes away. This will cause random drawing
// failure in gdiplus.
//
// The main thread spawns a 'creation' thread to initialize gdiplus and draw
// something. When it's done and terminated, the main thread attempts to draw
// something on the screen before shutting down gdiplus. By the time the 
// main thread gets to draw something, the DesktopDc has been cleaned up and
// we ASSERT in gdiplus.
//
// Created: 02/03/2001 [asecchia]
//

#include "precomp.hpp"

using namespace Gdiplus;

GdiplusStartupInput sti;
ULONG_PTR token;
bool gdiplusInitialized = false;
DWORD threadId;


// This is a CriticalSection Proxy designed to 
// automatically acquire the critical section 
// when the instance is created and release 
// it when it goes out of scope.

class ThreadMutex
{
public:

    static VOID InitializeCriticalSection()
    {
        ::InitializeCriticalSection(&critSec);
    }

    static VOID DeleteCriticalSection()
    {
        ::DeleteCriticalSection(&critSec);
    }

    ThreadMutex()
    {
        EnterCriticalSection(&critSec);
    }

    ~ThreadMutex()
    {
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
};

CRITICAL_SECTION ThreadMutex::critSec;

// This is the main routine for the creation thread.
// GDI+ will be initialized on this thread and we'll draw a red rectangle
// on the screen.
// It's protected under the thread mutex help ensure this thread is done
// before the main thread continues.
// This is not normally a useful requirement, but for the purposes of this 
// test, it's important.

DWORD WINAPI ThreadProc(VOID*)
{
    ThreadMutex tm;
    
    gdiplusInitialized = (Ok == GdiplusStartup(&token, &sti, NULL));
    
    if(gdiplusInitialized)
    {
        HDC hdc = GetDC(NULL);
        
        // Draw a red rectangle.
        
        Graphics g(hdc);
        SolidBrush brush(Color(0x3fff0000));
        g.FillRectangle(&brush, 300, 300, 400, 200);    
        
        ReleaseDC(NULL, hdc);
    }
    
    return 1;
}


// Main thread of execution.

void __cdecl main( void )
{
    ThreadMutex::InitializeCriticalSection();
    
    // Make the creation thread.

    CreateThread(
        NULL,                        // LPSECURITY_ATTRIBUTES
        0,                           // same stack size
        &ThreadProc,
        0,                           // parameter to thread
        0,                           // creation flags
        &threadId
    );


    // wait for the creation thread to initialize gdiplus.
    // This ensures the creation thread happens first and ensures the
    // correct ordering of acquiring the ThreadMutex.
    
    do { } while(!gdiplusInitialized);

    {
        // block till the ThreadMutex becomes available.
        // This ensures that the creation thread is done before we get started.
        
        ThreadMutex tm;

        // The thread mutex will ensure that we don't start till the thread
        // proc for the creation thread is done. However we want to wait till
        // NTUSER is done cleaning up our thread specific resources during
        // thread terminationi and that's not protected by the ThreadMutex.
        // Wait 5 seconds here to ensure that thread termination has enough
        // time to finish.
        
        Sleep(500);
        
        // If initialization of gdiplus was successful, draw a blue rectangle.
        
        if(gdiplusInitialized)
        {
            HDC hdc = GetDC(NULL);
        
            // Draw a blue rectangle.
                
            Graphics g(hdc);
            SolidBrush brush(Color(0x3f0000ff));
            g.FillRectangle(&brush, 100, 100, 400, 200);    
            
            ReleaseDC(NULL, hdc);
        }
    }
    
    // scope barrier so the objects above destruct before we call shutdown.
    
    if(gdiplusInitialized)
    {
        GdiplusShutdown(token);
    }
    
    ThreadMutex::DeleteCriticalSection();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\pathtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wndstuff.rc
//
#define IDR_ACCELERATOR1                101
#define MM_CLEARPATH                    40001
#define MM_OBEFOREMODE                  40002
#define MM_OAFTERMODE                   40003
#define MM_FLATNESS_1                   40004
#define MM_FLATNESS_2                   40005
#define MM_FLATNESS_3                   40006
#define MM_FLATNESS_4                   40007
#define MM_PRINT                        40008
#define MM_SAVESCRIPT                   40009
#define MM_SHOWHATCHBRUSHSTROKE         40010
#define MM_SHOWDASHSTROKE               40011
#define MM_USEASCLIPPATH                40012
#define MM_CLEARCLIPPATH                40013
#define MM_CHANGETEXTUREFILL            40014
#define MM_OPENFILE                     40015
#define MM_SAVEFILE                     40016
#define MM_SHOWTRANSSOLIDFILL           40017
#define MM_SHOWTEXTUREFILL              40018
#define MM_SHOWTRANSGRADFILL            40019
#define MM_LINEMODE                     40020
#define MM_BEZIERMODE                   40021
#define MM_CLOSEPATH                    40022
#define MM_COLORMODE_NOCHANGE           40023
#define MM_COLORMODE_TRANS50            40024
#define MM_COLORMODE_GRADTRANS          40025
#define MM_SHOWBGGRADFILL               40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\pathtest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

// for Win95 compile
#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <commdlg.h>
#include "wndstuff.h"

#include "../gpinit.inc"

HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;
bool buttondown = false;
float flatness = 0.25f;


PtFlag ifs(INT f, PtFlag v)
{
    return f ? v : PtNoFlag;
}

PtFlag CalcFlags(HWND hwnd)
{
    return (PtFlag)(
        ifs(GetMenuState(GetMenu(hwnd), MM_BEZIERMODE, MF_BYCOMMAND) & MF_CHECKED, PtBezierFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_OBEFOREMODE, MF_BYCOMMAND) & MF_CHECKED, PtOutlineBeforeFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_OAFTERMODE, MF_BYCOMMAND) & MF_CHECKED, PtOutlineAfterFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWDASHSTROKE, MF_BYCOMMAND) & MF_CHECKED, PtDashPatternFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWHATCHBRUSHSTROKE, MF_BYCOMMAND) & MF_CHECKED, PtHatchBrushFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWTEXTUREFILL, MF_BYCOMMAND) & MF_CHECKED, PtTextureFillFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWTRANSSOLIDFILL, MF_BYCOMMAND) & MF_CHECKED, PtTransSolidFillFlag) | 
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWTRANSGRADFILL, MF_BYCOMMAND) & MF_CHECKED, PtTransGradFillFlag) |
        ifs(GetMenuState(GetMenu(hwnd), MM_SHOWBGGRADFILL, MF_BYCOMMAND) & MF_CHECKED, PTBackgroundGradFillFlag));}

void HandleCheckUncheck(INT flag, HWND hwnd)
{
    if (GetMenuState(GetMenu(hwnd), flag, MF_BYCOMMAND) & MF_CHECKED)
        CheckMenuItem(GetMenu(hwnd), flag, MF_UNCHECKED);
    else
        CheckMenuItem(GetMenu(hwnd), flag, MF_CHECKED);
    InvalidateRect(hwnd, NULL, false);
}


/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LRESULT CALLBACK
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    INT xpos, ypos;

    switch (message)
    {
    case WM_CREATE:
        return true;

    case WM_SIZE:
        xpos = LOWORD(lParam);
        ypos = HIWORD(lParam);
        Resize(xpos, ypos);
        InvalidateRect(hwnd, NULL, false);
        return true;

    case WM_LBUTTONDOWN:
        buttondown = true;
        return true;

    case WM_LBUTTONUP:
        if (!buttondown)
            break;
        buttondown = false;
        xpos = LOWORD(lParam);
        ypos = HIWORD(lParam);
        RECT rect;
        GetClientRect(hwnd, &rect);
        AddPoint(xpos, ypos);
        InvalidateRect(hwnd, NULL, false);
        return true;

    case WM_COMMAND: {
        INT flag = LOWORD(wParam);
        switch(flag)
        {
        case MM_SHOWDASHSTROKE:
            HandleCheckUncheck(flag, hwnd);
            return true;
        
        case MM_SHOWHATCHBRUSHSTROKE:
            HandleCheckUncheck(flag, hwnd);
            return true;
            
        case MM_SHOWTEXTUREFILL:
            HandleCheckUncheck(flag, hwnd);
            return true;

        case MM_SHOWTRANSSOLIDFILL:
            HandleCheckUncheck(flag, hwnd);
            return true;
        
        case MM_SHOWTRANSGRADFILL:
            HandleCheckUncheck(flag, hwnd);
            return true;

        case MM_SHOWBGGRADFILL:
            HandleCheckUncheck(flag, hwnd);
            return true;

        case MM_CHANGETEXTUREFILL: {
            OPENFILENAME ofn;       // common dialog box structure
            char szFile[260];       // buffer for file name
            szFile[0] = 0;

            ZeroMemory(&ofn, sizeof(OPENFILENAME));
            ofn.lStructSize = sizeof(OPENFILENAME);
            ofn.hwndOwner = hwnd;
            ofn.lpstrFile = szFile;
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFilter = "Images\0*.*\0";
            ofn.nFilterIndex = 0;
            ofn.lpstrFileTitle = NULL;
            ofn.nMaxFileTitle = 0;
            ofn.lpstrInitialDir = NULL;
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
            char curdir[260];
            GetCurrentDirectory(sizeof(curdir), curdir);
            if (GetOpenFileName(&ofn)==TRUE)
            {
                WCHAR wchar[256];
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, ofn.lpstrFile, -1, wchar, 256);
                ChangeTexture(wchar);
                SetCurrentDirectory(curdir);
                InvalidateRect(hwnd, NULL, false);
            }
            else
            {
                printf("%d", CommDlgExtendedError());
            }
            return true;}
        
        case MM_OPENFILE: {
            OPENFILENAME ofn;       // common dialog box structure
            char szFile[260];       // buffer for file name
            szFile[0] = 0;

            ZeroMemory(&ofn, sizeof(OPENFILENAME));
            ofn.lStructSize = sizeof(OPENFILENAME);
            ofn.hwndOwner = hwnd;
            ofn.lpstrFile = szFile;
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFilter = "All\0*.*\0Text\0*.TXT\0";
            ofn.nFilterIndex = 1;
            ofn.lpstrFileTitle = NULL;
            ofn.nMaxFileTitle = 0;
            ofn.lpstrInitialDir = NULL;
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
            char curdir[260];
            GetCurrentDirectory(sizeof(curdir), curdir);
            if (GetOpenFileName(&ofn)==TRUE)
            {
                OpenPath(ofn.lpstrFile);
                SetCurrentDirectory(curdir);
                InvalidateRect(hwnd, NULL, false);
            }
            else
            {
                printf("%d", CommDlgExtendedError());
            }
            return true;}
            
        case MM_SAVEFILE: {
            OPENFILENAME ofn;       // common dialog box structure
            char szFile[260];       // buffer for file name
            szFile[0] = 0;

            ZeroMemory(&ofn, sizeof(OPENFILENAME));
            ofn.lStructSize = sizeof(OPENFILENAME);
            ofn.hwndOwner = hwnd;
            ofn.lpstrFile = szFile;
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFilter = "All\0*.*\0Text\0*.TXT\0";
            ofn.nFilterIndex = 1;
            ofn.lpstrFileTitle = NULL;
            ofn.nMaxFileTitle = 0;
            ofn.lpstrInitialDir = NULL;
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
            char curdir[260];
            GetCurrentDirectory(sizeof(curdir), curdir);
            if (GetOpenFileName(&ofn)==TRUE)
            {
                SavePath(ofn.lpstrFile);
                SetCurrentDirectory(curdir);
                InvalidateRect(hwnd, NULL, false);
            }
            else
            {
                printf("%d", CommDlgExtendedError());
            }
            return true;}
            
        case MM_PRINT:
            Print(hwnd, flatness, CalcFlags(hwnd));
            return true;

        case MM_CLOSEPATH:
            ClosePath();
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_CLEARPATH:
            ClearPath();
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_USEASCLIPPATH: {
            ClipPath(CalcFlags(hwnd) & PtBezierFlag);
            InvalidateRect(hwnd, NULL, false);
            return true;}

        case MM_CLEARCLIPPATH:
            ClearClipPath();
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_LINEMODE:
            CheckMenuItem(GetMenu(hwnd), MM_LINEMODE, MF_CHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_BEZIERMODE, MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_BEZIERMODE:
            CheckMenuItem(GetMenu(hwnd), MM_LINEMODE, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_BEZIERMODE, MF_CHECKED);
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_OBEFOREMODE:
            if (GetMenuState(GetMenu(hwnd), MM_OBEFOREMODE, MF_BYCOMMAND) & MF_CHECKED)
                CheckMenuItem(GetMenu(hwnd), MM_OBEFOREMODE, MF_UNCHECKED);
            else
                CheckMenuItem(GetMenu(hwnd), MM_OBEFOREMODE, MF_CHECKED);
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_OAFTERMODE:
            if (GetMenuState(GetMenu(hwnd), MM_OAFTERMODE, MF_BYCOMMAND) & MF_CHECKED)
                CheckMenuItem(GetMenu(hwnd), MM_OAFTERMODE, MF_UNCHECKED);
            else
                CheckMenuItem(GetMenu(hwnd), MM_OAFTERMODE, MF_CHECKED);
            InvalidateRect(hwnd, NULL, false);
            return true;

        case MM_FLATNESS_1:
        case MM_FLATNESS_2:
        case MM_FLATNESS_3:
        case MM_FLATNESS_4: {
            CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_1, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_2, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_3, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_4, MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, false);
            switch (LOWORD(wParam))
            {
            case MM_FLATNESS_1:
                flatness = 10.0f;
                CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_1, MF_CHECKED);
                return true;
            case MM_FLATNESS_2:
                flatness = 1.0f;
                CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_2, MF_CHECKED);
                return true;
            case MM_FLATNESS_3:
                flatness = 0.25f;
                CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_3, MF_CHECKED);
                return true;
            case MM_FLATNESS_4:
                flatness = 0.1f;
                CheckMenuItem(GetMenu(hwnd), MM_FLATNESS_4, MF_CHECKED);
                return true;
            }
        }

        case MM_COLORMODE_NOCHANGE:
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_NOCHANGE, MF_CHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_TRANS50, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_GRADTRANS, MF_UNCHECKED);
            SetColorMode(0);
            InvalidateRect(hwnd, NULL, false);
            return true;
        case MM_COLORMODE_TRANS50:
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_NOCHANGE, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_TRANS50, MF_CHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_GRADTRANS, MF_UNCHECKED);
            SetColorMode(1);
            InvalidateRect(hwnd, NULL, false);
            return true;
        case MM_COLORMODE_GRADTRANS:
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_NOCHANGE, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_TRANS50, MF_UNCHECKED);
            CheckMenuItem(GetMenu(hwnd), MM_COLORMODE_GRADTRANS, MF_CHECKED);
            SetColorMode(2);
            InvalidateRect(hwnd, NULL, false);
            return true;

        default:
            break;
        }
        break;}
        
    case WM_KEYUP:
        if(!( ((CHAR)wParam=='q') || 
              ((CHAR)wParam=='Q') ) )
        {
            break;
        }

    case WM_DESTROY:
        CleanUp();
        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    case WM_PAINT:
        DrawPath(hwnd, NULL, NULL, flatness, CalcFlags(hwnd));
        return true;

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    debug = FALSE;
    WNDCLASS wc;

    //ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    //wc.hbrBackground    = ghbrWhite;
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |
        WS_CAPTION      |
        WS_THICKFRAME   |
        WS_MAXIMIZEBOX  |
        WS_BORDER       |
        WS_MINIMIZEBOX  |
        WS_CLIPCHILDREN |
        WS_VISIBLE      |
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(101));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\pathtest\pathtest.cpp ===
#include <crtdbg.h>

#include <stdio.h>
#include <objbase.h>
#include <windows.h>
#include <winspool.h>
#include <commdlg.h>
#include <gdiplus.h>
using namespace Gdiplus;

#include "wndstuff.h"

GraphicsPath gppath;
GraphicsPath widepath;
GraphicsPath clippath;
TextureBrush *texturebrush = NULL;
PointF lastpoint(-1,-1);
Bitmap *offscreenbitmap = NULL;
int subpathlength = 0;
int ScaleColorMode = 0;
WCHAR savedFilename[255];

void
RemakePath(GraphicsPath *linepath, GraphicsPath *bezpath, BOOL bezmode)
{
    GraphicsPath *temppath = linepath->Clone();
    temppath->CloseFigure();
    bezpath->Reset();
    PointF *points = new PointF[temppath->GetPointCount()];
    BYTE *types = new BYTE[temppath->GetPointCount()];
    temppath->GetPathPoints(points, temppath->GetPointCount());
    temppath->GetPathTypes(types, temppath->GetPointCount());
    int last = 0;
    for (int i=0; i<temppath->GetPointCount(); i++)
    {
        if (types[i] & PathPointTypeCloseSubpath)
        {
            if (i-last+1 > 2)
            {
                if (!bezmode)
                {
                    bezpath->AddPolygon(points+last, i-last+1);
                }
                else
                {
                    bezpath->AddClosedCurve(points+last, i-last+1);
                }
                last = i+1;
            }
        }
    }
    delete points;
    delete types;
    delete temppath;
}

void
SplitPath(BOOL bezmode, BOOL before, BOOL after, float flatness)
{
    if (gppath.GetPointCount() < 3)
        return;
        
    RemakePath(&gppath, &widepath, bezmode);
    
    if (widepath.GetPointCount() > 2)
    {
        Pen pen(Color(0xff000000), 20);
        pen.SetLineJoin(LineJoinMiter);
        pen.SetMiterLimit(5);
        Matrix matrix;
        if (before)
            widepath.Outline(NULL, flatness);
        widepath.Widen(&pen, NULL, flatness);
        if (after)
            widepath.Outline(NULL, flatness);
    }
}

void
ClosePath()
{
    if (gppath.GetPointCount() < 1)
        return;
    gppath.CloseFigure();
    lastpoint = PointF(-1,-1);
}

void
ClearPath()
{
    lastpoint = PointF(-1,-1);
    gppath.Reset();
    widepath.Reset();
}

void
ClipPath(BOOL bezmode)
{
    clippath.Reset();
    GraphicsPath remadepath;
    RemakePath(&gppath, &remadepath, bezmode);
    clippath.AddPath(&remadepath, FALSE);
    ClearPath();
}

void
ClearClipPath()
{
    clippath.Reset();
}

void
AddPoint(INT x, INT y)
{
    if (!(lastpoint.X == -1 && lastpoint.Y == -1))
    {
        gppath.AddLine(lastpoint, PointF((float)x, (float)y));
    }
    lastpoint = PointF((float)x, (float)y);
}

void
OpenPath(char *filename)
{
    FILE *f = fopen(filename, "rt");
    INT count;

    fscanf(f, "%i", &count);
    for (INT i=0; i<count; i++)
    {
        INT type;
        REAL x, y;
        fscanf(f, "%i %f %f\n", &type, &x, &y);

        if (((type & 7) == 0) && i == 0)
        {
            gppath.Reset();
            PointF lastpoint; lastpoint.X = -1; lastpoint.Y = -1;
        }

        if ((type & 7) == 0)
        {
            lastpoint = PointF((float)x, (float)y);
        }
        else if ((type & 7) == 1)
        {
            gppath.AddLine(lastpoint, PointF((float)x, (float)y));
            lastpoint = PointF((float)x, (float)y);
        }
        
        if (type & 128)
        {
            //gppath.AddLine(firstpoint, lastpoint);
            ClosePath();
        }
    }

    fclose(f);
}

void
SavePath(char *filename)
{
    FILE *f = fopen(filename, "wt");

    int count = gppath.GetPointCount();

    Point *pathpoints = new Point[count];
    BYTE *pathtypes = new BYTE[count];
    gppath.GetPathPoints(pathpoints, count);
    gppath.GetPathTypes(pathtypes, count);

    fprintf(f, "%d\n", count);
    for (int i=0; i<count; i++)
    {
        fprintf(f, "%i %d %d\n", pathtypes[i], pathpoints[i].X, pathpoints[i].Y);
    }

    fclose(f);
    
    delete pathpoints;
    delete pathtypes;
}

void
SetColorMode(INT colorMode)
{
    ScaleColorMode = colorMode;
    ChangeTexture(savedFilename);
}

Color
ScaleColor(Color color, INT x, INT width)
{
    REAL alphaScale = 1, redScale = 1, greenScale = 1, blueScale = 1;
    switch (ScaleColorMode)
    {
    case 1:
        alphaScale = 0.5;
        break;
    case 2:
        alphaScale = (REAL)x / width;
        break;
    }
    
    REAL alpha = ((REAL)color.GetAlpha())*alphaScale;
    REAL red = ((REAL)color.GetRed())*redScale;
    REAL green = ((REAL)color.GetGreen())*greenScale;
    REAL blue = ((REAL)color.GetBlue())*blueScale;
    return Color((BYTE)alpha, (BYTE)red, (BYTE)green, (BYTE)blue);
}

void
ScaleColors(Bitmap* destBitmap, Bitmap *bitmap)
{
    BitmapData bmpData;
    Rect rect = Rect(0, 0, bitmap->GetWidth(), bitmap->GetHeight());
    if (bitmap->LockBits(&rect, ImageLockModeRead, PixelFormat32bppARGB, &bmpData) == Ok)
    {
        ARGB *data;
        for (UINT y=0; y<bitmap->GetHeight(); y++)
        {
            data = (ARGB*)((BYTE*)bmpData.Scan0+(y*bmpData.Stride));
            for (UINT x=0; x<bitmap->GetWidth(); x++)
            {
                *data = ScaleColor(Color(*data), x, bitmap->GetWidth()).GetValue();
                data++;
            }
        }
        BitmapData bmpDataDest;
        if (destBitmap->LockBits(&rect, ImageLockModeWrite, PixelFormat32bppARGB, &bmpDataDest) == Ok)
        {
            memcpy(bmpDataDest.Scan0, bmpData.Scan0, bitmap->GetWidth() * bitmap->GetHeight() * sizeof(ARGB));
            destBitmap->UnlockBits(&bmpDataDest);
        }
        bitmap->UnlockBits(&bmpData);
    }
}

void
ChangeTexture(const WCHAR *filename)
{
    wcsncpy(savedFilename, filename, 255);
    delete texturebrush;
    Bitmap image(filename);
    Bitmap image2(image.GetWidth(), image.GetHeight(), PixelFormat32bppARGB);
    ScaleColors(&image2, &image);
    texturebrush = new TextureBrush(&image2);
}

void
Resize(INT x, INT y)
{
    delete offscreenbitmap;
    offscreenbitmap = new Bitmap(x, y, PixelFormat32bppPARGB);
}

void
CleanUp()
{
    delete offscreenbitmap;
    delete texturebrush;
}

VOID
Print(HWND hwnd, float flatness, PtFlag flags)
{
    PRINTDLG printdlg;
    memset(&printdlg, 0, sizeof(PRINTDLG));
    printdlg.lStructSize = sizeof(PRINTDLG);
    printdlg.hwndOwner = hwnd;
    printdlg.hDevMode = NULL;
    printdlg.hDevNames = NULL;
    printdlg.hDC = NULL;
    printdlg.Flags = PD_RETURNDC;
    if (PrintDlg(&printdlg))
    {        
        DOCINFO di;
        memset(&di, 0, sizeof(DOCINFO));
        di.cbSize = sizeof(DOCINFO);
        di.lpszDocName = "Path Printing Test";
        di.lpszOutput = (LPTSTR)NULL;
        di.lpszDatatype = (LPTSTR)NULL;
        di.fwType = 0;
        DEVMODE *devmode = (DEVMODE*)GlobalLock(printdlg.hDevMode);
        if (devmode == NULL)
            return;
        HANDLE hprinter;
        OpenPrinter((LPSTR)devmode->dmDeviceName, &hprinter, NULL);
        GlobalUnlock(printdlg.hDevMode);

        StartDoc(printdlg.hDC, &di);
        StartPage(printdlg.hDC);

        DrawPath(hwnd, &printdlg.hDC, &hprinter, flatness, flags);
        
        EndPage(printdlg.hDC);
        EndDoc(printdlg.hDC);
    }
    else
    {
        DWORD error = CommDlgExtendedError();
        if (error)
        {
            char errormessage[100];
            sprintf(errormessage, "PrintDlg error: %d", error);
            MessageBox(hwnd, errormessage, "PrintDlg error", MB_OK);
        }
    }
}

void
DrawPath(HWND hwnd, HDC *phdc, HANDLE *hprinter, float flatness, PtFlag flags)
{
    if (!offscreenbitmap)
        return;

    Graphics *renderinggraphics;
    if (phdc)
    {
        renderinggraphics = new Graphics(*phdc, *hprinter);
    }
    else
    {
        renderinggraphics = new Graphics(offscreenbitmap);
    }

    RECT rect;
    GetClientRect(hwnd, &rect);

    Brush *background;
    if (flags & PTBackgroundGradFillFlag)
    {
        background = new LinearGradientBrush(Point(0, 0), Point((rect.right-rect.left)/4, 0), Color(0xffffffff), Color(0xff0000ff));
        ((LinearGradientBrush*)background)->SetWrapMode(WrapModeTileFlipX);
    }
    else
    {
        background = new SolidBrush(Color(0xffffffff));
    }
    renderinggraphics->FillRectangle(background, Rect(rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top));
    delete background;

    renderinggraphics->SetSmoothingMode(SmoothingModeAntiAlias);

    if (gppath.GetPointCount() > 0)
    {
        SplitPath(flags & PtBezierFlag, flags & PtOutlineBeforeFlag, flags & PtOutlineAfterFlag, flatness);
        if (clippath.GetPointCount() > 2)
        {
            renderinggraphics->SetClip(&clippath);
        }
        
        if (flags & PtTextureFillFlag)
        {
            if (!texturebrush)
                ChangeTexture(L"mycomputer.jpg");

            GraphicsPath bezpath;
            RemakePath(&gppath, &bezpath, flags & PtBezierFlag);
            if (flags & PtOutlineBeforeFlag)
                bezpath.Outline();
            bezpath.SetFillMode(FillModeWinding);
            renderinggraphics->FillPath(texturebrush, &bezpath);
        }

        if (flags & PtTransSolidFillFlag)
        {
            SolidBrush transsolidbrush(Color(0x80ffff00));
            GraphicsPath bezpath;
            RemakePath(&gppath, &bezpath, flags & PtBezierFlag);
            if (flags & PtOutlineBeforeFlag)
                bezpath.Outline();
            bezpath.SetFillMode(FillModeAlternate);
            renderinggraphics->FillPath(&transsolidbrush, &bezpath);
        }

        if (flags & PtTransGradFillFlag)
        {
            GraphicsPath bezpath;
            RemakePath(&gppath, &bezpath, flags & PtBezierFlag);
            Matrix m;
            bezpath.Flatten(&m, flatness);
            INT count = bezpath.GetPointCount();
            if (flags & PtOutlineBeforeFlag)
                bezpath.Outline();
            bezpath.SetFillMode(FillModeAlternate);
            PathGradientBrush pathgradientbrush(&bezpath);
            Color *colors = new Color[count];
            for (int i=0; i<count; i++)
                colors[i] = (i/2 == (float)i/2) ? 0xffff0000 : 0x80000000;
            pathgradientbrush.SetCenterColor(0x00000000);
            pathgradientbrush.SetSurroundColors(colors, &count);
            renderinggraphics->FillPath(&pathgradientbrush, &bezpath);
            delete colors;
        }

        if (!(flags & PtHatchBrushFlag))
        {
            SolidBrush pathbrush(Color(0xffc0c0ff));
            renderinggraphics->FillPath(&pathbrush, &widepath);
        }
        else
        {
            HatchBrush pathbrush(HatchStyleDiagonalBrick, Color(0xff000000), Color(0xffc0c0ff));
            renderinggraphics->FillPath(&pathbrush, &widepath);
        }

        Pen blackpen(Color(0xff000000), 2);
        blackpen.SetLineJoin(LineJoinMiter);
        renderinggraphics->DrawPath(&blackpen, &widepath);

        renderinggraphics->ResetClip();

        SolidBrush solidbrush(0xff0000ff);
        Pen pathpen(&solidbrush);
        pathpen.SetLineJoin(LineJoinRound);
        if (!(flags & PtDashPatternFlag))
        {
            pathpen.SetWidth(6);
        }
        else
        {
            pathpen.SetWidth(8);
            pathpen.SetDashStyle(DashStyleDot);
            pathpen.SetDashCap(DashCapRound);
            REAL distances[6] = {1.0f, 1.0f, 3.0f, 3.5f, 7.0f, 9.0f};
            pathpen.SetDashPattern(distances,6);
        }
        renderinggraphics->DrawPath(&pathpen, &gppath);

        PointF *points = new PointF[gppath.GetPointCount()];
        gppath.GetPathPoints(points, gppath.GetPointCount());
        for (INT i=0; i<gppath.GetPointCount(); i++)
        {
            SolidBrush bluebrush(Color(0xff0000ff));
            RectF rect((float)points[i].X-4, (float)points[i].Y-4, 8, 8);
            renderinggraphics->FillEllipse(&bluebrush, rect);
        }
        delete points;
    }

    if (clippath.GetPointCount() > 2)
    {
        Pen clippen(Color(0xffff0000), 4);
        clippen.SetDashStyle(DashStyleDot);
        clippen.SetLineJoin(LineJoinRound);
        renderinggraphics->DrawPath(&clippen, &clippath);
    }

    SolidBrush darkbluebrush(Color(0xff0000c0));
    if (lastpoint.X != -1 && lastpoint.Y != -1)
    {
        RectF rect(lastpoint.X-6, lastpoint.Y-6, 12, 12);
        renderinggraphics->FillEllipse(&darkbluebrush, rect);
    }

    delete renderinggraphics;

    if (phdc == NULL)
    {
        HDC hdc = GetDC(hwnd);
        Graphics *g = new Graphics(hdc);
        PAINTSTRUCT paintstruct;
        BeginPaint(hwnd, &paintstruct);
        g->DrawImage(offscreenbitmap, 0, 0);
        EndPaint(hwnd, &paintstruct);
        ReleaseDC(hwnd, hdc);
        delete g;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\debug.h ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   debug.h
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

#define ASSERT(cond) { if (!(cond)) DebugBreak(); }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define ASSERT(cond)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\pathtest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#include "resource.h"

enum PtFlag {
    PtNoFlag = 0,
    PtBezierFlag = 1,
    PtOutlineBeforeFlag = 2,
    PtOutlineAfterFlag = 4,
    PtDashPatternFlag = 8,
    PtHatchBrushFlag = 16,
    PtTextureFillFlag = 32,
    PtTransSolidFillFlag = 64,
    PtTransGradFillFlag = 128,
    PTBackgroundGradFillFlag = 256,
};


void DrawPath(HWND hwnd, HDC *phdc, HANDLE *hprinter, float flatness, PtFlag flags);
void AddPoint(INT x, INT y);
void OpenPath(char *filename);
void SavePath(char *filename);
void ChangeTexture(const WCHAR *filename);
void SetColorMode(INT colorMode);
void ClosePath();
void ClearPath();
void ClipPath(BOOL bezmode);
void ClearClipPath();
void Resize(INT x, INT y);
void CleanUp();
void Print(HWND hwnd, float flatness, PtFlag flags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perfdraw.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   perfdraw.cpp
*
* Abstract:
*
*   Contains all the tests for any routines that 'Draw'.
*
\**************************************************************************/

#include "perftest.h"

// Global array for holding line vertices:

Point SweepLines[2000];

int Initialize_256_Pixel_Sweep_Lines()
{
    int c = 0;
    int i;

    for (i = 0; i < 510; i += 4)
    {
        SweepLines[c].X = 255;
        SweepLines[c].Y = 255;
        c++;
        SweepLines[c].X = i;
        SweepLines[c].Y = 0;
        c++;
    }
    for (i = 0; i < 510; i += 4)
    {
        SweepLines[c].X = 255;
        SweepLines[c].Y = 255;
        c++;
        SweepLines[c].X = 510;
        SweepLines[c].Y = i;
        c++;
    }
    for (i = 0; i < 510; i += 4)
    {
        SweepLines[c].X = 255;
        SweepLines[c].Y = 255;
        c++;
        SweepLines[c].X = 510 - i;
        SweepLines[c].Y = 510;
        c++;
    }
    for (i = 0; i < 510; i += 4)
    {
        SweepLines[c].X = 255;
        SweepLines[c].Y = 255;
        c++;
        SweepLines[c].X = 0;
        SweepLines[c].Y = 510 - i;
        c++;
    }

    return(c / 2);
}

float Draw_Lines_PerPixel_Nominal_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    int lines = Initialize_256_Pixel_Sweep_Lines();

    if (g)
    {
        Pen pen(Color::Red, 1);
    
        StartTimer();
    
        do {
            for (i = 0; i < lines; i++)
            {
                g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                                  SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
            }
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        POINT points[2000];

        for (i = 0; i < lines * 2 + 1; i++)
        {
            points[i].x = SweepLines[i].X;
            points[i].y = SweepLines[i].Y;
        }

        HPEN hpen = CreatePen(PS_SOLID, 1, RGB(0xff, 0, 0));
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        StartTimer();

        do {
            for (i = 0; i < lines; i++)
            {
                Polyline(hdc, &points[i*2], 2);
            }

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
    }

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Nominal_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    if (!g) return(0);          // There is no GDI equivalent

    int lines = Initialize_256_Pixel_Sweep_Lines();

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    Pen pen(Color::Red, 1);

    StartTimer();

    do {
        for (i = 0; i < lines; i++)
        {
            g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                              SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
        }

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Nominal_Solid_Opaque_Antialiased_Quality(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    if (!g) return(0);          // There is no GDI equivalent

    int lines = Initialize_256_Pixel_Sweep_Lines();

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    g->SetCompositingQuality(CompositingQualityHighQuality);

    Pen pen(Color::Red, 1);

    StartTimer();

    do {
        for (i = 0; i < lines; i++)
        {
            g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                              SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
        }

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Wide_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    int lines = Initialize_256_Pixel_Sweep_Lines();

    if (g)
    {
        Pen pen(Color::Red, 2);
    
        StartTimer();
    
        do {
            for (i = 0; i < lines; i++)
            {
                g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                                  SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
            }
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        POINT points[2000];

        for (i = 0; i < lines * 2 + 1; i++)
        {
            points[i].x = SweepLines[i].X;
            points[i].y = SweepLines[i].Y;
        }

        HPEN hpen = CreatePen(PS_SOLID, 2, RGB(0xff, 0, 0));
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        StartTimer();

        do {
            for (i = 0; i < lines; i++)
            {
                Polyline(hdc, &points[i*2], 2);
            }

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
    }

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Wide_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    int lines = Initialize_256_Pixel_Sweep_Lines();

    Pen pen(Color::Red, 2);

    StartTimer();

    do {
        for (i = 0; i < lines; i++)
        {
            g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                              SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
        }

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerPixel_Wide_Solid_Opaque_Antialiased_Quality(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    int i;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    g->SetCompositingQuality(CompositingQualityHighQuality);

    int lines = Initialize_256_Pixel_Sweep_Lines();

    Pen pen(Color::Red, 2);

    StartTimer();

    do {
        for (i = 0; i < lines; i++)
        {
            g->DrawLine(&pen, SweepLines[i*2].X, SweepLines[i*2].Y, 
                              SweepLines[i*2+1].X, SweepLines[i*2+1].Y);
        }

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 256 * lines * iterations;

    return(pixels / seconds / KILO);        // Kilo-pixels per second
}

float Draw_Lines_PerLine_Nominal_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 1);
            g->DrawLine(&pen, 255, 255, 256, 256);  // 2 pixels long
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();

        do {
            POINT points[] = { 255, 255, 256, 256 };

            HPEN hpen = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Polyline(hdc, points, 2);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);    // Kilo-lines per second
}

float Draw_Lines_PerLine_Nominal_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    StartTimer();

    do {
        Pen pen(Color::Red, 1);
        g->DrawLine(&pen, 255, 255, 256, 256);  // 2 pixels long

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);    // Kilo-lines per second
}

float Draw_Lines_PerLine_Wide_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 2);
            g->DrawLine(&pen, 255, 255, 256, 256);  // 2 pixels long
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();
    
        do {
            POINT points[] = { 255, 255, 256, 256 };

            HPEN hpen = CreatePen(PS_SOLID, 2, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Polyline(hdc, points, 2);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);    // Kilo-lines per second
}

float Draw_Lines_PerLine_Wide_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    StartTimer();

    do {
        Pen pen(Color::Red, 2);
        g->DrawLine(&pen, 255, 255, 256, 256);  // 2 pixels long

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);    // Kilo-lines per second
}

float Draw_Ellipse_PerCall_Big_Nominal_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 0.1f);
            g->DrawEllipse(&pen, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();

        do {
            HPEN hpen = CreatePen(PS_SOLID, 0, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Ellipse(hdc, 0, 0, 512, 512);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Draw_Ellipse_PerCall_Big_WideLine_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 5);
            g->DrawEllipse(&pen, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();
    
        do {
            HPEN hpen = CreatePen(PS_SOLID, 5, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Ellipse(hdc, 0, 0, 512, 512);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Draw_Ellipse_PerCall_Small_Nominal_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();
    
        do {
            Pen pen(Color::Red, 0.1f);
            g->DrawEllipse(&pen, 64, 64, 64, 64);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();
    
        do {
            HPEN hpen = CreatePen(PS_SOLID, 0, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Ellipse(hdc, 64, 64, 128, 128);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Draw_Ellipse_PerCall_Small_WideLine_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            Pen pen(Color::Red, 5);
            g->DrawEllipse(&pen, 64, 64, 64, 64);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hbrush = GetStockObject(NULL_BRUSH);
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        StartTimer();
    
        do {
            HPEN hpen = CreatePen(PS_SOLID, 5, RGB(255, 0, 0));
            HGDIOBJ oldPen = SelectObject(hdc, hpen);

            Ellipse(hdc, 64, 64, 128, 128);

            SelectObject(hdc, oldPen);
            DeleteObject(hpen);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Draw_Pie_PerCall_Nominal(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    StartTimer();

    do {
        Pen pen(Color::Red, 0.1f);
        g->DrawPie(&pen, 0, 0, 512, 512, 90, 120);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test DrawTests[] = 
{
    T(1000, 1, Draw_Lines_PerPixel_Nominal_Solid_Opaque_Aliased                        , "Kpixels/s"),
    T(1001, 1, Draw_Lines_PerPixel_Nominal_Solid_Opaque_Antialiased                    , "Kpixels/s"),
    T(1002, 1, Draw_Lines_PerPixel_Wide_Solid_Opaque_Aliased                           , "Kpixels/s"),
    T(1003, 1, Draw_Lines_PerPixel_Wide_Solid_Opaque_Antialiased                       , "Kpixels/s"),
    T(1004, 1, Draw_Lines_PerLine_Nominal_Solid_Opaque_Aliased                         , "Klines/s"),
    T(1005, 1, Draw_Lines_PerLine_Nominal_Solid_Opaque_Antialiased                     , "Klines/s"),
    T(1006, 1, Draw_Lines_PerLine_Wide_Solid_Opaque_Aliased                            , "Klines/s"),
    T(1007, 1, Draw_Lines_PerLine_Wide_Solid_Opaque_Antialiased                        , "Klines/s"),
    T(1008, 1, Draw_Ellipse_PerCall_Big_Nominal_Aliased                                , "Kcalls/s"),
    T(1009, 1, Draw_Ellipse_PerCall_Big_WideLine_Aliased                               , "Kcalls/s"),
    T(1010, 1, Draw_Pie_PerCall_Nominal                                                , "Kcalls/s"),
    T(1011, 1, Draw_Ellipse_PerCall_Small_Nominal_Aliased                              , "Kcalls/s"),
    T(1012, 1, Draw_Ellipse_PerCall_Small_WideLine_Aliased                             , "Kcalls/s"),
    T(1013, 1, Draw_Lines_PerPixel_Nominal_Solid_Opaque_Antialiased_Quality            , "Kpixels/s"),
    T(1014, 1, Draw_Lines_PerPixel_Wide_Solid_Opaque_Antialiased_Quality               , "Kpixels/s"),
};

INT DrawTests_Count = sizeof(DrawTests) / sizeof(DrawTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perfimage.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   perfimage.cpp
*
* Abstract:
*
*   Contains all the tests for any routines that do imaging functionality.
*
\**************************************************************************/

#include "perftest.h"

float Image_Draw_PerPixel_Identity_NoDestinationRectangle(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerPixel_Identity(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Identity(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_CachedBitmap(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    CachedBitmap *cb = new CachedBitmap(&bitmap, g);

    StartTimer();

    do {
        g->DrawCachedBitmap(cb, 0, 0);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    delete cb;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_CachedBitmap(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    CachedBitmap *cb = new CachedBitmap(&bitmap, g);

    StartTimer();

    do {
        g->DrawCachedBitmap(cb, 0, 0);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    delete cb;

    return(iterations / seconds / KILO);           // Kilo-calls per second
}


float Image_Draw_PerPixel_HighQualityBilinear_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeHighQualityBilinear);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_HighQualityBilinear_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeHighQualityBilinear);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_HighQualityBicubic_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeHighQualityBicubic);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_HighQualityBicubic_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeHighQualityBicubic);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}


float Image_Draw_PerPixel_Bilinear_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBilinear);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Bilinear_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBilinear);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_Bilinear_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBilinear);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Bilinear_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBilinear);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_Bicubic_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBicubic);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Bicubic_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBicubic);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_Bicubic_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBicubic);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Bicubic_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeBicubic);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}


// Nearest Neighbor routines
float Image_Draw_PerPixel_NearestNeighbor_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeNearestNeighbor);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_NearestNeighbor_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeNearestNeighbor);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 0, 0, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Image_Draw_PerPixel_NearestNeighbor_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeNearestNeighbor);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_NearestNeighbor_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetInterpolationMode(InterpolationModeNearestNeighbor);
    g->RotateTransform(0.2f);

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        g->DrawImage(&bitmap, 10, 10, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}



float Image_Draw_PerPixel_Identity_Recolored_Matrix(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(512, 512, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 512, 512);

    StartTimer();

    do {
        ImageAttributes imageAttributes;
        ColorMatrix colorMatrix = { .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                       0,    0,    0, 1, 0,
                                     .1f,  .1f,  .1f, 0, 1 };  // Gray it

        imageAttributes.SetColorMatrix(&colorMatrix);

        g->DrawImage(&bitmap, RectF(0, 0, 512, 512), 0, 0, 512, 512, 
                     UNITPIXEL, &imageAttributes);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Image_Draw_PerCall_Identity_Recolored_Matrix(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(1, 1, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 1, 1);

    StartTimer();

    do {
        ImageAttributes imageAttributes;
        ColorMatrix colorMatrix = { .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                       0,    0,    0, 1, 0,
                                     .1f,  .1f,  .1f, 0, 1 };  // Gray it

        imageAttributes.SetColorMatrix(&colorMatrix);

        g->DrawImage(&bitmap, RectF(0, 0, 1, 1), 0, 0, 1, 1, 
                     UNITPIXEL, &imageAttributes);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);
}

float Image_Draw_PerPixel_Scaled_2x_Recolored_Matrix(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap source(L"winnt256.bmp");
    Bitmap bitmap(256, 256, g);

    Graphics gBitmap(&bitmap);
    gBitmap.DrawImage(&source, 0, 0, 256, 256);

    StartTimer();

    do {
        ImageAttributes imageAttributes;
        ColorMatrix colorMatrix = { .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                    .25f, .25f, .25f, 0, 0,
                                       0,    0,    0, 1, 0,
                                     .1f,  .1f,  .1f, 0, 1 };  // Gray it

        imageAttributes.SetColorMatrix(&colorMatrix);

        g->DrawImage(&bitmap, RectF(0, 0, 512, 512), 0, 0, 256, 256, 
                     UNITPIXEL, &imageAttributes);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test ImageTests[] = 
{
    T(2000, 1, Image_Draw_PerPixel_Identity                                            , "Mpixels/s"),
    T(2001, 1, Image_Draw_PerCall_Identity                                             , "Kcalls/s"),
    T(2002, 1, Image_Draw_PerPixel_Bilinear_Scaled                                     , "Mpixels/s"),
    T(2003, 1, Image_Draw_PerCall_Bilinear_Scaled                                      , "Kcalls/s"),
    T(2004, 1, Image_Draw_PerPixel_Bilinear_Rotated                                    , "Mpixels/s"),
    T(2005, 1, Image_Draw_PerCall_Bilinear_Rotated                                     , "Kcalls/s"),
    T(2006, 1, Image_Draw_PerPixel_Bicubic_Scaled                                      , "Mpixels/s"),
    T(2007, 1, Image_Draw_PerCall_Bicubic_Scaled                                       , "Kcalls/s"),
    T(2008, 1, Image_Draw_PerPixel_Bicubic_Rotated                                     , "Mpixels/s"),
    T(2009, 1, Image_Draw_PerCall_Bicubic_Rotated                                      , "Kcalls/s"),
    T(2010, 1, Image_Draw_PerPixel_Identity_NoDestinationRectangle                     , "Mpixels/s"),
    T(2011, 1, Image_Draw_PerPixel_Identity_Recolored_Matrix                           , "Mpixels/s"),
    T(2012, 1, Image_Draw_PerPixel_Scaled_2x_Recolored_Matrix                          , "Mpixels/s"),
    T(2013, 1, Image_Draw_PerCall_Identity_Recolored_Matrix                            , "Kcalls/s"),
    T(2014, 1, Image_Draw_PerPixel_NearestNeighbor_Scaled                              , "Mpixels/s"),
    T(2015, 1, Image_Draw_PerCall_NearestNeighbor_Scaled                               , "Kcalls/s"),
    T(2016, 1, Image_Draw_PerPixel_NearestNeighbor_Rotated                             , "Mpixels/s"),
    T(2017, 1, Image_Draw_PerCall_NearestNeighbor_Rotated                              , "Kcalls/s"),
    T(2018, 1, Image_Draw_PerPixel_HighQualityBilinear_Scaled                          , "Mpixels/s"),
    T(2019, 1, Image_Draw_PerCall_HighQualityBilinear_Scaled                           , "Kcalls/s"),    
    T(2020, 1, Image_Draw_PerPixel_HighQualityBicubic_Scaled                           , "Mpixels/s"),
    T(2021, 1, Image_Draw_PerCall_HighQualityBicubic_Scaled                            , "Kcalls/s"),    
    T(2022, 1, Image_Draw_PerPixel_CachedBitmap                                        , "Mpixels/s"),
    T(2023, 1, Image_Draw_PerCall_CachedBitmap                                         , "Kcalls/s"),    
};

INT ImageTests_Count = sizeof(ImageTests) / sizeof(ImageTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perffill.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   perffill.cpp
*
* Abstract:
*
*   Contains all the tests for any routines that 'Fill'.
*
\**************************************************************************/

#include "perftest.h"

float Fill_Ellipse_PerCall_Big_Solid(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            SolidBrush brush(Color::Red);
            g->FillEllipse(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hpen = GetStockObject(NULL_PEN);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        StartTimer();
    
        do {
            HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
            HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

            Ellipse(hdc, 0, 0, 512, 512);

            SelectObject(hdc, oldBrush);
            DeleteObject(hbrush);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
        DeleteObject(hpen);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Ellipse_PerCall_Small_Solid(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        StartTimer();
    
        do {
            SolidBrush brush(Color::Red);
            g->FillEllipse(&brush, 64, 64, 64, 64);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HGDIOBJ hpen = GetStockObject(NULL_PEN);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        StartTimer();
    
        do {
            HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
            HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

            Ellipse(hdc, 64, 64, 128, 128);

            SelectObject(hdc, oldBrush);
            DeleteObject(hbrush);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
        DeleteObject(hpen);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    SolidBrush brush(Color::Red);

    StartTimer();

    do {
        g->FillRectangle(&brush, 10, 10, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerPixel_Solid_Opaque_Antialiased_Integer(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    SolidBrush brush(Color::Red);

    StartTimer();

    do {
        g->FillRectangle(&brush, 10, 10, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerPixel_Solid_Opaque_Antialiased_HalfInteger(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    SolidBrush brush(Color::Red);

    StartTimer();

    do {
        g->FillRectangle(&brush, 10.5f, 10.5f, 512.0f, 512.0f);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        StartTimer();
    
        do {
            SolidBrush brush(Color::Red);
    
            g->FillRectangle(&brush, 20, 20, 1, 1);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();
    
        do {
            RECT rect = { 20, 20, 21, 21 };

            HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));

            FillRect(hdc, &rect, hbrush);

            DeleteObject(hbrush);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g)
    {
        SolidBrush brush(Color::Red);
        PointF points[] = { PointF(0, 0), PointF(512, 0), 
                            PointF(513, 512), PointF(1, 512) };
    
        StartTimer();
    
        do {
            g->FillPolygon(&brush, points, 4);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
        HGDIOBJ hpen = GetStockObject(NULL_PEN);

        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        POINT points[] = { 0, 0, 512, 0, 513, 512, 1, 512 };

        StartTimer();

        do {
            Polygon(hdc, points, 4);

        } while (!EndTimer());

        GdiFlush();

        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        SelectObject(hdc, oldPen);

        DeleteObject(hbrush);
        DeleteObject(hpen);
    }

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_CompatibleDIB(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    HDC screenDc = gScreen->GetHDC();
    HBITMAP bitmap = CreateCompatibleDIB2(screenDc, 520, 520);
    HDC dc = CreateCompatibleDC(screenDc);
    SelectObject(dc, bitmap);
    Graphics g(dc);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    BitBlt(screenDc, 0, 0, 520, 520, dc, 0, 0, SRCCOPY);

    gScreen->ReleaseHDC(screenDc);
    DeleteObject(dc);
    DeleteObject(bitmap);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_15bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat16bppRGB555);
    Graphics g(&bitmap);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_16bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat16bppRGB565);
    Graphics g(&bitmap);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_24bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat24bppRGB);
    Graphics g(&bitmap);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_32bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat32bppRGB);
    Graphics g(&bitmap);

    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Quality(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetCompositingQuality(CompositingQualityHighQuality);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_CompatibleDIB(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    HDC screenDc = gScreen->GetHDC();
    HBITMAP bitmap = CreateCompatibleDIB2(screenDc, 520, 520);
    HDC dc = CreateCompatibleDC(screenDc);
    SelectObject(dc, bitmap);
    Graphics g(dc);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    BitBlt(screenDc, 0, 0, 520, 520, dc, 0, 0, SRCCOPY);

    gScreen->ReleaseHDC(screenDc);
    DeleteObject(dc);
    DeleteObject(bitmap);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_15bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat16bppRGB555);
    Graphics g(&bitmap);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_16bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat16bppRGB565);
    Graphics g(&bitmap);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_24bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat24bppRGB);
    Graphics g(&bitmap);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_32bpp(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);          // There is no GDI equivalent

    // Note that this doesn't use the passed-in 'Graphics' at all in the
    // timing.

    Bitmap bitmap(520, 520, PixelFormat32bppRGB);
    Graphics g(&bitmap);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));
    PointF points[] = { PointF(0, 0), PointF(512, 0), 
                        PointF(513, 512), PointF(1, 512) };

    StartTimer();

    do {
        g.FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g.Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    gScreen->DrawImage(&bitmap, 0, 0);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerCall_Solid_Opaque_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        StartTimer();
    
        do {
            SolidBrush brush(Color::Red);
            PointF points[] = { PointF(20, 20), PointF(21, 20), 
                                PointF(21, 21), PointF(20, 21) };
    
            g->FillPolygon(&brush, points, 4);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();

        HGDIOBJ hpen = GetStockObject(NULL_PEN);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        do {
            HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
            HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

            POINT points[] = { 20, 20, 21, 20, 21, 21, 20, 21 };

            Polygon(hdc, points, 4);

            SelectObject(hdc, oldBrush);
            DeleteObject(hbrush);

        } while (!EndTimer());

        GdiFlush();

        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldPen);
        DeleteObject(hpen);
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Trapezoid_PerPixel_Texture_Identity_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);  // No GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Texture_Scaled_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);  // No GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    Matrix matrix(0.5, 0, 0, 0.5, 0, 0);
    brush.SetTransform(&matrix);

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Antialiased_Quality(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    g->SetCompositingQuality(CompositingQualityHighQuality);
    
    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerPixel_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    SolidBrush brush(Color::Red);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerCall_Solid_Opaque_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    StartTimer();

    do {
        SolidBrush brush(Color::Red);
        PointF points[] = { PointF(20, 20), PointF(21, 20), 
                            PointF(21, 21), PointF(20, 21) };

        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Trapezoid_PerPixel_Solid_Transparent_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);
    
    Color color(0x80, 0x80, 0, 0);
    SolidBrush brush(color);
    PointF points[] = { PointF(10, 10), PointF(522, 10), 
                        PointF(523, 522), PointF(11, 522) };

    StartTimer();

    do {
        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Trapezoid_PerCall_Solid_Transparent_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    StartTimer();

    do {
        Color color(0x80, 0x80, 0, 0);
        SolidBrush brush(color);
        PointF points[] = { PointF(20, 20), PointF(21, 20), 
                            PointF(21, 21), PointF(20, 21) };

        g->FillPolygon(&brush, points, 4);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Hatch_Opaque(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        HatchBrush brush(HatchStyleDiagonalCross, Color::Red, Color::Black);
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HBRUSH hbrush = CreateHatchBrush(HS_DIAGCROSS, RGB(0xff, 0, 0));
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);
    
        StartTimer();
    
        do {
            PatBlt(hdc, 0, 0, 512, 512, PATCOPY);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerPixel_Hatch_Transparent(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        HatchBrush brush(HatchStyleDiagonalCross, Color::Red, Color(0, 0, 0, 0));
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HBRUSH hbrush = CreateHatchBrush(HS_DIAGCROSS, RGB(0xff, 0, 0));
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        SetBkMode(hdc, TRANSPARENT);
    
        StartTimer();
    
        do {
            PatBlt(hdc, 0, 0, 512, 512, PATCOPY);
    
        } while (!EndTimer());
    
        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);
    }

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Hatch(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    StartTimer();

    do {
        HatchBrush brush(HatchStyleForwardDiagonal, Color::Red, Color::Black);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Texture_Big(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerPixel_Texture_Small(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Bitmap bitmap(L"winnt256.bmp");
    Bitmap texture(32, 32, PixelFormat32bppRGB);
    Graphics gTexture(&texture);
    gTexture.DrawImage(&bitmap, Rect(0, 0, 32, 32));

    TextureBrush brush(&texture);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Texture(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    StartTimer();

    do {
        Bitmap bitmap(L"winnt256.bmp");
        TextureBrush brush(&bitmap);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Texture_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Matrix matrix(0.5, 0, 0, 0.5, 0, 0);

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);
    brush.SetTransform(&matrix);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Texture_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Matrix matrix(0.5, 0, 0, 0.5, 0, 0);

    StartTimer();

    do {
        Bitmap bitmap(L"winnt256.bmp");
        TextureBrush brush(&bitmap);
        brush.SetTransform(&matrix);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_Texture_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Matrix matrix(0.707f, 0.707f, -0.707f, 0.707f, 0, 0);

    Bitmap bitmap(L"winnt256.bmp");
    TextureBrush brush(&bitmap);
    brush.SetTransform(&matrix);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_Texture_Rotated(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    Matrix matrix(0.707f, 0.707f, -0.707f, 0.707f, 0, 0);

    StartTimer();

    do {
        Bitmap bitmap(L"winnt256.bmp");
        TextureBrush brush(&bitmap);
        brush.SetTransform(&matrix);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

#if !USE_NEW_APIS
    
    float Fill_Rectangle_PerPixel_RectangleGradient(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    
        RectangleGradientBrush brush(RectF(0, 0, 512, 512), colors, WrapModeClamp);
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        UINT pixels = 512 * 512 * iterations;
    
        return(pixels / seconds / MEGA);        // Mega-pixels per second
    }
    
    float Fill_Rectangle_PerCall_RectangleGradient(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    
        StartTimer();
    
        do {
            RectangleGradientBrush brush(RectF(0, 0, 512, 512), colors, WrapModeClamp);
    
            g->FillRectangle(&brush, 20, 20, 1, 1);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        return(iterations / seconds / KILO);           // Kilo-calls per second
    }
    
    float Fill_Rectangle_PerPixel_RectangleGradient_BlendFactors(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
        REAL blendFactors[] = { 0.0f, 0.0168160f, 0.0333130f, 0.0844290f, 0.139409f,
                                0.210211f, 0.295801f, 0.393017f, 0.5f, 0.606983f,
                                1.0f };
        REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                                  0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                                  1.0f };
    
        RectangleGradientBrush brush(RectF(0, 0, 512, 512), colors, WrapModeClamp);
        brush.SetHorizontalBlend(blendFactors, blendPositions, 11);
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        UINT pixels = 512 * 512 * iterations;
    
        return(pixels / seconds / MEGA);        // Mega-pixels per second
    }
    
    float Fill_Rectangle_PerCall_RectangleGradient_BlendFactors(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
        REAL blendFactors[] = { 0.0f, 0.0168160f, 0.0333130f, 0.0844290f, 0.139409f,
                                0.210211f, 0.295801f, 0.393017f, 0.5f, 0.606983f,
                                1.0f };
        REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                                  0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                                  1.0f };
    
        StartTimer();
    
        do {
            RectangleGradientBrush brush(RectF(0, 0, 512, 512), colors, WrapModeClamp);
            brush.SetHorizontalBlend(blendFactors, blendPositions, 11);
    
            g->FillRectangle(&brush, 20, 20, 1, 1);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        return(iterations / seconds / KILO);           // Kilo-calls per second
    }
    
    float Fill_Rectangle_PerPixel_RadialGradient(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        RadialGradientBrush brush(RectF(0, 0, 512, 512), Color::Black, Color::Red, WrapModeTile);
    
        StartTimer();
    
        do {
            g->FillRectangle(&brush, 0, 0, 512, 512);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        UINT pixels = 512 * 512 * iterations;
    
        return(pixels / seconds / MEGA);        // Mega-pixels per second
    }
    
    float Fill_Rectangle_PerCall_RadialGradient(Graphics *g, HDC hdc)
    {
        UINT iterations;
        float seconds;
    
        if (!g) return(0);          // There is no GDI equivalent
    
        StartTimer();
    
        do {
            RadialGradientBrush brush(RectF(0, 0, 512, 512), Color::Black, Color::Red, WrapModeTile);
    
            g->FillRectangle(&brush, 20, 20, 1, 1);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    
        return(iterations / seconds / KILO);           // Kilo-calls per second
    }

#endif

float Fill_Rectangle_PerPixel_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    // LinearGradientBrush brush(PointF(128, 128), PointF(256, 256), 
    //                         Color::Red, Color::Black, WrapModeTileFlipX);

    LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    StartTimer();

    do {
        LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_LinearGradient_PresetColors(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    INT i;

    if (!g) return(0);          // There is no GDI equivalent

    Color colors[12];
    REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                              0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                              1.0f };
    for (i = 0; i < 12; i += 2)
    {
        colors[i] = Color::Red;
        colors[i + 1] = Color::Black;
    }

    LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);
    brush.SetInterpolationColors(colors, blendPositions, 11);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_LinearGradient_PresetColors(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;
    INT i;

    if (!g) return(0);          // There is no GDI equivalent

    Color colors[12];
    REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                              0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                              1.0f };
    for (i = 0; i < 12; i += 2)
    {
        colors[i] = Color::Red;
        colors[i + 1] = Color::Black;
    }

    StartTimer();

    do {
        LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);
        brush.SetInterpolationColors(colors, blendPositions, 11);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_LinearGradient_BlendFactors(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    REAL blendFactors[] = { 0.0f, 0.0168160f, 0.0333130f, 0.0844290f, 0.139409f,
                            0.210211f, 0.295801f, 0.393017f, 0.5f, 0.606983f,
                            1.0f };
    REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                              0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                              1.0f };

    LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);
    brush.SetBlend(blendFactors, blendPositions, 11);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_LinearGradient_BlendFactors(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    REAL blendFactors[] = { 0.0f, 0.0168160f, 0.0333130f, 0.0844290f, 0.139409f,
                            0.210211f, 0.295801f, 0.393017f, 0.5f, 0.606983f,
                            1.0f };
    REAL blendPositions[] = { 0.0f, 0.0625f, 0.125f, 0.1875f, 0.25f,
                              0.3125f, 0.375f, 0.4375f, 0.5f, 0.5625f, 
                              1.0f };

    StartTimer();

    do {
        LinearGradientBrush brush(PointF(0, 0), PointF(512, 512), Color::Red, Color::Black);
        brush.SetBlend(blendFactors, blendPositions, 11);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Red, Color::Red, Color::Red };
    INT count = 4;

    PathGradientBrush brush(points, 4);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Red, Color::Red, Color::Red };
    INT count = 4;

    StartTimer();

    do {
        PathGradientBrush brush(points, 4);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_LotsaTriangles(Graphics *g, HDC hdc)
{
    UINT iterations;
    INT count;
    INT i;
    float seconds;
    float pi;
    float angle;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[50];
    Color colors[50];

    pi = static_cast<float>(acos(-1.0f));

    for (angle = 0, count = 0; angle < 2*pi; angle += (pi / 20), count++)
    {
        points[count].X = 256 + 512 * static_cast<float>(cos(angle));
        points[count].Y = 256 + 512 * static_cast<float>(sin(angle));
    }

    for (i = 0; i < count; i++)
    {
        colors[i] = Color::Red;
    }

    PathGradientBrush brush(points, count);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient_LotsaTriangles(Graphics *g, HDC hdc)
{
    UINT iterations;
    INT count;
    INT i;
    float seconds;
    float pi;
    float angle;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[50];
    Color colors[50];

    pi = static_cast<float>(acos(-1.0f));

    for (angle = 0, count = 0; angle < 2*pi; angle += (pi / 20), count++)
    {
        points[count].X = 256 + 512 * static_cast<float>(cos(angle));
        points[count].Y = 256 + 512 * static_cast<float>(sin(angle));
    }

    for (i = 0; i < count; i++)
    {
        colors[i] = Color::Red;
    }

    StartTimer();

    do {
        PathGradientBrush brush(points, count);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Red, Color::Red, Color::Red };
    INT count = 4;

    PathGradientBrush brush(points, 4);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);
    brush.SetFocusScales(0.2f, 0.2f);
    brush.SetCenterPoint(PointF(200, 200));

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Red, Color::Red, Color::Red };
    INT count = 4;

    StartTimer();

    do {
        PathGradientBrush brush(points, 4);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);
        brush.SetFocusScales(0.2f, 0.2f);
        brush.SetCenterPoint(PointF(200, 200));

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_Multicolored(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    INT count = 4;

    PathGradientBrush brush(points, 4);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient_Multicolored(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    INT count = 4;

    StartTimer();

    do {
        PathGradientBrush brush(points, 4);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_Multicolored_LotsaTriangles(Graphics *g, HDC hdc)
{
    UINT iterations;
    INT count;
    INT i;
    float seconds;
    float pi;
    float angle;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[50];
    Color colors[50];

    pi = static_cast<float>(acos(-1.0f));

    // Create 40 points:

    for (angle = 0, count = 0; angle < 2*pi; angle += (pi / 20), count++)
    {
        points[count].X = 256 + 512 * static_cast<float>(cos(angle));
        points[count].Y = 256 + 512 * static_cast<float>(sin(angle));
    }

    for (i = 0; i < count; i += 2)
    {
        colors[i] = Color::Red;
        colors[i + 1] = Color::Blue;
    }

    PathGradientBrush brush(points, count);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PathGradient_Multicolored_LotsaTriangles(Graphics *g, HDC hdc)
{
    UINT iterations;
    INT count;
    INT i;
    float seconds;
    float pi;
    float angle;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[50];
    Color colors[50];

    pi = static_cast<float>(acos(-1.0f));

    // Create 40 points:

    for (angle = 0, count = 0; angle < 2*pi; angle += (pi / 20), count++)
    {
        points[count].X = 256 + 512 * static_cast<float>(cos(angle));
        points[count].Y = 256 + 512 * static_cast<float>(sin(angle));
    }

    for (i = 0; i < count; i += 2)
    {
        colors[i] = Color::Red;
        colors[i + 1] = Color::Blue;
    }

    StartTimer();

    do {
        PathGradientBrush brush(points, count);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Rectangle_PerPixel_PathGradient_Multicolored_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    INT count = 4;

    PathGradientBrush brush(points, 4);
    brush.SetCenterColor(Color::Black);
    brush.SetSurroundColors(colors, &count);
    brush.SetFocusScales(0.2f, 0.2f);
    brush.SetCenterPoint(PointF(200, 200));

    StartTimer();

    do {
        g->FillRectangle(&brush, 0, 0, 512, 512);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT pixels = 512 * 512 * iterations;

    return(pixels / seconds / MEGA);        // Mega-pixels per second
}

float Fill_Rectangle_PerCall_PathGradient_Multicolored_Scaled(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    PointF points[] = { PointF(0, 0), PointF(0, 512), PointF(512, 512), PointF(512, 0) };
    Color colors[] = { Color::Red, Color::Green, Color::Blue, Color::Black };
    INT count = 4;

    StartTimer();

    do {
        PathGradientBrush brush(points, 4);
        brush.SetCenterColor(Color::Black);
        brush.SetSurroundColors(colors, &count);
        brush.SetFocusScales(0.2f, 0.2f);
        brush.SetCenterPoint(PointF(200, 200));

        g->FillRectangle(&brush, 20, 20, 1, 1);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Path_PerCall_Solid_Complex_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    FontFamily family(L"Times New Roman");
    GraphicsPath path(FillModeWinding);

    PointF origin1(20, 20);
    path.AddString(L"GDI+", wcslen(L"GDI+"), &family, 0, 200,
                   origin1, NULL);

    PointF origin2(20, 220);
    path.AddString(L"Rocks!", wcslen(L"Rocks!"), &family, FontStyleItalic, 200,
                   origin2, NULL);

    if (g)
    {
        SolidBrush brush(Color::Silver);
    
        StartTimer();
    
        do {
            g->FillPath(&brush, &path);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        PathData pathData;
        INT i;

        INT count = path.GetPointCount();
        PointF *pointF = new PointF[count];
        BYTE *types = new BYTE[count];
        POINT *point = new POINT[count];

        // ACK - these should NOT be public!
        pathData.Points = pointF;
        pathData.Types = types;
        pathData.Count = count;

        path.GetPathData(&pathData);

        for (i = 0; i < count; i++)
        {
            point[i].x = (INT) (pointF[i].X + 0.5f);
            point[i].y = (INT) (pointF[i].Y + 0.5f);
        }

        for (i = 0; i < count; i++)
        {
            BYTE type = types[i] & PathPointTypePathTypeMask;

            if (type == PathPointTypeStart)
                type = PT_MOVETO;

            else if (type == PathPointTypeLine)
                type = PT_LINETO;

            else if (type == PathPointTypeBezier)
                type = PT_BEZIERTO;
            else
            {
                ASSERT(FALSE);
            }

            if (types[i] & PathPointTypeCloseSubpath)
                type |= PT_CLOSEFIGURE;

            types[i] = type;
        }

        HBRUSH hbrush = CreateSolidBrush(RGB(255, 0, 0));
        HGDIOBJ oldBrush = SelectObject(hdc, hbrush);

        HGDIOBJ hpen = GetStockObject(NULL_PEN);
        HGDIOBJ oldPen = SelectObject(hdc, hpen);

        BeginPath(hdc);
        PolyDraw(hdc, point, types, count);
        EndPath(hdc);

        StartTimer();
    
        do {
            SaveDC(hdc);
            FillPath(hdc);
            RestoreDC(hdc, -1);
    
        } while (!EndTimer());

        AbortPath(hdc);

        GdiFlush();
    
        GetTimer(&seconds, &iterations);

        SelectObject(hdc, oldBrush);
        DeleteObject(hbrush);

        SelectObject(hdc, oldPen);
        DeleteObject(hpen);

        // Clear these so that the PathData destructor doesn't cause trouble...
        pathData.Points = NULL;
        pathData.Types = NULL;
        pathData.Count = 0;

        delete[] pointF;
        delete[] types;
        delete[] point;
    }

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Path_PerCall_Solid_Complex_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    FontFamily family(L"Times New Roman");
    GraphicsPath path(FillModeWinding);

    PointF origin1(20, 20);
    path.AddString(L"GDI+", wcslen(L"GDI+"), &family, 0, 200,
                   origin1, NULL);

    PointF origin2(20, 220);
    path.AddString(L"Rocks!", wcslen(L"Rocks!"), &family, FontStyleItalic, 200,
                   origin2, NULL);

    SolidBrush brush(Color::Silver);

    StartTimer();

    do {
        g->FillPath(&brush, &path);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

float Fill_Path_PerCall_Solid_Complex_Antialiased_Transparent(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);          // There is no GDI equivalent

    g->SetSmoothingMode(SmoothingModeAntiAlias);

    FontFamily family(L"Times New Roman");
    GraphicsPath path(FillModeWinding);

    PointF origin1(20, 20);
    path.AddString(L"GDI+", wcslen(L"GDI+"), &family, 0, 200,
                   origin1, NULL);

    PointF origin2(20, 220);
    path.AddString(L"Rocks!", wcslen(L"Rocks!"), &family, FontStyleItalic, 200,
                   origin2, NULL);

    SolidBrush brush(Color(0x80, 0xff, 0, 0));

    StartTimer();

    do {
        g->FillPath(&brush, &path);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);           // Kilo-calls per second
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test FillTests[] = 
{
    T(3000, 1, Fill_Rectangle_PerPixel_Solid_Opaque_Aliased                            , "Mpixels/s"),
    T(3001, 1, Fill_Rectangle_PerCall_Solid_Opaque_Aliased                             , "Kcalls/s"),
    T(3002, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased                            , "Mpixels/s"),
    T(3003, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_CompatibleDIB              , "Mpixels/s"),
    T(3004, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_15bpp               , "Mpixels/s"),
    T(3005, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_16bpp               , "Mpixels/s"),
    T(3006, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_24bpp               , "Mpixels/s"),
    T(3007, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Aliased_Bitmap_32bpp               , "Mpixels/s"),
    T(3008, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased                       , "Mpixels/s"),
    T(3009, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Quality               , "Mpixels/s"),
    T(3010, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_CompatibleDIB         , "Mpixels/s"),
    T(3011, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_15bpp          , "Mpixels/s"),
    T(3012, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_16bpp          , "Mpixels/s"),
    T(3013, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_24bpp          , "Mpixels/s"),
    T(3014, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Aliased_Bitmap_32bpp          , "Mpixels/s"),
    T(3015, 1, Fill_Trapezoid_PerCall_Solid_Opaque_Aliased                             , "Kcalls/s"),
    T(3016, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Antialiased                        , "Mpixels/s"),
    T(3017, 1, Fill_Trapezoid_PerCall_Solid_Opaque_Antialiased                         , "Kcalls/s"),
    T(3018, 1, Fill_Trapezoid_PerPixel_Solid_Transparent_Antialiased                   , "Mpixels/s"),
    T(3019, 1, Fill_Trapezoid_PerCall_Solid_Transparent_Antialiased                    , "Kcalls/s"),
    T(3020, 1, Fill_Rectangle_PerPixel_Hatch_Opaque                                    , "Mpixels/s"),
    T(3021, 1, Fill_Rectangle_PerCall_Hatch                                            , "Kcalls/s"),
    T(3022, 1, Fill_Rectangle_PerPixel_Texture_Big                                     , "Mpixels/s"),
    T(3023, 1, Fill_Rectangle_PerCall_Texture                                          , "Kcalls/s"),
    T(3024, 1, Fill_Rectangle_PerPixel_Texture_Scaled                                  , "Mpixels/s"),
    T(3025, 1, Fill_Rectangle_PerCall_Texture_Scaled                                   , "Kcalls/s"),
    T(3026, 1, Fill_Rectangle_PerPixel_Texture_Rotated                                 , "Mpixels/s"),
    T(3027, 1, Fill_Rectangle_PerCall_Texture_Rotated                                  , "Kcalls/s"),
#if !USE_NEW_APIS
    T(3028, 1, Fill_Rectangle_PerPixel_RectangleGradient                               , "Mpixels/s"),
    T(3029, 1, Fill_Rectangle_PerCall_RectangleGradient                                , "Kcalls/s"),
    T(3030, 1, Fill_Rectangle_PerPixel_RectangleGradient_BlendFactors                  , "Mpixels/s"),
    T(3031, 1, Fill_Rectangle_PerCall_RectangleGradient_BlendFactors                   , "Kcalls/s"),
    T(3038, 1, Fill_Rectangle_PerPixel_RadialGradient                                  , "Mpixels/s"),
    T(3039, 1, Fill_Rectangle_PerCall_RadialGradient                                   , "Kcalls/s"),
#endif
    T(3032, 1, Fill_Rectangle_PerPixel_LinearGradient                                  , "Mpixels/s"),
    T(3033, 1, Fill_Rectangle_PerCall_LinearGradient                                   , "Kcalls/s"),
    T(3034, 1, Fill_Rectangle_PerPixel_LinearGradient_PresetColors                     , "Mpixels/s"),
    T(3035, 1, Fill_Rectangle_PerCall_LinearGradient_PresetColors                      , "Kcalls/s"),
    T(3036, 1, Fill_Rectangle_PerPixel_LinearGradient_BlendFactors                     , "Mpixels/s"),
    T(3037, 1, Fill_Rectangle_PerCall_LinearGradient_BlendFactors                      , "Kcalls/s"),
    T(3040, 1, Fill_Rectangle_PerPixel_PathGradient                                    , "Mpixels/s"),
    T(3041, 1, Fill_Rectangle_PerCall_PathGradient                                     , "Kcalls/s"),
    T(3042, 1, Fill_Rectangle_PerPixel_PathGradient_LotsaTriangles                     , "Mpixels/s"),
    T(3043, 1, Fill_Rectangle_PerCall_PathGradient_LotsaTriangles                      , "Kcalls/s"),
    T(3044, 1, Fill_Rectangle_PerPixel_PathGradient_Scaled                             , "Mpixels/s"),
    T(3045, 1, Fill_Rectangle_PerCall_PathGradient_Scaled                              , "Kcalls/s"),
    T(3046, 1, Fill_Rectangle_PerPixel_PathGradient_Multicolored                       , "Mpixels/s"),
    T(3047, 1, Fill_Rectangle_PerCall_PathGradient_Multicolored                        , "Kcalls/s"),
    T(3048, 1, Fill_Rectangle_PerPixel_PathGradient_Multicolored_LotsaTriangles        , "Mpixels/s"),
    T(3049, 1, Fill_Rectangle_PathGradient_Multicolored_LotsaTriangles                 , "Kcalls/s"),
    T(3050, 1, Fill_Rectangle_PerPixel_PathGradient_Multicolored_Scaled                , "Mpixels/s"),
    T(3051, 1, Fill_Rectangle_PerCall_PathGradient_Multicolored_Scaled                 , "Kcalls/s"),
    T(3052, 1, Fill_Trapezoid_PerPixel_Texture_Scaled_Opaque_Antialiased               , "Mpixels/s"),
    T(3053, 1, Fill_Trapezoid_PerPixel_Texture_Identity_Opaque_Antialiased             , "Mpixels/s"),
    T(3054, 1, Fill_Rectangle_PerPixel_Solid_Opaque_Antialiased_Integer                , "Mpixels/s"),
    T(3055, 1, Fill_Rectangle_PerPixel_Solid_Opaque_Antialiased_HalfInteger            , "Mpixels/s"),
    T(3056, 1, Fill_Rectangle_PerPixel_Hatch_Transparent                               , "Mpixels/s"),
    T(3057, 1, Fill_Ellipse_PerCall_Big_Solid                                          , "Mpixels/s"),
    T(3058, 1, Fill_Ellipse_PerCall_Small_Solid                                        , "Mpixels/s"),
    T(3059, 1, Fill_Rectangle_PerPixel_Texture_Small                                   , "Mpixels/s"),
    T(3060, 1, Fill_Path_PerCall_Solid_Complex_Aliased                                 , "Kcalls/s"),
    T(3061, 1, Fill_Path_PerCall_Solid_Complex_Antialiased                             , "Kcalls/s"),
    T(3062, 1, Fill_Path_PerCall_Solid_Complex_Antialiased_Transparent                 , "Kcalls/s"),
    T(3063, 1, Fill_Trapezoid_PerPixel_Solid_Opaque_Antialiased_Quality                , "Mpixels/s"),
};

INT FillTests_Count = sizeof(FillTests) / sizeof(FillTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perfother.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   perfother.cpp
*
* Abstract:
*
*   Contains all the tests for anything 'miscellaneous'.
*
\**************************************************************************/

#include "perftest.h"

float Other_Graphics_Create_FromHwnd_PerCall(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        StartTimer();
    
        do {
            Graphics g(ghwndMain);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        StartTimer();

        do {
            HDC hdc = GetDC(ghwndMain);
            ReleaseDC(ghwndMain, hdc);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);       // Kilo-calls per second
}

float Other_Graphics_Create_FromScreenHdc_PerCall(Graphics *gScreen, HDC hdcScreen)
{
    UINT iterations;
    float seconds;

    if (!gScreen) return(0);

    HDC hdc = GetDC(ghwndMain);

    StartTimer();

    do {
        Graphics g(hdc);

        ASSERT(g.GetLastStatus() == Ok);

    } while (!EndTimer());

    GetTimer(&seconds, &iterations);

    ReleaseDC(ghwndMain, hdc);

    return(iterations / seconds / KILO);       // Kilo-calls per second
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test OtherTests[] = 
{
    T(5000, 1, Other_Graphics_Create_FromHwnd_PerCall                   , "Kcalls/s"),
    T(5001, 1, Other_Graphics_Create_FromScreenHdc_PerCall              , "Kcalls/s"),
};

INT OtherTests_Count = sizeof(OtherTests) / sizeof(OtherTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\polytest\debug.h ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   debug.h
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

#define ASSERT(cond) { if (!(cond)) DebugBreak(); }

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define ASSERT(cond)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perftest.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   perftest.cpp
*
* Abstract:
*
*   Contains the UI and initialization code for the GDI+ performance test.
*
* Revision History:
*
*   01/03/2000 ericvan
*       Created it.
*
\**************************************************************************/

#include "perftest.h"
#include <winuser.h>

#include "../gpinit.inc"

///////////////////////////////////////////////////////////////////////////////

// Test settings:

BOOL AutoRun = FALSE;           // TRUE if invoked from command-line
BOOL ExcelOut = FALSE;          // Should we format our output for Excel?
BOOL Regressions = FALSE;       // We're running the check-in regressions
BOOL TestRender = FALSE;        // Only draw one iteration, for test purposes
BOOL Icecap = FALSE;            // Start/stop profiling before and after every test
BOOL FoundIcecap = FALSE;       // True if we could find ICECAP.DLL

// Windows state:

HINSTANCE ghInstance = NULL;    // Handle to the Application Instance
HBRUSH ghbrWhite = NULL;        // white brush handle for background
HWND ghwndMain = NULL;
HWND ghwndStatus = NULL;

// Information about the system:

LPTSTR processor = NULL;
TCHAR osVer[MAX_PATH];
TCHAR deviceName[MAX_PATH];
TCHAR machineName[MAX_PATH];

// Test data:

TestConfig *TestList;       // Allocation used for sorting tests
TestResult *ResultsList;    // Allocation to track test results

Config ApiList[Api_Count] =
{
    { _T("1 - Api - GDI+") },    
    { _T("1 - Api - GDI") }      
}; 

Config DestinationList[Destination_Count] =
{
    { _T("2 - Destination - Screen - Current") },
    { _T("2 - Destination - Screen - 800x600x8bppDefaultPalette") },
    { _T("2 - Destination - Screen - 800x600x8bppHalftonePalette") },
    { _T("2 - Destination - Screen - 800x600x16bpp") },
    { _T("2 - Destination - Screen - 800x600x24bpp") },
    { _T("2 - Destination - Screen - 800x600x32bpp") },
    { _T("2 - Destination - CompatibleBitmap - 8bpp") },
    { _T("2 - Destination - DIB - 15bpp") },
    { _T("2 - Destination - DIB - 16bpp") },
    { _T("2 - Destination - DIB - 24bpp") },
    { _T("2 - Destination - DIB - 32bpp") },
    { _T("2 - Destination - Bitmap - 32bpp ARGB") },
    { _T("2 - Destination - Bitmap - 32bpp PARGB (office cached format)") },
}; 

Config StateList[State_Count] =
{
    { _T("3 - State - Default") },
    { _T("3 - State - Antialias") },
}; 

TestGroup TestGroups[] = 
{
    DrawTests,  DrawTests_Count,
    FillTests,  FillTests_Count,
    ImageTests, ImageTests_Count,
    TextTests,  TextTests_Count,
    OtherTests, OtherTests_Count,
};

INT TestGroups_Count = sizeof(TestGroups) / sizeof(TestGroups[0]);
                        // Number of test groups

INT Test_Count;         // Total number of tests across all groups
 
/***************************************************************************\
* RegressionsInit
*
* Sets the state for running the standard regressions.
*
\***************************************************************************/

void RegressionsInit()
{
    INT i;

    DestinationList[Destination_Screen_Current].Enabled = TRUE;
    DestinationList[Destination_Bitmap_32bpp_ARGB].Enabled = TRUE;

    StateList[State_Default].Enabled = TRUE;

    ApiList[Api_GdiPlus].Enabled = TRUE;
    ApiList[Api_Gdi].Enabled = TRUE;

    for (i = 0; i < Test_Count; i++)
    {
        TestList[i].Enabled = TRUE;
    }
}
 
/***************************************************************************\
* RestoreInit
*
* Load the 'perftest.ini' file to retrieve all the saved test settings.
*
\***************************************************************************/

void RestoreInit()
{
    INT i;
    FILE* outfile;

    outfile = _tfopen(_T("perftest.ini"), _T("r"));
   
    if (!outfile) 
    {
        // may not have been created yet, first run?!

        return;
    }

   _ftscanf(outfile, _T("%d\n"), &ExcelOut);

    INT switchType = -1;
    while (!feof(outfile)) 
    {
        int tmp = -9999;

        _ftscanf(outfile, _T("%d\n"), &tmp);

        // Tags are indicated by negative numbers:

        if (tmp < 0) 
        {
            switchType = tmp;
        }
        else
        {
            // We've figured out the type, now process it:

            switch(switchType)
            {
            case -1: 
                // Tests are indexed by their unique identifier, because 
                // they're added to very frequently:
    
                for (i = 0; i < Test_Count; i++)
                {
                    if (TestList[i].TestEntry->UniqueIdentifier == tmp)
                    {
                        TestList[i].Enabled = TRUE;
                    }
                }
                break;
                
            case -2: 
                if (tmp < Destination_Count)
                    DestinationList[tmp].Enabled = TRUE; 
                break;
    
            case -3: 
                if (tmp < State_Count)
                    StateList[tmp].Enabled = TRUE; 
                break;
    
            case -4: 
                if (tmp < Api_Count)
                    ApiList[tmp].Enabled = TRUE; 
                break;
            }
        }
    }

    fclose(outfile);
}

/***************************************************************************\
* SaveInit
*
* Save all the current test settings into a 'perftest.ini' file.
*
\***************************************************************************/

void SaveInit()
{
   INT i;
   FILE* outfile;

   outfile = _tfopen(_T("perftest.ini"), _T("w"));
   
   if (!outfile) 
   {
      MessageF(_T("Can't create: perftest.ini"));
      return;
   }

   // I purposefully do not save the state of 'Icecap' or 'TestRender'
   // because they're too annoying when on accidentally.

   _ftprintf(outfile, _T("%d\n"), ExcelOut);

   _ftprintf(outfile, _T("-1\n")); // Test List

   for (i=0; i<Test_Count; i++) 
   {
       // Tests are indexed by their unique identifier, because 
       // they're added to very frequently:

       if (TestList[i].Enabled)
           _ftprintf(outfile, _T("%d\n"), TestList[i].TestEntry->UniqueIdentifier);
   }

   _ftprintf(outfile, _T("-2\n")); // Destination List
   
   for (i=0; i<Destination_Count; i++) 
   {
       if (DestinationList[i].Enabled) 
           _ftprintf(outfile, _T("%d\n"), i);
   }
           
   _ftprintf(outfile, _T("-3\n")); // State List
   
   for (i=0; i<State_Count; i++)
   {
       if (StateList[i].Enabled)
           _ftprintf(outfile, _T("%d\n"), i);
   }
   
   _ftprintf(outfile, _T("-4\n")); // Api List

   for (i=0; i<Api_Count; i++) 
   {
       if (ApiList[i].Enabled)
           _ftprintf(outfile, _T("%d\n"), i);
   }

   fclose(outfile);
}

/***************************************************************************\
* CmdArgument
*
* search for string and return just after it.
*
\***************************************************************************/

LPSTR CmdArgument(LPSTR arglist, LPSTR arg)
{
    LPSTR str = strstr(arglist, arg);

    if (str)
        return str + strlen(arg);
    else
        return NULL;
}

/***************************************************************************\
* MessageF
*
* Display a message in a pop-up dialog
*
\***************************************************************************/

VOID
MessageF(
    LPTSTR fmt,
    ...
    )

{
    TCHAR buf[1024];
    va_list arglist;

    va_start(arglist, fmt);
    _vstprintf(buf, fmt, arglist);
    va_end(arglist);

    MessageBox(ghwndMain, &buf[0], _T("PerfTest"), MB_OK | MB_ICONEXCLAMATION);
}

/***************************************************************************\
* UpdateList
*
* Update the active tests according to whatever is enabled in the list-
* boxes.
*
\***************************************************************************/

void
UpdateList(
    HWND hwnd
    )
{
    INT i;

    HWND hwndIcecap = GetDlgItem(hwnd, IDC_ICECAP);
    Icecap= 
      (SendMessage(hwndIcecap, BM_GETCHECK, 0, 0) == BST_CHECKED);
    DeleteObject(hwndIcecap);

    HWND hwndTestRender = GetDlgItem(hwnd, IDC_TESTRENDER);
    TestRender= 
      (SendMessage(hwndTestRender, BM_GETCHECK, 0, 0) == BST_CHECKED);
    DeleteObject(hwndTestRender);

    HWND hwndExcel = GetDlgItem(hwnd, IDC_EXCELOUT);
    ExcelOut= 
      (SendMessage(hwndExcel, BM_GETCHECK, 0, 0) == BST_CHECKED);
    DeleteObject(hwndExcel);
    
    // iterate through test case list and flag enabled/disabled
    
    HWND hwndList = GetDlgItem(hwnd, IDC_TESTLIST);
    
    for (i=0; i<Api_Count; i++)
        ApiList[i].Enabled =
            (SendMessage(hwndList,
                       LB_FINDSTRINGEXACT,
                       -1,
                       (LPARAM) ApiList[i].Description) != LB_ERR);
    
    for (i=0; i<Destination_Count; i++)
        DestinationList[i].Enabled =
            (SendMessage(hwndList,
                       LB_FINDSTRINGEXACT,
                       -1,
                       (LPARAM) DestinationList[i].Description) != LB_ERR);
    
    for (i=0; i<State_Count; i++)
        StateList[i].Enabled =
            (SendMessage(hwndList,
                        LB_FINDSTRINGEXACT,
                        0,
                        (LPARAM) StateList[i].Description) != LB_ERR);
    
    for (i=0; i<Test_Count; i++)
        TestList[i].Enabled =
            (SendMessage(hwndList,
                         LB_FINDSTRINGEXACT,
                         -1,
                         (LPARAM) TestList[i].TestEntry->Description) != LB_ERR);
    
    DeleteObject(hwndList);
}

/***************************************************************************\
* MainWindowProc
*
* Windows call-back procedure.
*
\***************************************************************************/

LRESULT
MainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
        if (Regressions)
            RegressionsInit();
        else
            RestoreInit();
        break;

    case WM_DISPLAYCHANGE:
    case WM_SIZE:
       TCHAR windText[MAX_PATH];

       GetWindowText(ghwndStatus, &windText[0], MAX_PATH);
       DestroyWindow(ghwndStatus);

       ghwndStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                _T("Performance Test Application"),
                                ghwndMain,
                                -1);
       SetWindowText(ghwndStatus, &windText[0]);
       break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {

        case IDM_QUIT:
            if (!Regressions)
            {
                UpdateList(hwnd);
                SaveInit();
            }

            exit(0);
            break;

        default:
            MessageBox(hwnd,
                       _T("Help Me - I've Fallen and Can't Get Up!"), 
                       _T("Help!"),
                       MB_OK);
            break;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        DeleteObject(ghbrWhite);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* GetSystemInformation
*
* Initializes some globals describing the current system.
*
\***************************************************************************/

void
GetSystemInformation()
{
    // Getting machine name assumes we have TCP/IP setup.  However, this
    // is true in all of our cases.

    LPCTSTR TCPIP_PARAMS_KEY = 
       _T("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");
    DWORD size;
    HKEY hKeyHostname;
    DWORD type;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     TCPIP_PARAMS_KEY, 
                     0, 
                     KEY_READ, 
                     &hKeyHostname) == ERROR_SUCCESS)
    {
        size = sizeof(machineName);

        if (RegQueryValueEx(hKeyHostname,
                        _T("Hostname"),
                        NULL,
                        (LPDWORD)&type,
                        (LPBYTE)&machineName[0], 
                        (LPDWORD)&size) == ERROR_SUCCESS)
        {
            if (type != REG_SZ) 
            {
                lstrcpy(&machineName[0], _T("Unknown"));
            }
        }

        RegCloseKey(hKeyHostname);
    }

    OSVERSIONINFO osver;
    osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osver);
    _stprintf(&osVer[0], _T("%s %d.%02d"),
                   osver.dwPlatformId == VER_PLATFORM_WIN32_NT ?
                   _T("Windows NT") : _T("Windows 9x"),
                   osver.dwMajorVersion,
                   osver.dwMinorVersion);

    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    if (osver.dwPlatformId = VER_PLATFORM_WIN32_NT) 
    {
        // we are assuming wProcessorArchitecture==PROCESSOR_ARCHITECTURE_INTEL

        // WinNT processor

        switch (sysinfo.wProcessorLevel)
        {
        case 3: processor = _T("Intel 80386"); break;
        case 4: processor = _T("Intel 80486"); break;
        case 5: processor = _T("Intel Pentium"); break;
        case 6: processor = _T("Intel Pentium Pro or Pentium II"); break;
        default: processor = _T("???"); break;
        }
    }
    else    // win 9x
    {
        switch (sysinfo.dwProcessorType) 
        {
        case PROCESSOR_INTEL_386: processor = _T("Intel 80386"); break;
        case PROCESSOR_INTEL_486: processor = _T("Intel 80486"); break;
        case PROCESSOR_INTEL_PENTIUM: processor = _T("Intel Pentium"); break;
        default: processor = _T("???");
        }
    }
    // Query the driver name:

    DEVMODE devMode;
    devMode.dmSize = sizeof(DEVMODE);
    devMode.dmDriverExtra = 0;

    INT result = EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &devMode);

    _tcscpy(deviceName, (result) ? (TCHAR*) &devMode.dmDeviceName[0] : _T("Unknown"));
}

INT CurrentTestIndex;
CHAR CurrentTestDescription[2048];

ICCONTROLPROFILEFUNC ICStartProfile=NULL, ICStopProfile=NULL;
ICCOMMENTMARKPROFILEFUNC ICCommentMarkProfile=NULL;

/***************************************************************************\
* LoadIcecap
*
* Try to dynamically load ICECAP.DLL
* If we fail, disable the check box
*
\***************************************************************************/

void LoadIcecap(HWND checkBox)
{
    if (!FoundIcecap)
    {
        HMODULE module = LoadLibraryA("icecap.dll");
        
        if (module)
        {
            ICStartProfile = (ICCONTROLPROFILEFUNC) GetProcAddress(module, "StartProfile");
            ICStopProfile = (ICCONTROLPROFILEFUNC) GetProcAddress(module, "StopProfile");
            ICCommentMarkProfile = (ICCOMMENTMARKPROFILEFUNC) GetProcAddress(module, "CommentMarkProfile");
            
            if (ICStartProfile && ICStopProfile && ICCommentMarkProfile)
            {
                EnableWindow(checkBox, TRUE);
                FoundIcecap = TRUE;
                return;
            }
        }
        
        EnableWindow(checkBox, FALSE);
        Icecap = FALSE;
    }
}

/***************************************************************************\
* DialogProc
*
* Dialog call-back procedure.
*
\***************************************************************************/

INT_PTR
DialogProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PAINTSTRUCT ps;

    switch (message)
    {

    case WM_INITDIALOG:
    {
       {
         INT i;
         HWND hwndTemp;
         HWND hwndTemp2;
         TCHAR fileName[MAX_PATH];

         hwndTemp = GetDlgItem(hwnd, IDC_PROCESSOR);
         SetWindowText(hwndTemp, processor);
         DeleteObject(hwndTemp);


         hwndTemp = GetDlgItem(hwnd, IDC_FILE);

         GetOutputFileName(fileName);
         SetWindowText(hwndTemp, fileName);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_OS);
         SetWindowText(hwndTemp, &osVer[0]);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_VDRIVER);
         SetWindowText(hwndTemp, deviceName);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_ICECAP);
         LoadIcecap(hwndTemp);
         SendMessage(hwndTemp, BM_SETCHECK, (WPARAM) (Icecap ?
                                                      BST_CHECKED :
                                                      BST_UNCHECKED), 0);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_TESTRENDER);
         SendMessage(hwndTemp, BM_SETCHECK, (WPARAM) (TestRender ?
                                                      BST_CHECKED :
                                                      BST_UNCHECKED), 0);
         DeleteObject(hwndTemp);

         hwndTemp = GetDlgItem(hwnd, IDC_EXCELOUT);
         SendMessage(hwndTemp, BM_SETCHECK, (WPARAM) (ExcelOut ?
                                                      BST_CHECKED :
                                                      BST_UNCHECKED), 0);
         DeleteObject(hwndTemp);
           
         // populate the perf test scenarios
         
         hwndTemp = GetDlgItem(hwnd, IDC_TESTLIST);
         hwndTemp2 = GetDlgItem(hwnd, IDC_SKIPLIST);

         for (i=0; i<Api_Count; i++)
         {
             if (ApiList[i].Description)
             {
                SendMessage(ApiList[i].Enabled ? hwndTemp : hwndTemp2, 
                            LB_ADDSTRING, 
                            0, 
                            (LPARAM) ApiList[i].Description);
             }
         }

         for (i=0; i<Destination_Count; i++)
         {
             if (DestinationList[i].Description)
             {
                SendMessage(DestinationList[i].Enabled ? hwndTemp : hwndTemp2, 
                            LB_ADDSTRING, 
                            0, 
                            (LPARAM) DestinationList[i].Description);
             }
         }
         
         for (i=0; i<State_Count; i++)
         {
             if (StateList[i].Description)
             {
                SendMessage(StateList[i].Enabled ? hwndTemp : hwndTemp2,
                            LB_ADDSTRING,
                            0,
                            (LPARAM) StateList[i].Description);
             }
         }
         
         for (i=0; i<Test_Count; i++)
         {
             if (TestList[i].TestEntry->Description)
             {
                SendMessage(TestList[i].Enabled ? hwndTemp : hwndTemp2,
                            LB_ADDSTRING,
                            0,
                            (LPARAM) TestList[i].TestEntry->Description);
             }
         }
         
         DeleteObject(hwndTemp);

         return FALSE;
       }
    }
    break;

    case WM_COMMAND:
        WORD wCommand = LOWORD(wParam);
        switch(wCommand)
        {
            case IDOK:
            {
               UpdateList(hwnd);
    
               ShowWindow(hwnd, SW_HIDE);
    
               // start running the tests
    
               {
                  TestSuite testSuite;
                  testSuite.Run(ghwndMain);
               }
    
               ShowWindow(hwnd, SW_SHOW);
               
               return TRUE;
            }
        break;
           
        case IDC_ADDTEST:
           {
              TCHAR temp[MAX_PATH];
              HWND hwndTestList = GetDlgItem(hwnd, IDC_TESTLIST);
              HWND hwndNopeList = GetDlgItem(hwnd, IDC_SKIPLIST);

              LRESULT curSel = SendMessage(hwndNopeList, LB_GETCURSEL, 0, 0);
              if (curSel != LB_ERR) 
              {
                 SendMessage(hwndNopeList, 
                             LB_GETTEXT, 
                             (WPARAM) curSel, 
                             (LPARAM) &temp[0]);

                 SendMessage(hwndNopeList,
                             LB_DELETESTRING,
                             (WPARAM) curSel,
                             0);

                 SendMessage(hwndTestList,
                             LB_ADDSTRING,
                             0,
                             (LPARAM) &temp[0]);
              }

              DeleteObject(hwndTestList);
              DeleteObject(hwndNopeList);
           }
           break;

        case IDC_DELTEST:
           {
              TCHAR temp[MAX_PATH];
              HWND hwndTestList = GetDlgItem(hwnd, IDC_TESTLIST);
              HWND hwndNopeList = GetDlgItem(hwnd, IDC_SKIPLIST);

              LRESULT curSel = SendMessage(hwndTestList, LB_GETCURSEL, 0, 0);
              if (curSel != LB_ERR) 
              {
                 SendMessage(hwndTestList, 
                             LB_GETTEXT, 
                             (WPARAM) curSel, 
                             (LPARAM) &temp[0]);

                 SendMessage(hwndTestList,
                             LB_DELETESTRING,
                             (WPARAM) curSel,
                             0);

                 SendMessage(hwndNopeList,
                             LB_ADDSTRING,
                             0,
                             (LPARAM) &temp[0]);
              }

              DeleteObject(hwndTestList);
              DeleteObject(hwndNopeList);
           }
           break;

        case IDC_DELALLTEST:
        case IDC_ADDALLTEST:
           {
               TCHAR temp[MAX_PATH];
               HWND hwndTestList;
               HWND hwndNopeList;

               if (wCommand == IDC_DELALLTEST)
               {
                   hwndTestList = GetDlgItem(hwnd, IDC_TESTLIST);
                   hwndNopeList = GetDlgItem(hwnd, IDC_SKIPLIST);
               }
               else
               {
                   hwndTestList = GetDlgItem(hwnd, IDC_SKIPLIST);
                   hwndNopeList = GetDlgItem(hwnd, IDC_TESTLIST);
               }

               LRESULT count = SendMessage(hwndTestList, LB_GETCOUNT, 0, 0);
               LRESULT curSel;

               for (curSel = count - 1; curSel >= 0; curSel--)
               {
                  SendMessage(hwndTestList, 
                              LB_GETTEXT, 
                              (WPARAM) curSel, 
                              (LPARAM) &temp[0]);

                  SendMessage(hwndTestList,
                              LB_DELETESTRING,
                              (WPARAM) curSel,
                              0);

                  SendMessage(hwndNopeList,
                              LB_ADDSTRING,
                              0,
                              (LPARAM) &temp[0]);
               }

               DeleteObject(hwndTestList);
               DeleteObject(hwndNopeList);
            }
            break;
        
        case IDCANCEL:
           if (!Regressions)
           {
               UpdateList(hwnd);
               SaveInit();
           }

           exit(-1);
           return TRUE;

        case WM_CLOSE:
           if (!Regressions)
           {
               UpdateList(hwnd);
               SaveInit();
           }

           DestroyWindow(hwnd);
           return TRUE;

        }
        break;
    }

    return FALSE;
}

/***************************************************************************\
* TestComparison
*
* Comparitor function for sorting the tests by Description.
*
\***************************************************************************/

int _cdecl TestComparison(const void *a, const void *b)
{
    const TestConfig* testA = static_cast<const TestConfig*>(a);
    const TestConfig* testB = static_cast<const TestConfig*>(b);

    return(_tcscmp(testA->TestEntry->Description, testB->TestEntry->Description));
}

/***************************************************************************\
* InitializeTests()
*
* Initializes test state.
*
\***************************************************************************/

BOOL InitializeTests()
{
    INT i;
    INT j;
    TestConfig* testList;

    // Count the total number of tests:

    Test_Count = 0;
    for (i = 0; i < TestGroups_Count; i++)
    {
        Test_Count += TestGroups[i].Count;
    }

    // Create one tracking array:

    TestList = static_cast<TestConfig*>
                                (malloc(sizeof(TestConfig) * Test_Count));
    if (TestList == NULL)
        return(FALSE);

    // Initialize the tracking array and sort it by description:

    testList = TestList;
    for (i = 0; i < TestGroups_Count; i++)
    {
        for (j = 0; j < TestGroups[i].Count; j++)
        {
            testList->Enabled = FALSE;
            testList->TestEntry = &TestGroups[i].Tests[j];
            testList++;
        }
    }

    qsort(TestList, Test_Count, sizeof(TestList[0]), TestComparison);

    // Now do some validation, by verifying that there is no repeated
    // uniqueness number:

    for (i = 0; i < Test_Count; i++)
    {
        for (j = i + 1; j < Test_Count; j++)
        {
            if (TestList[i].TestEntry->UniqueIdentifier == 
                TestList[j].TestEntry->UniqueIdentifier)
            {
                MessageF(_T("Oops, there are two test functions with the same unique identifier: %li.  Please fix."),
                         TestList[i].TestEntry->UniqueIdentifier);

                return(FALSE);
            }
        }
    }

    // Allocate our 3 dimensional results array:

    ResultsList = static_cast<TestResult*>
                    (malloc(sizeof(TestResult) * ResultCount()));
    if (ResultsList == NULL)
        return(FALSE);

    for (i = 0; i < ResultCount(); i++)
    {
        ResultsList[i].Score = 0.0f;
    }

    return(TRUE);
}

/***************************************************************************\
* UninitializeTests()
*
* Initializes tests.
*
\***************************************************************************/

VOID UninitializeTests()
{
    free(ResultsList);
    free(TestList);
}

/***************************************************************************\
* InitializeApplication()
*
* Initializes app.
*
\***************************************************************************/

BOOL InitializeApplication(VOID)
{
    WNDCLASS wc;

    if (!InitializeTests())
    {
        return(FALSE);
    }

    GetSystemInformation();

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));
    
    wc.style            = 0;
    wc.lpfnWndProc      = MainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = NULL;        
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = NULL;        
    wc.lpszClassName    = _T("TestClass");

    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }

    ghwndMain = CreateWindowEx(
        0,
        _T("TestClass"),
        _T("GDI+ Performance Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_MAXIMIZE     |
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    SetFocus(ghwndMain);

    ghwndStatus = CreateStatusWindow(WS_CHILD|WS_VISIBLE,
                                    _T("Performance Test Application"),
                                    ghwndMain,
                                    -1);
    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[]
    )
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    INT curarg = 1;
    while (curarg < argc) 
    {
        if (CmdArgument(argv[curarg],"/?") || 
            CmdArgument(argv[curarg],"/h") ||
            CmdArgument(argv[curarg],"/H")) 
        {
       
            MessageF(_T("GDI+ Perf Test\n")
                    _T("==============\n")
                    _T("\n")
                    _T("/b    Run batch mode\n")
                    _T("/e    Excel output format\n")
                    _T("/r    Regressions\n"));

            exit(-1);
        }

        if (CmdArgument(argv[curarg],"/b"))
            AutoRun = TRUE;
    
        if (CmdArgument(argv[curarg],"/e"))
            ExcelOut = TRUE;

        if (CmdArgument(argv[curarg],"/r"))
            Regressions = TRUE;
    
        curarg++;
    }

    ghInstance = GetModuleHandle(NULL);

    if (!InitializeApplication())
    {
        return(0);
    }

    // turn batching off to get true timing per call

    GdiSetBatchLimit(1);

    if (AutoRun) 
    {
        // start running the tests
           
        TestSuite testSuite;
        testSuite.Run(ghwndMain);
    }
    else
    {
        HWND hwndDlg = CreateDialog(ghInstance,
                                    MAKEINTRESOURCE(IDD_STARTDIALOG),
                                    ghwndMain,
                                    &DialogProc);
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    UninitializeTests();

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perftest.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   perftest.h
*
* Abstract:
*
*   This is the common include module for the GDI+ performance tests.
*
\**************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <math.h>            // sin & cos
#include <tchar.h>
#include <commctrl.h>
#include <objbase.h>

#if 0

    // So that we can continue testing the old drawing functionality for
    // a while, don't use the new API headers yet:
    
    #define RenderingHintAntiAlias      RenderingModeAntiAlias
    #define TextRenderingHintAntiAlias  TextAntiAlias
    #define TextRenderingHintClearType  TextClearType
    #define PixelFormatMax              PIXFMT_MAX
    #define PixelFormat32bppARGB        PIXFMT_32BPP_ARGB
    #define PixelFormat32bppPARGB       PIXFMT_32BPP_PARGB
    #define PixelFormat32bppRGB         PIXFMT_32BPP_RGB
    #define PixelFormat16bppRGB555      PIXFMT_16BPP_RGB555
    #define PixelFormat16bppRGB565      PIXFMT_16BPP_RGB565
    #define PixelFormat24bppRGB         PIXFMT_24BPP_RGB
    #define LinearGradientBrush         LineGradientBrush
    #define InterpolationModeBicubic    InterpolateBicubic
    #define InterpolationModeBilinear   InterpolateBilinear
    #define UNITPIXEL                   PageUnitPixel
    
#else
    
    #define USE_NEW_APIS 1
    #define USE_NEW_APIS2 1
    
    #define UNITPIXEL                   UnitPixel
    
#endif

#include <gdiplus.h>

using namespace Gdiplus;

#include "resource.h"
#include "debug.h"

// Handy window handle:

extern HWND ghwndMain;

// Dimensions of any bitmap destinations:

#define TestWidth 800
#define TestHeight 600

//--------------------------------------------------------------------------
// Types
//
// Enums for test permutations
//--------------------------------------------------------------------------

enum DestinationType 
{
    Destination_Screen_Current,
    Destination_Screen_800_600_8bpp_DefaultPalette,
    Destination_Screen_800_600_8bpp_HalftonePalette,
    Destination_Screen_800_600_16bpp,
    Destination_Screen_800_600_24bpp,
    Destination_Screen_800_600_32bpp,
    Destination_CompatibleBitmap_8bpp,
    Destination_DIB_15bpp,
    Destination_DIB_16bpp,
    Destination_DIB_24bpp,
    Destination_DIB_32bpp,
    Destination_Bitmap_32bpp_ARGB,
    Destination_Bitmap_32bpp_PARGB,

    Destination_Count                // Must be last entry, used for count
};

enum ApiType
{
    Api_GdiPlus,
    Api_Gdi,

    Api_Count                        // Must be last entry, used for count
};

enum StateType
{
    State_Default,
    State_Antialias,

    State_Count                      // Must be last entry, used for count
};
   
typedef float (*TESTFUNCTION)(Graphics *, HDC); 

struct Test 
{
    INT          UniqueIdentifier;
    INT          Priority;
    TESTFUNCTION Function;
    LPCTSTR      Description;
    LPCTSTR      Comment;
};

struct Config
{
    LPCTSTR     Description;
    BOOL        Enabled;
};

struct TestConfig
{
    BOOL        Enabled;
    Test*       TestEntry;          // Points to static entry describing test
};

extern TestConfig *TestList;        // Sorted test list
extern Config ApiList[];
extern Config DestinationList[];
extern Config StateList[];

//--------------------------------------------------------------------------
// Test groupings
//
//--------------------------------------------------------------------------

#define T(uniqueIdentifier, priority, function, comment) \
    { uniqueIdentifier, priority, function, _T(#function), _T(comment) }

struct TestGroup
{
    Test*   Tests;
    INT     Count;
};

extern Test DrawTests[];
extern Test FillTests[];
extern Test ImageTests[];
extern Test TextTests[];
extern Test OtherTests[];

extern INT DrawTests_Count;
extern INT FillTests_Count;
extern INT ImageTests_Count;
extern INT TextTests_Count;
extern INT OtherTests_Count;

extern INT Test_Count;      // Total number of tests

//--------------------------------------------------------------------------
// TestResult -
//
// Structure for maintaining test result information.  The data is kept
// as a multi-dimensional array, and the following routines are used 
// for access.
//--------------------------------------------------------------------------

struct TestResult 
{
    float Score;
};

inline INT ResultIndex(INT destinationIndex, INT apiIndex, INT stateIndex, INT testIndex)
{
    return(((testIndex * State_Count + stateIndex) * Api_Count + apiIndex) * 
            Destination_Count + destinationIndex);
}

inline INT ResultCount()
{
    return(Destination_Count * Api_Count * State_Count * Test_Count);
}

extern TestResult *ResultsList;     // Allocation to track test results

//--------------------------------------------------------------------------
// TestSuite - 
//
// Class that abstracts all the state setup for running all the tests.
//--------------------------------------------------------------------------

class TestSuite
{
private:

    // Save Destination state:

    BOOL ModeSet;                   // Was a mode set?
    HPALETTE HalftonePalette, OldPalette;

    // Saved State state:

    GraphicsState SavedState;

public:

    BOOL InitializeDestination(DestinationType, Bitmap**, HBITMAP*);
    VOID UninitializeDestination(DestinationType, Bitmap *, HBITMAP);

    BOOL InitializeApi(ApiType, Bitmap *, HBITMAP, HWND, Graphics **, HDC *);
    VOID UninitializeApi(ApiType, Bitmap *, HBITMAP, HWND, Graphics *, HDC);

    BOOL InitializeState(ApiType, StateType, Graphics*, HDC);
    VOID UninitializeState(ApiType, StateType, Graphics*, HDC);

    TestSuite();
   ~TestSuite();

    VOID Run(HWND hwnd);
};

///////////////////////////////////////////////////////////////////////////
// Test settings:

extern BOOL AutoRun;
extern BOOL ExcelOut;
extern BOOL Icecap;
extern BOOL FoundIcecap;
extern BOOL TestRender;
extern INT CurrentTestIndex;
extern CHAR CurrentTestDescription[];

extern LPTSTR processor;
extern TCHAR osVer[MAX_PATH];
extern TCHAR deviceName[MAX_PATH];
extern TCHAR machineName[MAX_PATH];

///////////////////////////////////////////////////////////////////////////
// IceCAP API functions

#define PROFILE_GLOBALLEVEL 1
#define PROFILE_CURRENTID ((unsigned long)0xFFFFFFFF)

typedef int (_stdcall *ICCOMMENTMARKPROFILEFUNC)(long lMarker, const char *szComment);

typedef int (_stdcall *ICCONTROLPROFILEFUNC)(int nLevel, unsigned long dwId);

extern ICCONTROLPROFILEFUNC ICStartProfile, ICStopProfile;
extern ICCOMMENTMARKPROFILEFUNC ICCommentMarkProfile;

///////////////////////////////////////////////////////////////////////////
// Worker routines

VOID MessageF(LPTSTR fmt, ...);
HBITMAP CreateCompatibleDIB2(HDC hdc, int width, int height);
VOID CreatePerformanceReport(TestResult *results, BOOL useExcel);
VOID GetOutputFileName(TCHAR*);

///////////////////////////////////////////////////////////////////////////
// Timer utility functions

#define MIN_ITERATIONS 16   // Must be power of two
#define MIN_DURATION 200    // Minimum time duration, in milliseconds
#define MEGA 1000000        // Handy constant for computing megapixels
#define KILO 1000           // Handy constant for computing kilopixels

void StartTimer();
BOOL EndTimer();
void GetTimer(float* seconds, UINT* iterations);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perfreport.cpp ===
/******************************Module*Header*******************************\
* Module Name: perfreport.cpp
*
* Copyright (c) 1991-2000 Microsoft Corporation
*
* Outputs the report file for this platform.
*
\**************************************************************************/

#include "perftest.h"
#include <time.h>

/***************************************************************************\
* GetOutputFileName
*
\***************************************************************************/

VOID GetOutputFileName(TCHAR *fileName)
{
   // Get OS Version Information

   OSVERSIONINFO osVer;
   osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   GetVersionEx(&osVer);

   switch (osVer.dwPlatformId) 
   {
   case VER_PLATFORM_WIN32_WINDOWS:
      _stprintf(&fileName[0], 
                _T("WIN9X%d.TXT"),
                osVer.dwBuildNumber & 0x0000FFFF);
      break;

   case VER_PLATFORM_WIN32_NT:
      _stprintf(&fileName[0], 
                _T("WINNT%d%02d.TXT"), 
                osVer.dwMajorVersion,
                osVer.dwMinorVersion);
      break;

   default:
      _stprintf(&fileName[0], _T("Unknown.Txt"));
   }
}

/***************************************************************************\
* DetectMMX
*
* Detects whether the processor supports MMX.
*
\***************************************************************************/

BOOL
DetectMMX()
{
    BOOL hasMMX = FALSE;

#if defined(_X86_)
    __try
    {
        __asm emms
        hasMMX = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
#endif

    return hasMMX;
}

/***************************************************************************\
* CreatePerformanceReport
*
* Writes the test results to a file.
*
\***************************************************************************/

VOID CreatePerformanceReport(TestResult* results, BOOL ExcelOut)
{
    TCHAR fileName[MAX_PATH];

    GetOutputFileName(fileName);
   
    OSVERSIONINFO osVer;
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osVer);
    
    FILE* outfile;
    
    outfile = _tfopen(fileName, _T("w"));
    
    if (!outfile) 
    {
       MessageF(_T("Can't create: %s"), &fileName[0]);
       return;
    }
    
    TCHAR timeStr[MAX_PATH];
    time_t ltime;
    struct tm tmtime;
    
    time(&ltime);
    tmtime = *localtime(&ltime);
    _tcsftime(&timeStr[0], MAX_PATH, _T("%B %d, %Y, %I:%M:%S %p"), &tmtime);

    if (ExcelOut) 
        _ftprintf(outfile, _T("GDI+ Performance Report\n")
                        _T("=======================\n")
                        _T("\n")
                        _T("Machine Name:\t%s\n")
                        _T("OS:\t\t%s %d.%02d %c%s%c\n")
                        _T("Processor:\t%s\n")
                        _T("MMX:\t\t%s\n")
                        _T("Video Driver:\t%s\n")
                        _T("Report Date:\t%s\n"),
                          machineName,
                          osVer.dwPlatformId == VER_PLATFORM_WIN32_NT ?
                             _T("Windows NT") : _T("Windows 9x"),
                          osVer.dwMajorVersion,
                          osVer.dwMinorVersion,
                          (osVer.szCSDVersion[0]) ? '[' : ' ',
                          &osVer.szCSDVersion[0],
                          (osVer.szCSDVersion[0]) ? '[' : ' ',
                          processor,
                          DetectMMX()?"Yes":"No",
                          &deviceName[0],
                          &timeStr[0]);
    else
        _ftprintf(outfile, _T("GDI+ Performance Report\n")
                        _T("=======================\n")
                        _T("\n")
                        _T("Machine Name:\t%s\n")
                        _T("OS:\t\t%s %d.%02d %c%s%c\n")
                        _T("Processor:\t%s\n")
                        _T("MMX:\t\t%s\n")
                        _T("Video Driver:\t%s\n")
                        _T("Report Date:\t%s\n"),
                          &machineName[0],
                          osVer.dwPlatformId == VER_PLATFORM_WIN32_NT ?
                             _T("Windows NT") : _T("Windows 9x"),
                          osVer.dwMajorVersion,
                          osVer.dwMinorVersion,
                          (osVer.szCSDVersion[0]) ? '[' : ' ',
                          &osVer.szCSDVersion[0],
                          (osVer.szCSDVersion[0]) ? '[' : ' ',
                          processor,
                          DetectMMX()?"Yes":"No",
                          &deviceName[0],
                          &timeStr[0]);
    
    // Go through the results matrix and output everything:

    for (INT destinationIndex = 0; 
         destinationIndex < Destination_Count; 
         destinationIndex++)
    {
        if (!DestinationList[destinationIndex].Enabled)
            continue;

        _ftprintf(outfile, _T("---------------------------------------------------------------------\n"));

        if (destinationIndex == Destination_Screen_Current)
        {
            HDC hdc = GetDC(NULL);
            _ftprintf(outfile, 
                      _T("\n%s %lix%lix%libpp\n"), 
                      DestinationList[destinationIndex].Description,
                      GetDeviceCaps(hdc, HORZRES),
                      GetDeviceCaps(hdc, VERTRES),
                      GetDeviceCaps(hdc, BITSPIXEL));
            ReleaseDC(NULL, hdc);
        }
        else
        {
            _ftprintf(outfile, _T("\n%s\n"), DestinationList[destinationIndex].Description);
        }

        for (INT stateIndex = 0; 
             stateIndex < State_Count; 
             stateIndex++) 
        {
            if (!StateList[stateIndex].Enabled) 
                continue;

            _ftprintf(outfile, _T("\n%s\n\n"), StateList[stateIndex].Description);
            
            for (INT testIndex = 0; 
                 testIndex < Test_Count; 
                 testIndex++) 
            {
                if (!TestList[testIndex].Enabled) 
                    continue;

                if (ApiList[Api_Gdi].Enabled)
                {
                    _ftprintf(outfile, 
                              _T("%10.03f %10.03f  %2li %3li %s - %s\n"), 
                              results[ResultIndex(destinationIndex, Api_GdiPlus, stateIndex, testIndex)].Score,
                              results[ResultIndex(destinationIndex, Api_Gdi, stateIndex, testIndex)].Score,
                              TestList[testIndex].TestEntry->Priority,
                              TestList[testIndex].TestEntry->UniqueIdentifier,
                              TestList[testIndex].TestEntry->Description,
                              TestList[testIndex].TestEntry->Comment);
                }
                else
                {
                    _ftprintf(outfile, 
                              _T("%10.03f  %2li %3li %s %s\n"),
                              results[ResultIndex(destinationIndex, Api_GdiPlus, stateIndex, testIndex)].Score,
                              TestList[testIndex].TestEntry->Priority,
                              TestList[testIndex].TestEntry->UniqueIdentifier,
                              TestList[testIndex].TestEntry->Description,
                              TestList[testIndex].TestEntry->Comment);
                }
            }
        }
    }

    fclose(outfile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perfsuite.cpp ===
/******************************Module*Header*******************************\
* Module Name: perfsuite.cpp
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
* Contains the test prototypes and includes
*
\**************************************************************************/

#include "perftest.h"
#include <winuser.h>

/***************************************************************************\
* TestSuite::TestSuite
*
\***************************************************************************/

TestSuite::TestSuite()
{
}

/***************************************************************************\
* TestSuite::~TestSuite
*
\***************************************************************************/

TestSuite::~TestSuite()
{
}

/***************************************************************************\
* TestSuite::InitializeDestination
*
* Create the destination to be used by the tests.  Could be a particular
* format for the screen, a bitmap, or a DIB.
*
* Returns:
*
*   *bitmapResult - if a GDI+ Bitmap is to be used (use g.GetHDC() to draw
*                   to via GDI)
*   *hbitmapResult - if a GDI bitmap is to be used (use Graphics(hdc) to
*                   draw to via GDI+)
*   both NULL - if the screen is to be used
*
\***************************************************************************/

BOOL 
TestSuite::InitializeDestination(
    DestinationType destinationIndex,
    Bitmap **bitmapResult,
    HBITMAP *hbitmapResult
    )
{
    Graphics *g = NULL;
    HDC hdc = 0;
    INT screenDepth = 0;
    PixelFormat bitmapFormat = PixelFormatMax;
    ULONG *bitfields;
    Bitmap *bitmap;
    HBITMAP hbitmap;

    union 
    {
        BITMAPINFO bitmapInfo;
        BYTE padding[sizeof(BITMAPINFO) + 3*sizeof(RGBQUAD)];
    };

    // Clear all state remembered or returned:

    ModeSet = FALSE;
    
    bitmap = NULL;
    hbitmap = NULL;

    HalftonePalette = NULL;
    
    // Initialize our DIB format in case we use it:

    RtlZeroMemory(&bitmapInfo, sizeof(bitmapInfo));

    bitmapInfo.bmiHeader.biSize   = sizeof(BITMAPINFOHEADER);
    bitmapInfo.bmiHeader.biWidth  = TestWidth;
    bitmapInfo.bmiHeader.biHeight = TestHeight;
    bitmapInfo.bmiHeader.biPlanes = 1;
    bitfields = reinterpret_cast<ULONG*>(&bitmapInfo.bmiColors[0]);

    // First handle any destinations that need to change the color depth:

    switch (destinationIndex)
    {
    case Destination_Screen_Current:
        break;
    
    case Destination_Screen_800_600_8bpp_HalftonePalette:
        HalftonePalette = DllExports::GdipCreateHalftonePalette();
        if (!HalftonePalette)
        {
            return FALSE;
        }
        screenDepth = 8;
        break;
    
    case Destination_Screen_800_600_8bpp_DefaultPalette:
        screenDepth = 8;
        break;

    case Destination_Screen_800_600_16bpp:
        screenDepth = 16;
        break;

    case Destination_Screen_800_600_24bpp:
        screenDepth = 24;
        break;

    case Destination_Screen_800_600_32bpp:
        screenDepth = 32;
        break;

    case Destination_CompatibleBitmap_8bpp:

        // We want to emulate a compatible bitmap at 8bpp.  Because of palette
        // issues, we really have to switch to 8bpp mode to do that.

        screenDepth = 8;
        break;

    case Destination_DIB_15bpp:
        bitmapInfo.bmiHeader.biBitCount    = 16;
        bitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;
        bitfields[0]                       = 0x7c00;
        bitfields[1]                       = 0x03e0;
        bitfields[2]                       = 0x001f;
        break;

    case Destination_DIB_16bpp:
        bitmapInfo.bmiHeader.biBitCount    = 16;
        bitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;
        bitfields[0]                       = 0xf800;
        bitfields[1]                       = 0x07e0;
        bitfields[2]                       = 0x001f;
        break;

    case Destination_DIB_24bpp:
        bitmapInfo.bmiHeader.biBitCount    = 24;
        bitmapInfo.bmiHeader.biCompression = BI_RGB;
        break;

    case Destination_DIB_32bpp:
        bitmapInfo.bmiHeader.biBitCount    = 32;
        bitmapInfo.bmiHeader.biCompression = BI_RGB;
        break;

    case Destination_Bitmap_32bpp_ARGB:
        bitmapFormat = PixelFormat32bppARGB;
        break;
    
    case Destination_Bitmap_32bpp_PARGB:
        bitmapFormat = PixelFormat32bppPARGB;
        break;
        
    default:
        return FALSE;
    }

    // Now that we've figured out what to do, actually create our stuff:

    if (bitmapInfo.bmiHeader.biBitCount != 0)
    {
        // It's a DIB:

        VOID* drawBits;
        HDC hdcScreen = GetDC(NULL);
        hbitmap = CreateDIBSection(hdcScreen,
                                   &bitmapInfo,
                                   DIB_RGB_COLORS,
                                   (VOID**) &drawBits,
                                   NULL,
                                   0);
        ReleaseDC(NULL, hdcScreen);

        if (!hbitmap)
            return(FALSE);
    }
    else if (bitmapFormat != PixelFormatMax)
    {
        // It's a Bitmap:

        bitmap = new Bitmap(TestWidth, TestHeight, bitmapFormat);
        if (!bitmap)
            return(FALSE);
    }
    else
    {
        // It's to the screen (or a weird 8bpp compatible bitmap):
    
        if (screenDepth != 0)
        {
            // We have to do a mode change:

            DEVMODE devMode;
    
            devMode.dmSize       = sizeof(DEVMODE);
            devMode.dmBitsPerPel = screenDepth;
            devMode.dmPelsWidth  = TestWidth;
            devMode.dmPelsHeight = TestHeight;
            devMode.dmFields     = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
    
            // Note that we invoke CDS_FULLSCREEN to tell the system that
            // the mode change is temporary (and so that User won't resize
            // all the windows on the desktop):
    
            if (ChangeDisplaySettings(&devMode, CDS_FULLSCREEN) 
                    != DISP_CHANGE_SUCCESSFUL)
            {
                return(FALSE);
            }

            // Remember that the mode was set:

            ModeSet = TRUE;
            
            // Wait several seconds to allow other OS threads to page in and
            // repaint the task bar, etc.  We don't want that polluting our 
            // perf numbers.
     
            Sleep(5000);
        }
        
        // Handle that 8bpp comaptible bitmap special case:
        
        if (destinationIndex == Destination_CompatibleBitmap_8bpp)
        {
            HDC hdcScreen = GetDC(NULL);
            hbitmap = CreateCompatibleBitmap(hdcScreen, TestWidth, TestHeight);
            ReleaseDC(NULL, hdcScreen);

            if (!hbitmap)
                return(FALSE);
        }
    }

    *hbitmapResult = hbitmap;
    *bitmapResult = bitmap;

    return(TRUE);
}

/***************************************************************************\
* TestSuite::UninitializeDestination
*
\***************************************************************************/

VOID
TestSuite::UninitializeDestination(
    DestinationType destinationIndex,
    Bitmap *bitmap,
    HBITMAP hbitmap
    )
{
    if (ModeSet)
    {
        ChangeDisplaySettings(NULL, 0);
    }
    
    if (HalftonePalette)
    {
        DeleteObject(HalftonePalette);
    }

    DeleteObject(hbitmap);
    delete bitmap;
}

/***************************************************************************\
* TestSuite::InitializeApi
*
* If 'Api_GdiPlus', returns a 'Graphics*' that can be used to render to
* the specified surface.
*
* If 'Api_Gdi', returns an 'HDC' that can be use to render to the specified
* surface.
*
* The surface is tried in the following order:
*
*   1. Bitmap* (if non-NULL)
*   2. HBITMAP (if non-NULL)
*   3. HWND
*
\***************************************************************************/

BOOL
TestSuite::InitializeApi(
    ApiType apiIndex,
    Bitmap *bitmap,
    HBITMAP hbitmap,
    HWND hwnd,
    Graphics **gResult,
    HDC *hdcResult)
{
    Graphics *g = NULL;
    HDC hdc = NULL;

    OldPalette = NULL;
    
    if (bitmap != NULL)
    {
        g = new Graphics(bitmap);
        if (!g)
            return(FALSE);

        if (apiIndex == Api_Gdi)
        {
            hdc = g->GetHDC();
            if (!hdc)
            {
                delete g;
                return(FALSE);
            }
        }
    }
    else if (hbitmap != NULL)
    {
        HDC hdcScreen = GetDC(hwnd);
        hdc = CreateCompatibleDC(hdcScreen);
        SelectObject(hdc, hbitmap);
        ReleaseDC(hwnd, hdcScreen);

        if (apiIndex == Api_GdiPlus)
        {
            g = new Graphics(hdc);
            if (!g)
            {
                DeleteObject(hdc);
                return(FALSE);
            }
        }
    }
    else
    {
        
        hdc = GetDC(hwnd);
        if (!hdc)
            return(FALSE);

        if (HalftonePalette)
        {
            OldPalette = SelectPalette(hdc, HalftonePalette, FALSE);
            RealizePalette(hdc);   
        }
        
        if (apiIndex == Api_GdiPlus)
        {
            g = new Graphics(hdc);
            if (!g)
                return(FALSE);
        }
    }

    *gResult = g;
    *hdcResult = hdc;

    return(TRUE);
}

/***************************************************************************\
* TestSuite::UninitializeApi
*
\***************************************************************************/

VOID
TestSuite::UninitializeApi(
    ApiType apiIndex,
    Bitmap *bitmap,
    HBITMAP hbitmap,
    HWND hwnd,
    Graphics *g,
    HDC hdc)
{
    if (bitmap != NULL)
    {
        if (apiIndex == Api_Gdi)
            g->ReleaseHDC(hdc);

        delete g;
    }
    else if (hbitmap != NULL)
    {
        if (apiIndex == Api_GdiPlus)
            delete g;

        DeleteObject(hdc);
    }
    else
    {
        if (apiIndex == Api_GdiPlus)
            delete g;
        
        if (OldPalette)
        {
            SelectPalette(hdc, OldPalette, FALSE);
            OldPalette = NULL;
        }
        
        ReleaseDC(hwnd, hdc);
    }
}

/***************************************************************************\
* TestSuite::InitializeState
*
\***************************************************************************/

BOOL
TestSuite::InitializeState(
    ApiType apiIndex,
    StateType stateIndex,
    Graphics *g,
    HDC hdc)
{
    if (apiIndex == Api_GdiPlus)
    {
        SavedState = g->Save();
        if (!SavedState)
            return(FALSE);

        switch (stateIndex)
        {
        case State_Antialias:
            g->SetSmoothingMode(SmoothingModeAntiAlias);
            g->SetTextRenderingHint(TextRenderingHintAntiAlias); 
            break;
        }
    }
    else
    {
        // Do stuff to 'hdc'
    }

    return(TRUE);
}

/***************************************************************************\
* TestSuite::UninitializeState
*
\***************************************************************************/

VOID
TestSuite::UninitializeState(
    ApiType apiIndex,
    StateType stateIndex,
    Graphics *g,
    HDC hdc)
{
    if (apiIndex == Api_GdiPlus)
    {
        g->Restore(SavedState);
    }
    else
    {
        // Do stuff to 'hdc'
    }
}

/***************************************************************************\
* TestSuite::Run
*
\***************************************************************************/

void TestSuite::Run(HWND hwnd)
{
    INT i;
    Graphics *g;
    HDC hdc;
    INT destinationIndex;
    INT apiIndex;
    INT stateIndex;
    INT testIndex;
    TCHAR string[2048];
    Bitmap *bitmap;
    HBITMAP hbitmap;
    
    CurrentTestIndex=0;

    // Maximize the window:

    ShowWindow(hwnd, SW_MAXIMIZE);

    // Zero out the results matrix

    for (i = 0; i < ResultCount(); i++)
    {
        ResultsList[i].Score = 0;
    }

    // Go through the matrix of tests to find stuff to run

    for (destinationIndex = 0;
         destinationIndex < Destination_Count; 
         destinationIndex++)
    {
        if (!DestinationList[destinationIndex].Enabled)
            continue;

        if (!InitializeDestination((DestinationType) destinationIndex, &bitmap, &hbitmap))
            continue;

        for (apiIndex = 0;
             apiIndex < Api_Count;
             apiIndex++)
        {
            if (!ApiList[apiIndex].Enabled)
                continue;

            if (!InitializeApi((ApiType) apiIndex, bitmap, hbitmap, hwnd, &g, &hdc))
                continue;

            for (stateIndex = 0;
                 stateIndex < State_Count;
                 stateIndex++)
            {
                if (!StateList[stateIndex].Enabled)
                    continue;

                if (!InitializeState((ApiType) apiIndex, (StateType) stateIndex, g, hdc))
                    continue;
    
                for (testIndex = 0;
                     testIndex < Test_Count;
                     testIndex++)
                {
                    if (!TestList[testIndex].Enabled)
                        continue;
    
                    _stprintf(string, 
                              _T("[%s] [%s] [%s] [%s]"),
                              ApiList[apiIndex].Description,
                              DestinationList[destinationIndex].Description,
                              StateList[stateIndex].Description,
                              TestList[testIndex].TestEntry->Description);

                    SetWindowText(hwnd, string); 
                    
                    if (Icecap && FoundIcecap)
                    {
                        // Save the test information so that we can
                        // add it to the profile
                        
                        CurrentTestIndex++;

                        #if UNICODE
                            
                            WideCharToMultiByte(
                                CP_ACP,
                                0,
                                string,
                                -1,
                                CurrentTestDescription,
                                2048,
                                NULL,
                                NULL);

                        #else
                        
                            strncpy(CurrentTestDescription, string, 2048);

                        #endif
                    }

                    // Woo hoo, everything is now set up and we're ready
                    // to run a test!

                    if (apiIndex == Api_GdiPlus)
                    {
                        GraphicsState oldState = g->Save();

                        ResultsList[ResultIndex(destinationIndex, 
                                                apiIndex, 
                                                stateIndex, 
                                                testIndex)].Score
                            = TestList[testIndex].TestEntry->Function(g, NULL);

                        g->Restore(oldState);
                    }
                    else
                    {
                        SaveDC(hdc);

                        ResultsList[ResultIndex(destinationIndex, 
                                                apiIndex, 
                                                stateIndex, 
                                                testIndex)].Score
                            = TestList[testIndex].TestEntry->Function(NULL, hdc);

                        RestoreDC(hdc, -1);
                    }

                    // Copy the result to the screen if it was from a bitmap:

                    if (bitmap)
                    {
                        Graphics gScreen(hwnd);
                        gScreen.DrawImage(bitmap, 0, 0);
                    }
                    else if (hbitmap)
                    {
                        // This will use the source 'hdc', which may have a
                        // transform set on it.  Oh well!

                        HDC hdcScreen = GetDC(hwnd);
                        BitBlt(hdcScreen, 0, 0, TestWidth, TestHeight, hdc, 0, 0, SRCCOPY);
                        ReleaseDC(hwnd, hdcScreen);
                    }
                }

                UninitializeState((ApiType) apiIndex, (StateType) stateIndex, g, hdc);
            }

            UninitializeApi((ApiType) apiIndex, bitmap, hbitmap, hwnd, g, hdc);
        }

        UninitializeDestination((DestinationType) destinationIndex, bitmap, hbitmap);
    }

    // We're done!

    CreatePerformanceReport(ResultsList, ExcelOut);
}

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*
*  20-Jan-2000 [gilmanw]
* Removed code to set color table for 8bpp and less DIBs since calling
* code will not create such DIBs.
*
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
        {
            //
            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".
            //

            GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                      DIB_RGB_COLORS);
        }

        bRet = TRUE;

        DeleteObject(hbm);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* CreateCompatibleDIB2
*
* Create a DIB section with a optimal format w.r.t. the specified device.
*
* Parameters
*
*     hdc
*
*         Specifies display DC used to determine format.  Must be a direct DC
*         (not an info or memory DC).
*
*     width
*
*         Specifies the width of the bitmap.
*
*     height
*
*         Specifies the height of the bitmap.
*
* Return Value
*
*     The return value is the handle to the bitmap created.  If the function
*     fails, the return value is NULL.
*
* Comments
*
*     For devices that are <= 8bpp, a normal compatible bitmap is
*     created (i.e., CreateCompatibleBitmap is called).  I have a
*     different version of this function that will create <= 8bpp
*     DIBs.  However, DIBs have the property that their color table
*     has precedence over the palette selected into the DC whereas
*     a bitmap from CreateCompatibleBitmap uses the palette selected
*     into the DC.  Therefore, in the interests of keeping this
*     version as close to CreateCompatibleBitmap as possible, I'll
*     revert to CreateCompatibleBitmap for 8bpp or less.
*
* History:
*  19-Jan-2000 [gilmanw]
* Adapted original "fastdib" version for maximum compatibility with
* CreateCompatibleBitmap.
*
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP 
CreateCompatibleDIB2(HDC hdc, int width, int height)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Redirect 8 bpp or lower to CreateCompatibleBitmap.
    //

    if ( (GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES)) <= 8 )
    {
        return CreateCompatibleBitmap(hdc, width, height);
    }

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        return hbmRet;
    }

    memset(aj, 0, sizeof(aj));
    if ( bFillBitmapInfo(hdc, pbmi) )
    {
        VOID *pvBits;

        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = width;
        pbmi->bmiHeader.biHeight = height;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = width * height * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = width * height * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
    }

    return hbmRet;
}

////////////////////////////////////////////////////////////////////////
//
// Timer Utility Functions
//
////////////////////////////////////////////////////////////////////////

LONGLONG StartCounter;      // Timer global, to be set by StartTimer()

LONGLONG MinimumCount;      // Minimum number of performance counter ticks
                            //   that must elapse before a test is considered
                            //   'done'
                            
LONGLONG CountsPerSecond;   // Frequency of the performance counter

UINT Iterations;            // Timer global, to be set by StartTimer() and
                            //   incremented for every call to EndTimer()

UINT MinIterations;         // Minimum number of iterations of the test to
                            //   be done

/***************************************************************************\
* StartTimer
*
* Called by timing routine to start the timer.
*
\***************************************************************************/

void StartTimer()
{
    if (Icecap && FoundIcecap)
    {
        ICStartProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
        ICCommentMarkProfile(CurrentTestIndex, CurrentTestDescription);
    }

    // Disable the cursor so that it doesn't interfere with the timing:

    ShowCursor(FALSE);

    if (TestRender)
    {
        // Rig it so that we do only one iteration of the test.

        MinIterations = 0;
        MinimumCount = 0;
    }
    else
    {
        // Somewhat randomly choose 1 second as the minimum counter time:
    
        QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>(&CountsPerSecond));
        MinimumCount = CountsPerSecond;
    
        // Okay, start timing!
    
        Iterations = 0;
        QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&StartCounter));
    }
}

/***************************************************************************\
* EndTimer
*
* Called by timing routine to see if it's okay to stop timing.  Timing
* can stop if 2 conditions are satisfied:
*
*   1.  We've gone the minimum time duration (to ensure that we good
*       good accuracy from the timer functions we're using)
*   2.  We've done the minimum number of iterations (to ensure, if the
*       routine being timed is very very slow, that we do more than
*       one iteration)
*
\***************************************************************************/

BOOL EndTimer()
{
    LONGLONG counter;

    // Always do at least MIN_ITERATIONS iterations (and only check
    // the timer that frequently as well):

    Iterations++;
    if (Iterations & MinIterations)
        return(FALSE);

    // Query the performance counter, and bail if for some bizarre reason
    // this computer doesn't support a high resolution timer (which I think
    // all do now-a-days):

    if (!QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&counter)))
        return(TRUE);

    // Ensure that we get good timer accuracy by going for the minimum
    // amount of time:

    if ((counter - StartCounter) <= MinimumCount)
        return(FALSE);

    ShowCursor(TRUE);

    if (Icecap && FoundIcecap)
    {
        ICStopProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
    }

    // Okay, you can stop timing!

    return(TRUE);
}

/***************************************************************************\
* GetTimer
*
* Should only be called after EndTimer() returns TRUE.  Returns the
* time in seconds, and the number of iterations benchmarked.
*
\***************************************************************************/

void GetTimer(float* seconds, UINT* iterations)
{
    LONGLONG counter;

    // Note that we re-check the timer here to account for any
    // flushes that the caller may have needed to have done after
    // the EndTimer() call:

    QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&counter));

    if ((TestRender) || (CountsPerSecond == 0))
    {
        // Either the timer doesn't work, or we're doing a 'test render':

        *seconds = 1000000.0f;
        *iterations = 1;
    }
    else
    {
        // Woo hoo, we're done!

        *seconds = static_cast<float>(counter - StartCounter) / CountsPerSecond;
        *iterations = Iterations;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\perftext.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   perftext.cpp
*
* Abstract:
*
*   Contains all the tests for any routines that do text functionality.
*
\**************************************************************************/

#include "perftest.h"

WCHAR TestStringW[] = L"The quick brown fox jumps over the lazy dog.";
CHAR TestStringA[] = "The quick brown fox jumps over the lazy dog.";
INT TestString_Count = sizeof(TestStringW) / sizeof(TestStringW[0]) - 1;

float Text_Draw_PerCall_30pt_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        FontFamily fontFamily(L"Arial");
        Font font(&fontFamily, 30);
        StringFormat stringFormat(0);
        SolidBrush brush(Color::Red);
        PointF origin(0, 0);

        StartTimer();
    
        do {
            PointF origin(64, 64);
            g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, _T("Arial"));
        HGDIOBJ oldFont = SelectObject(hdc, font);

        SetTextColor(hdc, RGB(0xff, 0, 0));
        SetBkMode(hdc, TRANSPARENT);

        StartTimer();

        do {
            TextOut(hdc, 0, 0, _T("A"), 1);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);       // Calls per second
}

float Text_Draw_PerGlyph_30pt_Aliased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        FontFamily fontFamily(L"Arial");
        Font font(&fontFamily, 30);
        StringFormat stringFormat(0);
        SolidBrush brush(Color::Red);
        PointF origin(0, 0);

        // Don't count font realization towards per-glyph time:
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

        StartTimer();
    
        do {
            PointF origin(64, 64);
            g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, _T("Arial"));
        HGDIOBJ oldFont = SelectObject(hdc, font);

        SetTextColor(hdc, RGB(0xff, 0, 0));
        SetBkMode(hdc, TRANSPARENT);
        TextOutA(hdc, 0, 0, TestStringA, TestString_Count);

        StartTimer();

        do {
            TextOutA(hdc, 0, 0, TestStringA, TestString_Count);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerGlyph_30pt_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    // Don't count font realization towards per-glyph time:
    g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        g->SetTextRenderingHint(TextRenderingHintAntiAlias);

        FontFamily fontFamily(L"Arial");
        Font font(&fontFamily, 30);
        StringFormat stringFormat(0);
        SolidBrush brush(Color::Red);
        PointF origin(0, 0);

        StartTimer();
    
        do {
            PointF origin(64, 64);
            g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ANTIALIASED_QUALITY, 0, _T("Arial"));
        HGDIOBJ oldFont = SelectObject(hdc, font);

        SetTextColor(hdc, RGB(0xff, 0, 0));
        SetBkMode(hdc, TRANSPARENT);

        StartTimer();

        do {
            TextOut(hdc, 0, 0, _T("A"), 1);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    return(iterations / seconds / KILO);       // Calls per second
}

float Text_Draw_PerGlyph_30pt_Antialiased(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (g) 
    {
        g->SetTextRenderingHint(TextRenderingHintAntiAlias);

        FontFamily fontFamily(L"Arial");
        Font font(&fontFamily, 30);
        StringFormat stringFormat(0);
        SolidBrush brush(Color::Red);
        PointF origin(0, 0);

        // Don't count font realization towards per-glyph time:
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

        StartTimer();
    
        do {
            PointF origin(64, 64);
            g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);
    
        } while (!EndTimer());
    
        g->Flush(FlushIntentionSync);
    
        GetTimer(&seconds, &iterations);
    }
    else
    {
        HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ANTIALIASED_QUALITY, 0, _T("Arial"));
        HGDIOBJ oldFont = SelectObject(hdc, font);

        SetTextColor(hdc, RGB(0xff, 0, 0));
        SetBkMode(hdc, TRANSPARENT);
        TextOutA(hdc, 0, 0, TestStringA, TestString_Count);

        StartTimer();

        do {
            TextOutA(hdc, 0, 0, TestStringA, TestString_Count);

        } while (!EndTimer());

        GdiFlush();
    
        GetTimer(&seconds, &iterations);
    }

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerGlyph_30pt_Antialiased_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintAntiAlias);
    
    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    // Don't count font realization towards per-glyph time:
    g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_Antialiased_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintAntiAlias);

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_Cleartype(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);      // No accessible GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    SolidBrush brush(Color::Red);
    PointF origin(0, 0);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    return(iterations / seconds / KILO);       // Calls per second
}

float Text_Draw_PerGlyph_30pt_Cleartype(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0);      // No accessible GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    SolidBrush brush(Color::Red);
    PointF origin(0, 0);

    // Don't count font realization towards per-glyph time:
    g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerGlyph_30pt_Cleartype_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);
    
    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    // Don't count font realization towards per-glyph time:
    g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(TestStringW, TestString_Count, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

float Text_Draw_PerCall_30pt_Cleartype_LinearGradient(Graphics *g, HDC hdc)
{
    UINT iterations;
    float seconds;

    if (!g) return(0); // No GDI equivalent

    g->SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    FontFamily fontFamily(L"Arial");
    Font font(&fontFamily, 30);
    StringFormat stringFormat(0);
    LinearGradientBrush brush(Point(0, 0), Point(512, 512), Color::Red, Color::Blue);
    PointF origin(0, 0);

    StartTimer();

    do {
        PointF origin(64, 64);
        g->DrawString(L"A", 1, &font, origin, &stringFormat, &brush);

    } while (!EndTimer());

    g->Flush(FlushIntentionSync);

    GetTimer(&seconds, &iterations);

    UINT glyphs = TestString_Count * iterations;

    return(glyphs / seconds / KILO); // Kglyphs/s
}

////////////////////////////////////////////////////////////////////////////////
// Add tests for this file here.  Always use the 'T' macro for adding entries.
// The parameter meanings are as follows:
//
// Parameter
// ---------
//     1     UniqueIdentifier - Must be a unique number assigned to no other test
//     2     Priority - On a scale of 1 to 5, how important is the test?
//     3     Function - Function name
//     4     Comment - Anything to describe the test

Test TextTests[] = 
{
    T(4000, 1, Text_Draw_PerCall_30pt_Aliased, "Kcalls/s"),
    T(4001, 1, Text_Draw_PerGlyph_30pt_Aliased, "Kglyphs/s"),
    T(4002, 1, Text_Draw_PerCall_30pt_LinearGradient, "Kcalls/s"),
    T(4003, 1, Text_Draw_PerGlyph_30pt_LinearGradient, "Kglyphs/s"),
    T(4004, 1, Text_Draw_PerCall_30pt_Antialiased, "Kcalls/s"),
    T(4005, 1, Text_Draw_PerGlyph_30pt_Antialiased, "Kglyphs/s"),
    T(4006, 1, Text_Draw_PerCall_30pt_Antialiased_LinearGradient, "Kcalls/s"),
    T(4007, 1, Text_Draw_PerGlyph_30pt_Antialiased_LinearGradient, "Kglyphs/s"),
    T(4008, 1, Text_Draw_PerCall_30pt_Cleartype, "Kcalls/s"),
    T(4009, 1, Text_Draw_PerGlyph_30pt_Cleartype, "Kglyphs/s"),
    T(4010, 1, Text_Draw_PerCall_30pt_Cleartype_LinearGradient, "Kcalls/s"),
    T(4011, 1, Text_Draw_PerGlyph_30pt_Cleartype_LinearGradient, "Kglyphs/s"),
};

INT TextTests_Count = sizeof(TextTests) / sizeof(TextTests[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\quadtest\precomp.hpp ===
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <math.h>
#include <windows.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\pseudotest\test.cpp ===
//
// GDI+ test program
//

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <windows.h>
#include <objbase.h>
#include <tchar.h>
#include <Commctrl.h>

#include "Gdiplus.h"

// Use the given namespace
using namespace Gdiplus;

HINSTANCE appInstance;  // handle to the application instance
HWND hwndMain;          // handle to application's main window
HWND hStatusWnd;        // Status window

//
// Display an error message dialog and quit
//

VOID Error(PCSTR fmt,...)
{
    va_list arglist;
    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}

#define CHECKERROR(e) \
{ \
    if (!(e)) \
    { \
        Error("Error on line %d\n", __LINE__); \
    } \
}

//
// Perform GDI+ tests
//

VOID DrawImages(Graphics *g)
{
    RadialGradientBrush gradBrush2(
        RectF(0,0,200,200),
        Color(0,128,255),
        Color(200,20,97)
        );
    GraphicsPath aPath(FillModeWinding);
    aPath.AddRectangle(Rect(48,0,70,30));
/*
    aPath.AddRectangle(Rect(0,80,20,50));
    aPath.AddBezier(
        PointF(20,20),
        PointF(60,30),
        PointF(80,80),
        PointF(30,100));
*/
//    Region aRegion(&aPath);

    GraphicsPath aPath2;
    Region aRegion3(&aPath2);
    Region aRegion4(&aPath2);
    Region aRegion5(&aPath2);
    Region aRegion6(&aPath2);
    g->FillPath(&gradBrush2,&aPath);
//    aPath2.AddArc(140,100,30,50,50,77);
//    aPath2.AddPie(100,200,76,20,0,200);
//    Region aRegion2(&aPath2);
//    aPath2.AddLine(100,100,130,130);
//    aPath2.AddLine(130,130,200,225);
//    aPath2.AddRectangle(Rect(350,300,60,70));
//    aPath2.AddBezier(200,225,230,250,270,200,290,300);

/*    
    SolidBrush aBrush(Color (255,0,0));
    SolidBrush aBrush2(Color(20,40,250));
    SolidBrush aBrush3(Color(20,200,30));
    SolidBrush aBrush4(Color(140,200,250));
    SolidBrush aBrushA(Color(150,200,50,130));
    SolidBrush aBrushA2(Color(80,15,150,4));
    
    Bitmap bitmap(L"c:\\frisbee.bmp");
    TextureBrush aBrushBitmap(&bitmap);
    
    HatchBrush aHatchBrush(
        HatchStyleDiagonalCross,
        Color(0,255,0),
        Color(0,0,255));
    HatchBrush aHatchBrushT(
        HatchStyleDiagonalCross,
        Color(0,255,0),
        Color(0,0,0,0));
    
    RadialGradientBrush gradBrush(
        RectF(0,0,50,50),
        Color(255,0,255),
        Color(0,0,255)
        );
    RadialGradientBrush gradBrush2(
        RectF(0,0,200,200),
        Color(0,128,255),
        Color(200,20,97)
        );
    RadialGradientBrush gradBrushA(
        RectF(0,0,200,200),
        Color(80,0,0,255),
        Color(170,0,255,0)
        );
    RadialGradientBrush gradBrushHuge(
        RectF(0,0,400,400),
        Color(80,0,0,255),
        Color(170,0,255,0)
        );

    Color colors[4] = {
        Color(0,0,0),
        Color(255,0,0),
        Color(0,255,0),
        Color(0,0,255)
        };
    RectangleGradientBrush gradBrushRect(
        RectF(0,0,500,500),
        colors,
        WrapModeTile
        );
        
    Pen aPen(Color(40,80,160),3,UnitWorld);
    Pen aPen2(&gradBrushRect,8,UnitWorld);
    Pen aPen3(Color(0,0,0),0,UnitWorld);
    Pen aPen4(Color(0,0,0),15,UnitWorld);
    // aPen4.SetDashStyle(DashStyleDash);
    aPen4.SetLineCap(LineCapRound,LineCapRound,LineCapRound);

    GraphicsPath aPath(FillModeWinding);
    aPath.AddRectangle(Rect(48,0,70,30));
    aPath.AddRectangle(Rect(0,80,20,50));
    aPath.AddBezier(
        PointF(20,20),
        PointF(60,30),
        PointF(80,80),
        PointF(30,100));
    Region aRegion(&aPath);

    GraphicsPath aPath2;
    aPath2.AddArc(140,100,30,50,50,77);
    aPath2.AddPie(100,200,76,20,0,200);
    Region aRegion2(&aPath2);
    aPath2.AddLine(100,100,130,130);
    aPath2.AddLine(130,130,200,225);
    aPath2.AddRectangle(Rect(350,300,60,70));
    aPath2.AddBezier(200,225,230,250,270,200,290,300);
    Region aRegion3(&aPath2);
    
    Region aRegion4(&aPath2);
    aRegion4.Or(&aRegion);
*/
    
//    g->DrawPath(&aPen,&aPath);
//    g->FillPath(&gradBrush2,&aPath);
//    g->FillPath(&aBrush2,&aPath);
/*
    g->FillEllipse(&gradBrushA,20,40,150,130);
*/
/*
    g->FillRectangle(&gradBrushA,48,0,70,30);
    g->FillPath(&gradBrush2,&aPath);
    g->FillRectangle(&gradBrush,0,50,50,50);
    g->FillRectangle(&gradBrush,90,90,30,30);
    g->TranslateWorldTransform(50,50);
    g->FillRectangle(&gradBrushA,0,130,20,20);
*/
/*
    g->FillRectangle(&aBrushBitmap,0,0,400,400);
    g->FillRegion(&aBrush2,&aRegion4);
    g->TranslateWorldTransform(100,100);
    g->FillPath(&gradBrushRect,&aPath2);
*/
    //////////// Final Test Case ///////////////
/*
    g->FillRectangle(&gradBrushHuge,0,0,400,400);
    g->FillRectangle(&aBrushA2,0,81,30,20);
    g->FillRectangle(&aBrushA2,81,0,20,30);
    g->FillRectangle(&aBrushA,0,0,100,100);
    g->FillRectangle(&aBrushA,110,110,5,5);
    g->TranslateWorldTransform(50,50);
    g->FillPath(&gradBrush2,&aPath);
*/
    //////////// Solid Test Case ///////////////
/*
    g->FillRectangle(&aBrush3,0,0,400,400);
    g->FillRectangle(&aBrush2,0,81,30,20);
    g->FillRectangle(&aBrush2,81,0,20,30);
    g->FillRectangle(&aBrush,0,0,100,100);
    g->FillRectangle(&aBrush,110,110,5,5);
*/
/*
    g->TranslateWorldTransform(40,40);
    g->FillPath(&aBrush,&aPath);
    g->FillPath(&aBrush2,&aPath2);
    g->DrawPath(&aPen2,&aPath2);
    g->TranslateWorldTransform(110,35);
    g->FillPath(&aBrush3,&aPath);
    g->DrawPath(&aPen,&aPath);
    g->DrawEllipse(&aPen3,100,20,90,50);
    g->DrawRectangle(&aPen4,10,200,90,30);
    g->DrawBezier(&aPen4,10,300,80,360,180,350,250,280);
*/
}

VOID RecordMetafile(HWND hwnd)
{
    HDC aDC = GetDC(hwnd);
    Metafile *  recording = new Metafile(L"c:\\TestEmfP.Emf", 
        aDC, NULL, PageUnitInch, NULL);
    Graphics *  gMeta = Graphics::GetFromImage(recording);
    DrawImages(gMeta);
    delete gMeta;
    delete recording;
    ReleaseDC(hwnd,aDC);
}

VOID DoTest(HWND hwnd,HDC hdc)
{
    Graphics *  gScreen = Graphics::GetFromHwnd(hwnd);
    DrawImages(gScreen);
/*
    Metafile * playback = new Metafile(L"c:\\TestEmfP.Emf");
    GpRectF playbackRect;
    gScreen->GetVisibleClipBounds(playbackRect);
    playbackRect.Width -= 10;
    playbackRect.Height -= 10;

    gScreen->DrawImage(playback, playbackRect);
    delete playback;
*/

    delete gScreen;
}


//
// Window callback procedure
//

LRESULT CALLBACK
MainWndProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    static BOOL once = FALSE;

    switch (uMsg)
    {
    case WM_ACTIVATE:
        if (!once)
        {
            once = TRUE;
            RecordMetafile(hwnd);
        }
        break;
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;
            ps.fErase = TRUE;

            hdc = BeginPaint(hwnd, &ps);

            DoTest(hwnd, hdc);
            EndPaint(hwnd, &ps);
        }
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;
    _TCHAR classname[] = _T("PseudoTestClass");

    appInstance = GetModuleHandle(NULL);

    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = appInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) GetStockObject(WHITE_BRUSH);  
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = classname;

    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }

    hwndMain =
      CreateWindowEx(
        0,
        classname,
        _T("PseudoDriver Functionality Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_MAXIMIZE     |
        WS_SYSMENU,
        80,
        70,
        512,
        512,
        NULL,
        NULL,
        appInstance,
        NULL);

    if (hwndMain == NULL)
    {
        return(FALSE);
    }

/*
    hStatusWnd = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                     _T("Functionality Test App"),
                                     hwndMain,
                                     -1);
*/

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!bInitApp())
    {
        return(0);
    }
    ShowWindow(hwndMain,SW_RESTORE);

    haccel = LoadAccelerators(appInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\pseudotest\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\perftest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by perftest.rc
//
#define IDD_STARTDIALOG                 100
#define IDC_ACCURACY                    1000
#define IDC_OS                          1002
#define IDC_PROCESSOR                   1003
#define IDC_VDRIVER                     1004
#define IDC_FILE                        1005
#define IDC_RESLIST                     1006
#define IDC_HIGHPRIORITY                1007
#define IDC_FLUSH                       1008
#define IDC_EXCELOUT                    1009
#define IDC_ICECAP                      1010
#define IDC_SKIPLIST                    1012
#define IDC_TESTLIST                    1013
#define IDC_ADDTEST                     1014
#define IDC_DELTEST                     1015
#define IDC_DELALLTEST                  1016
#define IDC_ADDALLTEST                  1017
#define IDC_TESTRENDER                  1018
#define IDM_QUIT                        40000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         41000
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#define SAMPLE_BITMAP                   8000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\polytest\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991-2000 Microsoft Corporation
\***************************************************************************/

#define ACCELS 3
#define POLYTESTICON 4

#define MM_REDRAW                   0x8000
#define MM_TIME                     0x8001
#define MM_POINTS                   0x8002
                                    
#define MM_DRAW                     0x8100
#define MM_WIDENPATH                0x8101
#define MM_FILL                     0x8102
#define MM_POLYGON                  0x8103
#define MM_BEZIER                   0x8104
#define MM_RECTANGLE                0x8105
#define MM_ELLIPSE                  0x8106
#define MM_TEXTPATH                 0x8107
#define MM_LINES                    0x8108
                                    
#define MM_ANTIALIAS                0x8200
#define MM_WINDING                  0x8201
#define MM_SPINE                    0x8202
#define MM_GDI                      0x8203
#define MM_CLIPGRID                 0x8204
#define MM_RANDOMTEST               0x8205
#define MM_ANCHORS                  0x8206
#define MM_TRANSFORMOVERLAY         0x8207
#define MM_SCALINGONLY              0x8208
#define MM_RESETTRANSFORM           0x8209
#define MM_EDITTRANSFORM            0x820a
#define MM_GAMMACORRECT             0x820b
                                    
#define MM_WIDTH                    0x8300
#define MM_MITERLIMIT               0x8301
#define MM_CAP_ROUND                0x8302
#define MM_CAP_FLAT                 0x8303
#define MM_CAP_SQUARE               0x8304
#define MM_CAP_TRIANGLE             0x8305
#define MM_JOIN_ROUND               0x8306
#define MM_JOIN_BEVEL               0x8307
#define MM_JOIN_MITER               0x8308
#define MM_STYLE_SOLID              0x8309
#define MM_STYLE_DASH               0x830a
#define MM_STYLE_DOT                0x830b
#define MM_STYLE_DASHDOT            0x830c
#define MM_STYLE_DASHDOTDOT         0x830d
#define MM_ALPHA                    0x830e
#define MM_ALIGNMENT_CENTER         0x830f
#define MM_ALIGNMENT_INSET          0x8310
#define MM_COMPOUND                 0x8314
                                    
#define MM_BRUSH_SOLID              0x8400
#define MM_BRUSH_TEXTURE            0x8401
#define MM_BRUSH_TEXTURE_32x32      0x8402
#define MM_BRUSH_TEXTURE_1x1        0x8403
#define MM_BRUSH_LINEAR             0x8404
#define MM_BRUSH_PATHGRADIENT       0x8405
#define MM_WRAP_TILE                0x8406
#define MM_WRAP_CLAMP               0x8407
#define MM_WRAP_FLIPX               0x8408
#define MM_WRAP_FLIPY               0x8409
#define MM_WRAP_FLIPXY              0x840a
#define MM_DYNAMICBRUSHRECTANGLE    0x840b
#define MM_EDITBRUSHSHAPE           0x840c
                                
#define SAMPLE_BITMAP               0x9000
                                    
#define IDD_OK                      0xa000
#define IDD_WIDTH                   0xa001
#define IDD_ALPHA                   0xa002
                                    
#define IDD_POINT1X                 0xa003
#define IDD_POINT1Y                 0xa004
#define IDD_POINT2X                 0xa005
#define IDD_POINT2Y                 0xa006
#define IDD_POINT3X                 0xa007
#define IDD_POINT3Y                 0xa008
#define IDD_POINT4X                 0xa009
#define IDD_POINT4Y                 0xa00a
                                    
#define IDD_M11                     0xa100
#define IDD_M12                     0xa101
#define IDD_M21                     0xa102
#define IDD_M22                     0xa103
#define IDD_M31                     0xa104
#define IDD_M32                     0xa105
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\polytest\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains all the code necessary for a simple GDI+ primitive
* test.
*
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1991-2000 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <windows.h>
#include <objbase.h>
#include <mmsystem.h>
#include <gdiplus.h>

using namespace Gdiplus;

#include "wndstuff.h"

#include "../gpinit.inc"

#define HIT_DISTANCE 16
#define ABS(x) (((x) >= 0) ? (x) : -(x))
#define ROUND(x) ((INT) floor(x + 0.5f))

// We set the GDI transform to a 16x scaling transform, and the mode to
// GM_ADVANCED, so that we can get full fractional accuracy on the points
// that we feed to GDI:

#define GDI_FIXEDPOINT_SCALE 16

// State for tracking the primitive vertices and transform:

const INT PrimitivePointsMax = 64;
INT PrimitivePointsCount = 4;
PointF PrimitivePoints[PrimitivePointsMax] = { PointF(100, 100), 
                                               PointF(100, 400), 
                                               PointF(400, 400), 
                                               PointF(400, 100) };
Matrix *PrimitiveTransform;
Matrix *PrimitiveInverseTransform;
INT PrimitiveDragVertex = -1;
BOOL IsAddingPoints = FALSE;

// State for tracking the location of the transform overlay:

const REAL OverlayDimension = 100;
PointF OverlayPoints[3];            // 3 device-space representing overlay,
                                    //   where [1] is the elbow
PointF OverlayOffset;               // World-space coordinate of overlay elbow
INT OverlayDragVertex = -1;

// Miscellaneous state:

INT WindowWidth;
INT WindowHeight;

// Settings:

BOOL DoFill = FALSE;
BOOL DoDraw = TRUE;
BOOL DoAntialias = FALSE;
BOOL DoGammaCorrect = FALSE;
BOOL DoGdi = FALSE;
BOOL DoClipGrid = FALSE;
BOOL DoRandomTest = FALSE;
BOOL DoWindingFill = FALSE;
BOOL DoAnchors = TRUE;
BOOL DoSpine = FALSE;
BOOL DoWiden = FALSE;
BOOL DoCompound = FALSE;
BOOL DoTransformOverlay = FALSE;
BOOL DoScalingOnly = FALSE;
BOOL DoShape = FALSE;
BOOL DoBrushRect = FALSE;

REAL RenderMiterLimit = 10;
INT RenderWidth = 1;
INT RenderAlpha = 255;

LinearGradientBrush *LinearBrush;
GraphicsPath *PathGradientPath;

Brush *RenderBrush;
Pen *RenderPen;
Region *RenderRegion;

HRGN RenderHrgn;
HBRUSH RenderHbrush;
HPEN RenderHpen;

WORD MmWrapMode = MM_WRAP_TILE;
WORD MmBrushType = MM_BRUSH_SOLID;
WORD MmEndCap = MM_CAP_FLAT;
WORD MmJoin = MM_JOIN_MITER;
WORD MmDashStyle = MM_STYLE_SOLID;
WORD MmAlignment = MM_ALIGNMENT_CENTER;
WORD MmPrimitive = MM_POLYGON;

// Other useful globals:

HINSTANCE ghInstance;
HWND      ghwndMain;
HBRUSH    ghbrWhite;

//FARPROC glpfnEnterWidth;
//FARPROC glpfnEnterAlpha;
//FARPROC glpfnEnterPoints;
//FARPROC glpfnEnterTransform;

/***************************************************************************\
* Creates the GDI+ brush to be used.
*
\***************************************************************************/

VOID
CreateBrush_Gdiplus()
{
    WrapMode wrapMode;
    INT i;

    // Delete the old brush:

    delete RenderBrush;

    LinearBrush = NULL;
    RenderBrush = NULL;

    // Create the new one:

    Bitmap bitmap(L"winnt256.bmp");

    switch (MmWrapMode)
    {
    case MM_WRAP_TILE: wrapMode = WrapModeTile; break;
    case MM_WRAP_CLAMP: wrapMode = WrapModeClamp; break;
    case MM_WRAP_FLIPX: wrapMode = WrapModeTileFlipX; break;
    case MM_WRAP_FLIPY: wrapMode = WrapModeTileFlipY; break;
    case MM_WRAP_FLIPXY: wrapMode = WrapModeTileFlipXY; break;
    }

    switch (MmBrushType)
    {
    case MM_BRUSH_SOLID:
        RenderBrush = new SolidBrush(Color(128, 128, 128));
        break;

    case MM_BRUSH_TEXTURE:
        RenderBrush = new TextureBrush(&bitmap, wrapMode);
        break;

    case MM_BRUSH_TEXTURE_32x32:
        {
            Bitmap texture(32, 32, PixelFormat32bppARGB);
            Graphics g(&texture);
            g.DrawImage(&bitmap, Rect(0, 0, 32, 32));
    
            TextureBrush *brush = new TextureBrush(&texture, wrapMode);

            // Set a translate:

            Matrix matrix(1, 0, 0, 1, 100, 100);
            brush->SetTransform(&matrix);

            RenderBrush = brush;
        }
        break;

    case MM_BRUSH_TEXTURE_1x1:
        {
            SolidBrush solidBrush(Color::Green);
            Bitmap texture(1, 1, PixelFormat32bppARGB);
            Graphics g(&texture);
            g.FillRectangle(&solidBrush, 0, 0, 1, 1);

            TextureBrush *brush = new TextureBrush(&texture, wrapMode);

            // Set a translate:

            Matrix matrix(1, 0, 0, 1, 100, 100);
            brush->SetTransform(&matrix);

            RenderBrush = brush;
        }
        break;

    case MM_BRUSH_LINEAR:
        {
            LinearGradientBrush *brush = new LinearGradientBrush(
                Point(100, 100), 
                Point(100, 300),
                Color::Red, 
                Color::Black
            );
            brush->SetWrapMode(wrapMode);
    
            RenderBrush = brush;
            LinearBrush = brush;
        }
        break;

    case MM_BRUSH_PATHGRADIENT:
        {
            PathGradientBrush *brush;
            INT count;

            if (PathGradientPath != NULL)
            {
                brush = new PathGradientBrush(PathGradientPath);
                count = PathGradientPath->GetPointCount();
            }
            else
            {
                // Substitute a default path for now:

                PointF points[] = { PointF(100, 100), PointF(100, 300),
                                    PointF(300, 300), PointF(30, 100) };

                brush = new PathGradientBrush(points, 4);
                count = 4;
            }

            Color *colors = new Color[count];

            for (i = 0; i < count; i += 2)
            {
                colors[i] = Color::Green;
                colors[i+1] = Color::Red;
            }
            brush->SetSurroundColors(colors, &count);

            delete [] colors;
    
            brush->SetCenterPoint(OverlayOffset);
            brush->SetCenterColor(Color::Black);

            RenderBrush = brush;
        }
        break;
    }
}

/***************************************************************************\
* Creates the GDI brush to be used.
*
\***************************************************************************/

VOID
CreateBrush_Gdi()
{
    DeleteObject(RenderHbrush);

    RenderHbrush = CreateSolidBrush(RGB(128, 128, 128));
}

/***************************************************************************\
* Creates the GDI and GDI+ brushes to be used.
*
\***************************************************************************/

VOID
CreateBrushes()
{
    CreateBrush_Gdiplus();
    CreateBrush_Gdi();
}

/***************************************************************************\
* Creates the GDI+ pen to be used.
*
\***************************************************************************/

VOID
CreatePen_Gdiplus()
{
    DashCap dashCap;
    LineCap lineCap;
    LineJoin lineJoin;
    DashStyle dashStyle;
    PenAlignment alignment;

    delete RenderPen;

    RenderPen = new Pen(Color((BYTE) RenderAlpha, 255, 0, 0), (REAL) RenderWidth);

    switch (MmEndCap)
    {
    case MM_CAP_ROUND: lineCap = LineCapRound; dashCap = DashCapRound; break;
    case MM_CAP_SQUARE: lineCap = LineCapSquare; dashCap = DashCapFlat; break;
    case MM_CAP_FLAT: lineCap = LineCapFlat; dashCap = DashCapFlat; break;
    case MM_CAP_TRIANGLE: lineCap = LineCapTriangle; dashCap = DashCapTriangle; break;
    }
    RenderPen->SetEndCap(lineCap);
    RenderPen->SetStartCap(lineCap);
    RenderPen->SetDashCap(dashCap);

    switch (MmJoin)
    {
    case MM_JOIN_ROUND: lineJoin = LineJoinRound; break;
    case MM_JOIN_BEVEL: lineJoin = LineJoinBevel; break;
    case MM_JOIN_MITER: lineJoin = LineJoinMiter; break;
    }
    RenderPen->SetLineJoin(lineJoin);

    switch (MmDashStyle)
    {
    case MM_STYLE_SOLID: dashStyle = DashStyleSolid; break;
    case MM_STYLE_DASH: dashStyle = DashStyleDash; break;
    case MM_STYLE_DOT: dashStyle = DashStyleDot; break;
    case MM_STYLE_DASHDOT: dashStyle = DashStyleDashDot; break;
    case MM_STYLE_DASHDOTDOT: dashStyle = DashStyleDashDotDot; break;
    }
    RenderPen->SetDashStyle(dashStyle);

    switch (MmAlignment)
    {
    case MM_ALIGNMENT_CENTER: alignment = PenAlignmentCenter; break;
    case MM_ALIGNMENT_INSET: alignment = PenAlignmentInset; break;
    }
    RenderPen->SetAlignment(alignment);

    RenderPen->SetMiterLimit(RenderMiterLimit);

    // We should add a 'compound array' UI to make this more flexible.
    // But for now, we only ever create one type of compound line:

    if (DoCompound)
    {
        REAL compoundArray[] = { 0.0f, 0.2f, 0.8f, 1.0f };
        RenderPen->SetCompoundArray(compoundArray, 4);
    }
}

/***************************************************************************\
* Creates the GDI pen to be used.
*
\***************************************************************************/

VOID
CreatePen_Gdi()
{
    DWORD lineCap;
    DWORD lineJoin;
    DWORD dashStyle;
    LOGBRUSH logBrush;

    DeleteObject(RenderHpen);

    switch (MmEndCap)
    {
    case MM_CAP_ROUND: lineCap = PS_ENDCAP_ROUND; break;
    case MM_CAP_SQUARE: lineCap = PS_ENDCAP_SQUARE; break;
    case MM_CAP_FLAT: lineCap = PS_ENDCAP_FLAT; break;
    case MM_CAP_TRIANGLE: lineCap = PS_ENDCAP_SQUARE; break;    // No equivalent
    }

    switch (MmJoin)
    {
    case MM_JOIN_ROUND: lineJoin = PS_JOIN_ROUND; break;
    case MM_JOIN_BEVEL: lineJoin = PS_JOIN_BEVEL; break;
    case MM_JOIN_MITER: lineJoin = PS_JOIN_MITER; break;
    }

    switch (MmDashStyle)
    {
    case MM_STYLE_SOLID: dashStyle = PS_SOLID; break;
    case MM_STYLE_DASH: dashStyle = PS_DASH; break;
    case MM_STYLE_DOT: dashStyle = PS_DOT; break;
    case MM_STYLE_DASHDOT: dashStyle = PS_DASHDOT; break;
    case MM_STYLE_DASHDOTDOT: dashStyle = PS_DASHDOTDOT; break;
    }

    logBrush.lbStyle = BS_SOLID;
    logBrush.lbColor = RGB(255, 0, 0);
    logBrush.lbHatch = 0;

    RenderHpen = ExtCreatePen(lineCap | lineJoin | dashStyle | PS_GEOMETRIC,
                              GDI_FIXEDPOINT_SCALE * RenderWidth,
                              &logBrush,
                              0,
                              NULL);
}

/***************************************************************************\
* Creates the GDI+ and GDI pens to be used.
*
\***************************************************************************/

VOID
CreatePens()
{
    CreatePen_Gdiplus();
    CreatePen_Gdi();
}

/***************************************************************************\
* Creates the GDI+ clip region to be used.
*
\***************************************************************************/

VOID
CreateRegion_Gdiplus()
{
    INT x;
    INT y;

    delete RenderRegion;
    
    RenderRegion = new Region();
    
    for (x = 0; x < WindowWidth; x += 128)
    {
        for (y = 0; y < WindowHeight; y += 128)
        {
            RenderRegion->Exclude(Rect(x + 64, y, 64, 64));
            RenderRegion->Exclude(Rect(x, y + 64, 64, 64));
        }
    }
}

/***************************************************************************\
* Creates the GDI clip region to be used.
*
\***************************************************************************/

VOID
CreateRegion_Gdi()
{
    INT x;
    INT y;
    HRGN hrgn;

    DeleteObject(RenderHrgn);

    RenderHrgn = CreateRectRgn(0, 0, WindowWidth, WindowHeight);

    hrgn = CreateRectRgn(0, 0, 0, 0);

    for (x = 0; x < WindowWidth; x += 128)
    {
        for (y = 0; y < WindowHeight; y += 128)
        {
            SetRectRgn(hrgn, x + 64, y, x + 128, y + 64);
            CombineRgn(RenderHrgn, RenderHrgn, hrgn, RGN_DIFF);

            SetRectRgn(hrgn, x, y + 64, x + 64, y + 128);
            CombineRgn(RenderHrgn, RenderHrgn, hrgn, RGN_DIFF);
        }
    }

    DeleteObject(hrgn);
}

/***************************************************************************\
* Free all our global objects.
*
\***************************************************************************/

VOID
DeleteObjects_Gdiplus()
{
    delete RenderRegion;
    delete RenderBrush;
    delete RenderPen;

    delete PrimitiveTransform;
    delete PrimitiveInverseTransform;
}

/***************************************************************************\
* Free all our global objects.
*
\***************************************************************************/

VOID
DeleteObjects_Gdi()
{
    DeleteObject(RenderHrgn);
    DeleteObject(RenderHbrush);
    DeleteObject(RenderHpen);
}

/***************************************************************************\
* Draw the control points
*
\***************************************************************************/

VOID
DrawAnchors(
    Graphics *g,
    PointF* points,
    INT count
    )
{
    SolidBrush blueBrush(Color(150, 128, 128, 128));

    for (; count != 0; count--, points++)
    {
        PointF point(*points);

        PrimitiveTransform->TransformPoints(&point, 1);

        g->FillRectangle(&blueBrush, RectF(point.X - 2, point.Y - 2, 5, 5));
    }
}

/***************************************************************************\
* DrawTransformOverlay
*
\***************************************************************************/

VOID
DrawTransformOverlay(
    Graphics *g
    )
{
    Pen pen(Color::Purple, 1);
    SolidBrush brush(Color::Purple);

    g->DrawLine(&pen, OverlayPoints[1].X, OverlayPoints[1].Y,
                      OverlayPoints[0].X, OverlayPoints[0].Y);
    g->DrawLine(&pen, OverlayPoints[1].X, OverlayPoints[1].Y,
                      OverlayPoints[2].X, OverlayPoints[2].Y);

    g->FillRectangle(&brush, RectF(OverlayPoints[0].X - 2, 
                                   OverlayPoints[0].Y - 2, 
                                   5, 
                                   5));

    g->FillRectangle(&brush, RectF(OverlayPoints[2].X - 2, 
                                   OverlayPoints[2].Y - 2, 
                                   5, 
                                   5));
}

/***************************************************************************\
* Render_Gdiplus
*
\***************************************************************************/

INT
Render_Gdiplus(
    Graphics *g,
    PointF *points,
    INT count
    )
{
    INT i;
    INT pointsUsed;

//    if (DoBrushRect)
//    {
//        LinearBrush->SetLinearPoints(points[0], points[1]);
//    }

    RectF rect(points[0].X, points[0].Y, 
               points[1].X - points[0].X, points[1].Y - points[0].Y);

    Pen spinePen(Color(0, 128, 0), 0);
    GraphicsPath shapePath;

    switch (MmPrimitive)
    {
        case MM_POLYGON:
        {
            shapePath.AddPolygon(points, count);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillPolygon(RenderBrush, points, count, (DoWindingFill) 
                                                        ? FillModeWinding
                                                        : FillModeAlternate);
                if (DoDraw)
                    g->DrawPolygon(RenderPen, points, count);
                if (DoSpine)
                    g->DrawPolygon(&spinePen, points, count);
            }

            pointsUsed = count;
            break;
        }

        case MM_LINES:
        {
            shapePath.AddLines(points, count);
            if (!DoShape)
            {
                if (DoDraw)
                    g->DrawLines(RenderPen, points, count);
                if (DoSpine)
                    g->DrawLines(&spinePen, points, count);
            }

            pointsUsed = count;
            break;
        }
    
        case MM_BEZIER:
        {
            GraphicsPath path;
            path.AddBeziers(points, count);

            shapePath.AddPath(&path, FALSE);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillPath(RenderBrush, &path);
                if (DoDraw)
                    g->DrawPath(RenderPen, &path);
                if (DoSpine)
                    g->DrawPath(&spinePen, &path);
            }

            pointsUsed = count;
            break;
        }
    
        case MM_RECTANGLE:
        {
            shapePath.AddRectangle(rect);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillRectangle(RenderBrush, rect);
                if (DoDraw)
                    g->DrawRectangle(RenderPen, rect);
                if (DoSpine)
                    g->DrawRectangle(&spinePen, rect);
            }

            pointsUsed = 2;
            break;
        }
    
        case MM_ELLIPSE:
        {
            shapePath.AddEllipse(rect);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillEllipse(RenderBrush, rect);  
                if (DoDraw)
                    g->DrawEllipse(RenderPen, rect);
                if (DoSpine)
                    g->DrawEllipse(&spinePen, rect);
            }

            pointsUsed = 2;
            break;
        }
    
        case MM_TEXTPATH:
        {
            WCHAR string[] = L"GDI+ Rules!";
            GraphicsPath path((DoWindingFill) ? FillModeWinding
                                              : FillModeAlternate);

            FontFamily family(L"Times New Roman");
            PointF origin(points[0].X, points[0].Y);
    
            path.AddString(
                string, 
                wcslen(string), 
                &family, 
                0, 
                200, 
                origin, 
                NULL
            );

            shapePath.AddPath(&path, FALSE);
            if (!DoShape)
            {
                if (DoFill)
                    g->FillPath(RenderBrush, &path);
                if (DoDraw)
                    g->DrawPath(RenderPen, &path);
                if (DoSpine)
                    g->DrawPath(&spinePen, &path);
            }

            pointsUsed = 1;
            break;
        }
    }

    if (DoShape)
    {
        // Recreate the path to be use for the path-gradient brush, 
        // using the new shape data:

        delete PathGradientPath;
        PathGradientPath = shapePath.Clone();

        // Recreate the brush and do a complete fill of the window using
        // the specified brush:

        CreateBrushes();

        if (DoFill)
            g->FillRectangle(RenderBrush, -262144, -262144, 524288, 524288);
        if (DoDraw)
            g->DrawPath(RenderPen, &shapePath);
        if (DoSpine)
            g->DrawPath(&spinePen, &shapePath);
    }

    if (DoWiden)
    {
        Pen widenPen(Color::Black, 0);

        shapePath.Widen(RenderPen, NULL);

        g->DrawPath(&widenPen, &shapePath);
    }

    return(pointsUsed);
}

/***************************************************************************\
* Render_Gdi
*
\***************************************************************************/

INT
Render_Gdi(
    HDC hdc,
    PointF *primitivePoints,
    INT count
    )
{
    BOOL drawSpine;
    HGDIOBJ oldPen;
    HGDIOBJ oldBrush;
    HPEN hpenSpine;
    INT pointsUsed;
    POINT points[PrimitivePointsMax];
    INT i;

    // Convert to integer, the preferred GDI format.  Remember that we've
    // set the transform to scale down by 16, so we have to multiply by
    // 16 here.  We've done this so that we can specify 28.4 directly to
    // GDI:

    for (i = 0; i < count; i++)
    {
        points[i].x = ROUND(GDI_FIXEDPOINT_SCALE * primitivePoints[i].X);
        points[i].y = ROUND(GDI_FIXEDPOINT_SCALE * primitivePoints[i].Y);
    }

    hpenSpine = CreatePen(PS_SOLID, 0, RGB(0, 128, 0));

    for (drawSpine = FALSE; drawSpine != TRUE; drawSpine = TRUE)
    {
        if (drawSpine)
        {
            oldPen = SelectObject(hdc, hpenSpine);
            oldBrush = SelectObject(hdc, GetStockObject(NULL_BRUSH));
        }
        else
        {
            oldPen = SelectObject(hdc,                                             
                    (DoDraw) ? RenderHpen : GetStockObject(NULL_PEN));     
            oldBrush = SelectObject(hdc,                                           
                    (DoFill) ? RenderHbrush : GetStockObject(NULL_BRUSH)); 
        }

        switch (MmPrimitive)
        {
            case MM_POLYGON:
            {
                Polygon(hdc, points, count);

                pointsUsed = count;
                break;
            }

            case MM_LINES:
            {
                Polyline(hdc, points, count);

                pointsUsed = count;
                break;
            }
        
            case MM_BEZIER:
            {
                // Don't use StrokeAndFillPath because GDI would close the
                // stroke:

                BeginPath(hdc);
                PolyBezier(hdc, points, count);
                EndPath(hdc);
                FillPath(hdc);

                BeginPath(hdc);
                PolyBezier(hdc, points, count);
                EndPath(hdc);
                StrokePath(hdc);

                pointsUsed = count;
                break;
            }
        
            case MM_RECTANGLE:
            {
                Rectangle(hdc, points[0].x, points[0].y, points[1].x, points[1].y);

                pointsUsed = 2;
                break;
            }
        
            case MM_ELLIPSE:
            {
                Ellipse(hdc, points[0].x, points[0].y, points[1].x, points[1].y);

                pointsUsed = 2;
                break;
            }
        
            case MM_TEXTPATH:
            {
                LOGFONT logFont;
                memset(&logFont, 0, sizeof(logFont));

                // Don't forget to multiply the height by 16, because
                // we're using a scaling transform with GDI so that we
                // can spit out 28.4 coordinates:

                logFont.lfHeight = - GDI_FIXEDPOINT_SCALE * 200;   
                strcpy(logFont.lfFaceName, "Times New Roman");

                SetBkMode(hdc, TRANSPARENT);

                HFONT font = CreateFontIndirect(&logFont);
                HGDIOBJ oldFont = SelectObject(hdc, font);
    
                WCHAR string[] = L"GDI+ Rules!";
                BeginPath(hdc);
                ExtTextOutW(hdc, points[0].x, points[0].y, 0, NULL, string, 
                            wcslen(string), NULL);
                EndPath(hdc);
                StrokeAndFillPath(hdc);

                SelectObject(hdc, oldFont);
                DeleteObject(font);

                pointsUsed = 1;
            }
        }

        SelectObject(hdc, oldBrush);
        SelectObject(hdc, oldPen);
    }

    DeleteObject(hpenSpine);

    return(pointsUsed);
}

/***************************************************************************\
* PrepareContext_Gdiplus
*
\***************************************************************************/

VOID
PrepareContext_Gdiplus(
    Graphics *g
    )
{
    g->SetSmoothingMode((DoAntialias) ? SmoothingModeAntiAlias
                                      : SmoothingModeNone);
    
    g->SetCompositingQuality((DoGammaCorrect) ? 
        CompositingQualityGammaCorrected : CompositingQualityAssumeLinear);

    if (DoClipGrid)
    {
        g->SetClip(RenderRegion);
    }

    g->SetTransform(PrimitiveTransform);
}

/***************************************************************************\
* PrepareContext_Gdi
*
\***************************************************************************/

VOID
PrepareContext_Gdi(
    HDC hdc
    )
{
    REAL m[6];
    XFORM xform;

    SetMiterLimit(hdc, RenderMiterLimit, NULL);

    SetPolyFillMode(hdc, (DoWindingFill) ? WINDING : ALTERNATE);

    if (DoClipGrid)
    {
        SelectClipRgn(hdc, RenderHrgn);
    }

    // Setup the transform:

    PrimitiveTransform->GetElements(m);

    // Scale the transform down by 16 so that we can give GDI 28.4 
    // coordinates directly as integers:

    xform.eM11 = m[0] / GDI_FIXEDPOINT_SCALE;
    xform.eM12 = m[1] / GDI_FIXEDPOINT_SCALE;
    xform.eM21 = m[2] / GDI_FIXEDPOINT_SCALE;
    xform.eM22 = m[3] / GDI_FIXEDPOINT_SCALE;
    xform.eDx = m[4];
    xform.eDy = m[5];

    SetGraphicsMode(hdc, GM_ADVANCED);

    SetWorldTransform(hdc, &xform);
}

/***************************************************************************\
* GenerateRandomPoints
*
\***************************************************************************/

INT
GenerateRandomPoints(
    PointF *randomPoints,
    INT maxPoints
    )
{
    INT randomPointsCount;
    INT i;

    // Make 1 in 32 have lotsa randomPoints:

    if ((rand() & 31) == 0)
    {
        randomPointsCount = rand() & 511;
    }
    else
    {
        randomPointsCount = (rand() & 7) + 1;
    }

    randomPointsCount = min(randomPointsCount, maxPoints);

    // !!! Need to randomize

    switch (rand() & 3)
    {
    case 0:     // Trivially clipped
        for (i = 0; i < randomPointsCount; i++)
        {
            randomPoints[i].X = (rand() % (16 * WindowWidth * 16)) / 16.0f;
            randomPoints[i].Y = (rand() % (16 * WindowHeight)) / 16.0f;
        }
        break;

    case 1:     // Really small
        for (i = 0; i < randomPointsCount; i++)
        {
            randomPoints[i].X = (rand() & 127) / 16.0f + 32;
            randomPoints[i].Y = (rand() & 127) / 16.0f + 32;
        }
        break;

    default:     // Big space, with at least one point inside window:
        randomPoints[0].X = (rand() % (16 * WindowWidth)) / 16.0f;
        randomPoints[0].Y = (rand() % (16 * WindowHeight)) / 16.0f;

        if (0)
        {
            for (i = 1; i < randomPointsCount; i++)
            {
                // Once in a while, make the points REALLY REALLY big:

                randomPoints[i].X = (REAL) (rand() * rand() * rand());
                randomPoints[i].Y = (REAL) (rand() * rand() * rand());
            }
        }
        else
        {
            for (i = 1; i < randomPointsCount; i++)
            {
                randomPoints[i].X = (rand() % 1000000 - 500000) / 16.0f;
                randomPoints[i].Y = (rand() % 1000000 - 500000) / 16.0f;
            }
        }
        break;
    }

    return(randomPointsCount);
}

/***************************************************************************\
* Draw
*
\***************************************************************************/

VOID
Draw(
    HDC hdc,
    BOOL doTime = FALSE
    )
{
    CHAR stringBuffer[200];
    LONGLONG startCounter;
    LONGLONG endCounter;
    LONGLONG counterFrequency;
    INT pointsUsed;
    INT repetitions = (doTime) ? 10 : 1;
    INT i;

    // Clear the window:

    HGDIOBJ hbrush = GetStockObject(WHITE_BRUSH);
    HGDIOBJ holdBrush = SelectObject(hdc, hbrush);
    PatBlt(hdc, -10000, -10000, 20000, 20000, PATCOPY);
    SelectObject(hdc, holdBrush);
    DeleteObject(hbrush);

    QueryPerformanceCounter((LARGE_INTEGER*) &startCounter);

    // Draw the stuff:

    if (DoGdi)
    {
        SaveDC(hdc);

        PrepareContext_Gdi(hdc);

        for (i = 0; i < repetitions; i++)
        {
            pointsUsed = Render_Gdi(hdc, PrimitivePoints, PrimitivePointsCount);
        }

        RestoreDC(hdc, -1);
    }
    else
    {
        Graphics g(hdc);
        PrepareContext_Gdiplus(&g);

        if (!DoRandomTest)
        {
            for (i = 0; i < repetitions; i++)
            {
                pointsUsed = Render_Gdiplus(&g, PrimitivePoints, PrimitivePointsCount);
            }
        }
        else
        {
            PointF points[512];
            INT count;

            // To get faster 'test' rendering (by avoiding clears between
            // successive tests), always draw in a batch of '20':

            for (i = 0; i < 20; i++)
            {
                count = GenerateRandomPoints(points, 512);
                pointsUsed = Render_Gdiplus(&g, points, count);
            }
        }
    }

    // Display the time:

    QueryPerformanceCounter((LARGE_INTEGER*) &endCounter);
    QueryPerformanceFrequency((LARGE_INTEGER*) &counterFrequency);

    float seconds = (float)(endCounter - startCounter) / counterFrequency;
    INT milliseconds = (INT) (seconds * 1000 + 0.5f);

    if (doTime)
    {
        sprintf(stringBuffer, "%li repetitions: %li ms", repetitions, milliseconds);
    }
    else
    {
        sprintf(stringBuffer, "Rasterization time: %li ms", milliseconds);
    }

    SetBkMode(hdc, TRANSPARENT);
    ExtTextOut(hdc, 0, 0, 0, NULL, stringBuffer, strlen(stringBuffer), NULL);

    if (!DoRandomTest)
    {
        // Now that we're out of the timing loop, draw our control points:
    
        Graphics g(hdc);

        if (DoAnchors)
        {
            DrawAnchors(&g, PrimitivePoints, pointsUsed);
        }
    
        if (DoTransformOverlay)
        {
            DrawTransformOverlay(&g);
        }
    }
}

/***************************************************************************\
* EnterWidth
*
* Dialog for entering pen width.
\***************************************************************************/

INT_PTR EnterWidth(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    BOOL    bTrans;

    switch (message)
    {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDD_WIDTH, RenderWidth, TRUE);
        return(TRUE);

    case WM_COMMAND:
        if (wParam == IDD_OK)
        {
            RenderWidth = GetDlgItemInt(hDlg, IDD_WIDTH, &bTrans, TRUE);
            EndDialog(hDlg, wParam);
            InvalidateRect(ghwndMain, NULL, TRUE);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hDlg, IDD_WIDTH));
        return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************\
* EnterAlpha
*
* Dialog for entering pen alpha.
\***************************************************************************/

INT_PTR EnterAlpha(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    BOOL    bTrans;

    switch (message)
    {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDD_ALPHA, RenderAlpha, TRUE);
        return(TRUE);

    case WM_COMMAND:
        if (wParam == IDD_OK)
        {
            RenderAlpha = GetDlgItemInt(hDlg, IDD_ALPHA, &bTrans, TRUE);
            EndDialog(hDlg, wParam);
            InvalidateRect(ghwndMain, NULL, TRUE);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hDlg, IDD_ALPHA));
        return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************\
* EnterPoints
*
* Dialog for entering points.
\***************************************************************************/

INT_PTR EnterPoints(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    BOOL    bTrans;
    INT     i;

    switch (message)
    {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDD_POINT1X, ROUND(PrimitivePoints[0].X), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT1Y, ROUND(PrimitivePoints[0].Y), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT2X, ROUND(PrimitivePoints[1].X), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT2Y, ROUND(PrimitivePoints[1].Y), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT3X, ROUND(PrimitivePoints[2].X), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT3Y, ROUND(PrimitivePoints[2].Y), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT4X, ROUND(PrimitivePoints[3].X), TRUE);
        SetDlgItemInt(hDlg, IDD_POINT4Y, ROUND(PrimitivePoints[3].Y), TRUE);
        return(TRUE);

    case WM_COMMAND:
        if (wParam == IDD_OK)
        {
            PrimitivePoints[0].X = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT1X, &bTrans, TRUE);
            PrimitivePoints[0].Y = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT1Y, &bTrans, TRUE);
            PrimitivePoints[1].X = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT2X, &bTrans, TRUE);
            PrimitivePoints[1].Y = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT2Y, &bTrans, TRUE);
            PrimitivePoints[2].X = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT3X, &bTrans, TRUE);
            PrimitivePoints[2].Y = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT3Y, &bTrans, TRUE);
            PrimitivePoints[3].X = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT4X, &bTrans, TRUE);
            PrimitivePoints[3].Y = (REAL) (INT) GetDlgItemInt(hDlg, IDD_POINT4Y, &bTrans, TRUE);

            EndDialog(hDlg, wParam);
            InvalidateRect(ghwndMain, NULL, TRUE);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hDlg, IDD_POINT1X));
        return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************\
* EnterTransform
*
* Dialog for entering arbitrary transforms.
\***************************************************************************/

INT_PTR EnterTransform(
    HWND    hDlg,
    WORD    message,
    WPARAM  wParam,
    LONG    lParam)
{
    BOOL    bTrans;
    REAL    m[6];

    PrimitiveTransform->GetElements(m);

    switch (message)
    {
    case WM_INITDIALOG:
        SetDlgItemInt(hDlg, IDD_M11, ROUND(m[0] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M12, ROUND(m[1] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M21, ROUND(m[2] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M22, ROUND(m[3] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M31, ROUND(m[4] * 1000.0f), TRUE);
        SetDlgItemInt(hDlg, IDD_M32, ROUND(m[5] * 1000.0f), TRUE);
        return(TRUE);

    case WM_COMMAND:
        if (wParam == IDD_OK)
        {
            m[0] = ((INT) GetDlgItemInt(hDlg, IDD_M11, &bTrans, TRUE)) / 1000.0f;
            m[1] = ((INT) GetDlgItemInt(hDlg, IDD_M12, &bTrans, TRUE)) / 1000.0f;
            m[2] = ((INT) GetDlgItemInt(hDlg, IDD_M21, &bTrans, TRUE)) / 1000.0f;
            m[3] = ((INT) GetDlgItemInt(hDlg, IDD_M22, &bTrans, TRUE)) / 1000.0f;
            m[4] = ((INT) GetDlgItemInt(hDlg, IDD_M31, &bTrans, TRUE)) / 1000.0f;
            m[5] = ((INT) GetDlgItemInt(hDlg, IDD_M32, &bTrans, TRUE)) / 1000.0f;

            PrimitiveTransform->SetElements(m[0], m[1], m[2], m[3], m[4], m[5]);
            PrimitiveInverseTransform->SetElements(m[0], m[1], m[2], m[3], m[4], m[5]);
            PrimitiveInverseTransform->Invert();

            // Calculate the new world-space elbow location:

            OverlayOffset.X = OverlayPoints[1].X;
            OverlayOffset.Y = OverlayPoints[1].Y;
            PrimitiveInverseTransform->TransformPoints(&OverlayOffset);

            // Now calculate the new device-space end-points, by initializing
            // in world-space and then converting back to device-space:

            OverlayPoints[0].X = OverlayOffset.X + OverlayDimension;
            OverlayPoints[0].Y = OverlayOffset.Y;

            OverlayPoints[2].X = OverlayOffset.X;
            OverlayPoints[2].Y = OverlayOffset.Y - OverlayDimension;

            PrimitiveTransform->TransformPoints(&OverlayPoints[0]);
            PrimitiveTransform->TransformPoints(&OverlayPoints[2]);

            // We're done; force a redraw:

            EndDialog(hDlg, wParam);
            InvalidateRect(ghwndMain, NULL, TRUE);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hDlg, IDD_OK));
        return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************\
* ComputeOverlayTransformFromPoints
*
\***************************************************************************/

VOID
ComputeOverlayTransformFromPoints()
{
    REAL dx1 = OverlayPoints[0].X - OverlayPoints[1].X;
    REAL dy1 = OverlayPoints[0].Y - OverlayPoints[1].Y;

    REAL dx2 = OverlayPoints[1].X - OverlayPoints[2].X;
    REAL dy2 = OverlayPoints[1].Y - OverlayPoints[2].Y;

    REAL xMid = (REAL) (WindowWidth >> 1);
    REAL yMid = (REAL) (WindowHeight >> 1);

    RectF srcRect(OverlayOffset.X, OverlayOffset.Y, OverlayDimension, OverlayDimension);

    // The order is upper-left, upper-right, lower-left corner:

    PointF dstPoints[] = { PointF(xMid, yMid),
                           PointF(xMid + dx1, yMid + dy1),
                           PointF(xMid + dx2, yMid + dy2) };

    delete PrimitiveTransform;
    PrimitiveTransform = new Matrix(srcRect, dstPoints);

    delete PrimitiveInverseTransform;
    PrimitiveInverseTransform = PrimitiveTransform->Clone();
    PrimitiveInverseTransform->Invert();
}

/***************************************************************************\
* CreateOverlayTransform
*
\***************************************************************************/

VOID
CreateOverlayTransform()
{
    REAL xMid = (REAL) (WindowWidth >> 1);
    REAL yMid = (REAL) (WindowHeight >> 1);

    OverlayPoints[0].X = xMid + OverlayDimension;
    OverlayPoints[0].Y = yMid;
    OverlayPoints[1].X = xMid;
    OverlayPoints[1].Y = yMid;
    OverlayPoints[2].X = xMid;
    OverlayPoints[2].Y = yMid - OverlayDimension;

    OverlayOffset.X = xMid;
    OverlayOffset.Y = yMid;

    ComputeOverlayTransformFromPoints();
}

/***************************************************************************\
* UpdateOverlay
*
\***************************************************************************/

VOID
UpdateOverlay(
    REAL x,
    REAL y
    )
{
    if (OverlayDragVertex == 1)
    {
        // The root of the overlay is being moved, so we move the overlay
        // as a whole:

        REAL dx = x - OverlayPoints[1].X;
        REAL dy = y - OverlayPoints[1].Y;

        OverlayPoints[0].X += dx;
        OverlayPoints[0].Y += dy;
        OverlayPoints[1].X = x;
        OverlayPoints[1].Y = y;
        OverlayPoints[2].X += dx;
        OverlayPoints[2].Y += dy;
    }
    else
    {
        OverlayPoints[OverlayDragVertex].X = x;
        OverlayPoints[OverlayDragVertex].Y = y;

        ComputeOverlayTransformFromPoints();
    }
}

/***************************************************************************\
* RecenterOverlay
*
\***************************************************************************/

VOID
RecenterOverlay()
{
    REAL xMid = (REAL) (WindowWidth >> 1);
    REAL yMid = (REAL) (WindowHeight >> 1);

    REAL dx = xMid - OverlayPoints[1].X;
    REAL dy = yMid - OverlayPoints[1].Y;

    // Center the transform around the new world-space focus point:

    OverlayOffset.X = OverlayPoints[1].X;
    OverlayOffset.Y = OverlayPoints[1].Y;

    if (PrimitiveInverseTransform != NULL)
    {
        PrimitiveInverseTransform->TransformPoints(&OverlayOffset, 1);
    }

    // Bring the overlay control back to the middle of the screen:

    OverlayPoints[0].X += dx;
    OverlayPoints[0].Y += dy;
    OverlayPoints[1].X = xMid;
    OverlayPoints[1].Y = yMid;
    OverlayPoints[2].X += dx;
    OverlayPoints[2].Y += dy;

    ComputeOverlayTransformFromPoints();
}

/***************************************************************************\
* FindNearest
*
\***************************************************************************/

INT
FindNearest(
    REAL x,                         // Device space
    REAL y,
    const PointF *points,           // World space
    INT count,
    const Matrix *matrix = NULL     // World-to-device transform
    )
{
    INT i;
    REAL d;
    REAL minDistance;
    INT vertex;

    PointF inputPoint(x, y);

    // Find the nearest vertex, using a simple Manhattan metric.

    minDistance = 100000;

    for (i = 0; i < count; i++)
    {
        PointF point(points[i]);

        // For the distance metric, we want to be doing our calculations
        // in device space:

        if (matrix)
        {
            matrix->TransformPoints(&point, 1);
        }

        d = ABS(x - point.X) + ABS(y - point.Y);

        if (d < minDistance)
        {
            minDistance = d;
            vertex = i;
        }
    }

    return((minDistance < HIT_DISTANCE) ? vertex : -1);
}

/***************************************************************************\
* MainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LRESULT
MainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PointF point;
    LONG i;
    LONG d;
    LONG minDistance;
    LONG vertex;
    HDC hdc;
    PAINTSTRUCT ps;

    HMENU hmenu = GetMenu(hwnd);
    WORD mmCommand = LOWORD(wParam);

    switch (message)
    {
    case WM_CREATE:
        // NOTICE-DavePr@2002/05/28
        //   Missing FreeProcInstance for these anyway.

        //glpfnEnterWidth = (FARPROC) MakeProcInstance(EnterWidth, ghwndMain);
        //glpfnEnterAlpha = (FARPROC) MakeProcInstance(EnterAlpha, ghwndMain);
        //glpfnEnterPoints = (FARPROC) MakeProcInstance(EnterPoints, ghwndMain);
        //glpfnEnterTransform = (FARPROC) MakeProcInstance(EnterTransform, ghwndMain);

        SetTimer(hwnd, 1, 80, NULL);
        break;

    case WM_COMMAND:

        switch(mmCommand)
        {
        case MM_RANDOMTEST:
            DoRandomTest = !DoRandomTest;
            if (!DoRandomTest)
                InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_WIDTH:
            //DialogBox(ghInstance, "Width", ghwndMain, glpfnEnterWidth);
            DialogBox(ghInstance, "Width", ghwndMain, EnterWidth);
            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_ALPHA:
            //DialogBox(ghInstance, "Alpha", ghwndMain, glpfnEnterAlpha);
            DialogBox(ghInstance, "Alpha", ghwndMain, EnterAlpha);
            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_POINTS:
            //DialogBox(ghInstance, "Points", ghwndMain, glpfnEnterPoints);
            DialogBox(ghInstance, "Points", ghwndMain, EnterPoints);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_EDITTRANSFORM:
            //DialogBox(ghInstance, "Transform", ghwndMain, glpfnEnterTransform);
            DialogBox(ghInstance, "Transform", ghwndMain, EnterTransform);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_REDRAW:
            hdc = GetDC(hwnd);
            Draw(hdc);
            ReleaseDC(hwnd, hdc);
            break;

        case MM_TIME:
            hdc = GetDC(hwnd);
            Draw(hdc, TRUE);
            ReleaseDC(hwnd, hdc);
            break;

        case MM_CLIPGRID:
            DoClipGrid = !DoClipGrid;
            CheckMenuItem(hmenu, mmCommand, DoClipGrid ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_ANTIALIAS:
            DoAntialias = !DoAntialias;
            CheckMenuItem(hmenu, mmCommand, DoAntialias ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_GAMMACORRECT:
            DoGammaCorrect = !DoGammaCorrect;
            CheckMenuItem(hmenu, mmCommand, DoGammaCorrect ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_WINDING:
            DoWindingFill = !DoWindingFill;
            CheckMenuItem(hmenu, mmCommand, DoWindingFill ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_SPINE:
            DoSpine = !DoSpine;
            CheckMenuItem(hmenu, mmCommand, DoSpine ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_WIDENPATH:
            DoWiden = !DoWiden;
            CheckMenuItem(hmenu, mmCommand, DoWiden ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_ANCHORS:
            DoAnchors = !DoAnchors;
            CheckMenuItem(hmenu, mmCommand, DoAnchors ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_TRANSFORMOVERLAY:
            DoTransformOverlay = !DoTransformOverlay;
            CheckMenuItem(hmenu, mmCommand, DoTransformOverlay ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_SCALINGONLY:
            DoScalingOnly = !DoScalingOnly;
            CheckMenuItem(hmenu, mmCommand, DoScalingOnly ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_RESETTRANSFORM:
            CreateOverlayTransform();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_FILL:
            DoFill = !DoFill;
            CheckMenuItem(hmenu, mmCommand, DoFill ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_DRAW:
            DoDraw = !DoDraw;
            CheckMenuItem(hmenu, mmCommand, DoDraw ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_POLYGON:
        case MM_LINES:
        case MM_BEZIER:
        case MM_RECTANGLE:
        case MM_ELLIPSE:
        case MM_TEXTPATH:
            CheckMenuItem(hmenu, MmPrimitive, MF_UNCHECKED);
            MmPrimitive = mmCommand;
            CheckMenuItem(hmenu, MmPrimitive, MF_CHECKED);

            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_COMPOUND:
            DoCompound = !DoCompound;
            CheckMenuItem(hmenu, mmCommand, DoCompound ? MF_CHECKED : MF_UNCHECKED);
            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_STYLE_SOLID:
        case MM_STYLE_DASH:
        case MM_STYLE_DOT:
        case MM_STYLE_DASHDOT:
        case MM_STYLE_DASHDOTDOT:
            CheckMenuItem(hmenu, MmDashStyle, MF_UNCHECKED);
            MmDashStyle = mmCommand;
            CheckMenuItem(hmenu, MmDashStyle, MF_CHECKED);

            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_CAP_FLAT:
        case MM_CAP_SQUARE:
        case MM_CAP_ROUND:
        case MM_CAP_TRIANGLE:
            CheckMenuItem(hmenu, MmEndCap, MF_UNCHECKED);
            MmEndCap = mmCommand;
            CheckMenuItem(hmenu, MmEndCap, MF_CHECKED);

            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_JOIN_ROUND:
        case MM_JOIN_MITER:
        case MM_JOIN_BEVEL:
            CheckMenuItem(hmenu, MmJoin, MF_UNCHECKED);
            MmJoin = mmCommand;
            CheckMenuItem(hmenu, MmJoin, MF_CHECKED);

            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_ALIGNMENT_CENTER: 
        case MM_ALIGNMENT_INSET: 
            CheckMenuItem(hmenu, MmAlignment, MF_UNCHECKED);
            MmAlignment = mmCommand;
            CheckMenuItem(hmenu, MmAlignment, MF_CHECKED);

            CreatePens();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_WRAP_TILE:
        case MM_WRAP_CLAMP:
        case MM_WRAP_FLIPX:
        case MM_WRAP_FLIPY:
        case MM_WRAP_FLIPXY:
            CheckMenuItem(hmenu, MmWrapMode, MF_UNCHECKED);
            MmWrapMode = mmCommand;
            CheckMenuItem(hmenu, MmWrapMode, MF_CHECKED);

            CreateBrushes();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_BRUSH_SOLID:
        case MM_BRUSH_TEXTURE:
        case MM_BRUSH_TEXTURE_32x32:
        case MM_BRUSH_TEXTURE_1x1:
        case MM_BRUSH_LINEAR:
        case MM_BRUSH_PATHGRADIENT:
            CheckMenuItem(hmenu, MmBrushType, MF_UNCHECKED);
            MmBrushType = mmCommand;
            CheckMenuItem(hmenu, MmBrushType, MF_CHECKED);

            CreateBrushes();
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_DYNAMICBRUSHRECTANGLE:
            DoBrushRect = !DoBrushRect;
            CheckMenuItem(hmenu, mmCommand, DoBrushRect ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_EDITBRUSHSHAPE:
            DoShape = !DoShape;
            CheckMenuItem(hmenu, mmCommand, DoShape ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case MM_GDI:
            DoGdi = !DoGdi;
            CheckMenuItem(hmenu, mmCommand, DoGdi ? MF_CHECKED : MF_UNCHECKED);
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        default:
            break;
        }
        break;

    case WM_SIZE:
        WindowWidth = (short)LOWORD(lParam);
        WindowHeight = (short)HIWORD(lParam);

        CreateRegion_Gdiplus();
        CreateRegion_Gdi();
        RecenterOverlay();

        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_LBUTTONDOWN:
        point.X = (REAL)(short)LOWORD(lParam);
        point.Y = (REAL)(short)HIWORD(lParam);

        // First, try to find a hit with the overlay.  Then try a hit with
        // the primitive points, in world space:

        OverlayDragVertex = -1;
        PrimitiveDragVertex = -1;

        if (DoTransformOverlay)
        {
            OverlayDragVertex = FindNearest(point.X, point.Y, OverlayPoints, 3);
        }

        if (OverlayDragVertex == -1)
        {
            PrimitiveDragVertex = FindNearest(point.X, point.Y, PrimitivePoints, 
                                  PrimitivePointsCount, PrimitiveTransform);
        }

        // The first left-click disables 'adding points' mode:

        IsAddingPoints = FALSE;

        break;

    case WM_RBUTTONDOWN:
        point.X = (REAL)(short)LOWORD(lParam);
        point.Y = (REAL)(short)HIWORD(lParam);
        PrimitiveInverseTransform->TransformPoints(&point, 1);

        // If we were in 'adding points' mode (which occurs when we're
        // right-clicking in succession), simply add the point to the
        // list.  
        //
        // If we're not in 'adding points' mode, reset the point list 
        // and switch us to 'adding points' mode:

        if (!IsAddingPoints)
        {
            IsAddingPoints = TRUE;
            PrimitivePointsCount = 0;
        }

        // Add this point to the list:

        if (PrimitivePointsCount < PrimitivePointsMax)
        {
            PrimitivePoints[PrimitivePointsCount] = point;
            PrimitivePointsCount++;

            // If this was the first point, make all the points the same
            // (in part to make 'ellipse' and 'rectangle' properly empty):

            if (PrimitivePointsCount == 1)
            {
                for (i = 1; i < PrimitivePointsMax; i++)
                {
                    PrimitivePoints[i] = PrimitivePoints[0];
                }
            }

            hdc = GetDC(hwnd);
            Draw(hdc);
            ReleaseDC(hwnd, hdc);
        }

        break;

    case WM_MOUSEMOVE:
        point.X = (REAL)(short)LOWORD(lParam);
        point.Y = (REAL)(short)HIWORD(lParam);

        // Overlay hit-testing works in screen space:
        
        if (OverlayDragVertex != -1)
        {
            // To prevent extraneous redraws, redraw only if the new point
            // is different:

            if ((OverlayPoints[OverlayDragVertex].X != point.X) ||
                (OverlayPoints[OverlayDragVertex].Y != point.Y))
            {
                UpdateOverlay(point.X, point.Y);
    
                hdc = GetDC(hwnd);
                Draw(hdc);
                ReleaseDC(hwnd, hdc);
            }
        }

        // Primitive hit-testing works in world space:

        PrimitiveInverseTransform->TransformPoints(&point, 1);

        if (PrimitiveDragVertex != -1)
        {
            // To prevent extraneous redraws, redraw only if the new point
            // is different:

            if ((PrimitivePoints[PrimitiveDragVertex].X != point.X) ||
                (PrimitivePoints[PrimitiveDragVertex].Y != point.Y))
            {
                PrimitivePoints[PrimitiveDragVertex] = point;
    
                hdc = GetDC(hwnd);
                Draw(hdc);
                ReleaseDC(hwnd, hdc);
            }
        }
        
        break;

    case WM_LBUTTONUP:
        PrimitiveDragVertex = -1;
        OverlayDragVertex = -1;

        RecenterOverlay();
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        Draw(hdc);
        ReleaseDC(hwnd, hdc);

        break;

    case WM_TIMER:
        if (DoRandomTest)
        {
            hdc = GetDC(hwnd);
            Draw(hdc);
            ReleaseDC(hwnd, hdc);
        }

        break;

    case WM_DESTROY:
        DeleteObjects_Gdiplus();
        DeleteObjects_Gdi();

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/***************************************************************************\
* InitializeApplication()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL InitializeApplication(VOID)
{
    WNDCLASS wc;

    ghbrWhite = (HBRUSH) GetStockObject(WHITE_BRUSH);

    wc.style            = 0;
    wc.lpfnWndProc      = MainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(ghInstance, MAKEINTRESOURCE(POLYTESTICON));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = "MainMenu";
    wc.lpszClassName    = "TestClass";
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        "TestClass",
        "PolyTest",
        (                      
            WS_OVERLAPPED   |  
            WS_CAPTION      |  
            WS_BORDER       |  
            WS_THICKFRAME   |  
            WS_MAXIMIZEBOX  |  
            WS_MINIMIZEBOX  |  
            WS_CLIPCHILDREN |  
            WS_VISIBLE      |  
            WS_SYSMENU         
        ),
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL
        );
    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);

    // Create our initialize stuff:

    CreateBrushes();
    CreatePens();
    CreateOverlayTransform();

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;
    CHAR*  pSrc;
    CHAR*  pDst;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    ghInstance = GetModuleHandle(NULL);

    if (!InitializeApplication())
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(ACCELS));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\samples\shapes\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

extern void LBprintf(PCH, ...);
extern void LBreset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\quadtest\resource.h ===
#define IDM_MAINMENU            1000
#define     IDC_TOGGLEMESH      1001
#define     IDC_RESETMESH       1002
#define     IDC_SHRINKTOFIT     1003
#define     IDC_DENSEMESH       1004
#define     IDC_SPARSEMESH      1005
#define     IDC_LIVEFEEDBACK    1006
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\reversi\reversi.h ===
#define BoardSize           100 
#define edge                0
#define empty               1
#define human               2
#define computer            3
#define infin               32767
#define win                 32000
#define loss                (-32000)
#define max_depth           6

#define PASS                20
#define NEW                 25
#define BSkill              40
#define EASY                41
#define MEDIUM              42
#define HARD                44
#define VHARD               46
#define HINT                50
#define EXIT                52


/* Menu ID's */

#define MN_HELP_INDEX       30
#define MN_HELP_KEYBOARD    31
#define MN_HELP_COMMANDS    32
#define MN_HELP_PLAYING     33
#define MN_HELP_RULES       34
#define MN_HELP_USINGHELP   35
#define MN_HELP_ABOUT       36
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\quadtest\quadtest.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   QuadTest.cpp
*
* Abstract:
*
*   Test app for quad transform
*
* Usage:
*   QuadTest
*
*
* Revision History:
*
*   03/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <windows.h>
#include <objbase.h>

#include <gdiplus.h>

// Use the given namespace
using namespace Gdiplus;

CHAR* programName;          // program name
HINSTANCE appInstance;      // handle to the application instance
HWND hwndMain;              // handle to application's main window
SIZE srcSize;               // source bitmap size
SIZE dstSize;               // destination bitmap size
SIZE wndSizeExtra;          // extra pixels for window decorations
BOOL isDragging = FALSE;    // used to handle mouse dragging
INT knobSize = 6;           // mesh control point knob size

BOOL showMesh = TRUE;

POINT pts[5];
INT   index = -1;
Rect srcRect;
Point ptsF[5];
Point pt00, pt10, pt20, pt30;
Point bPts[4];

class QuadGraphics : public Graphics
{
public:

    QuadGraphics(HDC hdc) : Graphics(hdc)
    {
    }

    QuadGraphics(HWND hwnd) : Graphics(hwnd)
    {
    }

    Status DrawWarpedLine(
        const Pen* pen,
        Point& pt1,
        Point& pt2,
        Point* points,
        INT count,
        Rect srcRect
        )
    {
        return SetStatus(DllExports::GdipDrawWarpedLine(
                GetNativeGraphics(),
                GetNativePen(pen),
                pt1.X,
                pt1.Y,
                pt2.X,
                pt2.Y,
                points,
                count,
                &srcRect
                )
            );
    }
    
    Status DrawWarpedBezier(
        const Pen* pen,
        Point& pt1,
        Point& pt2,
        Point& pt3,
        Point& pt4,
        Point* points,
        INT count,
        Rect srcRect
        )
    {
        return SetStatus(DllExports::GdipDrawWarpedBezier(
                GetNativeGraphics(),
                GetNativePen(pen),
                pt1.X,
                pt1.Y,
                pt2.X,
                pt2.Y,
                pt3.X,
                pt3.Y,
                pt4.X,
                pt4.Y,
                points,
                count,
                &srcRect
                )
            );
    }
};

//
// Display an error message dialog and quit
//

VOID
Error(
    const CHAR* fmt,
    ...
    )

{
    va_list arglist;

    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}


//
// Create a new mesh object
//

VOID
CreateMesh()
{
    srcSize.cx = 300;
    srcSize.cy = 300;

    dstSize = srcSize;
    INT offset = 10;
    pts[0].x = offset;
    pts[0].y = offset;
    pts[1].x = srcSize.cx - offset;
    pts[1].y = offset;
    pts[2].x = srcSize.cx - offset;
    pts[2].y = srcSize.cy - offset;
    pts[3].x = offset;
    pts[3].y = srcSize.cy - offset;
    pts[4] = pts[0];

    srcRect.X = (REAL) pts[0].x;
    srcRect.Y = (REAL) pts[0].y;
    srcRect.Width = (REAL) pts[2].x - pts[0].x;
    srcRect.Height = (REAL) pts[2].y - pts[0].y;

    ptsF[0].X = (REAL) pts[0].x;
    ptsF[0].Y = (REAL) pts[0].y;
    ptsF[1].X = (REAL) pts[1].x;
    ptsF[1].Y = (REAL) pts[1].y;
    ptsF[2].X = (REAL) pts[3].x;
    ptsF[2].Y = (REAL) pts[3].y;
    ptsF[3].X = (REAL) pts[2].x;
    ptsF[3].Y = (REAL) pts[2].y;

    pt00 = ptsF[0];
    pt10 = ptsF[1];
    pt20 = ptsF[2];
    pt30 = ptsF[3];

    bPts[0].X = (REAL) 2*offset;
    bPts[0].Y = (REAL) srcSize.cy/2;
    bPts[1].X = (REAL) srcSize.cx/2;
    bPts[1].Y = 0;
    bPts[2].X = (REAL) srcSize.cx;
    bPts[2].Y = (REAL) srcSize.cy/2;
    bPts[3].X = (REAL) 3*srcSize.cx/4;
    bPts[3].Y = (REAL) 3*srcSize.cy/4;
}

//
// Draw mesh
//

#define MESHCOLOR   RGB(255, 0, 0)

VOID
DrawMesh(
    HDC hdc
    )
{
    static HPEN meshPen = NULL;
    static HBRUSH meshBrush = NULL;

    if (meshPen == NULL)
        meshPen = CreatePen(PS_SOLID, 1, MESHCOLOR);

    SelectObject(hdc, meshPen);

    // Draw horizontal meshes

    INT i, j, rows, cols, pointCount;
    POINT* points;

    // Draw knobs

    // Create the brush to draw the mesh if necessary

    if (meshBrush == NULL)
        meshBrush = CreateSolidBrush(MESHCOLOR);

    Polyline(hdc, pts, 5);
    
    for (j=0; j < 4; j++)
    {
        RECT rect;

        rect.left = pts[j].x - knobSize/2;
        rect.top = pts[j].y - knobSize/2;
        rect.right = rect.left + knobSize;
        rect.bottom = rect.top + knobSize;

        FillRect(hdc, &rect, meshBrush);

    }
}


VOID
DoGDIPlusDrawing(
    HWND hwnd,
    HDC hdc
    )
{

//    QuadGraphics *g = Graphics::GetFromHwnd(hwnd);
    QuadGraphics *g = new QuadGraphics(hwnd);

    REAL width = 1;
    Color color(0, 0, 0);
    SolidBrush brush(color);
    Pen pen(&brush, width);

    ptsF[0].X = (REAL) pts[0].x;
    ptsF[0].Y = (REAL) pts[0].y;
    ptsF[1].X = (REAL) pts[1].x;
    ptsF[1].Y = (REAL) pts[1].y;
    ptsF[2].X = (REAL) pts[3].x;
    ptsF[2].Y = (REAL) pts[3].y;
    ptsF[3].X = (REAL) pts[2].x;
    ptsF[3].Y = (REAL) pts[2].y;

    g->DrawWarpedLine(&pen, pt00, pt30, ptsF, 4, srcRect);
    g->DrawWarpedLine(&pen, pt10, pt20, ptsF, 4, srcRect);
    g->DrawWarpedBezier(&pen, bPts[0], bPts[1], bPts[2], bPts[3],
                    ptsF, 4, srcRect);
    delete g;
}

//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )

{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    INT width, height;

    // Determine if we need to perform warping operation

    GetClientRect(hwnd, &rect);
    width = rect.right;
    height = rect.bottom;

    hdc = BeginPaint(hwnd, &ps);

    HBRUSH brush = CreateSolidBrush(RGB(255, 255, 255));
    HBRUSH savedBrush = (HBRUSH) SelectObject(hdc, brush);
    Rectangle(hdc, 0, 0, width, height);

    DoGDIPlusDrawing(hwnd, hdc);

    // Draw to offscreen DC to reduce flashing

    DrawMesh(hdc);
    SelectObject(hdc, savedBrush);
    DeleteObject(brush);

    EndPaint(hwnd, &ps);
}


//
// Handle WM_SIZING message
//

BOOL
DoWindowSizing(
    HWND hwnd,
    RECT* rect,
    INT side
    )

{
    INT w = rect->right - rect->left - wndSizeExtra.cx;
    INT h = rect->bottom - rect->top - wndSizeExtra.cy;

    if (w >= srcSize.cx && h >= srcSize.cy)
        return FALSE;

    // Window width is too small

    if (w < srcSize.cx)
    {
        INT dx = srcSize.cx + wndSizeExtra.cx;

        switch (side)
        {
        case WMSZ_LEFT:
        case WMSZ_TOPLEFT:
        case WMSZ_BOTTOMLEFT:
            rect->left = rect->right - dx;
            break;
        
        default:
            rect->right = rect->left + dx;
            break;
        }
    }

    // Window height is too small

    if (h < srcSize.cy)
    {
        INT dy = srcSize.cy + wndSizeExtra.cy;

        switch (side)
        {
        case WMSZ_TOP:
        case WMSZ_TOPLEFT:
        case WMSZ_TOPRIGHT:
            rect->top = rect->bottom - dy;
            break;
        
        default:
            rect->bottom = rect->top + dy;
            break;
        }
    }

    return TRUE;
}


//
// Handle left mouse-down event
//

VOID
DoMouseDown(
    HWND hwnd,
    INT x,
    INT y
    )

{
    // Figure out if the click happened in a mesh control knob

    INT i, j, rows, cols;
    POINT pt;
    RECT rect;

    GetClientRect(hwnd, &rect);

    for(i = 0; i < 4; i++)
    {
        pt = pts[i];
        pt.x -= knobSize/2;
        pt.y -= knobSize/2;

        if (x >= pt.x && x < pt.x+knobSize &&
            y >= pt.y && y < pt.y+knobSize)
        {
            index = i;
            SetCapture(hwnd);
            isDragging = TRUE;
            return;
        }
    }

    index = -1;

}


//
// Handle mouse-move event
//

VOID
DoMouseMove(
    HWND hwnd,
    INT x,
    INT y
    )

{
    // We assume isDragging is true here.

    RECT rect;
    INT w, h;

    GetClientRect(hwnd, &rect);
    w = rect.right;
    h = rect.bottom;

    if (x < 0 || x >= w || y < 0 || y >= h)
        return;

    pts[index].x = x;
    pts[index].y = y;

    if(index == 0)
        pts[4] = pts[0];

    InvalidateRect(hwnd, NULL, FALSE);
}


//
// Handle menu command
//

VOID
DoCommand(
    HWND hwnd,
    INT command
    )
{
    InvalidateRect(hwnd, NULL, FALSE);
}


//
// Handle popup menu
//

VOID
DoPopupMenu(
    HWND hwnd,
    INT x,
    INT y
    )
{
    HMENU menu;
    DWORD result;
    POINT pt;

    GetCursorPos(&pt);
    menu = LoadMenu(appInstance, MAKEINTRESOURCE(IDM_MAINMENU));

    result = TrackPopupMenu(
                GetSubMenu(menu, 0),
                TPM_CENTERALIGN | TPM_TOPALIGN |
                    TPM_NONOTIFY | TPM_RETURNCMD |
                    TPM_RIGHTBUTTON,
                pt.x,
                pt.y,
                0,
                hwnd,
                NULL);

    if (result == 0)
        return;

    DoCommand(hwnd, LOWORD(result));
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    INT x, y;

    switch (uMsg)
    {
    case WM_PAINT:

        DoPaint(hwnd);
        break;

    case WM_LBUTTONDOWN:

        if (showMesh)
        {
            x = (SHORT) LOWORD(lParam);
            y = (SHORT) HIWORD(lParam);
            DoMouseDown(hwnd, x, y);
        }
        break;

    case WM_LBUTTONUP:

        if (isDragging)
        {
            ReleaseCapture();
            isDragging = FALSE;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case WM_MOUSEMOVE:

        if (isDragging)
        {
            x = (SHORT) LOWORD(lParam);
            y = (SHORT) HIWORD(lParam);
            DoMouseMove(hwnd, x, y);
        }
        break;

    case WM_SIZING:

        if (DoWindowSizing(hwnd, (RECT*) lParam, wParam))
            return TRUE;
        else
            return DefWindowProc(hwnd, uMsg, wParam, lParam);

    case WM_SIZE:

        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_CHAR:

        switch ((CHAR) wParam)
        {
        case 'r':   // reset

            DoCommand(hwnd, IDC_RESETMESH);
            break;

        case ' ':   // show/hide mesh

            DoCommand(hwnd, IDC_TOGGLEMESH);
            break;

        case '1':   // restore 1-to-1 scale

            DoCommand(hwnd, IDC_SHRINKTOFIT);
            break;
        
        case '<':   // decrease mesh density

            DoCommand(hwnd, IDC_SPARSEMESH);
            break;

        case '>':   // increase mesh density

            DoCommand(hwnd, IDC_DENSEMESH);
            break;

        case 'f':   // toggle live feedback

            DoCommand(hwnd, IDC_LIVEFEEDBACK);
            break;
        }

        break;

    case WM_RBUTTONDOWN:

        x = (SHORT) LOWORD(lParam);
        y = (SHORT) HIWORD(lParam);
        DoPopupMenu(hwnd, x, y);
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMainWindow(
    VOID
    )

#define MYWNDCLASSNAME L"QuadTest"

{
    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            0,
            MyWindowProc,
            0,
            0,
            appInstance,
            LoadIcon(NULL, IDI_APPLICATION),
            LoadCursor(NULL, IDC_ARROW),
            NULL,
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }
    
    wndSizeExtra.cx = 2*GetSystemMetrics(SM_CXSIZEFRAME);
    wndSizeExtra.cy = 2*GetSystemMetrics(SM_CYSIZEFRAME) + GetSystemMetrics(SM_CYCAPTION);

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    srcSize.cx + wndSizeExtra.cx,
                    srcSize.cy + wndSizeExtra.cy,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);
}

//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);

    // Initialize mesh configuration

    CreateMesh();

    // Create the main application window

    CreateMainWindow();

    // Main message loop

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\reversi\rev.cpp ===
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <objbase.h>
#include <windows.h>
#include <math.h>
#include <float.h>
#include <gdiplus.h>

#include <port1632.h>
#include <process.h>
#include "reversi.h"

using namespace Gdiplus;

VOID NEAR PASCAL paintmove(BYTE b[BoardSize], INT move, INT friendly,
        INT enemy);
BOOL NEAR PASCAL msgcheck(VOID);

extern INT     moves[61];
extern INT     BestMove[max_depth+2];
extern HWND    hWin;
extern HDC     hDisp;
extern INT     depth;
extern INT     direc[];
extern Graphics* g;


/*       Indexes for computing scores and whether or not a player has       */
/*       any pieces on the board.  Very order dependant.                    */

BYTE PieceFlags[] = {   0x00 ,      /* Ignore sides */
                        0x00 ,      /* Ignore blanks */
                        0x01 ,      /* Human has a piece */
                        0x02 ,      /* Computer has a piece */
                    };

                    
INT Scores[] = { 0, 0 };
INT humanScore = 0;
INT compScroe = 0;

 

BYTE FinalComp[] = {0, 0, -1, 1 };   /* Table for compute # computer pieces */

BYTE FinalHuman[] = {0, 0, 1, -1};   /* Table for compute # human pieces    */

/*
 *       The scoring tables are used to evaluate the board
 *       position.  The corners of the board change value
 *       according to whether a given square is occupied or
 *       not.  This can be done dynamically, saving ~ 1K
 *       worth of data space but costing an as of yet
 *       undetermined performance hit.
 */

#define B11     11    /* Offsets to particular squares */
#define B18     18 
#define B81     81 
#define B88     88 

#define maskb11     0x08    /* Masks used for indexing into Scoring tables. */
#define maskb18     0x04
#define maskb81     0x02
#define maskb88     0x01


INT NEAR PASCAL finalscore(
BYTE b[],
INT friendly,
INT enemy)
{
    INT i;
    INT count=0;

    for (i=11 ; i<=88 ; i++) {
        if (b[i] == friendly) count++;
        else if (b[i] == enemy) count--;
    }
    if (count > 0)
        return(win +  count);
    else if (count < 0)
        return(loss + count);
    else
        return(0);
}



INT NEAR PASCAL legalcheck(
BYTE b[],
INT move,
INT friendly,
INT enemy)
{
   INT sq,d;
   INT *p;

   if (b[move] == empty) {
      p=direc;
      while ((d = *p++) != 0) {
          sq=move;
          if (b[sq += d] == enemy) {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == friendly) return(1);
          }
      }
   }
   return(0);
}


VOID NEAR PASCAL makemove(
BYTE b[],
INT move,
INT friendly,
INT enemy)
{
   INT sq,d;
   INT *p;

   if (move != PASS) {
      p=direc;
      while ((d = *p++) != 0) {
          sq=move;
          if (b[sq += d] == enemy) {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == friendly)
                while(b[sq -= d] == enemy)
                   b[sq]=friendly;
          }
      }
      b[move]=friendly;
   }
}


/*

   calculate the value of board

*/
INT NEAR PASCAL score(
BYTE b[],
INT friendly,
INT enemy)
{
    INT *pvalue;
    BYTE *pb;
    INT fpoints=0;
    INT epoints=0;
    INT ecount=0;
    BYTE bv;
    INT v,b11,b18,b81,b88;

    static INT value[79] = {     99, -8,  8,  6,  6,  8, -8, 99,000,
                                000, -8,-24, -4, -3, -3, -4,-24, -8,000,
                                000,  8, -4,  7,  4,  4,  7, -4,  8,000,
                                000,  6, -3,  4,  0,  0,  4, -3,  6,000,
                                000,  6, -3,  4,  0,  0,  4, -3,  6,000,
                                000,  8, -4,  7,  4,  4,  7, -4,  8,000,
                                000, -8,-24, -4, -3, -3, -4,-24, -8,000,
                                000, 99, -8,  8,  6,  6,  8, -8, 99,infin};

    static INT value2[79]= {     99, -8,  8,  6,  6,  8, -8, 99,000,
                                000, -8,-24,  0,  1,  1,  0,-24, -8,000,
                                000,  8,  0,  7,  4,  4,  7,  0,  8,000,
                                000,  6,  1,  4,  1,  1,  4,  1,  6,000,
                                000,  6,  1,  4,  1,  1,  4,  1,  6,000,
                                000,  8,  0,  7,  4,  4,  7,  0,  8,000,
                                000, -8,-24,  0,  1,  1,  1,-24, -8,000,
                                000, 99, -8,  8,  6,  6,  8, -8, 99,infin};

    pb = &b[11];
    b11 = *pb;
    b18 = b[18];
    b81 = b[81];
    b88 = b[88];

    if ((b11 != empty) || (b18 != empty) || (b81 != empty) || (b88 != empty)) {
        pvalue = value2;

        if (b11 == empty) {
                value2[12-11] = -8;  value2[21-11] = -8;  value2[22-11] = -24;
        } else {
                value2[12-11] = 12;  value2[21-11] = 12;  value2[22-11] = 8;
        }

        if (b18 == empty) {
                value2[17-11] = -8;  value2[28-11] = -8;  value2[27-11] = -24;
        } else {
                value2[17-11] = 12;  value2[28-11] = 12;  value2[27-11] = 8;
        }

        if (b81 == empty) {
                value2[82-11] = -8;  value2[71-11] = -8;  value2[72-11] = -24;
        } else {
                value2[82-11] = 12;  value2[71-11] = 12;  value2[72-11] = 8;
        }

        if (b88 == empty) {
                value2[87-11] = -8;  value2[78-11] = -8;  value2[77-11] = -24;
        } else {
                value2[87-11] = 12;  value2[78-11] = 12;  value2[77-11] = 8;
        }
    } else {
        pvalue = value;
    }

    while((v=*pvalue++) != infin) {
       bv = *pb++;
       if (bv == friendly)
           fpoints += v;
       else if (bv == enemy) {
                   epoints += v;
           ecount++;
       }

    }
    if (!ecount)          /* any enemy pieces on the board? */
       return(win);       /* if not, we just won!                 */
    else
       return(fpoints-epoints);
}



INT NEAR PASCAL minmax(
BYTE b[max_depth + 2][100],
INT move,
INT friendly,
INT enemy,
INT ply,
INT vmin,
INT vmax)
{
    BYTE *pCurrent, *pPrevious, *pSource, *pDest;
    INT *pMoves;
    INT *pBestMove;
    INT i;
    INT sq, value, cur_move;

    pPrevious = &b[ply][0];
    pCurrent =  &b[ply+1][0];

    pSource = &b[ply][11];
    pDest =   &b[ply+1][11];
    for (i=11 ; i<=88 ; i++) *pDest++=*pSource++;

    pBestMove = &BestMove[ply];
    if (move == PASS) {
        if (ply == depth) {
            pMoves = moves;
            while((sq = *pMoves++) != 0) {
                if (legalcheck(pCurrent,sq,enemy,friendly))
                    return(score(pCurrent,friendly,enemy));
            }
            return(finalscore(pCurrent,friendly,enemy));
        }
    }
    else {
        if (ply == 0) {
            g = new Graphics(hWin);
            paintmove(pCurrent,move,friendly,enemy);
            delete g;
            g = NULL;
        }
        else {
            makemove(pCurrent,move,friendly,enemy);
            if (ply == depth) return(score(pCurrent,friendly,enemy));
        }
    }
    pMoves = moves;
    cur_move = PASS;
    *pBestMove = PASS;
    while((sq = *pMoves++) != 0) {
        if (legalcheck(pCurrent,sq,enemy,friendly)) {
           cur_move = sq;
           value = minmax(b,cur_move,enemy,friendly,ply+1,-vmax,-vmin);
           if (value > vmin) {
              vmin = value;
              *pBestMove = cur_move;
              if (value >= vmax) goto cutoff;   /* alpha-beta cutoff */
           }
        }
    }
    if (cur_move == PASS) {
       if (move == PASS)        /* two passes in a row mean game is over */
          return(finalscore(pCurrent,friendly,enemy));
       else {
          value = minmax(b,PASS,enemy,friendly,ply+1,-vmax,-vmin);
          if (value > vmin) vmin = value;
       }
    }
cutoff:
    return(-vmin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\samples\shapes\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	shapes.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information


// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\samples\shapes\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: wndstuff.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

VOID Test(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\samples\shapes\shapes.h ===
/**************************************************************************\
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Shapes Sample Header File
*
* Abstract:
*
*   Decribes the shapes classes.
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

#include <objbase.h>

#include <Gdiplus.h>
#include <tchar.h>

using namespace Gdiplus;

#ifndef ASSERT
    #define ASSERT(cond)    if (!(cond)) { DebugBreak(); }
#endif

#define numberof(x) (sizeof(x)/sizeof(x[0]))


/**************************************************************************\
*
* Class Description:
*
* Shape Class
* Defines the basic functionnality of a shape.
* Contains a Pen, a Fill Brush, and a Text Brush
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

class Shape
{
public:
    Shape(Pen   *in_Pen = NULL,         // Pen we want to draw with
          Brush *in_Brush = NULL,       // Brush we want to fill with
          Brush *in_TextBrush = NULL,   // TextBrush we want to write with
          TCHAR* in_Text = NULL,        // Text we want to write
          TCHAR* in_FontFamily = NULL   // Font we want to use
          );

    virtual ~Shape();

    // Drawing methods
    VOID Draw(Graphics *g);             // Draw the shape
	VOID SetPen(Pen *in_Pen);           // Set the Drawing Pen
    VOID SetBrush(Brush *in_Brush);     // Set the Fill Brush
    VOID SetTextBrush(Brush *in_Brush); // Set the Text Brush

    // Transformations
	VOID SetSize(REAL sizeX, REAL sizeY);   // Set the size of the shape
	VOID SetAngle(REAL angle);              // Set the rotation angle
	VOID SetPosition(REAL posX, REAL posY); // Set the center of the shape

protected:
	// Don't do anything in the base class...
    // These are not pure because the derived classes don't need to
    // implement them. Shape class can also be used to have a text label only
	virtual VOID DrawShape(Graphics *g) {}; // Draw the shape
	virtual VOID FillShape(Graphics *g) {}; // Fill the shape
    virtual VOID DrawText(Graphics* g);     // Draw the text

    // Calculate the transformation matrix
	virtual VOID RecalcObjectMatrix();

    // Set the points to the default of the shape
    virtual VOID ResetPoints() {};

    // Data Members
protected:
    Pen      *m_Pen;                    // Pen for the outline of the shape
    Brush    *m_Brush;	                // Brush for the inside of the shape

    // Text Attributes
    Brush    *m_TextBrush;              // Brush for the text
    TCHAR    *m_szName;                 // Label that will be written
    Font     *m_Font;                   // Font used for the label

    // Shape Attributes
    GpMatrix  m_ObjectMatrix;           // Matrix that will transform the shape
	REAL	  m_Angle;                  // Rotation angle of the shape
	REAL      m_SizeX, m_SizeY;         // Size of the shape
	REAL      m_PosX, m_PosY;           // Position of the center of the shape

    // Control Points
	PointF   *m_Points;     			// The points that control the shape
	INT       m_NPoints;	        	// The number of points
};


/***************************************************************************\
 A Rectangular shape, with a diameter of 1
\***************************************************************************/
class RectShape : public Shape
{
public:
    RectShape(Pen   *in_Pen = NULL,
              Brush *in_Brush = NULL,
              Brush *in_TextBrush = NULL,
              TCHAR* in_Text = NULL,
              TCHAR* in_FontFamily = NULL
              )
			  : Shape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
        // We have two control points
		m_NPoints = 2 ;
		m_Points = new PointF[m_NPoints] ;
        ResetPoints();
	};

protected:
    VOID ResetPoints();
private:
	VOID DrawShape(Graphics *g);
	VOID FillShape(Graphics *g);
};

/***************************************************************************\
 An elliptical shape, with a diameter of 1
\***************************************************************************/
class EllipseShape : public Shape
{
public:
    EllipseShape(Pen   *in_Pen = NULL,
                 Brush *in_Brush = NULL,
                 Brush *in_TextBrush = NULL,
                 TCHAR* in_Text = NULL,
                 TCHAR* in_FontFamily = NULL
                 )
			     : Shape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
        // We have two control points
		m_NPoints = 2 ;
		m_Points = new PointF[m_NPoints] ;
        ResetPoints();
	};


protected:
    VOID ResetPoints();
private:
	VOID DrawShape(Graphics *g);
	VOID FillShape(Graphics *g);
};

/***************************************************************************\
 An 90 degree pie shape, of size 1
\***************************************************************************/
class PieShape : public Shape
{
public:
    PieShape(Pen   *in_Pen = NULL,
             Brush *in_Brush = NULL,
             Brush *in_TextBrush = NULL,
             TCHAR* in_Text = NULL,
             TCHAR* in_FontFamily = NULL
             )
			 : Shape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
             , m_PieAngle(360)
	{
        // We have two control points
		m_NPoints = 2 ;
		m_Points = new PointF[m_NPoints] ;
        ResetPoints();
	};

    // New method. Set the pie angle default is 360 degrees
    VOID SetPieAngle(REAL PieAngle) { m_PieAngle = PieAngle; };


protected:
    VOID ResetPoints();
private:
	VOID DrawShape(Graphics *g);
	VOID FillShape(Graphics *g);

    // Data Members
    REAL m_PieAngle;        // The angle of the pie slice we want
};

/***************************************************************************\
 An generic polygon shape. This class doesn't have any point information
\***************************************************************************/
class PolygonShape : public Shape
{
// A polygon shape cannot be instantiated
protected:
    PolygonShape(Pen   *in_Pen = NULL,
                 Brush *in_Brush = NULL,
                 Brush *in_TextBrush = NULL,
                 TCHAR* in_Text = NULL,
                 TCHAR* in_FontFamily = NULL
                 )
                 : Shape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
    };

private:
	VOID DrawShape(Graphics *g);
	VOID FillShape(Graphics *g);
};

/***************************************************************************\
 An regualar polygon shape, of size 1
\***************************************************************************/
class RegularPolygonShape : public PolygonShape
{
public:
    RegularPolygonShape(INT    in_Edges = 6,        // The number of edges
                                                    // we want to have
                        Pen   *in_Pen = NULL,
                        Brush *in_Brush = NULL,
                        Brush *in_TextBrush = NULL,
                        TCHAR* in_Text = NULL,
                        TCHAR* in_FontFamily = NULL
                        )
			            : PolygonShape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
        ASSERT(in_Edges > 0);
		m_NPoints = in_Edges ;
        m_Points = new PointF[m_NPoints];
        ResetPoints() ;
    };

protected:
    VOID ResetPoints();
};


/***************************************************************************\
 An star shape, of size 1
\***************************************************************************/
class StarShape : public PolygonShape
{
public:
    StarShape(INT    in_Edges = 6,                  // The number of edges
                                                    // we want to have
              Pen   *in_Pen = NULL,
              Brush *in_Brush = NULL,
              Brush *in_TextBrush = NULL,
              TCHAR* in_Text = NULL,
              TCHAR* in_FontFamily = NULL
              )
			  : PolygonShape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
        ASSERT(in_Edges > 0);
		m_NPoints = 2*in_Edges ;        // We always have twices as many
                                        // points as we have edges
        m_Points = new PointF[m_NPoints];
        ResetPoints() ;
    };

protected:
    VOID ResetPoints();
};

/***************************************************************************\
 An Cross.
\***************************************************************************/
class CrossShape : public PolygonShape
{
public:
    CrossShape(Pen   *in_Pen = NULL,
               Brush *in_Brush = NULL,
               Brush *in_TextBrush = NULL,
               TCHAR* in_Text = NULL,
               TCHAR* in_FontFamily = NULL
               )
			   : PolygonShape(in_Pen, in_Brush, in_TextBrush, in_Text, in_FontFamily)
	{
		m_NPoints = 12 ;
		m_Points = new PointF[m_NPoints] ;
        ResetPoints();
	};

protected:
    VOID ResetPoints();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\samples\shapes\shapes.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998 Microsoft Corporation
*
* Module Name:
*
*   Shapes Sample Classes Implementation
*
* Abstract:
*
*   This module implements the different shape classes that will be
*   used.
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

#include "stdafx.h"
#include "shapes.h"

#include <math.h>       // For sin and cos

/**************************************************************************\
*
* Function Description:
*
* Shape Constructor
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

Shape::Shape(Pen   *in_Pen,
             Brush *in_Brush,
             Brush *in_TextBrush,
             TCHAR* in_Text,
             TCHAR* in_FontFamily)
            : m_TextBrush(NULL)
            , m_Brush(NULL)
            , m_Pen(NULL)
            , m_Font(NULL)
            , m_szName(in_Text)
            , m_Points(NULL)
            , m_NPoints(0)
            , m_Angle(0)
            , m_SizeX(1.0f)
            , m_SizeY(1.0f)
            , m_PosX(0.0f)
            , m_PosY(0.0f)

{
    SetPen(in_Pen);
    SetBrush(in_Brush);
    SetTextBrush(in_TextBrush);

    // If we have a text brush then create a font for it
    if(m_TextBrush != NULL && m_szName != NULL)
    {
        if(in_FontFamily == NULL)
        {
            in_FontFamily = _T("Arial");
        }
        FontFamily fontFamily(in_FontFamily); 
        m_Font = new Font(&fontFamily, 12.0, 0, UnitWorld);
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape Desctuctor
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

Shape::~Shape()
{
    // Delete the font if allocated
    if(m_Font != NULL)
    {
        delete m_Font;
    }

    // Delete the control points
    if(m_Points != NULL)
    {
        delete m_Points;
        m_NPoints=0;
    }

    // Remove the brushes and pen
    SetPen(NULL);
    SetBrush(NULL);
    SetTextBrush(NULL);
}


/**************************************************************************\
*
* Function Description:
*
* Shape::SetPen
*
* Notes:
*   We clone the object to make sure that the Shape will be able to live
*   even if the pen is destroyed or modified
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetPen(Pen *in_Pen)
{
    // Remove the old pen
    if(m_Pen != NULL)
    {
        delete m_Pen;
        m_Pen = NULL;
    }

    // Set the new pen
    if(in_Pen != NULL)
    {
        m_Pen = in_Pen->Clone();
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape::SetBrush
*
* Notes:
*   We clone the object to make sure that the Shape will be able to live
*   even if the pen is destroyed or modified
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetBrush(Brush *in_Brush)
{
    // Remove the old brush
    if(m_Brush != NULL)
    {
        delete m_Brush;
        m_Brush = NULL;
    }

    // Set the new brush
    if(in_Brush != NULL)
    {
        m_Brush = in_Brush->Clone();
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape::SetBrush
*
* Notes:
*   We clone the object to make sure that the Shape will be able to live
*   even if the pen is destroyed or modified
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetTextBrush(Brush *in_Brush)
{
    // Remove the old brush
    if(m_TextBrush != NULL)
    {
        delete m_TextBrush;
        m_TextBrush = NULL;
    }

    // Set the new brush
    if(in_Brush != NULL)
    {
        m_TextBrush = in_Brush->Clone();
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape::Draw
*
* Notes:
*   Called to draw the shape.
*
* Parameters:
*   Graphics | *g | A pointer to a graphics object that we will be drawing
*                   into
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::Draw(Graphics *g)
{
    // Validate Parameters
    ASSERT(g != NULL);

    // Transform the world to map to the object
    g->SetTransform(&m_ObjectMatrix);

    // If we have a pen then draw the outline
    if(m_Pen != NULL)
    {
        // Call the derive class
        DrawShape(g);
    }

    // If we have a brush then draw the outline
    if(m_Brush != NULL)
    {
        // Call the derive class
        FillShape(g);
    }

    // Reset the world transform
    g->ResetTransform();

    // If we have a text brush then draw the outline
    if(m_TextBrush != NULL)
    {
        DrawText(g);
    }
}

/**************************************************************************\
*
* Function Description:
*
* Shape::Draw
*
* Notes:
*   Called to draw the text associated with the shape
*
* Parameters:
*   Graphics | *g | A pointer to a graphics object that we will be drawing
*                   into
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::DrawText(Graphics* g)
{
    // Validate Parameters
    ASSERT(g != NULL);

    // Set the text position to be 30 pixels right of the shape, based on its
    // size
    g->DrawString(m_szName,
                  _tcslen(m_szName),
                  m_Font,
                  PointF(m_PosX + m_SizeX / 2 + 30, m_PosY ),
                  m_TextBrush);
}


/**************************************************************************\
*
* Function Description:
*
* Shape::SetSize
*
* Notes:
*   Set the size of the shape in X and Y
*   The control points are then transformed with that scale, in order to
*   keep the pensize.
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetSize(REAL sizeX, REAL sizeY)
{
    // Don't do useless work
    if(m_SizeX == sizeX && m_SizeY == sizeY)
        return;

    // Save the new size
    m_SizeX = sizeX;
    m_SizeY = sizeY;

    // Reset the points to their default
    ResetPoints() ;

    // Scale the points according to the scale factor;
    if(m_NPoints != 0)
    {
        GpMatrix ScaleMatrix;
        ScaleMatrix.Scale(m_SizeX, m_SizeY);
        ScaleMatrix.TransformPoints(m_Points, m_NPoints);
    }

}

/**************************************************************************\
*
* Function Description:
*
* Shape::SetAngle
*
* Notes:
*   Set the rotation angle of the shape in degrees
*   The rotation is always applied before the translation
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetAngle(REAL Angle)
{
    // Don't do useless work
    if(m_Angle ==Angle)
        return;

    // Save the Angle
    m_Angle = Angle;

    // Recalculate the transformation matrix
    RecalcObjectMatrix();
}

/**************************************************************************\
*
* Function Description:
*
* Shape::SetPosition
*
* Notes:
*   Set the position of the center of the shape in X and Y
*   The translation is always applied after the rotation
*
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::SetPosition(REAL posX, REAL posY)
{
    // Don't do useless work
    if(m_PosX == posX && m_PosY == posY)
        return;

    // Save the new position
    m_PosX = posX;
    m_PosY = posY;

    // Recalculate the transformation matrix
    RecalcObjectMatrix();
}


/**************************************************************************\
*
* Function Description:
*
* Shape::RecalcObjectMatrix
*
* Notes:
*   Invalidate the Object Matrix
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

VOID Shape::RecalcObjectMatrix()
{
    m_ObjectMatrix.Reset();
    m_ObjectMatrix.Translate(m_PosX, m_PosY);
    m_ObjectMatrix.Rotate(m_Angle);
}


/***************************************************************************\
 A Rectangular shape, of size 1
\***************************************************************************/
VOID RectShape::DrawShape(Graphics *g)
{
    g->DrawRectangle(m_Pen,
        m_Points[0].X,                  // Top Left Corner
        m_Points[0].Y,
        m_Points[1].X - m_Points[0].X,  // Width
        m_Points[1].Y - m_Points[0].Y   // Height
        );
}
VOID RectShape::FillShape(Graphics *g)
{
    g->FillRectangle(m_Brush,
        m_Points[0].X,                  // Top Left Corner
        m_Points[0].Y,
        m_Points[1].X - m_Points[0].X,  // Width
        m_Points[1].Y - m_Points[0].Y   // Height
        );
}


// Set the points to have a square of size 1
VOID RectShape::ResetPoints()
{
    ASSERT(m_Points != NULL && m_NPoints == 2);
    m_Points[0].X = -0.5f;
    m_Points[0].Y = -0.5f;
    m_Points[1].X =  0.5f;
    m_Points[1].Y = 0.5f;
}


/***************************************************************************\
 An elliptical shape, of diameter 1
\***************************************************************************/
VOID EllipseShape::DrawShape(Graphics *g)
{
    g->DrawEllipse(m_Pen,
        m_Points[0].X,                  // X pos
        m_Points[0].Y,                  // Y pos
        m_Points[1].X - m_Points[0].X,  // Width
        m_Points[1].Y - m_Points[0].Y   // Height
        );
}

VOID EllipseShape::FillShape(Graphics *g)
{
    g->FillEllipse(m_Brush,
        m_Points[0].X,                  // X pos
        m_Points[0].Y,                  // Y pos
        m_Points[1].X - m_Points[0].X,  // Width
        m_Points[1].Y - m_Points[0].Y   // Height
        );
}

VOID EllipseShape::ResetPoints()
{
    ASSERT(m_Points != NULL && m_NPoints == 2);
    m_Points[0].X = -0.5f;
    m_Points[0].Y = -0.5f;
    m_Points[1].X =  0.5f;
    m_Points[1].Y =  0.5f;
}


/***************************************************************************\
 An pie shape, of size approx 1.
\***************************************************************************/
VOID PieShape::DrawShape(Graphics *g)
{
    g->DrawPie(m_Pen,
        m_Points[0].X, // X pos
        m_Points[0].Y, // Y pos
        m_Points[1].X - m_Points[0].X, // Width
        m_Points[1].Y - m_Points[0].Y, // Height
        0,          // Start Angle (rotation takes care of that)
        m_PieAngle  // Total angle of the pie
        );
}

VOID PieShape::FillShape(Graphics *g)
{
    g->FillPie(m_Brush,
        m_Points[0].X, // X pos
        m_Points[0].Y, // Y pos
        m_Points[1].X - m_Points[0].X, // Width
        m_Points[1].Y - m_Points[0].Y, // Height
        0,          // Start Angle (rotation takes care of that)
        m_PieAngle  // Total angle of the pie
        );
}

VOID PieShape::ResetPoints()
{
    ASSERT(m_Points != NULL && m_NPoints == 2);
    m_Points[0].X = -0.5f;
    m_Points[0].Y = -0.5f;
    m_Points[1].X =  0.5f;
    m_Points[1].Y =  0.5f;
}


/***************************************************************************\
 An generic polygon shape
\***************************************************************************/
VOID PolygonShape::DrawShape(Graphics *g)
{
    g->DrawPolygon(m_Pen, m_Points, m_NPoints);
}

VOID PolygonShape::FillShape(Graphics *g)
{
    g->FillPolygon(m_Brush, m_Points, m_NPoints);
}


/***************************************************************************\
 An regular polygon shape, of size 1
\***************************************************************************/
VOID RegularPolygonShape::ResetPoints()
{
    // Need to have an even number of points!!!
    ASSERT(m_Points != NULL && m_NPoints > 0);

    REAL s, c, theta;
    const REAL pi = 3.1415926535897932f;

    // Start with the angle representing (0,1)
    theta = -pi/2;

    // Calculate the increment between points
    REAL increment = (2.0f * pi) / m_NPoints;

    // Create a star shape.
    for(INT i = 0; i < m_NPoints;)
    {
        // Calculate the outer point
        s = sinf(theta);
        c = cosf(theta);
        m_Points[i].X = c*0.5f;
        m_Points[i++].Y = s*0.5f;
        theta += increment;
    }
}

/***************************************************************************\
 An star shape, of size 1
\***************************************************************************/
VOID StarShape::ResetPoints()
{
    // Need to have an even number of points!!!
    ASSERT(m_Points != NULL && ((m_NPoints & 0x1) == 0));

    REAL s, c, theta;
    const REAL pi = 3.1415926535897932f;

    // Start with the angle representing -90 degrees (0, 1)
    theta = -pi/2;

    // Calculate the increment between points
    REAL increment = (2.0f * pi) / m_NPoints;

    // Create a star shape.
    for(INT i = 0; i < m_NPoints;)
    {
        // Calculate the outer point
        s = sinf(theta);
        c = cosf(theta);
        m_Points[i].X = c*0.5f;
        m_Points[i++].Y = s*0.5f;
        theta += increment;

        // Calculate the inflexion point
        s = sinf(theta);
        c = cosf(theta);
        m_Points[i].X = c*0.25f;
        m_Points[i++].Y = s*0.25f;
        theta += increment;
    }
}

/***************************************************************************\
 An cross shape, of size 1.
\***************************************************************************/
VOID CrossShape::ResetPoints()
{
    ASSERT(m_Points != NULL && m_NPoints == 12);
    m_Points[0].X = -1.0f/6.0f;
    m_Points[0].Y = -0.5f;
    m_Points[1].X =  1.0f/6.0f;
    m_Points[1].Y = -0.5f;

    m_Points[2].X =  1.0f/6.0f;
    m_Points[2].Y = -1.0f/6.0f;

    m_Points[3].X =  0.5f;
    m_Points[3].Y = -1.0f/6.0f;
    m_Points[4].X =  0.5f;
    m_Points[4].Y =  1.0f/6.0f;

    m_Points[5].X =  1.0f/6.0f;
    m_Points[5].Y =  1.0f/6.0f;

    m_Points[6].X =  1.0f/6.0f;
    m_Points[6].Y =  0.5f;
    m_Points[7].X = -1.0f/6.0f;
    m_Points[7].Y =  0.5f;

    m_Points[8].X = -1.0f/6.0f;
    m_Points[8].Y =  1.0f/6.0f;

    m_Points[9].X =  -0.5f;
    m_Points[9].Y =   1.0f/6.0f;
    m_Points[10].X = -0.5f;
    m_Points[10].Y = -1.0f/6.0f;

    m_Points[11].X = -1.0f/6.0f;
    m_Points[11].Y = -1.0f/6.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\reversi\reversi.cpp ===
/****************************************************************************/
/*                                                                          */
/*  Windows Reversi -                                                       */
/*                                                                          */
/*      Originally written by Chris Peters                                  */
/*                                                                          */
/****************************************************************************/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <objbase.h>
#include <windows.h>
#include <math.h>
#include <float.h>

#include "windows.h"
#include <port1632.h>
#include <process.h>
#include <stdlib.h>
#include "reversi.h"
#include <gdiplus.h>

using namespace Gdiplus;

/* Exported procedures called from other modules */
LRESULT APIENTRY ReversiWndProc(HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY InverseMessage(HWND, UINT, UINT_PTR, DWORD);
INT_PTR APIENTRY AboutDlgProc(HWND, UINT, WPARAM, LPARAM);

PWSTR    pDisplayMessage;
Brush  *brBlack;
Brush  *brPat;
Brush  *brWhite;
Brush  *brRed;
Brush  *brGreen;
Brush  *brBlue;
Brush  *brHuman;
Brush  *brComputer;
HBRUSH       hbrWhite;
HBRUSH       hbrGreen;

HANDLE  hInst;
HANDLE  curIllegal;
HANDLE  curLegal;
HANDLE  curThink;
HANDLE  curBlank;
BOOL    fThinking = FALSE;
BOOL    fCheated = FALSE;
INT     direc[9] = {9, 10, 11, 1, -1, -9, -10, -11, 0};
WORD     prevCheck;
BYTE    board[max_depth+2][BoardSize];
INT     fPass;
INT     flashtimes;
INT     count;
INT     MessageOn;
INT     charheight;
INT     charwidth;
INT     xscr;
WCHAR    strBuf[80];
BOOL    bMouseDownInReversi = FALSE;
INT     xExt;
INT     yExt;
INT     Bx;
INT     By;
INT     ASPECT;
INT     COLOR;
INT     TXMIN;
INT     TYMIN = 45;
INT     dimension;
BOOL    ffirstmove;

WCHAR    szReversi[20];
WCHAR    szReversiPractice[40];
WCHAR    szPass[30];
WCHAR    szMustPass[30];
WCHAR    szTie[30];
WCHAR    szLoss[30];
WCHAR    szWon[30];
WCHAR    szWonPost[30];
WCHAR    szLossPost[30];
WCHAR    szAbout[20];
WCHAR    szIllegal[70];
WCHAR    szNoPass[70];
WCHAR    szHelpFile[15];

HANDLE  hAccel;

POINT   MousePos;

INT     depth;
INT     BestMove[max_depth+2];
HDC     hDisp;
HWND    hWin;
Graphics *g;

INT     moves[61] = {11,18,81,88, 13,31,16,61,
                     38,83,68,86, 14,41,15,51,
                     48,84,58,85, 33,36,63,66,
                     34,35,43,46, 53,56,64,65,
                     24,25,42,47, 52,57,74,75,
                     23,26,32,37, 62,67,73,76,
                     12,17,21,28, 71,78,82,87,
                     22,27,72,77,
              0};


INT NEAR PASCAL minmax(BYTE b[max_depth + 2][100], INT move, INT friendly,
    INT enemy, INT ply, INT vmin, INT vmax);
VOID NEAR PASCAL makemove(BYTE b[], INT move, INT friendly, INT enemy);
INT NEAR PASCAL legalcheck(BYTE b[], INT move, INT friendly, INT enemy);


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  UpdateCursor() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* To use UpdateCursor,  set the global var MousePos.x and MousePos.y and make
 * the call.  The cursor will appear at the new position
 */

VOID NEAR PASCAL UpdateCursor(
HWND    hwnd)
{
  POINT curpoint;

  curpoint.x = MousePos.x;
  curpoint.y = MousePos.y;
  ClientToScreen(hwnd, (LPPOINT)&curpoint);
  SetCursorPos(curpoint.x, curpoint.y);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  checkdepth() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL checkdepth(
HWND hWindow,
WORD  d)
{
  HMENU hMenu;

  hMenu = GetMenu(hWindow);
  CheckMenuItem(hMenu, prevCheck, MF_UNCHECKED);
  CheckMenuItem(hMenu, d, MF_CHECKED);
  prevCheck = d;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  clearboard() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL clearboard(
BYTE b[max_depth+2][BoardSize])
{
  register INT  i,j;
  INT           k;

  for (i=0; i<=max_depth ; i++)
      for (j=0 ; j<=99 ; j++)
          b[i][j] = edge;

    for (i=0 ; i<=max_depth ; i++)
      {
        for (j=11 ; j<=81 ; j=j+10)
            for (k=j ; k<j+8 ; k++)
                b[i][k] = empty;

        b[i][45]=computer;
        b[i][54]=computer;
        b[i][44]=human;
        b[i][55]=human;
      }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevCreate() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_CREATE messages. */

VOID NEAR PASCAL RevCreate(
register HWND   hWindow)

{
  register HDC  hDC;
  TEXTMETRIC    charsize;           /* characteristics of the characters */

  MessageOn   = FALSE;
  hDC = GetDC(hWindow);
  GetTextMetrics(hDC, (LPTEXTMETRIC)&charsize);

  charheight = charsize.tmHeight;
  charwidth = charsize.tmAveCharWidth;

  ReleaseDC(hWindow, hDC);

  if (COLOR == TRUE)
    {
      brComputer = brBlue;
      brHuman = brRed;
    }
  else
    {
      brComputer = brBlack;
      brHuman = brWhite;
    }

  TXMIN = 45 * ASPECT;

  clearboard(board);

  /* Okay to pass on first move */
  fPass = PASS;
  depth = 1;
  prevCheck = EASY;
  ffirstmove = TRUE;
  checkdepth(hWindow, prevCheck);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  printboard() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL printboard(
BYTE b[max_depth+2][BoardSize])

{
  register INT  i,j;
  INT sq;

  for (i=0; i < 8; i++)
    {
      for (j=0; j < 8; j++)
        {
          if ((sq = (INT)b[0][i*10+j+11]) != empty)
            {
              Brush *brush;
              
              if (sq == computer)
                  brush = brComputer;
              else
                  brush = brHuman;
              
              g->FillEllipse(brush,
                             Bx+2*ASPECT+i*xExt,
                             By+2+j*yExt,
                             xExt-4*ASPECT,
                             yExt-4);
            }
        }
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ClearMessageTop() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ClearMessageTop(
Graphics *graphics)
{
   if (MessageOn == TRUE)
   {
      flashtimes = count + 1;
      graphics->FillRectangle((COLOR) ? brGreen : brWhite, 0, 0, xscr, charheight);
      MessageOn = FALSE;
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowMessageTop() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowMessageTop(
Graphics *graphics,
PWSTR    string
)
{
  INT   dx;

  pDisplayMessage = string;
  ClearMessageTop(graphics);
  RectF rect(0, 0, xscr, charheight);
  graphics->FillRectangle(brWhite, rect);
  Font font((HFONT)NULL);
  graphics->DrawStringI((LPWSTR)string,
                       NULL,
                       0,
                       0,
                       NULL, 0,
                       brBlue);
  MessageOn = TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  drawboard() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL drawboard(
BYTE b[max_depth+2][BoardSize])
{
  register INT  i;
  INT           lcx,lcy;
  register INT  xdimension;
  INT           xLineExt,yLineExt;

  yLineExt = 8 * yExt;
  xLineExt = 8 * xExt;
  xdimension = dimension * ASPECT;

  g->FillRectangle(brBlack, Bx+2*xdimension, By+2*dimension, xLineExt, yLineExt);
  g->FillRectangle(brPat, Bx, By, xLineExt, yLineExt);

  for (i=Bx; i <= Bx + xLineExt; i += xExt)
     g->FillRectangle(brGreen, i, By, ASPECT, yLineExt);

  for (i=By; i <= By + yLineExt; i += yExt)
     g->FillRectangle(brGreen, Bx, i, xLineExt, 1);

  lcx = Bx+xLineExt;
  lcy = By+yLineExt;

  for (i=1; i < xdimension; ++i)
      g->FillRectangle(brPat, lcx+i, By+i/ASPECT, 1, yLineExt);

  /* Fill in bottom edge of puzzle. */
  for (i=1; i < dimension; ++i)
      g->FillRectangle(brPat, Bx+i*ASPECT, lcy+i, xLineExt, 1);

  Pen pen(brBlack, 1.0f, UnitWorld);

  g->DrawLine(&pen, lcx, By, lcx+xdimension, By+dimension);
  g->DrawLine(&pen, lcx+xdimension, By+dimension, lcx+xdimension, lcy+dimension);
  g->DrawLine(&pen, lcx+xdimension, lcy+dimension, Bx+xdimension, lcy+dimension);
  g->DrawLine(&pen, Bx+xdimension, lcy+dimension, Bx, lcy);
  g->DrawLine(&pen, lcx+xdimension, lcy+dimension, lcx, lcy);

  printboard(b);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevPaint() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_PAINT messages. */

VOID NEAR PASCAL RevPaint(
HWND    hWindow,
Graphics *graphics)

{
  register INT  Tx, Ty;
  INT           xLineExt, yLineExt;
  RECT          lpSize;

  /* Since it is easy to resize we'll do it on every repaint */
  g = graphics;
  hWin  = hWindow;
  //SetBkMode(hDisp, OPAQUE);
  GetClientRect(hWindow, (LPRECT)&lpSize);
  xscr = Tx = lpSize.right - lpSize.left;
  Ty = lpSize.bottom - lpSize.top;

  /* Dont go below minimum size */
  if (Tx < Ty*ASPECT)
    {
      if (Tx < TXMIN)
          Tx = TXMIN;
      xExt = Tx / (9 + 1);
      yExt = xExt / ASPECT;
    }
  else
    {
      if (Ty < TYMIN)
          Ty = TYMIN;
      yExt = Ty / (9 + 1);
      xExt = yExt * ASPECT;
    }
  yLineExt = 8 * yExt;
  xLineExt = 8 * xExt;
  dimension = yLineExt/30;

  Bx = (Tx > xLineExt) ? (Tx - xLineExt) / 2 : 0;
  By = (Ty > yLineExt) ? (Ty - yLineExt) / 2 : 0;

  RECT rect;
  GetClientRect(hWindow, &rect);

  g->FillRectangle(brWhite,
				   rect.left, 
				   rect.top, 
				   rect.right-rect.left, 
				   rect.bottom-rect.top);

  drawboard(board);

  if (MessageOn)
    {
      ShowMessageTop(graphics, pDisplayMessage);
      //PatBlt(hDC, 0, 0, xscr, charheight, DSTINVERT);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FlashMessageTop() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL FlashMessageTop(
HWND    hWindow)
{
  flashtimes = 0;
  count = 4;
  SetTimer(hWindow, 666, 200, InverseMessage);    /* Timer ID is 666 */
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMessage() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMessage(
HWND            hWindow,
Graphics       *graphics,
register WCHAR   *pS,
INT              n,
WCHAR            *pchPostStr)
{
  register WCHAR *pch;

  pch = strBuf;
  while (*pS)
      *pch++ = *pS++;

  if (n)
    {
      if (n / 10)
          *pch++ = (CHAR)(n / 10 + L'0');
      *pch++ = (CHAR)(n % 10 + L'0');
    }

  if (pchPostStr)
    {
      while (*pchPostStr)
          *pch++ = *pchPostStr++;
    }
  *pch = L'\0';

  ShowMessageTop(graphics, strBuf);
  FlashMessageTop(hWindow);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  flashsqr() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL flashsqr(
register Graphics *graphics,
INT             x1,
INT             y1,
INT             Ex,
INT             Ey,
INT             color,
BOOL            fBlankSquare,
INT             n)

{
  register INT  i;

// !! ??
//  if (fBlankSquare)
//      SelectObject(hDC, GetStockObject(NULL_PEN));

  SetCursor((HICON)curBlank);

  for (i=0; i < n; ++i)
    {
      if (color == 1)
          color = 2;
      else
          color = 1;

      Brush *brush;

      if (color == 1)
          brush = brComputer;
      else
          brush = brHuman;

      graphics->FillEllipse(brush, x1, y1, Ex, Ey);
    }

  if (fBlankSquare)
    {
      graphics->FillEllipse(brPat, x1, y1, Ex, Ey);
    }
  else
      SetCursor((HICON)curThink);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMouseMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMouseMove(
POINT   point)

{
  INT     move;
  INT     Si, Sj;
  INT     yLineExt = 8 * yExt;
  INT     xLineExt = 8 * xExt;
  HANDLE  cur;

  MousePos.x = point.x;
  MousePos.y = point.y;

  if(xExt ==0 || yExt == 0)
      return;

  cur = curIllegal;

  if ((point.x > Bx) && (point.x < (Bx+xLineExt)) && (point.y > By) && (point.y < (By+yLineExt)))
    {
      Si = (point.x - Bx) / xExt;
      Sj = (point.y - By) / yExt;
      move = Si * 10 + Sj + 11;
      if (legalcheck(board[0], move, human, computer))
          cur = curLegal;
    }
  SetCursor((HICON)cur);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowBestMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowBestMove(
HWND hwnd)

{
  HDC           hdc;
  INT           sq;
  register INT  x, y;
  INT           *pMoves;
  BOOL          bDone;

  if (fPass == PASS && !ffirstmove)
      return;

  if (!fCheated)
      SetWindowText(hwnd, (LPWSTR)szReversiPractice);

  fCheated = TRUE;
  SetCursor((HICON)curThink);
  fThinking = TRUE;

  if (ffirstmove)
    {
      /* HACK: Hardcode the first move hint. */
      x = 4;
      y = 2;
    }
  else
    {
      if (depth == 1)
        {
          bDone = FALSE;
          pMoves = moves;
          sq = *pMoves;
          while (!bDone)
            {
              sq = *pMoves;
              if (legalcheck(board[0], sq, human, computer))
                  bDone = TRUE;
              else
                  pMoves++;
            }
          y = (sq - 11) % 10;
          x = (sq - 11) / 10;
        }
      else
        {
          minmax(board, BestMove[0],  computer, human, 1, -infin, infin);
          y = (BestMove[1] - 11) % 10;
          x = (BestMove[1] - 11) / 10;
        }
    }

  MousePos.x = (x * xExt) + Bx + xExt/2;
  MousePos.y = (y * yExt) + By + yExt/2;

  UpdateCursor(hwnd);

  Graphics graphics(hwnd);
  
  x = x * xExt + Bx + 2 * ASPECT;
  y = y * yExt + By + 2;

  flashsqr(&graphics, x, y, xExt - 4 * ASPECT, yExt - 4, computer, TRUE, 3);

  fThinking = FALSE;

  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  gameover() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Find a human reply to the computers move.
 * As a side effect set flag fPass if the human
 * has a legal move.
 */

VOID NEAR PASCAL gameover(
register HWND   hWindow,
Graphics       *g,
BYTE            b[max_depth + 2][BoardSize],
INT             r)

{
  register INT  i;
  INT           cc;
  INT           hc;
  INT           sq;
  INT           reply2;
  INT           *pMoves;

  pMoves = moves;
  fPass = PASS;
  reply2 = PASS;
  while ((sq = *pMoves++) != 0)
    {
      if (legalcheck(b[0], sq, human, computer))
          fPass = sq;
      else if (legalcheck(b[0], sq, computer, human))
          reply2 = sq;
    }

  if (fPass == PASS)
    {
      if ((r == PASS) || (reply2 == PASS))
        {
          hc = 0;
          cc = 0;
          for (i=11; i <= 88; i++)
            {
              if (b[0][i] == human)
                  hc++;
              else if (b[0][i] == computer)
                  cc++;
            }

          if (hc > cc)
              RevMessage(hWindow, g, szWon, hc-cc, szWonPost);
          else if (hc < cc)
              RevMessage(hWindow, g, szLoss, cc-hc, szLossPost);
          else
              RevMessage(hWindow, g, szTie, 0, NULL);
        }
      else
        {
          RevMessage(hWindow, g, szMustPass, 0, NULL);
        }
    }
  else if (r == PASS)
    {
      RevMessage(hWindow, g, szPass, 0, NULL);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  paintmove() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Make a move and show the results. */

VOID NEAR PASCAL paintmove(
BYTE    b[BoardSize],
INT     move,
INT    friendly,
INT    enemy)
{
  INT           d;
  INT           sq;
  INT           *p;
  register INT  i,j;
  INT           color;

  if (move != PASS)
    {
      Brush *brush;

      if (friendly == computer)
        {
          brush = brComputer;
          color = 1;
        }
      else
        {
          brush = brHuman;
          color = 2;
        }

      i = ((move - 11) / 10) * xExt + Bx + 2 * ASPECT;
      j = ((move - 11) % 10) * yExt + By + 2;

      Pen pen(brush, 1.0f, UnitWorld);

      g->DrawEllipse(&pen, i, j, xExt - 4 * ASPECT, yExt - 4);
      flashsqr(g, i, j, xExt - 4 * ASPECT, yExt - 4, color, FALSE, 4);

      p = direc;
      while ((d = *p++) != 0)
        {
          sq=move;
          if (b[sq += d] == enemy)
           {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == (BYTE)friendly)
               {
                 while(b[sq -= d] == enemy)
                   {
                     board[0][sq] = b[sq] = friendly;
                     i = ((sq - 11)/10)*xExt+Bx+2*ASPECT;
                     j = ((sq - 11)%10)*yExt+By+2;
                     g->FillEllipse(brush, i, j, xExt-4*ASPECT, yExt-4);
                   }
               }
           }
        }
      b[move]=friendly;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMenu() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_COMMAND messages. */

VOID NEAR PASCAL RevMenu(
register HWND   hWindow,
INT             idval)

{
  HDC           hDC;
  register INT  cmd;

  if (fThinking)
      return;

  hWin = hWindow;

  switch (idval)
    {
      case EXIT:
          PostMessage(hWindow, WM_CLOSE, 0, 0L);
          break;

      case MN_HELP_ABOUT:
          DialogBox((HINSTANCE)hInst, MAKEINTRESOURCE(3), hWindow, AboutDlgProc);
          break;

      case MN_HELP_INDEX:
          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_INDEX, 0L);
          break;

      case MN_HELP_USINGHELP:
          //TEMPFIX WinHelp(hWindow, (LPSTR)NULL, HELP_HELPONHELP, 0L);
          break;

      case MN_HELP_KEYBOARD:
          cmd = 0x1e;
          goto HelpCommon;

      case MN_HELP_COMMANDS:
          cmd = 0x20;
          goto HelpCommon;

      case MN_HELP_PLAYING:
          cmd = 0x21;
          goto HelpCommon;

      case MN_HELP_RULES:
          cmd = 0x22;
HelpCommon:
          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_CONTEXT, (DWORD)cmd);
          break;

      case HINT:
          ShowBestMove(hWindow);
          return;
          break;

      case NEW:
          SetWindowText(hWindow , (LPWSTR)szReversi);
          ffirstmove = TRUE;
          g = new Graphics(hWindow);
          fCheated = FALSE;
          ClearMessageTop(g);
          fPass = PASS;
          clearboard(board);
          drawboard(board);
          delete g;
          g = NULL;
          break;

      case EASY:
          depth = 1;                      /* MUST BE AT LEAST 1.  */
          checkdepth(hWindow, EASY);      /* KEEP HANDS OFF!      */
          break;

      case MEDIUM:
          depth = 2;
          checkdepth(hWindow, MEDIUM);
          break;

      case HARD:
          depth = 4;
          checkdepth(hWindow, HARD);
          break;

      case VHARD:
          depth = 6;
          checkdepth(hWindow, VHARD);
          break;

      case PASS:
          if (fPass == PASS)
            {
              g = new Graphics(hWindow);
              fThinking = TRUE;
              ClearMessageTop(g);
              SetCursor((HICON)curThink);
              delete g;
              g = NULL;
              minmax(board, PASS, human, computer, 0, -infin, infin);
              g = new Graphics(hWindow);
              paintmove(board[0], BestMove[0], (BYTE)computer, (BYTE)human);
              gameover(hWindow, g, board, BestMove[0]);
              SetCursor((HICON)curIllegal);
              fThinking = FALSE;
              delete g;
              g = NULL;
            }
          else
              MessageBox(hWindow, (LPWSTR)szNoPass, (LPWSTR)szReversi, MB_OK | MB_ICONASTERISK);
          break;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  msgcheck() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called by ASM routine to allow other tasks to run. */

BOOL NEAR PASCAL msgcheck()
{
  MSG msg;

  if (PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE))
    {
      if (msg.message == WM_QUIT)
        exit(0);

      if (TranslateAccelerator(msg.hwnd, (HACCEL)hAccel, (LPMSG)&msg) == 0)
        {
          TranslateMessage((LPMSG)&msg);
          DispatchMessage((LPMSG)&msg);
        }

      return(TRUE);
    }
  return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevInit() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL RevInit(
HANDLE hInstance)

{
  register PWNDCLASS    pRevClass;
  HDC                   hdc;
  static INT rgpat[] = { 170, 85, 170, 85, 170, 85, 170, 85 };

  brWhite = new SolidBrush(Color::White);
  brBlack = new SolidBrush(Color::Black);
  Bitmap *bmdel = new Bitmap(8, 8, 4, PIXFMT_1BPP_INDEXED, (BYTE*)rgpat);
  brPat   = new TextureBrush((Bitmap *)bmdel);
  
  if (!brPat)
      return(FALSE);
  
  delete bmdel;
  
  ffirstmove = TRUE;
  hdc = GetDC((HWND)NULL);

  COLOR = GetDeviceCaps(hdc, NUMCOLORS) > 2;

  if (GetDeviceCaps(hdc, VERTRES) == 200)
      ASPECT = 2;
  else
      ASPECT = 1;
  ReleaseDC((HWND)NULL, hdc);

  brRed    = new SolidBrush(Color::Red);
  brGreen  = new SolidBrush(Color::Green);
  brBlue   = new SolidBrush(Color::Blue);

  LOGBRUSH logbrush;
  logbrush.lbStyle = BS_SOLID;
  logbrush.lbColor = Color::White;
  logbrush.lbHatch = 0;
  hbrWhite = CreateBrushIndirect(&logbrush);

  logbrush.lbColor = Color::Green;
  hbrGreen = CreateBrushIndirect(&logbrush);
  
  if (!brRed || !brGreen || !brBlue || !hbrWhite || !hbrGreen)
      return(FALSE);

  LoadStringW((HINSTANCE)hInstance, 3,  (LPWSTR)szReversi, 20);
  LoadStringW((HINSTANCE)hInstance, 4,  (LPWSTR)szReversiPractice, 40);
  LoadStringW((HINSTANCE)hInstance, 5,  (LPWSTR)szPass, 30);
  LoadStringW((HINSTANCE)hInstance, 6,  (LPWSTR)szMustPass, 30);
  LoadStringW((HINSTANCE)hInstance, 7,  (LPWSTR)szTie, 30);
  LoadStringW((HINSTANCE)hInstance, 8,  (LPWSTR)szLoss, 30);
  LoadStringW((HINSTANCE)hInstance, 9,  (LPWSTR)szWon, 30);
  LoadStringW((HINSTANCE)hInstance, 10, (LPWSTR)szAbout, 20);
  LoadStringW((HINSTANCE)hInstance, 11, (LPWSTR)szLossPost, 30);
  LoadStringW((HINSTANCE)hInstance, 12, (LPWSTR)szWonPost, 30);
  LoadStringW((HINSTANCE)hInstance, 13, (LPWSTR)szIllegal, 70);
  LoadStringW((HINSTANCE)hInstance, 14, (LPWSTR)szNoPass, 70);
  LoadStringW((HINSTANCE)hInstance, 15, (LPWSTR)szHelpFile, 15);

  hAccel = LoadAccelerators((HINSTANCE)hInstance, (LPWSTR)"MAINACC");
  pRevClass = (PWNDCLASS)((CHAR *)LocalAlloc(LMEM_ZEROINIT, sizeof(WNDCLASS)));
  if (!pRevClass)
      return(FALSE);

  curLegal   = LoadCursorW(NULL, IDC_CROSS);
  curIllegal = LoadCursorW(NULL, IDC_ARROW);
  curThink   = LoadCursorW(NULL, IDC_WAIT);
  curBlank   = LoadCursorW((HINSTANCE)hInstance, MAKEINTRESOURCE(1));
  if (!curLegal || !curIllegal || !curThink || !curBlank)
      return(FALSE);
  pRevClass->hIcon = LoadIcon((HINSTANCE)hInstance, MAKEINTRESOURCE(3));

  pRevClass->lpszClassName = (LPWSTR)"Reversi";
  pRevClass->hbrBackground = ((COLOR) ? hbrGreen : hbrWhite);
  pRevClass->lpfnWndProc   = ReversiWndProc;
  pRevClass->lpszMenuName  = MAKEINTRESOURCE(1);
  pRevClass->hInstance    = (HINSTANCE)hInstance;
  pRevClass->style         = CS_VREDRAW | CS_HREDRAW | CS_BYTEALIGNCLIENT;

  if (!RegisterClass((LPWNDCLASS)pRevClass))
    {
      LocalFree((HANDLE)pRevClass);
      return(FALSE);
    }
  LocalFree((HANDLE)pRevClass);

  return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMouseClick() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMouseClick(
HWND  hWnd,
POINT point)
{
  INT     move;
  INT     Si, Sj;
  INT     yLineExt = 8 * yExt;
  INT     xLineExt = 8 * xExt;
  HDC     hDC;

  MousePos.x = point.x;
  MousePos.y = point.y;

  if (xExt == 0 || yExt == 0)
      return;

  if ((point.x > Bx) && (point.x < (Bx+xLineExt)) && (point.y > By) && (point.y < (By+yLineExt)))
    {
      Si = (point.x - Bx) / xExt;
      Sj = (point.y - By) / yExt;
      move = Si * 10 + Sj + 11;
      if (legalcheck(board[0], move, human, computer))
        {
          board[0][move] = human;
          ffirstmove = FALSE;
          fThinking = TRUE;
          SetCursor((HICON)curThink);

          Graphics *gtemp;
          gtemp = g = new Graphics(hWnd);
          ClearMessageTop(g);

          minmax(board, move, human, computer, 0, -infin, infin);
          makemove(board[0], move, human, computer);

          g = gtemp;

          paintmove(board[0], BestMove[0], computer, human);
          gameover(hWnd, g, board, BestMove[0]);

          delete g;
          g = NULL;
          
          SetCursor((HICON)curIllegal);
          fThinking = FALSE;
        }
      else
          MessageBox(hWnd, (LPWSTR)szIllegal, (LPWSTR)szReversi, MB_OK | MB_ICONASTERISK);
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Next() -                                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL Next(
register INT *px,
register INT *py)

{
  (*px)++;
  if (*px > 7)
    {
      *px = 0;
      (*py)++;
      if (*py > 7)
          *py = 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Previous() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL Previous(
register INT *px,
register INT *py)
{
  (*px)--;
  if (*px < 0)
    {
      *px = 7;
      (*py)--;
      if (*py < 0)
          *py = 7;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowNextMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowNextMove(
HWND    hwnd,
BOOL    fforward)
{
  INT       x, y;
  INT       potentialmove;
  BOOL      done;

  /* What out for infinite loops. */
  if (fPass == PASS && !ffirstmove)
      return;

  x = (MousePos.x - Bx) / xExt;
  y = (MousePos.y - By) / yExt;

  done = FALSE;
  while (!done)
    {
      do
        {
          if (fforward)
              Next(&x, &y);
          else
              Previous(&x, &y);
        }
      while ((board[0][potentialmove = (x * 10 + y + 11)]) != empty);

      fThinking = TRUE;
      if (legalcheck(board[0], potentialmove, human, computer))
          done = TRUE;

      fThinking = FALSE;
    }

  MousePos.x = x * xExt + Bx + xExt / 2;
  MousePos.y = y * yExt + By + yExt / 2;

  UpdateCursor(hwnd);
  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevChar() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevChar(
HWND            hwnd,
register WORD   code)
{
  INT   a;
  POINT curpoint;

  curpoint.x = curpoint.y = 1;
  switch (code)
    {
      case 0x27:
          MousePos.x += xExt;
          break;

      case 0x28:
          MousePos.y += yExt;
          break;

      case 0x25:
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.x -= xExt;
          break;

      case 0x26:
          curpoint.y = (MousePos.y - By)/yExt;
          MousePos.y -= yExt;
          break;

      case 0x24:
          curpoint.y = (MousePos.y - By)/yExt;
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.y -= yExt;
          MousePos.x -= xExt;
          break;

      case 0x21:
          curpoint.y = (MousePos.y - By)/yExt;
          MousePos.y -= yExt;
          MousePos.x += xExt;
          break;

      case 0x23:
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.y += yExt;
          MousePos.x -= xExt;
          break;

      case 0x22:
          MousePos.y += yExt;
          MousePos.x += xExt;
          break;

      case 0x0020:
      case 0x000D:
          if (!fThinking)
              RevMouseClick(hwnd, MousePos);
          return;

      case 0x0009:
          if (fThinking)
              break;
          if (GetKeyState(VK_SHIFT) < 0)
              ShowNextMove(hwnd, FALSE);    /* look backwards */
          else
              ShowNextMove(hwnd, TRUE);     /* look forwards */
          return;

      default:
          return;
    }

  if (((a = ((MousePos.x - Bx) / xExt)) >7) || a <= 0)
      MousePos.x = Bx + xExt / 2;             /* wrap around horizontally */

  if (a > 8 || (curpoint.x == 0 && a == 0))
      MousePos.x = (7*xExt) + Bx + xExt / 2 ;

  if ( ((a = ((MousePos.y - By) / yExt)) >7) || a <= 0)
      MousePos.y = By + yExt / 2;

  if ( a > 8 || (curpoint.y == 0 && a == 0))
      MousePos.y = (7*yExt) + By + yExt / 2;

  MousePos.x = ((MousePos.x - Bx) / xExt) * xExt + Bx + xExt / 2;
  MousePos.y = ((MousePos.y - By) / yExt) * yExt + By + yExt / 2;
  UpdateCursor(hwnd);
  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InverseMessage() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID APIENTRY InverseMessage(
register HWND   hWindow,
UINT            message,
UINT_PTR        wParam,
DWORD           lParam)
{
  HDC   hDC;

  message;
  wParam;
  lParam;

  if (flashtimes <= count)
    {

     // !! THIS STILL NEEDS WORK: How to do Inversion?
     //Graphics graphics(hWindow);
     // graphics.FillRectangle(hDC, 0, 0, xscr, charheight, DSTINVERT);
     // flashtimes++;
     // ReleaseDC(hWindow, hDC);
    }
  else
      KillTimer(hWindow, 666);

  return;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReversiWndProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LRESULT APIENTRY ReversiWndProc(
HWND            hWnd,
register UINT   message,
WPARAM          wParam,
LPARAM          lParam)
{
  HMENU         hm;
  PAINTSTRUCT   ps;
  POINT         curpoint;

  switch (message)
    {
      case WM_COMMAND:
          RevMenu(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
          break;

      case WM_INITMENU:                 /* disable the menu if thinking */
          hm = GetMenu(hWnd);
          if (fThinking)
            {
              EnableMenuItem(hm, 0, MF_DISABLED | MF_BYPOSITION);
              EnableMenuItem(hm, 1, MF_DISABLED | MF_BYPOSITION);
            }
          else
            {
              EnableMenuItem(hm, 0, MF_ENABLED | MF_BYPOSITION);
              EnableMenuItem(hm, 1, MF_ENABLED | MF_BYPOSITION);
            }
          break;

      case WM_CREATE:
          RevCreate(hWnd);
          hWin = hWnd;
          break;

      case WM_CLOSE:
          if (hDisp)
              ReleaseDC(hWnd, hDisp);
          return(DefWindowProc(hWnd, message, wParam, lParam));

      case WM_DESTROY:
          if (MGetModuleUsage(hInst) == 1)
            {
              delete brGreen;
              delete brPat;
              delete brRed;
              delete brBlue;
            }

          /* In case WinHelp keys off hWindow, we need to do the HELP_QUIT
           * here instead of when there is just one instance of help...
           */
          //TEMPFIX WinHelp(hWnd, (LPSTR)szHelpFile, HELP_QUIT, 0L);

          PostQuitMessage(0);
          break;

      case WM_KEYDOWN:
          if (IsIconic(hWnd))
              return 0L;
          RevChar(hWnd, (WORD)wParam);
          break;

      case WM_ACTIVATE:
          if (!GetSystemMetrics(SM_MOUSEPRESENT))
            {
              if (GET_WM_ACTIVATE_STATE(wParam, lParam))
                {
                  if (GET_WM_ACTIVATE_HWND(wParam, lParam) != hWnd)
                    {
                      curpoint.x = MousePos.x;
                      curpoint.y = MousePos.y;
                      ClientToScreen(hWnd, (LPPOINT)&curpoint);
                      SetCursorPos(curpoint.x, curpoint.y);
                      RevMouseMove(MousePos);
                      ShowCursor(GET_WM_ACTIVATE_STATE(wParam, lParam));
                    }
                }
              else
                  ShowCursor((BOOL) wParam);
            }
          if (wParam && (!HIWORD(lParam)))
              SetFocus(hWnd);
          break;

      case WM_PAINT:
          BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);
          {
             Graphics graphics(ps.hdc);
			 RECT rect;
			 GetClientRect(hWnd, &rect);
		     RectF rectf(rect.left, 
						 rect.top, 
						 rect.right-rect.left, 
						 rect.bottom-rect.top);
			 graphics.SetClip(rectf);
             RevPaint(hWnd, &graphics);
          }
          EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
          break;

      case WM_MOUSEMOVE:
		  {
		  POINT pt;

		  LONG2POINT(lParam, pt);		/* convert LONG lParam to POINT structure*/
          if (!fThinking)
#ifdef ORGCODE		
              RevMouseMove(MAKEPOINT(lParam));
#else
              RevMouseMove(pt);
#endif
          else
              SetCursor((HICON)curThink);
          break;
		  }
      case WM_LBUTTONDOWN:
          SetCapture(hWnd);
          bMouseDownInReversi = TRUE;
          break;

      case WM_LBUTTONUP:
		  {
		  POINT pt;

		  LONG2POINT(lParam, pt);		/* convert LONG lParam to POINT structure*/

          ReleaseCapture();
          if (!fThinking && bMouseDownInReversi)
#ifdef ORGCODE
              RevMouseClick(hWnd, MAKEMPOINT(lParam));
#else
              RevMouseClick(hWnd, pt);
#endif
          bMouseDownInReversi = FALSE;
          break;
		  }
      case WM_TIMER:
          /* This should never be called. */
          break;

      case WM_VSCROLL:
      case WM_HSCROLL:
              break;

      default:
          return(DefWindowProc(hWnd, message, wParam, lParam));
          break;
      }
  return(0L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AboutDlgProc()                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR APIENTRY AboutDlgProc(
HWND          hDlg,
UINT          message,
WPARAM        wParam,
LPARAM        lParam)

{
  if (message == WM_COMMAND)
    {
      EndDialog(hDlg, TRUE);
      return(TRUE);
    }
  if (message == WM_INITDIALOG)
      return(TRUE);
  else
      return(FALSE);
  UNREFERENCED_PARAMETER(wParam);	
  UNREFERENCED_PARAMETER(lParam);	
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WinMain() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

MMain(hInstance, hPrev, lpszCmdLine, cmdShow) /* { */
  HWND hWnd;
  MSG   msg;

  _argc;
  _argv;

  hInst = hInstance;
  if (!hPrev)
    {
      if (!RevInit(hInstance))
          return(FALSE);
    }
  else
    {
      if (fThinking)
          return FALSE;
#ifdef WIN16
      GetInstanceData(hPrev, (PSTR)&hbrBlack,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrPat,             sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrWhite,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrRed,             sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrBlue,            sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrGreen,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrComputer,        sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrHuman,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&curIllegal,         sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curLegal,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curThink,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curBlank,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&prevCheck,          sizeof(prevCheck));
      GetInstanceData(hPrev, (PSTR)&depth,              sizeof(depth));
      GetInstanceData(hPrev, (PSTR)direc,               sizeof(direc));
      GetInstanceData(hPrev, (PSTR)moves,               sizeof(moves));
      GetInstanceData(hPrev, (PSTR)szReversi,           20);
      GetInstanceData(hPrev, (PSTR)szReversiPractice,   40);
      GetInstanceData(hPrev, (PSTR)szPass,              10);
      GetInstanceData(hPrev, (PSTR)szMustPass,          20);
      GetInstanceData(hPrev, (PSTR)szTie,               15);
      GetInstanceData(hPrev, (PSTR)szLoss,              15);
      GetInstanceData(hPrev, (PSTR)szWon,               15);
      GetInstanceData(hPrev, (PSTR)szAbout,             20);
      GetInstanceData(hPrev, (PSTR)&COLOR,              sizeof(INT));
      GetInstanceData(hPrev, (PSTR)&ASPECT,             sizeof(INT));
      GetInstanceData(hPrev, (PSTR)&hAccel,             2);
      GetInstanceData(hPrev, (PSTR)szIllegal,           70);
      GetInstanceData(hPrev, (PSTR)szNoPass,            70);
      GetInstanceData(hPrev, (PSTR)szHelpFile,          15);
#endif /* WIN16 */
    }

  TYMIN = 45;
  fThinking = FALSE;

  hWnd = CreateWindow((LPWSTR) "Reversi",
                fCheated ? (LPWSTR)szReversiPractice : (LPWSTR)szReversi,
                WS_TILEDWINDOW,
                CW_USEDEFAULT,
                0,
                (GetSystemMetrics(SM_CXSCREEN) >> 1),
                (GetSystemMetrics(SM_CYSCREEN) * 4 / 5),
                (HWND)NULL,
                (HMENU)NULL,
                (HINSTANCE)hInstance,
                NULL);

  if (!hWnd)
      return(FALSE);

  ShowWindow(hWnd, cmdShow);
  UpdateWindow(hWnd);

  /* Messaging Loop. */
  while (GetMessage((LPMSG)&msg, NULL, 0, 0))
    {
      if (!TranslateAccelerator(msg.hwnd, (HACCEL)hAccel, (LPMSG)&msg))
        {
          TranslateMessage((LPMSG)&msg);
          DispatchMessage((LPMSG)&msg);
        }
    }
  return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\samples\shapes\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\samples\shapes\test.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998 Microsoft Corporation
*
* Module Name:
*
*   Test Cases to test our shapes
*
* Abstract:
*
*   This module will create some shapes. Save them to a metafile
*   and draw them in our window
*
* Created:
*
*   03/13/2000 gillesk
*
\**************************************************************************/

#include "stdafx.h"
#include "shapes.h"

#define METAFILENAME L"MetaFile Sample.emf"


// Animate a shape. Fixed Size
VOID AnimateShape(Shape *shape, Graphics *g)
{
    // Validate Parameters
    if(shape != NULL && g != NULL)
    {
        // Draw a set of rotated shapes... From bigger to smaller
        // For now the size if fixed
        for(INT i = 18; i>0; i--)
        {
            shape->SetSize(10.0f*i, 10.0f*i);
            shape->SetAngle(i*10.0f);
            shape->Draw(g);

            // It important to flush to have a nice animation...
            g->Flush();
            Sleep(50);
        }
    }
}

// Draw some solid shapes
VOID TestSolidShapes(Graphics *g)
{
    // Validate Parameters
    if(g == NULL)
        return;

    // Create some brushes
    SolidBrush black(Color::Black);
    SolidBrush white(Color::White);
    SolidBrush transRed(Color(128, 255, 0, 0));
	SolidBrush transPink(Color(60, 255, 128, 255));

	// Create some pens
    Pen blackPen(Color::Black, 5);
	Pen bluePen(Color(255, 0, 0, 255), 10);
	Pen greenPen(Color(255, 0, 255, 0), 3);
    
    // Create some different shapes
    RectShape rect(&bluePen, &black, &black, L"Rectangle", L"Comic Sans MS");
    rect.SetPosition(50, 100);
    rect.SetSize(50, 50);
    rect.SetAngle(45);

    StarShape star(5, NULL, &transRed, &black, L"Star");
    star.SetPosition(150, 50);
    star.SetSize(50, 50);
    star.SetAngle(30);

    PieShape pie(&blackPen, &transPink, &black, L"Pie");
    pie.SetPosition(250, 50);
	pie.SetSize(100, 200);
    pie.SetAngle(-30);
    pie.SetPieAngle(90);

    EllipseShape circle(&greenPen, &white, &black, L"Ellipse");
    circle.SetPosition(400, 100);
    circle.SetSize(50, 200);

    RegularPolygonShape pentagon(5, NULL, &transPink, &black, L"Pentagon");
    pentagon.SetPosition(550, 50);
    pentagon.SetSize(100, 100);
    pentagon.SetAngle(14);

    CrossShape cross(&greenPen, &transRed, &black, L"Cross");
    cross.SetPosition(550, 150);
    cross.SetSize(50, 50);
    cross.SetAngle(30);
    
    // Draw all shapes
    rect.Draw(g);
    star.Draw(g);
    pie.Draw(g);
    circle.Draw(g);
    cross.Draw(g);
    pentagon.Draw(g);
}


// Draw some gradient shapes
VOID TestGradientShapes(Graphics *g)
{
    // Validate Parameters
    if(g == NULL)
        return;

    SolidBrush black(Color::Black);
	
    // Create the four exterior colors that will control the gradient
    Color gradColor[4] = {
		Color(128, 255, 0, 0),
		Color(255, 255, 255, 0),
		Color(128, 0, 255, 0),
		Color(128, 0, 0, 255)
	};


    // Do a linear gradient Brush and Pen
    LinearGradientBrush linearGradientBrush(Point(-100, -100), 
        Point(100, 100),
        Color(255, 0, 0, 255),
        Color(128, 255, 0, 0)
        );

    RegularPolygonShape polygon(10,
        NULL,
        &linearGradientBrush,
        &black,
        L"Gradient Polygons",
        L"Times New Roman"
        );

    polygon.SetSize(100, 100);
    polygon.SetPosition(500, 300);
    polygon.Draw(g);

    Pen gradPen(&linearGradientBrush);
    gradPen.SetWidth(20);

    // Make the line intersection round
    gradPen.SetLineJoin(LineJoinRound);

    // Draw a triangle. And then draw it animated
    RegularPolygonShape triangle(3, &gradPen, NULL);
    triangle.SetSize(100, 100);
    triangle.SetPosition(500, 300);
    triangle.SetAngle(180);
    triangle.Draw(g);
    triangle.SetPosition(500, 700);
    AnimateShape(&triangle, g);


    // Do a Path gradient brush, with colors at the four corners of a polygon
    Point Squarepoints[4] =
    { 
        Point(-100, -100), 
        Point(-100,100),
        Point(100,100),
        Point(100,-100)
    };

    INT size = numberof(gradColor);

	PathGradientBrush gradBrush(Squarepoints,
        numberof(Squarepoints),
        WrapModeClamp); // WrapModeExtrapolate is no longer supported.

    gradBrush.SetSurroundColors(gradColor, &size );
    gradBrush.SetCenterColor(Color(128, 128, 128, 64));
	
    // Draw an animated star
    StarShape star(12, NULL, &gradBrush);
    star.SetPosition(200, 300);
    AnimateShape(&star, g);

    // Draw some text now
    Shape Text(NULL, NULL, &black, L"Gradient Animated Star", L"Comic Sans MS");
    Text.SetPosition(100, 400);
    Text.Draw(g);
}


// Draw some textures shapes
VOID TestTextureShapes(Graphics *g)
{
    // Verify parameters
    if(g == NULL)
        return;

    SolidBrush black(Color::Black);

    // Load the texture
    Image texture(L"Texture.bmp");
    if(texture.GetLastStatus() != Ok)
        return;

    // Create a brush out of the texture
    TextureBrush textureBrush(&texture, WrapModeTile);

    // Draw an animated star
    StarShape star(6, NULL);
    star.SetPosition(150, 600);
    star.SetBrush(&textureBrush);
    AnimateShape(&star, g);

    // Draw some text now
    Shape Text(NULL, NULL, &black, L"Textured Animated Star", L"Comic Sans MS");
    Text.SetPosition(100, 750);
    Text.Draw(g);

    // Draw a polygon with a thick pen and a Clamped texture
    textureBrush.SetWrapMode(WrapModeClamp);
    Pen texturePen(&textureBrush);
    texturePen.SetWidth(30);
    RegularPolygonShape polygon(10, &texturePen, NULL, &black, L"Textured Polygon", L"Times New Roman");
    polygon.SetSize(100, 100);
    polygon.SetPosition(500, 500);
    polygon.Draw(g);
}

// Draw some hatched shapes
VOID TestHatchShapes(Graphics *g)
{
    // Verify parameters
    if(g == NULL)
        return;

    SolidBrush black(Color::Black);

    // Silver on Blue vertical hatch
    HatchBrush brush(HatchStyleVertical, Color::Silver, Color::Blue);

    Pen pen(&brush, 3.0f);
    pen.SetLineJoin(LineJoinRound);

    HatchBrush crossBrush(HatchStyleCross, Color::Fuchsia, Color::Red);

    StarShape star(8, &pen, &crossBrush, &black, L"Hatched Star");
    star.SetPosition(800, 75);
    star.SetSize(100, 100);
    star.Draw(g);

    pen.SetWidth(10);
    RegularPolygonShape line(2, &pen, NULL, &black, L"Hatched Line");
    line.SetPosition(800, 250);
    line.SetSize(100, 200);
    line.SetAngle(10);
    line.Draw(g);

    HatchBrush diagBrush(HatchStyleDiagonalCross, Color::Green, Color::White);
    CrossShape cross(NULL, &diagBrush, &black, L"Hatched Cross");
    cross.SetPosition(800, 400);
    cross.SetSize(50, 50);
    cross.Draw(g);
}


// Overall test
VOID TestRoutine(Graphics *g)
{
    // Verify parameters
    if(g == NULL)
        return;

    // Test some simple solid shapes
	TestSolidShapes(g);

    // Test some shapes with a gradient brush
	TestGradientShapes(g);

    // Test some shapes with some texture brushes
    TestTextureShapes(g);

    // Test some hatch pens and brushes
    TestHatchShapes(g);

    // Flush the graphics to make sure everything is displayed
    g->Flush();
}


// Draw to a metafile
VOID TestMetaFile(HDC hdc)
{
    // Create a metafile from the DC. We want to encompass the full region of the window
    // We want the units to be Pixels
    Metafile meta(METAFILENAME, hdc, RectF( 0.0f, 0.0f, 1600.0f, 1200.0f), MetafileFrameUnitPixel);

    // Create a graphics context for this metafile
    Graphics g(&meta);

    // Draw into the metafile
    TestRoutine(&g);
}


// Test routine
// Draw to a window
// Draw to a metafile
// Read the metafile, and draw it in our window with an offset
VOID Test(HWND hwnd)
{
    Graphics* g = Graphics::FromHWND(hwnd);
    TestRoutine(g);

    HDC dc = GetDC(hwnd);
    TestMetaFile(dc);
    ReleaseDC(hwnd, dc);

    Metafile meta(METAFILENAME);
    g->DrawImage(&meta, 100.0f, 100.0f);
    delete g;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\samples\shapes\wndstuff.cpp ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.cpp
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

#include "stdafx.h"
// for Win95 compile
//#undef UNICODE
//#undef _UNICODE

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <gdiplus.h>

#include "wndstuff.h"

#include "../../gpinit.inc"


HINSTANCE ghInstance;
HWND ghwndMain;
HWND ghwndDebug;
HWND ghwndList;
HBRUSH ghbrWhite;

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LRESULT
_stdcall lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    switch (message)
    {
    case WM_CREATE:
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case MM_TEST:
            Test(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
//        UninitializeEngine();

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}

/******************************Public*Routine******************************\
* DebugWndProc
*
* List box is maintained here.
*
\**************************************************************************/

LRESULT FAR PASCAL DebugWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    LRESULT lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = (LONG) DefWindowProc(ghwndList, message, wParam, lParam);
        GetClientRect(ghwndMain, &rcl);
        MoveWindow(
            ghwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(ghwndList);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    if (ghwndList)
    {
        va_list ap;
        char buffer[256];

        va_start(ap, msg);

        vsprintf(buffer, msg, ap);

        SendMessage(ghwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
        SendMessage(ghwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
        InvalidateRect(ghwndList, NULL, TRUE);
        UpdateWindow(ghwndList);

        va_end(ap);
    }
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    if (ghwndList)
        SendMessage(ghwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(BOOL debug)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = _T("MainMenu");
    wc.lpszClassName    = _T("TestClass");
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        _T("TestClass"),
        _T("Win32 Test"),
        WS_OVERLAPPED   |  
        WS_CAPTION      |  
        WS_BORDER       |  
        WS_THICKFRAME   |  
        WS_MAXIMIZEBOX  |  
        WS_MINIMIZEBOX  |  
        WS_CLIPCHILDREN |  
        WS_VISIBLE      |  
        WS_SYSMENU,
        80,
        70,
        500,
        500,
        NULL,
        NULL,
        ghInstance,
        NULL);

    if (ghwndMain == NULL)
    {
        return(FALSE);
    }

    if (debug)
    {
        RECT rcl;

        memset(&wc, 0, sizeof(wc));
        wc.style = 0;
        wc.lpfnWndProc = DebugWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = ghInstance;
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = ghbrWhite;
        wc.lpszClassName = _T("DebugWClass");
        RegisterClass(&wc);

        ghwndDebug = CreateWindow(
            _T("DebugWClass"),
            _T("Debug output"),
            WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
            600,
            70,
            300,
            500,
            NULL,
            NULL,
            ghInstance,
            NULL
            );

        if (ghwndDebug)
        {
            ShowWindow(ghwndDebug, SW_NORMAL);
            UpdateWindow(ghwndDebug);

        // Create the list box to fill the main window.

            GetClientRect(ghwndDebug, &rcl);

            ghwndList = CreateWindow(
                _T("LISTBOX"),
                _T("Debug output"),
                WS_CHILD | WS_VISIBLE | WS_VSCROLL
                | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                rcl.left, rcl.top,
                (rcl.right - rcl.left), (rcl.bottom - rcl.top),
                ghwndDebug,
                NULL,
                ghInstance,
                NULL
                );

            if (ghwndList)
            {
                SendMessage(
                    ghwndList,
                    WM_SETFONT,
                    (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                    (LPARAM) FALSE
                    );

                LBreset();

                ShowWindow(ghwndList, SW_NORMAL);
                UpdateWindow(ghwndList);
            }
        }

    }

    SetFocus(ghwndMain);

    return(TRUE);
}

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/


_cdecl main(
    INT   argc,
    PTCHAR argv[])
{
    MSG    msg;
    HACCEL haccel;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }
    
    BOOL wantDebugWindow = FALSE;

    CoInitialize(NULL);

    // Parse arguments

    for (argc--, argv++ ; argc && '-' == **argv ; argc--, argv++ )
    {
        switch ( *(++(*argv)) )
        {
        case 'd':
        case 'D':
            wantDebugWindow = TRUE;
            break;
        }
    }

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp(wantDebugWindow))
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\ddhelper.cpp ===
// File:	ddhelper.cpp
// Author:	Michael Marr    (mikemarr)

#include "StdAfx.h"
#include "DDHelper.h"
#include "Blt.h"

const PALETTEENTRY g_peZero = {0, 0, 0, 0};
const GUID g_guidNULL = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};

const DDPIXELFORMAT g_rgDDPF[iPF_Total] = {
	{sizeof(DDPIXELFORMAT), 0, 0, 0, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED1, 0, 1, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED2, 0, 2, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED4, 0, 4, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED8, 0, 8, 0x00, 0x00, 0x00, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 8, 0xE0, 0x1C, 0x03, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_ALPHAPIXELS, 0, 16, 0xF00, 0xF0, 0xF, 0xF000},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0xF800, 0x07E0, 0x001F, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x001F, 0x07E0, 0xF800, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x7C00, 0x03E0, 0x001F, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_ALPHAPIXELS, 0, 16, 0x7C00, 0x03E0, 0x001F, 0x8000},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0xFF0000, 0xFF00, 0xFF, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0xFF, 0xFF00, 0xFF0000, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0xFF0000, 0xFF00, 0xFF, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0xFF, 0xFF00, 0xFF0000, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_ALPHAPIXELS, 0, 32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000},
	{sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_ALPHAPIXELS, 0, 32, 0xFF, 0xFF00, 0xFF0000, 0xFF000000},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0xFF0000, 0xFF00, 0xFF, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0xFF0000, 0xFF00, 0xFF, 0x00},
	{sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0xFF, 0xFF00, 0xFF0000, 0x00}
};

/*
const GUID *g_rgpDDPFGUID[iPF_Total] = {
	&g_guidNULL,
	&DDPF_RGB1, &DDPF_RGB2, &DDPF_RGB4, &DDPF_RGB8,
	&DDPF_RGB332, &DDPF_ARGB4444, &DDPF_RGB565, &DDPF_BGR565, &DDPF_RGB555,
	&DDPF_ARGB1555, &DDPF_RGB24, &DDPF_BGR24, &DDPF_RGB32, &DDPF_BGR32,
	&DDPF_ARGB32, &DDPF_ABGR32, &DDPF_RGB24, &DDPF_RGB32, &DDPF_BGR32
};

DWORD
GetPixelFormat(const GUID *pGUID)
{
	for (DWORD i = 0; i < iPF_RGBTRIPLE; i++) {
		if ((pGUID == g_rgpDDPFGUID[i]) ||
			IsEqualGUID(*pGUID, *g_rgpDDPFGUID[i]))
			return i;
	}
	return iPF_NULL;
}

*/
const CPixelInfo g_rgPIXI[iPF_Total] = {
	CPixelInfo(0), CPixelInfo(1), CPixelInfo(2), CPixelInfo(4), CPixelInfo(8),
	CPixelInfo(8, 0xE0, 0x1C, 0x03, 0x00),
	CPixelInfo(16, 0xF00, 0xF0, 0xF, 0xF000),
	CPixelInfo(16, 0xF800, 0x07E0, 0x001F, 0x00),
	CPixelInfo(16, 0x001F, 0x07E0, 0xF800, 0x00),
	CPixelInfo(16, 0x7C00, 0x03E0, 0x001F, 0x00),
	CPixelInfo(16, 0x7C00, 0x03E0, 0x001F, 0x8000),
	CPixelInfo(24, 0xFF0000, 0xFF00, 0xFF, 0x00),
	CPixelInfo(24, 0xFF, 0xFF00, 0xFF0000, 0x00),
	CPixelInfo(32, 0xFF0000, 0xFF00, 0xFF, 0x00),
	CPixelInfo(32, 0xFF, 0xFF00, 0xFF0000, 0x00),
	CPixelInfo(32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000),
	CPixelInfo(32, 0xFF, 0xFF00, 0xFF0000, 0xFF000000),
	CPixelInfo(24, 0xFF0000, 0xFF00, 0xFF, 0x00),
	CPixelInfo(32, 0xFF0000, 0xFF00, 0xFF, 0x00),
	CPixelInfo(32, 0xFF, 0xFF00, 0xFF0000, 0x00)
};


DWORD
GetPixelFormat(const DDPIXELFORMAT &ddpf)
{
	for (DWORD i = 0; i < iPF_RGBTRIPLE; i++) {
		if (ddpf == g_rgDDPF[i])
			return i;
	}
	return iPF_NULL;
}

DWORD
GetPixelFormat(const CPixelInfo &pixi)
{
	for (DWORD i = 0; i < iPF_RGBTRIPLE; i++)
		if (pixi == g_rgPIXI[i])
			return i;
	return iPF_NULL;
}


DWORD g_rgdwBPPToPalFlags[9] = {
	0, DDPCAPS_1BIT, DDPCAPS_2BIT, 0, DDPCAPS_4BIT,
	0, 0, 0, DDPCAPS_8BIT};
DWORD g_rgdwBPPToPixFlags[9] = {
	0, DDPF_PALETTEINDEXED1, DDPF_PALETTEINDEXED2, 0, 
	DDPF_PALETTEINDEXED4, 0, 0, 0, DDPF_PALETTEINDEXED8};

DWORD
PaletteToPixelFlags(DWORD dwFlags)
{
	if (dwFlags & DDPCAPS_8BIT) return DDPF_PALETTEINDEXED8;
	if (dwFlags & DDPCAPS_4BIT) return DDPF_PALETTEINDEXED4;
	if (dwFlags & DDPCAPS_2BIT) return DDPF_PALETTEINDEXED2;
	if (dwFlags & DDPCAPS_1BIT) return DDPF_PALETTEINDEXED1;
	return 0;
}

DWORD
PixelToPaletteFlags(DWORD dwFlags)
{
	if (dwFlags & DDPF_PALETTEINDEXED8) return DDPCAPS_8BIT;
	if (dwFlags & DDPF_PALETTEINDEXED4) return DDPCAPS_4BIT;
	if (dwFlags & DDPF_PALETTEINDEXED2) return DDPCAPS_2BIT;
	if (dwFlags & DDPF_PALETTEINDEXED1) return DDPCAPS_1BIT;
	return 0;
}

BYTE
PixelFlagsToBPP(DWORD dwFlags)
{
	if (dwFlags & DDPF_PALETTEINDEXED8) return (BYTE) 8;
	if (dwFlags & DDPF_PALETTEINDEXED4) return (BYTE) 4;
	if (dwFlags & DDPF_PALETTEINDEXED2) return (BYTE) 2;
	if (dwFlags & DDPF_PALETTEINDEXED1) return (BYTE) 1;
	return (BYTE) 0;
}

BYTE
PaletteFlagsToBPP(DWORD dwFlags)
{
	if (dwFlags & DDPCAPS_8BIT) return (BYTE) 8;
	if (dwFlags & DDPCAPS_4BIT) return (BYTE) 4;
	if (dwFlags & DDPCAPS_2BIT) return (BYTE) 2;
	if (dwFlags & DDPCAPS_1BIT) return (BYTE) 1;
	return (BYTE) 0;
}


HRESULT
CreatePlainSurface(IDirectDraw *pDD, DWORD nWidth, DWORD nHeight, 
				   const DDPIXELFORMAT &ddpf, IDirectDrawPalette *pddp,
				   DWORD dwTransColor, bool bTransparent,
				   IDirectDrawSurface **ppdds)
{
	if (!pDD || !ppdds)
		return E_INVALIDARG;

	HRESULT hr;
	DDSURFACEDESC ddsd;
	INIT_DXSTRUCT(ddsd);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_PIXELFORMAT;
	ddsd.dwWidth = nWidth;
	ddsd.dwHeight = nHeight;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
	ddsd.ddpfPixelFormat = ddpf;

	LPDIRECTDRAWSURFACE pdds;
	if (FAILED(hr = pDD->CreateSurface(&ddsd, &pdds, NULL)))
		return hr;

	// attach palette if it exists
	if (pddp && FAILED(hr = pdds->SetPalette(pddp))) {
		pdds->Release();
		return hr;
	}

	// set the source color key
	if (bTransparent) {
		DDCOLORKEY ddck = {dwTransColor, dwTransColor};
		if (FAILED(hr = pdds->SetColorKey(DDCKEY_SRCBLT, &ddck))) {
			pdds->Release();
			return hr;
		}
	}

	*ppdds = pdds;

	return hr;
}


HRESULT
CreatePalette(IDirectDraw *pDD, const BYTE *pPalette, DWORD cEntries, 
			  BYTE nBPPTarget, const CPixelInfo &pixiPalFmt, 
			  IDirectDrawPalette **ppddp)
{
	if (!ppddp)
		return E_POINTER;

	if (!pDD || !pPalette || (cEntries > 256) || (nBPPTarget == 0) || (nBPPTarget > 8))
		return E_INVALIDARG;

	HRESULT hr;
	PALETTEENTRY rgpe[256];

	if ((pixiPalFmt != g_rgPIXI[iPF_PALETTEENTRY]) || (cEntries < (DWORD(1) << nBPPTarget))) {
		// copy info to palette
		if (FAILED(hr = BltFastRGBToRGB(pPalette, 0, (LPBYTE) rgpe, 0, cEntries, 
							1, pixiPalFmt, g_rgPIXI[iPF_PALETTEENTRY])))
			return hr;
		// zero out extra palette entries
		ZeroDWORDAligned((LPDWORD) rgpe + cEntries, 256 - cEntries);
		pPalette = (const BYTE *) rgpe;
	}

	DWORD dwPalFlags = BPPToPaletteFlags(nBPPTarget) | DDPCAPS_ALLOW256;
	return pDD->CreatePalette(dwPalFlags, (LPPALETTEENTRY) pPalette, ppddp, NULL);
}


HRESULT
ClearToColor(LPRECT prDst, LPDIRECTDRAWSURFACE pdds, DWORD dwColor)
{
	HRESULT hr;
	MMASSERT(pdds);
	
	DDBLTFX ddbfx;
	INIT_DXSTRUCT(ddbfx);
	ddbfx.dwFillColor = dwColor;
	
	RECT rDst;
	if (prDst == NULL) {
		::GetSurfaceDimensions(pdds, &rDst);
		prDst = &rDst;
	}

	hr = pdds->Blt(prDst, NULL, NULL, DDBLT_COLORFILL | DDBLT_ASYNC, &ddbfx);

	if (hr == E_NOTIMPL) {
		// fill by hand
		DDSURFACEDESC(ddsd);
		INIT_DXSTRUCT(ddsd);
		CHECK_HR(hr = pdds->Lock(&rDst, &ddsd, DDLOCK_WAIT, NULL));
		CHECK_HR(hr = DrawFilledBox(ddsd, rDst, dwColor));
e_Exit:
		pdds->Unlock(ddsd.lpSurface);
		return hr;
	} else {
		return hr;
	}
}


// blue is assumed to have a weight of 1.f
#define fSimpleRedWeight 2.1f
#define fSimpleGreenWeight 2.4f
#define fMaxColorDistance ((1.f + fSimpleRedWeight + fSimpleGreenWeight) * float(257 * 256))

static inline float
_ColorDistance(const PALETTEENTRY &pe1, const PALETTEENTRY &pe2)
{
	float fTotal, fTmpR, fTmpG, fTmpB;
	fTmpR = (float) (pe1.peRed - pe2.peRed);
	fTotal = fSimpleRedWeight * fTmpR * fTmpR;
	fTmpG = (float) (pe1.peGreen - pe2.peRed);
	fTotal += fSimpleGreenWeight * fTmpG * fTmpG;
	fTmpB = (float) (pe1.peBlue - pe2.peRed);
	// blue is assumed to have a weight of 1.f
	fTotal += fTmpB * fTmpB;

	return fTotal;
}

DWORD
SimpleFindClosestIndex(const PALETTEENTRY *rgpePalette, DWORD cEntries, 
					   const PALETTEENTRY &peQuery)
{
	MMASSERT(rgpePalette);

	float fTmp, fMinDistance = fMaxColorDistance;
	DWORD nMinIndex = cEntries;

	for (DWORD i = 0; i < cEntries; i++) {
		const PALETTEENTRY &peTmp = rgpePalette[i];
		if (!(peTmp.peFlags & (PC_RESERVED | PC_EXPLICIT))) {
			if ((fTmp = _ColorDistance(peTmp, peQuery)) < fMinDistance) {
				// check for exact match
				if (fTmp == 0.f)
					return i;
				nMinIndex = i;
				fMinDistance = fTmp;
			}
		}
	}
	MMASSERT(nMinIndex < cEntries);
	return nMinIndex;
}


// Function: GetColors
//    Compute packed/indexed color values for the given surface that most closely
//  matches the given color values.  Alpha can be expressed by using the peFlags
//  field.
HRESULT
GetColors(LPDIRECTDRAWSURFACE pdds, const PALETTEENTRY *rgpeQuery, 
		  DWORD cEntries, LPDWORD pdwColors)
{
	HRESULT hr;
	if (!pdwColors)
		return E_POINTER;
	if (!pdds || !rgpeQuery || (cEntries == 0))
		return E_INVALIDARG;

	DDSURFACEDESC ddsd;
	ddsd.dwSize = sizeof(DDSURFACEDESC);

	if (FAILED(hr = pdds->GetSurfaceDesc(&ddsd)))
		return hr;

	CPixelInfo pixi(ddsd.ddpfPixelFormat);

	if (pixi.IsRGB()) {
		for (DWORD i = 0; i < cEntries; i++)
			pdwColors[i] = pixi.Pack(rgpeQuery[i]);
	} else {
		LPDIRECTDRAWPALETTE pddp = NULL;
		PALETTEENTRY rgpe[256];
		if (FAILED(hr = pdds->GetPalette(&pddp)) ||
			FAILED(hr = pddp->GetEntries(0, 0, 256, rgpe)))
			return hr;
		for (DWORD i = 0; i < cEntries; i++) {
                        // what if the palette is not 8 bit?
			pdwColors[i] = SimpleFindClosestIndex(rgpe, 256, rgpeQuery[i]);
		}
	}

	return S_OK;
}


HRESULT
GetSurfaceDimensions(LPDIRECTDRAWSURFACE pdds, LPRECT prDim)
{
	MMASSERT(pdds && prDim);

	HRESULT hr;
	DDSURFACEDESC ddsd;
	ddsd.dwSize = sizeof(DDSURFACEDESC);
	if (FAILED(hr = pdds->GetSurfaceDesc(&ddsd))) {
		return hr;
	}
	prDim->left = prDim->top = 0;
	prDim->right = (long) ddsd.dwWidth;
	prDim->bottom = (long) ddsd.dwHeight;

	return S_OK;
}


HRESULT
CopyPixels8ToDDS(const BYTE *pSrcPixels, RECT rSrc, long nSrcPitch, 
				 LPDIRECTDRAWSURFACE pddsDst, DWORD nXPos, DWORD nYPos)
{
	if (!pddsDst || !pSrcPixels)
		return E_INVALIDARG;

	HRESULT hr;

	bool bLocked = FALSE;

	DDSURFACEDESC ddsd;
	INIT_DXSTRUCT(ddsd);

	DWORD nSrcWidth = rSrc.right - rSrc.left;
	DWORD nSrcHeight = rSrc.bottom - rSrc.top;
	LPBYTE pDstPixels = NULL;

	RECT rDst = {nXPos, nYPos, nXPos + nSrcWidth, nYPos + nSrcHeight};

	// lock the surface for writing
	if (FAILED(hr = pddsDst->Lock(&rDst, &ddsd, DDLOCK_WAIT, NULL)))
		return hr;
	bLocked = TRUE;

	// check that the surface is the right size for the copy
	if (((ddsd.dwWidth - nXPos) < nSrcWidth) || 
		((ddsd.dwHeight - nYPos) < nSrcHeight) ||
		(ddsd.ddpfPixelFormat.dwRGBBitCount != 8))
	{
		hr = E_INVALIDARG;
		goto e_CopyPixelsToDDS;
	}

	//
	// copy the pixels
	//
	pDstPixels = (LPBYTE) ddsd.lpSurface;
	
	// position the source pixel pointer
	pSrcPixels += rSrc.top * nSrcPitch + rSrc.left;

	hr = BltFast(pSrcPixels, nSrcPitch, pDstPixels, ddsd.lPitch, 
			nSrcWidth, nSrcHeight);
	
e_CopyPixelsToDDS:
	if (bLocked)
		pddsDst->Unlock(ddsd.lpSurface);

	return hr;
}


HRESULT
CreateSurfaceWithText(LPDIRECTDRAW pDD, LPDIRECTDRAWPALETTE pddp, 
					  bool bTransparent, DWORD iTrans, 
					  const char *szText, HFONT hFont, 
					  bool bShadowed, SIZE *psiz, 
					  LPDIRECTDRAWSURFACE *ppdds)
{
	MMASSERT(ppdds && psiz);
	// check arguments
	if ((szText == NULL) || (szText[0] == '\0') || (hFont == NULL) || (pDD == NULL) ||
		(iTrans >= 256))
		return E_INVALIDARG;

	HRESULT hr;
	HDC hDC = NULL;
	HGDIOBJ hOldFont = NULL, hOldDIB = NULL;
	LPDIRECTDRAWSURFACE pdds = NULL;
	BOOL b = FALSE;
	SIZE sizText;
	RECT rText;
	DDCOLORKEY ddck;

	ddck.dwColorSpaceLowValue = ddck.dwColorSpaceHighValue = iTrans;

	if (bTransparent == FALSE)
		iTrans = 0;

	int cTextLength = strlen(szText);

	//
	// compute the size and create the DDS
	//
	hr = E_FAIL;

		// open the DC
	b =(((hDC = GetDC(NULL)) == NULL) ||
		// select the font into the DC
		((hOldFont = SelectObject(hDC, hFont)) == NULL) ||
		// compute the size of the fontified string in pixels
		(GetTextExtentPoint32(hDC, szText, cTextLength, &sizText) == 0)) ||
		// set the size of the rect
		((SetRect(&rText, 0, 0, GetClosestMultipleOf4(sizText.cx, TRUE), 
			GetClosestMultipleOf4(sizText.cy, TRUE)) == 0) ||
		// create the DDS based on the extent
		FAILED(hr = CreatePlainSurface(pDD, rText.right, rText.bottom, 
						g_rgDDPF[iPF_Palette8], pddp, iTrans, bTransparent, &pdds)) ||
		// clear the surface to the transparency color
		FAILED(hr = ClearToColor(&rText, pdds, iTrans)));

	int nXOffset = (rText.right - sizText.cx) >> 1;
	int nYOffset = (rText.bottom - sizText.cy) >> 1;

	// update the size
	sizText.cx = rText.right;
	sizText.cy = rText.bottom;

	// clean up the DC
	if (hDC) {
		if (hOldFont) {
			// select the old object back into the DC
			SelectObject(hDC, hOldFont);
			hOldFont = NULL;
		}
		ReleaseDC(NULL, hDC);
		hDC = NULL;
	}

	if (b)
		return hr;

	//
	// output the font to the DDS
	//
#ifdef __GetDCWorksOnOffscreenSurfaces

		// open the DC on the surface
	b =(FAILED(hr = pdds->GetDC(&hDC)) ||
		// select in the font
		((hOldFont = SelectObject(hDC, hFont)) == NULL) ||
		// set the color of the text (the background is transparent)
		(SetTextColor(hDC, RGB(255,255,255)) == CLR_INVALID) ||
		(SetBkMode(hDC, TRANSPARENT) == 0) ||
		// output the text to the surface
		(ExtTextOut(hDC, 0, 0, 0, &rText, szText, cTextLength, NULL) == 0));

	// clean up the DC again
	if (hDC) {
		pdds->ReleaseDC(hDC);
		hDC = NULL;
	}
	if (b) {
		MMRELEASE(pdds);
		return (hr == S_OK ? E_FAIL : hr);
	}

#else

	HBITMAP hDIB = NULL;
	LPBYTE pDIBPixels = NULL;
	PALETTEENTRY rgpe[256];
	HDC hdcMem = NULL;
	PALETTEENTRY &peTrans = rgpe[iTrans];

	MMASSERT((hOldDIB == NULL) && (hOldFont == NULL));

	// get the DC again
	hDC = GetDC(NULL);
	MMASSERT(hDC != NULL);

		// get the palette entries for the DIB section
	b =(FAILED(hr = pddp->GetEntries(0, 0, 256, rgpe)) ||
		// create an empty DIB section
		FAILED(hr = CreatePlainDIBSection(hDC, rText.right, rText.bottom, 8, 
						rgpe, &hDIB, &pDIBPixels)) ||
		// create a memory DC
		((hdcMem = CreateCompatibleDC(hDC)) == NULL) ||
		// select DIB section and font into DC
		((hOldDIB = SelectObject(hdcMem, hDIB)) == NULL) ||
		((hOldFont = SelectObject(hdcMem, hFont)) == NULL) ||
		(SetBkColor(hdcMem, RGB(peTrans.peRed, peTrans.peGreen, peTrans.peBlue)) == CLR_INVALID) ||
		(SetBkMode(hdcMem, OPAQUE) == 0));

	UINT fuOptions = ETO_OPAQUE;
	if (!b && bShadowed) {
			// set the color of the shadow text
		b =((SetTextColor(hdcMem, RGB(0,0,0)) == CLR_INVALID) ||		// black
			// output the shadow text
			(ExtTextOut(hdcMem, nXOffset + 2, nYOffset + 2, fuOptions, &rText, szText, 
				cTextLength, NULL) == 0) ||
			(SetBkMode(hdcMem, TRANSPARENT) == 0));
		fuOptions = 0;		// transparent
	}

	if (!b) {
			// set the color of the foreground text
		b =((SetTextColor(hdcMem, RGB(255,255,255)) == CLR_INVALID) ||	// white
			// output the foreground text to the surface
			(ExtTextOut(hdcMem, nXOffset, nYOffset, fuOptions, &rText, szText, 
				cTextLength, NULL) == 0));
	}

	if (hdcMem) {
		if (hOldDIB)
			SelectObject(hdcMem, hOldDIB);
		if (hOldFont)
			SelectObject(hdcMem, hOldFont);
		ReleaseDC(NULL, hdcMem);
		hdcMem = NULL;
	}
	ReleaseDC(NULL, hDC);

	if (!b) {
		// copy the DIB pixels into the DDS
		hr = CopyPixels8ToDDS(pDIBPixels, rText, rText.right, pdds, 0, 0);
	}

	// clean up the DIB that we created
	if (hDIB) {
		DeleteObject(hDIB);
		pDIBPixels = NULL;
	}

	if (b || FAILED(hr))
		return (FAILED(hr) ? hr : E_FAIL);

#endif

	*psiz = sizText;
	*ppdds = pdds;

	return S_OK;
}

HRESULT
CreatePlainDIBSection(HDC hDC, DWORD nWidth, DWORD nHeight, DWORD nBPP, 
					  const PALETTEENTRY *rgpePalette, HBITMAP *phbm, LPBYTE *ppPixels)
{
	MMASSERT(rgpePalette && ppPixels && phbm);
	HRESULT hr = S_OK;
	if (nBPP != 8) {
		return E_INVALIDARG;
	}
	DWORD i, cPalEntries = (1 << nBPP);
	HBITMAP hbm = NULL;

	// allocate bitmap info structure
	BITMAPINFO *pbmi = NULL;
	pbmi = (BITMAPINFO *) new BYTE[sizeof(BITMAPINFOHEADER) + cPalEntries * sizeof(RGBQUAD)];
	if (pbmi == NULL)
		return E_OUTOFMEMORY;

	// specify bitmip info
	pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	pbmi->bmiHeader.biPlanes = 1;
	pbmi->bmiHeader.biSizeImage = 0;
	pbmi->bmiHeader.biClrUsed = 0;
	pbmi->bmiHeader.biClrImportant = 0;
	pbmi->bmiHeader.biBitCount = (WORD) nBPP;
	pbmi->bmiHeader.biCompression = BI_RGB;
	pbmi->bmiHeader.biWidth = (LONG) nWidth;
	pbmi->bmiHeader.biHeight = -(LONG) nHeight;

	// copy palette into bmi
	for(i = 0; i < cPalEntries; i++) {
		pbmi->bmiColors[i].rgbRed = rgpePalette[i].peRed;
		pbmi->bmiColors[i].rgbGreen= rgpePalette[i].peGreen;
		pbmi->bmiColors[i].rgbBlue = rgpePalette[i].peBlue;
		pbmi->bmiColors[i].rgbReserved = 0;
	}

	// create bitmap
	LPVOID pvBits = NULL;
	hbm = ::CreateDIBSection(hDC, pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
	if (hbm == NULL) {
		hr = E_FAIL;
		goto e_CreatePlainDIBSection;
	}

	*phbm = hbm;
	*ppPixels = (LPBYTE) pvBits;

e_CreatePlainDIBSection:
	MMDELETE(pbmi);

	return hr;
}


bool
ClipRect(const RECT &rTarget, RECT &rSrc)
{
	MMASSERT((rTarget.left <= rTarget.right) && (rTarget.top <= rTarget.bottom) &&
		(rSrc.left <= rSrc.right) && (rSrc.top <= rSrc.bottom));

	CLAMPMIN(rSrc.left, rTarget.left);
	CLAMPMIN(rSrc.top, rTarget.top);
	CLAMPMAX(rSrc.right, rTarget.right);
	CLAMPMAX(rSrc.bottom, rTarget.bottom);

	// make sure we still have a valid rectangle
	CLAMPMIN(rSrc.right, rSrc.left);
	CLAMPMIN(rSrc.bottom, rSrc.top);

	return ((rSrc.left != rSrc.right) && (rSrc.top != rSrc.bottom));
}

bool
ClipRect(long nWidth, long nHeight, RECT &rSrc)
{
	MMASSERT((rSrc.left <= rSrc.right) && (rSrc.top <= rSrc.bottom));

	CLAMPMIN(rSrc.left, 0);
	CLAMPMIN(rSrc.top, 0);
	CLAMPMAX(rSrc.right, nWidth);
	CLAMPMAX(rSrc.bottom, nHeight);

	// make sure we still have a valid rectangle
	CLAMPMIN(rSrc.right, rSrc.left);
	CLAMPMIN(rSrc.bottom, rSrc.top);

	return ((rSrc.left != rSrc.right) && (rSrc.top != rSrc.bottom));
}




// Function: CreatePaletteFromSystem
//    This function creates a DDPalette from the current system palette
HRESULT
CreatePaletteFromSystem(HDC hDC, IDirectDraw *pDD, IDirectDrawPalette **ppddp)
{
	HRESULT hr = E_INVALIDARG;
	if (ppddp == NULL)
		return E_POINTER;

	if ((hDC == NULL) || (pDD == NULL))
		return E_INVALIDARG;

	PALETTEENTRY rgPE[256];
	DWORD cEntries = 0, i;

	if ((cEntries = ::GetSystemPaletteEntries(hDC, 0, 256, rgPE)) == 0)
		return E_INVALIDARG;

	// fill palette entries
	for (i = 0; i < cEntries; i++)
		rgPE[i].peFlags = PC_NOCOLLAPSE;
	for (; i < 256; i++) {
		rgPE[i].peRed = rgPE[i].peGreen = rgPE[i].peBlue = 0;
		rgPE[i].peFlags = PC_NOCOLLAPSE;
	}
	
	if (FAILED(hr = pDD->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE, rgPE, ppddp, NULL)))
		return hr;

	return S_OK;
}


HRESULT
DrawPoints(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
		   DWORD nBytesPerPixel, const Point2 *rgpnt, DWORD cPoints, 
		   DWORD dwColor, DWORD nRadius)
{
	MMASSERT(pPixels && rgpnt && cPoints && nWidth && nHeight && 
		(nPitch >= nWidth) && INRANGE(nBytesPerPixel, 1, 4));

	RECT rSafe = {nRadius, nRadius, nWidth - nRadius, nHeight - nRadius};

	for (DWORD i = 0; i < cPoints; i++) {
		const Point2 &pnt = rgpnt[i];
		// REVIEW: HACK! for now
		POINT pt;
		pt.x = long(pnt.x);
		pt.y = long(pnt.y);
		if (IsInside(pt.x, pt.y, rSafe)) {
			DWORD nX = pt.x - nRadius, nY = pt.y - nRadius;
			DWORD nSize = nRadius * 2 + 1;
			g_rgColorFillFn[nBytesPerPixel](
				pPixels + PixelOffset(nX, nY, nPitch, nBytesPerPixel),
				nPitch, nSize, nSize, dwColor);
		} else {
			// REVIEW: clip the point for now
		}
	}

	return S_OK;
}


HRESULT
DrawBox(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
		DWORD nBytesPerPixel, const RECT &rSrc, DWORD dwColor, DWORD nThickness)
{
	MMASSERT(pPixels && nWidth && nHeight && (nPitch >= nWidth) && 
		nThickness && INRANGE(nBytesPerPixel, 1, 4));

	RECT r = rSrc;
	if (ClipRect(long(nWidth), long(nHeight), r)) {
		// compute pixel offset
		pPixels += PixelOffset(r.left, r.top, nPitch, nBytesPerPixel);
		DWORD nBoxWidth = r.right - r.left;
		DWORD nBoxHeight = r.bottom - r.top;
		
		// top
		g_rgColorFillFn[nBytesPerPixel](pPixels, nPitch, nBoxWidth, 1, dwColor);
		// left
		g_rgColorFillFn[nBytesPerPixel](pPixels, nPitch, 1, nBoxHeight, dwColor);
		// right
		g_rgColorFillFn[nBytesPerPixel](pPixels + nBoxWidth * nBytesPerPixel, nPitch, 1, nBoxHeight, dwColor);
		// bottom
		g_rgColorFillFn[nBytesPerPixel](pPixels + nBoxHeight * nPitch, nPitch, nBoxWidth, 1, dwColor);
	}

	return S_OK;
}

HRESULT
DrawFilledBox(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
		DWORD nBytesPerPixel, const RECT &rSrc, DWORD dwColor)
{
	HRESULT hr;
	MMASSERT(pPixels && nWidth && nHeight && (nPitch >= nWidth) && INRANGE(nBytesPerPixel, 1, 4));

	RECT r = rSrc;
	if (ClipRect(long(nWidth), long(nHeight), r)) {
		pPixels += PixelOffset(r.left, r.top, nPitch, nBytesPerPixel);
		DWORD nBoxWidth = r.right - r.left;
		DWORD nBoxHeight = r.bottom - r.top;
		hr = g_rgColorFillFn[nBytesPerPixel](pPixels, nPitch, nBoxWidth, nBoxHeight, dwColor);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\blt.cpp ===
// File:	Blt.cpp
// Author:	Michael Marr    (mikemarr)
//
// History:
// -@- 09/23/97 (mikemarr) copied to DXCConv from d2d\mmimage
// -@- 10/28/97 (mikemarr) added colorfill routines
//
// Notes:
//    Asserts can not be used because the code may be executing on
//  pixels in the front buffer.  If there is an assertion failure,
//  GDI might lock up.

#include "stdafx.h"
#include "PalMap.h"
#include "Blt.h"

ColorFillFn g_rgColorFillFn[5] = {
	NULL, ColorFill8, ColorFill16, ColorFill24, ColorFill32
};

HasPixelFn g_rgHasPixelFn[5] = {
	NULL, HasPixel8, HasPixel16, HasPixel24, HasPixel32
};


// Function: ColorFill
//    These functions are designed for small color fills...
HRESULT
ColorFill8(BYTE *pDstPixels, DWORD nDstPitch, 
		   DWORD nWidth, DWORD nHeight, DWORD dwColor)
{
	BYTE iColor = (BYTE) dwColor;
	DWORD i, j;
	for (i = 0; i < nHeight; i++) {
		for (j = 0; j < nWidth; j++)
			pDstPixels[j] = iColor;
		pDstPixels += nDstPitch;
	}
	return S_OK;
}

HRESULT
ColorFill16(BYTE *pDstPixels, DWORD nDstPitch, 
			DWORD nWidth, DWORD nHeight, DWORD dwColor)
{
	WORD wColor = (WORD) dwColor;
	DWORD i, j;
	for (i = 0; i < nHeight; i++) {
		WORD *pwDstPixels = (WORD *) pDstPixels;
		for (j = 0; j < nWidth; j++)
			*pwDstPixels++ = wColor;
		pDstPixels += nDstPitch;
	}
	return S_OK;
}

HRESULT
ColorFill24(BYTE *pDstPixels, DWORD nDstPitch, 
			DWORD nWidth, DWORD nHeight, DWORD dwColor)
{
	BYTE c0 = (BYTE) dwColor;
	BYTE c1 = (BYTE) (dwColor >> 8);
	BYTE c2 = (BYTE) (dwColor >> 16);
	DWORD i, j;
	for (i = 0; i < nHeight; i++) {
		BYTE *pDstNext = pDstPixels + nDstPitch;
		for (j = 0; j < nWidth; j++) {
			pDstPixels[0] = c0;
			pDstPixels[1] = c1;
			pDstPixels[2] = c2;
			pDstPixels += 3;
		}
		pDstPixels = pDstNext;
	}
	return S_OK;
}

HRESULT
ColorFill32(BYTE *pDstPixels, DWORD nDstPitch, 
			DWORD nWidth, DWORD nHeight, DWORD dwColor)
{
	DWORD i, j;
	for (i = 0; i < nHeight; i++) {
		DWORD *pdwDstPixels = (DWORD *) pDstPixels;
		for (j = 0; j < nWidth; j++)
			*pdwDstPixels++ = dwColor;
		pDstPixels += nDstPitch;
	}
	return S_OK;
}


HRESULT 
HasPixel8(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
		  DWORD nSrcWidth, DWORD nHeight, BOOL *pb)
{
	BYTE iPixel = (BYTE) dwPixel;
	if (nSrcPitch == nSrcWidth) {
		// do a flat search thru contiguous memory
		*pb = (memchr(pSrcPixels, iPixel, nSrcPitch * nHeight) != NULL);
	} else {
		// do search line by line
		for (; nHeight; nHeight--) {
			if (memchr(pSrcPixels, iPixel, nSrcWidth) != NULL) {
				*pb = TRUE;
				return S_OK;
			}
			pSrcPixels += nSrcPitch;
		}
		*pb = FALSE;
	}
	return S_OK;
}

HRESULT 
HasPixel16(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
		   DWORD nSrcWidth, DWORD nHeight, BOOL *pb)
{
	WORD wPixel = (WORD) dwPixel;
	for (; nHeight; nHeight--) {
		const WORD *pPixels = (const WORD *) pSrcPixels;
		const WORD *pLimit = pPixels + nSrcWidth;
		while (pPixels != pLimit) {
			if (*pPixels++ == wPixel) {
				*pb = TRUE;
				return S_OK;
			}
		}
		pSrcPixels += nSrcPitch;
	}
	*pb = FALSE;
	return S_OK;
}

HRESULT 
HasPixel24(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
		   DWORD nSrcWidth, DWORD nHeight, BOOL *pb)
{
	// REVIEW: only works on little endian machines
	BYTE c0 = (BYTE) dwPixel;
	BYTE c1 = (BYTE) (dwPixel >> 8);
	BYTE c2 = (BYTE) (dwPixel >> 16);
	DWORD nWidth = nSrcWidth * 3;
	for (; nHeight; nHeight--) {
		const BYTE *pPixels = pSrcPixels;
		const BYTE *pLimit = pPixels + nWidth;
		while (pPixels != pLimit) {
			if ((pPixels[0] == c0) && (pPixels[1] == c1) && (pPixels[2] == c2)) {
				*pb = TRUE;
				return S_OK;
			}
			pPixels += 3;
		}
		pSrcPixels += nSrcPitch;
	}
	*pb = FALSE;
	return S_OK;
}

HRESULT 
HasPixel32(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
		   DWORD nSrcWidth, DWORD nHeight, BOOL *pb)
{
	for (; nHeight; nHeight--) {
		const DWORD *pPixels = (const DWORD *) pSrcPixels;
		const DWORD *pLimit = pPixels + nSrcWidth;
		while (pPixels != pLimit) {
			if (*pPixels++ == dwPixel) {
				*pb = TRUE;
				return S_OK;
			}
		}
		pSrcPixels += nSrcPitch;
	}
	*pb = FALSE;
	return S_OK;
}


HRESULT 
BltFast(const BYTE *pSrcPixels, DWORD nSrcPitch,
		BYTE *pDstPixels, DWORD nDstPitch, DWORD nSrcWidth, DWORD nHeight)
{
	if (nSrcWidth == nDstPitch) {
		// do a flat copy
		memcpy(pDstPixels, pSrcPixels, nSrcPitch * nHeight);
	} else {
		LPBYTE pPixelLimit = pDstPixels + nDstPitch * nHeight;
		// copy each row
		for (; pDstPixels != pPixelLimit; ) {
			memcpy(pDstPixels, pSrcPixels, nSrcWidth);
			pDstPixels += nDstPitch;
			pSrcPixels += nSrcPitch;
		}
	}
	return S_OK;
}


HRESULT 
BltFast8CK(const BYTE *pSrcPixels, DWORD nSrcPitch,
		   BYTE *pDstPixels, DWORD nDstPitch, 
		   DWORD nSrcWidth, DWORD nHeight, DWORD dwTrans)
{
	if ((nSrcWidth == 0) || (nHeight == 0))
		return S_OK;

	DWORD nRemainder = (nSrcWidth & 0x7);
	DWORD nAligned = (nSrcWidth & ~0x7);
	const BYTE *pSrcLineStart = pSrcPixels;
	const BYTE *pPixelLimit = pSrcPixels + (nHeight * nSrcPitch);
	DWORD nSrcAlignedPitch = nSrcPitch + nAligned;
	DWORD nDstAlignedPitch = nDstPitch + nAligned;
	pSrcPixels += nAligned;
	pDstPixels += nAligned;
	BYTE iTrans = BYTE(dwTrans), uch;

	do {
		switch (nRemainder) {
		do {
			case 0:	pDstPixels -= 8; pSrcPixels -= 8;
					if ((uch = pSrcPixels[7]) != iTrans) pDstPixels[7] = uch;
			case 7:	if ((uch = pSrcPixels[6]) != iTrans) pDstPixels[6] = uch;
			case 6:	if ((uch = pSrcPixels[5]) != iTrans) pDstPixels[5] = uch;
			case 5:	if ((uch = pSrcPixels[4]) != iTrans) pDstPixels[4] = uch;
			case 4:	if ((uch = pSrcPixels[3]) != iTrans) pDstPixels[3] = uch;
			case 3:	if ((uch = pSrcPixels[2]) != iTrans) pDstPixels[2] = uch;
			case 2:	if ((uch = pSrcPixels[1]) != iTrans) pDstPixels[1] = uch;
			case 1:	if ((uch = pSrcPixels[0]) != iTrans) pDstPixels[0] = uch;
		} while (pSrcPixels != pSrcLineStart);
		}
		pSrcLineStart += nSrcPitch;
		pSrcPixels += nSrcAlignedPitch;
		pDstPixels += nDstAlignedPitch;
	} while (pSrcLineStart != pPixelLimit);

	return S_OK;
}


HRESULT 
BltFastMirrorY(const BYTE *pSrcPixels, DWORD nSrcPitch, 
			   BYTE *pDstPixels, DWORD nDstPitch, DWORD nSrcWidth, DWORD nHeight)
{
	LPBYTE pPixelLimit = pDstPixels + nDstPitch * nHeight;
	// set the src pixels to point to the last line of the bitmap
	pSrcPixels += nSrcPitch * (nHeight - 1);

	// copy each row
	for (; pDstPixels != pPixelLimit; ) {
		memcpy(pDstPixels, pSrcPixels, nSrcWidth);
		pDstPixels += nDstPitch;
		pSrcPixels -= nSrcPitch;
	}
	return S_OK;
}


HRESULT 
BltFastRGBToRGB(const BYTE *pSrcPixels, DWORD nSrcPitch,
				BYTE *pDstPixels, DWORD nDstPitch, 
				DWORD nWidth, DWORD nHeight,
				const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst)
{
	if (pixiSrc.nBPP == 24) {
		if (pixiDst.nBPP == 16)
			return BltFast24To16(pSrcPixels, nSrcPitch, pDstPixels, nDstPitch,
					nWidth, nHeight, pixiSrc, pixiDst);
		if (pixiDst.nBPP == 32)
			return BltFast24To32(pSrcPixels, nSrcPitch, pDstPixels, nDstPitch,
					nWidth, nHeight, pixiSrc, pixiDst);
	} else if (pixiSrc.nBPP == 32) {
		if (pixiDst.nBPP == 32)
			return BltFast32To32(pSrcPixels, nSrcPitch, pDstPixels, nDstPitch,
					nWidth, nHeight, pixiSrc, pixiDst);
	}
	return E_NOTIMPL;
}


HRESULT
BltFast32To32(const BYTE *pSrcPixels, DWORD nSrcPitch,
			  BYTE *pDstPixels, DWORD nDstPitch, 
			  DWORD nWidth, DWORD nHeight,
			  const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst)
{
	if (nSrcPitch == 0)
		nSrcPitch = nWidth * 4;
	if (nDstPitch == 0)
		nDstPitch = nWidth * 4;
	DWORD nDeltaSrcPitch = nSrcPitch - (nWidth * 4);
	const BYTE *pPixelLimit = pSrcPixels + nSrcPitch * nHeight;
	DWORD iRed = pixiSrc.iRed, iBlue = pixiSrc.iBlue;
	// copy each row
	for (; pSrcPixels != pPixelLimit; ) {
		LPDWORD pdwDstPixel = (LPDWORD) pDstPixels;
		for (DWORD i = nWidth; i != 0; i--) {
			*pdwDstPixel++ = pixiDst.Pack(pSrcPixels[iRed], pSrcPixels[1], pSrcPixels[iBlue], pSrcPixels[3]);
			pSrcPixels += 4;
		}
		pDstPixels += nDstPitch;
		pSrcPixels += nDeltaSrcPitch;
	}
	return S_OK;
}


HRESULT
BltFast24To16(const BYTE *pSrcPixels, DWORD nSrcPitch,
			  BYTE *pDstPixels, DWORD nDstPitch, 
			  DWORD nWidth, DWORD nHeight,
			  const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst)
{
	if (nSrcPitch == 0)
		nSrcPitch = nWidth * 3;
	if (nDstPitch == 0)
		nDstPitch = nWidth * 2;
	DWORD nDeltaSrcPitch = nSrcPitch - (nWidth * 3);
	const BYTE *pPixelLimit = pSrcPixels + nSrcPitch * nHeight;
	DWORD iRed = pixiSrc.iRed, iBlue = pixiSrc.iBlue;
	// copy each row
	for (; pSrcPixels != pPixelLimit; ) {
		LPWORD pwDstPixel = (LPWORD) pDstPixels;
		for (DWORD i = nWidth; i != 0; i--) {
			*pwDstPixel++ = pixiDst.Pack16(pSrcPixels[iRed], pSrcPixels[1], pSrcPixels[iBlue]);
			pSrcPixels += 3;
		}
		pDstPixels += nDstPitch;
		pSrcPixels += nDeltaSrcPitch;
	}
	return S_OK;
}


HRESULT
BltFast24To32(const BYTE *pSrcPixels, DWORD nSrcPitch,
			  BYTE *pDstPixels, DWORD nDstPitch, 
			  DWORD nWidth, DWORD nHeight,
			  const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst)
{
	if (nSrcPitch == 0)
		nSrcPitch = nWidth * 3;
	if (nDstPitch == 0)
		nDstPitch = nWidth * 4;
	DWORD nDeltaSrcPitch = nSrcPitch - (nWidth * 3);
	DWORD iRed = pixiSrc.iRed, iBlue = pixiSrc.iBlue;
	// copy each row
	const BYTE *pPixelLimit = pSrcPixels + nSrcPitch * nHeight;
	for (; pSrcPixels != pPixelLimit; ) {
		LPDWORD pdwDstPixel = (LPDWORD) pDstPixels;
		for (DWORD i = nWidth; i != 0; i--) {
			*pdwDstPixel++ = pixiDst.Pack(pSrcPixels[iRed], pSrcPixels[1], pSrcPixels[iBlue]);
			pSrcPixels += 3;
		}
		pDstPixels += nDstPitch;
		pSrcPixels += nDeltaSrcPitch;
	}
	return S_OK;
}



HRESULT 
BltFast8To4(const BYTE *pSrcPixels, DWORD nSrcPitch,
			BYTE *pDstPixels, DWORD nDstPitch,
			DWORD nWidth, DWORD nHeight, DWORD nOffset)
{
	return E_NOTIMPL;
}


HRESULT 
BltFast8To2(const BYTE *pSrcPixels, DWORD nSrcPitch,
			BYTE *pDstPixels, DWORD nDstPitch,
			DWORD nWidth, DWORD nHeight, DWORD nOffset)
{
	return E_NOTIMPL;
}


HRESULT 
BltFast8To1(const BYTE *pSrcPixels, long nSrcPitch,
			BYTE *pDstPixels, long nDstPitch,
			DWORD nWidth, DWORD nHeight, DWORD nOffset)
{
	HRESULT hr = E_NOTIMPL;

	return hr;
}


HRESULT
BltFast8To8T(const BYTE *pSrcPixel, long nSrcPitch, BYTE *pDstPixel, long nDstPitch,
			DWORD nWidth, DWORD nHeight, const BYTE *pIndexMap)
{
	if ((nWidth == 0) || (nHeight == 0))
		return S_OK;

	DWORD nRemainder = (nWidth & 0x7);
	DWORD nAligned = (nWidth & ~0x7);
	const BYTE *pSrcLineStart = pSrcPixel;
	const BYTE *pPixelLimit = pSrcPixel + (nHeight * nSrcPitch);
	DWORD nSrcAlignedPitch = nSrcPitch + nAligned;
	DWORD nDstAlignedPitch = nDstPitch + nAligned;
	pSrcPixel += nAligned;
	pDstPixel += nAligned;

	do {
		switch (nRemainder) {
		do {
			case 0:	pDstPixel -= 8; pSrcPixel -= 8;
					pDstPixel[7] = pIndexMap[pSrcPixel[7]];
			case 7: pDstPixel[6] = pIndexMap[pSrcPixel[6]];
			case 6:	pDstPixel[5] = pIndexMap[pSrcPixel[5]];
			case 5: pDstPixel[4] = pIndexMap[pSrcPixel[4]];
			case 4:	pDstPixel[3] = pIndexMap[pSrcPixel[3]];
			case 3: pDstPixel[2] = pIndexMap[pSrcPixel[2]];
			case 2:	pDstPixel[1] = pIndexMap[pSrcPixel[1]];
			case 1: pDstPixel[0] = pIndexMap[pSrcPixel[0]];
		} while (pSrcPixel != pSrcLineStart);
		}
		pSrcLineStart += nSrcPitch;
		pSrcPixel += nSrcAlignedPitch;
		pDstPixel += nDstAlignedPitch;
	} while (pSrcLineStart != pPixelLimit);

	return S_OK;
}

HRESULT
BltFast8To16T(const BYTE *pSrcPixel, long nSrcPitch, BYTE *pDstPixel, long nDstPitch,
			 DWORD nWidth, DWORD nHeight, const BYTE *pIndexMap)
{
#ifdef _DEBUG
	if ((long(pDstPixel) & 0x1) || (nDstPitch & 0x1) || (nWidth == 0) || (nHeight == 0))
		return E_INVALIDARG;
#endif
	DWORD nRemainder = (nWidth & 0x7);
	DWORD nAligned = (nWidth & ~0x7);
	const BYTE *pSrcLineStart = pSrcPixel;
	const BYTE *pPixelLimit = pSrcPixel + (nHeight * nSrcPitch);
	DWORD nSrcAlignedPitch = nSrcPitch + nAligned;
	DWORD nDstAlignedPitch = (nDstPitch >> 1) + nAligned;
	pSrcPixel += nAligned;
	WORD *pDstPixel16 = ((WORD *) pDstPixel) + nAligned;
	MapEntry16 *pIndexMap16 = (MapEntry16 *) pIndexMap;

	do {
		switch (nRemainder) {
		do {
			case 0:	pDstPixel16 -= 8; pSrcPixel -= 8;
					pDstPixel16[7] = pIndexMap16[pSrcPixel[7]];
			case 7: pDstPixel16[6] = pIndexMap16[pSrcPixel[6]];
			case 6:	pDstPixel16[5] = pIndexMap16[pSrcPixel[5]];
			case 5: pDstPixel16[4] = pIndexMap16[pSrcPixel[4]];
			case 4:	pDstPixel16[3] = pIndexMap16[pSrcPixel[3]];
			case 3: pDstPixel16[2] = pIndexMap16[pSrcPixel[2]];
			case 2:	pDstPixel16[1] = pIndexMap16[pSrcPixel[1]];
			case 1: pDstPixel16[0] = pIndexMap16[pSrcPixel[0]];
		} while (pSrcPixel != pSrcLineStart);
		}
		pSrcLineStart += nSrcPitch;
		pSrcPixel += nSrcAlignedPitch;
		pDstPixel16 += nDstAlignedPitch;
	} while (pSrcLineStart != pPixelLimit);

	return S_OK;
}

HRESULT
BltFast8To24T(const BYTE *pSrcPixels, long nSrcPitch, BYTE *pDstPixels, long nDstPitch,
			 DWORD nWidth, DWORD nHeight, const BYTE *pIndexMap)
{
	MapEntry24 *pIndexMap24 = (MapEntry24 *) pIndexMap;
	BYTE *pDstPixelsLimit = pDstPixels + nDstPitch * nHeight;
	int nDstWidth = nWidth * 3;
		
	for (; pDstPixels != pDstPixelsLimit; ) {
		const BYTE *pSrcPixel = pSrcPixels;
		BYTE *pDstPixel = pDstPixels;
		BYTE *pDstPixelLimit = pDstPixel + nDstWidth;
		for (; pDstPixel != pDstPixelLimit; ) {
			MapEntry24 mePixel = pIndexMap24[*pSrcPixel++];
			*pDstPixel++ = (BYTE) (mePixel);
			*pDstPixel++ = (BYTE) (mePixel >> 8);
			*pDstPixel++ = (BYTE) (mePixel >> 16);
		}
		pDstPixels += nDstPitch;
		pSrcPixels += nSrcPitch;
	}
	return S_OK;
}

HRESULT
BltFast8To32T(const BYTE *pSrcPixels, long nSrcPitch, BYTE *pDstPixels, long nDstPitch,
			 DWORD nWidth, DWORD nHeight, const BYTE *pIndexMap)
{
#ifdef _DEBUG
	if ((long(pDstPixels) & 0x3) != 0)
		return E_INVALIDARG;
#endif

	MapEntry32 *pIndexMap32 = (MapEntry32 *) pIndexMap;
	int nDstPitch32 = nDstPitch >> 2;
	DWORD *pDstPixels32 = (DWORD *) pDstPixels;
	DWORD *pDstPixelsLimit = pDstPixels32 + nDstPitch32 * nHeight;
		
	for (; pDstPixels32 != pDstPixelsLimit; ) {
		const BYTE *pSrcPixel = pSrcPixels;
		DWORD *pDstPixel = pDstPixels32;
		DWORD *pDstPixelLimit = pDstPixel + nWidth;
		for (; pDstPixel != pDstPixelLimit; ) {
			*pDstPixel++ = pIndexMap32[*pSrcPixel++];
		}
		pDstPixels32 += nDstPitch32;
		pSrcPixels += nSrcPitch;
	}
	return S_OK;
}


//
// RLE
//

HRESULT 
BltFastRLE8(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
			BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect)
{
	return E_NOTIMPL;
}

HRESULT
BltFastRLE8To8T(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
				BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect, 
				const BYTE *pIndexMap)
{
	return E_NOTIMPL;
}

HRESULT
BltFastRLE8To16T(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
				 BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect,
				 const BYTE *pIndexMap)
{
	return E_NOTIMPL;
}

HRESULT
BltFastRLE8To24T(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
				 BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect, 
				 const BYTE *pIndexMap)
{
	return E_NOTIMPL;
}

HRESULT
BltFastRLE8To32T(DWORD nXPos, DWORD nYPos, const BYTE *pSrcPixels, long nSrcPitch,
				 BYTE *pDstPixels, long nDstPitch, const LPRECT prSrcRect,
				 const BYTE *pIndexMap)
{
	return E_NOTIMPL;
}

/*
// Function: Write4BitRow
//    This function packs a buffer of unsigned char's representing
//  4 bit numbers into a packed unsigned char buffer.  It is assumed
//  that the bytes in the src have the uppermost 4 bits zeroed out.
void *
Write4BitRow(void *pDst, const void *pSrc, unsigned int cCount)
{
	// use an inverse Duff machine
	int nRemainder = cCount & 0x07;
	int nAligned = cCount - nRemainder;
	const unsigned char *puchSrc = (const unsigned char *) pSrc + nAligned;
	unsigned char *puchDst = (unsigned char *) pDst + (nAligned >> 1);
	unsigned char uchCompositionBuf = 0;

	switch (nRemainder) {
	do {
			puchDst -= 4; puchSrc -= 8;
			uchCompositionBuf = puchSrc[7];
	case 7: puchDst[3] = (puchSrc[6] << 4) | uchCompositionBuf;
	case 6:	uchCompositionBuf = puchSrc[5];
	case 5: puchDst[2] = (puchSrc[4] << 4) | uchCompositionBuf;
	case 4:	uchCompositionBuf = puchSrc[3];
	case 3: puchDst[1] = (puchSrc[2] << 4) | uchCompositionBuf;
	case 2:	uchCompositionBuf = puchSrc[1];
	case 1: puchDst[0] = (puchSrc[0] << 4) | uchCompositionBuf;
	case 0: ;
	} while (puchDst != (unsigned char *) pDst);
	} 

	return pDst;
}

// Function: Write2BitRow
//    This function packs a buffer of unsigned char's representing
//  2 bit numbers into a packed unsigned char buffer.  It is assumed
//  that the bytes in the src have the uppermost 6 bits zeroed out.
void *
Write2BitRow(void *pDst, const void *pSrc, unsigned int cCount)
{
	// use an inverse Duff machine
	int nRemainder = cCount & 0x07;
	int nAligned = cCount - nRemainder;
	const unsigned char *puchSrc = (const unsigned char *) pSrc + nAligned;
	unsigned char *puchDst = (unsigned char *) pDst + (nAligned >> 2);
	unsigned char uchCompositionBuf = 0;

	switch (nRemainder) {
	do {
			puchDst -= 2; puchSrc -= 8;
			uchCompositionBuf = puchSrc[7];
	case 7: uchCompositionBuf |= (puchSrc[6] << 2);
	case 6:	uchCompositionBuf |= (puchSrc[5] << 4);
	case 5: puchDst[1] = (puchSrc[4] << 6) | uchCompositionBuf;
	case 4:	uchCompositionBuf = puchSrc[3];
	case 3: uchCompositionBuf |= (puchSrc[2] << 2);
	case 2:	uchCompositionBuf |= (puchSrc[1] << 4);
	case 1: puchDst[0] = (puchSrc[0] << 6) | uchCompositionBuf;
	case 0: ;
	} while (puchDst != (unsigned char *) pDst);
	} 

	return pDst;
}

// Function: Write1BitRow
//    This function packs a buffer of unsigned char's representing
//  1 bit numbers into a packed unsigned char buffer.  It is assumed
//  that the bytes in the src have the uppermost 7 bits zeroed out.
void *
Write1BitRow(void *pDst, const void *pSrc, unsigned int cCount)
{
	// use an inverse Duff machine
	int nRemainder = cCount & 0x07;
	int nAligned = cCount - nRemainder;
	const unsigned char *puchSrc = (const unsigned char *) pSrc + nAligned;
	unsigned char *puchDst = (unsigned char *) pDst + (nAligned >> 3);
	unsigned char uchCompositionBuf = 0;

	switch (nRemainder) {
	do {
			puchDst -= 1; puchSrc -= 8;
			uchCompositionBuf = puchSrc[7];
	case 7: uchCompositionBuf |= (puchSrc[6] << 1);
	case 6:	uchCompositionBuf |= (puchSrc[5] << 2);
	case 5: uchCompositionBuf |= (puchSrc[4] << 3);
	case 4:	uchCompositionBuf |= (puchSrc[3] << 4);
	case 3: uchCompositionBuf |= (puchSrc[2] << 5);
	case 2:	uchCompositionBuf |= (puchSrc[1] << 6);
	case 1: puchDst[0] = (puchSrc[0] << 7) | uchCompositionBuf;
	case 0: ;
	} while (puchDst != (unsigned char *) pDst);
	} 

	return pDst;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpletest\test.cpp ===
//
// GDI+ test program
//

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <windows.h>
#include <objbase.h>

#include "Gdiplus.h"

// Use the given namespace
using namespace Gdiplus;

CHAR* programName;      // program name
HINSTANCE appInstance;  // handle to the application instance
HWND hwndMain;          // handle to application's main window
INT argCount;           // command line argument count
CHAR** argArray;        // command line arguments


//
// Display an error message dialog and quit
//

VOID
Error(
    PCSTR fmt,
    ...
    )

{
    va_list arglist;

    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}

#define CHECKERROR(e) \
        { \
            if (!(e)) \
            { \
                Error("Error on line %d\n", __LINE__); \
            } \
        }

//
// Perform GDI+ tests
//

VOID
DoTest(
    HWND hwnd,
    HDC hdc
    )
{
  {
    Graphics *g = Graphics::GetFromHwnd(hwnd);

    Rect rect(0, 0, 120, 100);
    Region *region = new Region(rect);

    g->SetClip(region);

    delete region; 
    delete g;
  }
  {
    Graphics* g = Graphics::GetFromHwnd(hwnd);

    // Scale everything up by 1.5
    g->SetPageTransform(PageUnitDisplay, 1.5);

    Color red(255, 0, 0);

    SolidBrush redBrush(red);
    g->FillRectangle(&redBrush, 20, 20, 50, 50);

    Color alphacolor(128, 0, 255, 0);
    SolidBrush alphaBrush(alphacolor);
    g->FillRectangle(&alphaBrush, 10, 10, 40, 40);

    Point points[10];
    points[0].X = 50;
    points[0].Y = 50;
    points[1].X = 100;
    points[1].Y = 50;
    points[2].X = 120;
    points[2].Y = 120;
    points[3].X = 50;
    points[3].Y = 100;

    Color blue(128, 0, 0, 255);
    SolidBrush blueBrush(blue);
    g->FillPolygon(&blueBrush, (Point*)&points[0], 4);

    // Currently only Geometric pen works for lines. - ikkof 1/6/99.

    REAL width = 4;
    Color black(0,0,0);
    SolidBrush blackBrush(black);
    Pen blackPen(&blackBrush, width);
    g->DrawPolygon(&blackPen, (Point*)&points[0], 4);
//    g->DrawLines(&blackPen, points, 4, FALSE);

    points[0].X = 100;
    points[0].Y = 10;
    points[1].X = -50;
    points[1].Y = 50;
    points[2].X = 150;
    points[2].Y = 200;
    points[3].X = 200;
    points[3].Y = 70;

    Color yellow(128, 255, 255, 0);
    SolidBrush yellowBrush(yellow);
    GraphicsPath* path = new GraphicsPath(FillModeAlternate);    
    path->AddBeziers((Point*)&points[0], 4);

    Region * region = new Region(path);
    g->FillRegion(&yellowBrush, region);
//    g->FillPath(&yellowBrush, path);
    g->DrawPath(&blackPen, path);
    delete path;
    delete region;

    // Create a rectangular gradient brush.

    RectF brushRect(0, 0, 32, 32);
    Color* colors[4];

    colors[0] = new Color(255, 255, 255, 255);
    colors[1] = new Color(255, 255, 0, 0);
    colors[2] = new Color(255, 0, 255, 0);
    colors[3] = new Color(255, 0, 0, 255);
    RectangleGradientBrush rectGrad(brushRect, (Color*)&colors[0], WrapModeTile);

    delete colors[0];
    delete colors[1];
    delete colors[2];
    delete colors[3];

    g->FillRectangle(&rectGrad, 200, 20, 100, 80);

    // Change the wrapping mode and fill.

    rectGrad.SetWrapMode(WrapModeTileFlipXY);
    g->FillRectangle(&rectGrad, 350, 20, 100, 80);
    g->DrawRectangle(&blackPen, brushRect);

    // Create a radial gradient brush.

    Color centerColor(255, 255, 255, 255);
    Color boundaryColor(255, 0, 0, 0);
    brushRect.X = 380;
    brushRect.Y = 130;
    RadialGradientBrush radGrad(brushRect, centerColor,
                        boundaryColor, WrapModeClamp);

    g->FillRectangle(&radGrad, 320, 120, 120, 100);

    // Load bmp files.

    WCHAR *filename = L"winnt256.bmp";
    Bitmap *bitmap = new Bitmap(filename);

    // Create a texture brush.
/*
    Rect copyRect;
    copyRect.X = 60;
    copyRect.Y = 60;
    copyRect.Width = 80;
    copyRect.Height = 60;
    Bitmap *copiedBitmap = bitmap->CopyArea(&copyRect, Bm32bppARGB);

    if(copiedBitmap)
    {
        // Create a texture brush.

        Texture textureBrush = Texture(copiedBitmap, WrapModeTile);
        copiedBitmap->Dispose();

        // Create a radial gradient pen.

        GeometricPen gradPen(width, &rectGrad);

        points[0].X = 50;
        points[0].Y = 300;
        points[1].X = 100;
        points[1].Y = 300;
        points[2].X = 120;
        points[2].Y = 370;
        points[3].X = 50;
        points[3].Y = 350;
        g->FillPolygon(&textureBrush, (Point*)&points[0], 4);
        g->DrawPolygon(&gradPen, (Point*)&points[0], 4);

        points[0].X = 100;
        points[0].Y = 160;
        points[1].X = -50;
        points[1].Y = 160;
        points[2].X = 150;
        points[2].Y = 350;
        points[3].X = 200;
        points[3].Y = 220;
        path = new Path(FillModeAlternate);
        path->AddBeziers((Point*)&points[0], 4);
        g->FillPath(&textureBrush, path);
//        g->FillPath(&rectGrad, path);
        g->DrawPath(&gradPen, path);

        delete path;
    }

    Rectangle destRect(220, 300, 180, 120);
    Rectangle srcRect;
    srcRect.X = 20;
    srcRect.Y = 20;
    srcRect.Width = 180;
    srcRect.Height = 180;
    g->DrawImage(bitmap, &destRect);
//    g->DrawImage(bitmap, destRect, srcRect);

    bitmap->Dispose();
/
 //   TestPath2(g);
 //   TestPrimitives(g);

    delete g;

    // TODO:  Mem leaks on other allocated memory.

/*
  {
    GeometricPen *pen = 
            new GeometricPen((REAL)1.0, (Gdiplus::Brush*)0);


    Rectangle rectf;

    Point pointf(1.0, 2.0);
  }


  {
    Gdiplus::GeometricPen *pen =
            new Gdiplus::GeometricPen((REAL)1.0, (Gdiplus::Brush*)0);


    Gdiplus::Rectangle rectf;

    Gdiplus::Point pointf(1.0, 2.0);
  }
  */
  }

}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    switch (uMsg)
    {
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;

            hdc = BeginPaint(hwnd, &ps);
            DoTest(hwnd, hdc);
            EndPaint(hwnd, &ps);
        }
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMainWindow(
    VOID
    )

#define MYWNDCLASSNAME TEXT("GdiplusDllTest")

{
    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            CS_HREDRAW|CS_VREDRAW,
            MyWindowProc,
            0,
            0,
            appInstance,
            NULL,
            LoadCursor(NULL, IDC_ARROW),
            (HBRUSH) (COLOR_WINDOW+1),
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);
    argCount = argc;
    argArray = argv;

    //
    // Create the main application window
    //

    CreateMainWindow();

    //
    // Main message loop
    //

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\dxtpriv.h ===
//depot/Lab06_N/root/public/internal/mshtml/inc/dxtpriv.h#1 - add change 5035 (text)
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the matrix classes.
*
*******************************************************************************/
#ifndef __DXTPRIV_H_
#define __DXTPRIV_H_

#ifndef _INC_MATH
#include <math.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

//=== Class, Enum, Struct and Union Declarations ===================
class CDXMatrix4x4F;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================
float det4x4( CDXMatrix4x4F *pIn );
float det3x3( float a1, float a2, float a3, float b1, float b2, float b3, 
              float c1, float c2, float c3 );
float det2x2( float a, float b, float c, float d );

/*** CDX2DXForm ************
*   This class implements basic matrix operation based on the GDI XFORM
*   structure.
*/
//const DX2DXFORM g_DX2DXFORMIdentity = { 1., 0., 0., 1., 0., 0., DX2DXO_IDENTITY };

class CDX2DXForm : public DX2DXFORM
{
  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDX2DXForm() { SetIdentity(); }
    CDX2DXForm( const CDX2DXForm& Other ) { memcpy( this, &Other, sizeof(*this) ); }
    CDX2DXForm( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); }

    /*--- methods ---*/
    void DetermineOp( void );
    void Set( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); DetermineOp(); }
    void ZeroMatrix( void ) { memset( this, 0, sizeof( *this ) ); }
    void SetIdentity( void ) {  
        eM11 = 1.;
        eM12 = 0.;
        eM21 = 0.;
        eM22 = 1.;
        eDx = 0.;
        eDy = 0.;
        eOp = DX2DXO_IDENTITY;
    }
    BOOL IsIdentity() const { return eOp == DX2DXO_IDENTITY; }
    void Scale( float sx, float sy );
    void Rotate( float Rotation );
    void Translate( float dx, float dy );
    BOOL Invert();
    void TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const;
    void TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const;
    void GetMinMaxScales( float& MinScale, float& MaxScale );

    /*--- operators ---*/
    DXFPOINT operator*( const DXFPOINT& v ) const;
    CDX2DXForm operator*( const CDX2DXForm& Other ) const;
};

//=== CDX2DXForm methods ==============================================================
inline void CDX2DXForm::DetermineOp( void )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        if( ( eM11 == 1. ) && ( eM22 == 1. ) )
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_IDENTITY):(DX2DXO_TRANSLATE);
        }
        else
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_SCALE):(DX2DXO_SCALE_AND_TRANS);
        }
    }
    else
    {
        eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_GENERAL):(DX2DXO_GENERAL_AND_TRANS);
    }
} /* CDX2DXForm::DetermineOp */

inline float DXSq( float f ) { return f * f; }

// This function computes the Min and Max scale that a matrix represents.
// In other words, what is the maximum/minimum length that a line of length 1
// could get stretched/shrunk to if the line was transformed by this matrix.
//
// The function uses eigenvalues; and returns two float numbers. Both are
// non-negative; and MaxScale >= MinScale.
// 
inline void CDX2DXForm::GetMinMaxScales( float& MinScale, float& MaxScale )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        // Let MinScale = abs(eM11)
        if (eM11 < 0)
            MinScale = -eM11;
        else
            MinScale = eM11;

        // Let MaxScale = abs(eM22)
        if (eM22 < 0)
            MaxScale = -eM22;
        else
            MaxScale = eM22;

        // Swap Min/Max if necessary
        if (MinScale > MaxScale)
        {
            float flTemp = MinScale;
            MinScale = MaxScale;
            MaxScale = flTemp;
        }
    }
    else
    {
        float t1 = DXSq(eM11) + DXSq(eM12) + DXSq(eM21) + DXSq(eM22);
        if( t1 == 0. )
        {
            MinScale = MaxScale = 0;
        }
        else
        {
            float t2 = (float)sqrt( (DXSq(eM12 + eM21) + DXSq(eM11 - eM22)) *
                                    (DXSq(eM12 - eM21) + DXSq(eM11 + eM22)) );

            // Due to floating point error; t1 may end up less than t2;
            // but that would mean that the min scale was small (relative
            // to max scale)
            if (t1 <= t2)
                MinScale = 0;
            else
                MinScale = (float)sqrt( (t1 - t2) * .5f );

            MaxScale = (float)sqrt( (t1 + t2) * .5f );
        }
    }
} /* CDX2DXForm::GetMinMaxScales */

inline void CDX2DXForm::Rotate( float Rotation )
{
    double Angle = Rotation * (3.1415926535/180.0);
    float CosZ   = (float)cos( Angle );
    float SinZ   = (float)sin( Angle );
    if (CosZ > 0.0F && CosZ < 0.0000005F)
    {
        CosZ = .0F;
    }
    if (SinZ > -0.0000005F && SinZ < .0F)
    {
        SinZ = .0F;
    }

    float M11 = ( CosZ * eM11 ) + ( SinZ * eM21 ); 
    float M21 = (-SinZ * eM11 ) + ( CosZ * eM21 );
    float M12 = ( CosZ * eM12 ) + ( SinZ * eM22 ); 
    float M22 = (-SinZ * eM12 ) + ( CosZ * eM22 );
    eM11 = M11; eM21 = M21; eM12 = M12; eM22 = M22;
    DetermineOp();
} /* CDX2DXForm::Rotate */

inline void CDX2DXForm::Scale( float sx, float sy )
{
    eM11 *= sx;
    eM12 *= sx;
    eDx  *= sx;
    eM21 *= sy;
    eM22 *= sy;
    eDy  *= sy;
    DetermineOp();
} /* CDX2DXForm::Scale */

inline void CDX2DXForm::Translate( float dx, float dy )
{
    eDx += dx;
    eDy += dy;
    DetermineOp();
} /* CDX2DXForm::Translate */

inline void CDX2DXForm::TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const
{
    ResultBnds = Bnds;
    if( eOp != DX2DXO_IDENTITY )
    {
        ResultBnds.u.D[DXB_X].Min = (long)(( eM11 * Bnds.u.D[DXB_X].Min ) + ( eM12 * Bnds.u.D[DXB_Y].Min ) + eDx);
        ResultBnds.u.D[DXB_X].Max = (long)(( eM11 * Bnds.u.D[DXB_X].Max ) + ( eM12 * Bnds.u.D[DXB_Y].Max ) + eDx);
        ResultBnds.u.D[DXB_Y].Min = (long)(( eM21 * Bnds.u.D[DXB_X].Min ) + ( eM22 * Bnds.u.D[DXB_Y].Min ) + eDy);
        ResultBnds.u.D[DXB_Y].Max = (long)(( eM21 * Bnds.u.D[DXB_X].Max ) + ( eM22 * Bnds.u.D[DXB_Y].Max ) + eDy);
    }
} /* CDX2DXForm::TransformBounds */

inline void CDX2DXForm::TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const
{
    ULONG i;
    switch( eOp )
    {
      case DX2DXO_IDENTITY:
        memcpy( OutPnts, InPnts, ulCount * sizeof( DXFPOINT ) );
        break;
      case DX2DXO_TRANSLATE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x + eDx;
            OutPnts[i].y = InPnts[i].y + eDy;
        }
        break;
      case DX2DXO_SCALE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x * eM11;
            OutPnts[i].y = InPnts[i].y * eM22;
        }
        break;
      case DX2DXO_SCALE_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = (InPnts[i].x * eM11) + eDx;
            OutPnts[i].y = (InPnts[i].y * eM22) + eDy;
        }
        break;
      case DX2DXO_GENERAL:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 );
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 );
        }
        break;
      case DX2DXO_GENERAL_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 ) + eDx;
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 ) + eDy;
        }
        break;
      default:
        _ASSERT( 0 );   // invalid operation id
    }
} /* CDX2DXForm::TransformPoints */

inline DXFPOINT CDX2DXForm::operator*( const DXFPOINT& v ) const
{
    DXFPOINT NewPnt;
    NewPnt.x = ( v.x * eM11 ) + ( v.y * eM12 ) + eDx;
    NewPnt.y = ( v.x * eM21 ) + ( v.y * eM22 ) + eDy;
    return NewPnt;
} /* CDX2DXForm::operator* */

inline CDX2DXForm CDX2DXForm::operator*( const CDX2DXForm& Other ) const
{
    DX2DXFORM x;
    x.eM11 = ( eM11 * Other.eM11 ) + ( eM12 * Other.eM21 );
    x.eM12 = ( eM11 * Other.eM12 ) + ( eM12 * Other.eM22 );
    x.eDx  = ( eM11 * Other.eDx  ) + ( eM12 * Other.eDy  ) + eDx;

    x.eM21 = ( eM21 * Other.eM11 ) + ( eM22 * Other.eM21 );
    x.eM22 = ( eM21 * Other.eM12 ) + ( eM22 * Other.eM22 );
    x.eDy  = ( eM21 * Other.eDx  ) + ( eM22 * Other.eDy  ) + eDy;
    return x;
} /* CDX2DXForm::operator*= */

inline BOOL CDX2DXForm::Invert()
{
    switch( eOp )
    {
    case DX2DXO_IDENTITY:
        break;
    case DX2DXO_TRANSLATE:
        eDx = -eDx;
        eDy = -eDy;
        break;
    case DX2DXO_SCALE:

        if (eM11 == 0.0 || eM22 == 0.0)
            return false;
        eM11 = 1.0f / eM11;
        eM22 = 1.0f / eM22;
        break;

    case DX2DXO_SCALE_AND_TRANS:
        {
            if (eM11 == 0.0f || eM22 == 0.0f)
                return false;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM11 and b is eDx
            float flOneOverA = 1.0f / eM11;
            eDx = -eDx * flOneOverA;
            eM11 = flOneOverA;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM22 and b is eDy

            flOneOverA = 1.0f / eM22;
            eDy = -eDy * flOneOverA;
            eM22 = flOneOverA;
            break;
        }

    case DX2DXO_GENERAL:
    case DX2DXO_GENERAL_AND_TRANS:
        {
            // The inverse of A=  |a b| is | d -c|*(1/Det) where Det is the determinant of A
            //                    |c d|    |-b  a|
            // Det(A) = ad - bc

            // Compute determininant
            float flDet = (eM11 * eM22 -  eM12 * eM21);
            if (flDet == 0.0f)
                return FALSE;

            float flCoef = 1.0f / flDet;

            // Remember old value of eM11
            float flM11Original = eM11;

            eM11 = flCoef * eM22;
            eM12 = -flCoef * eM12;
            eM21 = -flCoef * eM21;
            eM22 = flCoef * flM11Original;

            // If we have a translation; then we need to 
            // compute new values for that translation
            if (eOp == DX2DXO_GENERAL_AND_TRANS)
            {
                // Remember original value of eDx
                float eDxOriginal = eDx;

                eDx = -eM11 * eDx - eM12 * eDy;
                eDy = -eM21 * eDxOriginal - eM22 * eDy;
            }
        }
        break;

    default:
        _ASSERT( 0 );   // invalid operation id
    }

    // We don't need to call DetermineOp here
    // because the op doesn't change when inverted
    // i.e. a scale remains a scale, etc.

    return true;
} /* CDX2DXForm::Invert */

/*** CDXMatrix4x4F ************
*   This class implements basic matrix operation based on a 4x4 array.
*/
//const float g_DXMat4X4Identity[4][4] =
//{
//    { 1.0, 0. , 0. , 0.  },
//    { 0. , 1.0, 0. , 0.  },
//    { 0. , 0. , 1.0, 0.  },
//    { 0. , 0. , 0. , 1.0 }
//};

class CDXMatrix4x4F
{
public:
  /*=== Member Data ===*/
    float m_Coeff[4][4];

  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDXMatrix4x4F() { SetIdentity(); }
    CDXMatrix4x4F( const CDXMatrix4x4F& Other )
        { CopyMemory( (void *)&m_Coeff, (void *)&Other.m_Coeff, sizeof(m_Coeff) ); }
    CDXMatrix4x4F( DX2DXFORM& XForm );

    /*--- operations ---*/
    void ZeroMatrix( void ) { memset( m_Coeff, 0, sizeof( m_Coeff ) ); }
    void SetIdentity( void ) {
        memset( m_Coeff, 0, sizeof( m_Coeff ) );
        m_Coeff[0][0] = m_Coeff[1][1] = m_Coeff[2][2] = m_Coeff[3][3] = 1.0;
    }
    void SetCoefficients( float Coeff[4][4] ) { memcpy( m_Coeff, Coeff, sizeof( m_Coeff )); }
    void GetCoefficients( float Coeff[4][4] ) { memcpy( Coeff, m_Coeff, sizeof( m_Coeff )); }

    //BOOL IsIdentity();
    void Scale( float sx, float sy, float sz );
    void Rotate( float rx, float ry, float rz );
    void Translate( float dx, float dy, float dz );
    BOOL Invert();
    BOOL GetInverse( CDXMatrix4x4F *pIn );
    void Transpose();
    void GetTranspose( CDXMatrix4x4F *pIn );
    void GetAdjoint( CDXMatrix4x4F *pIn );
    HRESULT InitFromSafeArray( SAFEARRAY *psa );
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void TransformBounds( DXBNDS& Bnds, DXBNDS& ResultBnds );

    /*--- operators ---*/
    CDXDVec operator*( CDXDVec& v) const;
    CDXCVec operator*( CDXCVec& v) const;
    CDXMatrix4x4F operator*(CDXMatrix4x4F Matrix) const;
    void operator*=(CDXMatrix4x4F Matrix) const;
    void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix);
    void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix);
    void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix);
    BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const;
    BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const;
};

inline CDXMatrix4x4F::CDXMatrix4x4F( DX2DXFORM& XForm )
{
    SetIdentity();
    m_Coeff[0][0] = XForm.eM11;
    m_Coeff[0][1] = XForm.eM12;
    m_Coeff[1][0] = XForm.eM21;
    m_Coeff[1][1] = XForm.eM22;
    m_Coeff[0][3] = XForm.eDx;
    m_Coeff[1][3] = XForm.eDy;
}

// Additional Operations

inline void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix)
{
    CopyMemory( (void *)m_Coeff, (const void *)srcMatrix.m_Coeff, sizeof(srcMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator= */

inline BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const
{
    return !memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator== */

inline BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const
{
    return memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator!= */

inline void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix)
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] += otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator+= */

inline void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix) 
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] -= otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator-= */

inline CDXDVec CDXMatrix4x4F::operator*(CDXDVec& v) const
{
    CDXDVec t;
    float temp;
    temp = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[0] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[1] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[2] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    t[3] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    return t;
} /* CDXMatrix4x4F::operator*(DXDVEC) */

inline CDXCVec CDXMatrix4x4F::operator*(CDXCVec& v) const
{
    CDXCVec t;
    t[0] = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[1] = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[2] = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[3] = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    return t;
} /* CDXMatrix4x4F::operator*(DXCVEC) */

inline CDXMatrix4x4F CDXMatrix4x4F::operator*(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    return t;
} /* CDXMatrix4x4F::operator*(CDXMatrix4x4F) */
            
inline void CDXMatrix4x4F::operator*=(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    CopyMemory( (void *)m_Coeff, (void *)t.m_Coeff, sizeof(m_Coeff) );
} /* CDXMatrix4x4F::operator*=(CDXMatrix4x4F) */
            

inline void CDXMatrix4x4F::Scale( float sx, float sy, float sz )
{
    if( sx != 1. )
    {
        m_Coeff[0][0] *= sx;
        m_Coeff[0][1] *= sx;
        m_Coeff[0][2] *= sx;
        m_Coeff[0][3] *= sx;
    }
    if( sy != 1. )
    {
        m_Coeff[1][0] *= sy;
        m_Coeff[1][1] *= sy;
        m_Coeff[1][2] *= sy;
        m_Coeff[1][3] *= sy;
    }
    if( sz != 1. )
    {
        m_Coeff[2][0] *= sz;
        m_Coeff[2][1] *= sz;
        m_Coeff[2][2] *= sz;
        m_Coeff[2][3] *= sz;
    }
} /* CDXMatrix4x4F::Scale */

inline void CDXMatrix4x4F::Translate( float dx, float dy, float dz )
{
    float a, b, c, d;
    a = b = c = d = 0;
    if( dx != 0. )
    {
        a += m_Coeff[0][0]*dx;
        b += m_Coeff[0][1]*dx;
        c += m_Coeff[0][2]*dx;
        d += m_Coeff[0][3]*dx;
    }
    if( dy != 0. )
    {
        a += m_Coeff[1][0]*dy;
        b += m_Coeff[1][1]*dy;
        c += m_Coeff[1][2]*dy;
        d += m_Coeff[1][3]*dy;
    }
    if( dz != 0. )
    {
        a += m_Coeff[2][0]*dz;
        b += m_Coeff[2][1]*dz;
        c += m_Coeff[2][2]*dz;
        d += m_Coeff[2][3]*dz;
    }
    m_Coeff[3][0] += a;
    m_Coeff[3][1] += b;
    m_Coeff[3][2] += c;
    m_Coeff[3][3] += d;
} /* CDXMatrix4x4F::Translate */

inline void CDXMatrix4x4F::Rotate( float rx, float ry, float rz )
{
    const float l_dfCte = (const float)(3.1415926535/180.0);

    float lAngleY = 0.0;
    float lAngleX = 0.0;
    float lAngleZ = 0.0;
    float lCosX = 1.0;
    float lSinX = 0.0;
    float lCosY = 1.0;
    float lSinY = 0.0;
    float lCosZ = 1.0;
    float lSinZ = 0.0;

    // calculate rotation angle sines and cosines
    if( rx != 0 )
    {
        lAngleX = rx * l_dfCte;
        lCosX = (float)cos(lAngleX);
        lSinX = (float)sin(lAngleX);
        if (lCosX > 0.0F && lCosX < 0.0000005F)
        {
            lCosX = .0F;
        }
        if (lSinX > -0.0000005F && lSinX < .0F)
        {
            lSinX = .0F;
        }
    }
    if( ry != 0 )
    {
        lAngleY = ry * l_dfCte;
        lCosY = (float)cos(lAngleY);
        lSinY = (float)sin(lAngleY);
        if (lCosY > 0.0F && lCosY < 0.0000005F)
        {
            lCosY = .0F;
        }
        if (lSinY > -0.0000005F && lSinY < .0F)
        {
            lSinY = .0F;
        }
    }
    if( rz != 0 )
    {
        lAngleZ = rz * l_dfCte;
        lCosZ = (float)cos(lAngleZ);
        lSinZ = (float)sin(lAngleZ);
        if (lCosZ > 0.0F && lCosZ < 0.0000005F)
        {
            lCosZ = .0F;
        }
        if (lSinZ > -0.0000005F && lSinZ < .0F)
        {
            lSinZ = .0F;
        }
    }

    float u, v;
    int i;

    //--- X Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[1][i]; 
        v = m_Coeff[2][i];
        m_Coeff[1][i] = lCosX*u+lSinX*v; 
        m_Coeff[2][i] = -lSinX*u+lCosX*v;
    }

    //--- Y Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[2][i];
        m_Coeff[0][i] = lCosY*u-lSinY*v; 
        m_Coeff[2][i] = lSinY*u+lCosY*v;
    }

    //--- Z Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[1][i];
        m_Coeff[0][i] = lCosZ*u+lSinZ*v; 
        m_Coeff[1][i] = -lSinZ*u+lCosZ*v;
    }
}

/*
inline BOOL CDXMatrix4x4F::IsIdentity()
{
    return  !memcmp( m_Coeff, g_DXMat4X4Identity, sizeof(g_DXMat4X4Identity) );
} /* CDXMatrix4x4F::IsIdentity */


/*
   Uses Gaussian elimination to invert the 4 x 4 non-linear matrix in t and
   return the result in Mx.  The matrix t is destroyed in the process.
*/
inline BOOL CDXMatrix4x4F::Invert()
{
    int i,j,k,Pivot;
    float PValue;
    CDXMatrix4x4F Mx;
    Mx.SetIdentity();

/* Find pivot element.  Use partial pivoting by row */
    for( i = 0;i < 4; i++ )
    {
        Pivot = 0;
        for( j = 0; j < 4; j++ )
        {
            if( fabs(m_Coeff[i][j]) > fabs(m_Coeff[i][Pivot]) ) Pivot = j;
        }

        if( m_Coeff[i][Pivot] == 0.0 )
        {
            ZeroMatrix();   /* Singular Matrix */
            return FALSE; 
        }

/* Normalize */
        PValue = m_Coeff[i][Pivot];
        for( j = 0; j < 4; j++ )
        {
            m_Coeff[i][j] /= PValue;
            Mx.m_Coeff[i][j] /= PValue;
        }

/* Zeroing */
        for( j = 0; j < 4; j++ )
        {
            if( j != i )
            {
                PValue = m_Coeff[j][Pivot];
                for( k = 0; k < 4; k++ )
                {
                    m_Coeff[j][k] -= PValue*m_Coeff[i][k];
                    Mx.m_Coeff[j][k] -= PValue*Mx.m_Coeff[i][k];
                }
            }
        }
    }

/* Reorder rows */
    for( i = 0; i < 4; i++ )
    {
        if( m_Coeff[i][i] != 1.0 )
        {
            for( j = i + 1; j < 4; j++ )
                if( m_Coeff[j][i] == 1.0 ) break;
            if( j >= 4 )
            {
                ZeroMatrix();
                return FALSE;
            }

            //--- swap rows i and j of original
            for( k = 0; k < 4; k++ )
            {
                m_Coeff[i][k] += m_Coeff[j][k];
                m_Coeff[j][k] = m_Coeff[i][k] - m_Coeff[j][k];
                m_Coeff[i][k] -= m_Coeff[j][k];
            }
            
            //--- swap rows i and j of result
            for( k = 0; k < 4; k++ )
            {
                Mx.m_Coeff[i][k] += Mx.m_Coeff[j][k];
                Mx.m_Coeff[j][k] = Mx.m_Coeff[i][k] - Mx.m_Coeff[j][k];
                Mx.m_Coeff[i][k] -= Mx.m_Coeff[j][k];
            }
        }
    }
    *this = Mx;
    return TRUE;
} /* CDXMatrix4x4F::Invert */

inline void CDXMatrix4x4F::Transpose()
{
    float temp;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */

inline void CDXMatrix4x4F::GetTranspose( CDXMatrix4x4F *m )
{
    float temp;

    (*this) = *m;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */


/*
Matrix Inversion
by Richard Carling
from "Graphics Gems", Academic Press, 1990
*/

#define SMALL_NUMBER    1.e-8
/* 
 *   inverse( original_matrix, inverse_matrix )
 * 
 *    calculate the inverse of a 4x4 matrix
 *
 *     -1     
 *     A  = ___1__ adjoint A
 *         det A
 */

inline BOOL CDXMatrix4x4F::GetInverse( CDXMatrix4x4F *pIn )
{
    int i, j;
    float det;

    /* calculate the adjoint matrix */

    GetAdjoint( pIn );

    /*  calculate the 4x4 determinant
     *  if the determinant is zero, 
     *  then the inverse matrix is not unique.
     */

    det = det4x4( pIn );

    if( fabs( det ) < SMALL_NUMBER )
    {
        //  Non-singular matrix, no inverse!
        return FALSE;;
    }

    /* scale the adjoint matrix to get the inverse */

    for( i = 0; i < 4; i++ )
        for( j = 0; j < 4; j++ )
            m_Coeff[i][j] = m_Coeff[i][j] / det;

    return TRUE;
}


/* 
 *   adjoint( original_matrix, inverse_matrix )
 * 
 *     calculate the adjoint of a 4x4 matrix
 *
 *      Let  a   denote the minor determinant of matrix A obtained by
 *           ij
 *
 *      deleting the ith row and jth column from A.
 *
 *                    i+j
 *     Let  b   = (-1)    a
 *          ij            ji
 *
 *    The matrix B = (b  ) is the adjoint of A
 *                     ij
 */
inline void CDXMatrix4x4F::GetAdjoint( CDXMatrix4x4F *pIn )
{
    float a1, a2, a3, a4, b1, b2, b3, b4;
    float c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid  */
    /* selecting correct values  */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1];
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];


    /* row column labeling reversed since we transpose rows & columns */

    m_Coeff[0][0]  =   det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4);
    m_Coeff[1][0]  = - det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4);
    m_Coeff[2][0]  =   det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4);
    m_Coeff[3][0]  = - det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4);
        
    m_Coeff[0][1]  = - det3x3( b1, b3, b4, c1, c3, c4, d1, d3, d4);
    m_Coeff[1][1]  =   det3x3( a1, a3, a4, c1, c3, c4, d1, d3, d4);
    m_Coeff[2][1]  = - det3x3( a1, a3, a4, b1, b3, b4, d1, d3, d4);
    m_Coeff[3][1]  =   det3x3( a1, a3, a4, b1, b3, b4, c1, c3, c4);
        
    m_Coeff[0][2]  =   det3x3( b1, b2, b4, c1, c2, c4, d1, d2, d4);
    m_Coeff[1][2]  = - det3x3( a1, a2, a4, c1, c2, c4, d1, d2, d4);
    m_Coeff[2][2]  =   det3x3( a1, a2, a4, b1, b2, b4, d1, d2, d4);
    m_Coeff[3][2]  = - det3x3( a1, a2, a4, b1, b2, b4, c1, c2, c4);
        
    m_Coeff[0][3]  = - det3x3( b1, b2, b3, c1, c2, c3, d1, d2, d3);
    m_Coeff[1][3]  =   det3x3( a1, a2, a3, c1, c2, c3, d1, d2, d3);
    m_Coeff[2][3]  = - det3x3( a1, a2, a3, b1, b2, b3, d1, d2, d3);
    m_Coeff[3][3]  =   det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3);
}
/*
 * float = det4x4( matrix )
 * 
 * calculate the determinant of a 4x4 matrix.
 */
inline float det4x4( CDXMatrix4x4F *pIn )
{
    float ans;
    float a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid selecting */
    /*  correct elements */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1]; 
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];

    ans = a1 * det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4 )
        - b1 * det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4 )
        + c1 * det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4 )
        - d1 * det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4 );
    return ans;
}

/*
 * float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
 * 
 * calculate the determinant of a 3x3 matrix
 * in the form
 *
 *     | a1,  b1,  c1 |
 *     | a2,  b2,  c2 |
 *     | a3,  b3,  c3 |
 */

inline float det3x3( float a1, float a2, float a3, 
                     float b1, float b2, float b3, 
                     float c1, float c2, float c3 )
{
    float ans;

    ans = a1 * det2x2( b2, b3, c2, c3 )
        - b1 * det2x2( a2, a3, c2, c3 )
        + c1 * det2x2( a2, a3, b2, b3 );
    return ans;
}

/*
 * float = det2x2( float a, float b, float c, float d )
 * 
 * calculate the determinant of a 2x2 matrix.
 */
inline float det2x2( float a, float b, float c, float d )
{
    float ans = a * d - b * c;
    return ans;
}

inline HRESULT CDXMatrix4x4F::InitFromSafeArray( SAFEARRAY * /*pSA*/ )
{
    HRESULT hr = S_OK;
#if 0
    long *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(float) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                m_Bounds[i].Min = pData[i];
                m_Bounds[i].Max = pData[i+4];
                m_Bounds[i].SampleRate = SampleRate;
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::InitFromSafeArray */

inline HRESULT CDXMatrix4x4F::GetSafeArray( SAFEARRAY ** /*ppSA*/ ) const
{
    HRESULT hr = S_OK;
#if 0
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 16;

        if( !(pSA = SafeArrayCreate( VT_I4, 1, &rgsabound ) ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = m_Bounds[i].Min;
                    pData[i+4] = m_Bounds[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::GetSafeArray */

inline void CDXMatrix4x4F::TransformBounds( DXBNDS& /*Bnds*/, DXBNDS& /*ResultBnds*/ )
{

} /* CDXMatrix4x4F::TransformBounds */



#endif   // __DXTPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\blt.h ===
#ifndef _Blt_h
#define _Blt_h

// File:	Blt.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//    These are all of the blt routines that are available.  It is assumed
//  that clipping and parameter checking has already occurred.
//
// History:
// -@- 09/23/97 (mikemarr) copied to DXCConv from d2d\mmimage
// -@- 10/28/97 (mikemarr) added colorfill routines
// -@- 10/28/97 (mikemarr) added HasPixelFn/ColorFillFn arrays


#ifndef _PixInfo_h
#include "PixInfo.h"
#endif

typedef HRESULT (*ColorFillFn)(BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);

HRESULT	ColorFill8(		BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);
HRESULT	ColorFill16(	BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);
HRESULT	ColorFill24(	BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);
HRESULT	ColorFill32(	BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);

extern ColorFillFn g_rgColorFillFn[5];


typedef HRESULT (*HasPixelFn)(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel, 
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);

HRESULT HasPixel8(		const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);
HRESULT HasPixel16(		const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);
HRESULT HasPixel24(		const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);
HRESULT HasPixel32(		const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);

extern HasPixelFn g_rgHasPixelFn[5];


//
// Regular Image Bltting
//
// Notes:
//    Notice we can do subrectangle bltting by adjusting the src & dst
//  pixel pointers before calling these routines.



// straight Blts
HRESULT BltFast(		const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nSrcWidth, DWORD nHeight);

HRESULT BltFastMirrorY(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nSrcWidth, DWORD nHeight);

HRESULT BltFastRGBToRGB(const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight,
						const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst);

HRESULT BltFast24To16(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight,
						const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst);

HRESULT BltFast32To32(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight,
						const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst);

HRESULT BltFast24To32(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight,
						const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst);

HRESULT BltFast8To4(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch,
						DWORD nWidth, DWORD nHeight, DWORD nOffset);

HRESULT BltFast8To2(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch,
						DWORD nWidth, DWORD nHeight, DWORD nOffset);

HRESULT BltFast8To1(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight, DWORD nOffset);

// color key blt
HRESULT BltFast8CK(		const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nSrcWidth, DWORD nHeight, DWORD dwTrans);

// translation Blts
HRESULT BltFast8To8T(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);
HRESULT BltFast8To16T(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);
HRESULT BltFast8To24T(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);
HRESULT BltFast8To32T(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);

//
// RLE Bltting
// Notes:
//    RLE is assumed to encode transparency as the zeroth index.
//
// straight Blts
HRESULT BltFastRLE8(DWORD nXPos, DWORD nYPos,
					const BYTE *pSrcPixels, long nSrcPitch,
					BYTE *pDstPixels, long nDstPitch,
					const LPRECT prSrcRect);

// translation Blts
HRESULT BltFastRLE8To8T(DWORD nXPos, DWORD nYPos,
						const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						const LPRECT prSrcRect, const BYTE *pIndexMap);
HRESULT BltFastRLE8To16T(DWORD nXPos, DWORD nYPos,
						const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						const LPRECT prSrcRect, const BYTE *pIndexMap);
HRESULT BltFastRLE8To24T(DWORD nXPos, DWORD nYPos,
						const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						const LPRECT prSrcRect, const BYTE *pIndexMap);
HRESULT BltFastRLE8To32T(DWORD nXPos, DWORD nYPos,
						const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						const LPRECT prSrcRect, const BYTE *pIndexMap);

// Function: WriteXBitRow
//    These functions pack bytes into bit streams.  Buffers with
//  a bit count <= sizeof(unsigned char) are passed as a buffer 
//  of unsigned char's, buffers with a bit count <= sizeof(unsigned
//  short) are passed as unsigned short, etc.
//void *Write4BitRow(void *pDst, const void *pSrc, unsigned int cCount);
//void *Write2BitRow(void *pDst, const void *pSrc, unsigned int cCount);
//void *Write1BitRow(void *pDst, const void *pSrc, unsigned int cCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\dxtranspguid.h ===
//depot/Lab06_N/root/public/internal/mshtml/inc/dxtranspguid.h#1 - add change 5035 (text)

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtransp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXWarp,0xB7BCEBE0,0x6797,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTClipOrigin,0xEE1663D8,0x0988,0x4C48,0x9F,0xD6,0xDB,0x44,0x50,0x88,0x56,0x68);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSPLib,0x527A4DA4,0x7F2C,0x11d2,0xB1,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DXWarp,0xE0EEC500,0x6798,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtransp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXWarp,0xB7BCEBE0,0x6797,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTClipOrigin,0xEE1663D8,0x0988,0x4C48,0x9F,0xD6,0xDB,0x44,0x50,0x88,0x56,0x68);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSPLib,0x527A4DA4,0x7F2C,0x11d2,0xB1,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DXWarp,0xE0EEC500,0x6798,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\dxtransp.h ===
//depot/Lab06_N/root/public/internal/mshtml/inc/dxtransp.h#1 - add change 5035 (text)

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtransp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtransp_h__
#define __dxtransp_h__

/* Forward Declarations */ 

#ifndef __IDXRasterizer_FWD_DEFINED__
#define __IDXRasterizer_FWD_DEFINED__
typedef interface IDXRasterizer IDXRasterizer;
#endif 	/* __IDXRasterizer_FWD_DEFINED__ */


#ifndef __IDXTLabel_FWD_DEFINED__
#define __IDXTLabel_FWD_DEFINED__
typedef interface IDXTLabel IDXTLabel;
#endif 	/* __IDXTLabel_FWD_DEFINED__ */


#ifndef __IDX2DDebug_FWD_DEFINED__
#define __IDX2DDebug_FWD_DEFINED__
typedef interface IDX2DDebug IDX2DDebug;
#endif 	/* __IDX2DDebug_FWD_DEFINED__ */


#ifndef __IDX2D_FWD_DEFINED__
#define __IDX2D_FWD_DEFINED__
typedef interface IDX2D IDX2D;
#endif 	/* __IDX2D_FWD_DEFINED__ */


#ifndef __IDXGradient2_FWD_DEFINED__
#define __IDXGradient2_FWD_DEFINED__
typedef interface IDXGradient2 IDXGradient2;
#endif 	/* __IDXGradient2_FWD_DEFINED__ */


#ifndef __IDXWarp_FWD_DEFINED__
#define __IDXWarp_FWD_DEFINED__
typedef interface IDXWarp IDXWarp;
#endif 	/* __IDXWarp_FWD_DEFINED__ */


#ifndef __IDXTClipOrigin_FWD_DEFINED__
#define __IDXTClipOrigin_FWD_DEFINED__
typedef interface IDXTClipOrigin IDXTClipOrigin;
#endif 	/* __IDXTClipOrigin_FWD_DEFINED__ */


#ifndef __DXWarp_FWD_DEFINED__
#define __DXWarp_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXWarp DXWarp;
#else
typedef struct DXWarp DXWarp;
#endif /* __cplusplus */

#endif 	/* __DXWarp_FWD_DEFINED__ */


#ifndef __DXTLabel_FWD_DEFINED__
#define __DXTLabel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLabel DXTLabel;
#else
typedef struct DXTLabel DXTLabel;
#endif /* __cplusplus */

#endif 	/* __DXTLabel_FWD_DEFINED__ */


#ifndef __DXRasterizer_FWD_DEFINED__
#define __DXRasterizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXRasterizer DXRasterizer;
#else
typedef struct DXRasterizer DXRasterizer;
#endif /* __cplusplus */

#endif 	/* __DXRasterizer_FWD_DEFINED__ */


#ifndef __DX2D_FWD_DEFINED__
#define __DX2D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DX2D DX2D;
#else
typedef struct DX2D DX2D;
#endif /* __cplusplus */

#endif 	/* __DX2D_FWD_DEFINED__ */


/* header files for imported files */
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtransp_0000 */
/* [local] */ 






typedef 
enum DXRASTERFILL
    {	DXRASTER_PEN	= 0,
	DXRASTER_BRUSH	= 1,
	DXRASTER_BACKGROUND	= 2
    }	DXRASTERFILL;

typedef struct DXRASTERSCANINFO
    {
    ULONG ulIndex;
    ULONG Row;
    const BYTE __RPC_FAR *pWeights;
    const DXRUNINFO __RPC_FAR *pRunInfo;
    ULONG cRunInfo;
    }	DXRASTERSCANINFO;

typedef struct DXRASTERPOINTINFO
    {
    DXOVERSAMPLEDESC Pixel;
    ULONG ulIndex;
    BYTE Weight;
    }	DXRASTERPOINTINFO;

typedef struct DXRASTERRECTINFO
    {
    ULONG ulIndex;
    RECT Rect;
    BYTE Weight;
    }	DXRASTERRECTINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0000_v0_0_s_ifspec;

#ifndef __IDXRasterizer_INTERFACE_DEFINED__
#define __IDXRasterizer_INTERFACE_DEFINED__

/* interface IDXRasterizer */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDXRasterizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B635-C37D-11d1-905E-00C04FD9189D")
    IDXRasterizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            /* [in] */ IDXSurface __RPC_FAR *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFill( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ const POINT __RPC_FAR *ppt,
            /* [in] */ DXSAMPLE FillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFill( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ POINT __RPC_FAR *ppt,
            /* [out] */ DXSAMPLE __RPC_FAR *pFillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginRendering( 
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRendering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderScan( 
            /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPixel( 
            /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillRect( 
            /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS __RPC_FAR *pBounds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRasterizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXRasterizer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXRasterizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFill )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ const POINT __RPC_FAR *ppt,
            /* [in] */ DXSAMPLE FillColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFill )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ POINT __RPC_FAR *ppt,
            /* [out] */ DXSAMPLE __RPC_FAR *pFillColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginRendering )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndRendering )( 
            IDXRasterizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenderScan )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPixel )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FillRect )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBounds )( 
            IDXRasterizer __RPC_FAR * This,
            /* [out] */ DXBNDS __RPC_FAR *pBounds);
        
        END_INTERFACE
    } IDXRasterizerVtbl;

    interface IDXRasterizer
    {
        CONST_VTBL struct IDXRasterizerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRasterizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRasterizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRasterizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRasterizer_SetSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetSurface(This,pDXSurface)

#define IDXRasterizer_GetSurface(This,ppDXSurface)	\
    (This)->lpVtbl -> GetSurface(This,ppDXSurface)

#define IDXRasterizer_SetFill(This,ulIndex,pSurface,ppt,FillColor)	\
    (This)->lpVtbl -> SetFill(This,ulIndex,pSurface,ppt,FillColor)

#define IDXRasterizer_GetFill(This,ulIndex,ppSurface,ppt,pFillColor)	\
    (This)->lpVtbl -> GetFill(This,ulIndex,ppSurface,ppt,pFillColor)

#define IDXRasterizer_BeginRendering(This,ulTimeOut)	\
    (This)->lpVtbl -> BeginRendering(This,ulTimeOut)

#define IDXRasterizer_EndRendering(This)	\
    (This)->lpVtbl -> EndRendering(This)

#define IDXRasterizer_RenderScan(This,pScanInfo)	\
    (This)->lpVtbl -> RenderScan(This,pScanInfo)

#define IDXRasterizer_SetPixel(This,pPointInfo)	\
    (This)->lpVtbl -> SetPixel(This,pPointInfo)

#define IDXRasterizer_FillRect(This,pRectInfo)	\
    (This)->lpVtbl -> FillRect(This,pRectInfo)

#define IDXRasterizer_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRasterizer_SetSurface_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pDXSurface);


void __RPC_STUB IDXRasterizer_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetSurface_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXRasterizer_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetFill_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ IDXSurface __RPC_FAR *pSurface,
    /* [in] */ const POINT __RPC_FAR *ppt,
    /* [in] */ DXSAMPLE FillColor);


void __RPC_STUB IDXRasterizer_SetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetFill_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
    /* [out] */ POINT __RPC_FAR *ppt,
    /* [out] */ DXSAMPLE __RPC_FAR *pFillColor);


void __RPC_STUB IDXRasterizer_GetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_BeginRendering_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXRasterizer_BeginRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_EndRendering_Proxy( 
    IDXRasterizer __RPC_FAR * This);


void __RPC_STUB IDXRasterizer_EndRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_RenderScan_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo);


void __RPC_STUB IDXRasterizer_RenderScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetPixel_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo);


void __RPC_STUB IDXRasterizer_SetPixel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_FillRect_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo);


void __RPC_STUB IDXRasterizer_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetBounds_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [out] */ DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXRasterizer_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRasterizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0278 */
/* [local] */ 

typedef 
enum DX2DXFORMOPS
    {	DX2DXO_IDENTITY	= 0,
	DX2DXO_TRANSLATE	= DX2DXO_IDENTITY + 1,
	DX2DXO_SCALE	= DX2DXO_TRANSLATE + 1,
	DX2DXO_SCALE_AND_TRANS	= DX2DXO_SCALE + 1,
	DX2DXO_GENERAL	= DX2DXO_SCALE_AND_TRANS + 1,
	DX2DXO_GENERAL_AND_TRANS	= DX2DXO_GENERAL + 1
    }	DX2DXFORMOPS;

typedef struct DX2DXFORM
    {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
    DX2DXFORMOPS eOp;
    }	DX2DXFORM;

typedef struct DX2DXFORM __RPC_FAR *PDX2DXFORM;

typedef 
enum DX2DPOLYDRAW
    {	DX2D_WINDING_FILL	= 1L << 0,
	DX2D_NO_FLATTEN	= 1L << 1,
	DX2D_DO_GRID_FIT	= 1L << 2,
	DX2D_IS_RECT	= 1L << 3,
	DX2D_STROKE	= 1L << 4,
	DX2D_FILL	= 1L << 5,
	DX2D_UNUSED	= 0xffffffc0
    }	DX2DPOLYDRAW;

typedef struct DXFPOINT
    {
    FLOAT x;
    FLOAT y;
    }	DXFPOINT;

typedef 
enum DX2DPEN
    {	DX2D_PEN_DEFAULT	= 0,
	DX2D_PEN_WIDTH_IN_DISPLAY_COORDS	= 1L << 0,
	DX2D_PEN_UNUSED	= 0xfffffffe
    }	DX2DPEN;

typedef struct DXPEN
    {
    DXSAMPLE Color;
    float Width;
    DWORD Style;
    IDXSurface __RPC_FAR *pTexture;
    DXFPOINT TexturePos;
    DWORD dwFlags;
    }	DXPEN;

typedef struct DXBRUSH
    {
    DXSAMPLE Color;
    IDXSurface __RPC_FAR *pTexture;
    DXFPOINT TexturePos;
    }	DXBRUSH;

typedef 
enum DX2DGRADIENT
    {	DX2DGRAD_DEFAULT	= 0,
	DX2DGRAD_CLIPGRADIENT	= 1,
	DX2DGRAD_UNUSED	= 0xfffffffe
    }	DX2DGRADIENT;

typedef 
enum DXLOGFONTENUM
    {	DXLF_HEIGHT	= 1,
	DXLF_WIDTH	= 2,
	DXLF_ESC	= 4,
	DXLF_ORIENTATION	= 8,
	DXLF_WEIGHT	= 16,
	DXLF_ITALIC	= 32,
	DXLF_UNDERLINE	= 64,
	DXLF_STRIKEOUT	= 128,
	DXLF_CHARSET	= 256,
	DXLF_OUTPREC	= 512,
	DXLF_CLIPPREC	= 1024,
	DXLF_QUALITY	= 2048,
	DXLF_PITCHANDFAM	= 4096,
	DXLF_FACENAME	= 8192,
	DXLF_ALL	= 0x3fff
    }	DXLOGFONTENUM;

#ifndef _WINGDI_
typedef struct tagLOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    }	LOGFONTA;

typedef struct tagLOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    }	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0278_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0278_v0_0_s_ifspec;

#ifndef __IDXTLabel_INTERFACE_DEFINED__
#define __IDXTLabel_INTERFACE_DEFINED__

/* interface IDXTLabel */
/* [object][hidden][unique][uuid] */ 


EXTERN_C const IID IID_IDXTLabel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0C17F0E-AE41-11d1-9A3B-0000F8756A10")
    IDXTLabel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFontHandle( 
            /* [in] */ HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontHandle( 
            /* [out] */ HFONT __RPC_FAR *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextString( 
            /* [in] */ LPCWSTR pString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextString( 
            /* [out] */ LPWSTR __RPC_FAR *ppString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTexturePosition( 
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTexturePosition( 
            /* [in] */ long x,
            /* [in] */ long y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMatrix( 
            /* [out] */ PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMatrix( 
            /* [in] */ const PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogfont( 
            /* [in] */ const LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogfont( 
            /* [out] */ LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteWithRasterizer( 
            /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaselineOffset( 
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py,
            /* [out] */ long __RPC_FAR *pdx,
            /* [out] */ long __RPC_FAR *pdy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTLabelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTLabel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTLabel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFontHandle )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFontHandle )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ HFONT __RPC_FAR *phFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextString )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ LPCWSTR pString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTextString )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFillColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFillColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackgroundColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTexturePosition )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTexturePosition )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMatrix )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMatrix )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ const PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogfont )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ const LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogfont )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteWithRasterizer )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaselineOffset )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py,
            /* [out] */ long __RPC_FAR *pdx,
            /* [out] */ long __RPC_FAR *pdy);
        
        END_INTERFACE
    } IDXTLabelVtbl;

    interface IDXTLabel
    {
        CONST_VTBL struct IDXTLabelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTLabel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTLabel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTLabel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTLabel_SetFontHandle(This,hFont)	\
    (This)->lpVtbl -> SetFontHandle(This,hFont)

#define IDXTLabel_GetFontHandle(This,phFont)	\
    (This)->lpVtbl -> GetFontHandle(This,phFont)

#define IDXTLabel_SetTextString(This,pString)	\
    (This)->lpVtbl -> SetTextString(This,pString)

#define IDXTLabel_GetTextString(This,ppString)	\
    (This)->lpVtbl -> GetTextString(This,ppString)

#define IDXTLabel_GetFillColor(This,pVal)	\
    (This)->lpVtbl -> GetFillColor(This,pVal)

#define IDXTLabel_SetFillColor(This,newVal)	\
    (This)->lpVtbl -> SetFillColor(This,newVal)

#define IDXTLabel_GetBackgroundColor(This,pVal)	\
    (This)->lpVtbl -> GetBackgroundColor(This,pVal)

#define IDXTLabel_SetBackgroundColor(This,newVal)	\
    (This)->lpVtbl -> SetBackgroundColor(This,newVal)

#define IDXTLabel_GetTexturePosition(This,px,py)	\
    (This)->lpVtbl -> GetTexturePosition(This,px,py)

#define IDXTLabel_SetTexturePosition(This,x,y)	\
    (This)->lpVtbl -> SetTexturePosition(This,x,y)

#define IDXTLabel_GetMatrix(This,pXform)	\
    (This)->lpVtbl -> GetMatrix(This,pXform)

#define IDXTLabel_SetMatrix(This,pXform)	\
    (This)->lpVtbl -> SetMatrix(This,pXform)

#define IDXTLabel_SetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> SetLogfont(This,plf,dwFlags)

#define IDXTLabel_GetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> GetLogfont(This,plf,dwFlags)

#define IDXTLabel_ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)

#define IDXTLabel_GetBaselineOffset(This,px,py,pdx,pdy)	\
    (This)->lpVtbl -> GetBaselineOffset(This,px,py,pdx,pdy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTLabel_SetFontHandle_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ HFONT hFont);


void __RPC_STUB IDXTLabel_SetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFontHandle_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ HFONT __RPC_FAR *phFont);


void __RPC_STUB IDXTLabel_GetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTextString_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ LPCWSTR pString);


void __RPC_STUB IDXTLabel_SetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTextString_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppString);


void __RPC_STUB IDXTLabel_GetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFillColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pVal);


void __RPC_STUB IDXTLabel_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetFillColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBackgroundColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pVal);


void __RPC_STUB IDXTLabel_GetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetBackgroundColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTexturePosition_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py);


void __RPC_STUB IDXTLabel_GetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTexturePosition_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y);


void __RPC_STUB IDXTLabel_SetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetMatrix_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_GetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetMatrix_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ const PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_SetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetLogfont_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ const LOGFONT __RPC_FAR *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_SetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetLogfont_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ LOGFONT __RPC_FAR *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_GetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_ExecuteWithRasterizer_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement);


void __RPC_STUB IDXTLabel_ExecuteWithRasterizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBaselineOffset_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py,
    /* [out] */ long __RPC_FAR *pdx,
    /* [out] */ long __RPC_FAR *pdy);


void __RPC_STUB IDXTLabel_GetBaselineOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTLabel_INTERFACE_DEFINED__ */


#ifndef __IDX2DDebug_INTERFACE_DEFINED__
#define __IDX2DDebug_INTERFACE_DEFINED__

/* interface IDX2DDebug */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDX2DDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03BB2457-A279-11d1-81C6-0000F87557DB")
    IDX2DDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDC( 
            HDC hDC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDC( 
            HDC __RPC_FAR *phDC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDX2DDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDX2DDebug __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDX2DDebug __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDC )( 
            IDX2DDebug __RPC_FAR * This,
            HDC hDC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDC )( 
            IDX2DDebug __RPC_FAR * This,
            HDC __RPC_FAR *phDC);
        
        END_INTERFACE
    } IDX2DDebugVtbl;

    interface IDX2DDebug
    {
        CONST_VTBL struct IDX2DDebugVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2DDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2DDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2DDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2DDebug_SetDC(This,hDC)	\
    (This)->lpVtbl -> SetDC(This,hDC)

#define IDX2DDebug_GetDC(This,phDC)	\
    (This)->lpVtbl -> GetDC(This,phDC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2DDebug_SetDC_Proxy( 
    IDX2DDebug __RPC_FAR * This,
    HDC hDC);


void __RPC_STUB IDX2DDebug_SetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2DDebug_GetDC_Proxy( 
    IDX2DDebug __RPC_FAR * This,
    HDC __RPC_FAR *phDC);


void __RPC_STUB IDX2DDebug_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2DDebug_INTERFACE_DEFINED__ */


#ifndef __IDX2D_INTERFACE_DEFINED__
#define __IDX2D_INTERFACE_DEFINED__

/* interface IDX2D */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDX2D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EFD02A9-A996-11d1-81C9-0000F87557DB")
    IDX2D : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTransformFactory( 
            IDXTransformFactory __RPC_FAR *pTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformFactory( 
            IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            IUnknown __RPC_FAR *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipRect( 
            RECT __RPC_FAR *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipRect( 
            RECT __RPC_FAR *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorldTransform( 
            const DX2DXFORM __RPC_FAR *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorldTransform( 
            DX2DXFORM __RPC_FAR *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPen( 
            const DXPEN __RPC_FAR *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPen( 
            DXPEN __RPC_FAR *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrush( 
            const DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrush( 
            DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundBrush( 
            const DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundBrush( 
            DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFont( 
            HFONT __RPC_FAR *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Blt( 
            IUnknown __RPC_FAR *punkSrc,
            const RECT __RPC_FAR *pSrcRect,
            const POINT __RPC_FAR *pDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAPolyDraw( 
            const DXFPOINT __RPC_FAR *pPos,
            const BYTE __RPC_FAR *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAText( 
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradientBrush( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradientBrush( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDX2D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDX2D __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDX2D __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTransformFactory )( 
            IDX2D __RPC_FAR * This,
            IDXTransformFactory __RPC_FAR *pTransFact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransformFactory )( 
            IDX2D __RPC_FAR * This,
            IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDX2D __RPC_FAR * This,
            IUnknown __RPC_FAR *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDX2D __RPC_FAR * This,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClipRect )( 
            IDX2D __RPC_FAR * This,
            RECT __RPC_FAR *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClipRect )( 
            IDX2D __RPC_FAR * This,
            RECT __RPC_FAR *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWorldTransform )( 
            IDX2D __RPC_FAR * This,
            const DX2DXFORM __RPC_FAR *pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWorldTransform )( 
            IDX2D __RPC_FAR * This,
            DX2DXFORM __RPC_FAR *pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPen )( 
            IDX2D __RPC_FAR * This,
            const DXPEN __RPC_FAR *pPen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPen )( 
            IDX2D __RPC_FAR * This,
            DXPEN __RPC_FAR *pPen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBrush )( 
            IDX2D __RPC_FAR * This,
            const DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBrush )( 
            IDX2D __RPC_FAR * This,
            DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundBrush )( 
            IDX2D __RPC_FAR * This,
            const DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackgroundBrush )( 
            IDX2D __RPC_FAR * This,
            DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )( 
            IDX2D __RPC_FAR * This,
            HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            IDX2D __RPC_FAR * This,
            HFONT __RPC_FAR *phFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Blt )( 
            IDX2D __RPC_FAR * This,
            IUnknown __RPC_FAR *punkSrc,
            const RECT __RPC_FAR *pSrcRect,
            const POINT __RPC_FAR *pDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AAPolyDraw )( 
            IDX2D __RPC_FAR * This,
            const DXFPOINT __RPC_FAR *pPos,
            const BYTE __RPC_FAR *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AAText )( 
            IDX2D __RPC_FAR * This,
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRadialGradientBrush )( 
            IDX2D __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLinearGradientBrush )( 
            IDX2D __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDX2DVtbl;

    interface IDX2D
    {
        CONST_VTBL struct IDX2DVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2D_SetTransformFactory(This,pTransFact)	\
    (This)->lpVtbl -> SetTransformFactory(This,pTransFact)

#define IDX2D_GetTransformFactory(This,ppTransFact)	\
    (This)->lpVtbl -> GetTransformFactory(This,ppTransFact)

#define IDX2D_SetSurface(This,pSurface)	\
    (This)->lpVtbl -> SetSurface(This,pSurface)

#define IDX2D_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDX2D_SetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> SetClipRect(This,pClipRect)

#define IDX2D_GetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> GetClipRect(This,pClipRect)

#define IDX2D_SetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> SetWorldTransform(This,pXform)

#define IDX2D_GetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> GetWorldTransform(This,pXform)

#define IDX2D_SetPen(This,pPen)	\
    (This)->lpVtbl -> SetPen(This,pPen)

#define IDX2D_GetPen(This,pPen)	\
    (This)->lpVtbl -> GetPen(This,pPen)

#define IDX2D_SetBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBrush(This,pBrush)

#define IDX2D_GetBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBrush(This,pBrush)

#define IDX2D_SetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBackgroundBrush(This,pBrush)

#define IDX2D_GetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBackgroundBrush(This,pBrush)

#define IDX2D_SetFont(This,hFont)	\
    (This)->lpVtbl -> SetFont(This,hFont)

#define IDX2D_GetFont(This,phFont)	\
    (This)->lpVtbl -> GetFont(This,phFont)

#define IDX2D_Blt(This,punkSrc,pSrcRect,pDest)	\
    (This)->lpVtbl -> Blt(This,punkSrc,pSrcRect,pDest)

#define IDX2D_AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)	\
    (This)->lpVtbl -> AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)

#define IDX2D_AAText(This,Pos,pString,ulCount,dwFlags)	\
    (This)->lpVtbl -> AAText(This,Pos,pString,ulCount,dwFlags)

#define IDX2D_SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDX2D_SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2D_SetTransformFactory_Proxy( 
    IDX2D __RPC_FAR * This,
    IDXTransformFactory __RPC_FAR *pTransFact);


void __RPC_STUB IDX2D_SetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetTransformFactory_Proxy( 
    IDX2D __RPC_FAR * This,
    IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact);


void __RPC_STUB IDX2D_GetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetSurface_Proxy( 
    IDX2D __RPC_FAR * This,
    IUnknown __RPC_FAR *pSurface);


void __RPC_STUB IDX2D_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetSurface_Proxy( 
    IDX2D __RPC_FAR * This,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDX2D_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetClipRect_Proxy( 
    IDX2D __RPC_FAR * This,
    RECT __RPC_FAR *pClipRect);


void __RPC_STUB IDX2D_SetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetClipRect_Proxy( 
    IDX2D __RPC_FAR * This,
    RECT __RPC_FAR *pClipRect);


void __RPC_STUB IDX2D_GetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetWorldTransform_Proxy( 
    IDX2D __RPC_FAR * This,
    const DX2DXFORM __RPC_FAR *pXform);


void __RPC_STUB IDX2D_SetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetWorldTransform_Proxy( 
    IDX2D __RPC_FAR * This,
    DX2DXFORM __RPC_FAR *pXform);


void __RPC_STUB IDX2D_GetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetPen_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXPEN __RPC_FAR *pPen);


void __RPC_STUB IDX2D_SetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetPen_Proxy( 
    IDX2D __RPC_FAR * This,
    DXPEN __RPC_FAR *pPen);


void __RPC_STUB IDX2D_GetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_SetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_GetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBackgroundBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_SetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBackgroundBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_GetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetFont_Proxy( 
    IDX2D __RPC_FAR * This,
    HFONT hFont);


void __RPC_STUB IDX2D_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetFont_Proxy( 
    IDX2D __RPC_FAR * This,
    HFONT __RPC_FAR *phFont);


void __RPC_STUB IDX2D_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_Blt_Proxy( 
    IDX2D __RPC_FAR * This,
    IUnknown __RPC_FAR *punkSrc,
    const RECT __RPC_FAR *pSrcRect,
    const POINT __RPC_FAR *pDest);


void __RPC_STUB IDX2D_Blt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAPolyDraw_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXFPOINT __RPC_FAR *pPos,
    const BYTE __RPC_FAR *pTypes,
    ULONG ulCount,
    ULONG SubSampRes,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAPolyDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAText_Proxy( 
    IDX2D __RPC_FAR * This,
    DXFPOINT Pos,
    LPWSTR pString,
    ULONG ulCount,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetRadialGradientBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetRadialGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetLinearGradientBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetLinearGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2D_INTERFACE_DEFINED__ */


#ifndef __IDXGradient2_INTERFACE_DEFINED__
#define __IDXGradient2_INTERFACE_DEFINED__

/* interface IDXGradient2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0ef2a80-61dc-11d2-b2eb-00a0c936b212")
    IDXGradient2 : public IDXGradient
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradient( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradient( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradient2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXGradient2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXGradient2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXGradient2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXGradient2 __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGradient )( 
            IDXGradient2 __RPC_FAR * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSize )( 
            IDXGradient2 __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *pOutSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRadialGradient )( 
            IDXGradient2 __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLinearGradient )( 
            IDXGradient2 __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXGradient2Vtbl;

    interface IDXGradient2
    {
        CONST_VTBL struct IDXGradient2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient2_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient2_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient2_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)


#define IDXGradient2_SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDXGradient2_SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient2_SetRadialGradient_Proxy( 
    IDXGradient2 __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetRadialGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient2_SetLinearGradient_Proxy( 
    IDXGradient2 __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetLinearGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0282 */
/* [local] */ 

typedef 
enum DXFILTERTYPE
    {	DXFILTER_NEAREST	= 0,
	DXFILTER_BILINEAR	= DXFILTER_NEAREST + 1,
	DXFILTER_CUBIC	= DXFILTER_BILINEAR + 1,
	DXFILTER_BSPLINE	= DXFILTER_CUBIC + 1,
	DXFILTER_NUM_FILTERS	= DXFILTER_BSPLINE + 1
    }	DXFILTERTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0282_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0282_v0_0_s_ifspec;

#ifndef __IDXWarp_INTERFACE_DEFINED__
#define __IDXWarp_INTERFACE_DEFINED__

/* interface IDXWarp */
/* [object][hidden][unique][uuid] */ 


EXTERN_C const IID IID_IDXWarp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B7BCEBE0-6797-11d2-A484-00C04F8EFB69")
    IDXWarp : public IDXTScaleOutput
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFilterType( 
            /* [in] */ DXFILTERTYPE eType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterType( 
            /* [out] */ DXFILTERTYPE __RPC_FAR *peType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMapping( 
            /* [in] */ const DX2DXFORM __RPC_FAR *pXForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMapping( 
            /* [out] */ DX2DXFORM __RPC_FAR *pXForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSurface( 
            /* [in] */ IDXSurface __RPC_FAR *pSurf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultColor( 
            /* [in] */ DXSAMPLE color) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXWarpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXWarp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXWarp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFilterType )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ DXFILTERTYPE eType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilterType )( 
            IDXWarp __RPC_FAR * This,
            /* [out] */ DXFILTERTYPE __RPC_FAR *peType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMapping )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ const DX2DXFORM __RPC_FAR *pXForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMapping )( 
            IDXWarp __RPC_FAR * This,
            /* [out] */ DX2DXFORM __RPC_FAR *pXForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputSurface )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSurf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultColor )( 
            IDXWarp __RPC_FAR * This,
            /* [in] */ DXSAMPLE color);
        
        END_INTERFACE
    } IDXWarpVtbl;

    interface IDXWarp
    {
        CONST_VTBL struct IDXWarpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXWarp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXWarp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXWarp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXWarp_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXWarp_SetFilterType(This,eType)	\
    (This)->lpVtbl -> SetFilterType(This,eType)

#define IDXWarp_GetFilterType(This,peType)	\
    (This)->lpVtbl -> GetFilterType(This,peType)

#define IDXWarp_SetMapping(This,pXForm)	\
    (This)->lpVtbl -> SetMapping(This,pXForm)

#define IDXWarp_GetMapping(This,pXForm)	\
    (This)->lpVtbl -> GetMapping(This,pXForm)

#define IDXWarp_SetInputSurface(This,pSurf)	\
    (This)->lpVtbl -> SetInputSurface(This,pSurf)

#define IDXWarp_SetDefaultColor(This,color)	\
    (This)->lpVtbl -> SetDefaultColor(This,color)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXWarp_SetFilterType_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [in] */ DXFILTERTYPE eType);


void __RPC_STUB IDXWarp_SetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_GetFilterType_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [out] */ DXFILTERTYPE __RPC_FAR *peType);


void __RPC_STUB IDXWarp_GetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_SetMapping_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [in] */ const DX2DXFORM __RPC_FAR *pXForm);


void __RPC_STUB IDXWarp_SetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_GetMapping_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [out] */ DX2DXFORM __RPC_FAR *pXForm);


void __RPC_STUB IDXWarp_GetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_SetInputSurface_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSurf);


void __RPC_STUB IDXWarp_SetInputSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXWarp_SetDefaultColor_Proxy( 
    IDXWarp __RPC_FAR * This,
    /* [in] */ DXSAMPLE color);


void __RPC_STUB IDXWarp_SetDefaultColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXWarp_INTERFACE_DEFINED__ */


#ifndef __IDXTClipOrigin_INTERFACE_DEFINED__
#define __IDXTClipOrigin_INTERFACE_DEFINED__

/* interface IDXTClipOrigin */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTClipOrigin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE1663D8-0988-4C48-9FD6-DB4450885668")
    IDXTClipOrigin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClipOrigin( 
            DXVEC __RPC_FAR *pvecClipOrigin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTClipOriginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTClipOrigin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTClipOrigin __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTClipOrigin __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClipOrigin )( 
            IDXTClipOrigin __RPC_FAR * This,
            DXVEC __RPC_FAR *pvecClipOrigin);
        
        END_INTERFACE
    } IDXTClipOriginVtbl;

    interface IDXTClipOrigin
    {
        CONST_VTBL struct IDXTClipOriginVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTClipOrigin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTClipOrigin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTClipOrigin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTClipOrigin_GetClipOrigin(This,pvecClipOrigin)	\
    (This)->lpVtbl -> GetClipOrigin(This,pvecClipOrigin)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTClipOrigin_GetClipOrigin_Proxy( 
    IDXTClipOrigin __RPC_FAR * This,
    DXVEC __RPC_FAR *pvecClipOrigin);


void __RPC_STUB IDXTClipOrigin_GetClipOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTClipOrigin_INTERFACE_DEFINED__ */



#ifndef __DXTRANSPLib_LIBRARY_DEFINED__
#define __DXTRANSPLib_LIBRARY_DEFINED__

/* library DXTRANSPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTRANSPLib;

EXTERN_C const CLSID CLSID_DXWarp;

#ifdef __cplusplus

class DECLSPEC_UUID("E0EEC500-6798-11d2-A484-00C04F8EFB69")
DXWarp;
#endif

EXTERN_C const CLSID CLSID_DXTLabel;

#ifdef __cplusplus

class DECLSPEC_UUID("54702535-2606-11D1-999C-0000F8756A10")
DXTLabel;
#endif

EXTERN_C const CLSID CLSID_DXRasterizer;

#ifdef __cplusplus

class DECLSPEC_UUID("8652CE55-9E80-11D1-9053-00C04FD9189D")
DXRasterizer;
#endif

EXTERN_C const CLSID CLSID_DX2D;

#ifdef __cplusplus

class DECLSPEC_UUID("473AA80B-4577-11D1-81A8-0000F87557DB")
DX2D;
#endif
#endif /* __DXTRANSPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HFONT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
void                      __RPC_USER  HFONT_UserFree(     unsigned long __RPC_FAR *, HFONT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\ddhelper.h ===
#ifndef _DDHelper_h
#define _DDHelper_h

// File:	DDHelper.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//    These are some useful helper functions for sanitizing interactions
//  with DirectDraw
// 
// History:
// -@- 03/06/97 (mikemarr) created
// -@- 10/07/97 (mikemarr) snarfed from \d2d\mmimage\include
// -@- 10/07/97 (mikemarr) trimmed
// -@- 10/14/97 (mikemarr) added arrays for pixel format mgmt
// -@- 10/28/97 (mikemarr) added PixelOffset macro
// -@- 10/28/97 (mikemarr) added GetColor function

#ifndef __DDRAW_INCLUDED__
#include <ddraw.h>
#endif

#ifndef _PixInfo_h
#include "PixInfo.h"
#endif

#ifndef _Point_h
#include "Point.h"
#endif

typedef enum {
	iPF_NULL = 0, iPF_Palette1, iPF_Palette2, iPF_Palette4, iPF_Palette8,
	iPF_RGB332, iPF_ARGB4444, iPF_RGB565, iPF_BGR565, iPF_RGB555,
	iPF_ARGB5551, iPF_RGB24, iPF_BGR24, iPF_RGB32, iPF_BGR32,
	iPF_ARGB, iPF_ABGR, iPF_RGBTRIPLE, iPF_RGBQUAD, iPF_PALETTEENTRY,
	iPF_Total
} PixelFormatIndex;

extern const DDPIXELFORMAT g_rgDDPF[iPF_Total];
DWORD	GetPixelFormat(const DDPIXELFORMAT &ddpf);

extern const CPixelInfo g_rgPIXI[iPF_Total];
DWORD	GetPixelFormat(const CPixelInfo &pixi);

/*
extern const GUID g_rgDDPFGUID[iPF_Total];
DWORD	GetPixelFormat(const GUID &guid);
*/

extern const PALETTEENTRY g_peZero;

inline BOOL 
operator==(const DDPIXELFORMAT &ddpf1, const DDPIXELFORMAT &ddpf2)
{
	return (ddpf1.dwRGBBitCount == ddpf2.dwRGBBitCount) &&
		(ddpf1.dwRBitMask == ddpf2.dwRBitMask) && 
		(ddpf1.dwGBitMask == ddpf2.dwGBitMask) && 
		(ddpf1.dwBBitMask == ddpf2.dwBBitMask) && 
		(ddpf1.dwRGBAlphaBitMask == ddpf2.dwRGBAlphaBitMask) &&
		(ddpf1.dwFlags == ddpf2.dwFlags);
}

#define AllFieldsDefined(dxstruct, flags) (((dxstruct).dwFlags & (flags)) == (flags))
#define AnyFieldsDefined(dxstruct, flags) (((dxstruct).dwFlags & (flags)) != 0)

extern DWORD g_rgdwBPPToPalFlags[9];
extern DWORD g_rgdwBPPToPixFlags[9];

inline DWORD
BPPToPaletteFlags(DWORD nBPP)
{
	return (nBPP <= 8 ? g_rgdwBPPToPalFlags[nBPP] : 0);
}

inline DWORD
BPPToPixelFlags(DWORD nBPP)
{
	return (nBPP <= 8 ? g_rgdwBPPToPixFlags[nBPP] : 0);
}

DWORD		PaletteToPixelFlags(DWORD dwPaletteFlags);
DWORD		PixelToPaletteFlags(DWORD dwPaletteFlags);
BYTE		PixelFlagsToBPP(DWORD dwFlags);
BYTE		PaletteFlagsToBPP(DWORD dwFlags);

HRESULT		CreatePlainSurface(IDirectDraw *pDD, DWORD nWidth, DWORD nHeight, 
				const DDPIXELFORMAT &ddpf, IDirectDrawPalette *pddp,
				DWORD dwTransColor, bool bTransparent,
				IDirectDrawSurface **ppdds);

inline
HRESULT		CreatePlainSurface(IDirectDraw *pDD, DWORD nWidth, DWORD nHeight, 
				const CPixelInfo &pixiPixFmt, IDirectDrawPalette *pddp,
				DWORD dwTransColor, bool bTransparent,
				IDirectDrawSurface **ppdds)
{
	DDPIXELFORMAT ddpf;
	pixiPixFmt.GetDDPF(ddpf);

	return CreatePlainSurface(pDD, nWidth, nHeight, ddpf, 
		pddp, dwTransColor, bTransparent, ppdds);
}

HRESULT		CreatePalette(IDirectDraw *pDD, const BYTE *pPalette, DWORD cEntries, 
				BYTE nBPPTarget, const CPixelInfo &pixiPalFmt, 
				IDirectDrawPalette **ppddp);

// Notes: luminance ~= (77r + 151g + 28b)/256
#define nREDWEIGHT 77
#define nGREENWEIGHT 151
#define nBLUEWEIGHT 28

#define nMAXPALETTEENTRIES 256

HRESULT		ClearToColor(LPRECT prDst, LPDIRECTDRAWSURFACE pdds, DWORD dwColor);

DWORD		SimpleFindClosestIndex(const PALETTEENTRY *rgpePalette, DWORD cEntries, 
				const PALETTEENTRY &peQuery);

HRESULT		GetColors(LPDIRECTDRAWSURFACE pdds, const PALETTEENTRY *rgpeQuery, DWORD cEntries,
				LPDWORD pdwColors);

HRESULT		CreateSurfaceWithText(LPDIRECTDRAW pDD, LPDIRECTDRAWPALETTE pddp, 
				DWORD iTransp, const char *szText, HFONT hFont, BOOL bShadowed,
				SIZE *psiz, LPDIRECTDRAWSURFACE *ppdds);

HRESULT		CreatePlainDIBSection(HDC hDC, DWORD nWidth, DWORD nHeight, DWORD nBPP, 
				const PALETTEENTRY *rgpePalette, HBITMAP *phbm, LPBYTE *ppPixels);

HRESULT		GetSurfaceDimensions(LPDIRECTDRAWSURFACE pdds, LPRECT prDimensions);

HRESULT		CreatePaletteFromSystem(HDC hDC, IDirectDraw *pDD, 
				IDirectDrawPalette **ppddp);


// Robust Drawing Routines
HRESULT		DrawPoints(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch, DWORD nBytesPerPixel, 
				const Point2 *rgpnt, DWORD cPoints, 
				DWORD dwColor, DWORD nRadius);

HRESULT		DrawBox(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
				DWORD nBytesPerPixel, const RECT &r, DWORD dwColor, DWORD nThickness);

HRESULT		DrawFilledBox(LPBYTE pPixels, DWORD nWidth, DWORD nHeight, DWORD nPitch,
				DWORD nBytesPerPixel, const RECT &r, DWORD dwColor);

inline HRESULT
DrawPoints(DDSURFACEDESC &ddsd,	const Point2 *rgpnt, DWORD cPoints, 
		   DWORD dwColor, DWORD nRadius) 
{
	return DrawPoints((LPBYTE) ddsd.lpSurface, ddsd.dwWidth, ddsd.dwHeight, 
			(DWORD) ddsd.lPitch, (ddsd.ddpfPixelFormat.dwRGBBitCount + 7) >> 3,
			rgpnt, cPoints, dwColor, nRadius);
}

inline HRESULT
DrawBox(DDSURFACEDESC &ddsd, const RECT &r, DWORD dwColor, DWORD nThickness)
{
	return DrawBox((LPBYTE) ddsd.lpSurface, ddsd.dwWidth, ddsd.dwHeight, 
			(DWORD) ddsd.lPitch, (ddsd.ddpfPixelFormat.dwRGBBitCount + 7) >> 3,
			r, dwColor, nThickness);
}

inline HRESULT
DrawFilledBox(DDSURFACEDESC &ddsd, const RECT &r, DWORD dwColor)
{
	return DrawFilledBox((LPBYTE) ddsd.lpSurface, ddsd.dwWidth, ddsd.dwHeight, 
			(DWORD) ddsd.lPitch, (ddsd.ddpfPixelFormat.dwRGBBitCount + 7) >> 3,
			r, dwColor);
}

#define PixelOffset(_nX, _nY, _nPitch, _cBytesPerPixel) ((_nPitch * _nY) + (_cBytesPerPixel * _nX))

//
// RECT functions
//

// Function: ClipRect
//    Returns TRUE for a non-trivial intersection.
bool		ClipRect(const RECT &rTarget, RECT &rSrc);
bool		ClipRect(long nWidth, long nHeight, LPRECT prSrc);

// Function: IsInside
//    Returns true if the given point is inside the rectangle
inline bool
IsInside(long nX, long nY, const RECT &r)
{
	return ((nX >= r.left) && (nX < r.right) && (nY >= r.top) && (nY < r.bottom));
}

inline bool
IsInside(long nX, long nY, const SIZE &siz)
{
	return ((nX >= 0) && (nX < siz.cx) && (nY >= 0) && (nY < siz.cy));
}

inline bool
IsFullSize(DWORD nWidth, DWORD nHeight, const RECT &r)
{
	return ((r.right == (long) nWidth) && (r.bottom == (long) nHeight) &&
			(r.left == 0) && (r.top == 0));
}

inline bool
IsSameSize(DWORD nWidth, DWORD nHeight, const RECT &r)
{
	return ((r.right - r.left) == (long) nWidth) && 
		((r.bottom - r.top) == (long) nHeight);
}

inline bool
IsSameSize(const RECT &r1, const RECT &r2)
{
	return ((r1.right - r1.left) == (r2.right - r2.left)) &&
		((r1.bottom - r1.top) == (r2.bottom - r2.top));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__7CA4916A_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_MAINFRM_H__7CA4916A_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__7CA4916A_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "simpsons.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here

}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\guids.c ===
#include <objbase.h>
#include <initguid.h>
#include <DDrawEx.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\mdmutils.cpp ===
// File:	MMUtils.cpp
// Author:	Michael Marr    (mikemarr)
//
// History:
// -@- 04/12/96 (mikemarr) - created
// -@- 11/07/96 (mikemarr) - combined debug stuff
// -@- 09/09/97 (mikemarr) - snarfed from d2d\d2dutils\src\mmutils.cpp
// -@- 09/09/97 (mikemarr) - will only create code when in debug mode
// -@- 11/12/97 (mikemarr) - added CopyDWORDAligned

#include "stdafx.h"
#ifndef _MDMUtils_h
#include "MDMUtils.h"
#endif

char g_rgchTmpBuf[nTMPBUFSIZE];
char g_szEOFMessage[] = "unexpected EOF\n";

void
ZeroDWORDAligned(LPDWORD pdw, DWORD cEntries)
{
	// verify alignment
	MMASSERT(pdw && ((DWORD(pdw) & 0x3) == 0));
	LPDWORD pdwLimit = pdw + cEntries;
	// REVIEW: use Duff-Marr machine
	for (; pdw != pdwLimit; *pdw++ = 0);
}

void
CopyDWORDAligned(DWORD *pdwDst, const DWORD *pdwSrc, DWORD cEntries)
{
	// verify alignment
	MMASSERT(pdwSrc && pdwDst && ((DWORD(pdwSrc) & 0x3) == 0));
	LPDWORD pdwLimit = pdwDst + cEntries;
	// REVIEW: use Duff-Marr machine
	for (; pdwDst != pdwLimit; *pdwDst++ = *pdwSrc++);
}



DWORD
GetClosestMultipleOf4(DWORD n, bool bGreater)
{
	return (n + bGreater * 3) & ~3;
}


DWORD
GetClosestPowerOf2(DWORD n, bool bGreater)
{
	DWORD i = 0;
	for (n >>= 1; n != 0; i++) {
		n >>= 1;
	}
	i += (bGreater && ((n & ~(1 << i)) != 0));

	return (1 << i);
}


//
// Debug Stuff
//
#ifdef _DEBUG
void _MMStall(const char *szExp, const char *szFile, int nLine) {
	sprintf(g_rgchTmpBuf, "error: (%s) in %s at line %d\n", szExp, szFile, nLine);

#ifdef _WINDOWS
	OutputDebugString(g_rgchTmpBuf);
#endif
	fprintf(stderr, "%s", g_rgchTmpBuf);

	// hardcode breakpoint
#if defined(_DEBUG) && defined(_X86_)
	_asm { int 3 };
#else
	exit(1);
#endif
}

void _MMTrace(const char *szFmt, ...)
{
#ifndef _NOT_X86
	_vsnprintf(g_rgchTmpBuf, nTMPBUFSIZE - 1, szFmt, (va_list) (&szFmt+1));

#if defined(_WINDOWS) && defined(_DEBUG)
	OutputDebugString(g_rgchTmpBuf);
#else
	fprintf(stderr, "%s", g_rgchTmpBuf);
#endif
#endif // _NOT_X86
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\palmap.cpp ===
// File:    PalMap.cpp
// Author:  Michael Marr    (mikemarr)
//
// History:
// -@- 09/23/97 (mikemarr) copied to DXCConv from d2d\mmimage

#include "stdafx.h"
#include "PalMap.h"
#include "Blt.h"
#include "ddhelper.h"

char gs_szPMPrefix[] = "palette map error";


CPaletteMap::CPaletteMap()
{
    m_rgIndexMap = NULL;
    m_nConvertCode = cvcInvalid;
    m_cSrcBPP = m_cDstBPP = 0;
    m_bIdentity = FALSE;
}

CPaletteMap::~CPaletteMap()
{
    MMDELETE(m_rgIndexMap);
}

// Function: CreateMap
//    This function creates a new mapping from a src palette to a destination color model.
HRESULT
CPaletteMap::CreateMap(BYTE nBPPSrcPixels, BYTE nBPPSrcPalette, LPPALETTEENTRY rgpeSrc, 
                       const CPixelInfo &pixiDst, LPDIRECTDRAWPALETTE pddpDst)
{
    MMTRACE("CPaletteMap::CreateMap\n");
    HRESULT hr;
    PALETTEENTRY rgpeDst[256];
    DWORD dwDstCaps;

    // verify arguments
    if (rgpeSrc == NULL)
        return E_INVALIDARG;

    // delete the old index map, if it exists
    MMDELETE(m_rgIndexMap);

    // store the bit depths for mapping verification
    // REVIEW: perhaps the maps should be created with at least 256 entries always
    m_cSrcBPP = nBPPSrcPixels;
    m_cDstBPP = pixiDst.nBPP;

    // figure out what kind of conversion we are doing
    if ((m_nConvertCode = static_cast<BYTE>(GetConvertCode(m_cSrcBPP, m_cDstBPP))) == cvcInvalid) {
        MMTRACE("%s: can't convert from %d bit to %d bit\n", 
            gs_szPMPrefix, (int) m_cSrcBPP, (int) m_cDstBPP);
        return E_INVALIDARG;
    }

    if (pddpDst == NULL) {
        // destination is RGB
        switch (m_cDstBPP) {
        case 16: return DoPalTo16BitMap(nBPPSrcPalette, pixiDst, rgpeSrc); break;
        case 24: return DoPalTo24BitMap(nBPPSrcPalette, pixiDst, rgpeSrc); break;
        case 32: return DoPalTo32BitMap(nBPPSrcPalette, pixiDst, rgpeSrc); break;
        default:
            return E_INVALIDARG;
            break;
        }
    } else {
        // destination is 8 bit palettized
        hr = E_INVALIDARG;
        if ((m_cDstBPP != 8) ||
            // get the caps
            FAILED(pddpDst->GetCaps(&dwDstCaps)) ||
            // verify we have True Color entries
            (dwDstCaps & DDPCAPS_8BITENTRIES) ||
            // make sure the number of palette entries from the caps is 8 bits
            (!(dwDstCaps & DDPCAPS_8BIT)) ||
            // get the palette entries
            FAILED(hr = pddpDst->GetEntries(0, 0, 1 << m_cDstBPP, rgpeDst)))
        {
            MMTRACE("%s: invalid dst palette for map\n", gs_szPMPrefix);
            return hr;
        }
        // create map for palette to palette
        return DoPalToPalMap(nBPPSrcPalette, m_cDstBPP, rgpeSrc, rgpeDst);
    }
}


HRESULT
CPaletteMap::CreateMap(LPDIRECTDRAWPALETTE pddpSrc, const CPixelInfo &pixiDst, 
                       LPDIRECTDRAWPALETTE pddpDst)
{
//  MMTRACE("CPaletteMap::CreateMap\n");
    PALETTEENTRY rgpeSrc[256];
    BYTE nBPPSrc;
    DWORD dwSrcCaps;

    // sanitize the src palette and get the srcBPP
    HRESULT hr = E_INVALIDARG;
    if ((pddpSrc == NULL) ||
        // get the caps
        FAILED(pddpSrc->GetCaps(&dwSrcCaps)) ||
        // verify we have True Color entries
        (dwSrcCaps & DDPCAPS_8BITENTRIES) ||
        // get the number of palette entries from the caps
        ((nBPPSrc = BYTE(PaletteFlagsToBPP(dwSrcCaps))) == 0) ||
        // get the palette entries
        FAILED(hr = pddpSrc->GetEntries(0, 0, (1 << nBPPSrc), rgpeSrc)))
    {
        MMTRACE("%s: invalid src palette for map\n", gs_szPMPrefix);
        return hr;
    }

    return CreateMap(nBPPSrc, nBPPSrc, rgpeSrc, pixiDst, pddpDst);
}


/*
HRESULT
CPaletteMap::CreateSortedMap(BYTE nBPP, const RGB *rgrgbSrc, BYTE nBPPUsed, DWORD iTransColor, 
                             DWORD dwFlags, LPPALETTEENTRY rgpeDst)
{
    MMTRACE("CPaletteMap::CreateSortedMap\n");
    MMASSERT(nBPP <= nBPPUsed);
    DWORD i, j, imin;

    if ((rgrgbSrc == NULL) || (nBPPUsed > 8))
        return E_INVALIDARG;

    struct {
        DWORD   nPos;
        int     nLuminance;
    } rgSortMap[nMAXPALETTEENTRIES], minLuminance;

    // allocate the index map
    MMDELETE(m_rgIndexMap);

    m_rgIndexMap = (BYTE *) new BYTE[1 << nBPPUsed];
    if (m_rgIndexMap == NULL)
        return E_OUTOFMEMORY;

    m_nConvertCode = GetConvertCode(nBPPUsed, nBPPUsed);
    MMASSERT(m_nConvertCode == cvc8To8);
    m_cSrcBPP = nBPPUsed;
    m_cDstBPP = nBPPUsed;
//  m_pixiDst.Init(nBPPUsed);

    // initialize the sort map (compute luminance values)
    DWORD cMapLength = (1 << nBPP), cTotalEntries = (1 << nBPPUsed);
    for (i = 0; i < cMapLength; i++) {
        const RGB &rgbTmp = rgrgbSrc[i];
        rgSortMap[i].nPos = i;
        rgSortMap[i].nLuminance = nREDWEIGHT * rgbTmp.r + nGREENWEIGHT * rgbTmp.g + 
            nBLUEWEIGHT * rgbTmp.b;
    }

    // if transparency exists, change its luminance to -1 so it will
    // become the zeroth index
    if (dwFlags & flagTRANSPARENT) {
        if (iTransColor > cMapLength)
            return E_INVALIDARG;
        rgSortMap[iTransColor].nLuminance = -1;
    }

    // sort the entries by luminance
    // REVIEW: use naive insertion sort for now
    for (i = 0; i < cMapLength; i++) {
        imin = i;
        minLuminance = rgSortMap[imin];

        for (j = i + 1; j < cMapLength; j++) {
            if (minLuminance.nLuminance > rgSortMap[j].nLuminance) {
                imin = j;
                minLuminance = rgSortMap[imin];
            }
        }
        rgSortMap[imin] = rgSortMap[i];
        rgSortMap[i] = minLuminance;
    }

    // fill in the index map (sorting generates an "inverse" map)
    for (i = 0; i < cMapLength; i++) {
        m_rgIndexMap[rgSortMap[i].nPos] = (BYTE) i;
    }
    for (; i < cTotalEntries; i++)
        m_rgIndexMap[i] = (BYTE) i;


    // sort to a palette entry array based on this mapping
    if (rgpeDst) {
        for (i = 0; i < cMapLength; i++) {
            PALETTEENTRY &pe = rgpeDst[i];
            const RGB &rgb = rgrgbSrc[rgSortMap[i].nPos];
            pe.peRed = rgb.r; pe.peGreen = rgb.g; pe.peBlue = rgb.b; pe.peFlags = 0;
        }
        PALETTEENTRY peZero = {0, 0, 0, 0};
        for (; i < cTotalEntries; i++)
            rgpeDst[i] = peZero;
    }

    return S_OK;
}
*/

HRESULT
CPaletteMap::DoPalTo16BitMap(BYTE cSrcBPP, const CPixelInfo &pixiDst, const PALETTEENTRY *ppeSrc)
{
    MMASSERT(ppeSrc);

    DWORD cEntries = (1 << cSrcBPP);
    MapEntry16 *pIndexMap = new MapEntry16[cEntries];
    if (pIndexMap == NULL)
        return E_OUTOFMEMORY;

    for (DWORD i = 0; i < cEntries; i++) {
        pIndexMap[i] = pixiDst.Pack16(ppeSrc[i]);
    }

    m_rgIndexMap = (BYTE *) pIndexMap;
    return S_OK;
}


HRESULT
CPaletteMap::DoPalTo24BitMap(BYTE cSrcBPP, const CPixelInfo &pixiDst, const PALETTEENTRY *ppeSrc)
{
    MMASSERT(ppeSrc);

    if ((pixiDst.nRedResidual | pixiDst.nGreenResidual | pixiDst.nBlueResidual) != 0)
        return DDERR_INVALIDPIXELFORMAT;

    DWORD cEntries = (1 << cSrcBPP);
    MapEntry24 *pIndexMap = new MapEntry24[cEntries];
    if (pIndexMap == NULL)
        return E_OUTOFMEMORY;

    for (DWORD i = 0; i < cEntries; i++) {
        pIndexMap[i] = pixiDst.Pack(ppeSrc[i]);
    }

    m_rgIndexMap = (BYTE *) pIndexMap;
    return S_OK;
}


HRESULT
CPaletteMap::DoPalTo32BitMap(BYTE cSrcBPP, const CPixelInfo &pixiDst, const PALETTEENTRY *ppeSrc)
{
    // REVIEW: since PALETTEENTRY does not have an alpha field, 
    //  this should be the same as 24 bit
    return DoPalTo24BitMap(cSrcBPP, pixiDst, ppeSrc);
}

// blue is assumed to have a weight of 1.f
#define fSimpleRedWeight 2.1f
#define fSimpleGreenWeight 2.4f
#define fMaxColorDistance ((1.f + fSimpleRedWeight + fSimpleGreenWeight) * float(257 * 256))

static inline float
_ColorDistance(const PALETTEENTRY &pe, BYTE r, BYTE g, BYTE b)
{
    float fTotal, fTmpR, fTmpG, fTmpB;
    fTmpR = (float) (pe.peRed - r);
    fTotal = fSimpleRedWeight * fTmpR * fTmpR;
    fTmpG = (float) (pe.peGreen - g);
    fTotal += fSimpleGreenWeight * fTmpG * fTmpG;
    fTmpB = (float) (pe.peBlue - b);
    // blue is assumed to have a weight of 1.f
    fTotal += fTmpB * fTmpB;

    return fTotal;
}

DWORD
_SimpleFindClosestIndex(const PALETTEENTRY *rgpePalette, DWORD cEntries, BYTE r, BYTE g, BYTE b)
{
    MMASSERT(rgpePalette);
    MMASSERT(cEntries <= nMAXPALETTEENTRIES);

    float fTmp, fMinDistance = fMaxColorDistance;
    DWORD nMinIndex = cEntries;

    for (DWORD i = 0; i < cEntries; i++) {
        const PALETTEENTRY &peTmp = rgpePalette[i];
        if (!(peTmp.peFlags & (PC_RESERVED | PC_EXPLICIT))) {
            if ((fTmp = _ColorDistance(peTmp, r, g, b)) < fMinDistance) {
                // check for exact match
                if (fTmp == 0.f)
                    return i;
                nMinIndex = i;
                fMinDistance = fTmp;
            }
        }
    }
    MMASSERT(nMinIndex < cEntries);
    return nMinIndex;
}


// Function: DoPalToPalMap
//    Compute a mapping from one palette to another and store in the palette map.
HRESULT
CPaletteMap::DoPalToPalMap(BYTE cSrcBPP, BYTE cDstBPP, const PALETTEENTRY *ppeSrc, 
                           const PALETTEENTRY *ppeDst)
{
    MMASSERT(ppeSrc && ppeDst);

    DWORD cSrcEntries = (1 << cSrcBPP), cDstEntries = (1 << cDstBPP);
    m_rgIndexMap = new BYTE[cSrcEntries];
    if (m_rgIndexMap == NULL)
        return E_OUTOFMEMORY;
    for (DWORD i = 0; i < cSrcEntries; i++) {
        const PALETTEENTRY &pe = ppeSrc[i];
        m_rgIndexMap[i] = (BYTE) _SimpleFindClosestIndex(ppeDst, cDstEntries, 
                                    pe.peRed, pe.peGreen, pe.peBlue);
    }

    return S_OK;
}


// Function: GetConvertCode
//    This function computes the index into the function arrays for
//  mapping and color conversion.
int
CPaletteMap::GetConvertCode(DWORD nSrcBPP, DWORD nDstBPP)
{
    int nCode;

    if ((nDstBPP < 8) || (nSrcBPP > 8) || (nSrcBPP < 4)) {
        nCode = cvcInvalid;
    } else {
        nCode = (((nSrcBPP >> 2) - 1) << 2) | ((nDstBPP >> 3) - 1);
    }
    return nCode;   
}


static DWORD
GetColor8To8(DWORD dwSrcColor, const BYTE *pIndexMap)
{
    MMASSERT(dwSrcColor < 256);
    return (DWORD) pIndexMap[dwSrcColor];
}

static DWORD
GetColor8To16(DWORD dwSrcColor, const BYTE *pIndexMap)
{
    MMASSERT(dwSrcColor < 256);
    MapEntry16 *pIndexMap16 = (MapEntry16 *) pIndexMap;
    return (DWORD) pIndexMap16[dwSrcColor];
}

static DWORD
GetColor8To24(DWORD dwSrcColor, const BYTE *pIndexMap)
{
    MMASSERT(dwSrcColor < 256);
    MapEntry24 *pIndexMap24 = (MapEntry24 *) pIndexMap;
    return (DWORD) pIndexMap24[dwSrcColor];
}

static DWORD
GetColor8To32(DWORD dwSrcColor, const BYTE *pIndexMap)
{
    MMASSERT(dwSrcColor < 256);
    MapEntry32 *pIndexMap32 = (MapEntry32 *) pIndexMap;
    return (DWORD) pIndexMap32[dwSrcColor];
}

static GetColorFunction gs_rgGetColorFunctions[cvcNumCodes] = {
    NULL, NULL, NULL, NULL,
    GetColor8To8, GetColor8To16, 
    GetColor8To24, GetColor8To32
};

DWORD
CPaletteMap::GetIndexMapping(DWORD iSrcColor) const
{
    MMASSERT((m_nConvertCode < cvcInvalid) && (gs_rgGetColorFunctions[m_nConvertCode] != NULL));
    return gs_rgGetColorFunctions[m_nConvertCode](iSrcColor, m_rgIndexMap);
}

// Notes:
//    The convert functions also fix the transparency on the destination objects.
//  A better way to do this stuff might be to have Blt functions and then separate
//  convert functions that cleanup the rest of the image after the Blt.
ConvertFunction g_rgConvertFunctions[cvcNumCodes] = {
    NULL, NULL, NULL, NULL,
    BltFast8To8T, BltFast8To16T, 
    BltFast8To24T, BltFast8To32T
};

// Function: BltFast
//    This function takes a src dds and writes a dst dds using the
//  mapping defined by the PaletteMap.  The src and dst can be the
//  same surface.
HRESULT 
CPaletteMap::BltFast(LPDIRECTDRAWSURFACE pddsSrc, LPRECT prSrc, LPDIRECTDRAWSURFACE pddsDst,
                     DWORD nXPos, DWORD nYPos, DWORD dwFlags) const
{
    if (m_rgIndexMap == NULL)
        return E_NOTINITIALIZED;

    // make sure the surfaces are valid
    if (!pddsSrc || !pddsDst) {
        return E_INVALIDARG;
    }

    ConvertFunction pfnConvertFunction;
    HRESULT hr = E_INVALIDARG;
    BOOL bSrcLocked = FALSE, bDstLocked = FALSE;
    DDSURFACEDESC ddsdSrc, ddsdDst;
    INIT_DXSTRUCT(ddsdSrc);
    INIT_DXSTRUCT(ddsdDst);
    long nWidth, nHeight;

    //
    // Lock the surfaces
    //
    if (pddsSrc == pddsDst) {
        // REVIEW: this lock could just lock the minimum rectangle...
        if (FAILED(hr = pddsDst->Lock(NULL, &ddsdDst, DDLOCK_WAIT, NULL))) {
            goto e_Convert;
        }
        bSrcLocked = bDstLocked = TRUE;
        // copy the dst info into the src info
        ddsdSrc = ddsdDst;
    } else {

        // REVIEW: this lock could just lock the minimum rectangle...
        if (FAILED(hr = pddsSrc->Lock(NULL, &ddsdSrc, DDLOCK_WAIT, NULL)))
            goto e_Convert;
        bSrcLocked = TRUE;
        if (FAILED(hr = pddsDst->Lock(NULL, &ddsdDst, DDLOCK_WAIT, NULL)))
            goto e_Convert;
        bDstLocked = TRUE;
    }

    // verify the image information
    if ((ddsdSrc.ddpfPixelFormat.dwRGBBitCount != m_cSrcBPP) ||
        (ddsdDst.ddpfPixelFormat.dwRGBBitCount != m_cDstBPP)) {
        hr = E_INVALIDARG;
        goto e_Convert;
    }

    //
    // clip 
    //
    long nClipWidth, nClipHeight, nLeft, nTop;
    if (prSrc == NULL) {
        nWidth = ddsdSrc.dwWidth;
        nHeight = ddsdSrc.dwHeight;
        nLeft = 0;
        nTop = 0;
    } else {
        nWidth = prSrc->right - prSrc->left;
        nHeight = prSrc->bottom - prSrc->top;
        nLeft = prSrc->left;
        nTop = prSrc->top;
    }
    nClipWidth = long(ddsdDst.dwWidth - nXPos);
    nClipHeight = long(ddsdDst.dwHeight - nYPos);
    UPDATEMAX(nClipWidth, 0);
    UPDATEMAX(nClipHeight, 0);
    UPDATEMAX(nWidth, 0);
    UPDATEMAX(nHeight, 0);
    UPDATEMAX(nLeft, 0);
    UPDATEMAX(nTop, 0);
    UPDATEMIN(nClipWidth, nWidth);
    UPDATEMIN(nClipHeight, nHeight);
    if (((nLeft + nClipWidth) > long(ddsdSrc.dwWidth)) ||
        ((nTop + nClipHeight) > long(ddsdSrc.dwHeight))) {
        hr = E_INVALIDARG;
        goto e_Convert;
    }

    // REVIEW: for now, fail if we are not dealing with at least 8BPP
    if ((ddsdSrc.ddpfPixelFormat.dwRGBBitCount < 8) || (ddsdDst.ddpfPixelFormat.dwRGBBitCount < 8)) {
        hr = E_FAIL;
        goto e_Convert;
    }
        
    nLeft *= (ddsdSrc.ddpfPixelFormat.dwRGBBitCount >> 3);
    nXPos *= (ddsdDst.ddpfPixelFormat.dwRGBBitCount >> 3);

    pfnConvertFunction = g_rgConvertFunctions[m_nConvertCode];
    if (pfnConvertFunction) {
        hr = pfnConvertFunction(
            LPBYTE(ddsdSrc.lpSurface) + nLeft + (nTop * ddsdSrc.lPitch),
            ddsdSrc.lPitch,
            LPBYTE(ddsdDst.lpSurface) + nXPos + (nYPos * ddsdDst.lPitch),
            ddsdDst.lPitch,
            nClipWidth,
            nClipHeight,
            m_rgIndexMap);
    } else {
        hr = E_NOTIMPL;
        goto e_Convert;
    }

e_Convert:
    // unlock the surfaces
    if (pddsSrc == pddsDst) {
        if (bSrcLocked)
            pddsDst->Unlock(ddsdDst.lpSurface);
    } else {
        if (bDstLocked)
            pddsDst->Unlock(ddsdDst.lpSurface);
        if (bSrcLocked)
            pddsSrc->Unlock(ddsdSrc.lpSurface);
    }

    MMASSERT(SUCCEEDED(hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\mdmutils.h ===
#ifndef _MDMUtils_h
#define _MDMUtils_h

// File:	MDMUtils.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//     This header contains miscellaneous utility functions.
// 
// History:
// -@- 08/04/95 (mikemarr) - created
// -@- 09/09/97 (mikemarr) - snarfed from d2d\d2dutils\src\mmutils.cpp
// -@- 09/09/97 (mikemarr) - will only create code when in debug mode
// -@- 11/12/97 (mikemarr) - added CopyDWORDAligned

#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <memory.h>

#define nTMPBUFSIZE 1024
extern char g_rgchTmpBuf[nTMPBUFSIZE];

#if defined(_WINDOWS) || defined(WIN32)
	#ifndef _INC_WINDOWS
		#define WIN32_EXTRA_LEAN
		#define WIN32_LEAN_AND_MEAN
		#include <WINDOWS.H>
	#endif
#endif

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif
#ifndef FALSE
#define FALSE false
#endif
#ifndef TRUE
#define TRUE true
#endif
#ifndef IN
#define IN
#endif
#ifndef OUT
#define OUT
#endif
#ifndef INOUT
#define INOUT
#endif

#ifndef BOOL
typedef int BOOL;
typedef BOOL far *LPBOOL;
#endif
#ifndef BYTE
typedef unsigned char BYTE;
typedef BYTE far *LPBYTE;
#endif
#ifndef WORD
typedef unsigned short WORD;
typedef WORD far *LPWORD;
#endif
#ifndef DWORD
typedef unsigned long DWORD;
typedef DWORD far *LPDWORD;
#endif
#ifndef LPVOID
typedef void far *LPVOID;
#endif

#define maskBYTE	0xFF
#define maskWORD	0xFFFF
#define maskDWORD	0xFFFFFFFF

#define maxBYTE		0xFF
#define maxWORD		0xFFFF
#define maxDWORD	0xFFFFFFFF


#define chSPC ' '
#define chTAB '	'
#define chEOL '\0'
#define chNULL '\0'
#define chLINEFEED 0x0D
#define chCARRIAGERETURN 0x0A

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#define MACSTART do {
#define MACEND } while(0)

// Macro: ISWAP
//    This macro swaps two integer registers using 3 xor's.
//  This is unsafe because a & b are not guaranteed to get 2 regs.
#define ISWAP(a,b) MACSTART (a)^=(b); (b)^=(a); (a)^=(b); MACEND

// Macro: PSWAP
//    This macro swaps two pointers in place using 3 xor's.
#define PSWAP(a,b,type) MACSTART \
	a = (type *)(int(a) ^ int(b)); \
	b = (type *)(int(a) ^ int(b)); \
	a = (type *)(int(a) ^ int(b)); \
MACEND

#define MMINITSTRUCT(__s) memset(&(__s), 0, sizeof(__s))

#ifndef ZERO_DXSTRUCT
#define ZERO_DXSTRUCT(__dxstruct) MACSTART \
	MMINITSTRUCT(__dxstruct); (__dxstruct).dwSize = sizeof(__dxstruct); MACEND
#endif
#ifndef INIT_DXSTRUCT
#define INIT_DXSTRUCT(__dxstruct) MACSTART \
	MMINITSTRUCT(__dxstruct); (__dxstruct).dwSize = sizeof(__dxstruct); MACEND
#endif

#ifdef DBG
#define CHECK_HR(__hr) MACSTART if (FAILED(__hr)) { printf("%s(%d): CHECK_HR failed (0x%X)\n", __FILE__, __LINE__, hr); goto e_Exit; } MACEND
#else
#define CHECK_HR(__hr) MACSTART if (FAILED(__hr)) goto e_Exit; MACEND
#endif
#define CHECK_MEM(__p) MACSTART if ((__p) == NULL) { hr = E_OUTOFMEMORY; goto e_Exit; } MACEND

#define INRANGE(x, xmin, xmax) 	(((x) >= (xmin)) && ((x) <= (xmax)))
#define INARRAY(x, xmax) 		(((x) >= 0) && ((x) < (xmax)))

#define SETABS(x)					MACSTART if ((x) < 0) (x) = -(x); MACEND
#define SETMAX(dst, src1, src2)		MACSTART if ((src1) < (src2)) (dst) = (src2); else (dst) = (src1); MACEND
#define SETMIN(dst, src1, src2)		MACSTART if ((src1) > (src2)) (dst) = (src2); else (dst) = (src1); MACEND
#define UPDATEMAX(dst, src)			MACSTART if ((src) > (dst)) (dst) = (src); MACEND
#define UPDATEMIN(dst, src)			MACSTART if ((src) < (dst)) (dst) = (src); MACEND
#define UPDATEMINMAX(xmin, xmax, x) MACSTART if ((x) < (xmin)) (xmin) = (x); else if ((x) > (xmax)) (xmax) = (x); MACEND
#define CLAMPMAX(x, xmax)			MACSTART if ((x) > (xmax)) (x) = (xmax); MACEND
#define CLAMPMIN(x, xmin)			MACSTART if ((x) < (xmin)) (x) = (xmin); MACEND
#define CLAMP(x, xmin, xmax) MACSTART \
	if ((x) > (xmax)) (x) = (xmax); \
	else if ((x) < (xmin)) (x) = (xmin); \
MACEND

//
// BIT MANIPULATION: BitVector
//
// **Hungarian Prefix: bv
typedef unsigned int BitVector;

#define NUMBITS(Type)	(sizeof(Type) << 3)
// Macro: MASKRANGE
//    Create a bit mask in the specified range, where the lo value is inclusive, and the
//  hi value is exclusive.
//  For example, MASKRANGE(8, 16) == 0x0000FF00.
#define MASKRANGE(lo, hi) \
(((((BitVector) ~0) >> (lo)) << ((lo) + (NUMBITS(BitVector) - (hi)))) >> (NUMBITS(BitVector) - (hi)))
#define SETBIT(bv, i) ((bv) |= (((BitVector) 1) << (i)))
#define UNSETBIT(bv, i) ((bv) &= ~(((BitVector) 1) << (i)))
#define SETRANGE(bv, lo, hi) ((bv) |= MASKRANGE(lo, hi))
#define UNSETRANGE(bv, lo, hi) ((bv) &= ~MASKRANGE(lo, hi))

#define SETFLAG(_dwFlags, _flag, _b) MACSTART if (_b) _dwFlags |= _flag; else _dwFlags &= ~_flag; MACEND

//
// DEBUG STUFF
//
#ifndef __AFX_H__
	#ifdef _DEBUG
		void _MMStall(const char *szExp, const char *szFile, int nLine);
		void _MMTrace(const char *szFmt, ...);

		#define MMASSERT(exp)		(void)((exp) || (_MMStall(#exp, __FILE__, __LINE__),0))
		#define MMASSERT_VALID(exp)	MMASSERT(exp)
		#define MMVERIFY(exp)		MMASSERT(exp)
		#define MMDEBUG_ONLY(exp)	(exp)
		#define MMTRACE				::_MMTrace
	#else
//		void _MMIgnore(const char *szFmt, ...) {}
		#define MMASSERT(exp)		((void)0)
		#define MMASSERT_VALID(exp)	((void)0)
		#define MMVERIFY(exp)		((void)(exp))
		#define MMDEBUG_ONLY(exp)	((void)0)
		#define MMTRACE				1 ? (void)0 : ::printf
	#endif
#else
	#define MMASSERT(exp)		ASSERT(exp)
	#define MMASSERT_VALID(exp)	ASSERT_VALID(exp)
	#define MMVERIFY(exp)		VERIFY(exp)
	#define MMDEBUG_ONLY(exp)	DEBUG_ONLY(exp)
	#define MMTRACE				TRACE
#endif

// Macro: MMRELEASE
//    Safe release for COM objects
// ***this code should never change - there is stuff that relies on the pointer being
//    set to NULL after being released
#ifndef MMRELEASE
#define MMRELEASE(_p) MACSTART if ((_p) != NULL) {(_p)->Release(); (_p) = NULL;} MACEND
#endif

#define MMDELETE(__ptr) MACSTART delete (__ptr); (__ptr) = NULL; MACEND
#define MMDELETERG(__ptr) MACSTART delete [] (__ptr); (__ptr) = NULL; MACEND

#define MMSETREF(_pOld, _pNew) MACSTART if (_pOld) (_pOld)->Release(); if ((_pOld) = (_pNew)) (_pOld)->AddRef(); MACEND

#define MAKE_USERERROR(code)	MAKE_HRESULT(1,FACILITY_ITF,code)

#define E_NOTINITIALIZED		MAKE_USERERROR(0xFFFC)
#define E_ALREADYINITIALIZED	MAKE_USERERROR(0xFFFB)
#define E_NOTFOUND				MAKE_USERERROR(0xFFFA)
#define E_INSUFFICIENTDATA		MAKE_USERERROR(0xFFF9)

extern char g_szEOFMessage[];

// Macro for memory mapped file stuff
#define CHECKEOF(__pFilePos, __pFileLimit) MACSTART \
	if ((__pFilePos) >= (__pFileLimit)) { \
		MMTRACE(g_szEOFMessage); \
		return E_UNEXPECTED; \
	} MACEND


void		ZeroDWORDAligned(LPDWORD pdw, DWORD cEntries);
void		CopyDWORDAligned(DWORD *pdwDst, const DWORD *pdwSrc, DWORD cEntries);

inline void
ZeroPointers(void **ppv, DWORD cEntries)
{
	// use a Duff-Marr machine
	void **ppvLimit = ppv;
	ppv += (cEntries & ~0x7);
	switch (cEntries & 0x7) {
	do {
				ppv -= 8;
				ppv[7] = NULL;
		case 7:	ppv[6] = NULL;
		case 6:	ppv[5] = NULL;
		case 5:	ppv[4] = NULL;
		case 4:	ppv[3] = NULL;
		case 3:	ppv[2] = NULL;
		case 2:	ppv[1] = NULL;
		case 1:	ppv[0] = NULL;
		case 0: ;
	} while (ppv != ppvLimit);
	}
}

DWORD		GetClosestMultipleOf4(DWORD n, bool bGreater);
DWORD		GetClosestPowerOf2(DWORD n, bool bGreater);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\palmap.h ===
#ifndef _PalMap_h
#define _PalMap_h

// File:	PalMap.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//    This class helps perform on-the-fly pixel conversions.
// 
// History:
// -@- 11/18/96 (mikemarr) created
// -@- 12/05/96 (mikemarr) modified
//     added code for translating all palettes to 8, 16, 24, and 32 bit;
//     transparency/alpha stuff is not yet implemented
// -@- 06/24/97 (mikemarr) modified
//     removed PixelInfo
// -@- 09/23/97 (mikemarr) copied to DXCConv from d2d\mmimage
//
// Notes:
// REVIEW:
//    I probably will never support a 4 bit mode, since 4 bit stuff might
//  as well be stored as 8 bit since the space savings is small.  However,
//  2 and 1 bit stuff should still be considered, since the space savings
//  could be substantial.  Further, 1 and 2 bit surfaces represent a large
//  class of content - line art, text, FAX, etc.  (2 bits buys BGW +
//  transparency for example).  This type of content tends to be much larger
//  in dimension -- so we need an efficient representation.

#ifndef _PixInfo_h
#include "PixInfo.h"
#endif

typedef WORD MapEntry16;
typedef DWORD MapEntry24;
typedef DWORD MapEntry32;

#define flagTRANSPARENT 0x1
#define flagPALETTIZED  0x2

#define nMAXPALETTEENTRIES 256

typedef enum ConvertCode {
	cvc4To8 = 0, cvc4To16, cvc4To24, cvc4To32,
	cvc8To8, cvc8To16, cvc8To24, cvc8To32,
	cvcInvalid, cvcNumCodes
} ConvertCode;

typedef HRESULT		(*ConvertFunction)(const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);
typedef DWORD		(*GetColorFunction)(DWORD dwSrcColor, const BYTE *pIndexMap);

extern ConvertFunction g_rgConvertFunctions[cvcNumCodes];

class CPaletteMap {
public:
					CPaletteMap();
					~CPaletteMap();
	
	HRESULT			CreateMap(BYTE nBPPSrcPixels, BYTE nBPPSrcPalette, LPPALETTEENTRY rgpeSrc, 
					   const CPixelInfo &pixiDst, LPDIRECTDRAWPALETTE pddpDst);
	HRESULT			CreateMap(LPDIRECTDRAWPALETTE pddpSrc, const CPixelInfo &pixiDst,
						LPDIRECTDRAWPALETTE pddpDst);
//	HRESULT			CreateSortedMap(BYTE nBPP, const RGB *rgrgbSrc, BYTE nBPPUsed, DWORD iTransColor, 
//						DWORD dwFlags, LPPALETTEENTRY rgpeDst);


	HRESULT			BltFast(LPDIRECTDRAWSURFACE pddsSrc, LPRECT prSrc, LPDIRECTDRAWSURFACE pddsDst,
						DWORD nXPos, DWORD nYPos, DWORD dwFlags) const;

	// REVIEW: this is not "clip-safe"
	HRESULT			BltFast(const BYTE *pSrcPixels, long nSrcPitch, BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight);
	

	DWORD			GetIndexMapping(DWORD iSrcColor) const;

	DWORD			GetSrcBPP() const	{ return m_cSrcBPP; }
	DWORD			GetDstBPP() const	{ return m_cDstBPP; }
	BOOL			IsIdentity() const	{ return m_bIdentity; }
	
private:	
	HRESULT			DoPalTo16BitMap(BYTE nSrcBPP, const CPixelInfo &pixiDst, 
						const PALETTEENTRY *ppeSrc);
	HRESULT			DoPalTo24BitMap(BYTE nSrcBPP, const CPixelInfo &pixiDst, 
						const PALETTEENTRY *ppeSrc);
	HRESULT			DoPalTo32BitMap(BYTE nSrcBPP, const CPixelInfo &pixiDst, 
						const PALETTEENTRY *ppeSrc);
	HRESULT			DoPalToPalMap(BYTE nSrcBPP, BYTE nDstBPP, const PALETTEENTRY *ppeSrc, 
						const PALETTEENTRY *ppeDst);

	static int		GetConvertCode(DWORD nSrcBPP, DWORD nDstBPP);

private:
	BYTE *			m_rgIndexMap;
	BYTE			m_nConvertCode;
	// REVIEW: we don't need to store the src and dst info ==> implicit in ConvertCode
	BYTE			m_cSrcBPP, m_cDstBPP;
	BYTE			m_bIdentity;
};


inline HRESULT
CPaletteMap::BltFast(const BYTE *pSrcPixels, long nSrcPitch, BYTE *pDstPixels, long nDstPitch,
					 DWORD nWidth, DWORD nHeight)
{
	ConvertFunction pfnConvertFunction = g_rgConvertFunctions[m_nConvertCode];
	if (pfnConvertFunction)
		return pfnConvertFunction(pSrcPixels, nSrcPitch, pDstPixels, nDstPitch, 
					nWidth, nHeight, m_rgIndexMap);
	return E_NOTIMPL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\parse.cpp ===
// File:	Parse.cpp
// Author:	Michael Marr    (mikemarr)
//
// History:
// -@- 09/23/97 (mikemarr) copied from projects\vector2d

#include "StdAfx.h"
#include "Parse.h"

#define fGSCALE 1.f

class CAdobeFormatConverter {
public:
					CAdobeFormatConverter();
					~CAdobeFormatConverter() {}
	HRESULT			Parse(const char *pData, DWORD nFileLength, RenderCmd **ppCmds);

private:
	HRESULT			ParseProlog();
	HRESULT			ParseScript();
	HRESULT			ParseSetup();
	HRESULT			ParseObjects();
	HRESULT			ParseCompoundPath();
	HRESULT			ParsePath();
	HRESULT			ParsePaintStyle(const char *&pEnd);
	HRESULT			ParsePathGeometry(const char *pEnd);
	HRESULT			ParseTrailers();

private:
	void			EatLine();
	const char *	FindNextLine(const char *pch);
	const char *	FindLF(const char *pch);
	const char *	FindSpace(const char *pch);

private:
	const char *	m_pData, *m_pLimit;
	float			m_fWidth, m_fHeight;
//	float			m_fMaxHeight;
	bool			m_bNoBrush, m_bNoPen;

	DXFPOINT		m_rgPoints[nMAXPOINTS];
	DXFPOINT *		m_pCurPoint;
	BYTE			m_rgCodes[nMAXPOINTS];
	BYTE *			m_pCurCode;
	RenderCmd		m_rgRenderCmds[nMAXPOLYS];
	RenderCmd *		m_pCurRenderCmd;
	PolyInfo		m_rgPolyInfos[nMAXPOLYS];
	PolyInfo *		m_pCurPolyInfo;
	BrushInfo		m_rgBrushInfos[nMAXBRUSHES];
	BrushInfo *		m_pCurBrushInfo;
	PenInfo			m_rgPenInfos[nMAXPENS];
	PenInfo *		m_pCurPenInfo;
};

inline bool
mmIsSpace(char ch)
{
	return ((ch == ' ') || (ch == chLINEFEED) || (ch == chCARRIAGERETURN));
//	return isspace(ch) != 0;
}

inline bool
mmIsDigit(char ch)
{
	return ((ch >= '0') && (ch <= '9'));
//	return isdigit(ch) != 0;
}

float
mmSimpleAtoF(const char *&pData)
{
	const char *pSrc = pData;

	// eat white space
	while (mmIsSpace(*pSrc)) pSrc++;

	bool bNeg;
	if (*pSrc == '-') {
		bNeg = true;
		pSrc++;
	} else {
		bNeg = false;
	}

	// get digits before the decimal point
	float f;
	if (mmIsDigit(*pSrc)) {
		f = float(*pSrc++ - '0');
		
		while (mmIsDigit(*pSrc))
			f = f * 10.f + float(*pSrc++ - '0');
	} else {
		f = 0.f;
	}
	if (*pSrc == '.') 
		pSrc++;

	// get digits after the decimal point
	float fDec = 0.1f;
	while (mmIsDigit(*pSrc)) {
		f += (float(*pSrc++ - '0') * fDec);
		fDec *= 0.1f;
	}

	// REVIEW: assume no exponent for now

	pData = pSrc;

	return (bNeg ? -f : f);
}


inline const char *
CAdobeFormatConverter::FindLF(const char *pch)
{
	// find the linefeed character
	while ((*pch != chLINEFEED) && (*pch != chCARRIAGERETURN)) pch++;

	MMASSERT(pch <= m_pLimit);

	return pch;
}

inline const char *
CAdobeFormatConverter::FindNextLine(const char *pch)
{
	// find the linefeed character
	while (*pch++ != chLINEFEED);

	// check if there is also carriage return
	if (*pch == chCARRIAGERETURN)
		pch++;

	MMASSERT(pch <= m_pLimit);

	return pch;
}

inline const char *
CAdobeFormatConverter::FindSpace(const char *pch)
{
	// find the linefeed character
	while (!mmIsSpace(*pch)) pch++;

	MMASSERT(pch <= m_pLimit);

	return pch;
}


inline void
CAdobeFormatConverter::EatLine()
{
	m_pData = FindNextLine(m_pData);
}

CAdobeFormatConverter::CAdobeFormatConverter()
{
	m_pData = m_pLimit = NULL;
	m_fWidth = m_fHeight = 0.f;
//	m_fMaxHeight = 0.f;
	m_bNoBrush = m_bNoPen = true;
}


HRESULT
CAdobeFormatConverter::Parse(const char *pData, DWORD nFileLength, RenderCmd **ppCmds)
{
//	MMTRACE("Parse\n");

	HRESULT hr = S_OK;

	if (ppCmds == NULL)
		return E_POINTER;

	if (!pData || !nFileLength)
		return E_INVALIDARG;

	m_pData = pData;
	m_pLimit = pData + nFileLength;

	// intialize command storage stuff
	m_pCurPoint = m_rgPoints;
	m_pCurCode = m_rgCodes;
	m_pCurPolyInfo = m_rgPolyInfos;
	m_pCurRenderCmd = m_rgRenderCmds;
	m_pCurBrushInfo = m_rgBrushInfos;
	m_pCurPenInfo = m_rgPenInfos;

	CHECK_HR(hr = ParseProlog());
	CHECK_HR(hr = ParseScript());

e_Exit:
	// write a stop command to the end
	m_pCurRenderCmd->nType = typeSTOP;
	m_pCurRenderCmd->pvData = NULL;
	*ppCmds = m_rgRenderCmds;

	return hr;
}

HRESULT
CAdobeFormatConverter::ParseProlog()
{
//	MMTRACE("ParseProlog\n");
	const char *szSearch;

	// extract the image dimensions
	float f1, f2;
	// bounding box is supposed to be a required field with the proper numbers
	szSearch = "%%BoundingBox:";
	m_pData = strstr(m_pData, szSearch);
	m_pData = FindSpace(m_pData);

	f1 = mmSimpleAtoF(m_pData);
	f2 = mmSimpleAtoF(m_pData);
	m_fWidth = mmSimpleAtoF(m_pData);
	m_fHeight = mmSimpleAtoF(m_pData);
//	if (sscanf(m_pData, "%f %f %f %f", &f1, &f2, &m_fWidth, &m_fHeight) != 4)
//		return E_FAIL;
	if ((m_fWidth <= 0.f) || (m_fHeight < 0.f))
		return E_FAIL;

//	m_fMaxHeight = float(m_nHeight);

	// search until we find end string
	szSearch = "%%EndProlog";
	m_pData = strstr(m_pData, szSearch);
	if (m_pData == NULL)
		return E_FAIL;

	EatLine();

	return S_OK;
}

HRESULT
CAdobeFormatConverter::ParseScript()
{
//	MMTRACE("ParseScript\n");
	HRESULT hr;

	if (FAILED(hr = ParseSetup()) ||
		FAILED(hr = ParseObjects()) ||
		FAILED(hr = ParseTrailers()))
		return hr;

	return S_OK;
}

HRESULT
CAdobeFormatConverter::ParseSetup()
{
//	MMTRACE("ParseSetup\n");

	const char *szSearch;

	// search until we find end string
	szSearch = "%%EndSetup";
	m_pData = strstr(m_pData, szSearch);
	if (m_pData == NULL)
		return E_FAIL;

	EatLine();

	return S_OK;
}


HRESULT
CAdobeFormatConverter::ParseObjects()
{
//	MMTRACE("ParseObjects\n");
	HRESULT hr = S_OK;

	const char *szPageTrailer = "%%PageTrailer";
	const char *szTrailer = "%%Trailer";
	int cPageTrailer = strlen(szPageTrailer);
	int cTrailer = strlen(szTrailer);

	// process dimensions
/*	const char *pEnd;
	pEnd = FindLF(m_pData);
//	pEnd = strchr(m_pData, '\n');
	if ((pEnd[-1] == 'b') && (pEnd[-2] == 'L')) {
		// get the dimensions out
		int n1, n2, n3, n4, n5, n6, n7, n8;
		if ((sscanf(m_pData, "%d %d %d %d %d %d %d %d %d %d %d",
				&n1, &n2, &n3, &n4, &n5, &n6, &n7, &n8, &m_nWidth, &m_nHeight) != 10) ||
			(m_nWidth <= 0) || (m_nHeight < 0))
		{
			return E_FAIL;
		}
		m_fMaxHeight = float(m_nHeight);
		m_pData = FindNextLine(pEnd);
	}

	pEnd = FindLF(m_pData);
//	pEnd = strchr(m_pData, '\n');
	if ((pEnd[-1] == 'n') && (pEnd[-2] == 'L')) {
		// skip layer information
		m_pData = FindNextLine(pEnd);
	}
*/
	
	for (;;) {
		switch (m_pData[0]) {
		case '%':
			if ((strncmp(m_pData, szPageTrailer, cPageTrailer) == 0) ||
				(strncmp(m_pData, szTrailer, cTrailer) == 0))
			{
				// end of object definitions
				goto e_Exit;
			} else {
				// comment
				EatLine();
			}
			break;
		case '*':
			if (m_pData[1] == 'u')
				CHECK_HR(hr = ParseCompoundPath());
			else {
				hr = E_FAIL;
				goto e_Exit;
			}
			break;
		default:
			CHECK_HR(hr = ParsePath());
			break;
		}
	}

e_Exit:
	if (hr == S_OK)
		EatLine();

	return hr;
}


HRESULT
CAdobeFormatConverter::ParseCompoundPath()
{
//	MMTRACE("ParseCompoundPath\n");
	HRESULT hr = S_OK;

	// remove the "*u"
	MMASSERT((m_pData[0] == '*') && (m_pData[1] == 'u'));
//	if (strncmp(m_pData, "*u", 2) != 0)
//		return E_UNEXPECTED;
	EatLine();

	while (m_pData[0] != '*')
		CHECK_HR(hr = ParsePath());

	// remove the "*U"
	MMASSERT((m_pData[0] == '*') && (m_pData[1] == 'U'));
//	if (strncmp(m_pData, "*U", 2) != 0)
//		return E_UNEXPECTED;
	EatLine();

e_Exit:
	return hr;
}




inline 
UINT GetUInt(const char *pData)
{
	return (UINT) atoi(pData);
}

typedef DWORD FP;
#define nEXPBIAS	127
#define nEXPSHIFTS	23
#define nEXPLSB		(1 << nEXPSHIFTS)
#define maskMANT	(nEXPLSB - 1)
#define FloatToFixed08(nDst, fSrc) MACSTART \
	float fTmp = fSrc; \
	DWORD nRaw = *((FP *) &(fTmp)); \
	if (nRaw < ((nEXPBIAS + 23 - 31) << nEXPSHIFTS)) \
		nDst = 0; \
	else \
		nDst = ((nRaw | nEXPLSB) << 8) >> ((nEXPBIAS + 23) - (nRaw >> nEXPSHIFTS)); \
MACEND

HRESULT
CAdobeFormatConverter::ParsePaintStyle(const char *&pEnd)
{
	HRESULT hr = S_OK;
	BOOL bNotDone = TRUE;
//	int nLineJoin = 1, nLineCap = 1;
	float fLineWidth = 1.f;
	float fGrayFill, fGrayStroke;
	float fCyan, fYellow, fMagenta, fBlack;
	bool bColorFill = false, bGrayFill = false, bGrayStroke = false;

	// parse paint style
	for (; pEnd; pEnd = FindLF(m_pData)) {
		switch(pEnd[-1]) {
			//
			// path attributes
			//
		case 'd':	// process dash
			// REVIEW: skip this for now -- assume NULL pattern
			break;
		case 'j':	// process line join type
			// REVIEW: skip this for now, since it is always 1
//			nLineJoin = mmSimpleAtoI(m_pData);
			break;
		case 'J':	// process line cap type
			// REVIEW: skip this for now, since it is always 1
//			nLineCap = mmSimpleAtoI(m_pData);
			break;
		case 'w':	// process line width
			// REVIEW: skip this for now, since it is always 1.f
//			fLineWidth = mmSimpleAtoF(m_pData);
			break;

			//
			// fill color
			//
		case 'g':	// process gray color for fill
			fGrayFill = mmSimpleAtoF(m_pData);
			bGrayFill = true;
			break;
		case 'k':	// process color
			fCyan = mmSimpleAtoF(m_pData);
			fMagenta = mmSimpleAtoF(m_pData);
			fYellow = mmSimpleAtoF(m_pData);
			fBlack = mmSimpleAtoF(m_pData);
			bColorFill = true;
			break;

			//
			// stroke color
			//
		case 'G':	// process gray color for stroke
			fGrayStroke = mmSimpleAtoF(m_pData);
			bGrayStroke = true;
			break;

		default:
			goto Exit;
			break;
		}
		m_pData = FindNextLine(pEnd);
//		m_pData = pEnd + 1;
	}
Exit:

	// output GDI commands

	//
	// create a brush
	//
	if (bColorFill || bGrayFill) {
		static DWORD nLastRed = 256, nLastGreen = 256, nLastBlue = 256;
		DWORD nTmpRed, nTmpGreen, nTmpBlue;

		if (bColorFill) {
			FloatToFixed08(nTmpRed, fCyan + fBlack); CLAMPMAX(nTmpRed, 255); nTmpRed = 255 - nTmpRed;
			FloatToFixed08(nTmpGreen, fMagenta + fBlack); CLAMPMAX(nTmpGreen, 255); nTmpGreen = 255 - nTmpGreen;
			FloatToFixed08(nTmpBlue, fYellow + fBlack); CLAMPMAX(nTmpBlue, 255); nTmpBlue = 255 - nTmpBlue;
		} else if (bGrayFill) {
			DWORD nTmpGray;
			FloatToFixed08(nTmpGray, fGrayFill); CLAMPMAX(nTmpGray, 255);
			nTmpRed = nTmpGreen = nTmpBlue = nTmpGray;
		}

		if ((nLastRed != nTmpRed) || (nLastGreen != nTmpGreen) || (nLastBlue != nTmpBlue)) {
			// define a new brush
			nLastRed = nTmpRed; nLastGreen = nTmpGreen; nLastBlue = nTmpBlue;
//			fprintf(m_pFile, "\t// select a new brush\n");
//			fprintf(m_pFile, "\tBrush.Color = DXSAMPLE(255, %d, %d, %d);\n", nRed, nGreen, nBlue);
//			fprintf(m_pFile, "\tpDX2D->SetBrush(&Brush);\n\n");
			m_pCurBrushInfo->Color = DXSAMPLE(255, BYTE(nTmpRed), BYTE(nTmpGreen), BYTE(nTmpBlue));
			m_pCurRenderCmd->nType = typeBRUSH;
			m_pCurRenderCmd->pvData = (void *) m_pCurBrushInfo++;
			m_pCurRenderCmd++;
			m_bNoBrush = false;
		}
	}
		
	// create a pen
	if (bGrayStroke) {
		static bool bPenInit = false;
		
		// we only have one pen in the simpsons.ai
		if (!bPenInit) {
//			if ((fGrayStroke != 0.f) || (nLineJoin != 1) || (nLineCap != 1)) {
			if (fGrayStroke != 0.f) {
				MMTRACE("error: can not support pen type\n");
				return E_FAIL;
			}
			bPenInit = true;
//			fprintf(m_pFile, "\t// select a new pen\n");
//			fprintf(m_pFile, "\tPen.Color = DXSAMPLE(255, 0, 0, 0);\n");
//			fprintf(m_pFile, "\tPen.Width = %.2ff;\n", fLineWidth * fGSCALE);
//			fprintf(m_pFile, "\tPen.Style = PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_ROUND | PS_JOIN_ROUND;\n");
//			fprintf(m_pFile, "\tpDX2D->SetPen(&Pen);\n\n");
			// REVIEW: only can make one kind of pen right now
			m_pCurPenInfo->Color = DXSAMPLE(255, 0, 0, 0);
			m_pCurPenInfo->fWidth = fLineWidth * fGSCALE;
			m_pCurPenInfo->dwStyle = PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_ROUND | PS_JOIN_ROUND;
			m_pCurRenderCmd->nType = typePEN;
			m_pCurRenderCmd->pvData = (void *) m_pCurPenInfo++;
			m_pCurRenderCmd++;
			m_bNoPen = false;
		}
	}

	return S_OK;
}

#define GetCoordX(_fX) ((_fX) * fGSCALE)
#define GetCoordY(_fY) ((m_fHeight - (_fY)) * fGSCALE)

HRESULT
CAdobeFormatConverter::ParsePathGeometry(const char *pEnd)
{
	HRESULT hr = S_OK;
//	float fX1, fY1, fXBez1, fYBez1, fXBez2, fYBez2;

	m_pCurPolyInfo->pPoints = m_pCurPoint;
	m_pCurPolyInfo->pCodes = m_pCurCode;

	// parse path geometry
	DWORD cPoints = 0;
	bool bFlatten = false;
	for (; pEnd; pEnd = FindLF(m_pData)) {
		switch(pEnd[-1]) {
		case 'm':
//			fprintf(m_pFile, "\t// define geometry path\n");
//			sscanf(m_pData, "%f %f", &fX1, &fY1);
//			fprintf(m_pFile, "\tppt = rgpt; pb = rgCodes;\n");
//			fprintf(m_pFile, "\tppt->x   = %.2ff; ppt->y   = %.2ff; *pb++ = PT_MOVETO;   ppt++;\n", GetCoordX(fX1), GetCoordY(fY1));
			m_pCurPoint->x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint->y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint++;
			*m_pCurCode++ = PT_MOVETO;
			cPoints++;
			break;
		case 'L':
		case 'l':
//			sscanf(m_pData, "%f %f", &fX1, &fY1);
//			fprintf(m_pFile, "\tppt->x   = %.2ff; ppt->y   = %.2ff; *pb++ = PT_LINETO;   ppt++;\n", GetCoordX(fX1), GetCoordY(fY1));
			m_pCurPoint->x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint->y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint++;
			*m_pCurCode++ = PT_LINETO;
			cPoints++;
			break;
		case 'C':
		case 'c':
			bFlatten = true;
			m_pCurPoint[0].x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint[0].y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint[1].x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint[1].y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint[2].x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint[2].y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint += 3;
			m_pCurCode[0] = PT_BEZIERTO; 
			m_pCurCode[1] = PT_BEZIERTO; 
			m_pCurCode[2] = PT_BEZIERTO; 
			m_pCurCode += 3;
			cPoints += 3;
//			sscanf(m_pData, "%f %f %f %f %f %f", &fXBez1, &fYBez1, &fXBez2, &fYBez2, &fX1, &fY1);
//			fprintf(m_pFile, "\tppt[0].x = %.2ff; ppt[0].y = %.2ff; pb[0] = PT_BEZIERTO;\n", GetCoordX(fXBez1), GetCoordY(fYBez1));
//			fprintf(m_pFile, "\tppt[1].x = %.2ff; ppt[1].y = %.2ff; pb[1] = PT_BEZIERTO;\n", GetCoordX(fXBez2), GetCoordY(fYBez2));
//			fprintf(m_pFile, "\tppt[2].x = %.2ff; ppt[2].y = %.2ff; pb[2] = PT_BEZIERTO; ppt += 3; pb += 3;\n", GetCoordX(fX1), GetCoordY(fY1));
			break;
		default:
			goto Exit;
			break;
		}
		// skip the line
		m_pData = FindNextLine(pEnd);
	}
Exit:

	// create the path
//	char *pFillType = (bFlatten ? "0" : "DX2D_NO_FLATTEN");
	if (cPoints) {
		DWORD dwFlags;
		switch(pEnd[-1]) {
		case 'f':		// close path and fill
			if (m_bNoBrush) {
//				fprintf(m_pFile, "\tpDX2D->SetBrush(&Brush);\n"); m_nLines++;
				m_bNoBrush = false;
			}
			if (m_bNoPen == false) {
//				fprintf(m_pFile, "\tpDX2D->SetPen(NULL);\n"); m_nLines++;
				m_bNoPen = true;
			}
			dwFlags = DX2D_FILL;
			break;
		case 'S':		// stroke path
			if (m_bNoPen) { 
//				fprintf(m_pFile, "\tpDX2D->SetPen(&Pen);\n"); m_nLines++;
				m_bNoPen = false;
			}
			if (m_bNoBrush == false) {
//				fprintf(m_pFile, "\tpDX2D->SetBrush(NULL);\n"); m_nLines++;
				m_bNoBrush = true;
			}
			dwFlags = DX2D_STROKE;
			break;
		default:
			MMTRACE("error: unknown render mode -- aborting\n");
			return E_FAIL;
			break;
		}
//		fprintf(m_pFile, "\tpDX2D->AAPolyDraw(rgpt, rgCodes, %d, %s);\n", iPoint, pFillType);
		m_pCurPolyInfo->cPoints = cPoints;
		m_pCurPolyInfo->dwFlags = dwFlags | (bFlatten ? 0 : DX2D_NO_FLATTEN);
		m_pCurRenderCmd->nType = typePOLY;
		m_pCurRenderCmd->pvData = (PolyInfo *) m_pCurPolyInfo++;
		m_pCurRenderCmd++;
		m_pData = FindNextLine(pEnd);
	}

	return S_OK;
}

HRESULT
CAdobeFormatConverter::ParsePath()
{
//	MMTRACE("ParsePath\n");
	HRESULT hr;
	const char *pStart = m_pData, *pEnd = FindLF(m_pData);

	if (FAILED(hr = ParsePaintStyle(pEnd)))
		return hr;

	if (FAILED(hr = ParsePathGeometry(pEnd)))
		return hr;

	// skip it if we don't know how to deal with it
	if (pStart == m_pData) {
//		if ((m_pData[0] != 'L') || (m_pData[1] != 'B')) {
//			MMTRACE("warning: control data of unknown type -- ignoring line\n");
//		}
		m_pData = FindNextLine(pEnd);
	}

	return hr;
}

HRESULT
CAdobeFormatConverter::ParseTrailers()
{
	return S_OK;
}


HRESULT
OpenFileMapping(const char *szFilename, LPHANDLE phMapping, 
				DWORD *pnFileLength)
{
	MMASSERT(szFilename && phMapping && pnFileLength);
	HRESULT hr = S_OK;

	HANDLE hFile = NULL, hMapping = NULL;
	DWORD nFileLength = 0, dwHighSize = 0;

	MMTRACE("Opening File: %s\n", szFilename);

	// open the file
	hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, 
				OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);

	if ((hFile == NULL) || (hFile == INVALID_HANDLE_VALUE)) {
		MMTRACE("error: file not found - %s\n", szFilename);
		return STG_E_FILENOTFOUND;
	}

	// get the length of the file
	if (((nFileLength = GetFileSize(hFile, &dwHighSize)) == 0xFFFFFFFF) || dwHighSize ||
		// create a file mapping object
		((hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL)) == NULL))
	{
		MMTRACE("error: creating file mapping\n");
		hr = E_FAIL;
	}

	MMTRACE("\tLength: %d\n", nFileLength);

	if (hFile)
		CloseHandle(hFile);

	*phMapping = hMapping;
	*pnFileLength = nFileLength;

	return hr;
}


#define szDEFFILENAME "\\dtrans\\tools\\simpsons\\simpsons.ai"

HRESULT
ParseAIFile(const char *szFilename, RenderCmd **ppCmds)
{
	HRESULT hr = S_OK;

	static CAdobeFormatConverter afc;
	static RenderCmd s_CmdStop = {typeSTOP, NULL};
	DWORD nStartTick, nEndTick;
	DWORD nFileLength;
	HANDLE hMapping = NULL;
	char *pData = NULL;

	if (szFilename == NULL)
		szFilename = szDEFFILENAME;

	nStartTick = GetTickCount();

	CHECK_HR(hr = OpenFileMapping(szFilename, &hMapping, &nFileLength));

	// create a map view
	if ((pData = (char *) MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0)) == NULL) {
		hr = E_FAIL;
		goto e_Exit;
	}

	CHECK_HR(hr = afc.Parse(pData, nFileLength, ppCmds));

e_Exit:
	if (pData)
		UnmapViewOfFile(pData);

	if (hMapping)
		CloseHandle(hMapping);

	if (FAILED(hr)) {
		// set to the null command list
		*ppCmds = &s_CmdStop;
		MMTRACE("\terror parsing file\n");
	} else {
		nEndTick = GetTickCount();
		sprintf(g_rgchTmpBuf, "\tParse Time: %d\n", nEndTick - nStartTick);
		OutputDebugString(g_rgchTmpBuf);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\parse.h ===
#ifndef _Parse_h
#define _Parse_h

// File:    Parse.h
// Author:  Michael Marr    (mikemarr)
//
// History:
// -@- 09/23/97 (mikemarr) copied from projects\vector2d

#include "DXTransP.h"

#define nMAXPOINTS  (1 << 16)
#define nMAXPOLYS   (1 << 14)
#define nMAXBRUSHES (1 << 14)
#define nMAXPENS    16

#define typePOLY    0
#define typeBRUSH   1
#define typePEN     2
#define typeSTOP    4
typedef struct RenderCmd {
    DWORD       nType;
    void *      pvData;
} RenderCmd;

typedef struct BrushInfo {
    DXSAMPLE    Color;
} BrushInfo;

typedef struct PenInfo {
    DXSAMPLE    Color;
    float       fWidth;
    DWORD       dwStyle;
} PenInfo;

typedef struct PolyInfo {
    DXFPOINT *  pPoints;
    BYTE *      pCodes;
    DWORD       cPoints;
    DWORD       dwFlags;
} PolyInfo;

HRESULT     ParseAIFile(const char *szFilename, RenderCmd **ppCmds);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\pixinfo.h ===
#ifndef _PixInfo_h
#define _PixInfo_h

// File:	PixInfo.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//    Store the PixelFormat information in a form that is actually useful
//  to an application.
//
// ***Hungarian: pixi
// 
// History:
// -@- 06/24/97 (mikemarr) created -- snarfed from PalMap.h
// -@- 09/23/97 (mikemarr) moved to DXCConv to do color conversion stuff
// -@- 10/09/97 (mikemarr) - added 8 bit RGB
//                         - added flags
//                         - bug fixes for pixel formats with alpha

#define flagPixiRGB		0x1
#define flagPixiAlpha	0x2

class CPixelInfo {
public:
	HRESULT			Init(BYTE nBPP = 0, DWORD dwRedMask = 0, DWORD dwGreenMask = 0,
						DWORD dwBlueMask = 0, DWORD dwAlphaMask = 0);
	HRESULT			Init(const DDPIXELFORMAT &ddpf) {
						return Init(BYTE(ddpf.dwRGBBitCount), ddpf.dwRBitMask, ddpf.dwGBitMask,
							ddpf.dwBBitMask, ddpf.dwRGBAlphaBitMask); }

					CPixelInfo(BYTE nBPP = 0, DWORD dwRedMask = 0, DWORD dwGreenMask = 0,
						DWORD dwBlueMask = 0, DWORD dwAlphaMask = 0) {
							Init(nBPP, dwRedMask, dwGreenMask, dwBlueMask, dwAlphaMask); }
					CPixelInfo(const DDPIXELFORMAT &ddpf) { Init(ddpf); }
	

	void			GetDDPF(DDPIXELFORMAT &ddpf) const;
	BOOL			IsRGB() const { return uchFlags & flagPixiRGB; }
	BOOL			HasAlpha() const { return uchFlags & flagPixiAlpha; }

	BOOL			operator==(const CPixelInfo &pixi) const;
	BOOL			operator!=(const CPixelInfo &pixi) const { return !(*this == pixi); };
	BOOL			operator==(const DDPIXELFORMAT &ddpf) const;
	BOOL			operator!=(const DDPIXELFORMAT &ddpf) const { return !(*this == ddpf); }

	// generic pack
	DWORD			Pack(const BYTE *pPixels) const;
	DWORD			Pack(BYTE r, BYTE g, BYTE b) const;
	DWORD			Pack(BYTE r, BYTE g, BYTE b, BYTE a) const;
	DWORD			Pack(const PALETTEENTRY &pe) const	{ return Pack(pe.peRed, pe.peGreen, pe.peBlue, pe.peFlags); }
	void			UnPack(DWORD dwPixel, BYTE *pR, BYTE *pG, BYTE *pB, BYTE *pA) const;
	void			UnPack(DWORD dwPixel, BYTE *pR, BYTE *pG, BYTE *pB) const;
	DWORD			TranslatePack(DWORD dwSrcPixel, const CPixelInfo &pixiSrcFmt) const;

	// explicit pack
	WORD			Pack16(BYTE r, BYTE g, BYTE b) const;
	WORD			Pack16(BYTE r, BYTE g, BYTE b, BYTE a) const;
	WORD			Pack16(const PALETTEENTRY &pe) const	{ return Pack16(pe.peRed, pe.peGreen, pe.peBlue); }

public:
	BYTE			nBPP, uchFlags;
	BYTE			nRedShift, nRedResidual;
	BYTE			nGreenShift, nGreenResidual;
	BYTE			nBlueShift, nBlueResidual;
	BYTE			nAlphaShift, nAlphaResidual;
	BYTE			iRed, iBlue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\pixinfo.cpp ===
// File:	PixInfo.cpp
// Author:	Michael Marr    (mikemarr)

#include "stdafx.h"
#include "PixInfo.h"
#include "DDHelper.h"

static void
_GetShiftMaskInfo(DWORD dwMask, BYTE *pnShiftStart, BYTE *pnLengthResidual)
{
	MMASSERT(pnShiftStart && pnLengthResidual);
	// Note: - DWORD fills with zeros on right shift

	DWORD nShift = 0, nRes = 8;
	if (dwMask) {
		// compute shift
		if ((dwMask & 0xFFFF) == 0) { dwMask >>= 16, nShift += 16; }
		if ((dwMask & 0xFF) == 0) { dwMask >>= 8; nShift += 8; }
		if ((dwMask & 0xF) == 0) { dwMask >>= 4; nShift += 4; }
		if ((dwMask & 0x3) == 0) { dwMask >>= 2; nShift += 2; }
		if ((dwMask & 0x1) == 0) { dwMask >>= 1; nShift++; }
		// compute residual
		if ((dwMask & 0xFF) == 0xFF) { 
			nRes = 0;
		} else {
			if ((dwMask & 0xF) == 0xF) { dwMask >>= 4; nRes -= 4; }
			if ((dwMask & 0x3) == 0x3) { dwMask >>= 2; nRes -= 2; }
			if ((dwMask & 0x1) == 0x1) { nRes--; }
		}
	}
	*pnShiftStart = (BYTE) nShift;
	*pnLengthResidual = (BYTE) (nRes);
}


HRESULT
CPixelInfo::Init(BYTE tnBPP, DWORD dwRedMask, DWORD dwGreenMask,
				 DWORD dwBlueMask, DWORD dwAlphaMask)
{
	nBPP = tnBPP;
	uchFlags = 0;

	if (dwRedMask) {
		uchFlags |= flagPixiRGB;
		_GetShiftMaskInfo(dwRedMask, &nRedShift, &nRedResidual);
		_GetShiftMaskInfo(dwGreenMask, &nGreenShift, &nGreenResidual);
		_GetShiftMaskInfo(dwBlueMask, &nBlueShift, &nBlueResidual);
		_GetShiftMaskInfo(dwAlphaMask, &nAlphaShift, &nAlphaResidual);
		if (dwAlphaMask)
			uchFlags |= flagPixiAlpha;
	} else {
		nRedResidual = nGreenResidual = nBlueResidual = nAlphaResidual = 8;
		nRedShift = nGreenShift = nBlueShift = nAlphaShift = 0;
	}
	iRed = (nRedShift == 0 ? 0 : 2);
	iBlue = 2 - iRed;
	
//	MMTRACE("BPP: %2d   R: %2d %2d   G: %2d %2d   B: %2d %2d   A: %2d %2d\n", nBPP,
//		8 - nRedResidual, nRedShift, 8 - nGreenResidual, nGreenShift, 
//		8 - nBlueResidual, nBlueShift, 8 - nAlphaResidual, nAlphaShift);

	return S_OK;
}

void
CPixelInfo::GetDDPF(DDPIXELFORMAT &ddpf) const
{
	ddpf.dwSize = sizeof(DDPIXELFORMAT);
	ddpf.dwFlags = DDPF_RGB;
	ddpf.dwRGBBitCount = nBPP;
	if (IsRGB()) {
		ddpf.dwRBitMask = ((((DWORD) 0xFF) >> nRedResidual) << nRedShift);
		ddpf.dwGBitMask = ((((DWORD) 0xFF) >> nGreenResidual) << nGreenShift);
		ddpf.dwBBitMask = ((((DWORD) 0xFF) >> nBlueResidual) << nBlueShift);
		ddpf.dwRGBAlphaBitMask = ((((DWORD) 0xFF) >> nAlphaResidual) << nAlphaShift);
		if (HasAlpha())
			ddpf.dwFlags |= DDPF_ALPHAPIXELS;
	} else {
		ddpf.dwFlags |= BPPToPixelFlags(nBPP);
		ddpf.dwRBitMask = ddpf.dwGBitMask = ddpf.dwBBitMask = ddpf.dwRGBAlphaBitMask = 0;
	}
}

BOOL
CPixelInfo::operator==(const CPixelInfo &pixi) const
{
	return ((nBPP == pixi.nBPP) && (!IsRGB() || 
		((nRedShift == pixi.nRedShift) && (nGreenShift == pixi.nGreenShift) &&
		 (nBlueShift == pixi.nBlueShift) && (nAlphaShift == pixi.nAlphaShift))));
}

BOOL
CPixelInfo::operator==(const DDPIXELFORMAT &ddpf) const
{
	return ((nBPP == ddpf.dwRGBBitCount) && ((!IsRGB() && (ddpf.dwRBitMask == 0)) ||
			((ddpf.dwRBitMask == ((DWORD(0xFF) >> nRedResidual) << nRedShift)) &&
			 (ddpf.dwGBitMask == ((DWORD(0xFF) >> nGreenResidual) << nGreenShift)) &&
			 (ddpf.dwBBitMask == ((DWORD(0xFF) >> nBlueResidual) << nBlueShift)) &&
			 (ddpf.dwRGBAlphaBitMask == ((DWORD(0xFF) >> nAlphaResidual) << nAlphaShift)))));
}

DWORD
CPixelInfo::Pack(const BYTE *pPixel) const
{
	MMASSERT(pPixel && (nBPP >= 8));
	if (nBPP == 8)
		return (DWORD) *pPixel;
	if (HasAlpha())
		return Pack(pPixel[0], pPixel[1], pPixel[2], pPixel[3]);
	else
		return Pack(pPixel[0], pPixel[1], pPixel[2]);
}

DWORD
CPixelInfo::Pack(BYTE r, BYTE g, BYTE b) const
{
	// truncate the RGB values to fit in allotted bits
	return (((((DWORD) r) >> nRedResidual) << nRedShift) |
		((((DWORD) g) >> nGreenResidual) << nGreenShift) |
		((((DWORD) b) >> nBlueResidual) << nBlueShift));
}

DWORD
CPixelInfo::Pack(BYTE r, BYTE g, BYTE b, BYTE a) const
{
	// truncate the alpha value to fit in allotted bits
	return (((((DWORD) r) >> nRedResidual) << nRedShift) |
		((((DWORD) g) >> nGreenResidual) << nGreenShift) |
		((((DWORD) b) >> nBlueResidual) << nBlueShift) | 
		((((DWORD) a) >> nAlphaResidual) << nAlphaShift));
}

void
CPixelInfo::UnPack(DWORD dwPixel, BYTE *pR, BYTE *pG, BYTE *pB, BYTE *pA) const
{
	MMASSERT(pR && pG && pB && pA);

	*pR = (BYTE) (((dwPixel >> nRedShift) & (0xFF >> nRedResidual)) << nRedResidual);
	*pG = (BYTE) (((dwPixel >> nGreenShift) & (0xFF >> nGreenResidual)) << nGreenResidual);
	*pB = (BYTE) (((dwPixel >> nBlueShift) & (0xFF >> nBlueResidual)) << nBlueResidual);
	*pA = (BYTE) (((dwPixel >> nAlphaShift) & (0xFF >> nAlphaResidual)) << nAlphaResidual);
}

void
CPixelInfo::UnPack(DWORD dwPixel, BYTE *pR, BYTE *pG, BYTE *pB) const
{
	MMASSERT(pR && pG && pB);

	*pR = (BYTE)(((dwPixel >> nRedShift) & (0xFF >> nRedResidual)) << nRedResidual);
	*pG = (BYTE)(((dwPixel >> nGreenShift) & (0xFF >> nGreenResidual)) << nGreenResidual);
	*pB = (BYTE)(((dwPixel >> nBlueShift) & (0xFF >> nBlueResidual)) << nBlueResidual);
}

DWORD
CPixelInfo::TranslatePack(DWORD dwPix, const CPixelInfo &pixiSrc) const
{
	// REVIEW: this could be optimized by splitting out the cases
	DWORD dwTmp;
	dwTmp = ((((((dwPix >> pixiSrc.nRedShift) & (0xFF >> pixiSrc.nRedResidual)) 
		<< pixiSrc.nRedResidual) >> nRedResidual) << nRedShift) |
	(((((dwPix >> pixiSrc.nGreenShift) & (0xFF >> pixiSrc.nGreenResidual)) 
		<< pixiSrc.nGreenResidual) >> nGreenResidual) << nGreenShift) |
	(((((dwPix >> pixiSrc.nBlueShift) & (0xFF >> pixiSrc.nBlueResidual)) 
		<< pixiSrc.nBlueResidual) >> nBlueResidual) << nBlueShift));
	if (pixiSrc.HasAlpha())
		dwTmp |= (((((dwPix >> pixiSrc.nAlphaShift) & (0xFF >> pixiSrc.nAlphaResidual)) 
					<< pixiSrc.nAlphaResidual) >> nAlphaResidual) << nAlphaShift);
	return dwTmp;
}

WORD
CPixelInfo::Pack16(BYTE r, BYTE g, BYTE b) const
{
	MMASSERT(nBPP == 16);
	return (((((WORD) r) >> nRedResidual) << nRedShift) |
		((((WORD) g) >> nGreenResidual) << nGreenShift) |
		((((WORD) b) >> nBlueResidual) << nBlueShift));
}

WORD
CPixelInfo::Pack16(BYTE r, BYTE g, BYTE b, BYTE a) const
{
	MMASSERT(nBPP == 16);
	return (((((WORD) r) >> nRedResidual) << nRedShift) |
		((((WORD) g) >> nGreenResidual) << nGreenShift) |
		((((WORD) b) >> nBlueResidual) << nBlueShift) | 
		((((WORD) a) >> nAlphaResidual) << nAlphaShift));
}

/*
void
TestPixi()
{
	DDPIXELFORMAT ddpf;
	INIT_DXSTRUCT(ddpf);
	DWORD dwTmp = 0;
	BYTE r = 0, g = 0, b = 0, a = 0;

	MMASSERT(g_pixiPalette8 != g_ddpfBGR332);
	MMASSERT(g_pixiRGB != g_pixiBGR);
	MMASSERT(g_pixiRGB565 != g_ddpfBGR565);
	MMASSERT(g_pixiBGRA5551 == g_ddpfBGRA5551);
	MMASSERT(g_pixiBGRX != g_pixiBGRA);
	MMASSERT(g_pixiBGR != g_pixiBGRX);
	MMASSERT(g_pixiBGRA5551 != g_pixiBGR555);
	MMASSERT(g_pixiBGR332.Pack(0x00, 0xFF, 0x00) == g_ddpfBGR332.dwGBitMask);
	MMASSERT(g_pixiBGRA4444.Pack(0x00, 0x00, 0x00, 0xFF) == g_ddpfBGRA4444.dwRGBAlphaBitMask);
	MMASSERT(g_pixiBGRA5551.TranslatePack(g_pixiBGRA4444.Pack(0, 0, 0, 0xFF), g_pixiBGRA4444) == g_ddpfBGRA5551.dwRGBAlphaBitMask);
	g_pixiRGB.UnPack(g_pixiRGB.Pack(0xFF, 0, 0), &r, &g, &b, &a);
	MMASSERT((r == 0xFF) && (g == 0) && (b == 0) && (a == 0));
	g_pixiBGR332.GetDDPF(ddpf);
	MMASSERT(ddpf == g_ddpfBGR332);
	g_pixiPalette8.GetDDPF(ddpf);
	MMASSERT(ddpf == g_ddpfPalette8);
	g_pixiBGRA4444.GetDDPF(ddpf);
	MMASSERT(g_ddpfBGRA4444 == ddpf);
	g_pixiBGR565.GetDDPF(ddpf);
	MMASSERT(g_ddpfBGR565 == ddpf);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\simpdoc.cpp ===
// SimpDoc.cpp : implementation of the CSimpsonsDoc class
//

#include "stdafx.h"
#include "simpsons.h"
#include "SimpDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc

IMPLEMENT_DYNCREATE(CSimpsonsDoc, CDocument)

BEGIN_MESSAGE_MAP(CSimpsonsDoc, CDocument)
	//{{AFX_MSG_MAP(CSimpsonsDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc construction/destruction

CSimpsonsDoc::CSimpsonsDoc()
{
	m_bNoRenderFile = true;
	m_pCmds = NULL;
	m_bNeverRendered = true;
}

CSimpsonsDoc::~CSimpsonsDoc()
{
}

#define szDEFFILENAME "Simpsons.ai"

BOOL 
CSimpsonsDoc::OnNewDocument()
{
	HRESULT hr;

	if (!CDocument::OnNewDocument())
		return FALSE;

	if (m_bNoRenderFile) {
		m_bNoRenderFile = false;
		if (FAILED(hr = ParseAIFile(szDEFFILENAME, &m_pCmds))) {
			strcpy(m_szFileName, "invalid file");
			return TRUE;
		}
		strcpy(m_szFileName, szDEFFILENAME);
		m_bNeverRendered = true;
	}

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc serialization

void 
CSimpsonsDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		HRESULT hr = S_OK;
		hr = ParseAIFile(ar.m_strFileName, &m_pCmds);
		strcpy(m_szFileName, ar.m_strFileName);
		m_bNoRenderFile = FAILED(hr);
		m_bNeverRendered = true;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc diagnostics

#ifdef _DEBUG
void CSimpsonsDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CSimpsonsDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\simpdoc.h ===
// SimpDoc.h : interface of the CSimpsonsDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SIMPDOC_H__7CA4916C_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_SIMPDOC_H__7CA4916C_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "parse.h"

class CSimpsonsDoc : public CDocument
{
protected: // create from serialization only
	CSimpsonsDoc();
	DECLARE_DYNCREATE(CSimpsonsDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSimpsonsDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSimpsonsDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

private:
	RenderCmd *				m_pCmds;
	bool					m_bNoRenderFile;
	bool					m_bNeverRendered;
	char					m_szFileName[256];

public:
	const RenderCmd *		GetRenderCommands() const { return m_pCmds; }
	void					MarkRendered() { m_bNeverRendered = false; } 
	bool					HasNeverRendered() const { return m_bNeverRendered; }
	const char *			GetFileName() const { return m_szFileName; }


// Generated message map functions
protected:
	//{{AFX_MSG(CSimpsonsDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIMPDOC_H__7CA4916C_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SIMPSONS.RC
//
#define IDR_MAINFRAME				128
#define IDR_SIMPSOTYPE				129
#define IDD_ABOUTBOX				100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\simpsons.cpp ===
// simpsons.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "simpsons.h"

#include "MainFrm.h"
#include "SimpDoc.h"
#include "SimpView.h"
#include <DXTrans.h>
#include <dxtguid.c>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "../gpinit.inc"

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp

BEGIN_MESSAGE_MAP(CSimponsApp, CWinApp)
    //{{AFX_MSG_MAP(CSimponsApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp construction

CSimponsApp::CSimponsApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

CSimponsApp::~CSimponsApp()
{
}


/////////////////////////////////////////////////////////////////////////////
// The one and only CSimponsApp object

CSimponsApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp initialization

BOOL CSimponsApp::InitInstance()
{
    if (!gGdiplusInitHelper.IsValid())
    {
        return FALSE;
    }

    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    // You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CSimpsonsDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CSimpsonsView));
    AddDocTemplate(pDocTemplate);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CSimponsApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\simpsons.h ===
// simpsons.h : main header file for the SIMPSONS application
//

#if !defined(AFX_SIMPSONS_H__7CA49166_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_SIMPSONS_H__7CA49166_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp:
// See simpsons.cpp for the implementation of this class
//

class CSimponsApp : public CWinApp
{
public:
	CSimponsApp();
    ~CSimponsApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSimponsApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CSimponsApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIMPSONS_H__7CA49166_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\simpview.cpp ===
// SimpView.cpp : implementation of the CSimpsonsView class
//

#define DISABLE_CROSSDOT

#include "stdafx.h"
#include "simpsons.h"
#include "SimpDoc.h"
#include "SimpView.h"
#include "dxtrans.h"
#include "dxhelper.h"

#include <mmsystem.h>

#define fZOOMFACTOR 0.03f
#define fSCALEMIN 0.4f
#define fSCALEMAX 2.5f

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Flatten to an error of 2/3.  During initial phase, use 18.14 format.

#define TEST_MAGNITUDE_INITIAL    (6 * 0x00002aa0L)

// Error of 2/3.  During normal phase, use 15.17 format.

#define TEST_MAGNITUDE_NORMAL     (TEST_MAGNITUDE_INITIAL << 3)

// 'FIX' is a 28.4 fixed point type:

#define FIX_SCALE 16
typedef LONG FIX;
typedef POINT POINTFIX;
typedef struct _RECTFX
{
    FIX   xLeft;
    FIX   yTop;
    FIX   xRight;
    FIX   yBottom;
} RECTFX, *PRECTFX;

#define MIN(A,B)    ((A) < (B) ?  (A) : (B))
#define MAX(A,B)    ((A) > (B) ?  (A) : (B))
#define ABS(A)      ((A) <  0  ? -(A) : (A))

// Hacky macro which returns the current test case's attribute array

#define ThisTestCase (TC::testCases[m_testCaseNumber])

// Test case combinations
//
// We enumerate every test case in a table so that we can cycle through
// all of them.

namespace TC {
    // Names for each test case attribute
    enum {At_Library, At_Source, At_Destination, At_Aliasing};
    const char *AttributeStr[] = {
        "Library", "Source", "Dest", "Aliasing"
    };
    const int NumAttributes = (sizeof(AttributeStr)/sizeof(AttributeStr[0]));
    typedef int TestCase[NumAttributes];
    
    // For each attribute, names for each option:
    enum {Meta, GDIP, GDI};                           // At_Library
    enum {Native, FromMetafile, CreatePoly, PathAPI}; // At_Source
    enum {Memory, Screen, ToMetafile};                // At_Destination
    enum {Aliased, Antialiased};                      // At_Aliasing

    const char *OptionStr[NumAttributes][4] = {
        "Meta", "GDI+", "GDI", "",
        "Native", "Metafile", "CreatePoly", "PathAPI",
        "Memory", "Screen", "Metafile", "",
        "Aliased", "AA", "", ""
    };

    // Supported options for each library:
    //
    // GDI+:  At_Source      - Native, FromMetafile, PathAPI
    //        At_Destination - Memory, Screen, ToMetafile
    //        At_Aliasing    - Aliased, Antialiased
    //
    // Meta:  At_Source      - Native
    //        At_Destination - Memory, Screen
    //        At_Aliasing    - Antialiased
    //
    // GDI:   At_Source      - PathAPI, CreatePoly, FromMetafile
    //        At_Destination - Memory, Screen, ToMetafile
    //        At_Aliasing    - Aliased
    
    const TestCase testCases[] = {
    //  Library  Source         Destination  Aliasing
        GDIP,    Native,        Memory,      Antialiased,
        GDIP,    Native,        Screen,      Antialiased,
        GDIP,    Native,        Memory,      Aliased,
        GDIP,    Native,        Screen,      Aliased,

        GDIP,    Native,        ToMetafile,  Antialiased,
        GDIP,    FromMetafile,  Memory,      Antialiased,
        
        GDIP,    PathAPI,       Memory,      Antialiased,

        Meta,    Native,        Memory,      Antialiased,
        Meta,    Native,        Screen,      Antialiased,
                               
        GDI,     CreatePoly,    Memory,      Aliased,
        GDI,     CreatePoly,    Screen,      Aliased,

        GDI,     CreatePoly,    ToMetafile,  Aliased,
        GDI,     FromMetafile,  Memory,      Aliased,
        
        GDI,     PathAPI,       Memory,      Aliased,
    };
    const int numTestCases = (sizeof(testCases)/(sizeof(testCases[0])));
};

// Test results, used when we cycle automatically through all test combinations
// Hack: This should be a member of CSimpsonView, but I kept it here to reduce
// compile time when we add a test case.

DWORD timingResults[TC::numTestCases];

// IncrementAttribute(int): Changes the rendering attributes
//   Advances to the next test case which is different in the given
//   attribute. Unless the attribute is TC::At_Library, will only advance to a 
//   case which is identical in all other attributes.
//
//   If there is none, doesn't do anything.
//
// Returns: false if the test case didn't change

bool CSimpsonsView::IncrementAttribute(int attribute) {
    int startValue=m_testCaseNumber;
    int i;

    while (1) {
        // Increment the test case number, with wraparound
        m_testCaseNumber++;
        if (m_testCaseNumber >= TC::numTestCases) m_testCaseNumber = 0;

        // If we've returned to the case we started on, no suitable
        // case was found
        if (m_testCaseNumber == startValue) return false;

        // Continue searching if the attribute for this case is the same
        if (TC::testCases[startValue][attribute] == 
            TC::testCases[m_testCaseNumber][attribute]) continue;

        // If we're incrementing the library attribute, we've found what
        // we need. 
        if (attribute == TC::At_Library) break;

        // Otherwise, we need to continue if this case isn't identical
        // in the other attributes
        
        for (i=0; i<TC::NumAttributes; i++) {
            if (i==attribute) continue;
            if (TC::testCases[startValue][i] !=
                TC::testCases[m_testCaseNumber][i]) break;
        }

        // If all other attributes were identical, end the search
        if (i==TC::NumAttributes) break;
    }
    
    return true;
}

// IncrementTest(): Cycles through the possible combinations of attributes
//   Each call changes one of the test attributes.
//   Returns true when the cycle is done.

bool CSimpsonsView::IncrementTest() {
    UpdateStatusMessage();

    // Store the timing for the current test.
    timingResults[m_testCaseNumber] = m_dwRenderTime;

    m_testCaseNumber++;
    if (m_testCaseNumber == TC::numTestCases) m_testCaseNumber = 0;

    return m_testCaseNumber==0;
}

void CSimpsonsView::PrintTestResults() {
    int i,j;

    printf("\n");
    for (i=0;i<TC::NumAttributes;i++) {
        printf("%-11s", TC::AttributeStr[i]);
    }
    printf("   Time\n\n");

    for (i=0;i<TC::numTestCases;i++) {
        for (j=0;j<TC::NumAttributes;j++) {
            printf("%-11s", TC::OptionStr[j][TC::testCases[i][j]]);
        }
        printf("   %dms\n", timingResults[i]);
    }
    printf("\n");
};

DWORD g_aColors[] =
{
    0xFF000000,
    0xFF0000FF,
    0xFF00FF00,
    0xFF00FFFF,
    0xFFFF0000,
    0xFFFF00FF,
    0xFFFFFF00,
    0xFFFFFFFF,
    0xFFAAAAAA,
    0xFF444444
};
const ULONG NumColors = sizeof(g_aColors) / sizeof(g_aColors[0]);
ULONG g_ulColorIndex = 8;

/**********************************Class***********************************\
* class HFDBASIS32
*
*   Class for HFD vector objects.
*
* Public Interface:
*
*   vInit(p1, p2, p3, p4)       - Re-parameterizes the given control points
*                                 to our initial HFD error basis.
*   vLazyHalveStepSize(cShift)  - Does a lazy shift.  Caller has to remember
*                                 it changes 'cShift' by 2.
*   vSteadyState(cShift)        - Re-parameterizes to our working normal
*                                 error basis.
*
*   vTakeStep()                 - Forward steps to next sub-curve
*   vHalveStepSize()            - Adjusts down (subdivides) the sub-curve
*   vDoubleStepSize()           - Adjusts up the sub-curve
*   lError()                    - Returns error if current sub-curve were
*                                 to be approximated using a straight line
*                                 (value is actually multiplied by 6)
*   fxValue()                   - Returns rounded coordinate of first point in
*                                 current sub-curve.  Must be in steady
*                                 state.
*
* History:
*  10-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

class HFDBASIS32
{
private:
    LONG  e0;
    LONG  e1;
    LONG  e2;
    LONG  e3;

public:
    VOID  vInit(FIX p1, FIX p2, FIX p3, FIX p4);
    VOID  vLazyHalveStepSize(LONG cShift);
    VOID  vSteadyState(LONG cShift);
    VOID  vHalveStepSize();
    VOID  vDoubleStepSize();
    VOID  vTakeStep();

    LONG  lParentErrorDividedBy4() { return(MAX(ABS(e3), ABS(e2 + e2 - e3))); }
    LONG  lError()                 { return(MAX(ABS(e2), ABS(e3))); }
    FIX   fxValue()                { return((e0 + (1L << 12)) >> 13); }
};

/**********************************Class***********************************\
* class BEZIER32
*
*   Bezier cracker.
*
* A hybrid cubic Bezier curve flattener based on KirkO's error factor.
* Generates line segments fast without using the stack.  Used to flatten
* a path.
*
* For an understanding of the methods used, see:
*
*     Kirk Olynyk, "..."
*     Goossen and Olynyk, "System and Method of Hybrid Forward
*         Differencing to Render Bezier Splines"
*     Lien, Shantz and Vaughan Pratt, "Adaptive Forward Differencing for
*     Rendering Curves and Surfaces", Computer Graphics, July 1987
*     Chang and Shantz, "Rendering Trimmed NURBS with Adaptive Forward
*         Differencing", Computer Graphics, August 1988
*     Foley and Van Dam, "Fundamentals of Interactive Computer Graphics"
*
* This algorithm is protected by U.S. patents 5,363,479 and 5,367,617.
*
* Public Interface:
*
*   vInit(pptfx)                - pptfx points to 4 control points of
*                                 Bezier.  Current point is set to the first
*                                 point after the start-point.
*   BEZIER32(pptfx)             - Constructor with initialization.
*   vGetCurrent(pptfx)          - Returns current polyline point.
*   bCurrentIsEndPoint()        - TRUE if current point is end-point.
*   vNext()                     - Moves to next polyline point.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

class BEZIER32
{
public:
    LONG       cSteps;
    HFDBASIS32 x;
    HFDBASIS32 y;
    RECTFX     rcfxBound;

    BOOL bInit(POINTFIX* aptfx, RECTFX*);
    BOOL bNext(POINTFIX* pptfx);
};


#define INLINE inline

INLINE BOOL bIntersect(RECTFX* prcfx1, RECTFX* prcfx2)
{
    BOOL bRet = (prcfx1->yTop <= prcfx2->yBottom &&
                 prcfx1->yBottom >= prcfx2->yTop &&
                 prcfx1->xLeft <= prcfx2->xRight &&
                 prcfx1->xRight >= prcfx2->xLeft);
    return(bRet);
}

INLINE VOID vBoundBox(POINTFIX* aptfx, RECTFX* prcfx)
{
    if (aptfx[0].x >= aptfx[1].x)
        if (aptfx[2].x >= aptfx[3].x)
        {
            prcfx->xLeft  = MIN(aptfx[1].x, aptfx[3].x);
            prcfx->xRight = MAX(aptfx[0].x, aptfx[2].x);
        }
        else
        {
            prcfx->xLeft  = MIN(aptfx[1].x, aptfx[2].x);
            prcfx->xRight = MAX(aptfx[0].x, aptfx[3].x);
        }
    else
        if (aptfx[2].x <= aptfx[3].x)
        {
            prcfx->xLeft  = MIN(aptfx[0].x, aptfx[2].x);
            prcfx->xRight = MAX(aptfx[1].x, aptfx[3].x);
        }
        else
        {
            prcfx->xLeft  = MIN(aptfx[0].x, aptfx[3].x);
            prcfx->xRight = MAX(aptfx[1].x, aptfx[2].x);
        }

    if (aptfx[0].y >= aptfx[1].y)
        if (aptfx[2].y >= aptfx[3].y)
        {
            prcfx->yTop    = MIN(aptfx[1].y, aptfx[3].y);
            prcfx->yBottom = MAX(aptfx[0].y, aptfx[2].y);
        }
        else
        {
            prcfx->yTop    = MIN(aptfx[1].y, aptfx[2].y);
            prcfx->yBottom = MAX(aptfx[0].y, aptfx[3].y);
        }
    else
        if (aptfx[2].y <= aptfx[3].y)
        {
            prcfx->yTop    = MIN(aptfx[0].y, aptfx[2].y);
            prcfx->yBottom = MAX(aptfx[1].y, aptfx[3].y);
        }
        else
        {
            prcfx->yTop    = MIN(aptfx[0].y, aptfx[3].y);
            prcfx->yBottom = MAX(aptfx[1].y, aptfx[2].y);
        }
}

INLINE VOID HFDBASIS32::vInit(FIX p1, FIX p2, FIX p3, FIX p4)
{
// Change basis and convert from 28.4 to 18.14 format:

    e0 = (p1                     ) << 10;
    e1 = (p4 - p1                ) << 10;
    e2 = (3 * (p2 - p3 - p3 + p4)) << 11;
    e3 = (3 * (p1 - p2 - p2 + p3)) << 11;
}

INLINE VOID HFDBASIS32::vLazyHalveStepSize(LONG cShift)
{
    e2 = (e2 + e3) >> 1;
    e1 = (e1 - (e2 >> cShift)) >> 1;
}

INLINE VOID HFDBASIS32::vSteadyState(LONG cShift)
{
// We now convert from 18.14 fixed format to 15.17:

    e0 <<= 3;
    e1 <<= 3;

    register LONG lShift = cShift - 3;

    if (lShift < 0)
    {
        lShift = -lShift;
        e2 <<= lShift;
        e3 <<= lShift;
    }
    else
    {
        e2 >>= lShift;
        e3 >>= lShift;
    }
}

INLINE VOID HFDBASIS32::vHalveStepSize()
{
    e2 = (e2 + e3) >> 3;
    e1 = (e1 - e2) >> 1;
    e3 >>= 2;
}

INLINE VOID HFDBASIS32::vDoubleStepSize()
{
    e1 += e1 + e2;
    e3 <<= 2;
    e2 = (e2 << 3) - e3;
}

INLINE VOID HFDBASIS32::vTakeStep()
{
    e0 += e1;
    register LONG lTemp = e2;
    e1 += lTemp;
    e2 += lTemp - e3;
    e3 = lTemp;
}

typedef struct _BEZIERCONTROLS {
    POINTFIX ptfx[4];
} BEZIERCONTROLS;

BOOL BEZIER32::bInit(
POINTFIX* aptfxBez,     // Pointer to 4 control points
RECTFX* prcfxClip)      // Bound box of visible region (optional)
{
    POINTFIX aptfx[4];
    LONG cShift = 0;    // Keeps track of 'lazy' shifts

    cSteps = 1;         // Number of steps to do before reach end of curve

    vBoundBox(aptfxBez, &rcfxBound);

    *((BEZIERCONTROLS*) aptfx) = *((BEZIERCONTROLS*) aptfxBez);

    {
        register FIX fxOr;
        register FIX fxOffset;

        fxOffset = rcfxBound.xLeft;
        fxOr  = (aptfx[0].x -= fxOffset);
        fxOr |= (aptfx[1].x -= fxOffset);
        fxOr |= (aptfx[2].x -= fxOffset);
        fxOr |= (aptfx[3].x -= fxOffset);

        fxOffset = rcfxBound.yTop;
        fxOr |= (aptfx[0].y -= fxOffset);
        fxOr |= (aptfx[1].y -= fxOffset);
        fxOr |= (aptfx[2].y -= fxOffset);
        fxOr |= (aptfx[3].y -= fxOffset);

    // This 32 bit cracker can only handle points in a 10 bit space:

        if ((fxOr & 0xffffc000) != 0)
            return(FALSE);
    }

    x.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    y.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

    if (prcfxClip == (RECTFX*) NULL || bIntersect(&rcfxBound, prcfxClip))
    {
        while (TRUE)
        {
            register LONG lTestMagnitude = TEST_MAGNITUDE_INITIAL << cShift;

            if (x.lError() <= lTestMagnitude && y.lError() <= lTestMagnitude)
                break;

            cShift += 2;
            x.vLazyHalveStepSize(cShift);
            y.vLazyHalveStepSize(cShift);
            cSteps <<= 1;
        }
    }

    x.vSteadyState(cShift);
    y.vSteadyState(cShift);

// Note that this handles the case where the initial error for
// the Bezier is already less than TEST_MAGNITUDE_NORMAL:

    x.vTakeStep();
    y.vTakeStep();
    cSteps--;

    return(TRUE);
}

BOOL BEZIER32::bNext(POINTFIX* pptfx)
{
// Return current point:

    pptfx->x = x.fxValue() + rcfxBound.xLeft;
    pptfx->y = y.fxValue() + rcfxBound.yTop;

// If cSteps == 0, that was the end point in the curve!

    if (cSteps == 0)
        return(FALSE);

// Okay, we have to step:

    if (MAX(x.lError(), y.lError()) > TEST_MAGNITUDE_NORMAL)
    {
        x.vHalveStepSize();
        y.vHalveStepSize();
        cSteps <<= 1;
    }

    while (!(cSteps & 1) &&
           x.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2) &&
           y.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2))
    {
        x.vDoubleStepSize();
        y.vDoubleStepSize();
        cSteps >>= 1;
    }

    cSteps--;
    x.vTakeStep();
    y.vTakeStep();

    return(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView

IMPLEMENT_DYNCREATE(CSimpsonsView, CView)

BEGIN_MESSAGE_MAP(CSimpsonsView, CView)
    //{{AFX_MSG_MAP(CSimpsonsView)
    ON_WM_SIZE()
    ON_WM_LBUTTONUP()
    ON_WM_LBUTTONDOWN()
    ON_WM_KEYDOWN()
    ON_WM_RBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_MOUSEWHEEL()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView construction/destruction

CSimpsonsView::CSimpsonsView()
: m_sizWin(0, 0)
{
    m_pDD = NULL;
    m_pddsScreen = NULL;
    m_pSurfFactory = NULL;
    m_pDX2D = NULL;
    m_pDX2DScreen = NULL;
    m_pDX2DDebug = NULL;
    m_CycleTests = false;
    m_testCaseNumber = 0;
    m_bIgnoreStroke = m_bIgnoreFill = false;
    m_dwRenderTime = 0;
    m_gpPathArray = NULL;

    m_XForm.SetIdentity();
    m_centerPoint.x = m_centerPoint.y = 0;
    m_lastPoint.x = m_lastPoint.y = 0;
    m_tracking = m_scaling = false;
    m_bLButton = false;
}

CSimpsonsView::~CSimpsonsView()
{
    if (m_gpPathArray) delete [] m_gpPathArray;

    MMRELEASE(m_pDD);
    MMRELEASE(m_pddsScreen);
    MMRELEASE(m_pSurfFactory);
    MMRELEASE(m_pDX2D);
    MMRELEASE(m_pDX2DScreen);
    MMRELEASE(m_pDX2DDebug);
    CoUninitialize();
}


BOOL 
CSimpsonsView::PreCreateWindow(CREATESTRUCT &cs) 
{
    HRESULT hr = S_OK;
    IDXTransformFactory *pTranFact = NULL;
    IDirectDrawFactory *pDDrawFact = NULL;
    IDirectDraw *pDD = NULL;
    
    if (CView::PreCreateWindow(cs) == false)
        return false;

    CHECK_HR(hr = CoInitialize(NULL));
    
    //--- Create the transform factory
    CHECK_HR(hr = ::CoCreateInstance(CLSID_DXTransformFactory, NULL, CLSCTX_INPROC,
                        IID_IDXTransformFactory, (void **) &pTranFact));
    
    CHECK_HR(hr = ::CoCreateInstance(CLSID_DX2D, NULL, CLSCTX_INPROC,
                        IID_IDX2D, (void **) &m_pDX2D));
    
    CHECK_HR(hr = ::CoCreateInstance(CLSID_DX2D, NULL, CLSCTX_INPROC,
                        IID_IDX2D, (void **) &m_pDX2DScreen));

/*  m_pDX2D->QueryInterface(IID_IDX2DDebug, (void **) &m_pDX2DDebug);*/
    
    CHECK_HR(hr = m_pDX2D->SetTransformFactory(pTranFact));
    CHECK_HR(hr = m_pDX2DScreen->SetTransformFactory(pTranFact));
    
    CHECK_HR(hr = pTranFact->QueryInterface(IID_IDXSurfaceFactory, (void **) &m_pSurfFactory));
    
    //--- Create the direct draw object
    CHECK_HR(hr = ::CoCreateInstance(CLSID_DirectDrawFactory, NULL, CLSCTX_INPROC,
                        IID_IDirectDrawFactory, (void **) &pDDrawFact));
    
    CHECK_HR(hr = pDDrawFact->CreateDirectDraw( NULL, m_hWnd, DDSCL_NORMAL, 0, NULL, &pDD));
    CHECK_HR(hr = pDD->QueryInterface( IID_IDirectDraw3, (void **) &m_pDD));
    
    // Create the primary ddraw surface (m_pddsScreen)
    
    DDSURFACEDESC ddsd; 
    ZeroMemory(&ddsd, sizeof(ddsd)); 
    ddsd.dwSize = sizeof(ddsd); 
    ddsd.dwFlags = DDSD_CAPS; 
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; 
                     
    CHECK_HR(hr = m_pDD->CreateSurface(&ddsd, &m_pddsScreen, NULL));
    CHECK_HR(hr = m_pDX2DScreen->SetSurface(m_pddsScreen));

e_Exit:
    MMRELEASE(pTranFact);
    MMRELEASE(pDDrawFact);
    MMRELEASE(pDD);
    
    return (hr == S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView drawing

void 
CSimpsonsView::OnSize(UINT nType, int cx, int cy) 
{
//  MMTRACE("OnSize\n");
    m_centerPoint.x = cx / 2;
    m_centerPoint.y = cy / 2;
    CView::OnSize(nType, cx, cy);
}

HRESULT
CSimpsonsView::Resize(DWORD nX, DWORD nY)
{
//  MMTRACE("Resize\n");
    HRESULT hr;
    IDirectDrawSurface *pdds = NULL;
    CDXDBnds Bnds;

    MMASSERT(nX && nY);

    // store the new size
    m_sizWin.cx = nX;
    m_sizWin.cy = nY;
    Bnds.SetXYSize(m_sizWin);
    
    CHECK_HR(hr = m_pSurfFactory->CreateSurface(m_pDD, NULL, &DDPF_PMARGB32, &Bnds, 0,
                        NULL, IID_IDXSurface, (void **) &pdds));
    CHECK_HR(hr = m_pDX2D->SetSurface(pdds));

    // render the image to the backbuffer
    CHECK_HR(hr = Render(true));

    // Hack: Get the client rect in screen coordinates. My hacky way of doing
    // this is to get the window rect and adjust it.
    GetWindowRect(&m_clientRectHack);
    
    m_clientRectHack.left  += 2; m_clientRectHack.top    += 2;
    m_clientRectHack.right -= 2; m_clientRectHack.bottom -= 2;
    CHECK_HR(hr = m_pDX2DScreen->SetClipRect(&m_clientRectHack));

e_Exit:
    MMRELEASE(pdds);

    return hr;
}


void 
CSimpsonsView::OnDraw(CDC *pDC)
{
//  MMTRACE("OnDraw\n");

    HRESULT hr;
    HDC hdcSurf = NULL;
    IDirectDrawSurface *pdds = NULL;
    DDSURFACEDESC ddsd;
    RECT rDim;

    UpdateStatusMessage();
    
    // get the size of the invalid area
    GetClientRect(&rDim);
    if ((rDim.left == rDim.right) || (rDim.top == rDim.bottom))
        return;

    CSimpsonsDoc *pDoc = GetDocument();

    // if this is a new document, build the GDI+ path list
    if (pDoc->HasNeverRendered()) BuildGDIPList();
    
    // check if the back buffer has changed size
    if (pDoc->HasNeverRendered() || (rDim.right != m_sizWin.cx) || (rDim.bottom != m_sizWin.cy)) {
        ResetTransform();
        CHECK_HR(hr = Resize(rDim.right, rDim.bottom));
        pDoc->MarkRendered();
    }

    ddsd.dwSize = sizeof(ddsd);

        CHECK_HR(hr = m_pDX2D->GetSurface(IID_IDirectDrawSurface, (void **) &pdds));
        CHECK_HR(hr = pdds->GetSurfaceDesc(&ddsd));
        CHECK_HR(hr = pdds->GetDC(&hdcSurf));
        ::BitBlt(pDC->m_hDC, 0, 0, ddsd.dwWidth, ddsd.dwHeight, hdcSurf, 0, 0, SRCCOPY);

    e_Exit:
        if (hdcSurf) {
            pdds->ReleaseDC( hdcSurf );
        }
        MMRELEASE(pdds);
}

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView diagnostics

#ifdef _DEBUG
void CSimpsonsView::AssertValid() const
{
    CView::AssertValid();
}

void CSimpsonsView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CSimpsonsDoc* CSimpsonsView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CSimpsonsDoc)));
    return (CSimpsonsDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView message handlers

#include "ddhelper.h"

typedef DWORD FP;
#define nEXPBIAS    127
#define nEXPSHIFTS  23
#define nEXPLSB     (1 << nEXPSHIFTS)
#define maskMANT    (nEXPLSB - 1)
#define FloatToFixedNoScale(nDst, fSrc) MACSTART \
    float fTmp = fSrc; \
    DWORD nRaw = *((FP *) &(fTmp)); \
    if (nRaw < (nEXPBIAS << nEXPSHIFTS)) \
        nDst = 0; \
    else \
        nDst = ((nRaw | nEXPLSB) << 8) >> ((nEXPBIAS + 31) - (nRaw >> nEXPSHIFTS)); \
MACEND

// This routine converts a 'float' to 28.4 fixed point format.

inline FIX
FloatToFix(float f)
{
    FIX i;
    FloatToFixedNoScale(i, f*FIX_SCALE);
    return(i);
}

/*
    Draw a polygon with GDI. This version flattens beziers and packages
    the polygon up into a single polypoly call. (Compare to DrawGDIPolyPathAPI)
*/

void
CSimpsonsView::DrawGDIPoly(HDC hDC, PolyInfo *pPoly)
{
    POINT rgpt[1024];
    DWORD rgcpt[30];
    DWORD cPoints = pPoly->cPoints;
    BEZIER32 bez;
    POINTFIX aptfxBez[4];
    MMASSERT(cPoints);

    DWORD *pcptBuffer;
    POINT *pptBuffer;
    POINT *pptFigure;

    DXFPOINT *pCurPoint = pPoly->pPoints;
    DXFPOINT *pCurPointLimit = pPoly->pPoints + cPoints;
    BYTE *pCurCode = pPoly->pCodes;

    pptBuffer = rgpt;
    pptFigure = rgpt;
    pcptBuffer = rgcpt;

    // In an effort to reduce our per-call overhead, we try to avoid
    // calling GDI's BeginPath/EndPath/FillPath routines, because they
    // just add significant time when the drawing is small.  Instead,
    // we package everything up into PolyPoly calls that will draw
    // immediately.

    while (TRUE)
    {
        if (*pCurCode == PT_BEZIERTO)
        {
            aptfxBez[0].x = FloatToFix((pCurPoint-1)->x);
            aptfxBez[0].y = FloatToFix((pCurPoint-1)->y);
            aptfxBez[1].x = FloatToFix((pCurPoint)->x);
            aptfxBez[1].y = FloatToFix((pCurPoint)->y);
            aptfxBez[2].x = FloatToFix((pCurPoint+1)->x);
            aptfxBez[2].y = FloatToFix((pCurPoint+1)->y);
            aptfxBez[3].x = FloatToFix((pCurPoint+2)->x);
            aptfxBez[3].y = FloatToFix((pCurPoint+2)->y);

            if (bez.bInit(aptfxBez, NULL))
            {
                while (bez.bNext(pptBuffer++))
                    ;
            }

            pCurPoint += 3;
            pCurCode += 3;
        }
        else
        {
            pptBuffer->x = FloatToFix(pCurPoint->x);
            pptBuffer->y = FloatToFix(pCurPoint->y);

            pptBuffer++;
            pCurPoint++;
            pCurCode++;
        }

        if (pCurPoint == pCurPointLimit)
        {
            *pcptBuffer++ = (DWORD)(pptBuffer - pptFigure);
            break;
        }

        if (*pCurCode == PT_MOVETO)
        {
            *pcptBuffer++ = (DWORD)(pptBuffer - pptFigure);
            pptFigure = pptBuffer;
        }
    } 

    if (pPoly->dwFlags & DX2D_FILL)
    {
        if (!m_bNullPenSelected)
        {
            SelectObject(hDC, m_hNullPen);
            m_bNullPenSelected = TRUE;
        }

        PolyPolygon(hDC, rgpt, (INT*) rgcpt, (int) (pcptBuffer - rgcpt));
    }
    else
    {
        if (m_bNullPenSelected)
        {
            SelectObject(hDC, m_hStrokePen);
            m_bNullPenSelected = FALSE;
        }

        PolyPolyline(hDC, rgpt, rgcpt, (DWORD) (pcptBuffer - rgcpt));
    }
}

/*
    Same as DrawGDIPoly, but uses the slow GDI path functions.
*/

void
CSimpsonsView::DrawGDIPolyPathAPI(HDC hDC, PolyInfo *pPoly)
{
    POINTFIX aptfxBez[3];
    POINTFIX pt;

    DXFPOINT *pCurPoint = pPoly->pPoints;
    DXFPOINT *pCurPointLimit = pPoly->pPoints + pPoly->cPoints;
    BYTE *pCurCode = pPoly->pCodes;
    
    BeginPath(hDC);

    while (pCurPoint < pCurPointLimit) {
        switch (*pCurCode) {
        
        case PT_BEZIERTO:
            
            aptfxBez[0].x = FloatToFix((pCurPoint)->x);
            aptfxBez[0].y = FloatToFix((pCurPoint)->y);
            aptfxBez[1].x = FloatToFix((pCurPoint+1)->x);
            aptfxBez[1].y = FloatToFix((pCurPoint+1)->y);
            aptfxBez[2].x = FloatToFix((pCurPoint+2)->x);
            aptfxBez[2].y = FloatToFix((pCurPoint+2)->y);

            PolyBezierTo(hDC, aptfxBez, 3);

            pCurPoint += 3;
            pCurCode += 3;
            break;
        
        case PT_LINETO:
            pt.x = FloatToFix(pCurPoint->x);
            pt.y = FloatToFix(pCurPoint->y);

            PolylineTo(hDC, &pt, 1);

            pCurPoint++;
            pCurCode++;
            break;
        
        case PT_MOVETO:
            MoveToEx(hDC, 
                     FloatToFix(pCurPoint->x), 
                     FloatToFix(pCurPoint->y),
                     NULL);
            pCurPoint++;
            pCurCode++;
            break;
        }
    } 

    EndPath(hDC);

    if (pPoly->dwFlags & DX2D_FILL)
    {
        if (!m_bNullPenSelected)
        {
            SelectObject(hDC, m_hNullPen);
            m_bNullPenSelected = TRUE;
        }
        FillPath(hDC);
    }
    else
    {
        if (m_bNullPenSelected)
        {
            SelectObject(hDC, m_hStrokePen);
            m_bNullPenSelected = FALSE;
        }
        StrokePath(hDC);
    }
}

/*
    Draw the scene using GDI.
*/

void 
CSimpsonsView::DrawAllGDI(HDC hDC)
{
    DWORD nStart, nEnd;

    int dataSource = ThisTestCase[TC::At_Source];

    nStart = timeGetTime();

    HPEN hpenOld;
    HBRUSH hbrushOld;
    HGDIOBJ hBrush;
    
    HDC hdcOutput;

    const RenderCmd *pCurCmd = GetDocument()->GetRenderCommands();

    if (pCurCmd == NULL)
        return;

    PolyInfo *pPoly;
    BrushInfo *pBrush;
    PenInfo *pPen;

    m_hNullPen = (HPEN) GetStockObject(NULL_PEN);
    m_bNullPenSelected = TRUE;

    if (ThisTestCase[TC::At_Destination]==TC::ToMetafile) {
        // Determine the picture frame dimensions. 
        // iWidthMM is the display width in millimeters. 
        // iHeightMM is the display height in millimeters. 
        // iWidthPels is the display width in pixels. 
        // iHeightPels is the display height in pixels 
         
        LONG iWidthMM = GetDeviceCaps(hDC, HORZSIZE); 
        LONG iHeightMM = GetDeviceCaps(hDC, VERTSIZE); 
        LONG iWidthPels = GetDeviceCaps(hDC, HORZRES); 
        LONG iHeightPels = GetDeviceCaps(hDC, VERTRES); 

        // Hack the client rect         
         
        RECT rect={0, 0, 500, 500};
         
        // Convert client coordinates to .01-mm units. 
        // Use iWidthMM, iWidthPels, iHeightMM, and 
        // iHeightPels to determine the number of 
        // .01-millimeter units per pixel in the x- 
        //  and y-directions. 
 
        rect.left = (rect.left * iWidthMM * 100)/iWidthPels; 
        rect.top = (rect.top * iHeightMM * 100)/iHeightPels; 
        rect.right = (rect.right * iWidthMM * 100)/iWidthPels; 
        rect.bottom = (rect.bottom * iHeightMM * 100)/iHeightPels; 
 
        hdcOutput = CreateEnhMetaFile(hDC, "simpgdi.emf", &rect, NULL);
        if (!hdcOutput) { return; }
    } else {
        hdcOutput = hDC;
    }

    if (dataSource==TC::FromMetafile) {
        HENHMETAFILE hemf = GetEnhMetaFile("simpgdi.emf"); 

        if (hemf) {
            RECT rect = {0, 0, 500, 500};
             
            PlayEnhMetaFile(hdcOutput, hemf, &rect);
            DeleteEnhMetaFile(hemf); 
        } else {
            printf("Metafile didn't load!\n");
        }
    } else {
        HGDIOBJ hOldBrush = SelectObject(hdcOutput, GetStockObject(WHITE_BRUSH));
        HGDIOBJ hOldPen = SelectObject(hdcOutput, m_hNullPen);
    
        // Here we set a 1/16th shrinking transform.  We will have to 
        // scale up all the points we give GDI by a factor of 16.
        //
        // We do this because when set in advanced mode, NT's GDI can
        // rasterize with 28.4 precision, and since we have factional
        // coordinates, this will make the result look better on NT.
        //
        // (There will be no difference on Win9x.)
    
        SetGraphicsMode(hdcOutput, GM_ADVANCED);
        SetMapMode(hdcOutput, MM_ANISOTROPIC);
        SetWindowExtEx(hdcOutput, FIX_SCALE, FIX_SCALE, NULL);
        
        for (;pCurCmd->nType != typeSTOP; pCurCmd++) {
            switch (pCurCmd->nType) {
            case typePOLY:
                // draw the polygon
                pPoly = (PolyInfo *) pCurCmd->pvData;
                if (!((m_bIgnoreStroke && (pPoly->dwFlags & DX2D_STROKE)) ||
                        (m_bIgnoreFill && (pPoly->dwFlags & DX2D_FILL))))
                {
                    if (dataSource == TC::PathAPI) {
                        DrawGDIPolyPathAPI(hdcOutput, (PolyInfo *) pCurCmd->pvData);
                    } else {
                        ASSERT(dataSource == TC::CreatePoly);
                        DrawGDIPoly(hdcOutput, (PolyInfo *) pCurCmd->pvData);
                    }
                }
                break;
            case typeBRUSH:
                // select a new brush
                {
                    pBrush = (BrushInfo *) pCurCmd->pvData;
                    DWORD dwColor = pBrush->Color;
                    BYTE r = BYTE(dwColor >> 16);
                    BYTE g = BYTE(dwColor >> 8);
                    BYTE b = BYTE(dwColor);
                    hBrush = CreateSolidBrush(RGB(r,g,b));
                    hbrushOld = (HBRUSH) SelectObject(hdcOutput, hBrush);
                    DeleteObject(hbrushOld);
                }
                break;
            case typePEN: 
                // select a new pen
                {
                    pPen = (PenInfo *) pCurCmd->pvData;
                    DWORD dwColor = pPen->Color;
                    BYTE r = BYTE(dwColor >> 16);
                    BYTE g = BYTE(dwColor >> 8);
                    BYTE b = BYTE(dwColor);
                    hpenOld = m_hStrokePen;
                    m_hStrokePen = CreatePen(PS_SOLID, 
                                             DWORD(pPen->fWidth * FIX_SCALE), 
                                             RGB(r, g, b));
                    if (!m_bNullPenSelected)
                    {
                        SelectObject(hdcOutput, m_hStrokePen);
                    }
                    DeleteObject(hpenOld);
                }
                break;
            }
        }
        
        SetMapMode(hdcOutput, MM_TEXT);
        SetGraphicsMode(hdcOutput, GM_COMPATIBLE);
    
        hbrushOld = (HBRUSH) SelectObject(hdcOutput, hOldBrush);
        hpenOld = (HPEN) SelectObject(hdcOutput, hOldPen);
    
        DeleteObject(hbrushOld);
        DeleteObject(hpenOld);
        DeleteObject(m_hStrokePen);
    }
    
    nEnd = timeGetTime();
    m_dwRenderTime = nEnd-nStart;
    
    if (ThisTestCase[TC::At_Destination]==TC::ToMetafile) {
        DeleteEnhMetaFile(CloseEnhMetaFile(hdcOutput));
    }    
    
}

void
CSimpsonsView::DrawGDIPPoly(Graphics *g, PolyInfo *pPoly, Pen *pen, Brush *brush)
{
    GraphicsPath path(FillModeAlternate);
    
    DXFPOINT *pCurPoint = pPoly->pPoints;
        
    DXFPOINT *pCurPointLimit = pPoly->pPoints + pPoly->cPoints;
    BYTE *pCurCode = pPoly->pCodes;
    
    DXFPOINT currentPosition;

    while (pCurPoint < pCurPointLimit)
    {
        switch (*pCurCode) 
        {
        
        case PT_BEZIERTO:
            path.AddBezier(
                (pCurPoint-1)->x, (pCurPoint-1)->y,
                (pCurPoint)  ->x, (pCurPoint)  ->y,
                (pCurPoint+1)->x, (pCurPoint+1)->y,
                (pCurPoint+2)->x, (pCurPoint+2)->y);

            pCurPoint += 3;
            pCurCode += 3;
            break;

        case PT_MOVETO:
            path.StartFigure();
            pCurPoint++;
            pCurCode++;
            break;
        
        case PT_LINETO:
            path.AddLine(
                (pCurPoint-1)->x, 
                (pCurPoint-1)->y, 
                (pCurPoint)->x,
                (pCurPoint)->y);
            pCurPoint++;
            pCurCode++;
            break;
    
        }
    } 

    if (pPoly->dwFlags & DX2D_FILL)
    {
        g->FillPath(brush, &path);
    }
    else
    {
        g->DrawPath(pen, &path);
    }
}

struct BitmapInfo
{
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[256];     // 256 is the maximum palette size
};

/*
    Build an array of GDI+ paths for the current document. 
    This is used as a 'native' data source - so that we don't time path
    creation when rendering. Even in this mode, DrawAllGDIP() still uses the 
    RenderCmd buffer to read pen and brush data.
*/

void 
CSimpsonsView::BuildGDIPList()
{
    // Free the old path array, if any
    if (m_gpPathArray) {
        delete [] m_gpPathArray;
        m_gpPathArray = NULL;
    }

    const RenderCmd *pCmd = GetDocument()->GetRenderCommands();
    const RenderCmd *pCurCmd;

    if (!pCmd) return;
    
    // Count the number of polygons
    int count=0;

    for (pCurCmd=pCmd; pCurCmd->nType != typeSTOP; pCurCmd++) {
        if (pCurCmd->nType == typePOLY) count++;
    }

    m_gpPathArray = new GraphicsPath [count];
    if (!m_gpPathArray) return;

    GraphicsPath *pPath=m_gpPathArray;
    PolyInfo *pPoly;

    // Add each polygon to the path array
    for (pCurCmd=pCmd; pCurCmd->nType != typeSTOP; pCurCmd++) {
        if (pCurCmd->nType==typePOLY) {
            pPoly = (PolyInfo *) pCurCmd->pvData;
    
            DXFPOINT *pCurPoint = pPoly->pPoints;
        
            DXFPOINT *pCurPointLimit = pPoly->pPoints + pPoly->cPoints;
            BYTE *pCurCode = pPoly->pCodes;
    
            DXFPOINT currentPosition;

            while (pCurPoint < pCurPointLimit)
            {
                switch (*pCurCode) {
                
                case PT_BEZIERTO:
                    pPath->AddBezier(
                        (pCurPoint-1)->x, (pCurPoint-1)->y,
                        (pCurPoint)  ->x, (pCurPoint)  ->y,
                        (pCurPoint+1)->x, (pCurPoint+1)->y,
                        (pCurPoint+2)->x, (pCurPoint+2)->y);
        
                    pCurPoint += 3;
                    pCurCode += 3;
                    break;
        
                case PT_MOVETO:
                    pPath->StartFigure();
                    pCurPoint++;
                    pCurCode++;
                    break;
                
                case PT_LINETO:
                    pPath->AddLine(
                        (pCurPoint-1)->x, 
                        (pCurPoint-1)->y, 
                        (pCurPoint)->x,
                        (pCurPoint)->y);
                    pCurPoint++;
                    pCurCode++;
                    break;
            
                }
            } 
            pPath++;
        }
    }
    printf ("BuildGDIPList successful\n");
}

void 
CSimpsonsView::DrawAllGDIP(HDC hDC)
{
    DWORD nStart, nEnd;
    
    // 
    // START TIMING
    // 

    nStart = timeGetTime();
    
    int dataSource = ThisTestCase[TC::At_Source];

    const RenderCmd *pCurCmd = GetDocument()->GetRenderCommands();

    if (pCurCmd == NULL)
        return;

    PolyInfo *pPoly;
    BrushInfo *pBrush;
    PenInfo *pPen;

    GraphicsPath *pPath = NULL;
    
    if (dataSource==TC::Native) {
        pPath = m_gpPathArray;
        if (!pPath) {
            printf("GDI+ Native data is invalid\n");
            return;
        }
    }

    Graphics *gOutput, *g;
    Metafile *recMetafile, *playMetafile;

    g = Graphics::FromHDC(hDC);

    if (ThisTestCase[TC::At_Destination]==TC::ToMetafile) {
        recMetafile = new Metafile(L"simpsons.emf", hDC);
        if (!recMetafile) { delete g; return; }
        gOutput = Graphics::FromImage(recMetafile);
    } else {
        gOutput = g;
    }
    
    if (ThisTestCase[TC::At_Aliasing]==TC::Antialiased) {
        gOutput->SetSmoothingMode(SmoothingModeAntiAlias); 
    } else {
        gOutput->SetSmoothingMode(SmoothingModeNone);
    }

    if (dataSource==TC::FromMetafile) {
        playMetafile = new Metafile(L"simpsons.emf");
        if (playMetafile) {
            GpRectF playbackRect;
            gOutput->GetVisibleClipBounds(&playbackRect);
            gOutput->DrawImage(playMetafile, 0, 0);
        } else {
            printf("Metafile didn't load!\n");
        }
    } else {
    
        Color black(0,0,0);
        Pen currentPen(black, 1);
    
        SolidBrush currentBrush(black);
    
        for (;pCurCmd->nType != typeSTOP; pCurCmd++) {
            switch (pCurCmd->nType) {
            case typePOLY:
                // convert points to fixed point
                
                pPoly = (PolyInfo *) pCurCmd->pvData;
                if (!((m_bIgnoreStroke && (pPoly->dwFlags & DX2D_STROKE)) ||
                        (m_bIgnoreFill && (pPoly->dwFlags & DX2D_FILL))))
                {
                    if (pPath) {
                        // Draw from the pre-created path list
                        if (pPoly->dwFlags & DX2D_FILL)
                        {
                            gOutput->FillPath(&currentBrush, pPath);
                        }
                        else
                        {
                            gOutput->DrawPath(&currentPen, pPath);
                        }
                    } else {
                        ASSERT(dataSource == TC::PathAPI);

                        // Create the path and draw it
                        DrawGDIPPoly(gOutput, (PolyInfo *) pCurCmd->pvData, &currentPen, &currentBrush);
                    }
                }
                
                if(pPath != NULL) pPath++;

                break;
            case typeBRUSH:
                {
                // change brush color
                pBrush = (BrushInfo *) pCurCmd->pvData;
                DWORD dwColor = pBrush->Color;
                BYTE r = BYTE(dwColor >> 16);
                BYTE g = BYTE(dwColor >> 8);
                BYTE b = BYTE(dwColor);
                
                Color c(r,g,b);
                currentBrush.SetColor(c);
                }
                break;
            
            case typePEN: 
    #if 0
                {
                // select a new pen
                pPen = (PenInfo *) pCurCmd->pvData;
                DWORD dwColor = pPen->Color;
                BYTE r = BYTE(dwColor >> 16);
                BYTE g = BYTE(dwColor >> 8);
                BYTE b = BYTE(dwColor);
                
                currentPen.SetPenColor(Color(r,g,b));
                }
    #endif
                break;
    
            }
        }
    }
    
    gOutput->Flush();

    if (ThisTestCase[TC::At_Source]==TC::FromMetafile) {
        delete playMetafile;
    }

    if (ThisTestCase[TC::At_Destination]==TC::ToMetafile) {
        delete gOutput;
        delete recMetafile;
    }
    delete g;
    
    //
    // STOP TIMING
    //

    nEnd = timeGetTime();
    m_dwRenderTime = nEnd-nStart;
}

void
CSimpsonsView::UpdateStatusMessage()
{
    using namespace TC;

    sprintf(g_rgchTmpBuf, "Time: %dms  %s  Src: %s Dst: %s, %s", 
//      GetDocument()->GetFileName(),
        m_dwRenderTime, 
        OptionStr[At_Library][ThisTestCase[At_Library]],
        OptionStr[At_Source][ThisTestCase[At_Source]],
        OptionStr[At_Destination][ThisTestCase[At_Destination]],
        OptionStr[At_Aliasing][ThisTestCase[At_Aliasing]]
    );
//  OutputDebugString(g_rgchTmpBuf);
//  OutputDebugString("\n");

    CFrameWnd *pFrame = GetParentFrame();
    if (pFrame)
        pFrame->SetMessageText(g_rgchTmpBuf);
}

void 
CSimpsonsView::DrawAll(IDX2D *pDX2D)
{
    DWORD nStart, nEnd;

    nStart = timeGetTime();
    
    const RenderCmd *pCurCmd = GetDocument()->GetRenderCommands();

    DXBRUSH Brush;
    DXPEN Pen;

    // intialize Pen and Brush
    Pen.pTexture = NULL;
    Pen.TexturePos.x = 0.f;
    Pen.TexturePos.y = 0.f;
    Brush.pTexture = NULL;
    Brush.TexturePos.x = 0.f;
    Brush.TexturePos.y = 0.f;

    PolyInfo *pPoly;
    BrushInfo *pBrush;
    PenInfo *pPen;

    bool bBrush = false, bPen = false;

    for (;pCurCmd->nType != typeSTOP; pCurCmd++) {
        switch (pCurCmd->nType) {
        case typePOLY:
            pPoly = (PolyInfo *) pCurCmd->pvData;
            if (!((m_bIgnoreStroke && (pPoly->dwFlags & DX2D_STROKE)) ||
                (m_bIgnoreFill && (pPoly->dwFlags & DX2D_FILL))))
            {
                pDX2D->AAPolyDraw(pPoly->pPoints, pPoly->pCodes, pPoly->cPoints, 4, pPoly->dwFlags);
            }
            break;
        case typeBRUSH:
            // select a new brush
            pBrush = (BrushInfo *) pCurCmd->pvData;
            Brush.Color = pBrush->Color;
            pDX2D->SetBrush(&Brush);
            bBrush = true;
            break;
        case typePEN:
            // select a new pen
            pPen = (PenInfo *) pCurCmd->pvData;
            Pen.Color = pPen->Color;
            Pen.Width = pPen->fWidth;
            Pen.Style = pPen->dwStyle;
            pDX2D->SetPen(&Pen);
            bPen = true;
            break;
        }
    }
    nEnd = timeGetTime();
    m_dwRenderTime = nEnd-nStart;
}

HRESULT CSimpsonsView::Render(bool bInvalidate)
{
//  MMTRACE("Render\n");

    RECT rc = {0, 0, 500, 400};
    
    HRESULT hr = S_OK;
    IDirectDrawSurface *pdds = NULL;

    IDXSurface *pDXSurf = NULL;
    HDC screenDC = NULL, drawDC = NULL, memDC = NULL;
    BOOL bFinished = false;

    DWORD executionTime;

    sprintf(g_rgchTmpBuf, "Rendering with %s...", TC::OptionStr[TC::At_Library][ThisTestCase[TC::At_Library]]);
    CFrameWnd *pFrame = GetParentFrame();
    if (pFrame) {
        pFrame->SetMessageText(g_rgchTmpBuf);
    }

    CHECK_HR(hr = m_pDX2D->GetSurface(IID_IDXSurface, (void **) &pDXSurf));
    CHECK_HR(hr = pDXSurf->GetDirectDrawSurface(IID_IDirectDrawSurface, (void **) &pdds));
    
    while (!bFinished) {
        DXFillSurface(pDXSurf, g_aColors[g_ulColorIndex]);
    
        //--- Set alias mode
    //  CHECK_HR(hr = m_pDX2D->_SetDelegateToGDI(m_bAliased));
    
        //--- Set global opacity
    //  CHECK_HR(hr = m_pDX2D->SetGlobalOpacity(1.f));
    
        CHECK_HR(hr = m_pDX2D->SetWorldTransform(&m_XForm));
        
        CDX2DXForm xform;
        xform = m_XForm;
        xform.Translate((REAL)m_clientRectHack.left, (REAL)m_clientRectHack.top);
        
        CHECK_HR(hr = m_pDX2DScreen->SetWorldTransform(&xform));
    
        //--- Get the DC of the DD surface.
        CHECK_HR(hr = pdds->GetDC(&memDC));
    
        // render the scene and compute timing
    
        // Set the timer resolution to 1ms
        if (timeBeginPeriod(1)==TIMERR_NOCANDO) {
            hr = ERROR_INVALID_FUNCTION;
            goto e_Exit;
        }
        
        /*
            For the direct-to-screen cases, we bypass the ddraw surface.
            For repaints to look pretty, though, we copy the result to the ddraw
            surface (after the timer has been turned off.)
        */
    
        drawDC = memDC;
        HBRUSH backgroundBrush;
        
        if (ThisTestCase[TC::At_Destination]==TC::Screen) {
            screenDC = ::GetDC(m_hWnd);
            backgroundBrush = CreateSolidBrush(g_aColors[g_ulColorIndex] & 0xffffff);
            FillRect(screenDC, &rc, backgroundBrush);
            DeleteObject(backgroundBrush);
            drawDC = screenDC;
        }
    
        // The 'DrawAll' routine will actually do the timeGetTime() and store the
        // result in m_dwRenderTime.
    
        switch (ThisTestCase[TC::At_Library]) {
        case TC::GDI:
            DrawAllGDI(drawDC);
            break;
        case TC::Meta:
            if (ThisTestCase[TC::At_Destination]==TC::Screen) {
                DrawAll(m_pDX2DScreen);
            } else {
                DrawAll(m_pDX2D);
            }
            break;
        case TC::GDIP:
            DrawAllGDIP(drawDC);
            break;  
        }

        // !!! Release and re-acquire the DDraw surface DC to work-around
        //     a current limitation in GDI+ where Graphics(hdc) nukes the
        //     hdc of a DDraw surface

        pdds->ReleaseDC(memDC); memDC = NULL;
        CHECK_HR(hr = pdds->GetDC(&memDC));
    
        if (ThisTestCase[TC::At_Destination]==TC::Screen) {
            bInvalidate = false;
            UpdateStatusMessage();
    
            // Copy to from the screen to the ddraw surface, 
            // so that repaints work.
            ::BitBlt(memDC, 0, 0, 500, 400, screenDC, 0, 0, SRCCOPY);
            
        }
        
        timeEndPeriod(1); // Reset the multimedia timer to default resolution
        
        pdds->ReleaseDC(memDC); memDC = NULL;
        
        if (screenDC) {
            ::ReleaseDC(m_hWnd, screenDC);
            screenDC = NULL;
        }
        
        if (m_CycleTests) {
            bFinished = IncrementTest();
        } else {
            bFinished = true;
        }
    
    }
    
e_Exit:
    //--- Clean-up
    if (pdds) {
        if (memDC) 
            pdds->ReleaseDC(memDC);
        MMRELEASE(pdds);
    }
    if (screenDC) {
        ::ReleaseDC(m_hWnd, screenDC);
    }
    MMRELEASE(pDXSurf);
        
    //--- draw
    if (bInvalidate)
        Invalidate();
    
    return hr;
}

void CSimpsonsView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
    bool bNothing = false;
    float fTheta = 1.f;
    if (nChar == 'G') {
        ToggleGDI();
    } else if (nChar == 'A') {
        bNothing = !IncrementAttribute(TC::At_Aliasing);
    } else if (nChar == 'D') {
        bNothing = !IncrementAttribute(TC::At_Destination);
    } else if (nChar == 'I') {
        IncrementTest();
    } else if ((nChar >= '0') && (nChar <= '9')) {
        g_ulColorIndex = (nChar - '0');
    } else if (nChar == ' ') {
        // Redraw
    } else if (nChar == 'R') {
        ResetTransform();
    } else if (nChar == 'F') {
        ToggleFill();
    } else if (nChar == 'S') {
        ToggleStroke();
    } else if (nChar == 'C') {
        m_CycleTests = true;
        m_testCaseNumber = 0;
        if (m_pDX2DDebug) m_pDX2DDebug->SetDC(NULL);
    } else if (nChar == VK_LEFT) {
        AddRotation(fTheta);
    } else if (nChar == VK_RIGHT) {
        AddRotation(-fTheta);
    } else {
        bNothing = true;
    }

    if (!bNothing)
        Render(true);

    if (m_CycleTests) {
        PrintTestResults();
        m_CycleTests = false;
    }
    
    CView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void
CSimpsonsView::ToggleStroke()
{
    m_bIgnoreStroke ^= 1;
}

void
CSimpsonsView::ToggleFill()
{
    m_bIgnoreFill ^= 1;
}

void
CSimpsonsView::ResetTransform()
{
    m_XForm.SetIdentity();
}

void
CSimpsonsView::AddRotation(float fTheta)
{
    m_XForm.Rotate(fTheta);
}



void
CSimpsonsView::ToggleGDI()
{
    HRESULT hr = S_OK;
    IDXSurface *pdxsRender = NULL;
    IDirectDrawSurface *pddsRender = NULL;
    HDC hDC = NULL;

    IncrementAttribute(TC::At_Library);
    
    if (m_pDX2DDebug) {
        switch (ThisTestCase[TC::At_Library]) {
        case TC::GDI:
        case TC::GDIP:
            CHECK_HR(hr = m_pDX2D->GetSurface(IID_IDXSurface, (void**) &pdxsRender));
            CHECK_HR(hr = pdxsRender->QueryInterface(IID_IDirectDrawSurface, (void **) &pddsRender));
            CHECK_HR(hr = pddsRender->GetDC(&hDC));
            m_pDX2DDebug->SetDC(hDC);
            break;
        
        case TC::Meta:
            m_pDX2DDebug->SetDC(NULL);
            break;
        }
    }

e_Exit:
    if (pddsRender && hDC)
        pddsRender->ReleaseDC(hDC);
    MMRELEASE(pddsRender);
    MMRELEASE(pdxsRender);
}


void 
CSimpsonsView::OnLButtonDown(UINT nFlags, CPoint pt) 
{
    CView::OnLButtonDown(nFlags, pt);
}

 
void 
CSimpsonsView::OnRButtonDown(UINT nFlags, CPoint point) 
{
    CView::OnRButtonDown(nFlags, point);
}


void 
CSimpsonsView::ForceUpdate()
{
    HRESULT hr;
    Render(false);

    HDC hdcSurf = NULL;
    IDirectDrawSurface *pdds = NULL;
    DDSURFACEDESC ddsd;
    CDC *pDC = GetDC();

    ddsd.dwSize = sizeof(ddsd);

    CHECK_HR(hr = m_pDX2D->GetSurface(IID_IDirectDrawSurface, (void **) &pdds));
    CHECK_HR(hr = pdds->GetSurfaceDesc(&ddsd));
    CHECK_HR(hr = pdds->GetDC(&hdcSurf));
    ::BitBlt(pDC->m_hDC, 0, 0, ddsd.dwWidth, ddsd.dwHeight, hdcSurf, 0, 0, SRCCOPY);

    UpdateStatusMessage();

e_Exit:
    if (pdds && hdcSurf)
        pdds->ReleaseDC(hdcSurf);
    MMRELEASE(pdds);
}

void
CSimpsonsView::DoMove(POINT &pt)
{
    if ((m_lastPoint.x != pt.x) && (m_lastPoint.y != pt.y)) {
        float dx = float(pt.x - m_lastPoint.x);
        float dy = float(pt.y - m_lastPoint.y);

        if (m_scaling) {
            float scale = 1.f + dx * fZOOMFACTOR;
            CLAMP(scale, fSCALEMIN, fSCALEMAX);
            m_XForm.Translate(float(-m_centerPoint.x), float(-m_centerPoint.y));
            m_XForm.Scale(scale, scale);
            m_XForm.Translate(float(m_centerPoint.x), float(m_centerPoint.y));
        } else {
            // panning
            m_XForm.Translate(dx, dy);
        }
        
        ForceUpdate();
        m_lastPoint = pt;
    }
}



void 
CSimpsonsView::OnLButtonUp(UINT nFlags, CPoint ptPassed) 
{
    POINT pt;
    GetCursorPos(&pt);
    ScreenToClient(&pt);

    DoMove(pt);

    CView::OnLButtonUp(nFlags, pt);
}


void 
CSimpsonsView::OnMouseMove(UINT nFlagsPassed, CPoint ptPassed)
{
    // get current mouse position
    POINT pt;
    GetCursorPos(&pt);
    ScreenToClient(&pt);

    // check if left mouse button is down
    m_tracking = (GetAsyncKeyState(VK_LBUTTON) && (m_bLButton || IsInside(pt.x, pt.y, m_sizWin)));
    if (m_tracking) {
        if (m_bLButton) {
            DoMove(pt);
        } else {
            m_scaling = ((GetAsyncKeyState(VK_CONTROL) & ~0x1) != 0);
            m_bLButton = true;
            m_centerPoint = pt;
            m_lastPoint = pt;
        }
    }
    m_bLButton = m_tracking;

    CView::OnMouseMove(nFlagsPassed, ptPassed);
}


BOOL 
CSimpsonsView::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) 
{
    float fDelta = float (zDelta / 1200.f);
    float fScale = 1.f - fDelta;
    CLAMP(fScale, fSCALEMIN, fSCALEMAX);

    m_XForm.Translate(float(-m_centerPoint.x), float(-m_centerPoint.y));
    m_XForm.Scale(fScale, fScale);
    m_XForm.Translate(float(m_centerPoint.x), float(m_centerPoint.y));

    ForceUpdate();

    return CView::OnMouseWheel(nFlags, zDelta, pt);
}

_cdecl
main(INT argc, PCHAR argb[])
{
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	simpsons.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\afxres.h ===
//
//      Copyright(c) 1996 - 1999. Microsoft Corporation.
//

// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\point.h ===
#ifndef _Point_h
#define _Point_h

// File:	Point.h
//
//	Classes to support 2D and 3D affine space
//	D. P. Mitchell  95/06/02.
//
// History:
// -@- 08/01/95 (mikemarr) - unified & cleaned up interface
//                         - added Print and Parse
// -@- 08/01/95 (mikemarr) - define all inlined functions with macros 
// -@- 06/21/96 (mikemarr) - added IsCCW
// -@- 10/29/97 (mikemarr) - changed data to be floats, not vectors
//                         - removed data accessors & made data public
//                         - changed +=, -= operators to return reference
//                         - removed I/O
//                         - added operator const float *
//                         - changed fuzzy equal to be IsEqual, operator == to be exact
//                         - removed macro junk
// -@- 11/04/97 (mikemarr) - added initialization with POINT
// -@- 11/10/97 (mikemarr) - added operator *,/,*=,/=


#ifndef _VecMath_h
#include "VecMath.h"
#endif

// Class:		Point2
// Hungarian:	pnt
class Point2 {
public:
						Point2()					{}
						Point2(float fX, float fY)	: x(fX), y(fY) {}
						Point2(const Vector2 &v)	: x(v.x), y(v.y) {}
						Point2(const POINT &pt)		: x(pt.x + 0.5f), y(pt.y + 0.5f) {}

	// ALGEBRAIC OPERATORS
	friend Point2		operator +(const Point2 &p, const Vector2 &v);
	friend Point2		operator +(const Vector2 &v, const Point2 &p);
	friend Point2		operator -(const Point2 &p, const Vector2 &v);
	friend Point2		operator -(const Vector2 &v, const Point2 &p);
	friend Point2		operator *(const Point2 &p, float a);
	friend Point2		operator *(float a, const Point2 &p);
	friend Point2		operator /(const Point2 &p, float a);
	friend Vector2		operator -(const Point2 &p, const Point2 &q);

	friend Point2 &		operator +=(Point2 &p, const Vector2 &v);
	friend Point2 &		operator -=(Point2 &p, const Vector2 &v);
	friend Point2 &		operator *=(Point2 &p, float a);
	friend Point2 &		operator /=(Point2 &p, float a);

	friend float		operator *(const CoVector2 &cv, const Point2 &p);

	friend int			operator ==(const Point2 &p, const Point2 &q);
	friend int			operator !=(const Point2 &p, const Point2 &q);
	friend int			IsEqual(const Point2 &p, const Point2 &q);

	friend Point2		Lerp(const Point2 &p, const Point2 &q, float t);
	friend bool			IsCCW(const Point2 &p0, const Point2 &p, const Point2 &q);

						operator const float *() const { return &x; }

	float				X() const { return x; }
	float				Y() const { return y; }
	float &				X() { return x; }
	float &				Y() { return y; }
public:
	float				x, y;
};


// Class:		Point3
// Hungarian:	pnt
class Point3 {
public:
						Point3()								{}
						Point3(float fX, float fY, float fZ)	: x(fX), y(fY), z(fZ) {}
						Point3(const Vector3 &v)				: x(v.x), y(v.y), z(v.z) {}
	
	// ALGEBRAIC OPERATORS
	friend Point3		operator +(const Point3 &p, const Vector3 &v);
	friend Point3		operator +(const Vector3 &v, const Point3 &p);
	friend Point3		operator -(const Point3 &p, const Vector3 &v);
	friend Point3		operator -(const Vector3 &v, const Point3 &p);
	friend Vector3		operator -(const Point3 &p, const Point3 &q);
	friend Point3		operator *(const Point3 &p, float a);
	friend Point3		operator *(float a, const Point3 &p);
	friend Point3		operator /(const Point3 &p, float a);

	friend Point3 &		operator +=(Point3 &p, const Vector3 &v);
	friend Point3 &		operator -=(Point3 &p, const Vector3 &v);
	friend Point3 &		operator *=(Point3 &p, float a);
	friend Point3 &		operator /=(Point3 &p, float a);

	friend float		operator *(const CoVector3 &cv, const Point3 &p);

	friend int			operator ==(const Point3 &p, const Point3 &q);
	friend int			operator !=(const Point3 &p, const Point3 &q);
	friend int			IsEqual(const Point3 &p, const Point3 &q);

	friend Point3		Lerp(const Point3 &p, const Point3 &q, float t);
	Point2				Project(DWORD iAxis) const;

						operator const float *() const { return &x; }

	float				X() const { return x; }
	float				Y() const { return y; }
	float				Z() const { return z; }
	float &				X() { return x; }
	float &				Y() { return y; }
	float &				Z() { return z; }
public:
	float				x, y, z;
};

///////////
// Point2
///////////

inline Point2
operator +(const Point2 &p, const Vector2 &v)
{
	return Point2(p.x + v.x, p.y + v.y);
}

inline Point2
operator +(const Vector2 &v, const Point2 &p)
{
	return Point2(p.x + v.x, p.y + v.y);
}

inline Point2
operator -(const Point2 &p, const Vector2 &v)
{
	return Point2(p.x - v.x, p.y - v.y);
}

inline Point2
operator -(const Vector2 &v, const Point2 &p)
{
	return Point2(p.x - v.x, p.y - v.y);
}

inline Vector2
operator -(const Point2 &p, const Point2 &q)
{
	return Vector2(p.x - q.x, p.y - q.y);
}

inline Point2
operator *(float a, const Point2 &p)
{
	return Point2(a*p.x, a*p.y);
}

inline Point2
operator *(const Point2 &p, float a)
{
	return Point2(a*p.x, a*p.y);
}

inline Point2
operator /(const Point2 &p, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return Point2(p.x * fTmp, p.y * fTmp);
}



inline Point2 &
operator +=(Point2 &p, const Vector2 &v)
{
	p.x += v.x;
	p.y += v.y;
	return p;
}

inline Point2 &
operator -=(Point2 &p, const Vector2 &v)
{
	p.x -= v.x;
	p.y -= v.y;
	return p;
}

inline Point2 &
operator *=(Point2 &p, float a)
{
	p.x *= a;
	p.y *= a;
	return p;
}

inline Point2 &
operator /=(Point2 &p, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	p.x *= fTmp;
	p.y *= fTmp;
	return p;
}


inline int
operator ==(const Point2 &p, const Point2 &q)
{
	return ((p.x == q.x) && (p.y == q.y));
}

inline int
operator !=(const Point2 &p, const Point2 &q)
{
	return ((p.x != q.x) || (p.y != q.y));
}

inline int
IsEqual(const Point2 &p, const Point2 &q)
{
	return (FloatEquals(p.x, q.x) && FloatEquals(p.y, q.y));
}

inline Point2
Lerp(const Point2 &p, const Point2 &q, float t)
{
	return Point2(p.x + (q.x - p.x) * t, p.y + (q.y - p.y) * t);
}


inline bool
IsCCW(const Point2 &p0, const Point2 &p1, const Point2 &p2)
{
#ifdef MIRRORY
	return ((p0.y - p1.y) * (p2.x - p1.x) <= (p0.x - p1.x) * (p2.y - p1.y));
#else
	return ((p0.y - p1.y) * (p2.x - p1.x) >= (p0.x - p1.x) * (p2.y - p1.y));
#endif
}

inline float
operator *(const CoVector2 &cv, const Point2 &p)
{
	return cv.x*p.x + cv.y*p.y;
}


///////////
// Point3
///////////

inline Point3
operator +(const Point3 &p, const Vector3 &v)
{
	return Point3(p.x + v.x, p.y + v.y, p.z + v.z);
}

inline Point3
operator +(const Vector3 &v, const Point3 &p)
{
	return Point3(p.x + v.x, p.y + v.y, p.z + v.z);
}

inline Point3
operator -(const Point3 &p, const Vector3 &v)
{
	return Point3(p.x - v.x, p.y - v.y, p.z - v.z);
}

inline Point3
operator -(const Vector3 &v, const Point3 &p)
{
	return Point3(p.x - v.x, p.y - v.y, p.z - v.z);
}

inline Vector3
operator -(const Point3 &p, const Point3 &q)
{
	return Vector3(p.x - q.x, p.y - q.y, p.z - q.z);
}

inline Point3
operator *(float a, const Point3 &p)
{
	return Point3(a*p.x, a*p.y, a*p.z);
}

inline Point3
operator *(const Point3 &p, float a)
{
	return Point3(a*p.x, a*p.y, a*p.z);
}

inline Point3
operator /(const Point3 &p, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return Point3(p.x * fTmp, p.y * fTmp, p.z * fTmp);
}

inline Point3 &
operator +=(Point3 &p, const Vector3 &v)
{
	p.x += v.x;
	p.y += v.y;
	p.z += v.z;
	return p;
}

inline Point3 &
operator -=(Point3 &p, const Vector3 &v)
{
	p.x -= v.x;
	p.y -= v.y;
	p.z -= v.z;
	return p;
}

inline Point3 &
operator *=(Point3 &p, float a)
{
	p.x *= a;
	p.y *= a;
	p.z *= a;
	return p;
}

inline Point3 &
operator /=(Point3 &p, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	p.x *= fTmp;
	p.y *= fTmp;
	p.z *= fTmp;
	return p;
}


inline int
operator ==(const Point3 &p, const Point3 &q)
{
	return ((p.x == q.x) && (p.y == q.y) && (p.z == q.z));
}

inline int
operator !=(const Point3 &p, const Point3 &q)
{
	return ((p.x != q.x) || (p.y != q.y) || (p.z != q.z));
}

inline int
IsEqual(const Point3 &p, const Point3 &q)
{
	return (FloatEquals(p.x, q.x) && FloatEquals(p.y, q.y) && FloatEquals(p.z, q.z));
}

inline Point3
Lerp(const Point3 &p, const Point3 &q, float t)
{
	return Point3(p.x + (q.x - p.x) * t, p.y + (q.y - p.y) * t, p.z + (q.z - p.z) * t);
}

inline Point2
Point3::Project(DWORD iAxis) const
{
	switch (iAxis) {
	case 0: return Point2(y, z);
	case 1: return Point2(x, z);
	case 2: return Point2(x, y);
	}
	return Point2(0.f, 0.f);
}

inline float
operator *(const CoVector3 &cv, const Point3 &p)
{
	return cv.x*p.x + cv.y*p.y + cv.z*p.z;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7CA49168_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_STDAFX_H__7CA49168_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "MDMUtils.h"

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <DDrawEx.h>
#include <DXTrans.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7CA49168_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\simpview.h ===
// SimpView.h : interface of the CSimpsonsView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SIMPVIEW_H__7CA4916E_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_SIMPVIEW_H__7CA4916E_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// GDI+ includes
#include <math.h>
#include <gdiplus.h>

using namespace Gdiplus;

//#include "DXTrans.h"
#include "DXHelper.h"
#include "dxtpriv.h"
#include "Parse.h"

class CSimpsonsView : public CView
{
protected: // create from serialization only
    CSimpsonsView();
    DECLARE_DYNCREATE(CSimpsonsView)

// Attributes
public:
    CSimpsonsDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSimpsonsView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnDraw(CDC* pDC);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSimpsonsView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CSimpsonsView)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()


private:
    HRESULT                 Render(bool invalidate);
    
    void                    DrawAll(IDX2D *pDX2D);
    
    void                    DrawAllGDI(HDC hDC);
    void                    DrawGDIPoly(HDC hDC, PolyInfo *pPoly);
    void                    DrawGDIPolyPathAPI(HDC hDC, PolyInfo *pPoly);
    void                    DrawAllGDIP(HDC hDC);
    void                    BuildGDIPList();
    void                    DrawGDIPPoly(Graphics *g, PolyInfo *pPoly, Pen *pen, Brush *brush);
    void                    DrawGDIPPolyFromList(Graphics *g, int stroke, GraphicsPath *pPath, Pen *pen, Brush *brush);
    
    void                    UpdateStatusMessage();
    void                    ForceUpdate();

private:
    void                    ToggleGDI();
    void                    ToggleDelegateToGDI();
    void                    ToggleStroke();
    void                    ToggleFill();
    void                    AddRotation(float fTheta);
    void                    ResetTransform();
    bool                    IncrementAttribute(int attribute);
    bool                    IncrementTest();
    void                    PrintTestResults();

    HRESULT                 Resize(DWORD nX, DWORD nY);

    void                    DoMove(POINT &pt);

private:
    IDirectDraw3 *          m_pDD;
    IDirectDrawSurface *    m_pddsScreen;
    IDXSurfaceFactory *     m_pSurfFactory;
    IDX2D *                 m_pDX2D;
    IDX2D *                 m_pDX2DScreen;
    IDX2DDebug *            m_pDX2DDebug;
    CSize                   m_sizWin;
    RECT                    m_clientRectHack; // client rect in screen coords
    GraphicsPath *          m_gpPathArray;

    DWORD                   m_dwRenderTime;

    bool                    m_CycleTests;     // If true, cycle through all tests
    int                     m_testCaseNumber; // Which test case to render
    bool                    m_bIgnoreStroke;
    bool                    m_bIgnoreFill;
        bool                                    m_bNullPenSelected;
        HPEN                                    m_hNullPen;
        HPEN                                    m_hStrokePen;

    //view/tracking parameters
    CDX2DXForm              m_XForm;
    CPoint                  m_centerPoint;
    CPoint                  m_lastPoint;
    bool                    m_tracking;
    bool                    m_scaling;
    bool                    m_bLButton;
};

#ifndef _DEBUG  // debug version in SimpView.cpp
inline CSimpsonsDoc* CSimpsonsView::GetDocument()
   { return (CSimpsonsDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIMPVIEW_H__7CA4916E_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\vecmath.cpp ===
// File:	VecMath.cpp
// Author:	Michael Marr    (mikemarr)
//
// History:
//  -@- 8/1/95 (mikemarr) added FloatEquals

#include "StdAfx.h"
#include "VecMath.h"

// Function: FloatEquals
//    Peform a "fuzzy" compare of two floating point numbers.  This relies
//  on the IEEE bit representation of floating point numbers.
int 
FloatEquals(float x1, float x2)
{
	#define EXPMASK 		0x7f800000
	#define BITSOFPRECISION 19
	#define MANTBITS 		23
	#define EXPOFFSET		(BITSOFPRECISION<<MANTBITS)
	#define ZEROEPS 		3.8e-6F
	#define TINYEPS         1.E-35F

	if (x1 == x2) return 1;		// quick out on exact match
	
	float flEps;

	if ((x1 == 0.0f) || (x2 == 0.0f)) {
		flEps = ZEROEPS;
	} else {
		float maxX;

		if (x1 > x2) 
			maxX = x1;
		else 
			maxX = x2;

		// grab the exponent of the larger number
		unsigned int uExp = (*((unsigned int *) &maxX) & EXPMASK);
		if (uExp < EXPOFFSET)
			flEps = TINYEPS;
		else {
			uExp -= EXPOFFSET;
			flEps = *((float *) &uExp);
		}
	}
	return (((x1 + flEps) >= x2) && ((x1 - flEps) <= x2));
}

#include <math.h>

float 
Vector2::Norm() const
{
	return (float) sqrt(NormSquared());
}

float 
CoVector2::Norm() const
{
	return (float) sqrt(NormSquared());
}

float 
Vector3::Norm() const
{
	return (float) sqrt(NormSquared());
}

float
CoVector3::Norm() const
{
	return (float) sqrt(NormSquared());
}

// Function: Rotate
//    rotate the vector counterclockwise around the given axis by theta radians
// Preconditions:
//    axis must be UNIT LENGTH
void Vector3::Rotate(const Vector3 &vAxis, float fTheta)
{
	float fCosTheta = float(cos(fTheta)), fSinTheta = float(sin(fTheta));
	
	*this *= fCosTheta;
	*this += (vAxis * (Dot(*this, vAxis) * (1.f - fCosTheta)));
	*this += (Cross(*this, vAxis) * fSinTheta);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dspfamly.cpp ===
////    DspFamly.CPP - Display available font families
//
//


#include "precomp.hxx"
#include "global.h"



void PaintFamilies(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {


    // Establish available width and height in device coordinates

    int DrawingWidth = prc->right - prc->left;
    int DrawingHeight = DrawingWidth/2;


    // Establish a Graphics with 0,0 at the top left of the drawing area

    Graphics g(hdc);
    Matrix matrix;

    g.ResetTransform();
    g.TranslateTransform(REAL(prc->left), REAL(*piY));


    // Clear the background

    RectF rEntire(0, 0, REAL(DrawingWidth), REAL(DrawingHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(&whiteBrush, rEntire);


    // Leave a little space for right and bottom margins

    DrawingWidth  -= DrawingWidth/40;
    DrawingHeight -= DrawingHeight/40;


    // Display face names sized to fit: allow 1.5 ems vertical x 20 ems horizontal per char.
    // Thus failyCount fonts will take familyCount*30 square ems.

    INT emSize      = (INT)sqrt(DrawingWidth*DrawingHeight/(g_familyCount*30));
    if (emSize < 6)
        emSize = 6; // we need a reasonable lower limit otherwise we may div by zero
    INT columnCount = DrawingWidth / (emSize*15);

    // HFONT hfont = CreateFont(-emSize, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Tahoma");
    // HFONT hOldFont = (HFONT) SelectObject(hdc, hfont);

    Color        blackColor(0, 0, 0);
    SolidBrush   blackBrush(blackColor);
    Pen          blackPen(&blackBrush, 1);
    StringFormat format(g_formatFlags);

    for (INT i=0; i<g_familyCount; i++) {

        WCHAR facename[LF_FACESIZE];
        g_families[i].GetFamilyName(facename);

        RectF textRect(
            REAL(emSize*15*(i%columnCount)),
            REAL(emSize*3*(i/columnCount)/2),
            REAL(emSize*15),
            REAL(emSize*3/2));

        g.DrawString(
            facename, -1,
            &Font(&FontFamily(L"Tahoma"),REAL(emSize), 0, UnitWorld),
            textRect,
            &format,
            &blackBrush);

        /*
        TextOutW(
            hdc,
            prc->left + emSize*15*(i%columnCount),
            *piY      + emSize*3*(i/columnCount)/2,
            facename,
            lstrlenW(facename)
        );
        */


        // Do some metric analysis

        #ifdef TEXTV2
        char str[200];

        for (INT style = 0; style < 3; style++)
        {
            if (g_families[i].IsStyleAvailable(style))
            {
                if (g_families[i].GetTypographicDescent(style) >= 0)
                {
                    wsprintf(str, "%S: typo descent(%d) >= 0\n", facename, g_families[i].GetTypographicDescent(style));
                    OutputDebugString(str);
                }

                if (g_families[i].GetTypographicAscent(style) <= 0)
                {
                    wsprintf(str, "%S: typo ascent(%d) <= 0\n", facename, g_families[i].GetTypographicAscent(style));
                    OutputDebugString(str);
                }

                if (g_families[i].GetTypographicAscent(style) > g_families[i].GetCellAscent(style))
                {
                    wsprintf(str, "%S: typo ascent(%d) > cell ascent (%d)\n", facename, g_families[i].GetTypographicAscent(style), g_families[i].GetCellAscent(style));
                    OutputDebugString(str);
                }

                if (-g_families[i].GetTypographicDescent(style) > g_families[i].GetCellDescent(style))
                {
                    wsprintf(str, "%S: -typo descent(%d) > cell descent (%d)\n", facename, -g_families[i].GetTypographicDescent(style), g_families[i].GetCellDescent(style));
                    OutputDebugString(str);
                }
            }
        }
        #endif
    }

    // DeleteObject(SelectObject(hdc, hOldFont));

    *piY += emSize*3*(1+((g_familyCount-1)/columnCount))/2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dspdriver.cpp ===
////    DspDriver.CPP - Display strings with DrawDriverString API
//
//


#include "precomp.hxx"
#include "global.h"



void PaintDrawDriverString(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;


    BOOL testMetafile = FALSE;


    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;


    Graphics *g        = NULL;
    Metafile *metafile = NULL;

    if (testMetafile)
    {
        metafile = new Metafile(L"c:\\GdiPlusTest.emf", hdc);
        g = new Graphics(metafile);
    }
    else
    {
        g = new Graphics(hdc);
        g->ResetTransform();
        g->TranslateTransform(REAL(prc->left), REAL(*piY));
        g->SetSmoothingMode(g_SmoothingMode);
    }

    g->SetPageUnit(UnitPixel);
    g->SetTextContrast(g_GammaValue);
    g->SetTextRenderingHint(g_TextMode);

    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g->FillRectangle(g_textBackBrush, rEntire);


    // Apply selected world transform, adjusted to a little away from top
    // left edge.

    g->SetTransform(&g_WorldTransform);
    g->TranslateTransform(
        //REAL(prc->left + plainTextWidth/20),
        //REAL(*piY + plainTextHeight/10),
        REAL(prc->left + plainTextWidth/2),
        REAL(*piY + plainTextHeight/2),
        MatrixOrderAppend);


    Color      grayColor(0xc0, 0xc0, 0xc0);
    SolidBrush grayBrush(grayColor);
    Pen        grayPen(&grayBrush, 1.0);


    // Put some text in the middle

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);

    Font font(&FontFamily(g_style[0].faceName), REAL(g_style[0].emSize), g_style[0].style, g_fontUnit);

    // Prepare array of glyph origins

    PointF *origins;

    if (g_DriverOptions & DriverStringOptionsRealizedAdvance)
    {
        origins = new PointF[1];
        if (!origins)
        {
            return;
        }
        origins[0].X = 0.0;
        origins[0].Y = 0.0;
    }
    else
    {
        origins = new PointF[g_iTextLen];
        if (!origins)
        {
            return;
        }
        origins[0].X = 0.0;
        origins[0].Y = 0.0;

        for (INT i=1; i<g_iTextLen; i++)
        {
            origins[i].X = origins[i-1].X + g_DriverDx;
            origins[i].Y = origins[i-1].Y + g_DriverDy;
        }
    }


    RectF measuredBoundingBox;

    // Change the font size to the pixel height requested in g_DriverPixels,
    // and map to the actual height showing here by adjusting the
    // world transform.

    REAL scale = REAL(font.GetSize() / g_DriverPixels);
    Font scaledFont(&FontFamily(g_style[0].faceName), g_DriverPixels, g_style[0].style, g_fontUnit);

    for(int iRender=0;iRender<g_iNumRenders;iRender++)
    {
        {
            g->DrawDriverString(
                g_wcBuf,
                g_iTextLen,
                &font,
                g_textBrush,
                origins,
                g_DriverOptions,
                &g_DriverTransform
            );
        }
    }

    {
        g->MeasureDriverString(
            g_wcBuf,
            g_iTextLen,
            &font,
            origins,
            g_DriverOptions,
            &g_DriverTransform,
            &measuredBoundingBox
        );
    }

    // Mark the first origin with a cross

    g->DrawLine(&blackPen, origins[0].X,   origins[0].Y-4, origins[0].X,   origins[0].Y+4);
    g->DrawLine(&blackPen, origins[0].X-4, origins[0].Y,   origins[0].X+4, origins[0].Y);

    delete [] origins;

    g->DrawRectangle(
        &Pen(&SolidBrush(Color(0x80,0x80,0x80)), 1.0),
        measuredBoundingBox
    );

    delete g;
    if (metafile) delete metafile;


    if (testMetafile)
    {
        // Playback metafile to screen
        Metafile emfplus(L"c:\\GdiPlusTest.emf");
        Graphics graphPlayback(hdc);
        graphPlayback.ResetTransform();
        graphPlayback.TranslateTransform(REAL(prc->left), REAL(*piY));
        graphPlayback.DrawImage(
            &emfplus,
            REAL(0),
            REAL(0),
            REAL(plainTextWidth),
            REAL(plainTextHeight)
        );
        graphPlayback.Flush();
    }


    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dspgdi.cpp ===
////    DspGDI.CPP - Display strings with GDI API
//
//


#include "precomp.hxx"
#include "global.h"

void PaintGDI(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight)
{
    HFONT hfont, hfontOld;
    HBRUSH hbrush, hbrushOld;
    HPEN hpen, hpenOld;
    COLORREF color, colorOld;
    
    hfont = CreateFontW(
        -(INT)(g_style[0].emSize + 0.5),
        0,  //  int nWidth,                // average character width
        0,  //  int nEscapement,           // angle of escapement
        0,  //  int nOrientation,          // base-line orientation angle
        g_style[0].style & FontStyleBold ? 700 : 400,
        g_style[0].style & FontStyleItalic ? 1 : 0,
        g_style[0].style & FontStyleUnderline ? 1 : 0,
        g_style[0].style & FontStyleStrikeout ? 1 : 0,
        0,  //  DWORD fdwCharSet,          // character set identifier
        0,  //  DWORD fdwOutputPrecision,  // output precision
        0,  //  DWORD fdwClipPrecision,    // clipping precision
        g_TextMode == 3 ? ANTIALIASED_QUALITY : NONANTIALIASED_QUALITY,  //  DWORD fdwQuality,          // output quality
        0,  //  DWORD fdwPitchAndFamily,   // pitch and family
        g_style[0].faceName
    );

    Color textColor(g_TextColor);

    // Establish available width and height in device coordinates
    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;

	RECT textRect = *prc;

    textRect.top = *piY;
    textRect.left = textRect.left + (plainTextWidth / 4);
    textRect.right = textRect.left + (plainTextWidth / 2);
    textRect.bottom = textRect.top + (plainTextHeight / 3);

    color = RGB(textColor.GetRed(), textColor.GetGreen(), textColor.GetBlue());

    hbrush = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
    hpen = CreatePen(PS_SOLID, 0, color);

    colorOld = SetTextColor(hdc, color);
    hfontOld = (HFONT)SelectObject(hdc, hfont);
    hbrushOld = (HBRUSH)SelectObject(hdc, hbrush);
    hpenOld = (HPEN)SelectObject(hdc, hpen);

    SetBkMode(hdc, TRANSPARENT);

    PatBlt(hdc, prc->left, *piY, prc->right, prc->bottom, WHITENESS);

    for(int iRender=0;iRender<g_iNumRenders;iRender++)
    {
        if (g_UseDrawText)
        {
            int flags = DT_EXPANDTABS | DT_WORDBREAK;

            if (g_formatFlags & StringFormatFlagsNoWrap)
                flags |= DT_SINGLELINE;

            DrawTextW(
                hdc,
                g_wcBuf,
                g_iTextLen,
                &textRect,
                flags
            );
        }
        else
        {
            ExtTextOutW(
                hdc,
                textRect.left,
                textRect.top,
                ETO_CLIPPED,
                &textRect,
                g_wcBuf,
                g_iTextLen,
                NULL);
        }
    }

    Rectangle(hdc, textRect.left, textRect.top, textRect.right, textRect.bottom);

    GdiFlush();

    SetTextColor(hdc, colorOld);
    SelectObject(hdc, hbrushOld);
    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hfontOld);

    DeleteObject(hpen);
    DeleteObject(hfont);

    *piY += (textRect.bottom - textRect.top) + iLineHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\debug.cpp ===
#include "precomp.hxx"
#include "global.h"






////    DebugMsg - display a message via OutputDebugString
//
//      DebugMsg formats debug messages, including the file name
//      and line number the message originated form.
//
//      Supports the TRACEMSG and TRACE macros.
//
//      The current timer is adjusted to remove debug message
//      output from timing results.



extern "C" void WINAPIV DebugMsg(char *fmt, ...) {

    va_list vargs;
    char c[200];

//    TIMESUSPEND;

    wsprintfA(c, "%s[%d]                   ", strrchr(DG.psFile, '\\')+1, DG.iLine);
    c[17] = 0;
    OutputDebugStringA(c);

    wsprintfA(c, "%ld:      ", GetCurrentThreadId());
    c[5] = 0;
    OutputDebugStringA(c);

    va_start(vargs, fmt);
    wvsprintfA(c, fmt, vargs);
    OutputDebugStringA(c);

    OutputDebugStringA("\n");

//    TIMERESUME;
}






extern "C" void WINAPIV DebugHr(char *fmt, ...) {

    va_list vargs;
    char c[200];

//    TIMESUSPEND;

    wsprintfA(c, "%s[%d]                   ", strrchr(DG.psFile, '\\')+1, DG.iLine);
    c[17] = 0;
    OutputDebugStringA(c);

    wsprintfA(c, "%ld:      ", GetCurrentThreadId());
    c[5] = 0;
    OutputDebugStringA(c);

    va_start(vargs, fmt);
    wvsprintfA(c, fmt, vargs);
    OutputDebugStringA(c);

    //
    // Parse USP and Win32 Errors
    //

    switch( DG.hrLastError )
    {
    case USP_E_SCRIPT_NOT_IN_FONT:
      lstrcpyA( DG.sLastError , "Selected font doesn't contain requested script\n");
      break;

    default:
      FormatMessageA(
          FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
          NULL, DG.hrLastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
          DG.sLastError, sizeof(DG.sLastError), NULL);
    }

    wsprintfA(c, " -- HRESULT = %x: %s", DG.hrLastError, DG.sLastError);
    OutputDebugStringA(c);

//    TIMERESUME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dspdraws.cpp ===
////    DspDraws.CPP - Display plaintext using DrawString API
//
//


#include "precomp.hxx"
#include "global.h"
#include "gdiplus.h"



/*
REAL GetEmHeightInPoints(
    const Font *font,
    const Graphics *graphics
)
{
    FontFamily family;
    font->GetFamily(&family);

    INT style = font->GetStyle();

    REAL pixelsPerPoint = REAL(graphics->GetDpiY() / 72.0);

    REAL lineSpacingInPixels = font->GetHeight(graphics);

    REAL emHeightInPixels = lineSpacingInPixels * family.GetEmHeight(style)
                                                / family.GetLineSpacing(style);

    REAL emHeightInPoints = emHeightInPixels / pixelsPerPoint;

    return emHeightInPoints;
}
*/




void PaintDrawString(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)



    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;


    // Draw a simple figure in the world coordinate system

    Graphics *g = NULL;

    Metafile *metafile = NULL;

    if (g_testMetafile)
    {
        metafile = new Metafile(L"c:\\texttest.emf", hdc);
        g = new Graphics(metafile);
    }
    else
    {
        g = new Graphics(hdc);
    }


    Matrix matrix;


    g->ResetTransform();
    g->SetPageUnit(UnitPixel);
    g->TranslateTransform(REAL(prc->left), REAL(*piY));

    g->SetSmoothingMode(g_SmoothingMode);

    g->SetTextContrast(g_GammaValue);
    g->SetTextRenderingHint(g_TextMode);

    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));

    Color      grayColor(0xc0, 0xc0, 0xc0);
    SolidBrush grayBrush(grayColor);
    Pen        grayPen(&grayBrush, 1.0);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);



    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    g->FillRectangle(g_textBackBrush, rEntire);


    // Apply selected world transform, adjusted to middle of the plain text
    // area.

    g->SetTransform(&g_WorldTransform);
    g->TranslateTransform(
        REAL(prc->left + plainTextWidth/2),
        REAL(*piY + plainTextHeight/2),
        MatrixOrderAppend);


    Font font(
        &FontFamily(g_style[0].faceName),
        REAL(g_style[0].emSize),
        g_style[0].style,
        g_fontUnit
    );




    // Put some text in the middle

    RectF textRect(REAL(-25*plainTextWidth/100), REAL(-25*plainTextHeight/100),
                   REAL( 50*plainTextWidth/100), REAL( 50*plainTextHeight/100));


    StringFormat format(g_typographic ? StringFormat::GenericTypographic() : StringFormat::GenericDefault());
    format.SetFormatFlags(g_formatFlags);
    format.SetTrimming(g_lineTrim);
    format.SetAlignment(g_align);
    format.SetLineAlignment(g_lineAlign);
    format.SetHotkeyPrefix(g_hotkey);

    format.SetDigitSubstitution(g_Language, g_DigitSubstituteMode);

    REAL tab[3] = {textRect.Width/4,
                   textRect.Width*3/16,
                   textRect.Width*1/8};

    format.SetTabStops(0.0, sizeof(tab)/sizeof(REAL), tab);


    if (!g_AutoDrive)
    {
        // Display selection region if any

        if (g_iFrom || g_iTo)
        {
            if (g_RangeCount > 0)
            {
                Region regions[MAX_RANGE_COUNT];

                format.SetMeasurableCharacterRanges(g_RangeCount, g_Ranges);
                Status status = g->MeasureCharacterRanges(g_wcBuf, g_iTextLen, &font, textRect, &format, g_RangeCount, regions);

                if (status == Ok)
                {
                    Pen lightGrayPen(&SolidBrush(Color(0x80,0x80,0x80)), 1.0);
                    INT rangeCount = g_RangeCount;
                    Matrix identity;

                    while (rangeCount > 0)
                    {
                        /*INT scanCount = regions[rangeCount - 1].GetRegionScansCount(&identity);
                        RectF *boxes = new RectF[scanCount];

                        regions[rangeCount - 1].GetRegionScans(&identity, boxes, &scanCount);

                        for (INT i = 0; i < scanCount; i++)
                        {
                            g->DrawRectangle(&lightGrayPen, boxes[i]);
                        }

                        delete [] boxes;

                        rangeCount--;
                        */
                        g->FillRegion(&SolidBrush(Color(0xc0,0xc0,0xc0)), &regions[--rangeCount]);
                    }
                }
            }
        }
    }

    if (!g_AutoDrive)
    {
        // Outline the layout rectangle

        g->DrawRectangle(&grayPen, textRect);

        // Measure and outline the text

        RectF boundingBox;
        INT   codepointsFitted;
        INT   linesFilled;

        g->MeasureString(
            g_wcBuf, g_iTextLen, &font, textRect, &format,  // In
            &boundingBox, &codepointsFitted, &linesFilled);  // Out

        Pen lightGrayPen(&SolidBrush(Color(0x80,0x80,0x80)), 1.0);

        g->DrawRectangle(&lightGrayPen, boundingBox);

        // Also draw horizontal and vertical lines away from the rectangle
        // corners - this is to check that line and rectangle drawing coordinates
        // work consistently in a negative x scale (they didn't in GDI: the
        // rectangle and lines differed by one pixel).

        g->DrawLine(
            &lightGrayPen,
            boundingBox.X, boundingBox.Y,
            boundingBox.X-plainTextWidth/20, boundingBox.Y);
        g->DrawLine(
            &lightGrayPen,
            boundingBox.X, boundingBox.Y,
            boundingBox.X, boundingBox.Y-plainTextHeight/20);

        g->DrawLine(
            &lightGrayPen,
            boundingBox.X+boundingBox.Width, boundingBox.Y,
            boundingBox.X+boundingBox.Width+plainTextWidth/20, boundingBox.Y);
        g->DrawLine(
            &lightGrayPen,
            boundingBox.X+boundingBox.Width, boundingBox.Y,
            boundingBox.X+boundingBox.Width, boundingBox.Y-plainTextHeight/20);


        g->DrawLine(
            &lightGrayPen,
            boundingBox.X, boundingBox.Y+boundingBox.Height,
            boundingBox.X-plainTextWidth/20, boundingBox.Y+boundingBox.Height);
        g->DrawLine(
            &lightGrayPen,
            boundingBox.X, boundingBox.Y+boundingBox.Height,
            boundingBox.X, boundingBox.Y+boundingBox.Height+plainTextHeight/20);

        g->DrawLine(
            &lightGrayPen,
            boundingBox.X+boundingBox.Width, boundingBox.Y+boundingBox.Height,
            boundingBox.X+boundingBox.Width+plainTextWidth/20, boundingBox.Y+boundingBox.Height);
        g->DrawLine(
            &lightGrayPen,
            boundingBox.X+boundingBox.Width, boundingBox.Y+boundingBox.Height,
            boundingBox.X+boundingBox.Width, boundingBox.Y+boundingBox.Height+plainTextHeight/20);



        WCHAR metricString[100];
        wsprintfW(metricString, L"Codepoints fitted %d\r\nLines filled %d\r\nRanges %d.", codepointsFitted, linesFilled, g_RangeCount);

        REAL x, y;
        if (g_formatFlags & StringFormatFlagsDirectionVertical)
        {
            if (g_formatFlags & StringFormatFlagsDirectionRightToLeft)
            {
                x = textRect.X;
                y = textRect.Y + textRect.Height/2;
            }
            else
            {
                x = textRect.X + textRect.Width;
                y = textRect.Y + textRect.Height/2;
            }
        }
        else
        {
            x = textRect.X + textRect.Width/2;
            y = textRect.Y + textRect.Height;
        }

        g->DrawString(
            metricString,-1,
            &Font(&FontFamily(L"Tahoma"), 12, NULL, UnitPoint),
            PointF(x, y),
            &format,
            &SolidBrush(Color(0x80,0x80,0x80))
        );

        g->MeasureString(
            metricString,-1,
            &Font(&FontFamily(L"Tahoma"), 12, NULL, UnitPoint),
            PointF(x, y),
            &format,
            &boundingBox
        );

        g->DrawRectangle(&lightGrayPen, boundingBox);
     }


    // Actually draw the text string. We do this last so it appears on top of
    // the construction and measurement lines we have just drawn.

    for(int iRender=0;iRender<g_iNumRenders;iRender++)
    {
        g->DrawString(g_wcBuf, g_iTextLen, &font, textRect, &format, g_textBrush);
    }




/*

    // Test Font from Logfont, and generic layout

    HDC derivedDc = g->GetHDC();

    HFONT hFont = CreateFontW(
        iLineHeight/2,        // height of font
        0,                    // average character width
        0,                    // angle of escapement
        0,                    // base-line orientation angle
        0,                    // font weight
        0,                    // italic attribute option
        1,                    // underline attribute option
        0,                    // strikeout attribute option
        1,                    // character set identifier
        0,                    // output precision
        0,                    // clipping precision
        0,                    // output quality
        0,                    // pitch and family
        g_style[0].faceName   // typeface name
    );

    HFONT hOldFont = (HFONT) SelectObject(hdc, hFont);
    Font fontFromDc(hdc);
    ExtTextOutW(hdc, prc->left, prc->bottom-iLineHeight, 0, NULL, L"By ExtTextOut - AaBbCcDdEeFfGgQq", 32, NULL);
    DeleteObject(SelectObject(hdc, hOldFont));
    g->ReleaseHDC(derivedDc);

    REAL emHeightInPoints = GetEmHeightInPoints(&fontFromDc, &g);


    // Test the easy layout string format

    g->DrawString(
        L"AaBbCcDdEeFfGgQq - DrawString default layout", -1,
        &fontFromDc, //  Font(*FontFamily::GenericMonospace(), 18.0, 0, UnitPoint),
        PointF(0.0, REAL(plainTextHeight/2 - iLineHeight)),
        StringFormat::GenericDefault(),
        &blackBrush
    );


    // Test typographic string format

    g->DrawString(
        L"Typographic layout", -1,
        &Font(FontFamily::GenericSansSerif(), 10),
        PointF(0.0, REAL(plainTextHeight/2 - 2*iLineHeight)),
        StringFormat::GenericTypographic(),
        &blackBrush
    );
*/


    delete g;

    if (metafile)
    {
        delete metafile;
    }

    if (g_testMetafile)
    {
        // Playback metafile to screen
        Metafile emfplus(L"c:\\texttest.emf");
        Graphics graphPlayback(hdc);
        graphPlayback.ResetTransform();
        graphPlayback.TranslateTransform(REAL(prc->left), REAL(*piY));
        graphPlayback.DrawImage(
            &emfplus,
            REAL(0),
            REAL(0),
            REAL(plainTextWidth),
            REAL(plainTextHeight)
        );
        graphPlayback.Flush();
    }

    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dsplogcl.cpp ===
////    DspLogcl - Display logical text
//
//      Shows logical characters and selection range in backing store order and fixed width.


#include "precomp.hxx"
#include "global.h"






////    DottedLine
//
//      Draws a horizontal or a vertical dotted line
//
//      Not the best algorithm.


void DottedLine(HDC hdc, int x, int y, int dx, int dy) {

    SetPixel(hdc, x, y, 0);

    if (dx) {

        // Horizontal line

        while (dx > 2) {
            x += 3;
            SetPixel(hdc, x, y, 0);
            dx -= 3;
        }
        x += dx;
        SetPixel(hdc, x, y, 0);

    } else {

        // Vertical line

        while (dy > 2) {
            y += 3;
            SetPixel(hdc, x, y, 0);
            dy -= 3;
        }
        y += dy;
        SetPixel(hdc, x, y, 0);
    }
}






////    PaintLogical - show characters in logical sequence
//
//      Display each glyph separately - override the default advance width
//      processing to defeat any overlapping or combining action that the
//      font performs with it's default ABC width.
//
//      To achieve this, we call ScriptGetGlyphABCWidth to obtain the
//      leading side bearing (A), the black box width (B) and the trailing
//      side bearing (C).
//
//      Since we can control only the advance width per glyph, we have to
//      calulate suitable advance widths to override the affect of the
//      ABC values in the font.
//
//      You should never normally need to call ScriptGetGlyphABCWidth.
//
//      PaintLogical has to implement a form of font fallback - Indian and
//      Tamil scripts are not present in Tahoma, so we go
//      directly to Mangal and Latha for characters in those Unicode ranges.


void PaintLogical(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight) {

    const int MAXBUF     = 100;
    const int CELLGAP    = 4;      // Pixels between adjacent glyphs

    int   icpLineStart;     // First character of line
    int   icpLineEnd;       // End of line (end of buffer or index of CR character)
    int   icp;
    int   iLen;
    int   iPartLen;         // Part of string in a single font
    int   iPartX;
    int   iPartWidth;
    WORD  wGlyphBuf[MAXBUF];
    int   idx[MAXBUF];      // Force widths so all characters show
    BYTE  bFont[MAXBUF];    // Font used for each character
    ABC   abc[MAXBUF];
    int   iTotX;
    int   ildx;             // Overall line dx, adjusts for 'A' width of leading glyph
    int   iSliderX;
    int   iFont;            // 0 = Tahoma, 1 = Mangal, 2 = Latha
    RECT  rcClear;          // Clear each line before displaying it

    // Selection highlighting

    bool  bHighlight;       // Current state of highlighting in the hdc
    int   iFrom;            // Selection range
    int   iTo;
    DWORD dwOldBkColor=0;
    DWORD dwOldTextColor=0;

    // Item analysis

    SCRIPT_ITEM    items[MAXBUF];
    SCRIPT_CONTROL scriptControl;
    SCRIPT_STATE   scriptState;
    INT            iItem;


#define NUMLOGICALFONTS 4

    SCRIPT_CACHE sc[NUMLOGICALFONTS];
    HFONT        hf[NUMLOGICALFONTS];
    HFONT        hfold;
    HRESULT      hr;

    SCRIPT_FONTPROPERTIES sfp;
    BOOL         bMissing;

    icpLineStart = 0;

    hf[0]    = CreateFontA(iLineHeight*7/10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Tahoma");
    hf[1]    = CreateFontA(iLineHeight*7/10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Mangal");
    hf[2]    = CreateFontA(iLineHeight*7/10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Latha");
    hf[3]    = CreateFontA(iLineHeight*7/20, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Tahoma"); // for bidi level digits

    iFont    = 0;
    hfold    = (HFONT) SelectObject(hdc, hf[iFont]);
    ildx     = 0;

    memset(sc, 0, sizeof(sc));
    bHighlight = FALSE;

    INT iSliderHeight = g_fOverrideDx ? iLineHeight * 5 / 10 : 0;
    INT iLevelsHeight = g_fShowLevels ? iLineHeight * 8 / 20 : 0;



    // Display line by line

    while (icpLineStart < g_iTextLen) {


        // Clear line before displaying it

        rcClear        = *prc;
        rcClear.top    = *piY;
        rcClear.bottom = *piY + iLineHeight + iSliderHeight + iLevelsHeight;
        FillRect(hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));


        // Find end of line or end of buffer

        icpLineEnd = icpLineStart;
        while (icpLineEnd < g_iTextLen  &&  g_wcBuf[icpLineEnd] != 0x0D) {
            icpLineEnd++;
        }

        if (icpLineEnd - icpLineStart > MAXBUF) {
            iLen = MAXBUF;
        } else {
            iLen = icpLineEnd - icpLineStart;
        }


        // Obtain item analysis

        scriptControl = g_ScriptControl;
        scriptState   = g_ScriptState;
        ScriptItemize(g_wcBuf+icpLineStart, iLen, MAXBUF, &scriptControl, &scriptState, items, NULL);


        // Determine font and glyph index for each codepoint

        if (iFont != 0) {       // Start with Tahoma
            iFont = 0;
            SelectObject(hdc, hf[0]);
        }

        hr = ScriptGetCMap(hdc, &sc[iFont], g_wcBuf+icpLineStart, iLen, 0, wGlyphBuf);
        if (SUCCEEDED(hr))
        {

            memset(bFont, 0, iLen);

            if (hr != S_OK) {

                // Some characters were not in Tahoma

                sfp.cBytes = sizeof(sfp);
                ScriptGetFontProperties(hdc, &sc[iFont], &sfp);

                bMissing = FALSE;
                for (icp=0; icp<iLen; icp++) {
                    if (wGlyphBuf[icp] == sfp.wgDefault) {
                        bFont[icp] = 1;
                        bMissing = TRUE;
                    }
                }


                // Try other fonts

                while (bMissing  &&  iFont < 2) {
                    iFont++;
                    SelectObject(hdc, hf[iFont]);
                    ScriptGetFontProperties(hdc, &sc[iFont], &sfp);
                    bMissing = FALSE;
                    for (icp=0; icp<iLen; icp++) {
                        if (bFont[icp] == iFont) {
                            ScriptGetCMap(hdc, &sc[iFont], g_wcBuf+icpLineStart+icp, 1, 0, wGlyphBuf+icp);
                            if (wGlyphBuf[icp] == sfp.wgDefault) {
                                bFont[icp] = (BYTE)(iFont+1);
                                bMissing = TRUE;
                            }
                        }
                    }
                }

                if (bMissing) {

                    // Remaining missing characters come from font 0
                    for (icp=0; icp<iLen; icp++) {
                        if (bFont[icp] >= NUMLOGICALFONTS) {
                            bFont[icp] = 0;
                        }
                    }
                }
            }



            // Display each glyphs black box next to the previous. Override the
            // default ABC behaviour.

            idx[0] = 0;

            for (icp=0; icp<iLen; icp++) {

                if (iFont != bFont[icp]) {
                    iFont = bFont[icp];
                    SelectObject(hdc, hf[iFont]);
                }

                ScriptGetGlyphABCWidth(hdc, &sc[iFont], wGlyphBuf[icp], &abc[icp]);

                if (g_wcBuf[icpLineStart+icp] == ' ') {

                    // Treat entire space as black

                    abc[icp].abcB += abc[icp].abcA;   abc[icp].abcA = 0;
                    abc[icp].abcB += abc[icp].abcC;   abc[icp].abcC = 0;

                }

                // Glyph black box width is abc.abcB
                // We'd like the glyph to appear 2 pixels to the right of the
                // previous glyph.
                //
                // The default placement of left edge is abc.abcA.
                //
                // Therefore we need to shift this character to the right by
                // 2 - abc.abcA to get it positioned correctly. We do this by
                // updating the advance width for the previous character.

                if (!icp) {
                    ildx = CELLGAP/2 - abc[icp].abcA;
                } else {
                    idx[icp-1] += CELLGAP - abc[icp].abcA;
                }

                // Now adjust the advance width for this character to take us to
                // the right edge of it's black box.

                idx[icp] = abc[icp].abcB + abc[icp].abcA;
            }


            // Support selection range specified in either direction

            if (g_iFrom <= g_iTo) {
                iFrom = g_iFrom - icpLineStart;
                iTo   = g_iTo   - icpLineStart;
            } else {
                iFrom = g_iTo   - icpLineStart;
                iTo   = g_iFrom - icpLineStart;
            }

            // Display glyphs in their appropriate fonts

            icp = 0;
            iPartX = prc->left+ildx;

            while (icp < iLen) {

                if (iFont != bFont[icp]) {
                    iFont = bFont[icp];
                    SelectObject(hdc, hf[iFont]);
                }


                // Set selection highlighting at start

                if (    icp >= iFrom
                    &&  icp < iTo
                    &&  !bHighlight) {

                    // Turn on highlighting

                    dwOldBkColor   = SetBkColor(hdc,   GetSysColor(COLOR_HIGHLIGHT));
                    dwOldTextColor = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    bHighlight = TRUE;

                } else if (    (    icp < iFrom
                                ||  icp >= iTo)
                           &&  bHighlight) {

                    // Turn off highlighting

                    SetBkColor(hdc, dwOldBkColor);
                    SetTextColor(hdc, dwOldTextColor);
                    bHighlight = FALSE;
                }


                // Find longest run from a single font, and
                // without change of highlighting

                iPartLen   = 0;
                iPartWidth = 0;

                while (    icp+iPartLen < iLen
                       &&  iFont == bFont[icp+iPartLen]
                       &&  bHighlight == (icp+iPartLen >= iFrom && icp+iPartLen < iTo)) {

                    iPartWidth += idx[icp+iPartLen];
                    iPartLen++;
                }


                // Display single font, single highlighting

                ExtTextOutW(hdc,
                    iPartX,
                    *piY+2,
                    ETO_CLIPPED | ETO_GLYPH_INDEX,
                    prc,
                    wGlyphBuf+icp,
                    iPartLen,
                    idx+icp);

                icp    += iPartLen;
                iPartX += iPartWidth;
            }



            // Mark the cells to make the characters stand out clearly

            MoveToEx(hdc, prc->left, *piY, NULL);
            LineTo(hdc,   prc->left, *piY + iLineHeight*3/4);

            iTotX = 0;

            for (icp=0; icp<iLen; icp++){

                iTotX += abc[icp].abcB + CELLGAP;
                idx[icp] = iTotX;   // Record cell position for mouse hit testing

                DottedLine(hdc, prc->left + iTotX, *piY, 0, iLineHeight*3/4);


                // Add slider for OverridedDx control

                if (g_fOverrideDx) {

                    iSliderX = prc->left + (icp==0 ? idx[0]/2 : (idx[icp-1] + idx[icp])/2);

                    // Draw the axis of the slider

                    DottedLine(hdc, iSliderX, *piY + iLineHeight*35/40, 0, iSliderHeight*35/40);

                    // Draw the knob

                    if (g_iWidthBuf[icpLineStart + icp] < iSliderHeight) {

                        MoveToEx(hdc, iSliderX-2, *piY + iLineHeight*35/40 + iSliderHeight*35/40 - g_iWidthBuf[icpLineStart + icp], NULL);
                        LineTo  (hdc, iSliderX+3, *piY + iLineHeight*35/40 + iSliderHeight*35/40 - g_iWidthBuf[icpLineStart + icp]);

                    } else {

                        MoveToEx(hdc, iSliderX-2, *piY + iLineHeight*35/40, NULL);
                        LineTo  (hdc, iSliderX+3, *piY + iLineHeight*35/40);
                    }
                }
            }

            MoveToEx(hdc, prc->left + iTotX, *piY, NULL);
            LineTo(hdc,   prc->left + iTotX, *piY + iLineHeight*30/40);

            MoveToEx(hdc, prc->left, *piY, NULL);
            LineTo(hdc,   prc->left + iTotX, *piY);
            MoveToEx(hdc, prc->left, *piY + iLineHeight*30/40, NULL);
            LineTo(hdc,   prc->left + iTotX, *piY + iLineHeight*30/40);


            if (g_fShowLevels)
            {
                // Display bidi levels for each codepoint

                iItem = 0;
                iFont = 3;
                SelectObject(hdc, hf[3]);

                for (icp=0; icp<iLen; icp++)
                {
                    if (icp == items[iItem+1].iCharPos)
                    {
                        iItem++;

                        // Draw a vertical line to mark the item boundary
                        MoveToEx(hdc, prc->left + idx[icp-1], *piY + iLineHeight*35/40 + iSliderHeight, NULL);
                        LineTo(  hdc, prc->left + idx[icp-1], *piY + iLineHeight*35/40 + iSliderHeight + iLevelsHeight*35/40);
                    }

                    // Establish where horizontally to display the digit

                    char chDigit = char('0' + items[iItem].a.s.uBidiLevel);
                    int digitWidth;
                    GetCharWidth32A(hdc, chDigit, chDigit, &digitWidth);

                    ExtTextOutA(
                        hdc,
                        prc->left + (icp==0 ? idx[0]/2 : (idx[icp-1] + idx[icp])/2) - digitWidth / 2,
                        *piY + iLineHeight*35/40 + iSliderHeight,
                        0,
                        NULL,
                        &chDigit,
                        1,
                        NULL);
                }
            }


            // Check whether mouse clicks in this line are waiting to be processed

            if (    g_fOverrideDx
                &&  g_fMouseUp  &&  g_iMouseUpY > *piY + iLineHeight*33/40  &&  g_iMouseUpY < *piY + iLineHeight*63/40) {

                // Procss change to DX override slider

                icp = 0;
                while (icp<iLen  &&  prc->left + idx[icp] < g_iMouseUpX) {
                    icp++;
                }

                g_iWidthBuf[icpLineStart+icp] = *piY + 60 - g_iMouseUpY; // Adjust this slider
                InvalidateText();   // Force slider to redraw at new position
                g_fMouseDown = FALSE;
                g_fMouseUp   = FALSE;
                g_iFrom = icpLineStart+icp;
                g_iTo   = icpLineStart+icp;


            } else if (g_fMouseDown  &&  g_iMouseDownY > *piY  &&  g_iMouseDownY < *piY+iLineHeight) {

                // Handle text selection

                // Record char pos at left button down
                // Snap mouse hit to closest character boundary

                if (g_iMouseDownX < prc->left + idx[0]/2) {
                    icp = 0;
                } else {
                    icp = 1;
                    while (    icp < iLen
                           &&  g_iMouseDownX > prc->left + (idx[icp-1] + idx[icp]) / 2) {
                        icp++;
                    }
                }
                g_iFrom = icp + icpLineStart;

                if (g_iFrom < icpLineStart) {
                    g_iFrom = icpLineStart;
                }
                if (g_iFrom > icpLineEnd) {
                    g_iFrom = icpLineEnd;
                }
                g_fMouseDown = FALSE;
            }


            if (g_fMouseUp  &&  g_iMouseUpY > *piY  &&  g_iMouseUpY < *piY+iLineHeight) {

                // Complete selection processing

                if (g_iMouseUpX < prc->left + idx[0]/2) {
                    icp = 0;
                } else {
                    icp = 1;
                    while (    icp < iLen
                           &&  g_iMouseUpX > prc->left + (idx[icp-1] + idx[icp]) / 2) {
                        icp++;
                    }
                }
                g_iTo = icp + icpLineStart;

                if (g_iTo < icpLineStart) {
                    g_iTo = icpLineStart;
                }
                if (g_iTo > icpLineEnd) {
                    g_iTo = icpLineEnd;
                }

                // Caret is where mouse was raised

                g_iCurChar = g_iTo;
                g_iCaretSection = CARET_SECTION_LOGICAL;  // Show caret in logical text
                g_fUpdateCaret = TRUE;

                g_fMouseUp = FALSE;     // Signal that the mouse up is processed

            }

            if (    g_fUpdateCaret
                &&  g_iCurChar >= icpLineStart
                &&  g_iCurChar <= icpLineEnd
                &&  g_iCaretSection == CARET_SECTION_LOGICAL) {

                g_fUpdateCaret = FALSE;
                if (g_iCurChar <= icpLineStart) {
                    ResetCaret(prc->left, *piY, iLineHeight);
                } else {
                    ResetCaret(prc->left + idx[g_iCurChar - icpLineStart - 1], *piY, iLineHeight);
                }
            }


            }
        else {
            // ScriptGetCMap failed - therefore this is not a glyphable font.
            // This could indicate
            //      A printer device font
            //      We're running on FE Win95 which cannot handle glyph indices
            //
            // For the sample app, we know we are using a glyphable Truetype font
            // on a screen DC, so it must mean the sample is running on a Far
            // East version of Windows 95.
            // Theoretically we could go to the trouble of calling
            // WideCharToMultiByte and using the 'A' char interfaces to
            // implement DspLogcl.
            // However this is only a sample program - DspPlain and DspFormt
            // work correctly, but there's no advantage in implementing
            // DspLogcl so well.
            // Display an apology.

            ExtTextOutA(hdc, prc->left+2, *piY+2, ETO_CLIPPED, prc, "Sorry, no logical text display on Far East Windows 95.", 54, NULL);
            icpLineEnd = g_iTextLen;  // Hack to stop display of subsequent lines
        }

        *piY += iLineHeight + iSliderHeight + iLevelsHeight;


        // Advance to next line

        if (g_fPresentation) {
            icpLineStart = g_iTextLen;  // Only show one line in presentation mode

        } else {

            if (icpLineEnd < g_iTextLen) {
                icpLineEnd++;
            }
            if (icpLineEnd < g_iTextLen  &&  g_wcBuf[icpLineEnd] == 0x0A) {
                icpLineEnd++;
            }
            icpLineStart = icpLineEnd;
        }
    }

    SelectObject(hdc, hfold);


    if (bHighlight) {

        // Turn off highlighting

        SetBkColor(hdc, dwOldBkColor);
        SetTextColor(hdc, dwOldTextColor);
        bHighlight = FALSE;
    }


    for (iFont=0; iFont<NUMLOGICALFONTS; iFont++) {
        DeleteObject(hf[iFont]);
        if (sc[iFont]) {
            ScriptFreeCache(&sc[iFont]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dspglyph.cpp ===
////    DspDraws.CPP - Display plaintext using DrawString API
//
//


#include "precomp.hxx"
#include "global.h"
#include "gdiplus.h"



void PaintGlyphs(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;      // First character of line
    int      icpLineEnd;        // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;
    INT      row;
    INT      column;



    // Establish available width and height in device coordinates

    int DrawingWidth = prc->right - prc->left;
    int DrawingHeight = prc->bottom - *piY;

    // Establish a Graphics with 0,0 at the top left of the drawing area

    Graphics g(hdc);
    Matrix matrix;

    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));

    // Clear the background

    RectF rEntire(0, 0, REAL(DrawingWidth), REAL(DrawingHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(&whiteBrush, rEntire);


    // Leave a little space for right and bottom margins

    DrawingWidth  -= DrawingWidth/40;
    DrawingHeight -= DrawingHeight/40;


    // Fill in a grid

    SolidBrush grayBrush(Color(0xc0, 0xc0, 0xc0));
    Pen        grayPen(&grayBrush, 2.0);

    SolidBrush darkGrayBrush(Color(0x80, 0x80, 0x80));
    Pen        darkGrayPen(&darkGrayBrush, 2.0);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 2.0);

    for (row = 0; row <= g_GlyphRows; row++)
    {
        g.DrawLine(&grayPen,
            0,              row*(DrawingHeight-1)/g_GlyphRows,
            DrawingWidth-1, row*(DrawingHeight-1)/g_GlyphRows);
    }
    for (column = 0; column <= g_GlyphColumns; column++)
    {
        g.DrawLine(&grayPen,
            column*(DrawingWidth-1)/g_GlyphColumns, 0,
            column*(DrawingWidth-1)/g_GlyphColumns, DrawingHeight-1);
    }


    // Identify cell dimensions

    INT cellHeight = (DrawingHeight-1)/g_GlyphRows;
    INT cellWidth  = (DrawingWidth-1)/g_GlyphColumns;

    Font font(&FontFamily(g_style[0].faceName), REAL(cellHeight)*2/3, 0, UnitWorld);

    REAL zero = 0;

    INT DriverStringFlags = 0;

    if (g_CmapLookup)
    {
        DriverStringFlags |= DriverStringOptionsCmapLookup;
    }
    if (g_VerticalForms)
    {
        DriverStringFlags |= DriverStringOptionsVertical;
    }

    // Loop through each character cell

    for (row = 0; row < g_GlyphRows; row++)
    {
        for (column = 0; column < g_GlyphColumns; column++)
        {
            UINT16 glyphIndex;

            if (g_HorizontalChart)
            {
                glyphIndex = g_GlyphFirst + row*g_GlyphColumns + column;
            }
            else
            {
                glyphIndex = g_GlyphFirst + column*g_GlyphRows + row;
            }

            // Set world transform to apply to individual glyphs (excludes translation)

            g.ResetTransform();
            g.SetTransform(&g_WorldTransform);

            // Translate world transform to centre of glyph cell

            REAL cellOriginX = float(prc->left + column*(DrawingWidth-1)/g_GlyphColumns) + float(cellWidth)/2;
            REAL cellOriginY = float(*piY      + row*(DrawingHeight-1)/g_GlyphRows)      + float(cellHeight)/2;

            g.TranslateTransform(cellOriginX, cellOriginY, MatrixOrderAppend);

            // Get glyph bounding box

            RectF untransformedBoundingBox;     // Without font transform
            RectF transformedBoundingBox;       // With font transform

            g.MeasureDriverString(
                &glyphIndex, 1,
                &font,
                &PointF(0,0),
                DriverStringFlags,
                NULL,
                &untransformedBoundingBox
            );

            g.MeasureDriverString(
                &glyphIndex, 1,
                &font,
                &PointF(0,0),
                DriverStringFlags,
                &g_FontTransform,
                &transformedBoundingBox
            );

            REAL glyphOriginX = - transformedBoundingBox.Width/2 - transformedBoundingBox.X;
            REAL glyphOriginY = - transformedBoundingBox.Height/2 - transformedBoundingBox.Y;

            if (g_ShowCell)
            {
                // Show cell around transformed glyph

                transformedBoundingBox.X = - transformedBoundingBox.Width/2;
                transformedBoundingBox.Y = - transformedBoundingBox.Height/2;
                g.DrawRectangle(&darkGrayPen, transformedBoundingBox);
            }

            // Display the glyph

            g.DrawDriverString(
                &glyphIndex, 1,
                &font,
                &blackBrush,
                &PointF(glyphOriginX, glyphOriginY),
                DriverStringFlags,
                &g_FontTransform
            );

            if (g_ShowCell)
            {
                // Show transformed cell around untransformed glyph

                g.MultiplyTransform(&g_FontTransform);

                glyphOriginX = - untransformedBoundingBox.Width/2 - untransformedBoundingBox.X;
                glyphOriginY = - untransformedBoundingBox.Height/2 - untransformedBoundingBox.Y;

                untransformedBoundingBox.X = - untransformedBoundingBox.Width/2;
                untransformedBoundingBox.Y = - untransformedBoundingBox.Height/2;
                g.DrawRectangle(&darkGrayPen, untransformedBoundingBox);

                // Show baseline

                g.DrawLine(
                    &darkGrayPen,
                    glyphOriginX - cellWidth/20,
                    glyphOriginY,
                    glyphOriginX + untransformedBoundingBox.Width + cellWidth/20 + 1,
                    glyphOriginY
                );
            }

        }
    }


    *piY += DrawingHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\simpsons\vecmath.h ===
#ifndef _VecMath_h
#define _VecMath_h

// File:	VecMath.h
//
//	Classes to support 2D and 3D linear vector space and their duals
//	D. P. Mitchell  95/06/02.
//
// History:
// -@- 07/06/95 (mikemarr) - added Print and Read functions
// -@- 08/01/95 (mikemarr) - added fuzzy compare for floats
// -@- 04/15/96 (mikemarr) - changed stdio stuff to don's stream stuff
// -@- 04/18/96 (mikemarr) - added vector.inl to this file
// -@- 06/21/96 (mikemarr) - added +=, etc. operators
// -@- 06/21/96 (mikemarr) - added Rotate
// -@- 10/29/97 (mikemarr) - removed I/O
//                         - changed +=,-=,*=,/= operators to return reference
//                         - added operator const float *
//                         - added Unitize, Perp, NormSquared, SetNorm, Negate
//                         - comments/cleanup
//                         - changed fuzzy equal to be IsEqual, operator == to be exact
//                         - bug fix on Transpose
//                         - changed multiple divides to be 1 divide + multiplies
//                         - assert on divide by zero
// -@- 11/04/97 (mikemarr) - added intialization with SIZE

// Function: FloatEquals
//    Peform a "fuzzy" compare of two floating point numbers.  This relies
//  on the IEEE bit representation of floating point numbers.
int	FloatEquals(float x1, float x2);

class CoVector2;
class CoVector3;
class Vector3;

// Class:		Vector2
// Hungarian:	v
// Description:
//    This class represents a floating point 2D column vector useful for computational
//  geometry calculations.
class  Vector2 {
public:
						Vector2()					{}
						Vector2(float a, float b)	: x(a), y(b) {}
						Vector2(const SIZE &siz)	: x(float(siz.cx)), y(float(siz.cy)) {}

	friend Vector2		operator +(const Vector2 &u, const Vector2 &v);
	friend Vector2		operator -(const Vector2 &u, const Vector2 &v);
	friend Vector2		operator -(const Vector2 &u);
	friend Vector2		operator *(const Vector2 &u, float a);
	friend Vector2		operator *(float a, const Vector2 &u);
	friend Vector2		operator /(const Vector2 &u, float a);
	friend int			operator ==(const Vector2 &u, const Vector2 &v);
	friend int			operator !=(const Vector2 &u, const Vector2 &v);

	friend Vector2 &	operator +=(Vector2 &u, const Vector2 &v);
	friend Vector2 &	operator -=(Vector2 &u, const Vector2 &v);
	friend Vector2 &	operator *=(Vector2 &u, float a);
	friend Vector2 &	operator /=(Vector2 &u, float a);

#ifndef DISABLE_CROSSDOT
	friend float 		Cross(const Vector2 &u, const Vector2 &v);
	friend float 		Dot(const Vector2 &u, const Vector2 &v);
#endif
	friend int			IsEqual(const Vector2 &u, const Vector2 &v);

						operator const float *() const { return &x; }

	CoVector2 			Transpose() const;
	float 				Norm() const;
	float 				NormSquared() const;
	void				SetNorm(float a);
	Vector2  			Unit() const;
	void				Unitize();
	Vector2				Perp() const;	// points to left
	void				Negate();

public:
	float				x, y;
};


// Class:		CoVector2
// Hungarian:	cv
// Description:
//    This class represents a floating point 2D row vector useful for computational
//  geometry calculations.
class  CoVector2 {
public:
						CoVector2()						{}
						CoVector2(float a, float b)		: x(a), y(b) {}
						CoVector2(const SIZE &siz)		: x(float(siz.cx)), y(float(siz.cy)) {}

	friend CoVector2	operator +(const CoVector2 &u, const CoVector2 &v);
	friend CoVector2	operator -(const CoVector2 &u, const CoVector2 &v);
	friend CoVector2	operator -(const CoVector2 &u);
	friend CoVector2	operator *(const CoVector2 &u, float a);
	friend CoVector2	operator *(float a, const CoVector2 &u);
	friend CoVector2	operator /(const CoVector2 &u, float a);
	friend int			operator ==(const CoVector2 &u, const CoVector2 &v);
	friend int			operator !=(const CoVector2 &u, const CoVector2 &v);

	friend CoVector2 &	operator +=(CoVector2 &u, const CoVector2 &v);
	friend CoVector2 &	operator -=(CoVector2 &u, const CoVector2 &v);
	friend CoVector2 &	operator *=(CoVector2 &u, float a);
	friend CoVector2 &	operator /=(CoVector2 &u, float a);

#ifndef DISABLE_CROSSDOT
	friend float		Cross(const CoVector2 &u, const CoVector2 &v);
	friend float		Dot(const CoVector2 &u, const CoVector2 &v);
#endif
	friend int			IsEqual(const CoVector2 &u, const CoVector2 &v);

						operator const float *() const { return &x; }

	Vector2				Transpose() const;
	float				Norm() const;
	float 				NormSquared() const;
	void				SetNorm(float a);
	CoVector2 			Unit() const;
	void		 		Unitize();
	friend float		operator *(const CoVector2 &c, const Vector2 &v);
	CoVector2			Perp() const; 	// points to left
	void				Negate();

public:
	float				x, y;
};


// Class:		Vector3
// Hungarian:	v
// Description:
//    This class represents a floating point 3D column vector useful for computational
//  geometry calculations.
class  Vector3 {
public:
						Vector3()							{}
						Vector3(float a, float b, float c)	: x(a), y(b), z(c) {}

	friend Vector3		operator +(const Vector3 &u, const Vector3 &v);
	friend Vector3		operator -(const Vector3 &u, const Vector3 &v);
	friend Vector3		operator -(const Vector3 &u);
	friend Vector3		operator *(const Vector3 &u, float a);
	friend Vector3		operator *(float a, const Vector3 &u);
	friend Vector3		operator /(const Vector3 &u, float a);
	friend int			operator ==(const Vector3 &u, const Vector3 &v);
	friend int			operator !=(const Vector3 &u, const Vector3 &v);

	friend Vector3 &	operator +=(Vector3 &u, const Vector3 &v);
	friend Vector3 &	operator -=(Vector3 &u, const Vector3 &v);
	friend Vector3 &	operator *=(Vector3 &u, float a);
	friend Vector3 &	operator /=(Vector3 &u, float a);

#ifndef DISABLE_CROSSDOT
	friend Vector3		Cross(const Vector3 &u, const Vector3 &v);
	friend float		Dot(const Vector3 &u, const Vector3 &v);
#endif
	friend int			IsEqual(const Vector3 &u, const Vector3 &v);

						operator const float *() const { return &x; }

	CoVector3			Transpose() const;
	float				Norm() const;
	float 				NormSquared() const;
	void				SetNorm(float a);
	Vector3				Unit() const;
	void		 		Unitize();
	Vector2				Project(DWORD iAxis) const;
	void				Rotate(const Vector3 &vAxis, float fTheta);
	void				Negate();

public:
	float				x, y, z;
};


// Class:		CoVector3
// Hungarian:	cv
// Description:
//    This class represents a floating point 3D row vector useful for computational
//  geometry calculations.
class  CoVector3 {
public:
						CoVector3()								{}
						CoVector3(float a, float b, float c)	: x(a), y(b), z(c) {}

	friend CoVector3	operator +(const CoVector3 &u, const CoVector3 &v);
	friend CoVector3	operator -(const CoVector3 &u, const CoVector3 &v);
	friend CoVector3	operator -(const CoVector3 &u);
	friend CoVector3	operator *(const CoVector3 &u, float a);
	friend CoVector3	operator *(float, const CoVector3 &u);
	friend CoVector3	operator /(const CoVector3 &u, float a);
	friend int			operator ==(const CoVector3 &u, const CoVector3 &v);
	friend int			operator !=(const CoVector3 &u, const CoVector3 &v);

	friend CoVector3 &	operator +=(CoVector3 &u, const CoVector3 &v);
	friend CoVector3 &	operator -=(CoVector3 &u, const CoVector3 &v);
	friend CoVector3 &	operator *=(CoVector3 &u, float a);
	friend CoVector3 &	operator /=(CoVector3 &u, float a);

#ifndef DISABLE_CROSSDOT
	friend CoVector3	Cross(const CoVector3 &u, const CoVector3 &v);
	friend float		Dot(const CoVector3 &u, const CoVector3 &v);
#endif
	friend int			IsEqual(const CoVector3 &u, const CoVector3 &v);

						operator const float *() const { return &x; }

	Vector3				Transpose() const;
	float				Norm() const;
	float 				NormSquared() const;
	void				SetNorm(float a);
	CoVector3			Unit() const;
	void				Unitize();
	friend float		operator *(const CoVector3 &c, const Vector3 &u);	// linear form
	void				Negate();

public:
	float				x, y, z;
};


////////////
// Vector2
////////////

inline Vector2
operator +(const Vector2 &u, const Vector2 &v)
{
	return Vector2(u.x+v.x, u.y+v.y);
}

inline Vector2
operator -(const Vector2 &u, const Vector2 &v)
{
	return Vector2(u.x-v.x, u.y-v.y);
}

inline Vector2
operator -(const Vector2 &v)
{
	return Vector2(-v.x, -v.y);
}

inline Vector2
operator *(float a, const Vector2 &v)
{
	return Vector2(a*v.x, a*v.y);
}

inline Vector2
operator *(const Vector2 &v, float a)
{
	return Vector2(a*v.x, a*v.y);
}

inline Vector2
operator /(const Vector2 &v, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return Vector2(v.x * fTmp, v.y * fTmp);
}

inline int
operator ==(const Vector2 &u, const Vector2 &v)
{
	return ((u.x == v.x) && (u.y == v.y));
}

inline int
IsEqual(const Vector2 &u, const Vector2 &v)
{
	return (FloatEquals(u.x, v.x) && FloatEquals(u.y, v.y));
}

inline int
operator !=(const Vector2 &u, const Vector2 &v)
{
	return !(u == v);
}

inline Vector2 &
operator +=(Vector2 &u, const Vector2 &v)
{
	u.x += v.x; 
	u.y += v.y;
	return u;
}

inline Vector2 &
operator -=(Vector2 &u, const Vector2 &v)
{
	u.x -= v.x; 
	u.y -= v.y;
	return u;
}

inline Vector2 &
operator *=(Vector2 &u, float a)
{
	u.x *= a;
	u.y *= a;
	return u;
}

inline Vector2 &
operator /=(Vector2 &u, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	u.x *= fTmp;
	u.y *= fTmp;
	return u;
}

#ifndef DISABLE_CROSSDOT
inline float
Cross(const Vector2 &u, const Vector2 &v)
{
	return u.x*v.y - u.y*v.x;
}

inline float
Dot(const Vector2 &u, const Vector2 &v)
{
	return u.x*v.x + u.y*v.y;
}
#endif

inline CoVector2
Vector2::Transpose() const
{
	return CoVector2(x, y);
}

inline Vector2
Vector2::Unit() const
{
	return *this/this->Norm();
}

inline void
Vector2::Unitize()
{
	*this /= this->Norm();
}

inline Vector2
Vector2::Perp() const
{
	return Vector2(-y, x);
}

inline float
Vector2::NormSquared() const
{
	return x*x + y*y;
}

inline void
Vector2::SetNorm(float a)
{
	*this *= (a / Norm());
}

inline void
Vector2::Negate()
{
	x = -x; y = -y;
}



//////////////
// CoVector2
//////////////

inline CoVector2
operator +(const CoVector2 &u, const CoVector2 &v)
{
	return CoVector2(u.x+v.x, u.y+v.y);
}

inline CoVector2
operator -(const CoVector2 &u, const CoVector2 &v)
{
	return CoVector2(u.x-v.x, u.y-v.y);
}

inline CoVector2
operator -(const CoVector2 &v)
{
	return CoVector2(-v.x, -v.y);
}

inline CoVector2
operator *(float a, const CoVector2 &v)
{
	return CoVector2(a*v.x, a*v.y);
}

inline CoVector2
operator *(const CoVector2 &v, float a)
{
	return CoVector2(a*v.x, a*v.y);
}

inline CoVector2
operator /(const CoVector2 &v, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return CoVector2(v.x * fTmp, v.y * fTmp);
}

inline int
operator ==(const CoVector2 &u, const CoVector2 &v)
{
	return ((u.x == v.x) && (u.y == v.y));
}

inline int
IsEqual(const CoVector2 &u, const CoVector2 &v)
{
	return (FloatEquals(u.x, v.x) && FloatEquals(u.y, v.y));
}

inline int
operator !=(const CoVector2 &u, const CoVector2 &v)
{
	return !(u == v);
}

inline CoVector2 &
operator +=(CoVector2 &u, const CoVector2 &v)
{
	u.x += v.x; 
	u.y += v.y;
	return u;
}

inline CoVector2 &
operator -=(CoVector2 &u, const CoVector2 &v)
{
	u.x -= v.x; 
	u.y -= v.y;
	return u;
}

inline CoVector2 &
operator *=(CoVector2 &u, float a)
{
	u.x *= a;
	u.y *= a;
	return u;
}

inline CoVector2 &
operator /=(CoVector2 &u, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	u.x *= fTmp;
	u.y *= fTmp;
	return u;
}

#ifndef DISABLE_CROSSDOT
inline float
Cross(const CoVector2 &u, const CoVector2 &v)
{
	return u.x*v.y - u.y*v.x;
}

inline float
Dot(const CoVector2 &u, const CoVector2 &v)
{
	return u.x*v.x + u.y*v.y;
}
#endif

inline Vector2
CoVector2::Transpose() const
{
	return Vector2(x, y);
}

inline CoVector2
CoVector2::Unit() const
{
	return *this/this->Norm();
}

inline void
CoVector2::Unitize()
{
	*this /= this->Norm();
}

inline float
operator *(const CoVector2 &c, const Vector2 &v)
{
	return c.x*v.x + c.y*v.y;
}

inline CoVector2
CoVector2::Perp() const
{
	return CoVector2(-y, x);
}

inline float
CoVector2::NormSquared() const
{
	return x*x + y*y;
}

inline void
CoVector2::SetNorm(float a)
{
	*this *= (a / Norm());
}

inline void
CoVector2::Negate()
{
	x = -x; y = -y;
}

////////////
// Vector3
////////////

inline Vector3
operator +(const Vector3 &u, const Vector3 &v)
{
	return Vector3(u.x+v.x, u.y+v.y, u.z+v.z);
}

inline Vector3
operator -(const Vector3 &u, const Vector3 &v)
{
	return Vector3(u.x-v.x, u.y-v.y, u.z-v.z);
}

inline Vector3
operator -(const Vector3 &v)
{
	return Vector3(-v.x, -v.y, -v.z);
}

inline Vector3
operator *(float a, const Vector3 &v)
{
	return Vector3(a*v.x, a*v.y, a*v.z);
}

inline Vector3
operator *(const Vector3 &v, float a)
{
	return Vector3(a*v.x, a*v.y, a*v.z);
}

inline Vector3
operator /(const Vector3 &v, float a)
{
	float fTmp = 1.f / a;
	return Vector3(v.x * fTmp, v.y * fTmp, v.z * fTmp);
}

inline int
operator ==(const Vector3 &u, const Vector3 &v)
{
	return ((u.x == v.x) && (u.y == v.y) && (u.z == v.z));
}

inline int
IsEqual(const Vector3 &u, const Vector3 &v)
{
	return (FloatEquals(u.x, v.x) && FloatEquals(u.y, v.y) && FloatEquals(u.z, v.z));
}

inline int
operator !=(const Vector3 &u, const Vector3 &v)
{
	return !(u == v);
}

inline Vector3 &
operator +=(Vector3 &u, const Vector3 &v)
{
	u.x += v.x; 
	u.y += v.y;
	u.z += v.z;
	return u;
}

inline Vector3 &
operator -=(Vector3 &u, const Vector3 &v)
{
	u.x -= v.x; 
	u.y -= v.y;
	u.z -= v.z;
	return u;
}

inline Vector3 &
operator *=(Vector3 &u, float a)
{
	u.x *= a;
	u.y *= a;
	u.z *= a;
	return u;
}

inline Vector3 &
operator /=(Vector3 &u, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	u.x *= fTmp;
	u.y *= fTmp;
	u.z *= fTmp;
	return u;
}

#ifndef DISABLE_CROSSDOT
inline Vector3
Cross(const Vector3 &u, const Vector3 &v)
{
	return Vector3(u.y*v.z-u.z*v.y, u.z*v.x-u.x*v.z, u.x*v.y-u.y*v.x);
}

inline float
Dot(const Vector3 &u, const Vector3 &v)
{
	return u.x*v.x + u.y*v.y + u.z*v.z;
}
#endif

inline float
operator *(const CoVector3 &c, const Vector3 &v)
{
	return c.x*v.x + c.y*v.y + c.z*v.z;
}

inline CoVector3
Vector3::Transpose() const
{
	return CoVector3(x, y, z);
}

inline Vector3
Vector3::Unit() const
{
	return *this/this->Norm();
}

inline void
Vector3::Unitize()
{
	*this /= this->Norm();
}

inline float
Vector3::NormSquared() const
{
	return x*x + y*y + z*z;
}

inline void
Vector3::SetNorm(float a)
{
	*this *= (a / Norm());
}

inline void
Vector3::Negate()
{
	x = -x; y = -y; z = -z;
}

inline Vector2
Vector3::Project(DWORD iAxis) const
{
	switch (iAxis) {
	case 0: return Vector2(y, z);
	case 1: return Vector2(x, z);
	case 2: return Vector2(x, y);
	}
	return Vector2(0.f, 0.f);
}

//////////////
// CoVector3
//////////////

inline CoVector3
operator +(const CoVector3 &u, const CoVector3 &v)
{
	return CoVector3(u.x+v.x, u.y+v.y, u.z+v.z);
}

inline CoVector3
operator -(const CoVector3 &u, const CoVector3 &v)
{
	return CoVector3(u.x-v.x, u.y-v.y, u.z-v.z);
}

inline CoVector3
operator -(const CoVector3 &v)
{
	return CoVector3(-v.x, -v.y, -v.z);
}

inline CoVector3
operator *(float a, const CoVector3 &v)
{
	return CoVector3(a*v.x, a*v.y, a*v.z);
}

inline CoVector3
operator *(const CoVector3 &v, float a)
{
	return CoVector3(a*v.x, a*v.y, a*v.z);
}

inline CoVector3
operator /(const CoVector3 &v, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return CoVector3(v.x * fTmp, v.y * fTmp, v.z * fTmp);
}

inline int
operator ==(const CoVector3 &u, const CoVector3 &v)
{
	return ((u.x == v.x) && (u.y == v.y) && (u.z == v.z));
}

inline int
IsEqual(const CoVector3 &u, const CoVector3 &v)
{
	return (FloatEquals(u.x, v.x) && FloatEquals(u.y, v.y) && FloatEquals(u.z, v.z));
}

inline int
operator !=(const CoVector3 &u, const CoVector3 &v)
{
	return !(u == v);
}

inline CoVector3 &
operator +=(CoVector3 &u, const CoVector3 &v)
{
	u.x += v.x; 
	u.y += v.y;
	u.z += v.z;
	return u;
}

inline CoVector3 &
operator -=(CoVector3 &u, const CoVector3 &v)
{
	u.x -= v.x; 
	u.y -= v.y;
	u.z -= v.z;
	return u;
}

inline CoVector3 &
operator *=(CoVector3 &u, float a)
{
	u.x *= a;
	u.y *= a;
	u.z *= a;
	return u;
}

inline CoVector3 &
operator /=(CoVector3 &u, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	u.x *= fTmp;
	u.y *= fTmp;
	u.z *= fTmp;
	return u;
}

#ifndef DISABLE_CROSSDOT
inline CoVector3
Cross(const CoVector3 &u, const CoVector3 &v)
{
	return CoVector3(u.y*v.z-u.z*v.y, u.z*v.x-u.x*v.z, u.x*v.y-u.y*v.x);
}

inline float
Dot(const CoVector3 &u, const CoVector3 &v)
{
	return u.x*v.x + u.y*v.y + u.z*v.z;
}
#endif

inline Vector3
CoVector3::Transpose() const
{
	return Vector3(x, y, z);
}

inline CoVector3
CoVector3::Unit() const
{
	return *this/this->Norm();
}

inline void
CoVector3::Unitize()
{
	*this /= this->Norm();
}

inline float
CoVector3::NormSquared() const
{
	return x*x + y*y + z*z;
}

inline void
CoVector3::SetNorm(float a)
{
	*this *= (a / Norm());
}

inline void
CoVector3::Negate()
{
	x = -x; y = -y; z = -z;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dsppath.cpp ===
////    DspPath.CPP - Display plaintext using AddString and DrawPath APIs
//
//


#include "precomp.hxx"
#include "global.h"




void PaintPath(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;


    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;


    // Draw a simple figure in the world coordinate system

    Graphics g(hdc);
    Matrix matrix;

    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));

    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(&whiteBrush, rEntire);


    // Apply selected world transform, adjusted to middle of the plain text
    // area.

    g.SetTransform(&g_WorldTransform);
    g.TranslateTransform(
        REAL(prc->left + plainTextWidth/2),
        REAL(*piY + plainTextHeight/2),
        MatrixOrderAppend);

    // Put some text in the middle

    RectF textRect(REAL(-25*plainTextWidth/100), REAL(-25*plainTextHeight/100),
                   REAL( 50*plainTextWidth/100), REAL( 50*plainTextHeight/100));



    StringFormat format(g_formatFlags);
    format.SetTrimming(g_lineTrim);
    format.SetAlignment(g_align);
    format.SetLineAlignment(g_lineAlign);
    format.SetHotkeyPrefix(g_hotkey);

    REAL tab[3] = {textRect.Width/4,
                   textRect.Width*3/16,
                   textRect.Width*1/8};

    format.SetTabStops(0.0, sizeof(tab)/sizeof(REAL), tab);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);
	
	for(int iRender=0;iRender<g_iNumRenders;iRender++)
	{
	    GraphicsPath path;
	
	    path.AddString(
	        g_wcBuf,
	        g_iTextLen,
	       &FontFamily(g_style[0].faceName),
	        g_style[0].style,
	        REAL(g_style[0].emSize * g.GetDpiY() / 72.0),
	       textRect,
	       &format);
	
	    g.DrawPath(&blackPen, &path);
	}

    // Show the text rectangle

	if (!g_AutoDrive)
	{
	    g.DrawRectangle(&blackPen, textRect);
	}

    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dspmetric.cpp ===
////    DspMetric.CPP - Display font metrics
//
//


#include "precomp.hxx"
#include "global.h"




void AnnotateHeight(
    Graphics &g,
    Color     c,
    Font     &f,
    REAL      x,
    REAL      y1,
    REAL      y2,
    WCHAR    *id
)
{
    SolidBrush brush(c);
    Pen        pen(&brush, 2.0);

    pen.SetLineCap(LineCapArrowAnchor, LineCapArrowAnchor, DashCapFlat);

    g.DrawLine(&pen, x,y1, x,y2);
    g.DrawString(id,-1, &f, PointF(x,(y1+y2)/2), NULL, &brush);
}




void PaintMetrics(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;      // First character of line
    int      icpLineEnd;        // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;
    INT      row;
    INT      column;



    // Establish available width and height in device coordinates

    int DrawingWidth = prc->right - prc->left;
    int DrawingHeight = prc->bottom - *piY;

    // Establish a Graphics with 0,0 at the top left of the drawing area

    Graphics g(hdc);
    Matrix matrix;

    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));

    // Clear the background

    RectF rEntire(0, 0, REAL(DrawingWidth), REAL(DrawingHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(&whiteBrush, rEntire);


    // Leave a little space for right and bottom margins

    DrawingWidth  -= DrawingWidth/40;
    DrawingHeight -= DrawingHeight/40;

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 2.0);

    Color      grayColor(0xc0, 0xc0, 0xc0);
    SolidBrush grayBrush(grayColor);
    Pen        grayPen(&grayBrush, 2.0);


    // Measure the string to see how wide it would be

    FontFamily family(g_style[0].faceName);

    StringFormat format(StringFormat::GenericTypographic());
    format.SetFormatFlags(g_formatFlags | StringFormatFlagsNoWrap | StringFormatFlagsLineLimit);
    format.SetAlignment(g_align);

    RectF bounds;

    // Since we've chosen a size of 1.0 for the font height, MeasureString
    // will return the width as a multiple of the em height in bounds.Width.

    g.MeasureString(
        g_wcBuf,
        g_iTextLen,
        &Font(&family, 1.0, g_style[0].style, UnitWorld),
        PointF(0, 0),
        &format,
        &bounds
    );



    // Establish font metrics


    if (family.IsStyleAvailable(g_style[0].style))
    {
        // Establish line and cell dimensions in  units

        INT emHeight    = family.GetEmHeight(g_style[0].style);
        INT cellAscent  = family.GetCellAscent(g_style[0].style);
        INT cellDescent = family.GetCellDescent(g_style[0].style);
        INT lineSpacing = family.GetLineSpacing(g_style[0].style);

        #if TEXTV2
        INT typoAscent  = family.GetTypographicAscent(g_style[0].style);
        INT typoDescent = family.GetTypographicDescent(g_style[0].style);
        INT typoLineGap = family.GetTypographicLineGap(g_style[0].style);

        if (typoDescent < 0)
        {
            typoDescent = -typoDescent;
        }

        INT typoLineSpacing =   typoAscent + typoDescent + typoLineGap;
        #endif


        INT cellHeight      =   cellAscent + cellDescent;

        // We will display two lines from top of upper cell to bottom of lower
        // cell, with the lines separated by the typographic ascent + descent +
        // line gap.

        INT totalHeightInUnits = lineSpacing + cellHeight;
        REAL scale = REAL(DrawingHeight) / REAL(totalHeightInUnits);

        REAL worldEmHeight = emHeight * scale;



        // Now allow for the width of the string - if it would be wider than
        // the available DrawingWIdth, reduce the font size proportionately.

        if (worldEmHeight * bounds.Width > DrawingWidth)
        {
            REAL reduceBy = DrawingWidth / (worldEmHeight * bounds.Width);

            scale         *= reduceBy;
            worldEmHeight  = emHeight * scale;
        }

        Font font(&family, worldEmHeight, g_style[0].style, UnitWorld);


        // Draw two lines of text

        g.DrawString(
            g_wcBuf,
            g_iTextLen,
            &font,
            RectF(0, 0, REAL(DrawingWidth), REAL(DrawingHeight)),
            &format,
            &blackBrush
        );

        g.DrawString(
            g_wcBuf,
            g_iTextLen,
            &font,
            RectF(0, lineSpacing * scale, REAL(DrawingWidth), REAL(DrawingHeight)),
            &format,
            &grayBrush
        );

        // Draw lines

        REAL y=0;                                              g.DrawLine(&blackPen, 0.0,y, REAL(DrawingWidth-1),y);

        // Draw lines for second row first, in case they're oblitereated by first row.

        y = scale * (lineSpacing);                             g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (lineSpacing + cellAscent);                g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (lineSpacing + cellHeight);                g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);

        g.DrawLine(&blackPen, 0.0,0.0, REAL(DrawingWidth-1),0.0);
        y = scale * (cellAscent);                              g.DrawLine(&blackPen, 0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (cellHeight);                              g.DrawLine(&blackPen, 0.0,y, REAL(DrawingWidth-1),y);

        // Add construction lines.

        Font  annotationFont(FontFamily::GenericSansSerif(), 10, 0, UnitPoint);
        Color darkGrayColor(0x80, 0x80, 0x80);

        AnnotateHeight(g, darkGrayColor, annotationFont, REAL(DrawingWidth/100.0),    0, scale*cellAscent, L"ascent");
        AnnotateHeight(g, darkGrayColor, annotationFont, REAL(DrawingWidth/100.0),    scale*cellAscent, scale*cellHeight, L"descent");
        AnnotateHeight(g, darkGrayColor, annotationFont, REAL(95*DrawingWidth/100.0), 0, scale*lineSpacing, L"line spacing");
        AnnotateHeight(g, darkGrayColor, annotationFont, REAL(DrawingWidth/10.0),     scale*(cellHeight-emHeight), scale*cellHeight, L"Em Height");


        #if TEXTV2
        y = scale * (cellAscent - typoAscent);                 g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (cellAscent + typoDescent);                g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);

        y = scale * (lineSpacing + cellAscent - typoAscent);   g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (lineSpacing + cellAscent + typoDescent);  g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        #endif


        // Test font.GetHeight

        REAL fontHeight = font.GetHeight(&g);

        g.DrawLine(&blackPen, REAL(DrawingWidth-1),0.0, REAL(DrawingWidth-1),fontHeight);

    }

    *piY += 41*DrawingHeight/40;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dspscaling.cpp ===
////    DspScaling.CPP - DIsplay effect of hinting on text scaling
//
//      Tests for clipping and alignment problems in scaled text
//
//      Fixed pitch font misalignment
//      Leading space alignment
//      Overhang sufficient for italic and other overhanging glyphs
//



#include "precomp.hxx"
#include "global.h"
#include "gdiplus.h"






// Makebitmap

void MakeBitmap(
    IN  INT       width,
    IN  INT       height,
    OUT HBITMAP  *bitmap,
    OUT DWORD   **bits
)
{
    struct {
        BITMAPINFOHEADER  bmih;
        RGBQUAD           rgbquad[2];
    } bmi;

    bmi.bmih.biSize          = sizeof(bmi.bmih);
    bmi.bmih.biWidth         = width;
    bmi.bmih.biHeight        = height;
    bmi.bmih.biPlanes        = 1;
    bmi.bmih.biBitCount      = 32;
    bmi.bmih.biCompression   = BI_RGB;
    bmi.bmih.biSizeImage     = 0;
    bmi.bmih.biXPelsPerMeter = 3780; // 96 dpi
    bmi.bmih.biYPelsPerMeter = 3780; // 96 dpi
    bmi.bmih.biClrUsed       = 0;
    bmi.bmih.biClrImportant  = 0;

    memset(bmi.rgbquad, 0, 2 * sizeof(RGBQUAD));

    *bitmap = CreateDIBSection(
        NULL,
        (BITMAPINFO*)&bmi,
        DIB_RGB_COLORS,
        (void**)bits,
        NULL,
        NULL
    );
    
    
    // Initialise bitmap to white
    
    memset(*bits, 0xFF, width*height*sizeof(DWORD));
}




void PaintStringAsDots(
    HDC      hdc,
    INT      x,
    INT      *y, 
    INT      displayWidth,
    INT      ppem,
    BOOL     useGdi
)
{

    HBITMAP glyphs;
    DWORD *gbits;

    INT height = (ppem * 3) / 2;
    INT width = height * 16;

    MakeBitmap(width, height, &glyphs, &gbits);

    HDC hdcg = CreateCompatibleDC(hdc);

    if (!(glyphs && hdcg))
    {
        return;
    }

    SelectObject(hdcg, glyphs);
    
    if (useGdi) 
    {
        // Output with GDI

        HFONT oldFont = (HFONT)SelectObject(hdcg, CreateFontW(
            -ppem,                 // height of font
            0,                     // average character width
            0,                     // angle of escapement
            0,                     // base-line orientation angle
            g_style[0].style & FontStyleBold ? 700 : 400,  // font weight                
            g_style[0].style & FontStyleItalic ? 1 : 0,    // italic attribute option    
            0,                     // underline attribute option 
            0,                     // strikeout attribute option 
            DEFAULT_CHARSET,       // character set identifier   
            0,                     // output precision           
            0,                     // clipping precision         
            0,                     // output quality             
            0,                     // pitch and family           
            g_style[0].faceName    // typeface name
        ));        
        SetBkMode(hdcg, TRANSPARENT);
        ExtTextOutW(hdcg, 0,0, ETO_IGNORELANGUAGE, NULL, g_wcBuf, g_iTextLen, NULL);
        DeleteObject(SelectObject(hdcg, oldFont));
    }
    else
    {
        // Output with Gdiplus

        Graphics g(hdcg);

        Font(
            &FontFamily(g_style[0].faceName),
            REAL(ppem),
            g_style[0].style,
            UnitPixel
        );

        StringFormat format(g_typographic ? StringFormat::GenericTypographic() : StringFormat::GenericDefault());
        format.SetFormatFlags(g_formatFlags);
        format.SetTrimming(g_lineTrim);
        format.SetAlignment(g_align);
        format.SetLineAlignment(g_lineAlign);
        format.SetHotkeyPrefix(g_hotkey);

        g.DrawString(
            g_wcBuf, 
            g_iTextLen, 
            &Font(
                &FontFamily(g_style[0].faceName),
                REAL(ppem),
                g_style[0].style,
                UnitPixel
            ), 
            RectF(0,0, REAL(width), REAL(height)),
            &format, 
            g_textBrush
        );
    }
    

    // Display scaled bitmap

    StretchBlt(hdc, x, *y, displayWidth, displayWidth/16, hdcg, 0, 0, width, height, SRCCOPY);
    *y += displayWidth/16;

    DeleteObject(hdcg);
    DeleteObject(glyphs);
}






void PaintScaling(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {


    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;

    // Paint eqach resolution first with GDI, then again with GdiPlus
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 11, TRUE);  // 96  dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 11, FALSE); // 96  dpi 8pt
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 13, TRUE);  // 120 dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 13, FALSE); // 120 dpi 8pt
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 17, TRUE);  // 150 dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 17, FALSE); // 150 dpi 8pt
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 33, TRUE);  // 300 dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 33, FALSE); // 300 dpi 8pt
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 67, TRUE);  // 600 dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 67, FALSE); // 600 dpi 8pt
}



void DummyPaintScaling(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight
) 
{
    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)

    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;

    Graphics g(hdc);
    Matrix matrix;


    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));

    g.SetSmoothingMode(g_SmoothingMode);

    g.SetTextContrast(g_GammaValue);
    g.SetTextRenderingHint(g_TextMode);

    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));

    Color      grayColor(0xc0, 0xc0, 0xc0);
    SolidBrush grayBrush(grayColor);
    Pen        grayPen(&grayBrush, 1.0);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);



    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    g.FillRectangle(g_textBackBrush, rEntire);


    // Apply selected world transform, adjusted to middle of the plain text
    // area.

    g.SetTransform(&g_WorldTransform);
    g.TranslateTransform(
        REAL(prc->left + plainTextWidth/2),
        REAL(*piY + plainTextHeight/2),
        MatrixOrderAppend);


    // Preset a StringFormat with user settings

    StringFormat format(g_formatFlags);
    format.SetAlignment(g_align);
    format.SetLineAlignment(g_lineAlign);
    format.SetHotkeyPrefix(g_hotkey);

    double columnWidth = 50*plainTextWidth/300;

    REAL tab[3] = {REAL(columnWidth/4),
                   REAL(columnWidth*3/16),
                   REAL(columnWidth*1/8)};

    format.SetTabStops(0.0, sizeof(tab)/sizeof(REAL), tab);


    // Display string at a range of sizes

    double x = -25*plainTextWidth/100;
    double y = -25*plainTextHeight/100;


    for (INT i=6; i<20; i++)
    {
        Font font(
            &FontFamily(g_style[0].faceName),
            REAL(i),
            g_style[0].style,
            g_fontUnit
        );

        REAL cellHeight = font.GetHeight(&g);

        if (y+cellHeight > 25*plainTextHeight/100)
        {
            // Start a new column ...
            y = -25*plainTextWidth/100;
            x += columnWidth;
        }

        RectF textRect(REAL(x), REAL(y), REAL(9*columnWidth/10), cellHeight);
        g.DrawString(g_wcBuf, g_iTextLen, &font, textRect, &format, g_textBrush);


        // Draw formatting rectangle around box

        g.DrawRectangle(&grayPen, textRect);


        y += cellHeight + 5;
    }

    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\dspperf.cpp ===
////    DspPerf.CPP - Test and display performance
//
//


#include "precomp.hxx"
#include "global.h"


#if defined(i386)


double TimeDrawString(
    Graphics  *g,
    RectF     *textRect
)
{
    StringFormat format(g_formatFlags);
    format.SetAlignment(g_align);
    format.SetLineAlignment(g_lineAlign);
    format.SetHotkeyPrefix(g_hotkey);

    REAL tab[3] = {textRect->Width/4,
                   textRect->Width*3/16,
                   textRect->Width*1/8};

    format.SetTabStops(0.0, sizeof(tab)/sizeof(REAL), tab);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);

    Font font(&FontFamily(g_style[0].faceName), REAL(g_style[0].emSize), g_style[0].style, g_fontUnit);


    // Once to load the cache

    g->DrawString(g_wcBuf, g_iTextLen, &font, *textRect, &format, g_textBrush);

    ShowCursor(FALSE);
    g->Flush(FlushIntentionSync);
    GdiFlush();

    __int64 timeAtStart;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtStart+4,edx
        mov dword ptr timeAtStart,eax
    }

    // Now paint again repeatedly and measure the time taken

    for (INT i=0; i<g_PerfRepeat; i++)
    {
        g->DrawString(g_wcBuf, g_iTextLen, &font, *textRect, &format, g_textBrush);
    }

    g->Flush(FlushIntentionSync);
    GdiFlush();

    __int64 timeAtEnd;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtEnd+4,edx
        mov dword ptr timeAtEnd,eax
    }

    ShowCursor(TRUE);

    return (timeAtEnd - timeAtStart) / 1000000.0;
}



double TimeDrawText(
    Graphics *g,
    INT x,
    INT y,
    INT width,
    INT height
)
{
    g->Flush(FlushIntentionSync);   // Th is may not be necessary.
    HDC hdc = g->GetHDC();

    HFONT hfont = CreateFontW(
        -(INT)(g_style[0].emSize + 0.5),
        0,  //  int nWidth,                // average character width
        0,  //  int nEscapement,           // angle of escapement
        0,  //  int nOrientation,          // base-line orientation angle
        g_style[0].style & FontStyleBold ? 700 : 400,
        g_style[0].style & FontStyleItalic ? 1 : 0,
        g_style[0].style & FontStyleUnderline ? 1 : 0,
        g_style[0].style & FontStyleStrikeout ? 1 : 0,
        0,  //  DWORD fdwCharSet,          // character set identifier
        0,  //  DWORD fdwOutputPrecision,  // output precision
        0,  //  DWORD fdwClipPrecision,    // clipping precision
        NONANTIALIASED_QUALITY,  //  DWORD fdwQuality,          // output quality
        0,  //  DWORD fdwPitchAndFamily,   // pitch and family
        g_style[0].faceName
    );
    HFONT hOldFont = (HFONT) SelectObject(hdc, hfont);

    RECT textRECT;
    textRECT.left   = x;
    textRECT.top    = y;
    textRECT.right  = x + width;
    textRECT.bottom = y + height;

    SetBkMode(hdc, TRANSPARENT);

    DrawTextW(
        hdc,
        g_wcBuf,
        g_iTextLen,
        &textRECT,
        DT_EXPANDTABS | DT_WORDBREAK
    );

    ShowCursor(FALSE);
    GdiFlush();

    __int64 timeAtStart;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtStart+4,edx
        mov dword ptr timeAtStart,eax
    }

    // Now paint again repeatedly and measure the time taken

    for (INT i=0; i<g_PerfRepeat; i++)
    {
        DrawTextW(
            hdc,
            g_wcBuf,
            g_iTextLen,
            &textRECT,
            DT_EXPANDTABS | DT_WORDBREAK
        );
    }

    GdiFlush();

    __int64 timeAtEnd;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtEnd+4,edx
        mov dword ptr timeAtEnd,eax
    }

    ShowCursor(TRUE);
    DeleteObject(SelectObject(hdc, hOldFont));

    g->ReleaseHDC(hdc);

    return (timeAtEnd - timeAtStart) / 1000000.0;
}


double TimeExtTextOut(
    Graphics *g,
    INT x,
    INT y,
    INT width,
    INT height
)
{
    HDC hdc = g->GetHDC();

    HFONT hfont = CreateFontW(
        -(INT)(g_style[0].emSize + 0.5),
        0,  //  int nWidth,                // average character width
        0,  //  int nEscapement,           // angle of escapement
        0,  //  int nOrientation,          // base-line orientation angle
        g_style[0].style & FontStyleBold ? 700 : 400,
        g_style[0].style & FontStyleItalic ? 1 : 0,
        g_style[0].style & FontStyleUnderline ? 1 : 0,
        g_style[0].style & FontStyleStrikeout ? 1 : 0,
        0,  //  DWORD fdwCharSet,          // character set identifier
        0,  //  DWORD fdwOutputPrecision,  // output precision
        0,  //  DWORD fdwClipPrecision,    // clipping precision
        NONANTIALIASED_QUALITY,  //  DWORD fdwQuality,          // output quality
        0,  //  DWORD fdwPitchAndFamily,   // pitch and family
        g_style[0].faceName
    );
    HFONT hOldFont = (HFONT) SelectObject(hdc, hfont);

    RECT textRECT;
    textRECT.left   = x;
    textRECT.top    = y;
    textRECT.right  = x + width;
    textRECT.bottom = y + height;

    SetBkMode(hdc, TRANSPARENT);

    ExtTextOutW(
        hdc,
        textRECT.left,
        textRECT.top,
        ETO_IGNORELANGUAGE,
        &textRECT,
        g_wcBuf,
        g_iTextLen,
        NULL
    );

    ShowCursor(FALSE);
    GdiFlush();

    __int64 timeAtStart;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtStart+4,edx
        mov dword ptr timeAtStart,eax
    }

    // Now paint again repeatedly and measure the time taken

    for (INT i=0; i<g_PerfRepeat; i++)
    {
        ExtTextOutW(
            hdc,
            textRECT.left,
            textRECT.top,
            ETO_IGNORELANGUAGE,
            &textRECT,
            g_wcBuf,
            g_iTextLen,
            NULL
        );
    }

    GdiFlush();

    __int64 timeAtEnd;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtEnd+4,edx
        mov dword ptr timeAtEnd,eax
    }

    ShowCursor(TRUE);
    DeleteObject(SelectObject(hdc, hOldFont));

    g->ReleaseHDC(hdc);

    return (timeAtEnd - timeAtStart) / 1000000.0;
}

#endif // defined(i386)


void PaintPerformance(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;


    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;


    // Paint some simple text, and then repaint it several times measuring the
    // time taken.

    Graphics g(hdc);
    Matrix matrix;


    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));
    g.SetSmoothingMode(g_SmoothingMode);

    g.SetTextContrast(g_GammaValue);
    g.SetTextRenderingHint(g_TextMode);

    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(g_textBackBrush, rEntire);


    // Apply selected world transform, adjusted a little from the top left
    // of the available area.

    g.SetTransform(&g_WorldTransform);
    g.TranslateTransform(
        REAL(prc->left + plainTextWidth/20),
        REAL(*piY + plainTextHeight/20),
        MatrixOrderAppend);


#if defined(i386)


    double drawString = TimeDrawString(
        &g,
        &RectF(
            0.0,
            0.0,
            REAL(plainTextWidth*18.0/20.0),
            REAL(plainTextHeight*5.0/20.0)
        )
    );

    double drawText = TimeDrawText(
        &g,
        prc->left + plainTextWidth/20,
        *piY + 6*plainTextHeight/20,
        (18 * plainTextWidth)/20,
        (5 * plainTextHeight)/20
    );

    double extTextOut = TimeExtTextOut(
        &g,
        prc->left + plainTextWidth/20,
        *piY + 12*plainTextHeight/20,
        (18 * plainTextWidth)/20,
        (2 * plainTextHeight)/20
    );

    // Display the time taken

    RectF statisticsRect(
        0.0,
        REAL(plainTextHeight*15.0/20.0),
        REAL(plainTextWidth*18.0/20.0),
        REAL(plainTextHeight*5.0/20.0)
    );

    Font font(&FontFamily(L"Verdana"), 12, 0, UnitPoint);

    char drawStringFormatted[20]; _gcvt(drawString, 10, drawStringFormatted);
    char drawTextFormatted[20];   _gcvt(drawText,   10, drawTextFormatted);
    char extTextOutFormatted[20]; _gcvt(extTextOut, 10, extTextOutFormatted);

    WCHAR str[200];
    wsprintfW(str, L"Time taken to display %d times: DrawString %S, DrawText %S, ExtTextOut %S megaticks\n",
        g_PerfRepeat,
        drawStringFormatted,
        drawTextFormatted,
        extTextOutFormatted
    );
    g.DrawString(str, -1, &font, statisticsRect, NULL, g_textBrush);



#else

    Font font(&FontFamily(L"Verdana"), 12, 0, UnitPoint);
    g.DrawString(L"Perf test available only on i386 Intel architecture", -1, &font, PointF(0.0,0.0), NULL, g_textBrush);

#endif

    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\edit.cpp ===
////    TEXTEDIT.C
//
//


#include "precomp.hxx"
#include "global.h"





BOOL EditKeyDown(WCHAR wc) {

    switch(wc) {

        case VK_LEFT:
            if (g_iCurChar) {
                g_iCurChar--;
                if (    g_iCurChar
                    &&  g_wcBuf[g_iCurChar] == 0x000A
                    &&  g_wcBuf[g_iCurChar-1] == 0x000D) {
                    g_iCurChar--;
                }

                // If shift is down, extend selection, else clear it
                if (GetKeyState(VK_SHIFT) >= 0) {
                    g_iFrom = g_iCurChar;
                }
                g_iTo = g_iCurChar;

                InvalidateText();
                g_fUpdateCaret = TRUE;
            }
            break;


        case VK_RIGHT:
            if (g_iCurChar < g_iTextLen) {
                if (    g_iCurChar < g_iTextLen-1
                    &&  g_wcBuf[g_iCurChar] == 0x000D
                    &&  g_wcBuf[g_iCurChar+1] == 0x000A) {
                    g_iCurChar+= 2;
                } else {
                    g_iCurChar++;
                }

                // If shift is down, extend selection, else clear it
                if (GetKeyState(VK_SHIFT) >= 0) {
                    g_iFrom = g_iCurChar;
                }
                g_iTo = g_iCurChar;

                InvalidateText();
                g_fUpdateCaret = TRUE;
            }
            break;


        case VK_HOME:
            // Implemented as - go to start of text
            g_iCurChar = 0;
            g_iFrom    = 0;
            g_iTo      = 0;
            InvalidateText();
            g_fUpdateCaret = TRUE;
            break;


        case VK_END:
            // Implemented as - go to end of text
            g_iCurChar = g_iTextLen;
            g_iFrom    = g_iTextLen;
            g_iTo      = g_iTextLen;
            InvalidateText();
            g_fUpdateCaret = TRUE;
            break;

        case VK_INSERT:
            if (g_RangeCount < MAX_RANGE_COUNT)
            {
                g_Ranges[g_RangeCount].First = g_iFrom;
                g_Ranges[g_RangeCount].Length = g_iTo - g_iFrom;
                g_RangeCount++;
            }
            InvalidateText();
            break;

        case VK_DELETE:
            if (GetKeyState(VK_LSHIFT) & 0x8000)
            {
                g_RangeCount = 0;
            }
            else
            {
                if (g_iFrom != g_iTo) {

                    // Delete selection

                    if (g_iFrom < g_iTo) {
                        TextDelete(g_iFrom, g_iTo-g_iFrom);
                        g_iTo      = g_iFrom;
                        g_iCurChar = g_iFrom;
                    } else {
                        TextDelete(g_iTo, g_iFrom-g_iTo);
                        g_iTo      = g_iTo;
                        g_iCurChar = g_iTo;
                    }

                } else {

                    // Delete character

                    if (g_iCurChar < g_iTextLen) {
                        if (    g_iCurChar < g_iTextLen-1
                            &&  g_wcBuf[g_iCurChar] == 0x000D
                            &&  g_wcBuf[g_iCurChar+1] == 0x000A) {
                            TextDelete(g_iCurChar, 2);
                        } else {
                            TextDelete(g_iCurChar, 1);
                        }
                    }
                }
            }

            InvalidateText();
            g_fUpdateCaret = TRUE;
            break;
    }

    return TRUE;
}






BOOL EditChar(WCHAR wc) {

    switch(wc) {

        case VK_RETURN:
            if (!TextInsert(g_iCurChar, L"\r\n", 2))
                return FALSE;
            InvalidateText();
            g_iCurChar+=2;
            break;


        case VK_BACK:
            if (g_iCurChar) {
                g_iCurChar--;
                if (    g_iCurChar
                    &&  g_wcBuf[g_iCurChar] == 0x000A
                    &&  g_wcBuf[g_iCurChar-1] == 0x000D) {
                    g_iCurChar--;
                    TextDelete(g_iCurChar, 2);
                } else {
                    TextDelete(g_iCurChar, 1);
                }
                InvalidateText();
                g_fUpdateCaret = TRUE;
            }
            break;


        case 1:  // Ctrl/A - select all
            g_iFrom = 0;
            g_iTo = g_iTextLen;
            InvalidateText();
            break;


        default:
            /*
                if(!((wc >= 0x0900 && wc < 0x0d80)
                      || wc == 0x200c
                      || wc == 0x200d)){
                    TranslateCharToUnicode(&wc);
                }
            */

            if (!TextInsert(g_iCurChar, &wc, 1)) {
                return FALSE;
            }


            // If there was a range marked previously, now delete that range

            if (g_iFrom < g_iTo) {
                TextDelete(g_iFrom, g_iTo-g_iFrom);
                g_iTo      = g_iFrom;
                g_iCurChar = g_iFrom+1;
            } else if (g_iTo < g_iFrom) {
                TextDelete(g_iTo, g_iFrom-g_iTo);
                g_iFrom    = g_iTo;
                g_iCurChar = g_iTo+1;
            } else {
                // No prior selected text
                g_iCurChar++;

            }

            InvalidateText();
            g_fUpdateCaret = TRUE;
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\readprofile.cpp ===
//
// ReadProfile.cpp - Routine to parse a windows Profile file and setup globals
//

#include "precomp.hxx"
#include "global.h"
#include "winspool.h"
#include <Tchar.h>

// Pre-defined section names
#define SECTION_CONTROL      "Control"
#define SECTION_FONT         "Font"
#define SECTION_RENDER       "Render"
#define SECTION_API          "API"
#define SECTION_FONTLIST     "FontList"
#define SECTION_FONTHEIGHT   "FontHeight"
#define SECTION_AUTOFONTS    "AutoFonts"
#define SECTION_AUTOHEIGHTS  "AutoHeights"
#define SECTION_DRIVERSTRING "DriverString"

// Maximum length for a profile value string...
#define PROFILEVALUEMAX 4096

// Enumeration of profile variable types
typedef enum
{
    epitInvalid = 0,              // Invalid value
    epitBool    = 1,              // BOOL value
    epitInt     = 2,              // system integer (32 bits on x86) value
    epitFloat   = 3,              // single-precision floating point value
    epitDouble  = 4,              // double-precision floating point value
    epitString  = 5,              // ANSI string value
    epitAlign   = 6,              // StringAlignment value
    epitColor   = 7               // RGBQUAD color
} PROFILEINFOTYPE;

// profile information structure
typedef struct PROFILEINFO_tag
{
    char szSection[80];     // Section of the profile to read value from
    char szVariable[80];    // Name of the variable
    PROFILEINFOTYPE type;   // Type of the variable
    void *pvVariable;       // void * to the variable (&g_Foo...)
    DWORD dwVariableLength; // size in bytes of the variable (sizeof(g_Foo...))
} PROFILEINFO;

////////////////////////////////////////////////////////////////////////////////////////
// Global profile info structure : Add to this table to get a variable from the .INI
////////////////////////////////////////////////////////////////////////////////////////
PROFILEINFO g_rgProfileInfo[] =
{
    { SECTION_CONTROL,     "AutoDrive",       epitBool,    &g_AutoDrive,         sizeof(g_AutoDrive) },
    { SECTION_CONTROL,     "NumIterations",   epitInt,     &g_iNumIterations,    sizeof(g_iNumIterations) },
    { SECTION_CONTROL,     "NumRepaints",     epitInt,     &g_iNumRepaints,      sizeof(g_iNumRepaints) },
    { SECTION_CONTROL,     "NumRenders",      epitInt,     &g_iNumRenders,       sizeof(g_iNumRenders) },
    { SECTION_CONTROL,     "AutoFonts",       epitBool,    &g_AutoFont,          sizeof(g_AutoFont) },
    { SECTION_CONTROL,     "AutoHeight",      epitBool,    &g_AutoHeight,        sizeof(g_AutoHeight) },
    { SECTION_CONTROL,     "TextFile",        epitString,  &g_szSourceTextFile,  sizeof(g_szSourceTextFile) },
    { SECTION_CONTROL,     "FontOverride",    epitBool,    &g_FontOverride,      sizeof(g_FontOverride) },
    { SECTION_API,         "DrawString",      epitBool,    &g_ShowDrawString,    sizeof(g_ShowDrawString) },
    { SECTION_API,         "ShowDriver",      epitBool,    &g_ShowDriver,        sizeof(g_ShowDriver) },
    { SECTION_API,         "ShowPath",        epitBool,    &g_ShowPath,          sizeof(g_ShowPath) },
    { SECTION_API,         "ShowFamilies",    epitBool,    &g_ShowFamilies,      sizeof(g_ShowFamilies) },
    { SECTION_API,         "ShowGlyphs",      epitBool,    &g_ShowGlyphs,        sizeof(g_ShowGlyphs) },
    { SECTION_API,         "ShowMetric",      epitBool,    &g_ShowMetric,        sizeof(g_ShowMetric) },
    { SECTION_API,         "ShowGDI",         epitBool,    &g_ShowGDI,           sizeof(g_ShowGDI) },
    { SECTION_API,         "UseDrawText",     epitBool,    &g_UseDrawText,       sizeof(g_UseDrawText) },
    { SECTION_FONT,        "FaceName",        epitString,  &g_szFaceName,        sizeof(g_szFaceName) },
    { SECTION_FONT,        "Height",          epitInt,     &g_iFontHeight,       sizeof(g_iFontHeight) },
    { SECTION_FONT,        "Unit",            epitInt,     &g_fontUnit,          sizeof(g_fontUnit) },
    { SECTION_FONT,        "Typographic",     epitBool,    &g_typographic,       sizeof(g_typographic) },
    { SECTION_FONT,        "Bold",            epitBool,    &g_Bold,              sizeof(g_Bold) },
    { SECTION_FONT,        "Italic",          epitBool,    &g_Italic,            sizeof(g_Italic) },
    { SECTION_FONT,        "Underline",       epitBool,    &g_Underline,         sizeof(g_Underline) },
    { SECTION_FONT,        "Strikeout",       epitBool,    &g_Strikeout,         sizeof(g_Strikeout) },
    { SECTION_RENDER,      "TextMode",        epitInt,     &g_TextMode,          sizeof(g_TextMode) },
    { SECTION_RENDER,      "Align",           epitAlign,   &g_align,             sizeof(g_align) },
    { SECTION_RENDER,      "LineAlign",       epitAlign,   &g_lineAlign,         sizeof(g_lineAlign) },
    { SECTION_RENDER,      "HotKey",          epitInt,     &g_hotkey,            sizeof(g_hotkey) },
    { SECTION_RENDER,      "LineTrim",        epitInt,     &g_lineTrim,          sizeof(g_lineTrim) },
    { SECTION_RENDER,      "NoFitBB",         epitBool,    &g_NoFitBB,           sizeof(g_NoFitBB) },
    { SECTION_RENDER,      "NoWrap",          epitBool,    &g_NoWrap,            sizeof(g_NoWrap) },
    { SECTION_RENDER,      "NoClip",          epitBool,    &g_NoClip,            sizeof(g_NoClip) },
    { SECTION_RENDER,      "Offscreen",       epitBool,    &g_Offscreen,         sizeof(g_Offscreen) },
    { SECTION_RENDER,      "TextColor",       epitColor,   &g_TextColor,         sizeof(g_TextColor) },
    { SECTION_RENDER,      "BackColor",       epitColor,   &g_BackColor,         sizeof(g_BackColor) },
    { SECTION_AUTOFONTS,   "NumFonts",        epitInt,     &g_iAutoFonts,        sizeof(g_iAutoFonts) },
    { SECTION_AUTOHEIGHTS, "NumHeights",      epitInt,     &g_iAutoHeights,      sizeof(g_iAutoHeights) },
    { SECTION_DRIVERSTRING,"CMapLookup",      epitBool,    &g_CMapLookup,        sizeof(g_CMapLookup) },
    { SECTION_DRIVERSTRING,"Vertical",        epitBool,    &g_Vertical,          sizeof(g_Vertical) },
    { SECTION_DRIVERSTRING,"RealizedAdvance", epitBool,    &g_RealizedAdvance,   sizeof(g_RealizedAdvance) },
    { SECTION_DRIVERSTRING,"CompensateRes",   epitBool,    &g_CompensateRes,     sizeof(g_CompensateRes) },

    { "INVALID"           "INVALID",       epitInvalid, NULL,                 0 }
};

////////////////////////////////////////////////////////////////////////////////////////
// Routine to read the specified profile file (full-path required) and set the variables
// defined in the above table based on the results.
////////////////////////////////////////////////////////////////////////////////////////

void ReadProfileInfo(char *szProfileFile)
{
    int iProfile =0;
    int iRead = 0;
    char szValue[PROFILEVALUEMAX];

    if (!szProfileFile)
        return;

    // Loop through the table of profile information...
    while(g_rgProfileInfo[iProfile].pvVariable != NULL)
    {
        void *pvValue = g_rgProfileInfo[iProfile].pvVariable;
        DWORD dwValueLength = g_rgProfileInfo[iProfile].dwVariableLength;

        // Read the profile string
        iRead = ::GetPrivateProfileStringA(
            g_rgProfileInfo[iProfile].szSection,
            g_rgProfileInfo[iProfile].szVariable,
            NULL,
            szValue,
            sizeof(szValue),
            szProfileFile);

        if (iRead > 0)
        {
            // Convert the string value to the proper variable type based on
            // the specified type in the table of profile information...
            switch(g_rgProfileInfo[iProfile].type)
            {
                case epitInvalid :
                {
                    ASSERT(0);
                }
                break;

                case epitBool :
                {
                    ASSERT(dwValueLength == sizeof(BOOL));

                    // Only look at the first character for boolean values...
                    if (szValue[0] == 'Y' || szValue[0] == 'y' || szValue[0] == 'T' || szValue[0] == 't' || szValue[0] == '1')
                    {
                        *((BOOL *)pvValue) = true;
                    }
                    else
                    {
                        *((BOOL *)pvValue) = false;
                    }
                }
                break;

                case epitInt :
                {
                    ASSERT(dwValueLength == sizeof(int));

                    // Just use atoi here - strips whitespace and supports negative numbers...
                    int iValue = atoi(szValue);

                    *((int *)pvValue) = iValue;
                }
                break;

                case epitFloat :
                {
                    ASSERT(dwValueLength == sizeof(float));

                    // Just use atof here - strips whitespace...
                    float fltValue = (float)atof(szValue);

                    *((float *)pvValue) = fltValue;
                }
                break;

                case epitDouble :
                {
                    ASSERT(dwValueLength == sizeof(double));

                    // Just use atof here - strips whitespace...
                    double dblValue = atof(szValue);

                    *((double *)pvValue) = dblValue;
                }
                break;

                case epitString :
                {
                    // Just use strncpy. NOTE : Truncates if necessary and does NOT support full UNICODE
                    strncpy((char *)pvValue, szValue, dwValueLength);
                }
                break;

                case epitColor :
                {
                    // We will only handle HEX color values here:
                    int i;
                    ARGB color = 0;

                    for(i=0;i<8;i++)
                    {
                        if (szValue[i] == 0)
							break;
						
						// move along...
                        color <<= 4;

                        if (szValue[i] >= '0' && szValue[i] <= '9')
                        {
                            color += szValue[i] - '0';
                        }
                        else if (szValue[i] >='a' && szValue[i] <= 'f')
                        {
                            color += (szValue[i] - 'a') + 10;
                        }
                        else if (szValue[i] >='A' && szValue[i] <= 'F')
                        {
                            color += (szValue[i] - 'A') + 10;
                        }
                    }

                    *((ARGB *)pvValue) = color;
                }
                break;

                case epitAlign :
                {
                    ASSERT(dwValueLength == sizeof(StringAlignment));

                    switch(szValue[0])
                    {
                        case 'n' :
                        case 'N' :
                        {
                            // Near Alignment (left or top for US English)
                            *((StringAlignment *)pvValue) = StringAlignmentNear;
                        }
                        break;

                        case 'c' :
                        case 'C' :
                        {
                            // Center Alignment
                            *((StringAlignment *)pvValue) = StringAlignmentCenter;
                        }
                        break;

                        case 'F' :
                        case 'f' :
                        {
                            // Far Alignment (right or bottom for US English)
                            *((StringAlignment *)pvValue) = StringAlignmentFar;
                        }
                        break;
                    }
                }
                break;
            }
        }

        iProfile++;
    }

    // Get the enumerated fonts list (if any)
    if (g_AutoFont)
    {
        int iFont = 0;

        if (g_iAutoFonts > MAX_AUTO_FONTS)
            g_iAutoFonts = MAX_AUTO_FONTS;

        for(iFont=0;iFont<g_iAutoFonts;iFont++)
        {
            char szFontIndex[MAX_PATH];
            char szValue[MAX_PATH];

            wsprintfA(szFontIndex, "Font%d", iFont+1);

            // Read the profile string
            ::GetPrivateProfileStringA(
                SECTION_AUTOFONTS,
                szFontIndex,
                NULL,
                szValue,
                sizeof(g_rgszAutoFontFacenames[iFont]),
                szProfileFile);

#ifdef UNICODE
                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         szValue,
                                         -1,
                                         g_rgszAutoFontFacenames[iFont],
                                         lstrlenA(szValue) );
#else
                        strcpy(g_rgszAutoFontFacenames[iFont], szValue);
#endif

        }
    }

    // Get the enumerated font heights (if any)
    if (g_AutoHeight)
    {
        int iHeight = 0;

        if (g_iAutoHeights > MAX_AUTO_HEIGHTS)
            g_iAutoHeights = MAX_AUTO_HEIGHTS;

        for(iHeight=0;iHeight<g_iAutoHeights;iHeight++)
        {
            char szHeightIndex[MAX_PATH];
            char szValue[MAX_PATH];

            wsprintfA(szHeightIndex, "Height%d", iHeight+1);

            // Read the profile string
            ::GetPrivateProfileStringA(
                SECTION_AUTOHEIGHTS,
                szHeightIndex,
                NULL,
                szValue,
                sizeof(szValue),
                szProfileFile);

            g_rgiAutoHeights[iHeight] = atoi(szValue);
        }
    }

    // Combine various booleans into proper bit-flags
    g_DriverOptions =
        (g_CMapLookup      ? DriverStringOptionsCmapLookup           : 0) |
        (g_Vertical        ? DriverStringOptionsVertical             : 0) |
        (g_RealizedAdvance ? DriverStringOptionsRealizedAdvance      : 0)
    ;

    g_formatFlags =
        (g_NoFitBB         ? StringFormatFlagsNoFitBlackBox     : 0) |
        (g_NoWrap          ? StringFormatFlagsNoWrap            : 0) |
        (g_NoClip          ? StringFormatFlagsNoClip            : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\global.h ===
////    GLOBAL.H - Global variables for CSSAMP
//
//





////    Constants
//
//


#define APPNAMEA   "TextTest"
#define APPTITLEA  "TextTest - GdipPlus Text support (Text+) Tests"
#define APPNAMEW   L"TextTest"
#define APPTITLEW  L"TextTest - GdipPlus Text support (Text+) Tests"

const int MAX_STYLES = 5;      // Better implementation would use dynamic memory
const int MAX_TEXT   = 10000;  // Fixed buffer size in Unicode characters
const int MAX_AUTO_FONTS = 20; // Maximum number of fonts to sequence through
const int MAX_AUTO_HEIGHTS = 20; // Maximum number of heights to sequence through
const int MAX_RANGE_COUNT = 10; // Maximum number of ranges

const int CARET_SECTION_LOGICAL    = 0;
const int CARET_SECTION_PLAINTEXT  = 1;
const int CARET_SECTION_FORMATTED  = 2;


////    RUN - A run of characters with similar attributes
//
//


struct RUN {
    struct RUN       *pNext;
    int               iLen;
    int               iStyle;       // Index to style sheet (global 'g_style').
    SCRIPT_ANALYSIS   analysis;     // Uniscribe analysis
};






////    STYLE - Text attribute
//


struct STYLE {
    WCHAR  faceName[LF_FACESIZE];
    REAL   emSize;
    INT    style;
    //HFONT         hf;       // Handle to font described by lf
    //SCRIPT_CACHE  sc;       // Uniscribe cache associated with this style
};






////    Global variables
//
//


#ifdef GLOBALS_HERE
#define GLOBAL
#define GLOBALINIT(a) = a
#else
#define GLOBAL extern
#define GLOBALINIT(a)
#endif

// Read these from the settings file (command line) - auto-drive for profiling
GLOBAL  char            g_szProfileName[MAX_PATH];              // Profile File name
GLOBAL  BOOL            g_AutoDrive          GLOBALINIT(FALSE); // Automatically run suite and exit
GLOBAL  int             g_iNumIterations     GLOBALINIT(1);     // Number of test iterations to execute
GLOBAL  int             g_iNumRepaints       GLOBALINIT(1);     // Number of re-paints to execute
GLOBAL  int             g_iNumRenders        GLOBALINIT(1);     // Number of API Render calls to execute
GLOBAL  char            g_szSourceTextFile[MAX_PATH];           // Source Text Filename
GLOBAL  BOOL            g_Offscreen          GLOBALINIT(FALSE); // Use offscreen surface
GLOBAL  ARGB            g_TextColor          GLOBALINIT(0xFF000000); // Text color
GLOBAL  ARGB            g_BackColor          GLOBALINIT(0xFFFFFFFF); // Background color

// Automatic cycling data for font height/face
GLOBAL  BOOL            g_AutoFont           GLOBALINIT(FALSE); // Sequence through fonts
GLOBAL  BOOL            g_AutoHeight         GLOBALINIT(FALSE); // Sequence through all font heights
GLOBAL  int             g_iAutoFonts         GLOBALINIT(0);     // Number of fonts to sequence through
GLOBAL  int             g_iAutoHeights       GLOBALINIT(0);     // Number of heights to sequence through
GLOBAL  TCHAR           g_rgszAutoFontFacenames[MAX_AUTO_FONTS][MAX_PATH]; // Array of auto-font facenames
GLOBAL  int             g_rgiAutoHeights[MAX_AUTO_HEIGHTS];     // Array of auto-height sizes

// These correspond to bits in g_DriverOptions (enumeration)
GLOBAL  BOOL            g_CMapLookup         GLOBALINIT(TRUE);
GLOBAL  BOOL            g_Vertical           GLOBALINIT(FALSE);
GLOBAL  BOOL            g_RealizedAdvance    GLOBALINIT(TRUE);
GLOBAL  BOOL            g_CompensateRes      GLOBALINIT(FALSE);

// These correspond to bits in g_formatFlags
GLOBAL  BOOL            g_NoFitBB            GLOBALINIT(FALSE);
GLOBAL  BOOL            g_NoWrap             GLOBALINIT(FALSE);
GLOBAL  BOOL            g_NoClip             GLOBALINIT(FALSE);

// Initial Font controls
GLOBAL  BOOL            g_FontOverride       GLOBALINIT(FALSE); // Over-ride default font settings
GLOBAL  TCHAR           g_szFaceName[MAX_PATH];                 // Font Face name
GLOBAL  int             g_iFontHeight        GLOBALINIT(8);     // Font Height
GLOBAL  BOOL            g_Bold               GLOBALINIT(FALSE); // Bold flag
GLOBAL  BOOL            g_Italic             GLOBALINIT(FALSE); // Italic flag
GLOBAL  BOOL            g_Underline          GLOBALINIT(FALSE); // Underline
GLOBAL  BOOL            g_Strikeout          GLOBALINIT(FALSE); // Strikeout

GLOBAL  HINSTANCE       g_hInstance          GLOBALINIT(NULL);  // The one and only instance
GLOBAL  char            g_szAppDir[MAX_PATH];                   // Application directory
GLOBAL  HWND            g_hSettingsDlg       GLOBALINIT(NULL);  // Settings panel
GLOBAL  HWND            g_hGlyphSettingsDlg  GLOBALINIT(NULL);  // Settings panel
GLOBAL  HWND            g_hDriverSettingsDlg GLOBALINIT(NULL);  // Settings panel
GLOBAL  HWND            g_hTextWnd           GLOBALINIT(NULL);  // Text display/editing panel
GLOBAL  BOOL            g_bUnicodeWnd        GLOBALINIT(FALSE); // If text window is Unicode
GLOBAL  int             g_iSettingsWidth;
GLOBAL  int             g_iSettingsHeight;
GLOBAL  BOOL            g_fShowLevels        GLOBALINIT(FALSE); // Show bidi levels for each codepoint
GLOBAL  int             g_iMinWidth;                            // Main window minimum size
GLOBAL  int             g_iMinHeight;
GLOBAL  BOOL            g_fPresentation      GLOBALINIT(FALSE); // Hide settings, show text very large
GLOBAL  BOOL            g_ShowLogical        GLOBALINIT(FALSE);
GLOBAL  BOOL            g_ShowGDI            GLOBALINIT(FALSE); // Render text using GDI
GLOBAL  BOOL            g_UseDrawText        GLOBALINIT(TRUE); // Render using DrawText

GLOBAL  BOOL            g_fOverrideDx        GLOBALINIT(FALSE); // Provide UI for changing logical widths

GLOBAL  SCRIPT_CONTROL  g_ScriptControl      GLOBALINIT({0});
GLOBAL  SCRIPT_STATE    g_ScriptState        GLOBALINIT({0});
GLOBAL  BOOL            g_fNullState         GLOBALINIT(FALSE);

GLOBAL  DWORD           g_dwSSAflags         GLOBALINIT(SSA_FALLBACK);

GLOBAL  STYLE           g_style[MAX_STYLES];                    // 0 for plaintext, 1-4 for formatted text

GLOBAL  WCHAR           g_wcBuf[MAX_TEXT];
GLOBAL  int             g_iWidthBuf[MAX_TEXT];

GLOBAL  RUN            *g_pFirstFormatRun    GLOBALINIT(NULL);   // Formatting info

GLOBAL  int             g_iTextLen           GLOBALINIT(0);

GLOBAL  int             g_iCaretX            GLOBALINIT(0);      // Caret position in text window
GLOBAL  int             g_iCaretY            GLOBALINIT(0);      // Caret position in text window
GLOBAL  int             g_iCaretHeight       GLOBALINIT(0);      // Caret height in pixels
GLOBAL  int             g_fUpdateCaret       GLOBALINIT(TRUE);   // Caret requires updating

GLOBAL  int             g_iCaretSection      GLOBALINIT(CARET_SECTION_LOGICAL);  // Whether caret is in logical, plain or formatted text
GLOBAL  int             g_iCurChar           GLOBALINIT(0);      // Caret sits on leading edge of buffer[iCurChar]

GLOBAL  int             g_iMouseDownX        GLOBALINIT(0);
GLOBAL  int             g_iMouseDownY        GLOBALINIT(0);
GLOBAL  BOOL            g_fMouseDown         GLOBALINIT(FALSE);
GLOBAL  int             g_iMouseUpX          GLOBALINIT(0);
GLOBAL  int             g_iMouseUpY          GLOBALINIT(0);
GLOBAL  BOOL            g_fMouseUp           GLOBALINIT(FALSE);

GLOBAL  int             g_iFrom              GLOBALINIT(0);      // Highlight start
GLOBAL  int             g_iTo                GLOBALINIT(0);      // Highlight end


GLOBAL  HFONT           g_hfCaption          GLOBALINIT(NULL);   // Caption font
GLOBAL  int             g_iLogPixelsY        GLOBALINIT(0);

GLOBAL  Matrix          g_WorldTransform;
GLOBAL  Matrix          g_FontTransform;
GLOBAL  Matrix          g_DriverTransform;

GLOBAL  SmoothingMode   g_SmoothingMode         GLOBALINIT(SmoothingModeDefault);

// Font families



    // Enumerate available families

GLOBAL  InstalledFontCollection     g_InstalledFontCollection;
GLOBAL  FontFamily     *g_families;
GLOBAL  INT             g_familyCount;


GLOBAL  BOOL            g_ShowFamilies       GLOBALINIT(FALSE);


// Glyphs

GLOBAL  BOOL            g_ShowGlyphs         GLOBALINIT(FALSE);
GLOBAL  int             g_GlyphRows          GLOBALINIT(16);
GLOBAL  int             g_GlyphColumns       GLOBALINIT(16);
GLOBAL  int             g_GlyphFirst         GLOBALINIT(0);
GLOBAL  BOOL            g_CmapLookup         GLOBALINIT(FALSE);
GLOBAL  BOOL            g_HorizontalChart    GLOBALINIT(FALSE);
GLOBAL  BOOL            g_ShowCell           GLOBALINIT(FALSE);
GLOBAL  BOOL            g_VerticalForms      GLOBALINIT(FALSE);


// Driver string

GLOBAL  BOOL            g_ShowDriver         GLOBALINIT(FALSE);
GLOBAL  INT             g_DriverOptions      GLOBALINIT(  DriverStringOptionsCmapLookup
                                                        | DriverStringOptionsRealizedAdvance);
GLOBAL  REAL            g_DriverDx           GLOBALINIT(15.0);
GLOBAL  REAL            g_DriverDy           GLOBALINIT(0.0);
GLOBAL  REAL            g_DriverPixels       GLOBALINIT(13.0);


// DrawString

GLOBAL  BOOL            g_ShowDrawString     GLOBALINIT(FALSE);
GLOBAL  TextRenderingHint g_TextMode         GLOBALINIT(TextRenderingHintSystemDefault);
GLOBAL  UINT            g_GammaValue         GLOBALINIT(4);
GLOBAL  INT             g_formatFlags        GLOBALINIT(0);
GLOBAL  BOOL            g_typographic        GLOBALINIT(FALSE);
GLOBAL  StringAlignment g_align              GLOBALINIT(StringAlignmentNear);
GLOBAL  HotkeyPrefix    g_hotkey             GLOBALINIT(HotkeyPrefixNone);
GLOBAL  StringAlignment g_lineAlign          GLOBALINIT(StringAlignmentNear);
GLOBAL  StringTrimming  g_lineTrim           GLOBALINIT(StringTrimmingNone);
GLOBAL  Unit            g_fontUnit           GLOBALINIT(UnitPoint);
GLOBAL  Brush *         g_textBrush          GLOBALINIT(NULL);
GLOBAL  Brush *         g_textBackBrush      GLOBALINIT(NULL);
GLOBAL  BOOL            g_testMetafile       GLOBALINIT(FALSE);


// Path

GLOBAL  BOOL            g_ShowPath           GLOBALINIT(FALSE);

// Metrics

GLOBAL BOOL             g_ShowMetric         GLOBALINIT(FALSE);

// Performance

GLOBAL BOOL             g_ShowPerformance    GLOBALINIT(FALSE);
GLOBAL INT              g_PerfRepeat         GLOBALINIT(2000);

// Scaling

GLOBAL BOOL             g_ShowScaling        GLOBALINIT(FALSE);

// String format digit substitution
GLOBAL StringDigitSubstitute   g_DigitSubstituteMode   GLOBALINIT(StringDigitSubstituteUser);
GLOBAL LANGID                  g_Language              GLOBALINIT(LANG_NEUTRAL);

GLOBAL INT              g_RangeCount         GLOBALINIT(0);
GLOBAL CharacterRange   g_Ranges[MAX_RANGE_COUNT];

/* obsolete

GLOBAL  BOOL            g_fFillLines         GLOBALINIT(TRUE);
GLOBAL  BOOL            g_fLogicalOrder      GLOBALINIT(FALSE);
GLOBAL  BOOL            g_fNoGlyphIndex      GLOBALINIT(FALSE);

GLOBAL  BOOL            g_fShowWidths        GLOBALINIT(FALSE);
GLOBAL  BOOL            g_fShowStyles        GLOBALINIT(FALSE);

GLOBAL  BOOL            g_fShowPlainText     GLOBALINIT(TRUE);
GLOBAL  BOOL            g_fShowFancyText     GLOBALINIT(FALSE);

*/

////    Function prototypes
//
//

// DspGDI.cpp
void PaintGDI(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspFamly.cpp

void PaintFamilies(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);

void InitializeLegacyFamilies();


// DspLogcl.cpp

void PaintLogical(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspDraws.cpp

void PaintDrawString(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspDriver.cpp

void PaintDrawDriverString(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspPerf.cpp

void PaintPerformance(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspPath.cpp

void PaintPath(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight);


// DspGlyph.cpp

void PaintGlyphs(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspMetric.cpp

void PaintMetrics(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspScaling.cpp

void PaintScaling(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// Settings.cpp
INT_PTR CALLBACK SettingsDlgProc(
        HWND    hDlg,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam);

INT_PTR CALLBACK GlyphSettingsDlgProc(
        HWND    hDlg,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam);

INT_PTR CALLBACK DriverSettingsDlgProc(
        HWND    hDlg,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam);

void InsertText(HWND hDlg, char *textId);

// ReadSettings.cpp
void ReadProfileInfo(char *szProfileName);

// Text.cpp

void InitText(INT id);

BOOL TextInsert(
    int   iPos,
    PWCH  pwc,
    int   iLen);

BOOL TextDelete(
    int iPos,
    int iLen);



// TextWnd.cpp

HWND CreateTextWindow();

void ResetCaret(int iX, int iY, int iHeight);

LRESULT CALLBACK TextWndProc(
        HWND    hWnd,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam);

void InvalidateText();

void PrintPage();

// Edit.cpp

BOOL EditChar(WCHAR wc);
BOOL EditKeyDown(WCHAR wc);
void EditFreeCaches();
void EditInsertUnicode();


// Style.cpp

void SetStyle(
    int     iStyle,
    int     iHeight,
    int     iWeight,
    int     iItalic,
    int     iUnderline,
    int     iStrikeout,
    TCHAR   *pcFaceName);

void InitStyles();

void FreeStyles();

void SetLogFont(
    PLOGFONTA   plf,
    int         iHeight,
    int         iWeight,
    int         iItalic,
    int         iUnderline,
    char       *pcFaceName);

void StyleDeleteRange(
    int     iDelPos,
    int     iDelLen);

void StyleExtendRange(
    int     iExtPos,
    int     iExtLen);

void StyleSetRange(
    int    iSetStyle,
    int    iSetPos,
    int    iSetLen);

BOOL StyleCheckRange();



// Debugging support


#define TRACEMSG(a)   {DG.psFile=__FILE__; DG.iLine=__LINE__; DebugMsg a;}
#define ASSERT(a)     {if (!(a)) TRACEMSG(("Assertion failure: "#a));}
#define ASSERTS(a,b)  {if (!(a)) TRACEMSG(("Assertion failure: "#a" - "#b));}
#define ASSERTHR(a,b) {if (!SUCCEEDED(a)) {DG.psFile=__FILE__; \
                       DG.iLine=__LINE__; DG.hrLastError=a; DebugHr b;}}



///     Debug variables
//


struct DebugGlobals {
    char   *psFile;
    int     iLine;
    HRESULT hrLastError;        // Last hresult from GDI
    CHAR    sLastError[100];    // Last error string
};




///     Debug function prototypes
//


extern "C" void WINAPIV DebugMsg(char *fmt, ...);
extern "C" void WINAPIV DebugHr(char *fmt, ...);

GLOBAL DebugGlobals DG   GLOBALINIT({0});
GLOBAL UINT debug        GLOBALINIT(0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TextTest.rc
//
#define IDD_FORMATTEDTEXT               105
#define IDD_ITEMIZATION                 106
#define ID_INITIAL_TEXT                 110
#define IDD_OBSOLETE                    112
#define ID_MULTILINGUAL_TEXT            120
#define ID_METRICS_TEXT                 130
#define IDC_HORIZ                       1000
#define IDC_VERT                        1001
#define IDC_TRIMMING                    1001
#define IDC_LTR                         1002
#define IDC_RTL                         1003
#define IDC_NEAR                        1004
#define IDC_CENTER                      1005
#define IDC_JUSTIFY                     1006
#define IDC_FAR                         1007
#define IDC_CONTROL_CHARS               1008
#define IDC_NO_GLYPH_INDEX              1009
#define IDC_HIGHLIGHT_FROM              1010
#define IDC_HIGHLIGHT_TO                1011
#define IDC_CODEPOINT                   1012
#define IDC_INSERT_CODEPOINT            1013
#define IDC_LOGICAL_ORDER               1014
#define IDC_LOGICAL                     1018
#define IDC_LOGICAL_WIDTH               1019
#define IDC_GLYPHCELLMETRICS            1019
#define IDC_GLYPHCMAPLOOKUP             1019
#define IDC_LOGICAL_STYLES              1020
#define IDC_GLYPHDESIGNADVANCE          1020
#define IDC_GLYPHVERTICALFORMS          1020
#define IDC_PLAINTEXT                   1021
#define IDC_GLYPHHINTEDADVANCE          1021
#define IDC_GLYPHHORIZONTALCHART        1021
#define IDC_SHOWGLYPHS                  1022
#define IDC_SHOWDRAWSTRING              1023
#define IDC_PLAINTEXT_FONT              1024
#define IDC_PLAINTEXT_SIZE              1025
#define IDC_PLAINTEXT_BOLD              1026
#define IDC_PLAINTEXT_ITALIC            1027
#define IDC_PLAINTEXT_UNDERLINE         1028
#define IDC_PLAINTEXT_CLIP              1029
#define IDC_SHOWFAMILIES                1029
#define IDC_PLAINTEXT_FIT               1030
#define IDC_GLYPHROWS                   1030
#define IDC_PLAINTEXT_STRIKEOUT         1030
#define IDC_PLAINTEXT_DX                1031
#define IDC_GLYPHCOLUMNS                1031
#define IDC_PLAINTEXT_TAB               1032
#define IDC_GLYPHINDEX                  1032
#define IDC_DRIVERORIGINALPIXELS        1032
#define IDC_PLAINTEXT_FALLBACK          1033
#define IDC_SHOWPATH                    1033
#define IDC_PLAINTEXT_LINK              1034
#define IDC_SHOWMETRIC                  1034
#define IDC_PLAINTEXT_HOTKEY            1035
#define IDC_SHOWDRIVER                  1035
#define IDC_PLAINTEXT_PASSWORD          1036
#define IDC_FORMATTED                   1037
#define IDC_FORMAT1                     1038
#define IDC_CONTROL_CONTEXT             1039
#define IDC_LANGUAGE                    1040
#define IDC_LEGACY_BIDI                 1041
#define IDC_OVERRIDE                    1042
#define IDC_DIGIT_SUBSTITUTE            1043
#define IDC_LINEFILL                    1044
#define IDC_ARANUMCONTEXT               1045
#define IDC_APPLYDIGITSUBST             1046
#define IDC_PRESENTATION                1047
#define IDC_SHOWLEVELS                  1048
#define IDC_WORLDTRANSFORM              1052
#define IDC_GLYPHHORIZONTAL             1053
#define IDC_GLYPHVERTICAL               1054
#define IDC_FONTTRANSFORM               1054
#define IDC_GDIGLYPHOUTPUT              1055
#define IDC_UNISCRIBE                   1056
#define IDC_PRINT                       1057
#define IDC_ALIGN                       1058
#define IDC_RENDERER                    1059
#define IDC_NOLINELIMIT                 1059
#define IDC_FONTUNIT                    1060
#define IDC_ALIGNMENT                   1061
#define IDC_FANCY_FONT1                 1062
#define IDC_GLYPHSHOWCELL               1062
#define IDC_FANCY_SIZE1                 1063
#define IDC_FANCY_BOLD1                 1064
#define IDC_FANCY_ITALIC1               1065
#define IDC_RENDER                      1065
#define IDC_FANCY_UNDERLINE1            1066
#define IDC_GDI                         1066
#define IDC_FANCY_FONT2                 1067
#define IDC_FONTSIZE                    1067
#define IDC_FANCY_SIZE2                 1068
#define IDC_FANCY_BOLD2                 1069
#define IDC_FANCY_ITALIC2               1070
#define IDC_FANCY_UNDERLINE2            1071
#define IDC_FANCY_FONT3                 1072
#define IDC_HOTKEY                      1072
#define IDC_FANCY_SIZE3                 1073
#define IDC_LINEALIGN                   1073
#define IDC_FANCY_BOLD3                 1074
#define IDC_DIR                         1074
#define IDC_FANCY_ITALIC3               1075
#define IDC_DRIVERCMAP                  1075
#define IDC_WRAP                        1075
#define IDC_FANCY_UNDERLINE3            1076
#define IDC_DRIVERVERTICAL              1076
#define IDC_HINTED                      1076
#define IDC_NOMINAL                     1076
#define IDC_FANCY_FONT4                 1077
#define IDC_DRIVERREALIZEDADVANCE       1077
#define IDC_METAFILE                    1077
#define IDC_FANCY_SIZE4                 1078
#define IDC_CHECK4                      1078
#define IDC_LIMITSUBPIXEL               1078
#define IDC_CLIP                        1078
#define IDC_FANCY_BOLD4                 1079
#define IDC_DRIVERDX                    1079
#define IDC_FANCY_ITALIC4               1080
#define IDC_DRIVERDY                    1080
#define IDC_FANCY_UNDERLINE4            1081
#define IDC_DRIVERTRANSFORM             1081
#define IDC_FORMAT2                     1087
#define IDC_FORMAT3                     1090
#define IDC_FORMAT4                     1091
#define IDC_TEXTMODE                    1092
#define IDC_GAMMAVALUE                  1093
#define IDC_BRUSHTYPE                   1094
#define IDC_BACKBRUSHTYPE               1094
#define IDC_FOREBRUSHTYPE               1096
#define IDC_CHECK1                      1097
#define IDC_PERFORMANCE                 1097
#define IDC_SHOWSCALING                 1098
#define IDC_ALIGNNEAR                   1099
#define IDC_ALIGNCENTER                 1100
#define IDC_ALIGNFAR                    1101
#define IDC_LINEALIGNNEAR               1102
#define IDC_LINEALIGNCENTER             1103
#define IDC_LINEALIGNFAR                1104
#define IDC_HOTKEYNONE                  1105
#define IDC_HOTKEYSHOW                  1106
#define IDC_HOTKEYHIDE                  1107
#define IDC_NOFITBB                     1110
#define IDC_NUMCTXAR                    1111
#define IDC_NOKASHIDA                   1112
#define IDC_DISPLAYFMT                  1113
#define IDC_NOKERNING                   1114
#define IDC_LEGACYBIDI                  1115
#define IDC_NOCHANGES                   1116
#define IDC_NOFALLBACK                  1117
#define IDC_MEASPACE                    1118
#define IDC_NOWRAP                      1119
#define IDC_LINELIMIT                   1120
#define IDC_NOCLIP                      1121
#define IDC_NOGDI                       1122
#define IDC_FULLIMAGER                  1123
#define IDC_TRIMMINGCHAR                1124
#define IDC_TRIMMINGWORD                1125
#define IDC_TRIMMINGELPSCH              1126
#define IDC_TRIMMINGELPSWD              1127
#define IDC_TRIMMINGELPSURL             1128
#define IDC_DEFAULTFORMAT               1129
#define IDC_TRIMMINGNONE                1130
#define IDC_NOLIGATURE                  1131
#define IDC_TYPOGRAPHICFORMAT           1132
#define IDC_CLR_FOR                     1133
#define IDC_BUTTON2                     1134
#define IDC_CLR_BAC                     1134
#define IDC_SHOWGDI                     1135
#define IDM_EXIT                        40001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1135
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\settings.cpp ===
////    SETTINGS.CPP - Handles settings dialog
//
//


#include "precomp.hxx"
#include "global.h"
#include <stdio.h>
#include <tchar.h>



////    HexToInt - convert hex digit string to int value
//
//      Ignores 'x' in the string so accepts input like '0x0100'.


int HexToInt(char szHex[]) {

    int i;
    int h;
    //int d;

    i = 0;
    h = 0;
    //d = 0;

    while (szHex[i]  &&  szHex[i] != ' ') {

        if (szHex[i] >= '0'  &&  szHex[i] <= '9') {

            h = h*16 + szHex[i] - '0';
            //d = d*10 + szHex[i] - '0';

        } else if (szHex[i] >= 'a'  &&  szHex[i] <= 'f') {

            h = h*16 + 10 + szHex[i] - 'a';

        } else if (szHex[i] >= 'A'  &&  szHex[i] <= 'F') {

            h = h*16 + 10 + szHex[i] - 'A';

        } else if (szHex[i] != ' '  &&  szHex[i] != ','  &&  szHex[i] != 'x'  &&  szHex[i] != 'X') {

            return -1;
        }

        i++;
    }


    return h;
}

VOID GetTextForeGroundBrush(INT_PTR iBrushType)
{

    if (g_textBrush)
    {
        delete g_textBrush;
        g_textBrush = NULL;
    }

    switch(iBrushType)
    {
    case 0: // Solid color
        {
            Color      blackColor(g_TextColor);
            SolidBrush * blackBrush = new SolidBrush(blackColor);
            g_textBrush = (Brush *) blackBrush;
        }

        break;

    #ifndef USE_NEW_APIS3
    // rectangle, triangle and radiant gradient brushes are not available in v1.
        case 1: // RectGradient
            {
                RectF brushRect(0, 0, 32, 32);

                Color colors[5] = {
                        Color(255, 255, 255, 255),
                        Color(255, 255, 0, 0),
                        Color(255, 0, 255, 0),
                        Color(255, 0, 0, 255),
                        Color(255, 0, 0, 0)
                };

                RectangleGradientBrush * rectGrad = new RectangleGradientBrush(brushRect, (Color*) &colors, WrapModeTile);

                g_textBrush = (Brush *) rectGrad;

            }
            break;


        case 2: // RadialGradient
            {
                RectF brushRect;

                Color centerColor(255, 255, 255, 255);
                Color boundaryColor(255, 0, 0, 0);
                brushRect.X = 0;
                brushRect.Y = 0;
                brushRect.Width = 60;
                brushRect.Height = 32;
                PointF center;
                center.X = brushRect.X + brushRect.Width/2;
                center.Y = brushRect.Y + brushRect.Height/2;
                RadialGradientBrush * radGrad = new RadialGradientBrush(brushRect, centerColor,
                                        boundaryColor, WrapModeTile);

                g_textBrush = (Brush *) radGrad;
            }
            break;
        case 3: // TriangleGradient
            {
                PointF points[7];
                points[0].X = 50;
                points[0].Y = 10;
                points[1].X = 200;
                points[1].Y = 20;
                points[2].X = 100;
                points[2].Y = 100;
                points[3].X = 30;
                points[3].Y = 120;

                Color colors[5] = {
                    Color(255, 255, 255, 0),
                    Color(255, 255, 0, 0),
                    Color(255, 0, 255, 0),
                    Color(255, 0, 0, 255),
                    Color(255, 0, 0, 0)
                };

                TriangleGradientBrush * triGrad = new TriangleGradientBrush(points, (Color*) &colors, WrapModeTileFlipXY);

                g_textBrush = (Brush *) triGrad;
            }
            break;
#endif

    case 4: // LineGradient
        {
            RectF lineRect(120, -20, 200, 60);
            Color color1(200, 255, 255, 0);
            Color color2(200, 0, 0, 255);

            LinearGradientBrush *lineGrad = new LinearGradientBrush(
                lineRect,
                color1,
                color2,
                LinearGradientModeForwardDiagonal
            );
            g_textBrush = (Brush *) lineGrad;
        }
    break;
    default: // Solid Color
        {
            Color      blackColor(g_TextColor);
            SolidBrush * blackBrush = new SolidBrush(blackColor);
            g_textBrush = (Brush *) blackBrush;
        }
    break;
    }
}

VOID GetTextRenderingMode(INT_PTR iTextMode)
{
    switch (iTextMode) {
    case 0: g_TextMode = TextRenderingHintSystemDefault;            break;
    case 1: g_TextMode = TextRenderingHintSingleBitPerPixelGridFit; break;
    case 2: g_TextMode = TextRenderingHintSingleBitPerPixel;        break;
    case 3: g_TextMode = TextRenderingHintAntiAliasGridFit;         break;
    case 4: g_TextMode = TextRenderingHintAntiAlias;                break;
    case 5: g_TextMode = TextRenderingHintClearTypeGridFit;         break;

    default:g_TextMode = TextRenderingHintSystemDefault;            break;
    }
}

VOID GetTextBackGroundBrush(INT_PTR iBrushType)
{

    if (g_textBackBrush)
    {
        delete g_textBackBrush;
        g_textBackBrush = NULL;
    }

    switch(iBrushType)
    {
    case 0: // Solid color
        {
            Color      blackColor(g_BackColor);
            SolidBrush * blackBrush = new SolidBrush(blackColor);
            g_textBackBrush = (Brush *) blackBrush;
        }

        break;

    #ifndef USE_NEW_APIS3
    // rectangle, triangle and radiant gradient brushes are not available in v1.
    case 1: // RectGradient
        {
            RectF brushRect(0, 0, 32, 32);

            Color colors[5] = {
                    Color(255, 255, 255, 255),
                    Color(255, 255, 0, 0),
                    Color(255, 0, 255, 0),
                    Color(255, 0, 0, 255),
                    Color(255, 0, 0, 0)
            };

            RectangleGradientBrush * rectGrad = new RectangleGradientBrush(brushRect, (Color*) &colors, WrapModeTile);

            g_textBackBrush = (Brush *) rectGrad;

        }
        break;
    case 2: // RadialGradient
        {
            RectF brushRect;

            Color centerColor(255, 255, 255, 255);
            Color boundaryColor(255, 0, 0, 0);
            brushRect.X = 0;
            brushRect.Y = 0;
            brushRect.Width = 60;
            brushRect.Height = 32;
            PointF center;
            center.X = brushRect.X + brushRect.Width/2;
            center.Y = brushRect.Y + brushRect.Height/2;
            RadialGradientBrush * radGrad = new RadialGradientBrush(brushRect, centerColor,
                                    boundaryColor, WrapModeTile);

            g_textBackBrush = (Brush *) radGrad;
        }
        break;
    case 3: // TriangleGradient
        {
            PointF points[7];
            points[0].X = 50;
            points[0].Y = 10;
            points[1].X = 200;
            points[1].Y = 20;
            points[2].X = 100;
            points[2].Y = 100;
            points[3].X = 30;
            points[3].Y = 120;

            Color colors[5] = {
                Color(255, 255, 255, 0),
                Color(255, 255, 0, 0),
                Color(255, 0, 255, 0),
                Color(255, 0, 0, 255),
                Color(255, 0, 0, 0)
            };

            TriangleGradientBrush * triGrad = new TriangleGradientBrush(points, (Color*) &colors, WrapModeTileFlipXY);

            g_textBackBrush = (Brush *) triGrad;
        }
        break;
#endif
    case 4: // LineGradient
        {
            RectF lineRect(120, -20, 200, 60);
            Color color1(200, 255, 255, 0);
            Color color2(200, 0, 0, 255);

            LinearGradientBrush *lineGrad = new LinearGradientBrush(
                lineRect,
                color1,
                color2,
                LinearGradientModeForwardDiagonal
            );
            g_textBackBrush = (Brush *) lineGrad;
        }
    break;
    default: // Solid Color
        {
            Color      blackColor(g_BackColor);
            SolidBrush * blackBrush = new SolidBrush(blackColor);
            g_textBackBrush = (Brush *) blackBrush;
        }
    break;
    }
}

VOID GetDigitSubstituteMode (HWND hDlg, INT_PTR iDigitSubstituteType)
{
    g_DigitSubstituteMode = (StringDigitSubstitute)iDigitSubstituteType;

    if(g_DigitSubstituteMode == StringDigitSubstituteUser || g_DigitSubstituteMode == StringDigitSubstituteNone)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE) , FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE) , TRUE);
    }
}

BOOL ChangeFont(
    HWND hDlg,
    int iStyle,
    int idFont,
    int idSize,
    int idBold,
    int idItalic,
    int idUnderline,
    int idStrikeout,
    int iCmd,
    int iNotify
)
{
    int   iHeight;
    char sFaceSize[100];
    TCHAR sFaceName[100];
    WPARAM   i;


    // Get size

    if (    iCmd    == idSize
        &&  iNotify == CBN_SELCHANGE)
    {
        i = SendDlgItemMessage(hDlg, idSize, CB_GETCURSEL, 0, 0);
        if (SendDlgItemMessageA(hDlg, idSize, CB_GETLBTEXT, i, (LPARAM)sFaceSize) == CB_ERR) {
            return FALSE;
        }
    }
    else
    {
        if (SendDlgItemMessageA(hDlg, idSize, WM_GETTEXT, sizeof(sFaceSize), (LPARAM)sFaceSize) == CB_ERR)
        {
            return FALSE;
        }
    }

    int pos = atoi(sFaceSize);

    if (iCmd == IDC_PLAINTEXT_SIZE)
    {
        SendDlgItemMessage(hDlg, IDC_FONTSIZE, TBM_SETPOS,   TRUE, pos);
    }

    iHeight = pos;  //  Was for CSSAMP: MulDiv(pos, g_iLogPixelsY, 72);



    // Get facename

    i = SendDlgItemMessage(hDlg, idFont, CB_GETCURSEL, 0, 0);
    if (SendDlgItemMessage(hDlg, idFont, CB_GETLBTEXT, i, (LPARAM)sFaceName) == CB_ERR) {
        return FALSE;
    }


    SetStyle(
        iStyle,
        iHeight,
        IsDlgButtonChecked(hDlg, idBold)      == BST_CHECKED ? 700 : 400,
        IsDlgButtonChecked(hDlg, idItalic)    == BST_CHECKED,
        IsDlgButtonChecked(hDlg, idUnderline) == BST_CHECKED,
        IsDlgButtonChecked(hDlg, idStrikeout) == BST_CHECKED,
        sFaceName);



    InvalidateText();
    return TRUE;
}




// SplitTransform here temporarily for testing purposes



void SplitTransform(
    const Matrix    &matrix,
    PointF          &scale,
    REAL            &rotate,
    REAL            &shear,
    PointF          &translate)
{

    REAL m[6];
    matrix.GetElements(m);

    // m11 = m[0]    m12 = m[1]
    // m21 = m[2]    m22 = m[3]
    //  dx = m[4]     dy = m[5]


    // Extract translation

    translate = PointF(m[4],m[5]);


    //         2           2
    // Use  Sin theta + cos theta = 1 to obtain (absolute value) of
    // the X scale factor. Because we're returning the shear as an X
    // shear, it's a factor of y, so this formula is correct regardless of shear.


    REAL m11Sq = m[0]*m[0];
    REAL m12Sq = m[1]*m[1];

    scale.X = REAL(sqrt(m11Sq + m12Sq));

    // Always treat X scale factor as positive: handle originally negative
    // X scale factors as rotation by 180 degrees and invert Y scale factor.


    if (m[1] >= 0 && m[0] > 0)
    {
        rotate = REAL(atan(m[1]/m[0]));                     // 0-90
    }
    else if (m[0] < 0)
    {
        rotate = REAL(atan(m[1]/m[0]) + 3.14159265358979);  // 90-270
    }
    else if (m[1] < 0 && m[0] > 0)
    {
        rotate = REAL(atan(m[1]/m[0]) + 2*3.14159265358979);// 270-360
    }
    else
    {
        // m[0] == 0

        if (m[1] > 0)
        {
            rotate = REAL(3.14159265358979);                // 90
        }
        else
        {
            rotate = REAL(3*3.14159265358979/2);            // 270
        }
    }


    // y scale factor in terms of x scale factor

    scale.Y = scale.X * (m[0]*m[3] - m[1]*m[2]) / (m11Sq + m12Sq);


    // Shear

    shear = (m[1]*m[3] + m[0]*m[2]) / (m11Sq + m[1]);
}








class TransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        rect.X      = x;
        rect.Y      = y;
        rect.Width  = width;
        rect.Height = height;
        origin.X    = x + width/2;
        origin.Y    = y + height/2;
        fontCellHeight = cellHeight;
    }
    BOOL inControl(INT x, INT y, Point *point) {
        if (    x >= rect.X
            &&  y >= rect.Y
            &&  x < rect.X + rect.Width
            &&  y < rect.Y + rect.Height + fontCellHeight) {
            if (point)
            {
                // Set point to tenths of the controls 'radius'
                point->X = (x - origin.X) * 200 / rect.Width;
                point->Y = (y - origin.Y) * 200 / rect.Height;
            }
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    void paint(HDC hdc) {
        // Add vertical and horizontal lines

        HPEN hOldPen = (HPEN) SelectObject(hdc, CreatePen(PS_SOLID, 0, COLORREF(0x00C0C0C0)));

        MoveToEx(hdc, rect.X,            origin.Y, NULL);
        LineTo  (hdc, rect.X+rect.Width, origin.Y);

        MoveToEx(hdc, origin.X, rect.Y,            NULL);
        LineTo  (hdc, origin.X, rect.Y+rect.Height);

        DeleteObject(SelectObject(hdc, hOldPen));
    }
    Rect  rect;
    Point origin;
    INT   fontCellHeight;
    enum {
        SampleRectSize = 40
    };
};

class AngleTransformControl : TransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
        angle = 0;
    }
    void mouse(INT x, INT y) {
        Point vector;
        if (inControl(x, y, &vector)) {
            if (vector.Y > 100)
            {
                // Reset
                angle = 0;
            }
            else if (vector.X == 0)  // Convert mouse hit to angle
            {
                // Special case: straight up or straight down
                if (vector.Y < 0)
                {
                    angle = REAL(3.14159265358979*3/2);
                }
                else if (vector.Y == 0)
                {
                    angle = 0;
                }
                else
                {
                    angle = REAL(3.14159265358979/2);
                }
            }
            else
            {
                angle = REAL(atan(REAL(vector.Y)/REAL(vector.X)));
                if (vector.X < 0)
                {
                    angle += REAL(3.14159265358979);
                }
            }
        }
    }
    void paint(HDC hdc) {
        Ellipse(hdc, rect.X, rect.Y, rect.X+rect.Width, rect.Y+rect.Height);
        TransformControl::paint(hdc);
        MoveToEx(hdc, origin.X, origin.Y, NULL);
        Point vector;

        vector.X = INT(cos(angle)*80+0.4999);
        vector.Y = INT(sin(angle)*80+0.4999);
        LineTo(hdc, origin.X+vector.X*rect.Width/200, origin.Y+vector.Y*rect.Height/200);
        SetTextAlign(hdc, TA_CENTER);
        char strKey[50];
        INT strLen = sprintf(strKey, "Rotate %.1f", angle * 180 / 3.14159265358979);
        RECT textRect = {rect.X, rect.Y+rect.Height, rect.X+rect.Width, rect.Y+rect.Height+fontCellHeight};
        ExtTextOutA(hdc, origin.X, rect.Y+rect.Height, ETO_OPAQUE, &textRect, strKey, strLen, NULL);
    }
    REAL getAngle() {
        return REAL(angle * 180 / 3.14159265358979);
    }
    REAL angle;
};

class VectorTransformControl : public TransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
    }
    void paint(HDC hdc) {
        Rectangle(hdc, rect.X, rect.Y, rect.X+rect.Width, rect.Y+rect.Height);
        TransformControl::paint(hdc);
    }
    Point vector;
};

class ScaleTransformControl : public VectorTransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
        vector.X = SampleRectSize;
        vector.Y = SampleRectSize;
    }
    void mouse(INT x, INT y) {
        if (inControl(x, y, &vector)) {
            if (vector.Y > 100)
            {   // Reset
                vector.X = SampleRectSize;
                vector.Y = SampleRectSize;
            }
        }
    }
    void paint(HDC hdc) {
        VectorTransformControl::paint(hdc);
        MoveToEx(hdc, origin.X, origin.Y, NULL);
        LineTo(hdc, origin.X+vector.X*rect.Width/200, origin.Y);
        LineTo(hdc, origin.X+vector.X*rect.Width/200, origin.Y+vector.Y*rect.Height/200);
        LineTo(hdc, origin.X,                         origin.Y+vector.Y*rect.Height/200);
        LineTo(hdc, origin.X, origin.Y);
        SetTextAlign(hdc, TA_CENTER);
        char strKey[50];
        INT strLen = sprintf(strKey, "Scale %.1f,%.1f", REAL(vector.X)/REAL(SampleRectSize), REAL(vector.Y)/REAL(SampleRectSize));
        RECT textRect = {rect.X, rect.Y+rect.Height, rect.X+rect.Width, rect.Y+rect.Height+fontCellHeight};
        ExtTextOutA(hdc, origin.X, rect.Y+rect.Height, ETO_OPAQUE, &textRect, strKey, strLen, NULL);
    }
    REAL getScaleX() {
        REAL  ScaleX = REAL(vector.X)/REAL(SampleRectSize);
        // snap values close to 1.0 and -1.0 to make it easier to test mirror image
        if ((ScaleX > 0.9) && (ScaleX < 1.1))
            ScaleX = 1.0;
        if ((ScaleX < -0.9) && (ScaleX > -1.1))
            ScaleX = -1.0;
        return ScaleX;
    }
    REAL getScaleY() {
        REAL  ScaleY = REAL(vector.Y)/REAL(SampleRectSize);
        // snap values close to 1.0 and -1.0 to make it easier to test mirror image
        if ((ScaleY > 0.9) && (ScaleY < 1.1))
            ScaleY = 1.0;
        if ((ScaleY < -0.9) && (ScaleY > -1.1))
            ScaleY = -1.0;
        return ScaleY;
    }
};

class ShearTransformControl : public VectorTransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
        vector.X = 0;
        vector.Y = 0;
    }
    void mouse(INT x, INT y) {
        if (inControl(x, y, &vector)) {
            if (vector.Y > 100)
            {   // Reset
                vector.X = 0;
                vector.Y = 0;
            }
            else
            {   // Offset so user appears to be dragging 1,1 coordinate
                vector.X -= SampleRectSize;
                vector.Y -= SampleRectSize;
            }
        }
    }
    void paint(HDC hdc) {
        VectorTransformControl::paint(hdc);
        INT vx = vector.X*rect.Width/200;
        INT vy = vector.Y*rect.Height/200;

        MoveToEx(hdc, origin.X,                                origin.Y, NULL);
        LineTo(hdc, origin.X+vx,                               origin.Y+   rect.Height*SampleRectSize/200);
        LineTo(hdc, origin.X+vx+rect.Width*SampleRectSize/200, origin.Y+vy+rect.Height*SampleRectSize/200);
        LineTo(hdc, origin.X+   rect.Width*SampleRectSize/200, origin.Y+vy);
        LineTo(hdc, origin.X,                                  origin.Y);

        SetTextAlign(hdc, TA_CENTER);
        char strKey[50];
        INT strLen = sprintf(strKey, "Shear %.1f,%.1f", REAL(vector.X)/REAL(SampleRectSize), REAL(vector.Y)/REAL(SampleRectSize));
        RECT textRect = {rect.X, rect.Y+rect.Height, rect.X+rect.Width, rect.Y+rect.Height+fontCellHeight};
        ExtTextOutA(hdc, origin.X, rect.Y+rect.Height, ETO_OPAQUE, &textRect, strKey, strLen, NULL);
    }
    REAL getShearX() {
        return REAL(vector.X)/REAL(SampleRectSize);
    }
    REAL getShearY() {
        return REAL(vector.Y)/REAL(SampleRectSize);
    }
};

class TranslateTransformControl : public VectorTransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
        vector.X = 0;
        vector.Y = 0;
    }
    void mouse(INT x, INT y) {
        if (inControl(x, y, &vector)) {
            if (vector.Y > 100)
            {   // Reset
                vector.X = 0;
                vector.Y = 0;
            }
            else
            {   // Offset so user appears to be dragging 1,1 coordinate
                vector.X -= SampleRectSize;
                vector.Y -= SampleRectSize;
            }
        }
    }
    void paint(HDC hdc) {
        VectorTransformControl::paint(hdc);
        MoveToEx(hdc, origin.X+vector.X*rect.Width/200,                  origin.Y+vector.Y*rect.Height/200, NULL);
        LineTo  (hdc, origin.X+(vector.X+SampleRectSize)*rect.Width/200, origin.Y+vector.Y*rect.Height/200);
        LineTo  (hdc, origin.X+(vector.X+SampleRectSize)*rect.Width/200, origin.Y+(vector.Y+SampleRectSize)*rect.Height/200);
        LineTo  (hdc, origin.X+vector.X*rect.Width/200,                  origin.Y+(vector.Y+SampleRectSize)*rect.Height/200);
        LineTo  (hdc, origin.X+vector.X*rect.Width/200,                  origin.Y+vector.Y*rect.Height/200);
        SetTextAlign(hdc, TA_CENTER);
        char strKey[50];
        INT strLen = sprintf(strKey, "Trnslt %.1f,%.1f", REAL(vector.X)/REAL(SampleRectSize), REAL(vector.Y)/REAL(SampleRectSize));
        RECT textRect = {rect.X, rect.Y+rect.Height, rect.X+rect.Width, rect.Y+rect.Height+fontCellHeight};
        ExtTextOutA(hdc, origin.X, rect.Y+rect.Height, ETO_OPAQUE, &textRect, strKey, strLen, NULL);
    }
    REAL getTranslateX() {
        return REAL(vector.X)/REAL(SampleRectSize);
    }
    REAL getTranslateY() {
        return REAL(vector.Y)/REAL(SampleRectSize);
    }
};



class WorldTransformSetting {
public:
    void init           (HWND hDlg, Matrix *matrix);
    void paint          (HWND hWnd);
    void CalculateMatrix();
    void leftButtonDown (HWND hWnd, INT x, INT y);
    void leftButtonUp   (HWND hWnd, INT x, INT y);
    void mouseMove      (HWND hWnd, INT x, INT y);
    static LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
    ScaleTransformControl     scaleControl;
    AngleTransformControl     rotateControl;
    ShearTransformControl     shearControl;
    TranslateTransformControl translateControl;
    INT                       fontCellHeight;
    INT m11X, m11Y, m12X, m12Y, m21X, m21Y, m22X, m22Y, dxX, dxY, dyX, dyY;
    INT rX, rY, sxX, sxY, syX, syY, shX, shY;
    Matrix *TransformMatrix;

    // The controls sit in a grid:
    //
    // ************************
    // *                      *
    // * ****** ****** ****** *
    // * *    * *    * *    * *
    // * *Scl * *Rot * *Shr * *
    // * *    * *    * *    * *
    // * ****** ****** ****** *
    // *                      *
    // * ******  m11  m12   0 *
    // * *    *               *
    // * *xlt *  m21  m22   0 *
    // * *    *               *
    // * ******  d1   d2    1 *
    // *                      *
    // ************************

};

void WorldTransformSetting::init(HWND hWnd, Matrix *matrix) {
    SetWindowLongPtr(hWnd, GWLP_WNDPROC,  (LONG_PTR)this->WndProc);
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)this);

    TransformMatrix = matrix;

    RECT rect;
    GetClientRect(hWnd, &rect);
    fontCellHeight = rect.bottom*2/30;

    scaleControl.init    (rect.right/34,    rect.bottom/27,    rect.right*10/34, rect.bottom*10/27, fontCellHeight);
    rotateControl.init   (rect.right*12/34, rect.bottom/27,    rect.right*10/34, rect.bottom*10/27, fontCellHeight);
    shearControl.init    (rect.right*23/34, rect.bottom/27,    rect.right*10/34, rect.bottom*10/27, fontCellHeight);
    translateControl.init(rect.right/34,    rect.bottom*14/27, rect.right*10/34, rect.bottom*10/27, fontCellHeight);
    m11X = rect.right*17/34;  m11Y = rect.bottom*14/27;
    m12X = rect.right*28/34;  m12Y = rect.bottom*14/27;
    m21X = rect.right*17/34;  m21Y = rect.bottom*17/27;
    m22X = rect.right*28/34;  m22Y = rect.bottom*17/27;
    dxX  = rect.right*17/34;  dxY  = rect.bottom*20/27;
    dyX  = rect.right*28/34;  dyY  = rect.bottom*20/27;
    rX   = rect.right*15/34;  rY   = rect.bottom*24/27;
    sxX  = rect.right*20/34;  sxY  = rect.bottom*24/27;
    syX  = rect.right*24/34;  syY  = rect.bottom*24/27;
    shX  = rect.right*30/34;  shY  = rect.bottom*24/27;
    return;
}

void WorldTransformSetting::paint(HWND hWnd) {
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hWnd, &ps);

    HFONT hOldFont = (HFONT) SelectObject(hdc, CreateFontA(fontCellHeight,0,0,0,400,0,0,0,0,0,0,0,0,"Tahoma"));

    SetBkColor(hdc, COLORREF(0xC0C0C0));

    scaleControl.paint(hdc);
    rotateControl.paint(hdc);
    shearControl.paint(hdc);
    translateControl.paint(hdc);

    // Write out the matrix

    REAL mv[6];
    g_WorldTransform.GetElements(mv);

    SetTextAlign(hdc, TA_CENTER);
    char strKey[50];
    RECT textRect = {m11X - (m12X-m11X)/2, m11Y, m12X+(m12X-m11X)/2, shY+fontCellHeight};
    ExtTextOutA(hdc, 0, 0, ETO_OPAQUE, &textRect, "", 0, NULL);
    INT strLen;
    strLen = sprintf(strKey, "m11  %.1f", mv[0]); TextOutA(hdc, m11X, m11Y, strKey, strLen);
    strLen = sprintf(strKey, "m12  %.1f", mv[1]); TextOutA(hdc, m12X, m12Y, strKey, strLen);
    strLen = sprintf(strKey, "m21  %.1f", mv[2]); TextOutA(hdc, m21X, m21Y, strKey, strLen);
    strLen = sprintf(strKey, "m22  %.1f", mv[3]); TextOutA(hdc, m22X, m22Y, strKey, strLen);
    strLen = sprintf(strKey, "dx  %.1f",  mv[4]); TextOutA(hdc, dxX,  dxY,  strKey, strLen);
    strLen = sprintf(strKey, "dy  %.1f",  mv[5]); TextOutA(hdc, dyX,  dyY,  strKey, strLen);


    // Show result of Split Transform

    PointF scale;
    REAL   rotate;
    REAL   shear;
    PointF translate;
    SplitTransform(g_WorldTransform, scale, rotate, shear, translate);
    rotate = REAL(rotate * 180 / 3.14159265358979);
    strLen = sprintf(strKey, "r  %.1f", rotate);   TextOutA(hdc, rX,  rY,  strKey, strLen);
    strLen = sprintf(strKey, "sx  %.1f", scale.X); TextOutA(hdc, sxX, sxY, strKey, strLen);
    strLen = sprintf(strKey, "sy  %.1f", scale.Y); TextOutA(hdc, syX, syY, strKey, strLen);
    strLen = sprintf(strKey, "sh  %.1f", shear);   TextOutA(hdc, shX, shY, strKey, strLen);


    DeleteObject(SelectObject(hdc, hOldFont));
    EndPaint(hWnd, &ps);
    InvalidateText();
    return;
}

void WorldTransformSetting::CalculateMatrix() {
    TransformMatrix->Reset();
    TransformMatrix->Rotate(rotateControl.getAngle());
    TransformMatrix->Scale(scaleControl.getScaleX(), scaleControl.getScaleY());
    TransformMatrix->Shear(shearControl.getShearX(), shearControl.getShearY());
    TransformMatrix->Translate(
        translateControl.getTranslateX() * 10,  // * 10 (arbitrary) to make it visible
        translateControl.getTranslateY() * 10);
    return;
}

void WorldTransformSetting::leftButtonDown(HWND hWnd, INT x, INT y) {
    scaleControl.mouse(x,y);
    rotateControl.mouse(x,y);
    shearControl.mouse(x,y);
    translateControl.mouse(x,y);
    CalculateMatrix();
    InvalidateRect(hWnd, NULL, TRUE);
    return;
}

void WorldTransformSetting::leftButtonUp(HWND hWnd, INT x, INT y) {
    scaleControl.mouse(x,y);
    rotateControl.mouse(x,y);
    shearControl.mouse(x,y);
    translateControl.mouse(x,y);
    CalculateMatrix();
    InvalidateRect(hWnd, NULL, TRUE);
    return;
}

void WorldTransformSetting::mouseMove(HWND hWnd, INT x, INT y) {
    scaleControl.mouse(x,y);
    rotateControl.mouse(x,y);
    shearControl.mouse(x,y);
    translateControl.mouse(x,y);
    CalculateMatrix();
    InvalidateRect(hWnd, NULL, TRUE);
    return;
}

LRESULT CALLBACK WorldTransformSetting::WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

    HDC hdc;
    WorldTransformSetting *thisSetting = (WorldTransformSetting*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (message) {

        case WM_LBUTTONDOWN:
            thisSetting->leftButtonDown(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MOUSEMOVE:
            // Treat movement like lbuttonup while lbutton is down,
            // so the selection tracks the cursor movement.
            if (wParam & MK_LBUTTON) {
                thisSetting->mouseMove(hWnd, LOWORD(lParam), HIWORD(lParam));
            }
            break;


        case WM_LBUTTONUP:
            thisSetting->leftButtonUp(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;


        case WM_PAINT:
            thisSetting->paint(hWnd);
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
    }

    return 0;
}

WorldTransformSetting worldTransform;
WorldTransformSetting fontTransform;
WorldTransformSetting driverTransform;




const char *szAlignments[] = {
    "AlignNear",
    "AlignCenter",
    "AlignFar"
};

const char *szUnits[] = {
    "UnitWorld",      // 0 -- World coordinate (non-physical unit)
    "UnitNotValid",   // 1 -- UnitDisplay not valid for size units -- device dependent
    "UnitPixel",      // 2 -- Each unit is one device pixel.
    "UnitPoint",      // 3 -- Each unit is a printer's point, or 1/72 inch.
    "UnitInch",       // 4 -- Each unit is 1 inch.
    "UnitDocument",   // 5 -- Each unit is 1/300 inch.
    "UnitMillimeter"  // 6 -- Each unit is 1 millimeter.
};

const char *szForeGroundBrush[] = {
    "Solid",
    "RectGradient",
    "RadialGradient",
    "TriangleGradient",
    "LineGradient"
};

const char *szBackGroundBrush[] = {
    "Solid",
    "RectGradient",
    "RadialGradient",
    "TriangleGradient",
    "LineGradient"
};

const char *szTextMode[] = {
    "SystemDefault",
    "SingleBitPerPixelGridFit",
    "SingleBitPerPixel",
    "AntiAliasGridFit",
    "AntiAlias",
    "ClearTypeGridFit"
};

const char *szUniChar[] = {
    "(File)",
    "(Initial text)",
    "(Multilingual text)",
    "(Metrics text)",
    "200B ZWSP",
    "200C ZWNJ",
    "200D ZWJ",
    "200E LRM",
    "200F RLM",
    "202A LRE",
    "202B RLE",
    "202C PDF",
    "202D LRO",
    "202E RLO",
    "206A ISS",
    "206B ASS",
    "206E NADS",
    "206F NODS",
    "0908 Letter Ii",
    "0915 Letter Ka",
    "093f Vowel I",
    "094D Virama",
};


const char *szRows[] = {
    "1",
    "2",
    "4",
    "8",
    "16",
    "32",
    "64"   // ! Let's hope our friendly client brought his or her magnifying glass ....
};

const char *szDigitSubstitute[] = {
    "StringDigitSubstituteUser",
    "StringDigitSubstituteNone",
    "StringDigitSubstituteNational",
    "StringDigitSubstituteTraditional"
};


// Keep in sync with szLanguage
const LANGID Language[] = {
    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
    MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
    MAKELANGID(LANG_AFRIKAANS, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ALBANIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_IRAQ),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_EGYPT),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_LIBYA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_ALGERIA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_MOROCCO),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_TUNISIA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_OMAN),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_YEMEN),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SYRIA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_JORDAN),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_LEBANON),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_KUWAIT),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_UAE),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_BAHRAIN),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_QATAR),
    MAKELANGID(LANG_ARMENIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ASSAMESE, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_AZERI, SUBLANG_AZERI_LATIN),
    MAKELANGID(LANG_AZERI, SUBLANG_AZERI_CYRILLIC),
    MAKELANGID(LANG_BASQUE, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_BELARUSIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_BENGALI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_BULGARIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_CATALAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_HONGKONG),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SINGAPORE),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_MACAU),
    MAKELANGID(LANG_CROATIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_CZECH, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_DANISH, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH),
    MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH_BELGIAN),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_AUS),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_CAN),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_NZ),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_EIRE),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_SOUTH_AFRICA),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_JAMAICA),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_CARIBBEAN),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_BELIZE),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_TRINIDAD),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_ZIMBABWE),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_PHILIPPINES),
    MAKELANGID(LANG_ESTONIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_FAEROESE, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_FARSI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_FINNISH, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_BELGIAN),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_CANADIAN),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_SWISS),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_LUXEMBOURG),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_MONACO),
    MAKELANGID(LANG_GEORGIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_SWISS),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_AUSTRIAN),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_LUXEMBOURG),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_LIECHTENSTEIN),
    MAKELANGID(LANG_GREEK, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_GUJARATI,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_HEBREW, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_HINDI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_HUNGARIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ICELANDIC, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_INDONESIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ITALIAN,SUBLANG_ITALIAN),
    MAKELANGID(LANG_ITALIAN,SUBLANG_ITALIAN_SWISS),
    MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_KANNADA, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_KASHMIRI, SUBLANG_KASHMIRI_SASIA),
    MAKELANGID(LANG_KAZAK, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_KONKANI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_KOREAN,SUBLANG_KOREAN),
    MAKELANGID(LANG_LATVIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_LITHUANIAN,SUBLANG_LITHUANIAN),
    MAKELANGID(LANG_MACEDONIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_MALAY, SUBLANG_MALAY_MALAYSIA),
    MAKELANGID(LANG_MALAY, SUBLANG_MALAY_BRUNEI_DARUSSALAM),
    MAKELANGID(LANG_MALAYALAM,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_MANIPURI,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_MARATHI,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_NEPALI, SUBLANG_NEPALI_INDIA),
    MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL),
    MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_NYNORSK),
    MAKELANGID(LANG_ORIYA, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_POLISH, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE),
    MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE_BRAZILIAN),
    MAKELANGID(LANG_PUNJABI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ROMANIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_RUSSIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SANSKRIT, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SERBIAN, SUBLANG_SERBIAN_LATIN),
    MAKELANGID(LANG_SERBIAN, SUBLANG_SERBIAN_CYRILLIC),
    MAKELANGID(LANG_SINDHI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SLOVAK, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SLOVENIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MEXICAN),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MODERN),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_GUATEMALA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_COSTA_RICA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_PANAMA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_DOMINICAN_REPUBLIC),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_VENEZUELA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_COLOMBIA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_PERU),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_ARGENTINA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_ECUADOR),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_CHILE),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_URUGUAY),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_PARAGUAY),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_BOLIVIA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_EL_SALVADOR),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_HONDURAS),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_NICARAGUA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_PUERTO_RICO),
    MAKELANGID(LANG_SWAHILI,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH),
    MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH_FINLAND),
    MAKELANGID(LANG_TAMIL,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_TATAR, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_TELUGU, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_THAI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_TURKISH,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_UKRAINIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_URDU, SUBLANG_URDU_PAKISTAN),
    MAKELANGID(LANG_URDU, SUBLANG_URDU_INDIA),
    MAKELANGID(LANG_UZBEK, SUBLANG_UZBEK_LATIN),
    MAKELANGID(LANG_UZBEK, SUBLANG_UZBEK_CYRILLIC),
    MAKELANGID(LANG_VIETNAMESE, SUBLANG_NEUTRAL)
};

const char *szLanguage[] = {
    "Neutral, Neutral",
    "Neutral, Default",
    "Neutral, System default",
    "Afrikaans",
    "Albanian",
    "Arabic, Saudi Arabia",
    "Arabic, Iraq",
    "Arabic, Egypt",
    "Arabic, Libya",
    "Arabic, Algeria",
    "Arabic, Morocco",
    "Arabic, Tunisia",
    "Arabic, Oman",
    "Arabic, Yemen",
    "Arabic, Syria",
    "Arabic, Jordan",
    "Arabic, Lebanon",
    "Arabic, Kuwait",
    "Arabic, UAE",
    "Arabic, Bahrain",
    "Arabic, Qatar",
    "Armenian",
    "Assamese",
    "Azeri, Latin",
    "Azeri, Cyrillic",
    "Basque, ",
    "Belarusian",
    "Bengali",
    "Bulgarian",
    "Catalan",
    "Chinese, Traditional",
    "Chinese, Simplified",
    "Chinese, Hong Kong",
    "Chinese, Singapore",
    "Chinese, Macau",
    "Croatian",
    "Czech",
    "Danish",
    "Dutch",
    "Dutch, Belgian",
    "English, US",
    "English, UK",
    "English, Australia",
    "English, Canada",
    "English, New Zeland",
    "English, Eire",
    "English, South Africa",
    "English, Jamaica",
    "English, Caribbean",
    "English, Belize",
    "English, Trinidad",
    "English, Zimbabwe",
    "English, Philippines",
    "Estonian",
    "Faeroese",
    "Farsi",
    "Finnish",
    "French",
    "French, Belgian",
    "French, Canadian",
    "French, Swiss",
    "French, Luxembourg",
    "French, Monaco",
    "Georgian",
    "German",
    "German, Swiss",
    "German, Austrian",
    "German, Luxembourg",
    "German, Liechtenstein",
    "Greek",
    "Gujarati",
    "Hebrew",
    "Hindi",
    "Hungarian",
    "Icelandic",
    "Indonesian",
    "Italian",
    "Italian, Swiss",
    "Japanese",
    "Kannada",
    "Kashmiri",
    "Kazak",
    "Konkani",
    "Korean",
    "Latvian",
    "Lithuanian",
    "FYRO Macedonian",
    "Malay, Malaysia",
    "MALAY, Brunei darussalam",
    "Malayalam",
    "Manipuri",
    "Marathi",
    "Nepali, India",
    "Norwegian, Bokmal",
    "Norwegian, Nynorsk",
    "Oriya",
    "Polish",
    "Portuguese",
    "Portuguese, Brazilian",
    "Punjabi",
    "Romanian",
    "Russian",
    "Sanskrit",
    "Serbian, Latin",
    "Serbian, Cyrillic",
    "Sindhi",
    "Slovak",
    "Slovenian",
    "Spanish",
    "Spanish, Mexican",
    "Spanish, Modern",
    "Spanish, Guatemala",
    "Spanish, Costa Rica",
    "Spanish, Panama",
    "Spanish, Dominican Republic",
    "Spanish, Venezuela",
    "Spanish, Colombia",
    "Spanish, Peru",
    "Spanish, Argentina",
    "Spanish, Ecuador",
    "Spanish, Chile",
    "Spanish, Uruguay",
    "Spanish, Paraguay",
    "Spanish, Bolivia",
    "Spanish, El Salvador",
    "Spanish, Honduras",
    "Spanish, Nicaragua",
    "Spanish, Puerto Rico",
    "Swahili",
    "Swedish",
    "Swedish, Finland",
    "Tamil",
    "Tatar",
    "Telugu",
    "Thai",
    "Turkish",
    "Ukrainian",
    "Urdu, Pakistan",
    "Urdu, India",
    "Uzbek, Latin",
    "Uzbek, Cyrillic",
    "Vietnamese"
};


const char *szDriverDx[] = {
    "0",
    "10",
    "15",
    "20",
    "25",
    "30",
    "35",
    "40"
};


const char *szDriverPixels[] = {
    "8",
    "9",
    "10",
    "11",
    "12",
    "13",
    "14",
    "16",
    "18",
    "20",
    "24",
    "28",
    "36"
};


const char *szOffsets[] = {
    "0",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900",
    "a00",
    "b00",
    "c00",
    "d00",
    "e00",
    "f00",
    "1000",
    "2000",
    "3000",
    "4000",
    "5000",
    "6000",
    "7000",
    "8000",
    "9000",
    "a000",
    "b000",
    "c000",
    "d000",
    "e000",
    "f000",
};




void ShowSecondaryDialog(HWND hDialog)
{
    RECT rcText;    GetWindowRect(g_hTextWnd, &rcText);
    RECT rcDialog;  GetWindowRect(hDialog,    &rcDialog);

    if (rcText.bottom < rcDialog.bottom)
    {
        SetWindowPos(
            g_hTextWnd,
            NULL,
            0,0,
            g_iMinWidth * 29 / 10, rcDialog.bottom - rcText.top,
            SWP_NOZORDER | SWP_NOMOVE);
    }
    ShowWindow(hDialog, SW_SHOW);
}



void EnableSecondaryDialog(HWND hDlg, INT dialogId, BOOL enable)
{
    if (g_ShowDriver)
    {
        g_ShowDriver = FALSE;
        ShowWindow(g_hDriverSettingsDlg, SW_HIDE);
        SendDlgItemMessage(hDlg, IDC_SHOWDRIVER,  BM_SETCHECK, BST_UNCHECKED, 0);
    }

    if (g_ShowGlyphs)
    {
        g_ShowGlyphs = FALSE;
        ShowWindow(g_hGlyphSettingsDlg, SW_HIDE);
        SendDlgItemMessage(hDlg, IDC_SHOWGLYPHS,  BM_SETCHECK, BST_UNCHECKED, 0);
    }

    if (enable)
    {
        switch (dialogId)
        {
            case IDC_SHOWGLYPHS:  ShowSecondaryDialog(g_hGlyphSettingsDlg);  g_ShowGlyphs = TRUE; break;
            case IDC_SHOWDRIVER:  ShowSecondaryDialog(g_hDriverSettingsDlg); g_ShowDriver = TRUE; break;
        }
    }


    InvalidateText();
}




BOOL FormatFlag(HWND hDlg, INT iCmd, INT flag)
{
    if (IsDlgButtonChecked(hDlg, iCmd))
    {
        g_formatFlags |= flag;
    }
    else
    {
        g_formatFlags &= ~flag;
    }
    SetFocus(g_hTextWnd);
    InvalidateText();
    return TRUE;
}



static COLORREF s_Colors[16];

void InsertText(HWND hDlg, char *textId)
{
    BOOL fLoadTextFile = false;
    char szTextFilename[MAX_PATH];

    if (lstrcmpiA(textId, "(file)") == 0)
    {
        OPENFILENAMEA  ofn = {0};
        char         szSelectedFile[128];

        szSelectedFile[0] = 0;

        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = hDlg;
        ofn.lpstrFilter     = "Text files\0*.TXT\0";
        ofn.lpstrFile       = szSelectedFile;
        ofn.nMaxFile        = sizeof(szSelectedFile);
        ofn.Flags           = OFN_FILEMUSTEXIST | OFN_LONGNAMES;

        if (GetOpenFileNameA(&ofn))
        {
            fLoadTextFile = true;
            lstrcpyA(szTextFilename, ofn.lpstrFile);
        }
    }
    else if (lstrcmpiA(textId, "(Initial text)") == 0)
    {
        InitText(ID_INITIAL_TEXT);
        InvalidateText();
    }
    else if (lstrcmpiA(textId, "(Multilingual text)") == 0)
    {
        InitText(ID_MULTILINGUAL_TEXT);
        InvalidateText();
    }
    else if (lstrcmpiA(textId, "(Metrics text)") == 0)
    {
        InitText(ID_METRICS_TEXT);
        InvalidateText();
    }
    else
    {
        // Attempt to load this as a file...
        lstrcpyA(szTextFilename, textId);
        fLoadTextFile = true;
    }

    if (fLoadTextFile)
    {
        HANDLE  hf = CreateFileA (szTextFilename,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                NULL,
                                NULL);

        if (hf != INVALID_HANDLE_VALUE)
        {
            DWORD   charRead;
            BYTE    *fileData = NULL;

            DWORD   fileSize = GetFileSize (hf, NULL);

            if (fileSize > 0)
                fileData = new BYTE [fileSize];

            if (fileData)
            {
                if (ReadFile (hf,
                             fileData,
                             (DWORD)(min (MAX_TEXT * sizeof(WCHAR), fileSize)),
                             &charRead,
                             NULL) != 0)
                {
                    INT c = 0;

                    if (((WCHAR *)fileData)[0] == 0xfeff)
                    {
                        charRead /= sizeof(WCHAR);
                        c += 1;     // strip out Unicode BOM
                    }

                    TextDelete (0, g_iTextLen);
                    TextInsert (0, &((WCHAR *)fileData)[c], charRead - c);
                    InvalidateText();
                }
                delete [] fileData;
            }
            CloseHandle (hf);
        }
    }
}






BOOL Command(HWND hDlg, int iCmd, int iNotify, HWND hItemWnd) {

    char   str[100];
    WCHAR  wc;
    int    i;
    char   hex[] = "0123456789abcdef";


    switch(iCmd) {

    // Font family enumeration

    case IDC_SHOWFAMILIES:
        g_ShowFamilies = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;

    case IDC_PLAINTEXT_FONT:
    case IDC_PLAINTEXT_SIZE:
    case IDC_PLAINTEXT_BOLD:
    case IDC_PLAINTEXT_ITALIC:
    case IDC_PLAINTEXT_UNDERLINE:
    case IDC_PLAINTEXT_STRIKEOUT:

        ChangeFont(
            hDlg,
            0,
            IDC_PLAINTEXT_FONT,
            IDC_PLAINTEXT_SIZE,
            IDC_PLAINTEXT_BOLD,
            IDC_PLAINTEXT_ITALIC,
            IDC_PLAINTEXT_UNDERLINE,
            IDC_PLAINTEXT_STRIKEOUT,
            iCmd,
            iNotify);
        return TRUE;



    // Logical Unicode text

    case IDC_LOGICAL:
        g_ShowLogical = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;

    case IDC_INSERT_CODEPOINT:
        if (GetDlgItemTextA(hDlg, IDC_CODEPOINT, str, sizeof(str)))
        {
            if (str[0] == '(')
            {
                InsertText(hDlg, str);
            }
            else
            {
                wc = (WCHAR)HexToInt(str);
                if (TextInsert(g_iCurChar, &wc, 1)) {
                    g_iCurChar++;
                    InvalidateText();
                }
            }
        }
        return TRUE;

    case IDC_SHOWLEVELS:
        g_fShowLevels = !g_fShowLevels;
        if (g_fShowLevels)
        {
            SetDlgItemTextA(hDlg, IDC_SHOWLEVELS, "Hide levels");
        }
        else
        {
            SetDlgItemTextA(hDlg, IDC_SHOWLEVELS, "Show levels");
        }
        SetFocus(g_hTextWnd);
        InvalidateText();
        return TRUE;



    // Glyph chart using DrawGlyphs

    case IDC_SHOWGLYPHS:
        EnableSecondaryDialog(hDlg, iCmd, IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED);
        return TRUE;


    // Driver strings

    case IDC_SHOWDRIVER:
        EnableSecondaryDialog(hDlg, iCmd, IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED);
        return TRUE;


    // Plain text displayed with DrawString

    case IDC_SHOWDRAWSTRING:
        g_ShowDrawString = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;

    case IDC_SHOWGDI:
        g_ShowGDI = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_METAFILE:
        g_testMetafile = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        SetFocus(g_hTextWnd);
        InvalidateText();
        return TRUE;


    // StringFormatFlags


    case IDC_DIR:        return FormatFlag(hDlg, iCmd, StringFormatFlagsDirectionRightToLeft);
    case IDC_HORIZ:      return FormatFlag(hDlg, iCmd, StringFormatFlagsDirectionVertical);
    case IDC_NOFITBB:    return FormatFlag(hDlg, iCmd, StringFormatFlagsNoFitBlackBox);
    case IDC_DISPLAYFMT: return FormatFlag(hDlg, iCmd, StringFormatFlagsDisplayFormatControl);
    case IDC_NOFALLBACK: return FormatFlag(hDlg, iCmd, StringFormatFlagsNoFontFallback);
    case IDC_MEASPACE:   return FormatFlag(hDlg, iCmd, StringFormatFlagsMeasureTrailingSpaces);
    case IDC_NOWRAP:     return FormatFlag(hDlg, iCmd, StringFormatFlagsNoWrap);
    case IDC_LINELIMIT:  return FormatFlag(hDlg, iCmd, StringFormatFlagsLineLimit);
    case IDC_NOCLIP:     return FormatFlag(hDlg, iCmd, StringFormatFlagsNoClip);

    // Private, testing, flags

    case IDC_NOGDI:      return FormatFlag(hDlg, iCmd, 0x80000000);
    case IDC_FULLIMAGER: return FormatFlag(hDlg, iCmd, 0x40000000);
    case IDC_NOMINAL:    return FormatFlag(hDlg, iCmd, 0x20000000);



    // String format fields

    case IDC_ALIGNNEAR:   g_align = StringAlignmentNear;   InvalidateText();  return TRUE;
    case IDC_ALIGNCENTER: g_align = StringAlignmentCenter; InvalidateText();  return TRUE;
    case IDC_ALIGNFAR:    g_align = StringAlignmentFar;    InvalidateText();  return TRUE;

    case IDC_LINEALIGNNEAR:   g_lineAlign = StringAlignmentNear;   InvalidateText();  return TRUE;
    case IDC_LINEALIGNCENTER: g_lineAlign = StringAlignmentCenter; InvalidateText();  return TRUE;
    case IDC_LINEALIGNFAR:    g_lineAlign = StringAlignmentFar;    InvalidateText();  return TRUE;

    case IDC_HOTKEYNONE:  g_hotkey = HotkeyPrefixNone;  InvalidateText();  return TRUE;
    case IDC_HOTKEYSHOW:  g_hotkey = HotkeyPrefixShow;  InvalidateText();  return TRUE;
    case IDC_HOTKEYHIDE:  g_hotkey = HotkeyPrefixHide;  InvalidateText();  return TRUE;

    case IDC_TRIMMINGNONE:     g_lineTrim = StringTrimmingNone;               InvalidateText();  return TRUE;
    case IDC_TRIMMINGCHAR:     g_lineTrim = StringTrimmingCharacter;          InvalidateText();  return TRUE;
    case IDC_TRIMMINGWORD:     g_lineTrim = StringTrimmingWord;               InvalidateText();  return TRUE;
    case IDC_TRIMMINGELPSCH:   g_lineTrim = StringTrimmingEllipsisCharacter;  InvalidateText();  return TRUE;
    case IDC_TRIMMINGELPSWD:   g_lineTrim = StringTrimmingEllipsisWord;       InvalidateText();  return TRUE;
    case IDC_TRIMMINGELPSURL:  g_lineTrim = StringTrimmingEllipsisPath;       InvalidateText();  return TRUE;


    case IDC_DEFAULTFORMAT:
        g_typographic = FALSE;
        InvalidateText();
        return TRUE;


    case IDC_TYPOGRAPHICFORMAT:
        g_typographic = TRUE;
        InvalidateText();
        return TRUE;



    case IDC_FONTUNIT:
        g_fontUnit = Unit(SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    case IDC_FOREBRUSHTYPE:
        GetTextForeGroundBrush(SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    case IDC_BACKBRUSHTYPE:
        GetTextBackGroundBrush(SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    case IDC_TEXTMODE:
        GetTextRenderingMode(SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    // String formant digit substitution
    case IDC_DIGIT_SUBSTITUTE:
        GetDigitSubstituteMode(hDlg, SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    case IDC_LANGUAGE:
        g_Language = Language[SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0)];
        InvalidateText();
        return TRUE;

    // Plain text displayed with paths

    case IDC_SHOWPATH:
        g_ShowPath = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    // Font metrics

    case IDC_SHOWMETRIC:
        g_ShowMetric = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    // Performance tests

    case IDC_PERFORMANCE:
        g_ShowPerformance = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    // Scaling

    case IDC_SHOWSCALING:
        g_ShowScaling = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    // Print

    case IDC_PRINT:
        PrintPage();
        return TRUE;

    case IDC_CLR_FOR:
        {
            CHOOSECOLOR cc = {0};
            Color color(g_TextColor);
            cc.lStructSize = sizeof cc;
            cc.lpCustColors = s_Colors;
            cc.rgbResult = RGB(color.GetRed(), color.GetGreen(), color.GetBlue());
            cc.Flags = CC_RGBINIT | CC_ANYCOLOR;
            BOOL bRet = ChooseColor(&cc);
            color.SetFromCOLORREF(cc.rgbResult);
            g_TextColor = color.GetValue();
            GetTextForeGroundBrush(SendDlgItemMessage(hDlg, IDC_FOREBRUSHTYPE, CB_GETCURSEL, 0, 0));
            InvalidateText();
        }
        return TRUE;

    case IDC_CLR_BAC:
        {
            CHOOSECOLOR cc = {0};
            Color color(g_BackColor);
            cc.lStructSize = sizeof cc;
            cc.lpCustColors = s_Colors;
            cc.rgbResult = RGB(color.GetRed(), color.GetGreen(), color.GetBlue());
            cc.Flags = CC_RGBINIT | CC_ANYCOLOR;
            BOOL bRet = ChooseColor(&cc);
            color.SetFromCOLORREF(cc.rgbResult);
            g_BackColor = color.GetValue();
            GetTextBackGroundBrush(SendDlgItemMessage(hDlg, IDC_BACKBRUSHTYPE, CB_GETCURSEL, 0, 0));
            InvalidateText();
        }
        return TRUE;

/* obsolete


    case IDC_PLAINTEXT:
        g_fShowPlainText = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_LANGUAGE:

        if (iNotify == CBN_SELCHANGE) {
            i = SendMessage(hItemWnd, CB_GETCURSEL, 0, 0);
            if (SendMessage(hItemWnd, CB_GETLBTEXT, i, (LPARAM)str) != CB_ERR) {
                wc = (WCHAR)HexToInt(str);
                g_ScriptControl.uDefaultLanguage = wc;
                InvalidateText();
            }
        } else if (iNotify == CBN_EDITCHANGE) {
            if (SendMessage(hItemWnd, WM_GETTEXT, sizeof(str), (LPARAM)str)) {
                wc = (WCHAR)HexToInt(str);
                g_ScriptControl.uDefaultLanguage = wc;
                InvalidateText();
            }
        }
        return TRUE;

    case IDC_HIGHLIGHT_FROM:
    case IDC_HIGHLIGHT_TO:
        InvalidateText();
        return TRUE;


    case IDC_LINEFILL:
        g_fFillLines = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;

    case IDC_LTR:
        g_ScriptState.uBidiLevel = 0;
        SendDlgItemMessage(hDlg, IDC_LTR, BM_SETSTATE, TRUE, 0);
        SendDlgItemMessage(hDlg, IDC_RTL, BM_SETSTATE, FALSE, 0);
        InvalidateText();
        return TRUE;

    case IDC_RTL:
        g_ScriptState.uBidiLevel = 1;
        SendDlgItemMessage(hDlg, IDC_RTL, BM_SETSTATE, TRUE, 0);
        SendDlgItemMessage(hDlg, IDC_LTR, BM_SETSTATE, FALSE, 0);
        InvalidateText();
        return TRUE;


    case IDC_CONTROL_CONTEXT:
        g_ScriptControl.fContextDigits = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_DIGIT_SUBSTITUTE:
        g_ScriptState.fDigitSubstitute = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_ARANUMCONTEXT:
        g_ScriptState.fArabicNumContext = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_LEGACY_BIDI:
        g_ScriptControl.fLegacyBidiClass = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_OVERRIDE:
        g_ScriptState.fOverrideDirection = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_CONTROL_CHARS:
        g_ScriptState.fDisplayZWG = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_LOGICAL_ORDER:
        g_fLogicalOrder = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_NO_GLYPH_INDEX:
        g_fNoGlyphIndex = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_FIT:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_FIT;
        } else {
            g_dwSSAflags &= ~SSA_FIT;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_CLIP:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_CLIP;
        } else {
            g_dwSSAflags &= ~SSA_CLIP;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_TAB:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_TAB;
        } else {
            g_dwSSAflags &= ~SSA_TAB;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_DX:
        g_fOverrideDx = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        memset(g_iWidthBuf, 0, sizeof(int)*g_iTextLen+1);
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_FALLBACK:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_FALLBACK;
        } else {
            g_dwSSAflags &= ~SSA_FALLBACK;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_LINK:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_LINK;
        } else {
            g_dwSSAflags &= ~SSA_LINK;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_HOTKEY:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_HOTKEY;
        } else {
            g_dwSSAflags &= ~SSA_HOTKEY;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_PASSWORD:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_PASSWORD;
        } else {
            g_dwSSAflags &= ~SSA_PASSWORD;
        }
        InvalidateText();
        return TRUE;



    case IDC_FORMATTED:
        g_fShowFancyText = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_FANCY_FONT1:
    case IDC_FANCY_SIZE1:
        if (iNotify != CBN_SELCHANGE) {
            return FALSE;
        }
    case IDC_FANCY_BOLD1:
    case IDC_FANCY_ITALIC1:
    case IDC_FANCY_UNDERLINE1:
        ChangeFont(
            hDlg,
            1,
            IDC_FANCY_FONT1,
            IDC_FANCY_SIZE1,
            IDC_FANCY_BOLD1,
            IDC_FANCY_ITALIC1,
            IDC_FANCY_UNDERLINE1);
        return TRUE;


    case IDC_FANCY_FONT2:
    case IDC_FANCY_SIZE2:
        if (iNotify != CBN_SELCHANGE) {
            return FALSE;
        }
    case IDC_FANCY_BOLD2:
    case IDC_FANCY_ITALIC2:
    case IDC_FANCY_UNDERLINE2:
        ChangeFont(
            hDlg,
            2,
            IDC_FANCY_FONT2,
            IDC_FANCY_SIZE2,
            IDC_FANCY_BOLD2,
            IDC_FANCY_ITALIC2,
            IDC_FANCY_UNDERLINE2);
        return TRUE;


    case IDC_FANCY_FONT3:
    case IDC_FANCY_SIZE3:
        if (iNotify != CBN_SELCHANGE) {
            return FALSE;
        }
    case IDC_FANCY_BOLD3:
    case IDC_FANCY_ITALIC3:
    case IDC_FANCY_UNDERLINE3:
        ChangeFont(
            hDlg,
            3,
            IDC_FANCY_FONT3,
            IDC_FANCY_SIZE3,
            IDC_FANCY_BOLD3,
            IDC_FANCY_ITALIC3,
            IDC_FANCY_UNDERLINE3);
        return TRUE;


    case IDC_FANCY_FONT4:
    case IDC_FANCY_SIZE4:
        if (iNotify != CBN_SELCHANGE) {
            return FALSE;
        }
    case IDC_FANCY_BOLD4:
    case IDC_FANCY_ITALIC4:
    case IDC_FANCY_UNDERLINE4:
        ChangeFont(
            hDlg,
            4,
            IDC_FANCY_FONT4,
            IDC_FANCY_SIZE4,
            IDC_FANCY_BOLD4,
            IDC_FANCY_ITALIC4,
            IDC_FANCY_UNDERLINE4);
        return TRUE;


    case IDC_FORMAT1:
    case IDC_FORMAT2:
    case IDC_FORMAT3:
    case IDC_FORMAT4:

        if (g_iTo < g_iFrom) {
            i=g_iTo;  g_iTo=g_iFrom;  g_iFrom=i;
        }

        if (    g_iFrom <  g_iTo
            &&  g_iFrom <  g_iTextLen
            &&  g_iTo   <= g_iTextLen) {

            i=1; // Default
            switch(iCmd) {
                case IDC_FORMAT1:  i=1;  break;
                case IDC_FORMAT2:  i=2;  break;
                case IDC_FORMAT3:  i=3;  break;
                case IDC_FORMAT4:  i=4;  break;
            }
            StyleSetRange(i, g_iFrom, g_iTo-g_iFrom);
            ASSERT(StyleCheckRange());
            InvalidateText();
        }
        return TRUE;


    case IDC_APPLYDIGITSUBST:
        ScriptApplyDigitSubstitution(NULL, &g_ScriptControl, &g_ScriptState);

        SendDlgItemMessage(hDlg, IDC_DIGIT_SUBSTITUTE,  BM_SETCHECK, g_ScriptState.fDigitSubstitute ? BST_CHECKED : BST_UNCHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_CONTROL_CONTEXT,   BM_SETCHECK, g_ScriptControl.fContextDigits ? BST_CHECKED : BST_UNCHECKED, 0);
        str[0] = '0';
        str[1] = 'x';
        str[2] = hex[(g_ScriptControl.uDefaultLanguage & 0xf0) >> 4];
        str[3] = hex[ g_ScriptControl.uDefaultLanguage & 0x0f];
        str[4] = 0;
        SendDlgItemMessage(hDlg, IDC_LANGUAGE,          CB_SELECTSTRING, 0, (LPARAM) str);

        InvalidateText();
        return TRUE;


    case IDC_PRESENTATION:
        g_fPresentation = TRUE;
        ShowWindow(g_hSettingsDlg, SW_HIDE);
        SetFocus(g_hTextWnd);
        InvalidateText();
        return TRUE;



*/


    }  // end switch

    return FALSE;
}





BOOL GetDropListValue(HWND hDlg, INT iCmd, INT iNotify, char *str, INT strlen)
{
    switch (iNotify)
    {
        case CBN_EDITCHANGE:
            return GetDlgItemTextA(hDlg, iCmd, str, strlen);

        case CBN_SELCHANGE:
            return SendDlgItemMessage(
                hDlg,
                iCmd,
                CB_GETLBTEXT,
                SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0),
                (LPARAM)str
            ) != CB_ERR;
    }

    return FALSE;
}


BOOL DriverSettingsCommand(HWND hDlg, int iCmd, int iNotify, HWND hItemWnd) {

    char   str[100];

    switch(iCmd) {

    // Driver strings

        case IDC_DRIVERCMAP:
            if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED)
            {
                g_DriverOptions |= DriverStringOptionsCmapLookup;
            }
            else
            {
                g_DriverOptions &= ~DriverStringOptionsCmapLookup;
            }
            InvalidateText();
            return TRUE;

        case IDC_DRIVERVERTICAL:
            if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED)
            {
                g_DriverOptions |= DriverStringOptionsVertical;
            }
            else
            {
                g_DriverOptions &= ~DriverStringOptionsVertical;
            }
            InvalidateText();
            return TRUE;

        case IDC_DRIVERREALIZEDADVANCE:
            if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED)
            {
                g_DriverOptions |= DriverStringOptionsRealizedAdvance;
            }
            else
            {
                g_DriverOptions &= ~DriverStringOptionsRealizedAdvance;
            }
            InvalidateText();
            return TRUE;


        case IDC_DRIVERDX:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_DriverDx = REAL(atof(str));
                InvalidateText();
            }
            return TRUE;

        case IDC_DRIVERDY:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_DriverDy = REAL(atof(str));
                InvalidateText();
            }
            return TRUE;

            case IDC_LIMITSUBPIXEL:
                if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED)
                {
                    g_DriverOptions |= DriverStringOptionsLimitSubpixel;
                }
                else
                {
                    g_DriverOptions &= ~DriverStringOptionsLimitSubpixel;
                }
                InvalidateText();
                return TRUE;

        case IDC_DRIVERORIGINALPIXELS:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_DriverPixels = REAL(atof(str));
                InvalidateText();
            }
            return TRUE;

    }  // end switch

    return FALSE;
}





BOOL GlyphSettingsCommand(HWND hDlg, int iCmd, int iNotify, HWND hItemWnd) {

    char   str[100];

    switch(iCmd) {

        case IDC_GLYPHCMAPLOOKUP:
            g_CmapLookup = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
            InvalidateText();
            return TRUE;

        case IDC_GLYPHHORIZONTALCHART:
            g_HorizontalChart = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
            InvalidateText();
            return TRUE;

        case IDC_GLYPHSHOWCELL:
            g_ShowCell = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
            InvalidateText();
            return TRUE;

        case IDC_GLYPHVERTICALFORMS:
            g_VerticalForms = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
            InvalidateText();
            return TRUE;


        case IDC_GLYPHROWS:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_GlyphRows = atoi(str);
                if (g_GlyphRows > 64) g_GlyphRows = 64;
                InvalidateText();
            }
            return TRUE;


        case IDC_GLYPHCOLUMNS:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_GlyphColumns = atoi(str);
                if (g_GlyphColumns > 64) g_GlyphColumns = 64;
                InvalidateText();
            }
            return TRUE;


        case IDC_GLYPHINDEX:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_GlyphFirst = HexToInt(str);
                InvalidateText();
            }
            return TRUE;



    }  // end switch

    return FALSE;
}





int CALLBACK InitOneFace(
    const ENUMLOGFONTEXA   *lpelfe,    // pointer to logical-font data
    const NEWTEXTMETRICEXA *lpntme,    // pointer to physical-font data
    int                     FontType,  // type of font
    LPARAM                  lParam) {  // application-defined data

    if (SendDlgItemMessage(
            (HWND)lParam,
            IDC_PLAINTEXT_FONT,
            CB_FINDSTRINGEXACT,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName) == CB_ERR) {

        // It's a new font name

        SendDlgItemMessage(
            (HWND)lParam,
            IDC_PLAINTEXT_FONT,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);

/*
        SendDlgItemMessage(
            (HWND)lParam,
            IDC_FANCY_FONT1,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);

        SendDlgItemMessage(
            (HWND)lParam,
            IDC_FANCY_FONT2,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);

        SendDlgItemMessage(
            (HWND)lParam,
            IDC_FANCY_FONT3,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);

        SendDlgItemMessage(
            (HWND)lParam,
            IDC_FANCY_FONT4,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);
*/
    }


    return 1;   // Continue enumeration


    UNREFERENCED_PARAMETER(FontType);
    UNREFERENCED_PARAMETER(lpntme);
}


void InitOneSize(
    HWND   hDlg,
    char  *str) {

    SendDlgItemMessageA(hDlg, IDC_PLAINTEXT_SIZE, CB_ADDSTRING, 0, (LPARAM)str);
/*
    SendDlgItemMessage(hDlg, IDC_FANCY_SIZE1,    CB_ADDSTRING, 0, (LPARAM)str);
    SendDlgItemMessage(hDlg, IDC_FANCY_SIZE2,    CB_ADDSTRING, 0, (LPARAM)str);
    SendDlgItemMessage(hDlg, IDC_FANCY_SIZE3,    CB_ADDSTRING, 0, (LPARAM)str);
    SendDlgItemMessage(hDlg, IDC_FANCY_SIZE4,    CB_ADDSTRING, 0, (LPARAM)str);
*/
}



void InitSelection(HWND hDlg, int idFace, int idSize, TCHAR *sFaceName) {

    INT_PTR     i;

    i = SendDlgItemMessage(hDlg, idFace, CB_FINDSTRINGEXACT, 0, (LPARAM)sFaceName);
    if (i == CB_ERR) {
        SendDlgItemMessage(hDlg, idFace, CB_SETCURSEL, 0, 0);
    } else {
        SendDlgItemMessage(hDlg, idFace, CB_SETCURSEL, i, 0);
    }

    SendDlgItemMessage(hDlg, idSize, CB_SETCURSEL, 2, 0);   // Selection 2 is 8 point
}


void InitFaceLists(HWND hDlg) {

    HDC      hdc;
    LOGFONT lf;

    memset(&lf, 0, sizeof(lf));
    lf.lfCharSet = DEFAULT_CHARSET;
    hdc = GetDC(g_hTextWnd);
    EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)InitOneFace, (LPARAM)hDlg, 0);

    // Hard coded addtion of MS Shell Dlg fonts

    SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_ADDSTRING, 0,  (LPARAM)"MS Shell Dlg");
    SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_ADDSTRING, 0,  (LPARAM)"MS Shell Dlg 2");

    ReleaseDC(g_hTextWnd, hdc);


    // Initialise sizes

    InitOneSize(hDlg, "6");
    InitOneSize(hDlg, "7");
    InitOneSize(hDlg, "8");
    InitOneSize(hDlg, "9");
    InitOneSize(hDlg, "10");
    InitOneSize(hDlg, "11");
    InitOneSize(hDlg, "12");
    InitOneSize(hDlg, "13");
    InitOneSize(hDlg, "14");
    InitOneSize(hDlg, "16");
    InitOneSize(hDlg, "18");
    InitOneSize(hDlg, "20");
    InitOneSize(hDlg, "22");
    InitOneSize(hDlg, "24");
    InitOneSize(hDlg, "28");
    InitOneSize(hDlg, "32");
    InitOneSize(hDlg, "36");
    InitOneSize(hDlg, "48");
    InitOneSize(hDlg, "60");
    InitOneSize(hDlg, "72");
    InitOneSize(hDlg, "90");
    InitOneSize(hDlg, "108");
    InitOneSize(hDlg, "144");
    InitOneSize(hDlg, "180");
    InitOneSize(hDlg, "216");
    InitOneSize(hDlg, "252");
    InitOneSize(hDlg, "288");
    InitOneSize(hDlg, "324");
    InitOneSize(hDlg, "360");
    InitOneSize(hDlg, "396");
    InitOneSize(hDlg, "450");
    InitOneSize(hDlg, "504");
    InitOneSize(hDlg, "558");
    InitOneSize(hDlg, "612");
    InitOneSize(hDlg, "666");
    InitOneSize(hDlg, "720");
#define MAXPOINTSIZE 720  // Keep same as point size in the previous line


    // Select standard fonts and sizes


    InitSelection(hDlg, IDC_PLAINTEXT_FONT, IDC_PLAINTEXT_SIZE, _TEXT("Microsoft Sans Serif"));

/*
    InitSelection(hDlg, IDC_FANCY_FONT1,    IDC_FANCY_SIZE1,    "Tahoma");
    InitSelection(hDlg, IDC_FANCY_FONT2,    IDC_FANCY_SIZE2,    "Mangal");
    InitSelection(hDlg, IDC_FANCY_FONT3,    IDC_FANCY_SIZE3,    "Latha");
    InitSelection(hDlg, IDC_FANCY_FONT4,    IDC_FANCY_SIZE4,    "Tahoma");
*/

/*
    ChangeFont(hDlg, 1, IDC_FANCY_FONT1, IDC_FANCY_SIZE1, IDC_FANCY_BOLD1, IDC_FANCY_ITALIC1, IDC_FANCY_UNDERLINE1);
    ChangeFont(hDlg, 2, IDC_FANCY_FONT2, IDC_FANCY_SIZE2, IDC_FANCY_BOLD2, IDC_FANCY_ITALIC2, IDC_FANCY_UNDERLINE2);
    ChangeFont(hDlg, 3, IDC_FANCY_FONT3, IDC_FANCY_SIZE3, IDC_FANCY_BOLD3, IDC_FANCY_ITALIC3, IDC_FANCY_UNDERLINE3);
    ChangeFont(hDlg, 4, IDC_FANCY_FONT4, IDC_FANCY_SIZE4, IDC_FANCY_BOLD4, IDC_FANCY_ITALIC4, IDC_FANCY_UNDERLINE4);
*/
};







void InitDropList(
    HWND          hDlg,
    int           id,
    const char  **strings,
    int           stringCount
)
{
    INT i;
    for (i=0; i<stringCount; i++) {
        SendDlgItemMessageA(hDlg, id, CB_ADDSTRING, 0, (LPARAM)strings[i]);
    }
    SendDlgItemMessage(hDlg, id, CB_SETCURSEL, 0, 0);
}



INT_PTR CALLBACK GlyphSettingsDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:

            for (INT i=0; i < sizeof(szRows)/sizeof(szRows[0]); i++) {
                SendDlgItemMessage(hDlg, IDC_GLYPHROWS, CB_ADDSTRING, 0, (LPARAM)szRows[i]);
                SendDlgItemMessage(hDlg, IDC_GLYPHCOLUMNS, CB_ADDSTRING, 0, (LPARAM)szRows[i]);
            }
            SendDlgItemMessage(hDlg, IDC_GLYPHROWS,    CB_SETCURSEL, 4, 0);
            SendDlgItemMessage(hDlg, IDC_GLYPHCOLUMNS, CB_SETCURSEL, 4, 0);

            InitDropList(hDlg, IDC_GLYPHINDEX, szOffsets, sizeof(szOffsets)/sizeof(szOffsets[0]));

            fontTransform.init(GetDlgItem(hDlg, IDC_FONTTRANSFORM), &g_FontTransform);
            return FALSE;

        case WM_COMMAND:
            GlyphSettingsCommand(hDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            return FALSE;
    }

    return FALSE;
}




INT_PTR CALLBACK DriverSettingsDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:

            InitDropList(hDlg, IDC_DRIVERDX, szDriverDx, sizeof(szDriverDx)/sizeof(szDriverDx[0]));
            InitDropList(hDlg, IDC_DRIVERDY, szDriverDx, sizeof(szDriverDx)/sizeof(szDriverDx[0]));
            InitDropList(hDlg, IDC_DRIVERORIGINALPIXELS, szDriverPixels, sizeof(szDriverPixels)/sizeof(szDriverPixels[0]));

            SendDlgItemMessage(hDlg, IDC_DRIVERDX,              CB_SETCURSEL, 2, 0);
            SendDlgItemMessage(hDlg, IDC_DRIVERDY,              CB_SETCURSEL, 0, 0);
            SendDlgItemMessage(hDlg, IDC_DRIVERORIGINALPIXELS,  CB_SETCURSEL, 5, 0);

            driverTransform.init(GetDlgItem(hDlg, IDC_DRIVERTRANSFORM), &g_DriverTransform);

            SendDlgItemMessage(hDlg, IDC_DRIVERCMAP,            BM_SETCHECK, BST_CHECKED, 0);
            SendDlgItemMessage(hDlg, IDC_DRIVERREALIZEDADVANCE, BM_SETCHECK, BST_CHECKED, 0);
            return FALSE;

        case WM_COMMAND:
            DriverSettingsCommand(hDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            return FALSE;
    }

    return FALSE;
}




INT_PTR CALLBACK SettingsDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
        int i;


        switch (uMsg)
        {


        case WM_INITDIALOG:

            // Populate the Unicode codepoint combo box

            for (i=0; i<sizeof(szUniChar)/sizeof(szUniChar[0]); i++) {
                SendDlgItemMessageA(hDlg, IDC_CODEPOINT, CB_ADDSTRING, 0, (LPARAM)szUniChar[i]);
            }

/*
            for (i=0; i<sizeof(szLanguage)/sizeof(szLanguage[0]); i++) {
                SendDlgItemMessage(hDlg, IDC_LANGUAGE, CB_ADDSTRING, 0, (LPARAM)szLanguage[i]);
            }

            SendDlgItemMessage(hDlg, IDC_LANGUAGE, CB_SETCURSEL, 0, 0);
*/

            InitDropList(hDlg, IDC_ALIGNMENT, szAlignments, sizeof(szAlignments)/sizeof(szAlignments[0]));
            InitDropList(hDlg, IDC_FONTUNIT, szUnits, sizeof(szUnits)/sizeof(szUnits[0]));
            InitDropList(hDlg, IDC_FOREBRUSHTYPE, szForeGroundBrush, sizeof(szForeGroundBrush)/sizeof(szForeGroundBrush[0]));
            InitDropList(hDlg, IDC_BACKBRUSHTYPE, szBackGroundBrush, sizeof(szBackGroundBrush)/sizeof(szBackGroundBrush[0]));
            InitDropList(hDlg, IDC_TEXTMODE, szTextMode, sizeof(szTextMode)/sizeof(szTextMode[0]));

            InitDropList(hDlg, IDC_DIGIT_SUBSTITUTE, szDigitSubstitute, sizeof(szDigitSubstitute)/sizeof(szDigitSubstitute[0]));
            InitDropList(hDlg, IDC_LANGUAGE,         szLanguage, sizeof(szLanguage)/sizeof(szLanguage[0]));

            GetTextForeGroundBrush(0);
            GetTextBackGroundBrush(0);

            SendDlgItemMessage(hDlg, IDC_FONTUNIT, CB_SETCURSEL, 3, 0);

            //InitDropList(hDlg, IDC_RENDERER, szRenderers, sizeof(szRenderers)/sizeof(szRenderers[0]));

            InitFaceLists(hDlg);


            if (g_ShowFamilies)   SendDlgItemMessage(hDlg, IDC_SHOWFAMILIES,   BM_SETCHECK, BST_CHECKED, 0);
            if (g_ShowLogical)    SendDlgItemMessage(hDlg, IDC_LOGICAL,        BM_SETCHECK, BST_CHECKED, 0);
            if (g_ShowGlyphs)     SendDlgItemMessage(hDlg, IDC_SHOWGLYPHS,     BM_SETCHECK, BST_CHECKED, 0);
            if (g_ShowDrawString) SendDlgItemMessage(hDlg, IDC_SHOWDRAWSTRING, BM_SETCHECK, BST_CHECKED, 0);

            if (g_Bold)      SendDlgItemMessage(hDlg, IDC_PLAINTEXT_BOLD,      BM_SETCHECK, BST_CHECKED, 0);
            if (g_Italic)    SendDlgItemMessage(hDlg, IDC_PLAINTEXT_ITALIC,    BM_SETCHECK, BST_CHECKED, 0);
            if (g_Underline) SendDlgItemMessage(hDlg, IDC_PLAINTEXT_UNDERLINE, BM_SETCHECK, BST_CHECKED, 0);
            if (g_Strikeout) SendDlgItemMessage(hDlg, IDC_PLAINTEXT_STRIKEOUT, BM_SETCHECK, BST_CHECKED, 0);

            SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_SELECTSTRING, -1, (LPARAM)g_szFaceName);

            // Make sure the control shows the proper selection...
            SendDlgItemMessage(hDlg, IDC_TEXTMODE, CB_SETCURSEL, g_TextMode, 0);

/*
            SendDlgItemMessage(hDlg, IDC_LTR,       BM_SETSTATE, TRUE, 0);
            SendDlgItemMessage(hDlg, IDC_HORIZ,     BM_SETSTATE, TRUE, 0);

            SendDlgItemMessage(hDlg, IDC_LOGICAL,   BM_SETCHECK, BST_CHECKED, 0);
            SendDlgItemMessage(hDlg, IDC_PLAINTEXT, BM_SETCHECK, BST_CHECKED, 0);
            SendDlgItemMessage(hDlg, IDC_FORMATTED, BM_SETCHECK, BST_CHECKED, 0);

            SendDlgItemMessage(hDlg, IDC_LINEFILL,  BM_SETCHECK, BST_CHECKED, 0);

            SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FALLBACK, BM_SETCHECK, BST_CHECKED, 0);
*/

            SendDlgItemMessage(hDlg, IDC_FONTSIZE, TBM_SETRANGE, 0,    MAKELONG(1,MAXPOINTSIZE));
            SendDlgItemMessage(hDlg, IDC_FONTSIZE, TBM_SETPOS,   TRUE, g_iFontHeight);

            SendDlgItemMessage(hDlg, IDC_GAMMAVALUE, TBM_SETRANGE, 0,    MAKELONG(0,12));
            SendDlgItemMessage(hDlg, IDC_GAMMAVALUE, TBM_SETPOS,   TRUE, 4);


            worldTransform.init(GetDlgItem(hDlg, IDC_WORLDTRANSFORM), &g_WorldTransform);

            return FALSE;

        case WM_COMMAND:
            Command(hDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            return FALSE;

        case WM_NOTIFY:

            /*
                char str[200];
                wsprintf(str, "WM_NOTIFY (hDlg %x, IDC_FONTSIZE %x = wnd %x), hwnd %x, hwndFrom %x, idFrom %x, code %x.\n",
                    hDlg,
                    IDC_FONTSIZE,
                    GetDlgItem(hDlg, IDC_FONTSIZE),
                    wParam,
                    ((NMHDR*)lParam)->hwndFrom,
                    ((NMHDR*)lParam)->idFrom,
                    ((NMHDR*)lParam)->code
                );
                OutputDebugString(str);
            */

            if (    ((NMHDR*)lParam)->idFrom == IDC_GAMMAVALUE
                &&  ((NMHDR*)lParam)->code   == NM_CUSTOMDRAW)
            {
                // Update font size

                g_GammaValue = (UINT)SendDlgItemMessage(hDlg, IDC_GAMMAVALUE, TBM_GETPOS, 0, 0);

                InvalidateText();
            }

            if (    ((NMHDR*)lParam)->idFrom == IDC_FONTSIZE
                &&  ((NMHDR*)lParam)->code   == NM_CUSTOMDRAW)
            {
                // Update font size

                INT pos = (INT)SendDlgItemMessage(hDlg, IDC_FONTSIZE, TBM_GETPOS, 0, 0);

                char str[100];
                wsprintfA(str, "%d", pos);

                /*
                    OutputDebugString("Pos: ");
                    OutputDebugString(str);
                    OutputDebugString("\n");
                */

                SendDlgItemMessageA(hDlg, IDC_PLAINTEXT_SIZE, WM_SETTEXT, 0, (LPARAM)str);

                // Get facename

                UINT_PTR i = SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_GETCURSEL, 0, 0);
                TCHAR sFaceName[100];
                if (SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_GETLBTEXT, i, (LPARAM)sFaceName) == CB_ERR) {
                    return FALSE;
                }


                SetStyle(
                    0,
                    pos,
                    IsDlgButtonChecked(hDlg, IDC_PLAINTEXT_BOLD)      == BST_CHECKED ? 700 : 400,
                    IsDlgButtonChecked(hDlg, IDC_PLAINTEXT_ITALIC)    == BST_CHECKED,
                    IsDlgButtonChecked(hDlg, IDC_PLAINTEXT_UNDERLINE) == BST_CHECKED,
                    IsDlgButtonChecked(hDlg, IDC_PLAINTEXT_STRIKEOUT) == BST_CHECKED,
                    sFaceName
                );
                InvalidateText();
            }
            return FALSE;

        }



        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\style.cpp ===
////    Style - simple character styles for formatted text
//
//      Provides a simple style selection mechanism for demostrating
//      formatted text.


#include "precomp.hxx"
#include "global.h"
#include <tchar.h>






/*
void SetLogFont(
    PLOGFONTA   plf,
    int         iHeight,
    int         iWeight,
    int         iItalic,
    int         iUnderline,
    char       *pcFaceName) {

    memset(plf, 0, sizeof(LOGFONTA));
    plf->lfCharSet        = DEFAULT_CHARSET;
    plf->lfHeight         = iHeight;
    plf->lfWeight         = iWeight;
    plf->lfItalic         = (BYTE) iItalic;
    plf->lfUnderline      = (BYTE) iUnderline;
    lstrcpy(plf->lfFaceName, pcFaceName);
    plf->lfOutPrecision   = OUT_STROKE_PRECIS;
    plf->lfClipPrecision  = CLIP_STROKE_PRECIS;
    plf->lfQuality        = DRAFT_QUALITY;
    plf->lfPitchAndFamily = VARIABLE_PITCH;
    plf->lfEscapement     = 0;
    plf->lfOrientation    = 0;
}
*/





void FreeStyle(int iStyle) {

    /*
    if (g_style[iStyle].hf) {
        DeleteObject(g_style[iStyle].hf);
    }

    if (g_style[iStyle].sc) {
        ScriptFreeCache(&g_style[iStyle].sc);
    }
    */

}






void SetStyle(
    int     iStyle,
    int     iHeight,
    int     iWeight,
    int     iItalic,
    int     iUnderline,
    int     iStrikeout,
    TCHAR   *pcFaceName) {

    LOGFONTA lf;

    FreeStyle(iStyle);

    //SetLogFont(&lf, iHeight, iWeight, iItalic, iUnderline, pcFaceName);
    //g_style[iStyle].hf = CreateFontIndirect(&lf);
    //g_style[iStyle].sc = NULL;

    g_style[iStyle].emSize = REAL(iHeight);
    for (UINT i=0; i<_tcslen(pcFaceName); i++)
    {
        g_style[iStyle].faceName[i] = pcFaceName[i];
    }
    g_style[iStyle].faceName[_tcslen(pcFaceName)] = 0;
    g_style[iStyle].style =
            (iWeight >= 700 ? FontStyleBold      : 0)
        +   (iItalic        ? FontStyleItalic    : 0)
        +   (iUnderline     ? FontStyleUnderline : 0)
        +   (iStrikeout     ? FontStyleStrikeout : 0);
}






void InitStyles() {

    memset(g_style, 0, sizeof(g_style));
}






void FreeStyles() {
    int i;
    for (i=0; i<5; i++) {
        FreeStyle(i);
    }
}





////    StyleCheckRange - dir use in ASSERTs
//
//      Returns TRUE if style length matches text length


BOOL StyleCheckRange() {

    int     iFormatPos;
    RUN    *pFormatRider;

    // Check that style length is same as text length

    pFormatRider = g_pFirstFormatRun;
    iFormatPos = 0;
    while (pFormatRider != NULL) {

        iFormatPos += pFormatRider->iLen;
        pFormatRider = pFormatRider->pNext;
    }

    return iFormatPos == g_iTextLen;
}







/////   Style range manipulation
//
//      StyleDeleteRange
//      StyleExtendRange
//      StyleSetRange
//
//      The style list is a linked list of RUNs (see global.h) that
//      covers the entire text buffer.
//
//      Each run has a length, and a style number (an index to g_Style[])
//      (The analysis field in the run is not used by the style list.)
//
//      StyleDeleteRange and StyleExtendRange are called as part of text
//      insertion/deletion to maintain the style list.
//
//      StyleSetRange is called to change the style of the current selection
//      when the user clicks on one the of the numbered style buttons.






///     StyleDeleteRange - delete range of style information
//
//


void StyleDeleteRange(
    int     iDelPos,
    int     iDelLen) {


    int     iFormatPos;
    RUN    *pFormatRider;
    RUN    *pPrevRun;
    RUN    *pDelRun;            // Run to be deleted


    if (iDelLen <= 0) return;


    // Find first run affected by the deletion

    iFormatPos   = 0;
    pFormatRider = g_pFirstFormatRun;
    pPrevRun = NULL;
    while (iFormatPos + pFormatRider->iLen <= iDelPos) {
        iFormatPos  += pFormatRider->iLen;
        pPrevRun     = pFormatRider;
        pFormatRider = pFormatRider->pNext;
        ASSERT(pFormatRider);
    }



    // Delete from end of first run

    if (iDelPos + iDelLen  >  iFormatPos + pFormatRider->iLen) {

        // Delete all the way from iDelPos to the end of the first affected run

        iDelLen = iDelPos + iDelLen - (iFormatPos + pFormatRider->iLen);    // Amount that will remain to be deleted
        pFormatRider->iLen = iDelPos - iFormatPos;

    } else {

        // Deletion is entirely in the first affected run

        pFormatRider->iLen -= iDelLen;
        iDelLen = 0;
    }


    // First affected run now contains no range to be deleted
    // If it's empty, remove it, otherwise step over it

    if (pFormatRider->iLen == 0) {

        // Remove redundant run

        if (pFormatRider->pNext) {

            // Replace this run by the next one

            pDelRun       = pFormatRider->pNext;
            *pFormatRider = *pDelRun;                 // Copy content of next run over this one
            delete pDelRun;

        } else {

            // No runs following this one

            if (pPrevRun) {

                ASSERT(iDelLen == 0);
                delete pFormatRider;
                pPrevRun->pNext = NULL;

            } else {

                // No runs left at all

                ASSERT(iDelLen == 0);
                delete pFormatRider;
                g_pFirstFormatRun = NULL;
            }
        }

    } else {

        //  Current run now contains no text to be deleted, so advance to next run

        iFormatPos  += pFormatRider->iLen;
        pPrevRun     = pFormatRider;
        pFormatRider = pFormatRider->pNext;
    }


    // Delete from start of any remaining runs

    while (iDelLen > 0) {

        if (pFormatRider->iLen <= iDelLen) {

            // This entire run must go

            ASSERT(pFormatRider->pNext);
            iDelLen -= pFormatRider->iLen;
            pDelRun  = pFormatRider->pNext;
            *pFormatRider = *pDelRun;
            delete pDelRun;

        } else {

            // Last run is deleted in part only

            pFormatRider->iLen -= iDelLen;
            iDelLen = 0;
        }
    }


    // Check whether current run (which immediately follows deletion) can
    // now be collapsed into the previous run

    if (pPrevRun  &&  pFormatRider  &&  pPrevRun->iStyle == pFormatRider->iStyle) {

        pPrevRun->iLen += pFormatRider->iLen;
        pPrevRun->pNext = pFormatRider->pNext;
        delete pFormatRider;
    }
}






///     StyleExtendRange - Extend style immediately preceeding iPos by iLen characters
//
//


void StyleExtendRange(
    int     iExtPos,
    int     iExtLen) {

    int     iFormatPos;
    RUN    *pFormatRider;

    const SCRIPT_ANALYSIS nullAnalysis = {0};


    if (g_pFirstFormatRun == NULL) {

        // Starting from no text at all

        ASSERT(iExtPos == 0);

        g_pFirstFormatRun           = new RUN;
        g_pFirstFormatRun->iLen     = iExtLen;
        g_pFirstFormatRun->iStyle   = 1;
        g_pFirstFormatRun->pNext    = NULL;
        g_pFirstFormatRun->analysis = nullAnalysis;

    } else {

        // Find run containing character immediately prior to iExtPos

        iFormatPos = 0;
        pFormatRider = g_pFirstFormatRun;

        while (iFormatPos + pFormatRider->iLen < iExtPos) {
            iFormatPos += pFormatRider->iLen;
            pFormatRider = pFormatRider->pNext;
        }

        pFormatRider->iLen += iExtLen;

    }
}






////    StyleSetRange - Change style for a given range
//
//


void StyleSetRange(
    int    iSetStyle,
    int    iSetPos,
    int    iSetLen) {

    int     iFormatPos;
    RUN    *pFormatRider;
    RUN    *pNewRun;


    if (iSetLen <= 0) return;


    // Remove existing style for the range

    StyleDeleteRange(iSetPos, iSetLen);


    if (g_pFirstFormatRun == NULL) {

        // Replace style on entire text

        g_pFirstFormatRun = new RUN;
        g_pFirstFormatRun->pNext = NULL;
        g_pFirstFormatRun->iLen = iSetLen;
        g_pFirstFormatRun->iStyle = iSetStyle;

    } else {

        // Find first run affected by the change

        iFormatPos   = 0;
        pFormatRider = g_pFirstFormatRun;
        while (iFormatPos + pFormatRider->iLen < iSetPos) {
            iFormatPos  += pFormatRider->iLen;
            pFormatRider = pFormatRider->pNext;
            ASSERT(pFormatRider);
        }


        // New style starts after beginning of this run or at beginning of next run


        if (pFormatRider->iStyle == iSetStyle) {

            // Already the same style - just increase length

            pFormatRider->iLen += iSetLen;

        } else {

            if (iFormatPos + pFormatRider->iLen > iSetPos) {

                // New style is within this run
                // Split this run around the new run

                pNewRun = new RUN;          // Create second part of existing run
                *pNewRun = *pFormatRider;
                pNewRun->iLen      -= iSetPos - iFormatPos;
                pFormatRider->iLen  = iSetPos - iFormatPos;
                pFormatRider->pNext = pNewRun;

                pNewRun = new RUN;          // Create inserted run
                *pNewRun = *pFormatRider;
                pNewRun->iLen = iSetLen;
                pNewRun->iStyle = iSetStyle;
                pFormatRider->pNext = pNewRun;

            } else {

                // New style is between this run and the next run

                if (    pFormatRider->pNext
                    &&  pFormatRider->pNext->iStyle == iSetStyle) {

                    // New style is same as adjacent following run

                    pFormatRider->pNext->iLen += iSetLen;

                } else {

                    // Create new run between current run and next run

                    pNewRun = new RUN;
                    *pNewRun = *pFormatRider;
                    pNewRun->iStyle = iSetStyle;
                    pNewRun->iLen   = iSetLen;
                    pFormatRider->pNext = pNewRun;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\textwnd.cpp ===
////    TEXTWND.CPP
//
//              Maintains the text display panel



#include "precomp.hxx"
#include "global.h"
#include "winspool.h"
#include <Tchar.h>




////    InvalidateText - Force redisplay
//
//

void InvalidateText() {
    RECT rc;
    rc.left   = g_fPresentation ? 0 : g_iSettingsWidth;
    rc.top    = 0;
    rc.right  = 10000;
    rc.bottom = 10000;
    InvalidateRect(g_hTextWnd, &rc, TRUE);
}






////    Header - draw a simple header for each text section
//
//      Used to distinguish logical, plaintext and formatted text sections of
//      text window.
//
//      Advances SEPARATORHEIGHT drawing a horizontal line 2/5ths of the way
//      down, and displays a title below the line.
//
//      At the top of the page displays only the title.

void Header(HDC hdc, char* str, RECT *prc, int *piY) {

    HFONT hf;
    HFONT hfold;
    RECT  rcClear;

    int iLinePos;
    int iTextPos;
    int iFontEmHeight;
    int iHeight;

    int separatorHeight = (prc->bottom - prc->top) / 20;

    iFontEmHeight = separatorHeight*40/100;

    if (*piY <= prc->top)
    {
        // Prepare settings for title only, at top of window
        iLinePos = -1;
        iTextPos = 0;
        iHeight  = separatorHeight*60/100;

    }
    else
    {
        // Prepare settings for 40% white space, a line, 10% whitespace, text and 3% whitespace
        iLinePos = separatorHeight*30/100;
        iTextPos = separatorHeight*40/100;
        iHeight  = separatorHeight;
    }


    rcClear = *prc;
    rcClear.top = *piY;
    rcClear.bottom = *piY + iHeight;
    FillRect(hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));


    if (*piY > prc->top) {

        // Separate from previous output with double pixel line

        MoveToEx(hdc, prc->left,  *piY+iLinePos, NULL);
        LineTo  (hdc, prc->right, *piY+iLinePos);
        MoveToEx(hdc, prc->left,  *piY+iLinePos+1, NULL);
        LineTo  (hdc, prc->right, *piY+iLinePos+1);
    }


    hf = CreateFontA(-iFontEmHeight, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Tahoma");
    hfold = (HFONT) SelectObject(hdc, hf);
    ExtTextOutA(hdc, prc->left, *piY + iTextPos, 0, prc, str, strlen(str), NULL);

    *piY += iHeight;

    SelectObject(hdc, hfold);
    DeleteObject(hf);
}






////    ResetCaret - used during paint by each DSP*.CPP
//
//


void ResetCaret(int iX, int iY, int iHeight) {

    g_iCaretX = iX;
    g_iCaretY = iY;

    if (g_iCaretHeight != iHeight) {
        g_iCaretHeight = iHeight;
        HideCaret(g_hTextWnd);
        DestroyCaret();
        CreateCaret(g_hTextWnd, NULL, 0, g_iCaretHeight);
        SetCaretPos(g_iCaretX, g_iCaretY);
        ShowCaret(g_hTextWnd);
    } else {
        SetCaretPos(g_iCaretX, g_iCaretY);
    }
}



/////   PaintDC - display all selected tests, either on screen
//      or on printer.

void PaintDC(HDC hdc, BOOL presentation, RECT &rcText, INT &iY)
{
    int   iPos;
    int   iLineHeight;

    iY = rcText.top;

    if (presentation) {
        iLineHeight = rcText.bottom*9/20;
    } else {
        iLineHeight = 40;
    }


    if (g_ShowGDI) {
        if (!presentation) {
            Header(hdc, "GDI", &rcText, &iY);
        }
        PaintGDI(hdc, &iY, &rcText, iLineHeight);
    }

    if (g_ShowFamilies) {
        if (!presentation) {
            Header(hdc, "Font families", &rcText, &iY);
        }
        PaintFamilies(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowLogical) {
        if (!presentation) {
            Header(hdc, "Logical characters (ScriptGetCmap, ExtTextOut(ETO_GLYPHINDEX))", &rcText, &iY);
        }
        PaintLogical(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowGlyphs) {
        if (!presentation) {
            Header(hdc, "DrawGlyphs", &rcText, &iY);
        }
        PaintGlyphs(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowDrawString) {
        if (!presentation) {
            Header(hdc, "DrawString", &rcText, &iY);
        }
        PaintDrawString(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowDriver) {
        if (!presentation) {
            Header(hdc, "DrawDriverString", &rcText, &iY);
        }
        PaintDrawDriverString(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowPath) {
        if (!presentation) {
            Header(hdc, "Path", &rcText, &iY);
        }
        PaintPath(hdc, &iY, &rcText, iLineHeight);
    }

    if (g_ShowMetric) {
        if (!presentation) {
            Header(hdc, "Metrics", &rcText, &iY);
        }
        PaintMetrics(hdc, &iY, &rcText, iLineHeight);
    }

    if (g_ShowPerformance) {
        if (!presentation) {
            Header(hdc, "Performance", &rcText, &iY);
        }
        PaintPerformance(hdc, &iY, &rcText, iLineHeight);
    }

    if (g_ShowScaling) {
        if (!presentation) {
            Header(hdc, "Scaling", &rcText, &iY);
        }
        PaintScaling(hdc, &iY, &rcText, iLineHeight);
    }


/*
    if (g_fShowFancyText  &&  !presentation) {
        Header(hdc, "Formatted text (ScriptItemize, ScriptLayout, ScriptShape, ScriptPlace, ScriptTextOut)", &rcText, &iY);
        PaintFormattedText(hdc, &iY, &rcText, iLineHeight);
    }
*/

}





////    Paint - redraw part or all of client area
//
//


void PaintWindow(HWND hWnd) {

    PAINTSTRUCT  ps;
    HDC          hdc;
    RECT         rcText;
    RECT         rcClear;
    int          iY;

    hdc = BeginPaint(hWnd, &ps);

    // Remove the settings dialog from the repaint rectangle


    if (ps.fErase) {

        // Clear below the settings dialog

        if (!g_fPresentation) {

            rcClear = ps.rcPaint;
            if (rcClear.right > g_iSettingsWidth) {
                rcClear.right = g_iSettingsWidth;
            }
            if (rcClear.top < g_iSettingsHeight) {
                rcClear.top = g_iSettingsHeight;
            }

            FillRect(ps.hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));
        }
    }


    // Clear top and left margin

    GetClientRect(hWnd, &rcText);

    // Left margin

    rcClear = rcText;
    rcClear.left  = g_fPresentation ? 0 : g_iSettingsWidth;
    rcClear.right = rcClear.left + 10;
    FillRect(ps.hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));


    // Top margin

    rcClear = rcText;
    rcClear.left  = g_fPresentation ? 0 : g_iSettingsWidth;
    rcClear.top = 0;
    rcClear.bottom = 8;
    FillRect(ps.hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));

    rcText.left = g_fPresentation ? 10 : g_iSettingsWidth + 10;
    rcText.top  = 8;


    if (!g_Offscreen)
    {
        PaintDC(hdc, g_fPresentation, rcText, iY);
    }
    else
    {
        // Render everything to an offscreen buffer instead of
        // directly to the display surface...
        HBITMAP hbmpOffscreen = NULL;
        HDC hdcOffscreen = NULL;
        RECT rectOffscreen;

        rectOffscreen.left = 0;
        rectOffscreen.top = 0;
        rectOffscreen.right = rcText.right - rcText.left;
        rectOffscreen.bottom = rcText.bottom - rcText.top;

        hbmpOffscreen = CreateCompatibleBitmap(hdc, rectOffscreen.right, rectOffscreen.bottom);

        if (hbmpOffscreen)
        {
            hdcOffscreen = CreateCompatibleDC(hdc);

            if (hdcOffscreen)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcOffscreen, hbmpOffscreen);

                PaintDC(hdcOffscreen, g_fPresentation, rectOffscreen, iY);

                StretchBlt(
                    hdc,
                    rcText.left,
                    rcText.top,
                    rectOffscreen.right,
                    rectOffscreen.bottom,
                    hdcOffscreen,
                    0,
                    0,
                    rectOffscreen.right,
                    rectOffscreen.bottom,
                    SRCCOPY);

                SelectObject(hdcOffscreen, (HGDIOBJ)hbmpOld);

                DeleteDC(hdcOffscreen);
            }

            DeleteObject(hbmpOffscreen);
        }
    }

    // Clear any remaining space below the text

    if (    ps.fErase
        &&  iY < rcText.bottom) {

        rcClear = rcText;
        rcClear.top = iY;
        FillRect(ps.hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));
    }


    EndPaint(hWnd, &ps);
}



void PrintPage()
{
    PRINTDLG printDialog;

    memset(&printDialog, 0, sizeof(printDialog));

    printDialog.lStructSize = sizeof(printDialog);
    printDialog.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION ;

    if (PrintDlg(&printDialog))
    {
        HDC dc = printDialog.hDC;

        if (dc != NULL)
        {
            DOCINFO documentInfo;
            documentInfo.cbSize       = sizeof(documentInfo);
            documentInfo.lpszDocName  = _T("TextTest");
            documentInfo.lpszOutput   = NULL;
            documentInfo.lpszDatatype = NULL;
            documentInfo.fwType       = 0;

            if (StartDoc(dc, &documentInfo))
            {
                if (StartPage(dc) > 0)
                {
                    RECT rcText;
                    INT  iY;

                    rcText.left   = 0;
                    rcText.top    = 0;
                    rcText.right  = GetDeviceCaps(dc, HORZRES);
                    rcText.bottom = GetDeviceCaps(dc, VERTRES);

                    PaintDC(dc, FALSE, rcText, iY);
                    EndPage(dc);
                }

                EndDoc(dc);
            }

            DeleteDC(dc);
        }
    }
}




////    TextWndProc - Main window message handler and dispatcher
//
//


LRESULT CALLBACK TextWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

    HDC hdc;

    switch (message) {

        case WM_CREATE:
            hdc = GetDC(hWnd);
            g_iLogPixelsY = GetDeviceCaps(hdc, LOGPIXELSY);
            ReleaseDC(hWnd, hdc);
            break;


        case WM_ERASEBKGND:
            return 0;       // Leave Paint to erase the background


        case WM_CHAR:

            if (!g_bUnicodeWnd) {

                // Convert ANSI keyboard data to Unicode

                int   iCP;

                switch (PRIMARYLANGID(LOWORD(GetKeyboardLayout(NULL)))) {
                    case LANG_ARABIC:   iCP = 1256;   break;
                    case LANG_HEBREW:   iCP = 1255;   break;
                    case LANG_THAI:     iCP =  874;   break;
                    default:            iCP = 1252;   break;
                }

                MultiByteToWideChar(iCP, 0, (char*)&wParam, 1, (WCHAR*)&wParam, 1);
            }

            if (LOWORD(wParam) == 0x1B) {

                // Exit presentation mode

                g_fPresentation = FALSE;
                ShowWindow(g_hSettingsDlg, SW_SHOW);
                UpdateWindow(g_hSettingsDlg);
                InvalidateText();

            } else {

                EditChar(LOWORD(wParam));
            }

            break;


        case WM_KEYDOWN:
            EditKeyDown(LOWORD(wParam));
            break;


        case WM_KEYUP:

            if (wParam != VK_ESCAPE) {
                goto DefaultWindowProcedure;
            }
            // Eat all escape key processing
            break;


        case WM_LBUTTONDOWN:
            g_iMouseDownX = LOWORD(lParam);  // horizontal position of cursor
            g_iMouseDownY = HIWORD(lParam);  // vertical position of cursor
            g_fMouseDown  = TRUE;
            SetFocus(hWnd);
            break;

        case WM_MOUSEMOVE:
            // Treat movement like lbuttonup while lbutton is down,
            // so the selection tracks the cursor movement.
            if (wParam & MK_LBUTTON) {
                g_iMouseUpX = LOWORD(lParam);  // horizontal position of cursor
                g_iMouseUpY = HIWORD(lParam);  // vertical position of cursor
                g_fMouseUp = TRUE;
                InvalidateText();
                SetActiveWindow(hWnd);
            }
            break;


        case WM_LBUTTONUP:
            g_iMouseUpX = LOWORD(lParam);  // horizontal position of cursor
            g_iMouseUpY = HIWORD(lParam);  // vertical position of cursor
            g_fMouseUp = TRUE;
            InvalidateText();
            SetActiveWindow(hWnd);
            break;


        case WM_SETFOCUS:
            CreateCaret(hWnd, NULL, 0, g_iCaretHeight);
            SetCaretPos(g_iCaretX, g_iCaretY);
            ShowCaret(hWnd);
            break;


        case WM_KILLFOCUS:
            DestroyCaret();
            break;


        case WM_GETMINMAXINFO:

            // Don't let text window size drop too low

            ((LPMINMAXINFO)lParam)->ptMinTrackSize.x = g_fPresentation ? 10 : g_iMinWidth;
            ((LPMINMAXINFO)lParam)->ptMinTrackSize.y = g_fPresentation ? 10 : g_iMinHeight;
            return 0;


        case WM_PAINT:
            PaintWindow(hWnd);
            break;

        case WM_DESTROY:
            if (g_textBrush)
                delete g_textBrush;

            if (g_textBackBrush)
                delete g_textBackBrush;

            DestroyWindow(g_hSettingsDlg);
            PostQuitMessage(0);
            return 0;

        default:
        DefaultWindowProcedure:
            if (g_bUnicodeWnd) {
                return DefWindowProcW(hWnd, message, wParam, lParam);
            } else {
                return DefWindowProcA(hWnd, message, wParam, lParam);
            }
    }

    return 0;
}






////    CreateTextWindow - create window class and window
//
//      Attempts to use a Unicode window, if this fails uses an ANSI
//      window.
//
//      For example the Unicode window will succeed on Windows NT and
//      Windows CE, but fail on Windows 9x.


HWND CreateTextWindow() {

    WNDCLASSA  wcA;
    WNDCLASSW  wcW;
    HWND       hWnd;

    // Try registering as a Unicode window

    wcW.style         = CS_HREDRAW | CS_VREDRAW;
    wcW.lpfnWndProc   = TextWndProc;
    wcW.cbClsExtra    = 0;
    wcW.cbWndExtra    = 0;
    wcW.hInstance     = g_hInstance;
    wcW.hIcon         = LoadIconW(g_hInstance, APPNAMEW);
    wcW.hCursor       = LoadCursorW(NULL, (WCHAR*)IDC_ARROW);
    wcW.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wcW.lpszMenuName  = APPNAMEW;
    wcW.lpszClassName = APPNAMEW;

    if (RegisterClassW(&wcW)) {

        // Use a Unicode window

        g_bUnicodeWnd = TRUE;

        hWnd  = CreateWindowW(
            APPNAMEW, APPTITLEW,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0,
            NULL, NULL,
            g_hInstance,
            NULL);


        return hWnd;

    } else {

        // Must use an ANSI window.

        wcA.style         = CS_HREDRAW | CS_VREDRAW;
        wcA.lpfnWndProc   = TextWndProc;
        wcA.cbClsExtra    = 0;
        wcA.cbWndExtra    = 0;
        wcA.hInstance     = g_hInstance;
        wcA.hIcon         = LoadIconA(g_hInstance, APPNAMEA);
        wcA.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wcA.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcA.lpszMenuName  = APPNAMEA;
        wcA.lpszClassName = APPNAMEA;

        if (!RegisterClassA(&wcA)) {
            return NULL;
        }

        g_bUnicodeWnd = FALSE;

        hWnd  = CreateWindowA(
            APPNAMEA, APPTITLEA,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0,
            NULL, NULL,
            g_hInstance,
            NULL);
    };


    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\text.cpp ===
////    TEXTREP - Text representation
//
//      For this demonstration, text representation is rather simple


#include "precomp.hxx"
#include "global.h"

#include <tchar.h>




////    InitText - Initialise text buffer
//
//

void InitText(INT id) {

    HMODULE    hmod;
    HRSRC      hrsrc;
    HGLOBAL    hglob;
    WCHAR     *pwcIt;  // Initial text
    int        i;


    g_iTextLen = 0;

    hmod       = GetModuleHandle(NULL);
    hrsrc      = FindResource(hmod, MAKEINTRESOURCE(id), _TEXT("INITIALTEXT"));
    hglob      = LoadResource(hmod, hrsrc);
    g_iTextLen = SizeofResource(hmod, hrsrc) - 2;  // Remove leading byte order mark
    pwcIt      = (WCHAR*) LockResource(hglob);

    if (!hmod  ||  !hrsrc  ||  !hglob  ||  !pwcIt  ||  !g_iTextLen) {
        ASSERTS(hmod,    "GetModuleHandle(usptest.exe) failed");
        ASSERTS(hrsrc,   "FindResource(110, INITIALTEXT) failed");
        ASSERTS(hglob,   "LoadResource(110, INITIALTEXT) failed");
        ASSERTS(pwcIt,   "LockResource(110, INITIALTEXT) failed");
        ASSERTS(g_iTextLen, "INITIALTEXT length zero");

        g_iTextLen = 0;
    }

    if (g_iTextLen >= sizeof(g_wcBuf)) {
        g_iTextLen = sizeof(g_wcBuf);
    }

    memcpy(g_wcBuf, pwcIt+1, g_iTextLen);
    g_iTextLen >>= 1;  // Bytes to characters

    // Drop any zero padding

    i = 0;
    while (    (i < g_iTextLen)
           &&  g_wcBuf[i]) {
        i++;
    }
    g_iTextLen = i;


    // Construct initial formatting style run covering the entire text

    StyleExtendRange(0, g_iTextLen);
    ASSERT(StyleCheckRange());
}






////    textDelete - Delete text from buffer
//


BOOL TextDelete(int iPos, int iLen) {

    if (   iPos < 0
        || iLen < 0
        || iPos +iLen > g_iTextLen) {
        return FALSE;
    }


    if (iPos + iLen >= g_iTextLen) {
        g_iTextLen = iPos;
        StyleDeleteRange(iPos, iLen);
        ASSERT(StyleCheckRange());
        return TRUE;
    }


    if (iLen == 0) {
        return TRUE;
    }



    memcpy(g_wcBuf + iPos, g_wcBuf + iPos + iLen, sizeof(WCHAR) * (g_iTextLen - (iPos + iLen)));
    g_iTextLen -= iLen;


    StyleDeleteRange(iPos, iLen);
    ASSERT(StyleCheckRange());

    return TRUE;
}






////    textInsert - Insert new characters in the buffer at the given insertion point
//


BOOL TextInsert(int iPos, PWCH pwc, int iLen) {

    if (   iPos < 0
        || iLen < 0
        || iPos + iLen >= MAX_TEXT
        || iPos > g_iTextLen) {
        return FALSE;
    }


    // Shift text above iPos up the buffer

    if (iPos < g_iTextLen) {
        memmove(g_wcBuf+iPos+iLen, g_wcBuf+iPos, sizeof(WCHAR)*(g_iTextLen-iPos));
    }


    // Copy new text into buffer

    memcpy(g_wcBuf+iPos, pwc, sizeof(WCHAR)*iLen);
    g_iTextLen += iLen;


    // Give the new characters the same style as the original character they follow

    StyleExtendRange(iPos, iLen);
    ASSERT(StyleCheckRange());


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\warpdemo\resource.h ===
#define IDM_MAINMENU            1000
#define     IDC_TOGGLEMESH      1001
#define     IDC_RESETMESH       1002
#define     IDC_SHRINKTOFIT     1003
#define     IDC_DENSEMESH       1004
#define     IDC_SPARSEMESH      1005
#define     IDC_LIVEFEEDBACK    1006
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\texttest\texttest.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1998  Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:    CSSAMP
//
// PURPOSE:    Demonstrate and test Uniscribe APIs
//
// PLATFORMS:  Windows 95, 98, NT 4, NT 5.
//


#include "precomp.hxx"

#define GLOBALS_HERE 1
#include "global.h"

#include "..\gpinit.inc"

//#define ICECAP 1 // Since this isn't defined for some reason automatically

#ifdef ICECAP
#include "icecap.h"
#endif // ICECAP


/* Testing

Font* ConstructFontWithCellHeight(
    const WCHAR *familyName,
    INT          style,
    REAL         cellHeight,   // From positive LOGFONT.lfHeight
    Unit         unit
)
{
    // Get the family details so we can do height arithmetic

    const FontFamily family(familyName);
    if (!family.IsStyleAvailable(style))
    {
        return NULL;
    }


    // Convert cell height to em height

    REAL emSize =     cellHeight * family.GetEmHeight(style)
                  /   (   family.GetCellAscent(style)
                       +  family.GetCellDescent(style));

    return new Font(&family, emSize, style, unit);
}



*/



// Check to see if a given pathname contains a path or not...
BOOL HasPath(char *szPathName)
{
    BOOL fResult = false;

    ASSERT(szPathName);

    if (!szPathName)
        return fResult;

    char *p = szPathName;

    while(*p)
    {
        if (*p == '\\')
        {
                // We found a backslash - we have a path
                fResult = true;
                break;
        }
        p++;
    }

    return fResult;
}

// Strip any filename (and final backslash) from a pathname
void StripFilename(char *szPathName)
{
    ASSERT(szPathName);

    if (szPathName)
    {
        char *p = szPathName + (strlen(szPathName)-1);
    
        while(p > szPathName)
        {
            if (*p == '\\')
            {
                    // Terminate the string at the first backslash.
                    *p = 0;
                    break;
            }
            p--;
        }
    }
}



////    Initialise
//


void Initialise()
{
    INITCOMMONCONTROLSEX icce;
    icce.dwSize = sizeof(icce);
    icce.dwICC  = ICC_BAR_CLASSES;

    InitCommonControlsEx(&icce);
    InitStyles();
    InitText(ID_INITIAL_TEXT);

    g_familyCount = g_InstalledFontCollection.GetFamilyCount();
    g_families    = new FontFamily[g_familyCount];
    g_InstalledFontCollection.GetFamilies(g_familyCount, g_families, &g_familyCount);

    // Default values...
    g_szSourceTextFile[0] = 0;
    g_szProfileName[0] = 0;

    // Generate the application base directory...
    GetModuleFileNameA(g_hInstance, g_szAppDir, sizeof(g_szAppDir));
    StripFilename(g_szAppDir);
}


// Parse the command line...
void ParseCommandLine(char *szCmdLine)
{
    char *p = szCmdLine;

    // Look for a -p...
    while(*p)
    {
        switch (*p)
        {
            case '-' :
            case '/' :
            {
                // we have a command, so figure out what it is...
                p++; // next char indicate which command...

                switch(*p)
                {
                    case 'p' :
                    case 'P' :
                    {
                        char szProfileName[MAX_PATH];
                        int i = 0;

                        // Profile filename follows immediately (no spaces)
                        p++; // skip the 'p'

                        while(*p && *p != '\b')
                        {
                            szProfileName[i] = *p;
                            i++;
                            p++;
                        }

                        // Terminate the string...
                        szProfileName[i] = 0;

                        if (strlen(szProfileName) > 0)
                        {
                               if (!HasPath(szProfileName))
                               {
                                   // Look for the profile file in the application directory
                                   wsprintfA(g_szProfileName, "%s\\%s", g_szAppDir, szProfileName);
                               }
                               else
                               {
                                   // Otherwise it already contains a path
                                   strcpy(g_szProfileName, szProfileName);
                               }
                        }
                    }
                    break;
                }
            }
            break;

            default :
            break;
        }

        p++;
    }
}


////    WinMain - Application entry point and dispatch loop
//
//


int APIENTRY WinMain(
    HINSTANCE   hInst,
    HINSTANCE   hPrevInstance,
    char       *pCmdLine,
    int         nCmdShow) {

    MSG         msg;
    HACCEL      hAccelTable;
    RECT        rc;
    RECT        rcMain;
    int iNumRenders = 1;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    g_hInstance = hInst;  // Global hInstance

#ifdef ICECAP
    // Mark the profile...
    StopProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif // ICECAP

    Initialise();

    // Parse the command line...
    ParseCommandLine(pCmdLine);

    // Read the global settings from the profile...
    ReadProfileInfo(g_szProfileName);

    // Over-ride number of renders on initial display...
    iNumRenders = g_iNumRenders;
    g_iNumRenders = 1;

    // It is possible that we want to use a file for the default text, so try to load it
    if (lstrlenA(g_szSourceTextFile) > 0)
    {
        char szFullPathText[MAX_PATH];

        if (!HasPath(g_szSourceTextFile))
        {
            // Look for the source text file in the application directory
            wsprintfA(szFullPathText, "%s\\%s", g_szAppDir, g_szSourceTextFile);
        }
        else
        {
            // Otherwise it contains a path already
            strcpy(szFullPathText, g_szSourceTextFile);
        }

        // This will replace the initial text with the text from the file
        InsertText(NULL, szFullPathText);
    }
     
    // Create main text window

    g_hTextWnd = CreateTextWindow();


    // Add dialog boxes on leading side

    g_hSettingsDlg = CreateDialogA(
        g_hInstance,
        "Settings",
        g_hTextWnd,
        SettingsDlgProc);


    g_hGlyphSettingsDlg = CreateDialogA(
        g_hInstance,
        "GlyphSettings",
        g_hTextWnd,
        GlyphSettingsDlgProc);


    g_hDriverSettingsDlg = CreateDialogA(
        g_hInstance,
        "DriverSettings",
        g_hTextWnd,
        DriverSettingsDlgProc);


    // Establish positon of text surface relative to the dialog

    GetWindowRect(g_hSettingsDlg, &rc);

    g_iSettingsWidth = rc.right - rc.left;
    g_iSettingsHeight = rc.bottom - rc.top;

    // Establish offset from main window to settings dialog

    GetWindowRect(g_hTextWnd, &rcMain);
    g_iMinWidth = rc.right - rcMain.left;
    g_iMinHeight = rc.bottom - rcMain.top;



    // Size main window to include dialog and text surface

    SetWindowPos(
        g_hTextWnd,
        NULL,
        0,0,
        g_iMinWidth * 29 / 10, g_iMinHeight,
        SWP_NOZORDER | SWP_NOMOVE);

    // Position the sub dialogs below the main dialog

    SetWindowPos(
        g_hGlyphSettingsDlg,
        NULL,
        0, rc.bottom-rc.top,
        0,0,
        SWP_NOZORDER | SWP_NOSIZE);

    SetWindowPos(
        g_hDriverSettingsDlg,
        NULL,
        0, rc.bottom-rc.top,
        0,0,
        SWP_NOZORDER | SWP_NOSIZE);

    if (g_FontOverride)
    {
        // Update the styles with the values read from the profile...
        for(int iStyle=0;iStyle<5;iStyle++)
        {
            SetStyle(
                iStyle,
                g_iFontHeight,
                g_Bold ? 700 : 300,
                g_Italic ? 1 : 0,
                g_Underline ? 1 : 0,
                g_Strikeout ? 1 : 0,
                g_szFaceName);
        }
    }

    if (g_AutoDrive)
    {
        int iFont = 0;
        int iHeight = 0;
        int cFonts = 1;
        int cHeights = 1;
        int iIteration = 0;
        int iRepeatPaint = 0;
        int iStyle = 0;

        g_fPresentation = true;

        // Move the settings window out of the way...
        ShowWindow(g_hTextWnd, SW_SHOWNORMAL);
        SetWindowPos(g_hSettingsDlg, HWND_BOTTOM, -g_iSettingsWidth, 0, g_iSettingsWidth, g_iSettingsHeight, SWP_NOREDRAW);
        UpdateWindow(g_hSettingsDlg);

        // Initial Paint to setup font cache...
        InvalidateText();
        UpdateWindow(g_hTextWnd);

        // Reset the render multiplier...
        g_iNumRenders = iNumRenders;

#ifdef ICECAP
        // Start the profiling...
        StartProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif // ICECAP

        if (g_AutoFont)
            cFonts = g_iAutoFonts;

        if (g_AutoHeight)
            cHeights = g_iAutoHeights;

        for(iIteration = 0;iIteration < g_iNumIterations; iIteration++)
        {
            for(iFont=0;iFont<cFonts;iFont++)
            {
                for(iHeight=0;iHeight<cHeights;iHeight++)
                {
                    TCHAR szFaceName[MAX_PATH];
                    int iFontHeight = g_iFontHeight;
    
                    if (g_AutoFont)
                    {
                        lstrcpy(szFaceName, g_rgszAutoFontFacenames[iFont]);
                    }
                    else
                    {
                        lstrcpy(szFaceName, g_szFaceName);
                    }
    
                    if (g_AutoHeight)
                        iFontHeight = g_rgiAutoHeights[iHeight];
    
                    // Update the styles with the values read from the profile...
                    for(int iStyle=0;iStyle<5;iStyle++)
                    {
                        SetStyle(
                            iStyle,
                            iFontHeight,
                            g_Bold ? 700 : 300,
                            g_Italic ? 1 : 0,
                            g_Underline ? 1 : 0,
                            g_Strikeout ? 1 : 0,
                            szFaceName);
                    }

                    for(int iPaint=0;iPaint<g_iNumRepaints;iPaint++)
                    {
                        // Force a re-display of the entire text window...
                        InvalidateText();
                        UpdateWindow(g_hTextWnd);
                    }
                }
            }
        }

#ifdef ICECAP
        // Stop the profiling...
        StopProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif // ICECAP

        // Trigger application exit
        PostMessage(g_hTextWnd, WM_DESTROY, (WPARAM)0, (LPARAM)0);
    }
    else
    {
        ShowWindow(g_hTextWnd, SW_SHOWNORMAL);

        InvalidateText();
        UpdateWindow(g_hTextWnd);
    }


    // Main message loop

    if (g_bUnicodeWnd) {

        hAccelTable = LoadAcceleratorsW(g_hInstance, APPNAMEW);

        while (GetMessageW(&msg, (HWND) NULL, 0, 0) > 0) {

            if (    !IsDialogMessageW(g_hSettingsDlg, &msg)
                &&  !IsDialogMessageW(g_hGlyphSettingsDlg, &msg)
                &&  !TranslateAcceleratorW(g_hTextWnd, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
        }

    } else {

        hAccelTable = LoadAcceleratorsA(g_hInstance, APPNAMEA);

        while (GetMessageA(&msg, (HWND) NULL, 0, 0) > 0) {

            if (    !IsDialogMessageA(g_hSettingsDlg, &msg)
                &&  !IsDialogMessageA(g_hGlyphSettingsDlg, &msg)
                &&  !TranslateAcceleratorA(g_hTextWnd, hAccelTable, &msg)
                )
            {
                TranslateMessage(&msg);
                DispatchMessageA(&msg);
            }
        }
    }


    FreeStyles();

    delete [] g_families;

    return (int)msg.wParam;

    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(pCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\warpdemo\mesh.cxx ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   mesh.cxx
*
* Abstract:
*
*   Implementation of spline meshes
*
* Revision History:
*
*   01/18/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hxx"


//
// Mesh constructor
//

Mesh::Mesh(
    INT gridRows,
    INT gridCols
    )

{
    this->gridRows = gridRows;
    this->gridCols = gridCols;
    ptTemp = NULL;
    ptxTemp1 = ptxTemp2 = NULL;
    dstSize.cx = dstSize.cy = 2;

    mesh = new PointX[gridRows*gridCols];

    if (mesh == NULL)
        Error("Couldn't allocate memory to hold mesh grids\n");

    initMesh();
}

//
// Mesh destructor
//

Mesh::~Mesh()
{
    delete[] mesh;
    delete[] ptTemp;
    delete[] ptxTemp1;
    delete[] ptxTemp2;
}


//
// Initialize mesh configuration
//

VOID
Mesh::initMesh()
{
    PointX* p = mesh;
    double sx = 1.0 / (gridCols-1);
    double sy = 1.0 / (gridRows-1);

    for (INT row=0; row < gridRows; row++)
    {
        double y = row * sy;

        for (INT col=0; col < gridCols; col++)
        {
            p->x = col * sx;
            p->y = y;
            p++;
        }
    }
}


//
// Allocate temporary memory to hold 
//

VOID
Mesh::allocTempPoints()
{
    // Check to see if we have already allocated
    // temporary memory for holding spline and bezier points

    if (ptTemp)
        return;

    INT count = max(gridRows, gridCols);

    ptxTemp1 = new PointX[count];
    ptxTemp2 = new PointX[3*count+1];
    ptTemp = new POINT[3*count+1];

    if (!ptxTemp1 || !ptxTemp2 || !ptTemp)
        Error("Out of memory\n");
}


//
// Convert a spline curve to Bezier segments
//

VOID
Mesh::spline2Bezier(
    const PointX* srcPts,
    PointX* dstPts,
    INT count
    )

{
    const PointX* p;
    PointX tempPts[4];

    // We use the default tension of 0.5

    double a3 = 0.5 / 3;

    *dstPts = *srcPts;

    for (INT i=0; i < count; i++)
    {
        if (i > 1 && i < count-1)
            p = srcPts + (i-1);
        else
        {
            tempPts[0] = srcPts[(i > 0) ? (i-1) : 0];
            tempPts[1] = srcPts[i];
            tempPts[2] = srcPts[(i+1 < count) ? (i+1) : count];
            tempPts[3] = srcPts[(i+2 < count) ? (i+2) : count];
            p = tempPts;
        }

        dstPts[1].x = -a3*p[0].x + p[1].x + a3*p[2].x;
        dstPts[1].y = -a3*p[0].y + p[1].y + a3*p[2].y;
        dstPts[2].x =  a3*p[1].x + p[2].x - a3*p[3].x;
        dstPts[2].y =  a3*p[1].y + p[2].y - a3*p[3].y;
        dstPts[3] = p[2];

        dstPts += 3;
    }
}


//
// Return the beizer control points corresponding to
// the specified row of the mesh.
//

PointX*
Mesh::getMeshRowBeziers(
    INT row,
    INT* pointCount,
    double sx,
    double sy
    )
{
    allocTempPoints();

    PointX* ptx = mesh + indexOf(row);

    for (INT i=0; i < gridCols; i++)
    {
        ptxTemp1[i].x = ptx[i].x * sx;
        ptxTemp1[i].y = ptx[i].y * sy;
    }

    INT segments = gridCols-1;
    spline2Bezier(ptxTemp1, ptxTemp2, segments);

    *pointCount = 3*segments + 1;
    return ptxTemp2;
}

POINT*
Mesh::getMeshRowBeziers(
    INT row,
    INT* pointCount
    )
{
    PointX* ptx;

    ptx = getMeshRowBeziers(row, pointCount, dstSize.cx - 1, dstSize.cy - 1);
    PointX::convertToPOINT(ptx, ptTemp, *pointCount);
    return ptTemp;
}


//
// Return the beizer control points corresponding to
// the specified column of the mesh.
//

PointX*
Mesh::getMeshColumnBeziers(
    INT col,
    INT* pointCount,
    double sx,
    double sy
    )
{
    allocTempPoints();

    INT i, j;

    for (i=0, j=col; i < gridRows; i++, j+=gridCols)
    {
        ptxTemp1[i].x = mesh[j].x * sx;
        ptxTemp1[i].y = mesh[j].y * sy;
    }

    INT segments = gridRows-1;
    spline2Bezier(ptxTemp1, ptxTemp2, segments);

    *pointCount = 3*segments + 1;
    return ptxTemp2;
}

POINT*
Mesh::getMeshColumnBeziers(
    INT col,
    INT* pointCount
    )
{
    PointX* ptx;

    ptx = getMeshColumnBeziers(col, pointCount, dstSize.cx - 1, dstSize.cy - 1);
    PointX::convertToPOINT(ptxTemp2, ptTemp, *pointCount);
    return ptTemp;
}


//
// Return the mesh control points for the specified row
//

POINT*
Mesh::getMeshRowPoints(
    INT row,
    INT* pointCount
    )
{
    allocTempPoints();

    POINT* pt = ptTemp;
    PointX* ptx = mesh + indexOf(row);

    double sx = dstSize.cx - 1;
    double sy = dstSize.cy - 1;

    for (INT j=0; j < gridCols; j++)
    {
        pt[j].x = ROUND2INT(ptx[j].x * sx);
        pt[j].y = ROUND2INT(ptx[j].y * sy);
    }

    return pt;
}


//
// Return the specified mesh control point (given row & column)
//

VOID
Mesh::getMeshPoint(
    INT row,
    INT col,
    POINT* point
    )
{
    INT index = indexOf(row, col);

    point->x = ROUND2INT(mesh[index].x * (dstSize.cx - 1));
    point->y = ROUND2INT(mesh[index].y * (dstSize.cy - 1));
}


//
// Set a mesh control point to the specified values
//

BOOL
Mesh::setMeshPoint(
    INT row,
    INT col,
    INT x,
    INT y
    )
{
    // special case for mesh control points along the border

    if ((row == 0 && y != 0) ||
        (row == gridRows-1 && y != dstSize.cy-1) ||
        (col == 0 && x != 0) ||
        (col == gridCols-1 && x != dstSize.cx-1))
    {
        return FALSE;
    }

    double tx, ty;

    tx = (double) x / (dstSize.cx - 1);
    ty = (double) y / (dstSize.cy - 1);

    // quick test to ensure the mesh control point
    // is well-ordered relative to its four neighbors

    if (col > 0 && tx <= mesh[indexOf(row, col-1)].x ||
        col < gridCols-1 && tx >= mesh[indexOf(row, col+1)].x ||
        row > 0 && ty <= mesh[indexOf(row-1, col)].y ||
        row < gridRows-1 && ty >= mesh[indexOf(row+1, col)].y)
    {
        return FALSE;
    }

    INT index = indexOf(row, col);
    PointX ptx = mesh[index];

    mesh[index].x = tx;
    mesh[index].y = ty;

    // verify the mesh row and mesh column is single-valued

    if (verifyRow(row) && verifyColumn(col))
        return TRUE;

    // if not, reject the mesh control point

    mesh[index] = ptx;
    return FALSE;
}


//
// Verify that the specified mesh row is well-ordered
//

BOOL
Mesh::verifyRow(INT row)
{
    INT count;
    PointX* points = getMeshRowBeziers(row, &count, dstSize.cx, dstSize.cy);

    while (count > 3)
    {
        if (!verifyBezierX(points))
            return FALSE;

        points += 3;
        count -= 3;
    }

    return TRUE;
}

//
// Verify that the specified mesh column is well-ordered
//

BOOL
Mesh::verifyColumn(INT col)
{
    INT count;
    PointX* points = getMeshColumnBeziers(col, &count, dstSize.cx, dstSize.cy);

    while (count > 3)
    {
        if (!verifyBezierY(points))
            return FALSE;

        points += 3;
        count -= 3;
    }

    return TRUE;
}


//
// Check if a Bezier segment is well-ordered in the x-direction
//

BOOL
Mesh::verifyBezierX(
    PointX* pts
    )
{
    double a, b, c, d;

    // get the quadratic equation for x'(t)

    a = 3.0 * (3*pts[1].x + pts[3].x - pts[0].x - 3*pts[2].x);
    b = 6.0 * (pts[0].x - 2*pts[1].x + pts[2].x);
    c = 3.0 * (pts[1].x - pts[0].x);

    // solve t for x'(t) = 0

    d = b*b - 4*a*c;

    if (d <= 0 || a == 0)
        return TRUE;

    // if both solution are between 0 <= t <= 1
    // then the Bezier curve is not well-ordered in x-direction

    double t1, t2;

    d = sqrt(d);
    a = 0.5 / a;

    t1 =  (d - b) * a;
    t2 = -(d + b) * a;
    
    return t1 < 0 || t1 > 1 ||
           t2 < 0 || t2 > 1;
}


//
// Check if a Bezier segment is well-ordered in the y-direction
//

BOOL
Mesh::verifyBezierY(
    PointX* pts
    )
{
    double a, b, c, d;

    // get the quadratic equation for y'(t)

    a = 3.0 * (3*pts[1].y + pts[3].y - pts[0].y - 3*pts[2].y);
    b = 6.0 * (pts[0].y - 2*pts[1].y + pts[2].y);
    c = 3.0 * (pts[1].y - pts[0].y);

    // solve t for y'(t) = 0

    d = b*b - 4*a*c;

    if (d <= 0 || a == 0)
        return TRUE;

    // if both solution are between 0 <= t <= 1
    // then the Bezier curve is not well-ordered in y-direction

    double t1, t2;

    d = sqrt(d);
    a = 0.5 / a;

    t1 =  (d - b) * a;
    t2 = -(d + b) * a;
    
    return t1 < 0 || t1 > 1 ||
           t2 < 0 || t2 > 1;
}


//
// Return a new MeshIterator object so that we can
// step along the y-direction and get the scale factors
// for each scanline.
//

MeshIterator*
Mesh::getYIterator(
    INT srcWidth,
    INT dstWidth,
    INT ySteps
    )
{
    MeshIterator* iterator;
    
    iterator  = new MeshIterator(srcWidth, dstWidth, ySteps, gridCols);

    if (iterator == NULL)
        Error("Out of memory\n");

    PointX* ptx;
    INT count;

    for (INT col=0; col < gridCols; col++)
    {
        ptx = getMeshColumnBeziers(col, &count, dstWidth-1, ySteps-1);

        // swap x and y coordinates

        for (INT i=0; i < count; i++)
        {
            double t = ptx[i].x;
            ptx[i].x = ptx[i].y;
            ptx[i].y = t;
        }

        iterator->addCurve(ptx, count);
    }

    return iterator;
}


//
// Return a new MeshIterator object so that we can
// step along the y-direction and get the scale factors
// for each vertical column of pixels.
//

MeshIterator*
Mesh::getXIterator(
    INT srcHeight,
    INT dstHeight,
    INT xSteps
    )
{
    MeshIterator* iterator;

    iterator  = new MeshIterator(srcHeight, dstHeight, xSteps, gridRows);

    if (iterator == NULL)
        Error("Out of memory\n");

    PointX* ptx;
    INT count;

    for (INT row=0; row < gridRows; row++)
    {
        ptx = getMeshRowBeziers(row, &count, xSteps-1, dstHeight-1);
        iterator->addCurve(ptx, count);
    }

    return iterator;
}


//
// MeshIterator constructor
//

MeshIterator::MeshIterator( 
    INT srcLen,
    INT dstLen,
    INT steps,
    INT maxCurves
    )
{
    if (maxCurves > MAXCURVES)
        Error("Too many curves in MeshIterator constructor\n");

    this->srcLen = srcLen;
    this->dstLen = dstLen;
    this->steps = steps;
    this->maxCurves = maxCurves;
    curveCount = 0;

    for (INT i=0; i < MAXCURVES; i++)
        curves[i] = NULL;
}


//
// MeshIterator - destructor
//

MeshIterator::~MeshIterator()
{
    for (INT i=0; i < MAXCURVES; i++)
        delete curves[i];
}


//
// MeshIterator - add another curve
//

VOID
MeshIterator::addCurve(
    const PointX* pts,
    INT count
    )
{
    if (curveCount == maxCurves)
        Error("Program error in MeshIterator::addCurve\n");
    
    FlatCurve* curve = new FlatCurve(pts, count);

    if (curve == NULL)
        Error("Out of memory\n");
    
    curves[curveCount++] = curve;
}


//
// MeshIterator - get out positions
//

VOID
MeshIterator::getOutPos(
    INT index,
    double* outpos
    )
{
    if (curveCount != maxCurves ||
        index < 0 || index >= steps)
    {
        Error("Program error in MeshIterator::getOutPos\n");
    }

    INT i, j;
    double scale;
    double x = index;

    for (i=0; i < maxCurves; i++)
        stops[i] = curves[i]->getPos(x);

    scale = 1.0 / (srcLen-1);

    for (i=0; i < srcLen; i++)
    {
        j = i * (maxCurves-1) / (srcLen-1);

        INT i0 = (srcLen-1) * j / (maxCurves-1);

        if (i == i0)
            outpos[i] = stops[j];
        else
        {
            INT i1 = (srcLen-1) * (j+1) / (maxCurves-1);

            outpos[i] = stops[j] + (stops[j+1] - stops[j]) * (i-i0) / (i1-i0);
        }
    }

    outpos[srcLen] = dstLen;
}


//
// FlatCurve constructor
//

FlatCurve::FlatCurve(
    const PointX* pts,
    INT count
    )
{
    capacity = elementCount = 0;
    allocIncr = count * 3;
    allocIncr = (allocIncr + 31) & ~31;
    pointArray = NULL;
    lastIndex = 0;

    while (count > 3)
    {
        addBezierFlatten(pts);
        count -= 3;
        pts += 3;
    }
}


//
// FlatCurve destructor
//

FlatCurve::~FlatCurve()
{
    free(pointArray);
}


//
// FlatCurve - add a flattened bezier segment
//

VOID
FlatCurve::addBezierFlatten(
    const PointX* pts
    )
{
    BOOL flatEnough;
    double dx, dy, distSq;
    PointX tempPts[4];

    static const double epsilon = 0.00001;
    static const double flatness = 1;
    static const double flatness2 = flatness*flatness;

    //
    // Determine if the Bezier curve is flat enough
    //
    // Algorithm
    //  Given 3 points (Ax, Ay), (Bx, By), and (Cx, Cy),
    //  the distance from C to line AB is:
    //      dx = Bx - Ax
    //      dy = By - Ay
    //      L = sqrt(dx*dx + dy*dy)
    //      dist = (dy * (Cx - Ax) - dx * (Cy - Ay))/ L
    //

    dx = pts[3].x - pts[0].x;
    dy = pts[3].y - pts[0].y;
    distSq = dx*dx + dy*dy;

    if (distSq < epsilon)
    {
        // if P0 and P3 are too close

        flatEnough = PointX::getSquareDist(pts[0], pts[1]) <= flatness2 &&
                     PointX::getSquareDist(pts[2], pts[3]) <= flatness2;
    }
    else
    {
        // check if P1 is close enough to line P0-P3

        double s;

        s = dy*(pts[1].x - pts[0].x) - dx*(pts[1].y - pts[0].y);
        s *= s;
        distSq *= flatness2;

        if (s > distSq)
            flatEnough = FALSE;
        else
        {
            // check if P2 is close enough to line P0-P3

            s = dy*(pts[2].x - pts[0].x) - dx*(pts[2].y - pts[0].y);
            flatEnough = (s*s <= distSq);
        }
    }

    //
    // If Bezier segment is already flat enough, we're done
    //

    if (flatEnough)
    {
        addLine(pts[0], pts[3]);
        return;
    }

    //
    // Otherwise, we need to subdivide
    //

    tempPts[0] = pts[0];
    tempPts[1].x = (pts[0].x + pts[1].x) * 0.5;
    tempPts[1].y = (pts[0].y + pts[1].y) * 0.5;
    tempPts[2].x = (pts[0].x + pts[2].x) * 0.25 + pts[1].x * 0.5;
    tempPts[2].y = (pts[0].y + pts[2].y) * 0.25 + pts[1].y * 0.5;
    tempPts[3].x = (pts[0].x + pts[3].x) * 0.125 +
                   (pts[1].x + pts[2].x) * 0.375;
    tempPts[3].y = (pts[0].y + pts[3].y) * 0.125 +
                   (pts[1].y + pts[2].y) * 0.375;

    addBezierFlatten(tempPts);

    tempPts[0] = tempPts[3];
    tempPts[1].x = (pts[1].x + pts[3].x) * 0.25 + pts[2].x * 0.5;
    tempPts[1].y = (pts[1].y + pts[3].y) * 0.25 + pts[2].y * 0.5;
    tempPts[2].x = (pts[2].x + pts[3].x) * 0.5;
    tempPts[2].y = (pts[2].y + pts[3].y) * 0.5;
    tempPts[3] = pts[3];

    addBezierFlatten(tempPts);
}


//
// FlatCurve - add a line segment
//

VOID
FlatCurve::addLine(
    const PointX& p1,
    const PointX& p2
    )
{
    // make sure we have enough space

    if (capacity < elementCount+2)
    {
        capacity += allocIncr;
        pointArray = (PointX*) realloc(pointArray, capacity*sizeof(PointX));

        if (pointArray == NULL)
            Error("Out of memory\n");
    }

    // add the first end point of the line, if necessary

    if (elementCount == 0 ||
        p1.x != pointArray[elementCount-1].x ||
        p1.y != pointArray[elementCount-1].y)
    {
        pointArray[elementCount++] = p1;
    }

    // add the second end point

    pointArray[elementCount++] = p2;
}


//
// FlatCurve - calculate the value of the curve at a given position
//

double
FlatCurve::getPos(
    double x
    )
{
    while (lastIndex < elementCount && pointArray[lastIndex].x < x)
        lastIndex++;

    if (lastIndex == elementCount)
        return pointArray[elementCount-1].y;

    if (pointArray[lastIndex].x == x)
        return pointArray[lastIndex].y;

    double x0 = pointArray[lastIndex-1].x;
    double y0 = pointArray[lastIndex-1].y;

    return y0 + (x - x0) * (pointArray[lastIndex].y - y0) /
                           (pointArray[lastIndex].x - x0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\warpdemo\resample.cxx ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   resample.cxx
*
* Abstract:
*
*   1-dimensional image resampling
*
* Revision History:
*
*   01/18/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hxx"

VOID
Resample1D(
    VOID* src,
    INT srccnt,
    VOID* dst,
    INT dstcnt,
    INT pixstride,
    double* outpos
    )

{
    static double* inpos = NULL;
    static int inposLen = 0;

    // allocate working memory

    if (inposLen < dstcnt+2)
    {
        inposLen = dstcnt+2;

        inpos = (double*) realloc(inpos, inposLen*sizeof(double));

        if (inpos == NULL)
            Error("Out of memory\n");
        
        memset(inpos, 0, inposLen*sizeof(double));
    }

    // we only deal with 32-bit RGB pixel

    if (PIXELSIZE != sizeof(DWORD))
        Error("Resample1D can only handle 32bit pixel\n");

    DWORD* in = (DWORD*) src;
    DWORD* out = (DWORD*) dst;
    pixstride /= sizeof(DWORD);

    INT u, x;
    double accB, intensityB,
           accG, intensityG,
           accR, intensityR;
    double insfac, inseg, outseg;

    for (u=x=0; x < dstcnt; x++)
    {
        while (outpos[u+1] < x)
            u++;

        inpos[x] = u + (x-outpos[u]) / (outpos[u+1] - outpos[u]);
    }

    inpos[dstcnt] = srccnt;
    inseg = 1.0;
    outseg = inpos[1];
    insfac = outseg;
    accB = accG = accR = 0.0;

    for (x=0; x < dstcnt; )
    {
        DWORD pix0 = in[0];
        DWORD pix1;
        double rem;

        if (inseg == 1.0)
        {
            intensityB = (BYTE) (pix0      );
            intensityG = (BYTE) (pix0 >>  8);
            intensityR = (BYTE) (pix0 >> 16);
        }
        else
        {
            pix1 = in[pixstride];
            rem = 1.0 - inseg;

            intensityB = inseg * ((BYTE) (pix0      )) +
                           rem * ((BYTE) (pix1      ));
            intensityG = inseg * ((BYTE) (pix0 >>  8)) +
                           rem * ((BYTE) (pix1 >>  8));
            intensityR = inseg * ((BYTE) (pix0 >> 16)) +
                           rem * ((BYTE) (pix1 >> 16));
        }

        if (inseg < outseg)
        {
            accB += intensityB*inseg;
            accG += intensityG*inseg;
            accR += intensityR*inseg;

            outseg -= inseg;
            inseg = 1.0;
            in += pixstride;
        }
        else
        {
            DWORD r, g, b;

            insfac = 1.0 / insfac;
            b = (DWORD) ((accB + intensityB*outseg) * insfac);
            g = (DWORD) ((accG + intensityG*outseg) * insfac);
            r = (DWORD) ((accR + intensityR*outseg) * insfac);

            *out = ((b & 0xff)      ) |
                   ((g & 0xff) <<  8) |
                   ((r & 0xff) << 16);

            out += pixstride;
            x++;

            accB = accG = accR = 0.0;
            inseg -= outseg;
            outseg = insfac = inpos[x+1] - inpos[x];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\warpdemo\warpdemo.cxx ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   warpdemo.cxx
*
* Abstract:
*
*   Image warping demo program
*
* Usage:
*   warpdemo bitmapfile
*
*   Keystrokes:
*       SPACE - show/hide mesh
*       r - reset mesh to default
*       1 - restore 1-to-1 scale
*       < - decrease mesh density
*       > - increase mesh density
*       f - toggle realtime feedback
*
* Revision History:
*
*   01/18/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hxx"

CHAR* programName;          // program name
HINSTANCE appInstance;      // handle to the application instance
HWND hwndMain;              // handle to application's main window
SIZE srcSize;               // source bitmap size
PVOID srcBmpData;           // source bitmap data
INT srcStride;              // source scanline stride
SIZE dstSize;               // destination bitmap size
PVOID dstBmpData;           // destination bitmap data
INT dstStride;              // destination scanline stride
SIZE wndSizeExtra;          // extra pixels for window decorations
BOOL isDragging = FALSE;    // used to handle mouse dragging
INT dragRow, dragCol;       // the control knob being dragged
BOOL clearWarpCache;        // is the cached warping result valid?
BOOL liveFeedback = FALSE;  // realtime feedback while dragging mesh?
INT knobSize;               // mesh control point knob size

#define MIN_KNOB_SIZE       4
#define MAX_KNOB_SIZE       7

#define MIN_MESH_GRID       3
#define MAX_MESH_GRID       32
#define DEFAULT_MESH_GRID   9

INT meshGrids = DEFAULT_MESH_GRID;
Mesh* mesh = NULL;
BOOL showMesh = TRUE;

//
// Display an error message dialog and quit
//

VOID
Error(
    const CHAR* fmt,
    ...
    )

{
    va_list arglist;

    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}


//
// Create a new mesh object
//

VOID
CreateMesh()
{
    mesh = new Mesh(meshGrids, meshGrids);

    if (mesh == NULL)
        Error("Couldn't create Mesh object\n");

    clearWarpCache = TRUE;
}


//
// Calculate mesh control point knob size based
// on current window width and height and also
// the number of mesh grids.
//

VOID
CalcKnobSize(
    INT width,
    INT height
    )
{
    width /= (meshGrids-1);
    height /= (meshGrids-1);

    knobSize = min(width, height) / 5;

    if (knobSize < MIN_KNOB_SIZE)
        knobSize = MIN_KNOB_SIZE;
    else if (knobSize > MAX_KNOB_SIZE)
        knobSize = MAX_KNOB_SIZE;
}


//
// Perform image warping operation based on current mesh configuration
//

HDC hdcWarp = NULL;
HBITMAP hbmpWarp = NULL;

VOID
DoWarp(
    INT width,
    INT height
    )

{
    // Uncache any previous warping results

    if (hdcWarp)
        DeleteDC(hdcWarp);
    
    if (hbmpWarp)
        DeleteObject(hbmpWarp);

    // Create offscreen DC to cache warping results

    dstSize.cx = width;
    dstSize.cy = height;
    dstStride = ((width * PIXELSIZE) + 3) & ~3;

    BITMAPINFOHEADER header =
    {
        sizeof(header),
        dstSize.cx,
        -dstSize.cy,
        1,
        PIXELSIZE*8,
        BI_RGB,
    };

    hdcWarp = CreateCompatibleDC(NULL);

    hbmpWarp = CreateDIBSection(
                        NULL,
                        (BITMAPINFO*) &header,
                        DIB_RGB_COLORS,
                        &dstBmpData,
                        NULL,
                        0);

    if (!hdcWarp || !hbmpWarp)
        Error("Couldn't create DC to cache warping results\n");

    SelectObject(hdcWarp, hbmpWarp);

    // Horizontal pass

    PVOID tmpBmpData;
    INT x, y;
    double* outpos;

    tmpBmpData = malloc(dstStride*(srcSize.cy + 2));
    outpos = (double*) malloc(sizeof(double) * (max(srcSize.cx, srcSize.cy) + 1));

    if (!tmpBmpData || !outpos)
        Error("Could allocate temporary memory for warping\n");

    MeshIterator* iterator;
    
    iterator = mesh->getYIterator(srcSize.cx, dstSize.cx, srcSize.cy);

    for (y=0; y < srcSize.cy; y++)
    {
        // compute the output position for each 

        iterator->getOutPos(y, outpos);

        // perform 1D resampling

        Resample1D(
            (PBYTE) srcBmpData + y*srcStride,
            srcSize.cx,
            (PBYTE) tmpBmpData + y*dstStride,
            dstSize.cx,
            PIXELSIZE,
            outpos);
    }

    delete iterator;

    // Vertical pass

    iterator = mesh->getXIterator(srcSize.cy, dstSize.cy, dstSize.cx);

    for (x=0; x < dstSize.cx; x++)
    {
        // compute the output position for each 

        iterator->getOutPos(x, outpos);

        // perform 1D resampling

        Resample1D(
            (PBYTE) tmpBmpData + PIXELSIZE*x,
            srcSize.cy,
            (PBYTE) dstBmpData + PIXELSIZE*x,
            dstSize.cy,
            dstStride,
            outpos);
    }

    delete iterator;

    free(tmpBmpData);
    free(outpos);
}


//
// Draw mesh
//

#define MESHCOLOR   RGB(255, 0, 0)

VOID
DrawMesh(
    HDC hdc
    )
{
    static HPEN meshPen = NULL;
    static HBRUSH meshBrush = NULL;

    mesh->setDstSize(dstSize.cx, dstSize.cy);

    // Create the pen to draw the mesh, if necessary

    if (meshPen == NULL)
        meshPen = CreatePen(PS_SOLID, 1, MESHCOLOR);

    SelectObject(hdc, meshPen);

    // Draw horizontal meshes

    INT i, j, rows, cols, pointCount;
    POINT* points;

    rows = mesh->getGridRows();

    for (i=0; i < rows; i++)
    {
        points = mesh->getMeshRowBeziers(i, &pointCount);
        PolyBezier(hdc, points, pointCount);
    }

    // Draw vertical meshes

    cols = mesh->getGridColumns();

    for (i=0; i < cols; i++)
    {
        points = mesh->getMeshColumnBeziers(i, &pointCount);
        PolyBezier(hdc, points, pointCount);
    }

    // Draw knobs

    // Create the brush to draw the mesh if necessary

    if (meshBrush == NULL)
        meshBrush = CreateSolidBrush(MESHCOLOR);

    for (i=0; i < rows; i++)
    {
        points = mesh->getMeshRowPoints(i, &pointCount);

        for (j=0; j < cols; j++)
        {
            RECT rect;

            rect.left = points[j].x - knobSize/2;
            rect.top = points[j].y - knobSize/2;
            rect.right = rect.left + knobSize;
            rect.bottom = rect.top + knobSize;

            FillRect(hdc, &rect, meshBrush);
        }
    }
}


//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )

{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    INT width, height;

    // Determine if we need to perform warping operation

    GetClientRect(hwnd, &rect);
    width = rect.right;
    height = rect.bottom;

    if (clearWarpCache ||
        dstSize.cx != width ||
        dstSize.cy != height)
    {
        CalcKnobSize(width, height);

        clearWarpCache = FALSE;
        DoWarp(width, height);
    }

    hdc = BeginPaint(hwnd, &ps);

    if (showMesh)
    {
        // Draw to offscreen DC to reduce flashing

        HDC hdcMem;
        HBITMAP hbmp;

        hdcMem = CreateCompatibleDC(hdc);
        hbmp = CreateCompatibleBitmap(hdc, width, height);
        SelectObject(hdcMem, hbmp);

        BitBlt(hdcMem, 0, 0, width, height, hdcWarp, 0, 0, SRCCOPY);
        DrawMesh(hdcMem);

        // Blt from offscreen memory to window

        BitBlt(hdc, 0, 0, width, height, hdcMem, 0, 0, SRCCOPY);

        DeleteDC(hdcMem);
        DeleteObject(hbmp);
    }
    else
    {
        // Blt cached warping result to window

        BitBlt(hdc, 0, 0, width, height, hdcWarp, 0, 0, SRCCOPY);
    }

    EndPaint(hwnd, &ps);
}


//
// Handle WM_SIZING message
//

BOOL
DoWindowSizing(
    HWND hwnd,
    RECT* rect,
    INT side
    )

{
    INT w = rect->right - rect->left - wndSizeExtra.cx;
    INT h = rect->bottom - rect->top - wndSizeExtra.cy;

    if (w >= srcSize.cx && h >= srcSize.cy)
        return FALSE;

    // Window width is too small

    if (w < srcSize.cx)
    {
        INT dx = srcSize.cx + wndSizeExtra.cx;

        switch (side)
        {
        case WMSZ_LEFT:
        case WMSZ_TOPLEFT:
        case WMSZ_BOTTOMLEFT:
            rect->left = rect->right - dx;
            break;
        
        default:
            rect->right = rect->left + dx;
            break;
        }
    }

    // Window height is too small

    if (h < srcSize.cy)
    {
        INT dy = srcSize.cy + wndSizeExtra.cy;

        switch (side)
        {
        case WMSZ_TOP:
        case WMSZ_TOPLEFT:
        case WMSZ_TOPRIGHT:
            rect->top = rect->bottom - dy;
            break;
        
        default:
            rect->bottom = rect->top + dy;
            break;
        }
    }

    return TRUE;
}


//
// Handle left mouse-down event
//

VOID
DoMouseDown(
    HWND hwnd,
    INT x,
    INT y
    )

{
    // Figure out if the click happened in a mesh control knob

    INT i, j, rows, cols;
    POINT pt;
    RECT rect;

    GetClientRect(hwnd, &rect);
    mesh->setDstSize(rect.right, rect.bottom);

    rows = mesh->getGridRows();
    cols = mesh->getGridColumns();

    for (i=0; i < rows; i++)
        for (j=0; j < cols; j++)
        {
            mesh->getMeshPoint(i, j, &pt);
            pt.x -= knobSize/2;
            pt.y -= knobSize/2;

            if (x >= pt.x && x < pt.x+knobSize &&
                y >= pt.y && y < pt.y+knobSize)
            {
                dragRow = i;
                dragCol = j;
                SetCapture(hwnd);
                isDragging = TRUE;
                return;
            }
        }
}


//
// Handle mouse-move event
//

VOID
DoMouseMove(
    HWND hwnd,
    INT x,
    INT y
    )

{
    // We assume isDragging is true here.

    RECT rect;
    INT w, h;

    GetClientRect(hwnd, &rect);
    w = rect.right;
    h = rect.bottom;

    if (x < 0 || x >= w || y < 0 || y >= h)
        return;

    mesh->setDstSize(w, h);

    if (mesh->setMeshPoint(dragRow, dragCol, x, y))
    {
        if (liveFeedback)
            clearWarpCache = TRUE;

        InvalidateRect(hwnd, NULL, FALSE);
    }
}


//
// Handle menu command
//

VOID
DoCommand(
    HWND hwnd,
    INT command
    )
{
    switch (command)
    {
    case IDC_RESETMESH:

        mesh->initMesh();
        clearWarpCache = TRUE;
        break;

    case IDC_TOGGLEMESH:

        showMesh = !showMesh;
        break;

    case IDC_SHRINKTOFIT:

        SetWindowPos(
            hwnd, NULL, 0, 0, 
            srcSize.cx + wndSizeExtra.cx,
            srcSize.cy + wndSizeExtra.cy,
            SWP_NOOWNERZORDER|SWP_NOMOVE);
        break;

    case IDC_DENSEMESH:

        if (meshGrids >= MAX_MESH_GRID)
            return;
        
        meshGrids++;
        CreateMesh();
        showMesh = TRUE;
        break;

    case IDC_SPARSEMESH:

        if (meshGrids <= MIN_MESH_GRID)
            return;

        meshGrids--;
        CreateMesh();
        showMesh = TRUE;
        break;

    case IDC_LIVEFEEDBACK:

        liveFeedback = !liveFeedback;
        return;

    default:
        return;
    }

    InvalidateRect(hwnd, NULL, FALSE);
}


//
// Handle popup menu
//

VOID
DoPopupMenu(
    HWND hwnd,
    INT x,
    INT y
    )
{
    HMENU menu;
    DWORD result;
    POINT pt;

    GetCursorPos(&pt);
    menu = LoadMenu(appInstance, MAKEINTRESOURCE(IDM_MAINMENU));

    result = TrackPopupMenu(
                GetSubMenu(menu, 0),
                TPM_CENTERALIGN | TPM_TOPALIGN |
                    TPM_NONOTIFY | TPM_RETURNCMD |
                    TPM_RIGHTBUTTON,
                pt.x,
                pt.y,
                0,
                hwnd,
                NULL);

    if (result == 0)
        return;

    DoCommand(hwnd, LOWORD(result));
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    INT x, y;

    switch (uMsg)
    {
    case WM_PAINT:

        DoPaint(hwnd);
        break;

    case WM_LBUTTONDOWN:

        if (showMesh)
        {
            x = (SHORT) LOWORD(lParam);
            y = (SHORT) HIWORD(lParam);
            DoMouseDown(hwnd, x, y);
        }
        break;

    case WM_LBUTTONUP:

        if (isDragging)
        {
            ReleaseCapture();
            isDragging = FALSE;

            clearWarpCache = TRUE;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case WM_MOUSEMOVE:

        if (isDragging)
        {
            x = (SHORT) LOWORD(lParam);
            y = (SHORT) HIWORD(lParam);
            DoMouseMove(hwnd, x, y);
        }
        break;

    case WM_SIZING:

        if (DoWindowSizing(hwnd, (RECT*) lParam, wParam))
            return TRUE;
        else
            return DefWindowProc(hwnd, uMsg, wParam, lParam);

    case WM_SIZE:

        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_CHAR:

        switch ((CHAR) wParam)
        {
        case 'r':   // reset

            DoCommand(hwnd, IDC_RESETMESH);
            break;

        case ' ':   // show/hide mesh

            DoCommand(hwnd, IDC_TOGGLEMESH);
            break;

        case '1':   // restore 1-to-1 scale

            DoCommand(hwnd, IDC_SHRINKTOFIT);
            break;
        
        case '<':   // decrease mesh density

            DoCommand(hwnd, IDC_SPARSEMESH);
            break;

        case '>':   // increase mesh density

            DoCommand(hwnd, IDC_DENSEMESH);
            break;

        case 'f':   // toggle live feedback

            DoCommand(hwnd, IDC_LIVEFEEDBACK);
            break;
        }

        break;

    case WM_RBUTTONDOWN:

        x = (SHORT) LOWORD(lParam);
        y = (SHORT) HIWORD(lParam);
        DoPopupMenu(hwnd, x, y);
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMainWindow(
    VOID
    )

#define MYWNDCLASSNAME "WarpDemo"

{
    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            0,
            MyWindowProc,
            0,
            0,
            appInstance,
            LoadIcon(NULL, IDI_APPLICATION),
            LoadCursor(NULL, IDC_ARROW),
            NULL,
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }
    
    wndSizeExtra.cx = 2*GetSystemMetrics(SM_CXSIZEFRAME);
    wndSizeExtra.cy = 2*GetSystemMetrics(SM_CYSIZEFRAME) + GetSystemMetrics(SM_CYCAPTION);

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    srcSize.cx + wndSizeExtra.cx,
                    srcSize.cy + wndSizeExtra.cy,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);
}


//
// Map a file into process memory space
//

PVOID
MapFileIntoMemory(
    PCSTR filename,
    DWORD* size
    )

{
    HANDLE filehandle, filemap;
    PVOID fileview = NULL;

    //
    // Open a handle to the specified file
    //

    filehandle = CreateFile(
                        filename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL||FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if (filehandle == INVALID_HANDLE_VALUE)
        return NULL;

    //
    // Obtain the file size
    //

    *size = GetFileSize(filehandle, NULL);

    if (*size == 0xFFFFFFFF)
    {
        CloseHandle(filehandle);
        return NULL;
    }

    //
    // Map the file into memory
    //

    filemap = CreateFileMapping(filehandle, NULL, PAGE_READONLY, 0, 0, NULL);

    if (filemap != NULL)
    {
        fileview = MapViewOfFile(filemap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(filemap);
    }

    CloseHandle(filehandle);
    return fileview;
}


//
// Load source bitmap file
//

VOID
LoadBitmapFile(
    PCSTR filename
    )

{
    BITMAPFILEHEADER* bmpfile;
    BITMAPINFO* bmpinfo;
    PBYTE bmpdata;
    HBITMAP dibSection = NULL;
    DWORD filesize;
    PVOID fileview = NULL;
    HDC hdc = NULL;
    BOOL success = FALSE;

    __try
    {
        //
        // Map the bitmap file into memory
        //

        fileview = MapFileIntoMemory(filename, &filesize);

        if (fileview == NULL)
            __leave;

        bmpfile = (BITMAPFILEHEADER *) fileview;
        bmpinfo = (BITMAPINFO *) ((PBYTE) fileview + sizeof(BITMAPFILEHEADER));
        bmpdata = (PBYTE) fileview + bmpfile->bfOffBits;

        //
        // Check bitmap file header information
        //

        if (bmpfile->bfType != 0x4D42 ||    // 'BM'
            bmpfile->bfSize > filesize ||
            bmpfile->bfOffBits >= bmpfile->bfSize)
        {
            __leave;
        }

        //
        // Allocate memory for source bitmap
        //

        srcSize.cx = bmpinfo->bmiHeader.biWidth;
        srcSize.cy = abs(bmpinfo->bmiHeader.biHeight);
        srcStride = ((srcSize.cx * PIXELSIZE) + 3) & ~3;

        BITMAPINFOHEADER header =
        {
            sizeof(header),
            srcSize.cx,
            -srcSize.cy,
            1,
            PIXELSIZE*8,
            BI_RGB,
        };

        dibSection = CreateDIBSection(
                            NULL,
                            (BITMAPINFO*) &header,
                            DIB_RGB_COLORS,
                            &srcBmpData,
                            NULL,
                            0);

        if (!dibSection)
            __leave;

        //
        // Blt from the bitmap file to the DIB section
        //

        HBITMAP hbmp;

        hdc = CreateCompatibleDC(NULL);
        hbmp = (HBITMAP) SelectObject(hdc, dibSection);

        StretchDIBits(
            hdc,
            0, 0, srcSize.cx, srcSize.cy,
            0, 0, srcSize.cx, srcSize.cy,
            bmpdata,
            bmpinfo,
            DIB_RGB_COLORS,
            SRCCOPY);

        SelectObject(hdc, hbmp);
        success = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // AV while reading bitmap file
    }

    if (hdc)
        DeleteDC(hdc);

    if (fileview)
        UnmapViewOfFile(fileview);

    if (!success)
        Error("Failed to read source bitmap\n");
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);

    // Load source bitmap file

    if (argc != 1)
        Error("usage: %s bitmapfile\n", programName);

    LoadBitmapFile(*argv);

    // Initialize mesh configuration

    CreateMesh();

    // Create the main application window

    CreateMainWindow();

    // Main message loop

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\test\thumbtst\thumbtst.cpp ===
//
// Simple test program for imaging library
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <urlmon.h>
#include <commdlg.h>
#include <math.h>

#include <gdiplus.h>
#include <gdiplusflat.h>

using namespace Gdiplus;
#include "../gpinit.inc"

#define     k_DefaultWidth  720
#define     k_DefaultHeight 480
#define     THUMBSIZE       120
#define     MAX_FILENAME    1000

CHAR*       g_pcProgramName = NULL;     // program name
HINSTANCE   g_hAppInstance;             // handle to the application instance
HWND        g_hwndMain;                 // handle to application's main window

int         g_iTotalNumOfImages;
int         lastS;
int         numX;
int         g_iNumFileNames;

Image**     g_ppThumbImages;
CHAR**      g_ppcInputFilenames;
RECT        g_ThumbRect;

BOOL        g_fVerbose = FALSE;
BOOL        g_fHighQualityThumb = FALSE;

#define ERREXIT(args)   { printf args; exit(-1); }
#define VERBOSE(args) printf args

//
// Helper class to convert ANSI strings to Unicode strings
//

inline BOOL
UnicodeToAnsiStr(
    const WCHAR*    unicodeStr,
    CHAR*           ansiStr,
    INT             ansiSize
    )
{
    return WideCharToMultiByte(CP_ACP, 0, unicodeStr, -1, ansiStr, ansiSize,
                               NULL, NULL) > 0;
}

inline BOOL
AnsiToUnicodeStr(
    const CHAR*     ansiStr,
    WCHAR*          unicodeStr,
    INT             unicodeSize
    )
{
    return MultiByteToWideChar(CP_ACP, 0, ansiStr, -1, unicodeStr,
                               unicodeSize) > 0;
}


class UnicodeStrFromAnsi
{
public:

    UnicodeStrFromAnsi(const CHAR* ansiStr)
    {
        if (ansiStr == NULL)
        {
            valid = TRUE;
            unicodeStr = NULL;
        }
        else
        {
            // NOTE: we only handle strings with length < MAX_PATH.

            valid = AnsiToUnicodeStr(ansiStr, buf, MAX_PATH);
            unicodeStr = valid ? buf : NULL;
        }
    }

    BOOL IsValid() const
    {
        return valid;
    }

    operator WCHAR*()
    {
        return unicodeStr;
    }

private:

    BOOL valid;
    WCHAR* unicodeStr;
    WCHAR buf[MAX_PATH];
};

//
// Create thumbnails for the specified list of files
//

VOID
DrawThumbnails(
    const RECT  rect,
    HDC         hdc
    )
{
    if ( (rect.bottom - rect.top <= 0) || (rect.right - rect.left <= 0) )
    {
        return;
    }

    // Figure out how many rows and columns we need to divide in order to put
    // "g_iTotalNumOfImages" images within the fixed size "rect"
    // Basically "iNumColumns" * "iNumRows" should >= "g_iTotalNumOfImages"

    int iWindowWidth = rect.right - rect.left;
    int iWindowHeight = rect.bottom - rect.top;

    int iSum = 1;
    while ( ((iWindowWidth / iSum) * (iWindowHeight / iSum))
            >= g_iTotalNumOfImages )
    {
        iSum++;
    }

    iSum--;

    int iNumColumns = iWindowWidth / iSum;
    int iNumRows = iWindowHeight / iSum;

    lastS = iSum;           // Reset the global
    numX = iNumColumns;     // Reset the global

    Graphics* pGraphics = new Graphics(g_hwndMain);
    
    int x = 0;
    int y = 0;

    for ( int i = 0; i < g_iTotalNumOfImages; i++ )
    {
        if ( NULL == g_ppThumbImages[i] ) 
        {
            // Bad image. But we still leave the position for it so that it can
            // be easily noticed

            x++;
            if (x >= iNumColumns)
            {
                x = 0;
                y++;
            }
            
            continue;
        }
        
        // Copy thumbnail bitmap image data to offscreen memory DC

        int tx;
        int ty;

        SizeF size;
        g_ppThumbImages[i]->GetPhysicalDimension(&size);

        float dAspect = size.Width / size.Height;
        RECT r;

        if ( dAspect > 1 )
        {
            tx = iSum;
            ty = (int)(iSum / dAspect);
            int d = (iSum - ty) / 2;
            r.left = x * iSum;
            r.top = y * iSum + d;
            r.right = x * iSum + tx;
            r.bottom = y * iSum + ty + d;
        }
        else
        {
            ty = iSum;
            tx = (int)(iSum * dAspect);
            int d = (iSum - tx) / 2;
            r.left = x * iSum + d;
            r.top = y * iSum;
            r.right = x * iSum + tx + d;
            r.bottom = y * iSum + ty;
        }
        
        if ( g_fHighQualityThumb == FALSE )
        {
            Rect    dstRect(r.left, r.top, tx, ty);

            pGraphics->DrawImage(g_ppThumbImages[i],
                                 dstRect,
                                 0,
                                 0,
                                 (UINT)g_ppThumbImages[i]->GetWidth(),
                                 (UINT)g_ppThumbImages[i]->GetHeight(),
                                 UnitPixel,
                                 NULL,
                                 NULL,
                                 NULL);
        }
        else
        {
            // Generate high quality thumbnail based on required size

            Bitmap*     dstBmp = new Bitmap(tx, ty, PixelFormat32bppPARGB);
            Graphics*   gdst = new Graphics(dstBmp);

            // Ask the source image for it's size.

            int width = g_ppThumbImages[i]->GetWidth();
            int height = g_ppThumbImages[i]->GetHeight();

            // Compute the optimal scale factor without changing the aspect ratio

            float scalex = (float)width / tx;
            float scaley = (float)height / ty;
            float scale = min(scalex, scaley);

            Rect dstRect(0, 0, tx, ty);

            // Set the resampling quality to the bicubic filter

            gdst->SetInterpolationMode(InterpolationModeHighQualityBicubic);

            // Set the compositing quality to copy source pixels rather than
            // alpha blending. This will preserve any alpha in the source image.

            gdst->SetCompositingMode(CompositingModeSourceCopy);

            ImageAttributes imgAttr;
            imgAttr.SetWrapMode(WrapModeTileFlipXY);

            // Draw the source image onto the destination with the correct scale
            // and quality settings.

            GpStatus status = gdst->DrawImage(g_ppThumbImages[i], 
                                              dstRect, 
                                              0,
                                              0,
                                              INT((tx * scale) + 0.5),
                                              INT((ty * scale) + 0.5),
                                              UnitPixel,
                                              &imgAttr);

            if( status != Ok )
            {
                printf("Error drawing the image\n");
                continue;
            }

            // Draw the result onto the screen

            Rect drawDstRect(r.left, r.top, tx, ty);

            pGraphics->DrawImage(dstBmp,
                                 drawDstRect,
                                 0,
                                 0,
                                 (UINT)dstBmp->GetWidth(),
                                 (UINT)dstBmp->GetHeight(),
                                 UnitPixel,
                                 NULL,
                                 NULL,
                                 NULL);

            delete dstBmp;
            delete gdst;
        }

        x++;
        if (x >= iNumColumns)
        {
            x = 0;
            y++;
        }
    }// Loop through all the thumbnail images to draw

    delete pGraphics;
}

//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rect;

    hdc =       BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rect);

    const RECT  r = {rect.left, rect.top, rect.right, rect.bottom};
    DrawThumbnails(r, hdc);

    EndPaint(hwnd, &ps);
}// DoPaint()

//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    int index=0;
    
    switch (uMsg)
    {
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_LBUTTONDBLCLK:
        if (lastS == 0) 
        {
            lastS = 1;
        }
        index = (HIWORD(lParam) / lastS) * numX + (LOWORD(lParam) / lastS);
        
        if (index < g_iNumFileNames) 
        {
            char cmdLine[MAX_FILENAME];
            strcpy(cmdLine, "frametest ");
            strcat(cmdLine, g_ppcInputFilenames[index]);
            WinExec(cmdLine, SW_SHOWNORMAL);
        }
        break;

    case WM_SIZE:
        SendMessage(g_hwndMain, WM_ERASEBKGND, WPARAM(GetDC(g_hwndMain)), NULL);

        InvalidateRect(g_hwndMain, NULL, FALSE);

        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

#define MYWNDCLASSNAME "ThumbTst"

VOID
CreateMainWindow(
    VOID
    )
{
    // Use a hatch brush as background so that we can get transparent info
    // from the source image

    HBRUSH hBrush = CreateHatchBrush(HS_HORIZONTAL,
                                     RGB(0, 200, 0));

    // Register window class

    WNDCLASS wndClass =
    {
        CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS,
        MyWindowProc,
        0,
        0,
        g_hAppInstance,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        hBrush,
        NULL,
        MYWNDCLASSNAME
    };

    RegisterClass(&wndClass);

    // Calculate default window size

    INT iWidth = g_ThumbRect.right + 2 * GetSystemMetrics(SM_CXFRAME);

    INT iHeight = g_ThumbRect.bottom
                + 2 * GetSystemMetrics(SM_CYFRAME)
                + GetSystemMetrics(SM_CYCAPTION);

    // Create application window

    g_hwndMain = CreateWindow(MYWNDCLASSNAME,
                              MYWNDCLASSNAME,
                              WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              iWidth,
                              iHeight,
                              NULL,
                              NULL,
                              g_hAppInstance,
                              NULL);
}// CreateMainWindow()

void
DisplayImageInfo(
    Image* pImage
    )
{
    UINT    uiImagePixelFormat = pImage->GetPixelFormat();
    UINT    uiImageFlags = pImage->GetFlags();

    VERBOSE(("Width = %d\n", pImage->GetWidth()));
    VERBOSE(("Width = %d\n", pImage->GetHeight()));

    // Pixel format

    switch ( uiImagePixelFormat )
    {
    case PixelFormat1bppIndexed:
        VERBOSE(("Color depth: 1 BPP INDEXED\n"));

        break;

    case PixelFormat4bppIndexed:
        VERBOSE(("Color depth: 4 BPP INDEXED\n"));

        break;

    case PixelFormat8bppIndexed:
        VERBOSE(("Color depth: 8 BPP INDEXED\n"));

        break;

    case PixelFormat16bppGrayScale:
        VERBOSE(("Color depth: 16 BPP GRAY SCALE\n"));

        break;

    case PixelFormat16bppRGB555:
        VERBOSE(("Color depth: 16 BPP RGB 555\n"));

        break;

    case PixelFormat16bppRGB565:
        VERBOSE(("Color depth: 16 BPP RGB 565\n"));

        break;

    case PixelFormat16bppARGB1555:
        VERBOSE(("Color depth: 16 BPP ARGB 1555\n"));

        break;

    case PixelFormat24bppRGB:
        VERBOSE(("Color depth: 24 BPP RGB\n"));

        break;

    case PixelFormat32bppARGB:
        VERBOSE(("Color depth: 32 BPP ARGB\n"));

        break;

    case PixelFormat32bppPARGB:
        VERBOSE(("Color depth: 32 BPP PARGB\n"));

        break;

    case PixelFormat48bppRGB:
        VERBOSE(("Color depth: 48 BPP PARGB\n"));

    case PixelFormat64bppARGB:
        VERBOSE(("Color depth: 64 BPP ARGB\n"));

        break;

    case PixelFormat64bppPARGB:
        VERBOSE(("Color depth: 64 BPP PARGB\n"));

        break;

    default:
        VERBOSE(("Unknown color depth\n"));
        break;
    }// Color format

    // Physical dimension info

    VERBOSE(("X DPI (dots per inch) = %f\n",pImage->GetHorizontalResolution()));
    VERBOSE(("Y DPI (dots per inch) = %f\n",pImage->GetVerticalResolution()));
    
    // Pixel size

    if ( uiImageFlags & ImageFlagsHasRealPixelSize )
    {
        VERBOSE(("---The pixel size info is from the original image\n"));
    }
    else
    {
        VERBOSE(("---The pixel size info is NOT from the original image\n"));
    }

    // DPI info

    if ( uiImageFlags & ImageFlagsHasRealPixelSize )
    {
        VERBOSE(("---The pixel size info is from the original image\n"));
    }
    else
    {
        VERBOSE(("---The pixel size info is NOT from the original image\n"));
    }

    // Transparency info

    if ( uiImageFlags & ImageFlagsHasAlpha )
    {
        VERBOSE(("This image contains alpha pixels\n"));

        if ( uiImageFlags & ImageFlagsHasTranslucent )
        {
            VERBOSE(("---It has non-0 and 1 alpha pixels (TRANSLUCENT)\n"));
        }
    }
    else
    {
        VERBOSE(("This image does not contain alpha pixels\n"));
    }

    // Display color space

    if ( uiImageFlags & ImageFlagsColorSpaceRGB )
    {
        VERBOSE(("This image is in RGB color space\n"));
    }
    else if ( uiImageFlags & ImageFlagsColorSpaceCMYK )
    {
        VERBOSE(("This image is in CMYK color space\n"));
    }
    else if ( uiImageFlags & ImageFlagsColorSpaceGRAY )
    {
        VERBOSE(("This image is a gray scale image\n"));
    }
    else if ( uiImageFlags & ImageFlagsColorSpaceYCCK )
    {
        VERBOSE(("This image is in YCCK color space\n"));
    }
    else if ( uiImageFlags & ImageFlagsColorSpaceYCBCR )
    {
        VERBOSE(("This image is in YCBCR color space\n"));
    }
}// DisplayImageInfo()

//
// Create thumbnails for the specified list of files
//

VOID
CreateThumbnails(
    CHAR** ppcFilenames
    )
{
    // Generate thumbnails

    UINT    uiTimer;
    if ( g_fVerbose == TRUE )
    {
        uiTimer = GetTickCount();
    }

    g_ppThumbImages = new Image*[g_iTotalNumOfImages];
    Image* pSrcImage = NULL;

    // Loop through all the images and generate thumbnail

    for ( int i = 0; i < g_iTotalNumOfImages; i++ )
    {
        g_ppThumbImages[i] = NULL;
        
        // Get a Unicode file name

        UnicodeStrFromAnsi namestr(ppcFilenames[i]);

        VERBOSE(("Loading - %s\n", ppcFilenames[i]));

        if ( namestr.IsValid() == FALSE )
        {
            VERBOSE(("Couldn't open image file: %s\n", ppcFilenames[i]));
            continue;
        }
        else if ( g_fHighQualityThumb == FALSE )
        {
            pSrcImage = new Image(namestr, TRUE);
        
            if ( (pSrcImage == NULL) || (pSrcImage->GetLastStatus() != Ok) )
            {
                VERBOSE(("Couldn't open image file: %s\n", ppcFilenames[i]));
                if ( pSrcImage != NULL )
                {
                    delete pSrcImage;
                    pSrcImage = NULL;
                }

                continue;
            }

            if ( g_fVerbose == TRUE )
            {
                DisplayImageInfo(pSrcImage);
            }

            // Get build in thumbnail image if there is one. Otherwise, GDI+
            // will generate one for us

            g_ppThumbImages[i] = pSrcImage->GetThumbnailImage(0, 0, NULL, NULL);
            delete pSrcImage;
            pSrcImage = NULL;
        }
        else
        {
            // High quality thumbnail images. We don't generate it here

            g_ppThumbImages[i] = new Image(namestr, TRUE);
            
            if ( g_ppThumbImages[i] == NULL )
            {
                VERBOSE(("Couldn't open image file: %s\n", ppcFilenames[i]));
                continue;
            }

            if ( g_fVerbose == TRUE )
            {
                DisplayImageInfo(g_ppThumbImages[i]);
            }
        }
    }// Loop through all the images

    if ( g_fVerbose == TRUE )
    {
        uiTimer = GetTickCount() - uiTimer;
        VERBOSE(("Generate %d thumbnails in %dmsec\n", g_iTotalNumOfImages,
                uiTimer));
    }
}// CreateThumbnails

void
USAGE()
{
    printf("******************************************************\n");
    printf("Usage: thumbtst [-?] [-v] ImageFileNames\n");
    printf("-v                        Verbose image information output\n");
    printf("-h                        Generate higher quality thumbnail\n");
    printf("-?                        Print this usage message\n");
    printf("ImageFileNames            Files to be opened\n\n");
    printf("Sample usage:\n");
    char myChar = '\\';
    printf("    thumbtst.exe c:%cpublic%c*.jpg\n", myChar, myChar);
}// USAGE()

char html_header[1024] = "<html>\n<head>\n <title>My Fun Photo Album</title>\n</head>\n</html>\0";

void
OutputHTML()
{
    FILE*    hFile = fopen("mytest.html", "w");
    if ( hFile == NULL )
    {
        return;
    }

    fprintf(hFile, "%s", html_header);
    fclose(hFile);
}// OutputHTML()

void
ValidateArguments(
    int   argc,
    char* argv[]
    )
{
    g_pcProgramName = *argv++;
    argc--;
    g_hAppInstance = GetModuleHandle(NULL);

    while ( argc > 0 )
    {
        if ( strcmp(*argv, "-v") == 0 )
        {
            argc--;
            argv++;

            g_fVerbose = TRUE;
        }
        else if ( strcmp(*argv, "-h") == 0 )
        {
            argc--;
            argv++;

            g_fHighQualityThumb = TRUE;
        }
        else if ( strcmp(*argv, "-?") == 0 )
        {
            USAGE();
            exit(1);
        }
        else
        {
            // Get the pointer to image file list

            g_ppcInputFilenames = argv;
            g_iNumFileNames = argc;

            // Total number of images
            // Note: if you do "thumbtst.exe c:\temp\*.jpg", this argc is
            // actually the total number of images in that dir. While in argv,
            // it points to each image under that dir

            g_iTotalNumOfImages = argc;
            
            return;
        }
    }// while (argc > 0 )

    if ( argc == 0 )
    {
        USAGE();
        exit(1);
    }
    
    return;
}// ValidateArguments()

//
// Main program entrypoint
//

INT _cdecl
main(
    INT     argc,
    CHAR**  argv
    )
{
    ValidateArguments(argc, argv);

    g_ThumbRect.left = 0;
    g_ThumbRect.top = 0;
    g_ThumbRect.right = k_DefaultWidth;
    g_ThumbRect.bottom = k_DefaultHeight;

    // Generate thumbnail images and store it in g_ppThumbImages

    CreateThumbnails(g_ppcInputFilenames);

    // Create the main application window

    CreateMainWindow();

//    OutputHTML();

    // Main message loop

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Clean up
    // Note: above while loop won't finish until we don't have any messages

    for ( int i = 0; i < g_iTotalNumOfImages; i++ )
    {
        if ( NULL != g_ppThumbImages[i] ) 
        {
            delete g_ppThumbImages[i];
        }
    }

    delete [] g_ppThumbImages;

    return (INT)(msg.wParam);
}// main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\tools\memcounter\memcounter.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Memory allocation profiling support
*
* Abstract:
*
*   Declares logging functions used for memory allocation profiling.
*   This is only enabled when PROFILE_MEMORY_USAGE is set.
*   See memcounter.cpp for more details.
*
* Notes:
*
*   I've added calls to MC_LogAllocation to most of our allocation sites.
*   These are the omissions I'm aware of:
*     runtime\debug.cpp - it's chk only.
*     gpmf3216\* - (calls LocalAlloc) I think it's a separate lib.
*     entry\create.cpp - calls GlobalAlloc (a single tiny allocation).
*     imaging\pwc\pwclib - many calls to LocalAlloc.
*     text\uniscribe\usp10\usp_mem.cxx - DBrown says that GDI+ never this
*         allocation code.
*
* Created:
*
*   06/08/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _PROFILEMEM_H
#define _PROFILEMEM_H

#if PROFILE_MEMORY_USAGE

#ifdef __cplusplus
extern "C" {
#endif

VOID _stdcall MC_LogAllocation(UINT size);

#ifdef __cplusplus
}
#endif

#endif // PROFILE_MEMORY_USAGE

#endif // _PROFILEMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\tools\memcounter\memcounter.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   IceCAP user counters for GDI+ memory allocations
*
* Abstract:
*
*   This is an IceCAP "user counter" DLL. It exports logging functions which
*   GDI+ will call during memory allocation (if PROFILE_MEMORY_USAGE is
*   true). It also exports query functions for hooking up to IceCAP.
*
* Instructions for use:
*
*   + Build memcounter.dll
*   + Copy memcounter.dll and the icecap.ini file (which is in the same 
*     directory as memcounter.cpp) to the test app directory.
*   + set PROFILE_MEMORY_USAGE=1
*   + Build GDIPLUS.DLL
*   + Instrument it (using "gppick.bat")
*   + Run the test
*   + Afterwards, view the .ICP file that has been generated.
*
*   In the IceCAP viewer, you will need to add columns for 
*   "User counter 1, elapsed inclusive", etc.
*
* Created:
*
*   06/10/2000 agodfrey
*      Created it from the sample code in IceCAP4\Samples\MemTrack.
*
**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define DONTUSEICECAPLIB
#include "icecap.h"

// GLOBALS
//
// This is where we will store our counter values.  These could
// just as easily be put in shared memory so you can have another
// process updating them.  They can not be put in the counter
// functions as auto variables, since naked functions don't 
// allow for this.

DWORD g_dwTlsSlot = 0xffffffff;         // TLS Slot, allocated in DllMain
DWORD g_dwTlsIndexSize;                 // 'Pre-computed' slot offset, so we can
                                        // avoid calling TlsGetValue in probes

//
//  Data tracked for each thread.
struct SAllocInfo
{
    COUNTER cntAllocs;                  // Number of allocations made
    COUNTER cntBytes;                   // Bytes (total) allocated
};


const UINT g_uiMaxThreads = 64;         // Max sim. threads tracked
SAllocInfo g_aAllocInfo[g_uiMaxThreads]; // Data tracked
BOOL g_afInUse[g_uiMaxThreads];         // Is a particular data slot used


// FUNCTIONS
//
///////////////////////////////////////////////////////////////
// DllMain
//
// Standard DLL entry point, sets up storage for per-thread 
// counter information.
//
// History:  9-16-98 MHotchin Created
//
///////////////////////////////////////////////////////////////

BOOL
APIENTRY
DllMain(
        HANDLE ,
        DWORD  dwReason,
        LPVOID )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_dwTlsSlot = TlsAlloc();

        memset(g_afInUse, 0, sizeof(g_afInUse));

        if (g_dwTlsSlot == 0xffffffff)
        {
            return FALSE;
        }

        //
        //  Tricky, tricky, tricky...
        //  We can pre-compute where the TLS slot will be, once
        //  we have the index.  The offsets are OS dependent!
        //
        //  This makes the probes much faster, becuase we don't need to
        //  call TlsGetValue().
        if (GetVersion() & 0x80000000)
        {
            //  *** WIN 9x ONLY ***
            g_dwTlsIndexSize = g_dwTlsSlot * sizeof(void *) + 0x88;
        }
        else
        {
            //
            //  *** NT ONLY ***
            g_dwTlsIndexSize = g_dwTlsSlot * sizeof(void *) + 0xe10;
        }

        //
        //  FALL THROUGH
    case DLL_THREAD_ATTACH:
        {
            SAllocInfo *pInfo = NULL;

            //
            //  Locate a data slot for this thread and remeber it's pointer
            //  in the TLS slot.
            for (UINT i = 0; i < g_uiMaxThreads; i++)
            {
                if (!g_afInUse[i])
                {
                    g_afInUse[i] = TRUE;
                    pInfo = &(g_aAllocInfo[i]);
                    memset(pInfo, 0, sizeof(SAllocInfo));

                    break;
                }
            }
            TlsSetValue(g_dwTlsSlot, pInfo);
        }
    break;

    case DLL_PROCESS_DETACH:
        if (g_dwTlsSlot != 0xffffffff)
        {
            TlsFree(g_dwTlsSlot);
            g_dwTlsSlot = 0xffffffff;
        }
        break;

    case DLL_THREAD_DETACH:
        {
            SAllocInfo *pInfo = (SAllocInfo *)TlsGetValue(g_dwTlsSlot);

            if (pInfo != NULL)
            {
                UINT iIndex = pInfo - g_aAllocInfo;

                g_afInUse[iIndex] = FALSE;
            }
        }

    break;
    }

    return TRUE;
}




///////////////////////////////////////////////////////////////
// GetCounterInfo
//
// This is where we define what is counter is, and how it
// behaves.  
//
// History:  9-16-98 MHotchin Created
//           2-26-99 AlonB updated for new USERCOUNTER API
//
///////////////////////////////////////////////////////////////
extern "C" BOOL _stdcall GetCounterInfo(DWORD iCounter, USERCOUNTERINFO *pInfo)

{
    // we only have two counters to set up
    if (iCounter > 1)
        return FALSE;

    pInfo->dwSize = sizeof(USERCOUNTERINFO);
    pInfo->bSynchronized = TRUE;

    if (0 == iCounter)
    {
        // SETUP COUNTER 0
        strcpy(pInfo->szCounterFuncName, "GetCounterOneValue");
        strcpy(pInfo->szName, "Mem Allocs");
        pInfo->ct = MonotonicallyIncreasing;
    }
    else // 1 == iCounter
    {
        // SETUP COUNTER 1
        strcpy(pInfo->szCounterFuncName, "GetCounterTwoValue");
        strcpy(pInfo->szName, "Byte Allocs");
        pInfo->ct = RandomIncreasing;
    }

    // We didn't do anything here that could fail, at least nothing
    // that wouldn't be catistrophic.  So just return TRUE.
    //
    return TRUE;
}

extern  "C" 
VOID _stdcall 
MC_LogAllocation(UINT size)
{
    //
    //  Get data pointer from TLS slot and update counts for this thread.
    if (g_dwTlsSlot != 0xffffffff)
    {
        SAllocInfo *pAllocInfo = (SAllocInfo *)TlsGetValue(g_dwTlsSlot);

        if (pAllocInfo != NULL)
        {
            pAllocInfo->cntAllocs++;
            pAllocInfo->cntBytes += size;
        }
    }
}

extern "C"
BOOL
_stdcall
InitCounters(void)
{

    return TRUE;
}



#define PcTeb                         0x18


//-----------------------------------------------------------------------------
// GetCounterOneValue
//
// Return current value for first counter - number of CRT allocs
//
// History:  9-16-98 MHotchin Created
//
//-----------------------------------------------------------------------------
//
extern "C"
COUNTER
_declspec(naked) _stdcall
GetCounterOneValue(void)
{
    _asm
    {
        mov eax, g_dwTlsIndexSize       // Load TLS slot offset
        add eax, fs:[PcTeb]             // Load pointer to TLS slot
        mov eax, [eax]                  // Load Data pointer from TLS slot
        je NoSample                     // If NULL, skip

        mov edx, dword ptr [eax+0x04]   // High word of # allocs
        mov eax, dword ptr [eax]        // Low word of # allocs

        ret
    NoSample:
        mov eax, 0
        mov edx, 0

        ret
    }
}


//-----------------------------------------------------------------------------
// GetCounterTwoValue
//
//  Return current value of second counter - number of bytes allocated.
//
// History:  9-16-98 MHotchin Created
//
//-----------------------------------------------------------------------------
extern "C"
COUNTER
_declspec(naked) _stdcall
GetCounterTwoValue(void)
{
    _asm
    {
        mov eax, g_dwTlsIndexSize       // Load TLS slot offset
        add eax, fs:[PcTeb]             // Load pointer to TLS slot
        mov eax, [eax]                  // Load Data pointer from TLS slot
        je NoSample                     // If NULL, skip

        mov edx, dword ptr [eax+0x0c]   // High wors of # bytes
        mov eax, dword ptr [eax+0x08]   // Low word of # bytes

        ret
    NoSample:
        mov eax, 0
        mov edx, 0

        ret
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\ahui\ids.h ===
#ifndef __APPHELP_IDS
#define __APPHELP_IDS

#define IDS_APPCOMPATWIN95H         1000
#define IDS_APPCOMPATWIN95          1001
#define IDS_APPCOMPATWIN95L         1002
#define IDS_APPCOMPATWIN95R         1003
#define IDS_APPCOMPAT_CANCEL        1004
#define IDS_APPCOMPAT_RUNCANCEL     1005

#define IDC_WORKED                  1100
#define IDC_NOTWORKING              1101


#define DLG_APPCOMPAT               2000
#define DLG_FEEDBACK                2100

#define IDD_STATE                   2001
#define IDD_RICHTEXT                2002
#define IDD_LINE_1                  2003
#define IDD_DETAILS                 2004
#define IDD_ICON                    2005
#define IDD_ICON_TRASH              2006
#define IDD_APPNAME                 2007
#define IDD_CONTACT                 2008
#define IDD_LINE_2                  2009
#define IDD_APPHELP_DETAILS         2010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\ahui\ahmsg.h ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    ahmsg.mc

  Abstract:

    Contains message definitions
    for event logging.

  Notes:

    DO NOT change the order of the MessageIds.
    The event log service uses these numbers
    to determine which strings to pull from
    the EXE. If the user has installed a previous
    package on the PC and these get changed,
    their event log entries will break.

  History:

    10/22/2001      dmunsil  Created

--*/
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ID_APPHELP_TRIGGERED
//
// MessageText:
//
//  A compatibility warning message was triggered on launch of application '%1'.
//
#define ID_APPHELP_TRIGGERED             ((DWORD)0x40000001L)

//
// MessageId: ID_APPHELP_BLOCK_TRIGGERED
//
// MessageText:
//
//  A compatibility error message was triggered on launch of application '%1' and the application was not allowed to launch.
//
#define ID_APPHELP_BLOCK_TRIGGERED       ((DWORD)0x40000002L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\apphelp\check.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        check.c

    Abstract:

        This module implements the main API that CreateProcess
        calls to check if an EXE is shimmed or apphelpped.

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        clupu      cleanup                                12/27/2000
        andyseti   added ApphelpCheckExe                  03/29/2001
        andyseti   added ApphelpCheckInstallShieldPackage 06/28/2001
--*/

#include "apphelp.h"
#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>

static  const WCHAR ShimEngine_ModuleName[]         = L"Shimeng.dll";
static  const CHAR  DynamicShimProcedureName[]      = "SE_DynamicShim";
static  const CHAR  DynamicUnshimProcedureName[]    = "SE_DynamicUnshim";

typedef BOOL (WINAPI *_pfn_SE_DynamicShim)(LPCWSTR , HSDB , SDBQUERYRESULT*, LPCSTR, LPDWORD);
typedef BOOL (WINAPI *_pfn_SE_DynamicUnshim)(DWORD);

typedef struct tagEXE_DYN_SHIM_INFO {
    LIST_ENTRY  entry;
    LPWSTR      pwszFullPath;    // full path to the executable.
    DWORD       dwToken;          // the dynamic shimming token associated with this exe.
} EXE_DYN_SHIM_INFO, *PEXE_DYN_SHIM_INFO;

LIST_ENTRY g_ExeDynShimInfoList;

BOOL
AddExeDynShimInfoToList(
    IN LPCWSTR pwszFullPath,
    IN DWORD   dwToken
    );

BOOL
RemoveExeDynShimInfoFromList(
    IN LPCWSTR pwszFullPath
    );

extern HINSTANCE ghInstance;

//
// Prototypes of internal functions
//
void
GetExeNTVDMData(
    IN  HSDB hSDB,                  // the SDB context
    IN  PSDBQUERYRESULT psdbQuery,  // the EXEs and LAYERs that are active
    OUT WCHAR* pszCompatLayer,      // The new compat layer variable. with format:
                                    // "Alpha Bravo Charlie"
    OUT PNTVDM_FLAGS pFlags         // The flags
    );


//
// Appcompat Infrastructure disable-via-policy-flag
//
DWORD gdwInfrastructureFlags; // initialized to 0

#define APPCOMPAT_INFRA_DISABLED   0x00000001
#define APPCOMPAT_INFRA_VALID_FLAG 0x80000000

#define IsAppcompatInfrastructureDisabled() \
    (!!( (gdwInfrastructureFlags & APPCOMPAT_INFRA_VALID_FLAG) ? \
        (gdwInfrastructureFlags & APPCOMPAT_INFRA_DISABLED) : \
        (CheckAppcompatInfrastructureFlags() & APPCOMPAT_INFRA_DISABLED)) )


DWORD
CheckAppcompatInfrastructureFlags(
    VOID
    );


#if DBG

BOOL
bDebugChum(
    void
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Checks an env var. If the var is present return TRUE.
--*/
{
    UNICODE_STRING ustrDebugChum;
    UNICODE_STRING ustrDebugChumVal = { 0 };
    NTSTATUS       Status;

    RtlInitUnicodeString(&ustrDebugChum, L"DEBUG_OFFLINE_CONTENT");

    Status = RtlQueryEnvironmentVariable_U(NULL,
                                           &ustrDebugChum,
                                           &ustrDebugChumVal);

    if (Status == STATUS_BUFFER_TOO_SMALL) {
        return TRUE;
    }

    return FALSE;
}

#else // DBG
    #define bDebugChum() TRUE
#endif // DBG

BOOL
GetExeID(
    IN  PDB   pdb,              // the pointer to the database
    IN  TAGID tiExe,            // the TAGID of the EXE for which we need the ID
    OUT GUID* pGuid             // will receive the EXE's ID
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Reads the EXE's ID from the database using the EXE's tag id.
--*/
{
    TAGID tiExeID;

    tiExeID = SdbFindFirstTag(pdb, tiExe, TAG_EXE_ID);

    if (tiExeID == TAGID_NULL) {
        DBGPRINT((sdlError, "GetExeID", "EXE tag 0x%x without an ID !\n", tiExe));
        return FALSE;
    }

    if (!SdbReadBinaryTag(pdb, tiExeID, (PBYTE)pGuid, sizeof(*pGuid))) {
        DBGPRINT((sdlError, "GetExeID", "Cannot read the ID for EXE tag 0x%x.\n", tiExe));
        return FALSE;
    }

    return TRUE;
}


BOOL
GetExeIDByTagRef(
    IN  HSDB   hSDB,            // handle to the database object
    IN  TAGREF trExe,           // EXE tag ref
    OUT GUID*  pGuid            // will receive the EXE's ID
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Reads the EXE's ID from the database using the EXE's tag ref.
--*/
{
    PDB   pdb;
    TAGID tiExe;
    TAGID tiExeID;

    if (!SdbTagRefToTagID(hSDB, trExe, &pdb, &tiExe)) {
        DBGPRINT((sdlError,
                  "GetExeIDByTagRef",
                  "Failed to get the tag id from EXE tag ref 0x%x.\n",
                  tiExe));
        return FALSE;
    }

    return GetExeID(pdb, tiExe, pGuid);
}



#define APPHELP_CLSID_REG_PATH  L"\\Registry\\Machine\\Software\\Classes\\CLSID\\"
#define APPHELP_INPROCSERVER32  L"\\InProcServer32"

DWORD
ResolveCOMServer(
    IN  REFCLSID    CLSID,
    OUT LPWSTR      lpPath,
    OUT DWORD       dwBufSize)
{
    DWORD                           dwReqBufSize = 0;
    UNICODE_STRING                  ustrKey = { 0 };
    UNICODE_STRING                  ustrValueName = { 0 };
    UNICODE_STRING                  ustrGuid = { 0 };
    UNICODE_STRING                  ustrUnexpandedValue = { 0 };
    UNICODE_STRING                  ustrValue = { 0 };
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle = NULL;
    PKEY_VALUE_FULL_INFORMATION     pKeyValueInfo = NULL;
    DWORD                           dwKeyValueInfoSize = 0;
    DWORD                           dwKeyValueInfoReqSize = 0;
    LPWSTR                          wszCLSIDRegFullPath = NULL;
    DWORD                           dwCLSIDRegFullPathSize = 0;
    WCHAR                           wszCLSID[41] = { 0 };

    // Enough for path + CLSID in string form
    dwCLSIDRegFullPathSize = wcslen(APPHELP_CLSID_REG_PATH) +
                             wcslen(APPHELP_INPROCSERVER32) + 64;

    wszCLSIDRegFullPath = RtlAllocateHeap(
                            RtlProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwCLSIDRegFullPathSize * sizeof(WCHAR));

    if (wszCLSIDRegFullPath == NULL) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Memory allocation failure\n"));
        goto Done;
    }

    StringCchCopyW(wszCLSIDRegFullPath, dwCLSIDRegFullPathSize, APPHELP_CLSID_REG_PATH);

    Status = RtlStringFromGUID(CLSID, &ustrGuid);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Malformed CLSID\n"));
        goto Done;
    }

    if (ustrGuid.Length/sizeof(WCHAR) > 40) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "CLSID more than 40 characters\n"));
        goto Done;
    }

    RtlMoveMemory(wszCLSID,
                  ustrGuid.Buffer,
                  ustrGuid.Length);

    wszCLSID[ustrGuid.Length/sizeof(WCHAR)] = L'\0';

    StringCchCatW(wszCLSIDRegFullPath, dwCLSIDRegFullPathSize, wszCLSID);
    StringCchCatW(wszCLSIDRegFullPath, dwCLSIDRegFullPathSize, APPHELP_INPROCSERVER32);

    RtlInitUnicodeString(&ustrKey, wszCLSIDRegFullPath);
    RtlInitUnicodeString(&ustrValueName, L"");

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       GENERIC_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Failed to open Key \"%s\" Status 0x%x\n",
                  wszCLSIDRegFullPath,
                  Status));
        goto Done;
    }

    if (lpPath == NULL &&
        dwBufSize != 0) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Bad parameters\n"));
        goto Done;
    }

    pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    dwBufSize * 2);

    if (pKeyValueInfo == NULL) {
        DBGPRINT((sdlInfo,
                  "SdbResolveCOMServer",
                  "Memory allocation failure\n"));
        goto Done;
    }

    dwKeyValueInfoSize = dwBufSize * 2;

    Status = NtQueryValueKey(KeyHandle,
                             &ustrValueName,
                             KeyValueFullInformation,
                             pKeyValueInfo,
                             dwKeyValueInfoSize,
                             &dwKeyValueInfoReqSize);

    if (!NT_SUCCESS(Status)) {

        if (Status == STATUS_BUFFER_TOO_SMALL) {

            RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);

            pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            dwKeyValueInfoReqSize);

            if (pKeyValueInfo == NULL) {
                DBGPRINT((sdlInfo,
                          "SdbResolveCOMServer",
                          "Memory allocation failure\n"));
                goto Done;
            }

            dwKeyValueInfoSize = dwKeyValueInfoReqSize;

            Status = NtQueryValueKey(KeyHandle,
                                     &ustrValueName,
                                     KeyValueFullInformation,
                                     pKeyValueInfo,
                                     dwKeyValueInfoSize,
                                     &dwKeyValueInfoReqSize);

            if (!NT_SUCCESS(Status)) {
                DBGPRINT((sdlInfo,
                          "SdbResolveCOMServer",
                          "Failed to retrieve default key value for \"%s\" Status 0x%x\n",
                          wszCLSIDRegFullPath,
                          Status));
                goto Done;
            }

        } else {
            DBGPRINT((sdlInfo,
                      "SdbResolveCOMServer",
                      "Failed to retrieve default key value for \"%s\" Status 0x%x\n",
                      wszCLSIDRegFullPath,
                      Status));
            goto Done;
        }
    }

    if (pKeyValueInfo->Type == REG_SZ) {
        dwReqBufSize = pKeyValueInfo->DataLength + (1 * sizeof(WCHAR));

        if (dwBufSize >= dwReqBufSize) {
            RtlMoveMemory(lpPath, ((PBYTE) pKeyValueInfo) + pKeyValueInfo->DataOffset, pKeyValueInfo->DataLength);
            lpPath[pKeyValueInfo->DataLength / sizeof(WCHAR)] = '\0';
        }

    } else if (pKeyValueInfo->Type == REG_EXPAND_SZ) {
        ustrUnexpandedValue.Buffer = (PWSTR) (((PBYTE) pKeyValueInfo) + pKeyValueInfo->DataOffset);
        ustrUnexpandedValue.Length = (USHORT) pKeyValueInfo->DataLength;
        ustrUnexpandedValue.MaximumLength = (USHORT) pKeyValueInfo->DataLength;
        ustrValue.Buffer = lpPath;
        ustrValue.Length = 0;
        ustrValue.MaximumLength = (USHORT) dwBufSize;
        Status = RtlExpandEnvironmentStrings_U(NULL,
                                               &ustrUnexpandedValue,
                                               &ustrValue,
                                               &dwReqBufSize);

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            goto Done;
        } else if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlInfo,
                      "SdbResolveCOMServer",
                      "Failed to expand key value for \"%s\" Status 0x%x\n",
                      wszCLSIDRegFullPath,
                      Status));
            goto Done;
        }
    }

    DBGPRINT((sdlInfo,
              "SdbResolveCOMServer",
              "CLSID %s resolved to \"%s\"\n",
              wszCLSID, lpPath));

Done:

    if (KeyHandle != NULL) {
        NtClose(KeyHandle);
    }

    if (wszCLSIDRegFullPath != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, wszCLSIDRegFullPath);
    }

    if (pKeyValueInfo != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);
    }

    if (ustrGuid.Buffer != NULL) {
        RtlFreeUnicodeString(&ustrGuid);
    }

    return dwReqBufSize;
}

VOID
ParseSdbQueryResult(
    IN HSDB            hSDB,
    IN PSDBQUERYRESULT pQuery,
    OUT TAGREF*        ptrAppHelp,      // apphelp tagref, optional
    OUT PAPPHELP_DATA  pApphelpData,    // apphelp data, optional
    OUT TAGREF*        ptrSxsData       // fusion tagref, optional
    )
{
    DWORD dwIndex;
    BOOL  bAppHelp   = FALSE;
    BOOL  bFusionFix = FALSE;
    TAGREF trExe;
    TAGREF trAppHelp = TAGREF_NULL;
    TAGREF trSxsData = TAGREF_NULL;

    //
    // scan matching exes; we extract fusion fix (the first one we find) and apphelp data,
    // also the first one we find
    //

    for (dwIndex = 0; dwIndex < pQuery->dwExeCount; ++dwIndex) {
        trExe = pQuery->atrExes[dwIndex];
        if (ptrAppHelp != NULL && !bAppHelp) {
            bAppHelp = SdbReadApphelpData(hSDB, trExe, pApphelpData);
            if (bAppHelp) {
                trAppHelp = trExe;
                if (ptrSxsData == NULL || bFusionFix) {
                    break;
                }
            }
        }

        // see if we have sxs fix as well
        if (ptrSxsData != NULL && !bFusionFix) {
            bFusionFix = GetExeSxsData(hSDB, trExe, NULL, NULL);
            if (bFusionFix) {
                trSxsData = trExe;
            }
            if (bFusionFix && (ptrAppHelp == NULL || bAppHelp)) {
                break;
            }
        }
    }

    if (ptrAppHelp != NULL) {
        *ptrAppHelp = trAppHelp;
    }

    if (ptrSxsData != NULL) {
        *ptrSxsData = trSxsData;
    }
}

BOOL
InternalCheckRunApp(
    IN  HANDLE   hFile,          // [Optional] Handle to an open file to check
    IN  LPCWSTR  pwszPath,       // path to the app in NT format
    IN  LPCWSTR  pEnvironment,   // pointer to the environment of the process that is
                                 // being created or NULL.
    IN  USHORT   uExeType,       // executable's image type
    IN OUT PDWORD pdwReason,      // collection of flags hinting at why we were called
    OUT PVOID*   ppData,         // this will contain the pointer to the allocated buffer
                                 // containing the appcompat data.
    OUT PDWORD   pcbData,        // if appcompat data is found, the size of the buffer
                                 // is returned here.
    OUT PVOID*   ppSxsData,      // out: Sxs data block from the compatibility database
    OUT PDWORD   pcbSxsData,     // out: sxs data block size
    OUT PDWORD   pdwFusionFlags, // out: flags for sxs
    IN  BOOL     bNTVDMMode,     // Are we doing the special NTVDM stuff?

    IN  LPCWSTR  szModuleName,   // the module name (for NTVDM only)

    OUT LPWSTR   pszCompatLayer, // The new compat layer variable. with format:
                                 // "__COMPAT_LAYER=Alpha Bravo Charlie"
    OUT PNTVDM_FLAGS  pFlags,    // The flags
    OUT PAPPHELP_INFO pAHInfo,   // If there is apphelp to display, this will be filled
                                 // in with non-null values
    OUT HSDB*    phSDB,          // The handle to the database.
    OUT PSDBQUERYRESULT pQueryResult // The query result.
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   This is the main API of apphelp.dll. It is called from CreateProcess
            to retrieve application compatibility information for the current process.

            This function does not check whether the appcompat infrastructure has been
            disabled, (kernel32 checks that)

--*/
{

    APPHELP_DATA    ApphelpData;
    BOOL            bSuccess;
    BOOL            bRunApp             = TRUE; // run by default
    BOOL            bAppHelp            = FALSE;
    WCHAR*          pwszDosPath         = NULL;
    BOOL            bBypassCache        = FALSE;    // this is set if cache bypass occured (as opposed to entry not being found
    BOOL            bGetSxsData         = TRUE;
    BOOL            bFusionFix          = FALSE;
    HSDB            hSDB                = NULL;
    SDBQUERYRESULT  sdbQuery;
    PSDBQUERYRESULT pSdbQuery           = NULL;
    NTSTATUS        Status;
    TAGREF          trAppHelp           = TAGREF_NULL;
    TAGREF          trFusionFix         = TAGREF_NULL;
    ULARGE_INTEGER  uliFusionFlags      = {0};

    UNICODE_STRING  ExePath;
    RTL_UNICODE_STRING_BUFFER DosPathBuffer;
    UCHAR BufferPath[MAX_PATH*2];

    if (phSDB) {
        *phSDB = NULL;
    }

    if (pQueryResult) {
        pSdbQuery = pQueryResult;
    } else {
        pSdbQuery = &sdbQuery;
    }

    RtlZeroMemory(pSdbQuery, sizeof(sdbQuery));
    RtlInitUnicodeStringBuffer(&DosPathBuffer, BufferPath, sizeof(BufferPath));

    RtlInitUnicodeString(&ExePath, pwszPath);

    Status = RtlAssignUnicodeStringBuffer(&DosPathBuffer, &ExePath);
    if (NT_SUCCESS(Status)) {
        Status = RtlNtPathNameToDosPathName(0, &DosPathBuffer, NULL, NULL);
    }

    if (!NT_SUCCESS(Status)) {
        DBGPRINT((sdlError, "InternalCheckRunApp", "Failed to convert path \"%S\" to DOS.\n", pwszPath));
        goto Done;
    }

    //
    // we have been successful, this is 0-terminated dos path
    //
    pwszDosPath = DosPathBuffer.String.Buffer;

    //
    // Cache lookup was bypassed by one reason or the other.
    // We do not update cache after it had been bypassed.
    //
    if (pdwReason) {
        bBypassCache = !!(*pdwReason & SHIM_CACHE_BYPASS);
    } else {
        bBypassCache = TRUE;
    }

    hSDB = SdbInitDatabaseEx(0, NULL, uExeType);

    if (phSDB) {
        *phSDB = hSDB;
    }

    if (hSDB == NULL) {
        DBGPRINT((sdlError,
                  "InternalCheckRunApp",
                  "Failed to initialize the database.\n"));
        goto Done;
    }

    //
    // We didn't find this EXE in the cache. Query the database
    // to get all the info about this EXE.
    //
    SdbGetMatchingExe(hSDB, pwszDosPath, szModuleName, pEnvironment, 0, pSdbQuery);

    if (pSdbQuery->dwFlags & SHIMREG_DISABLE_SXS) {
        bGetSxsData = FALSE;
    }

    //
    // get the flags for fusion.
    //
    SdbQueryFlagMask(hSDB, pSdbQuery, TAG_FLAG_MASK_FUSION, &uliFusionFlags.QuadPart, NULL);

    if (pdwFusionFlags) {
        *pdwFusionFlags = (DWORD)uliFusionFlags.QuadPart;
    }


    //
    // find apphelp/and/or Fusion fix
    //
    ParseSdbQueryResult(hSDB,
                        pSdbQuery,
                        &trAppHelp,
                        &ApphelpData,
                        bGetSxsData ? &trFusionFix : NULL);

    bAppHelp = (trAppHelp != TAGREF_NULL);

    if (bAppHelp) {

        //
        // Check whether the disable bit is set (the dwFlags has been retrieved from the
        // registry via the SdbReadApphelpData call)
        //
        if (!(pSdbQuery->dwFlags & SHIMREG_DISABLE_APPHELP)) {

            BOOL bNoUI;

            //
            // See whether the user has checked "Don't show this anymore" box before.
            //
            bNoUI = ((pSdbQuery->dwFlags & SHIMREG_APPHELP_NOUI) != 0);

            if (bNoUI) {
                DBGPRINT((sdlInfo,
                          "InternalCheckRunApp",
                          "NoUI flag is set, apphelp UI disabled for this app.\n"));
            }

            //
            // Depending on severity of the problem...
            //
            switch (ApphelpData.dwSeverity) {
            case APPHELP_MINORPROBLEM:
            case APPHELP_HARDBLOCK:
            case APPHELP_NOBLOCK:
            case APPHELP_REINSTALL:

                //
                // NTVDM needs the severity info.
                //

                if (pAHInfo) {
                    pAHInfo->dwSeverity = ApphelpData.dwSeverity;
                }

                if (bNoUI) {
                    bRunApp = (ApphelpData.dwSeverity != APPHELP_HARDBLOCK);
                } else {
                    DWORD dwRet;


                    //
                    // We need to show apphelp -- pack up the info
                    // so we can hand it off to shimeng or ntvdm.
                    //
                    pSdbQuery->trAppHelp = trAppHelp;

                    if (pAHInfo) {
                        PDB   pdb;
                        TAGID tiWhich;

                        if (SdbTagRefToTagID(hSDB, trAppHelp, &pdb, &tiWhich)) {
                            if (SdbGetDatabaseGUID(hSDB, pdb, &(pAHInfo->guidDB))) {
                                pAHInfo->tiExe = tiWhich;
                            }
                        }
                    }

                    bRunApp = TRUE;
                }
                break;

            default:
                //
                // Some other case was found (e.g. VERSIONSUB which should be replaced
                // by shims in most cases).
                //
                DBGPRINT((sdlWarning,
                          "InternalCheckRunApp",
                          "Unhandled severity flag 0x%x.\n",
                          ApphelpData.dwSeverity));
                break;
            }
        }
    }

    //
    // Apphelp verification is done. Check for shims if we should still run the app.
    //
    if (bRunApp) {

        if (ppData &&
            (pSdbQuery->atrExes[0] != TAGREF_NULL ||
             pSdbQuery->atrLayers[0] != TAGREF_NULL ||
             pSdbQuery->trAppHelp)) {
            //
            // There are shims for this EXE. Pack the appcompat data
            // so it can be sent to ntdll in the context of the starting EXE.
            //
            SdbPackAppCompatData(hSDB, pSdbQuery, ppData, pcbData);
        }

        if (ppSxsData && bGetSxsData && trFusionFix != TAGREF_NULL) {
            //
            // See if we have Fusion data to report.
            //
            GetExeSxsData(hSDB, trFusionFix, ppSxsData, pcbSxsData);
            bFusionFix = (ppSxsData != NULL && *ppSxsData != NULL);
        }

        if (bNTVDMMode) {
            GetExeNTVDMData(hSDB, pSdbQuery, pszCompatLayer, pFlags);
        }
    }

    //
    // Update the cache now.
    //
    if (!bBypassCache) {
        //
        // Do not update the cache if we got the EXE entry from a local database.
        //
        bBypassCache = (pSdbQuery->atrExes[0] != TAGREF_NULL &&
                        !SdbIsTagrefFromMainDB(pSdbQuery->atrExes[0]));
    }

    if (!bBypassCache) {

        //
        // We remove from cache only if we have some appcompat data
        //
        BOOL
        bCleanApp = pSdbQuery->atrExes[0] == TAGREF_NULL &&
                    pSdbQuery->atrLayers[0] == TAGREF_NULL &&
                    !bAppHelp &&
                    pSdbQuery->dwFlags == 0 &&
                    !bFusionFix;

        if (hFile != INVALID_HANDLE_VALUE) {
            *pdwReason |= SHIM_CACHE_ACTION;
            if (bCleanApp) {
                *pdwReason |= SHIM_CACHE_UPDATE;
            }
        }
    }

Done:

    RtlFreeUnicodeStringBuffer(&DosPathBuffer);

    //
    // NTVDM needs to have the database handle open.
    //
    if (!bNTVDMMode) {
        if (hSDB != NULL) {
            SdbReleaseDatabase(hSDB);
        }
    }

    return bRunApp;
}


BOOL
ApphelpQueryExe(
    IN  HSDB            hSDB,
    IN  LPCWSTR         pwszPath,            // Unicode path to the executable (DOS_PATH)
    IN  BOOL            bAppHelpIfNecessary, // Produce AppHelp dialog if necessary
    IN  DWORD           dwGetMatchingExeFlags,
    OUT SDBQUERYRESULT* pQueryResult         // Shim Database Query Result
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   This function is similar with ApphelpCheckRunApp but without validating
            cache and Layer flags and doesn't return application compatibility
            information for given app name. It is intended to be called from
            a shim / user mode to verify whether an executable is allowed to run or not.

--*/
{
    BOOL   bRunApp   = TRUE; // run by default
    DWORD  dwDatabaseType = 0;
    DWORD  dwSeverity     = 0;
    TAGREF trAppHelp = TAGREF_NULL;

    HAPPHELPINFOCONTEXT hApphelpInfoContext = NULL;

    //
    // Query the database to get all the info about this EXE.
    // Note:
    //   This function is intended to be called from user mode.
    //   It doesn't require a call to ConvertToDosPath to string \??\ from the filepath.
    //
    DBGPRINT((sdlInfo,
              "ApphelpCheckExe",
              "Calling SdbGetMatchingExe for \"%s\"\n",
              pwszPath));

    SdbGetMatchingExe(hSDB, pwszPath, NULL, NULL, dwGetMatchingExeFlags, pQueryResult);


    //
    // get info out of the query
    //
    ParseSdbQueryResult(hSDB,
                        pQueryResult,
                        &trAppHelp,
                        NULL,       // Apphelp Information api is used here
                        NULL);      // no sxs fixes are needed


    //
    // The last EXE in the list is always the more specific one, and the one we want to
    // use for checking IDs and flags and whatnot.
    //
    if (trAppHelp != TAGREF_NULL) {
        //
        // Read the apphelp data if available for this EXE.
        //
        if (SdbIsTagrefFromMainDB(trAppHelp)) {
            dwDatabaseType |= SDB_DATABASE_MAIN;
        }

        hApphelpInfoContext = SdbOpenApphelpInformationByID(hSDB,
                                                            trAppHelp,
                                                            dwDatabaseType);
    }

    //
    // Check whether the disable bit is set (the dwFlags has been retrieved from the
    // registry via the SdbReadApphelpData call)
    //
    if (hApphelpInfoContext != NULL) {
        if (!(pQueryResult->dwFlags & SHIMREG_DISABLE_APPHELP)) {
            BOOL bNoUI;

            //
            // See whether the user has checked "Don't show this anymore" box before.
            //
            bNoUI = ((pQueryResult->dwFlags & SHIMREG_APPHELP_NOUI) != 0);

            if (bNoUI) {
                DBGPRINT((sdlInfo,
                          "ApphelpCheckExe",
                          "NoUI flag is set, apphelp UI disabled for this app.\n"));
            }


            SdbQueryApphelpInformation(hApphelpInfoContext,
                                       ApphelpProblemSeverity,
                                       &dwSeverity,
                                       sizeof(dwSeverity));

            if (!bAppHelpIfNecessary) {
                bNoUI = TRUE;
            }

            //
            // depending on severity of the problem...
            //
            switch (dwSeverity) {
            case APPHELP_MINORPROBLEM:
            case APPHELP_HARDBLOCK:
            case APPHELP_NOBLOCK:
            case APPHELP_REINSTALL:
                bRunApp = (dwSeverity != APPHELP_HARDBLOCK);

                if (!bNoUI) {
                    DWORD dwRet;
                    APPHELP_INFO AHInfo = { 0 };

                    SdbQueryApphelpInformation(hApphelpInfoContext,
                                               ApphelpDatabaseGUID,
                                               &AHInfo.guidDB,
                                               sizeof(AHInfo.guidDB));

                    SdbQueryApphelpInformation(hApphelpInfoContext,
                                               ApphelpExeTagID,
                                               &AHInfo.tiExe,
                                               sizeof(AHInfo.tiExe));
                    AHInfo.bOfflineContent = bDebugChum();
                    SdbShowApphelpDialog(&AHInfo,
                                         NULL,
                                         &bRunApp); // either we succeeded or bInstall package is treated
                                                    // the same way as No UI
                }
                break;
            default:
                //
                // Some other case was found (e.g. VERSIONSUB which should be replaced
                // by shims in most cases).
                //
                DBGPRINT((sdlWarning,
                          "ApphelpCheckExe",
                          "Unhandled severity flag 0x%x.\n",
                          dwSeverity));
                break;
            }
        }
    }

    //
    // Apphelp verification is done.
    //

    if (hApphelpInfoContext != NULL) {
        SdbCloseApphelpInformation(hApphelpInfoContext);
    }

    return bRunApp;
}


/*++
// This code was used to check for include/exclude list in the database
// to eliminate confusion entries should ALWAYS provide the list
//
// CheckIncludeExcludeList
// returns: TRUE  - database provides the list
//          FALSE - no list is provided in the database
//

BOOL
CheckIncludeExcludeList(
    IN HSDB hSDB,
    IN SDBQUERYRESULT* pQueryResult
    )
{
    INT i;
    TAGREF trExe;
    TAGREF trFix;
    TAGREF trInexclude;

    for (i = 0; i < SDB_MAX_EXES && pQueryResult->atrExes[i] != TAGREF_NULL; ++i) {
        trExe  = pQueryResult->atrExes[i];
        trFix = SdbFindFirstTagRef(hSDB, trExe, TAG_SHIM_REF);
        while (trFix != TAGREF_NULL) {
            trInexclude = SdbFindFirstTagRef(hSDB, trFix, TAG_INEXCLUDE);
            if (trInexclude != TAGREF_NULL) {
                return TRUE;
            }

            trFix = SdbFindNextTagRef(hSDB, trExe, trFix);
        }
    }

    //
    // layers have their own inclusion/exclusion scheme
    //
    return FALSE;

}

--*/

BOOL
AddExeDynShimInfoToList(
    IN LPCWSTR pwszFullPath,
    IN DWORD   dwToken
    )
{
    BOOL                bResult = FALSE;
    PEXE_DYN_SHIM_INFO  pDynShimInfo = NULL;
    DWORD               dwLen = 0;
    static BOOL         bInitialized = FALSE;

    if (pwszFullPath == NULL) {
        return TRUE;
    }

    RtlEnterCriticalSection(&g_csDynShimInfo);

    if (!bInitialized) {
        bInitialized = TRUE;
        InitializeListHead(&g_ExeDynShimInfoList);
    }

    pDynShimInfo =
        RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof (EXE_DYN_SHIM_INFO));

    if (pDynShimInfo == NULL) {
        DBGPRINT((sdlError,"AddExeDynShimInfoToList",
            "Failed to allocate a new dynamic shim info entry for %s\n",
            pwszFullPath));
        goto Done;
    }

    dwLen = wcslen(pwszFullPath) + 1;

    pDynShimInfo->pwszFullPath =
        RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, dwLen * sizeof(WCHAR));

    if (pDynShimInfo->pwszFullPath == NULL) {
        DBGPRINT((sdlError,"AddExeDynShimInfoToList",
            "Failed to allocate a new dynamic shim info entry for %s\n",
            pwszFullPath));
        goto Done;
    }

    StringCchCopyW(pDynShimInfo->pwszFullPath, dwLen, pwszFullPath);
    pDynShimInfo->dwToken = dwToken;

    InsertHeadList(&g_ExeDynShimInfoList, &pDynShimInfo->entry);

    DBGPRINT((sdlInfo,"AddExeDynShimInfoToList",
              "Added %s(token: %d) to the list\n",
              pwszFullPath,
              dwToken));

    bResult = TRUE;

Done:

    if (!bResult) {
        if (pDynShimInfo) {

            if (pDynShimInfo->pwszFullPath) {
                RtlFreeHeap(RtlProcessHeap(), 0, pDynShimInfo->pwszFullPath);
            }

            RtlFreeHeap(RtlProcessHeap(), 0, pDynShimInfo);
        }
    }

    RtlLeaveCriticalSection(&g_csDynShimInfo);

    return bResult;
}

BOOL
RemoveExeDynShimInfoFromList(
    IN LPCWSTR pwszFullPath
    )
{
    BOOL                    bResult = FALSE;
    _pfn_SE_DynamicUnshim   pfnDynamicUnshim = NULL;
    HMODULE                 hmodShimEngine = 0;
    PEXE_DYN_SHIM_INFO      pDynShimInfo = NULL;
    PLIST_ENTRY             pEntry, pTempEntry;
    PLIST_ENTRY             pHead = &g_ExeDynShimInfoList;

    if (pwszFullPath == NULL) {
        return TRUE;
    }

    hmodShimEngine = LoadLibraryW(ShimEngine_ModuleName);

    if (hmodShimEngine == NULL) {
        DBGPRINT((sdlError,"RemoveExeDynShimInfoFromList",
                  "Failed to get ShimEngine module handle.\n"));
        goto Done;
    }

    pfnDynamicUnshim = (_pfn_SE_DynamicUnshim) GetProcAddress(hmodShimEngine, DynamicUnshimProcedureName);

    if (NULL == pfnDynamicUnshim) {
        DBGPRINT((sdlError,
                  "RemoveExeDynShimInfoFromList",
                  "Failed to get Dynamic Shim procedure address from ShimEngine module.\n"));
        goto Done;
    }

    RtlEnterCriticalSection(&g_csDynShimInfo);

    pEntry = pHead->Flink;

    while (pEntry != pHead) {

        pDynShimInfo = CONTAINING_RECORD(pEntry, EXE_DYN_SHIM_INFO, entry);

        if (_wcsicmp(pDynShimInfo->pwszFullPath, pwszFullPath) == 0) {

            pTempEntry = pEntry->Flink;
            RemoveEntryList(pEntry);

            if (!(*pfnDynamicUnshim)(pDynShimInfo->dwToken)) {
                DBGPRINT((sdlInfo,"RemoveExeDynShimInfoFromList",
                        "Unshimming %s(token: %d) failed\n",
                        pwszFullPath,
                        pDynShimInfo->dwToken));

                bResult = FALSE;
                break;
            }

            DBGPRINT((sdlInfo,"RemoveExeDynShimInfoFromList",
                      "Removed %s(token: %d) from the list\n",
                      pwszFullPath,
                      pDynShimInfo->dwToken));

            RtlFreeHeap(RtlProcessHeap(), 0, pDynShimInfo->pwszFullPath);
            RtlFreeHeap(RtlProcessHeap(), 0, pDynShimInfo);

            bResult = TRUE;

            //
            // We need to remove all the entries for this exe so keep going.
            //
            pEntry = pTempEntry;
        } else {
            pEntry = pEntry->Flink;
        }
    }

    RtlLeaveCriticalSection(&g_csDynShimInfo);

Done:

    return bResult;
}

BOOL
ApphelpFixExe(
    IN  HSDB            hSDB,
    IN  LPCWSTR         pwszPath,       // Unicode path to the executable (DOS_PATH)
    IN  SDBQUERYRESULT* pQueryResult,   // QueryResult
    IN  BOOL            bUseModuleName  // if false, module name is not used for dynamic shimming
    )
{
    static  _pfn_SE_DynamicShim     pfnDynamicShim = NULL;

    HMODULE         hmodShimEngine = 0;
    BOOL            bResult = FALSE;
    ANSI_STRING     AnsiModuleName = { 0 };
    UNICODE_STRING  UnicodeModuleName;
    NTSTATUS        Status;
    LPCSTR          pszModuleName = NULL;
    LPCWSTR         pwszModuleName;
    DWORD           dwDynamicToken = 0;

    //
    // Do we need to do anything?
    //
    if (pQueryResult->atrExes[0] == TAGREF_NULL &&
        pQueryResult->atrLayers[0] == TAGREF_NULL) {
        //
        // Nothing for the shim engine to do.
        //
        bResult = TRUE;
        goto Done;
    }

    //
    // Load additional shims for this exe.
    //
    DBGPRINT((sdlInfo,"ApphelpFixExe", "Loading ShimEngine for \"%s\"\n", pwszPath));

    hmodShimEngine = LoadLibraryW(ShimEngine_ModuleName);

    if (hmodShimEngine == NULL) {
        DBGPRINT((sdlError,"ApphelpFixExe", "Failed to get ShimEngine module handle.\n"));
        goto Done;
    }

    pfnDynamicShim = (_pfn_SE_DynamicShim) GetProcAddress(hmodShimEngine, DynamicShimProcedureName);

    if (NULL == pfnDynamicShim) {
        DBGPRINT((sdlError,
                  "ApphelpFixExe",
                  "Failed to get Dynamic Shim procedure address from ShimEngine module.\n"));
        goto Done;
    }

    //
    // check inclusion/exclusion list
    //
    if (pwszPath != NULL && bUseModuleName) {
        //
        // no inclusion/exclusion in the xml -- determine module name
        //
        pwszModuleName = wcsrchr(pwszPath, L'\\'); // last backslash please

        if (pwszModuleName == NULL) {
            pwszModuleName = pwszPath;
        } else {
            ++pwszModuleName;
        }

        //
        // convert to ansi
        //
        RtlInitUnicodeString(&UnicodeModuleName, pwszModuleName);
        Status = RtlUnicodeStringToAnsiString(&AnsiModuleName,
                                              &UnicodeModuleName,
                                              TRUE);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError, "ApphelpFixExe",
                       "Failed to convert unicode string \"%s\" to ansi, Status 0x%lx.\n",
                       pwszModuleName, Status));

            goto Done;
        }

        pszModuleName = AnsiModuleName.Buffer; // this will be allocated by RtlUnicodeStringToAnsiString

    }

    bResult = (*pfnDynamicShim)(pwszPath,
                                hSDB,
                                pQueryResult,
                                pszModuleName,
                                &dwDynamicToken);
    if (FALSE == bResult) {
        DBGPRINT((sdlError, "ApphelpFixExe", "Failed to call Dynamic Shim.\n"));
        goto Done;
    }

    if (pszModuleName == NULL) {
        if (!AddExeDynShimInfoToList(pwszPath, dwDynamicToken)) {
            DBGPRINT((sdlError, "ApphelpFixExe",
                "Failed to add %s(token: %d) to the list\n",
                pwszPath,
                dwDynamicToken));
            goto Done;
        }
    }

    bResult = TRUE;

Done:

    RtlFreeAnsiString(&AnsiModuleName); // this will do nothing if string is empty
    return bResult;
}

BOOL
ApphelpCheckExe(
    IN  LPCWSTR     pwszPath,            // Unicode path to the executable (DOS_PATH)
    IN  BOOL        bAppHelpIfNecessary, // Only present AppHelp this executable if TRUE
    IN  BOOL        bShimIfNecessary,    // Only load shim for this executable if TRUE
    IN  BOOL        bUseModuleName       // use module name when inclusion/exclusion list is not provided
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   If you are calling this API with the last parameter set to FALSE and it returns
            TRUE, you'll have to call ApphelpReleaseExe when you are done running this exe.

--*/
{
    BOOL            bRunApp = TRUE;
    SDBQUERYRESULT  QueryResult;
    HSDB            hSDB;

    if (IsAppcompatInfrastructureDisabled()) {
        goto Done;
    }

    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    hSDB = SdbInitDatabaseEx(0, NULL, IMAGE_FILE_MACHINE_I386);
    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckExe", "Failed to initialize database.\n"));
        goto Done;
    }

    bRunApp = ApphelpQueryExe(hSDB,
                              pwszPath,
                              bAppHelpIfNecessary,
                              SDBGMEF_IGNORE_ENVIRONMENT,
                              &QueryResult);

    if (TRUE == bRunApp && TRUE == bShimIfNecessary) {
        ApphelpFixExe(hSDB, pwszPath, &QueryResult, bUseModuleName);
    }

    SdbReleaseDatabase(hSDB);

Done:

    return bRunApp;
}

BOOL
ApphelpReleaseExe(
    IN LPCWSTR pwszPath // Unicode path to the executable (DOS_PATH)
    )
{
    return RemoveExeDynShimInfoFromList(pwszPath);
}

BOOL
ApphelpCheckIME(
    IN LPCWSTR pwszPath            // Unicode path to the exe
    )
{
    BOOL            bRunApp = TRUE;
    SDBQUERYRESULT  QueryResult;
    HSDB            hSDB;
    BOOL            bCleanApp;

    if (IsAppcompatInfrastructureDisabled()) {
        return TRUE;
    }

    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckIME", "Failed to initialize database.\n"));
        goto Done;
    }

    bRunApp = ApphelpQueryExe(hSDB,
                              pwszPath,
                              TRUE,
                              SDBGMEF_IGNORE_ENVIRONMENT,
                              &QueryResult);

    if (TRUE == bRunApp) {
        ApphelpFixExe(hSDB, pwszPath, &QueryResult, FALSE);
    }

    SdbReleaseDatabase(hSDB);

    //
    // see that it's in the cache if no fixes
    //
    bCleanApp = QueryResult.atrExes[0]   == TAGREF_NULL &&
                QueryResult.atrLayers[0] == TAGREF_NULL &&
                QueryResult.trAppHelp    == TAGREF_NULL &&
                QueryResult.dwFlags      == 0;

#ifndef WIN2K_NOCACHE

    BaseUpdateAppcompatCache(pwszPath, INVALID_HANDLE_VALUE, !bCleanApp);

#endif

Done:

    return bRunApp;
}

BOOL
ApphelpCheckShellObject(
    IN  REFCLSID    ObjectCLSID,
    IN  BOOL        bShimIfNecessary,
    OUT ULONGLONG*  pullFlags
    )
/*++
    Return: FALSE if the object should be blocked from instantiating, TRUE otherwise.

    Desc:   This is a helper function for Explorer and Internet Explorer that will
            allow those applications to detect bad extension objects and either
            block them from running or fix them.

            pullFlags is filled with a 64-bit flag mask that can be used to turn
            on 'hack' flags in Explorer/IE. These are pulled out of the App Compat
            database.

            If the database indicates that a shim should be used to fix the extension
            and bShimIfNecessary is TRUE, this function will load SHIMENG.DLL and
            apply the fix.

--*/
{
    BOOL            bGoodObject = TRUE;
    LPWSTR          szComServer = NULL;
    LPWSTR          szDLLName = NULL;
    DWORD           dwBufSize = 0;
    DWORD           dwReqBufSize = 0;
    SDBQUERYRESULT  QueryResult;
    HSDB            hSDB = NULL;
    PVOID           pModuleHandle = NULL;
    UNICODE_STRING  ustrDLLName = { 0 };
    UNICODE_STRING  ustrNtPath = { 0 };
    NTSTATUS        status;
    HANDLE          hDLL = INVALID_HANDLE_VALUE;
    DWORD           dwReason;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    if (IsAppcompatInfrastructureDisabled()) {
        return TRUE;
    }

    if (pullFlags != NULL) {
        *pullFlags = 0;
    }

    szComServer = RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);

    if (szComServer == NULL) {
        DBGPRINT((sdlInfo,"ApphelpCheckShellObject", "Memory allocation error\n"));
        goto Done;
    }

    dwBufSize = MAX_PATH;

    //
    // Turn the CLSID into a filename (ie, the DLL that serves the object)
    //
    dwReqBufSize = ResolveCOMServer(ObjectCLSID, szComServer, dwBufSize);

    if (dwReqBufSize == 0) {
        //
        // CLSID could not be resolved to a DLL.
        //
        goto Done;
    }

    if (dwReqBufSize > dwBufSize) {

        RtlFreeHeap(RtlProcessHeap(), 0, szComServer);
        szComServer = RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, dwReqBufSize);

        if (szComServer == NULL) {
            DBGPRINT((sdlInfo,"ApphelpCheckShellObject", "Memory allocation error\n"));
            goto Done;
        }

        dwBufSize = dwReqBufSize;

        dwReqBufSize = ResolveCOMServer(ObjectCLSID, szComServer, dwBufSize);

        if (dwReqBufSize > dwBufSize || dwReqBufSize == 0) {
            //
            // What? Buffer size changed. This could happen if registration of an
            // object took place between the time we first queried and the next time.
            // Just being paranoid...
            //
            DBGPRINT((sdlInfo,"ApphelpCheckShellObject", "Memory allocation error\n"));
            goto Done;
        }
    }

    //
    // Determine DLL name (w/o path). Walk back to first backslash.
    //
    szDLLName = szComServer + dwReqBufSize/sizeof(WCHAR);

    while (szDLLName >= szComServer) {
        if (*szDLLName == L'\\') {
            break;
        }

        szDLLName--;
    }

    szDLLName++;

    //
    // Check if this DLL is already loaded. If so, no need to try and do anything
    // since it's really too late anyway.
    //
    RtlInitUnicodeString(&ustrDLLName, szDLLName);

    status = LdrGetDllHandle(NULL,
                             NULL,
                             &ustrDLLName,
                             &pModuleHandle);

    if (NT_SUCCESS(status)) {
        //
        // Already loaded.
        //
        goto Done;
    }

    if (!RtlDosPathNameToNtPathName_U(szComServer,
                                      &ustrNtPath,
                                      NULL,
                                      NULL)) {
        DBGPRINT((sdlError,
                    "ApphelpCheckShellObject",
                    "RtlDosPathNameToNtPathName_U failed, path \"%s\"\n",
                    szComServer));
        goto Done;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &ustrNtPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hDLL,
                          GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DBGPRINT((sdlError,
                    "ApphelpCheckShellObject",
                    "SdbpOpenFile failed, path \"%s\"\n",
                    szComServer));
        goto Done;
    }

    if (BaseCheckAppcompatCache(ustrNtPath.Buffer, hDLL, NULL, &dwReason)) {
        //
        // We have this in cache
        //
        goto Done;
    }

    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckShellObject", "Failed to initialize database.\n"));
        goto Done;
    }

    bGoodObject = ApphelpQueryExe(hSDB,
                                  szComServer,
                                  FALSE,
                                  SDBGMEF_IGNORE_ENVIRONMENT,
                                  &QueryResult);

    if (TRUE == bGoodObject && TRUE == bShimIfNecessary) {
        ApphelpFixExe(hSDB, szComServer, &QueryResult, FALSE);
    }

    SdbQueryFlagMask(hSDB, &QueryResult, TAG_FLAG_MASK_SHELL, pullFlags, NULL);

    //
    // we might want to use Apphelp api for this -- but shell does pass the right
    // thing to us (most likely)
    //
    BaseUpdateAppcompatCache(ustrNtPath.Buffer,
                             hDLL,
                             !(QueryResult.atrExes[0] == TAGREF_NULL &&
                               QueryResult.atrLayers[0] == TAGREF_NULL));

Done:

    RtlFreeUnicodeString(&ustrNtPath);

    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    if (hDLL != INVALID_HANDLE_VALUE) {
        NtClose(hDLL);
    }

    if (szComServer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, szComServer);
    }

    return bGoodObject;
}

BOOL
ApphelpGetNTVDMInfo(
    IN  LPCWSTR pwszPath,       // path to the app in NT format
    IN  LPCWSTR pwszModule,     // module name
    IN  LPCWSTR pEnvironment,   // pointer to the environment of the task that is
                                // being created or NULL if we are to use the main NTVDM
                                // environment block.
    OUT LPWSTR pszCompatLayer,  // The new compat layer variable. with format:
                                // "Alpha Bravo Charlie" -- allow 256 chars for this.
    OUT PNTVDM_FLAGS pFlags,    // The flags
    OUT PAPPHELP_INFO pAHInfo,  // If there is apphelp to display, this will be filled
                                // in with non-null values
    OUT HSDB*  phSDB,           // The handle to the database.
    OUT PSDBQUERYRESULT pQueryResult // The query result.
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   This is essentially the equivalent of ApphelpCheckRunApp, but specific
            to NTVDM.
--*/
{
    DWORD dwReason = 0;

    if (IsAppcompatInfrastructureDisabled()) {
        return TRUE;
    }

    return InternalCheckRunApp(INVALID_HANDLE_VALUE, pwszPath, pEnvironment,
                               IMAGE_FILE_MACHINE_I386, &dwReason,
                               NULL, NULL, NULL, NULL, NULL, TRUE,
                               pwszModule, pszCompatLayer, pFlags, pAHInfo,
                               phSDB, pQueryResult);
}

void
GetExeNTVDMData(
    IN  HSDB hSDB,                  // the SDB context
    IN  PSDBQUERYRESULT psdbQuery,  // the EXEs and LAYERs that are active
    OUT WCHAR* pszCompatLayer,      // The new compat layer variable. with format:
                                    // "Alpha Bravo Charlie"
    OUT PNTVDM_FLAGS pFlags         // The flags
    )
{
    DWORD i;
    ULARGE_INTEGER uliFlags;
    LPVOID pFlagContext = NULL;
    HRESULT hr;

    ZeroMemory(pFlags, sizeof(NTVDM_FLAGS));

    //
    // Build the layer variable, and look for the two "special" layers
    //
    if (pszCompatLayer) {
        pszCompatLayer[0] = 0;

        for (i = 0; i < SDB_MAX_LAYERS && psdbQuery->atrLayers[i] != TAGREF_NULL; ++i) {
            WCHAR* pszEnvVar;

            //
            // Get the environment var and tack it onto the full string
            //
            pszEnvVar = SdbGetLayerName(hSDB, psdbQuery->atrLayers[i]);

            if (pszEnvVar) {
                //
                // check for one of the two "special" layers
                //
                if (_wcsicmp(pszEnvVar, L"640X480") == 0) {
                    //
                    // set the 640x480 flag -- found in base\mvdm\inc\wowcmpat.h
                    //
                    // NOTE: we don't have this flag yet -- waiting on WOW guys
                }
                if (_wcsicmp(pszEnvVar, L"256COLOR") == 0) {
                    //
                    // set the 256 color flag -- found in base\mvdm\inc\wowcmpat.h
                    //
                    pFlags->dwWOWCompatFlagsEx |= 0x00000002;
                }

                hr = StringCchCatW(pszCompatLayer, COMPATLAYERMAXLEN, pszEnvVar);
                if (hr == S_OK) {
                    hr = StringCchCatW(pszCompatLayer, COMPATLAYERMAXLEN, L" ");
                }

                if (hr == STRSAFE_E_INSUFFICIENT_BUFFER) {
                    DBGPRINT((sdlError, "GetExeNTVDMData", "pszCompatLayer not big enough.\n"));

                    //
                    // If the buffer is not big enough, we just set it to an empty string -
                    // we don't want to fill in incomplete data.
                    //
                    pszCompatLayer[0] = 0;

                    break;
                }
            }
        }
    }

    //
    // Look for compat flags
    //
    SdbQueryFlagMask(hSDB, psdbQuery, TAG_FLAGS_NTVDM1, &uliFlags.QuadPart, &pFlagContext);
    pFlags->dwWOWCompatFlags |= uliFlags.LowPart;
    pFlags->dwWOWCompatFlagsEx |= uliFlags.HighPart;

    SdbQueryFlagMask(hSDB, psdbQuery, TAG_FLAGS_NTVDM2, &uliFlags.QuadPart, &pFlagContext);
    pFlags->dwUserWOWCompatFlags |= uliFlags.LowPart;
    pFlags->dwWOWCompatFlags2 |= uliFlags.HighPart;

    SdbQueryFlagMask(hSDB, psdbQuery, TAG_FLAGS_NTVDM3, &uliFlags.QuadPart, &pFlagContext);
    pFlags->dwWOWCompatFlagsFE |= uliFlags.LowPart;
    // High Part is unused for now.

    // now pack command line parameters

    SdbpPackCmdLineInfo(pFlagContext, &pFlags->pFlagsInfo);
    SdbpFreeFlagInfoList(pFlagContext);
}


BOOL
ApphelpCheckRunApp(
    IN  HANDLE hFile,           // [Optional] Handle to an open file to check
    IN  WCHAR* pwszPath,        // path to the app in NT format
    IN  WCHAR* pEnvironment,    // pointer to the environment of the process that is
                                // being created or NULL.
    IN  USHORT uExeType,        // executable's image type
    IN  PDWORD  pdwReason,        // collection of flags hinting at why we were called
    OUT PVOID* ppData,          // this will contain the pointer to the allocated buffer
                                // containing the appcompat data.
    OUT PDWORD pcbData,         // if appcompat data is found, the size of the buffer
                                // is returned here.
    OUT PVOID* ppSxsData,       // BUGBUG: describe
    OUT PDWORD pcbSxsData,      // BUGBUG: describe
    OUT PDWORD pdwFusionFlags
    )
/*++
    Return: FALSE if the app should be blocked from running, TRUE otherwise.

    Desc:   This is the main API of apphelp.dll. It is called from CreateProcess
            to retrieve application compatibility information for the current process.
--*/
{
    return InternalCheckRunApp(hFile, pwszPath, pEnvironment, uExeType, pdwReason,
                               ppData, pcbData, ppSxsData, pcbSxsData,pdwFusionFlags,
                               FALSE, NULL, NULL, NULL, NULL, NULL, NULL);
}



//
// =============================================================================================
//                              InstallShield 7 Support
// =============================================================================================
//
BOOL
ApphelpCheckInstallShieldPackage(
    IN  REFCLSID    PackageID,
    IN  LPCWSTR     lpszPackageFullPath
    )
{
    BOOL            bPackageGood = TRUE; // This return value MUST TRUE otherwise InstallShield7 will cancel its processes.

    TAGREF          trExe = TAGREF_NULL;

    DWORD           dwNumExes = 0;
    DWORD           dwDataType = 0;
    DWORD           dwSize = 0;
    DWORD           dwReturn = 0;

    BOOL            bMatchFound = FALSE;
    NTSTATUS        Status;

    BOOL            bAppHelpIfNecessary = FALSE;
    BOOL            bResult = TRUE;

    WCHAR           wszCLSID[41];
    WCHAR           wszPackageCode[41];

    GUID            guidPackageID;
    GUID            guidPackageCode;

    HSDB            hSDB = NULL;
    SDBQUERYRESULT  QueryResult;

    if (IsAppcompatInfrastructureDisabled()) {
        goto Done;
    }

    if (NULL == lpszPackageFullPath) {
        DBGPRINT((sdlInfo,
                  "ApphelpCheckInstallShieldPackage",
                  "lpszPackageFullPath is NULL\n"));
        goto Done;
    }

    SdbGUIDToString((GUID *)&PackageID, wszCLSID, CHARCOUNT(wszCLSID));

    DBGPRINT((sdlWarning,
              "ApphelpCheckInstallShieldPackage",
              "InstallShield package detected. CLSID: %s FullPath: %s\n",
              wszCLSID, lpszPackageFullPath));

    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckExe", "Failed to initialize database.\n"));
        goto Done;
    }

    bMatchFound = ApphelpQueryExe(hSDB,
                              lpszPackageFullPath,
                              bAppHelpIfNecessary,
                              SDBGMEF_IGNORE_ENVIRONMENT,
                              &QueryResult);

    if (!bMatchFound)
    {
        DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "No match found.\n"));
        goto Done;
    }

    for (dwNumExes = 0; dwNumExes < SDB_MAX_EXES; ++dwNumExes)
    {
        if (TAGREF_NULL == QueryResult.atrExes[dwNumExes]) {
            break;
        }
        trExe = QueryResult.atrExes[dwNumExes];

        DBGPRINT((sdlInfo, "ApphelpCheckInstallShieldPackage", "Processing TAGREF atrExes[%d] = 0x%8x.\n", dwNumExes, trExe));

        dwSize = sizeof(wszPackageCode);
        *wszPackageCode = L'\0';

        dwReturn = SdbQueryData(  hSDB,
                                trExe,
                                L"PackageCode",
                                &dwDataType,
                                wszPackageCode,
                                &dwSize);

        if (dwReturn == ERROR_SUCCESS)
        {
            DBGPRINT((sdlInfo, "ApphelpCheckInstallShieldPackage", "SdbQueryData returns dwSize = %d and dwDataType = %d.\n", dwSize, dwDataType));

            if ((dwSize > 0) && (dwSize < sizeof(wszPackageCode)))
            {
                // we have some data
                // check the type (should be string)
                if (REG_SZ != dwDataType)
                {
                    DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "SdbQueryData returns non STRING PackageCode data. Exiting.\n"));
                    goto Done;
                }

                DBGPRINT((sdlInfo, "ApphelpCheckInstallShieldPackage", "Comparing PackageId = %s and PackageCode = %s.\n", wszCLSID, wszPackageCode));

                // convert to guid
                if (FALSE == SdbGUIDFromString(wszPackageCode, &guidPackageCode))
                {
                   DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "Can not convert PackageCode to GUID. Exiting.\n"));
                   goto Done;
                }

                if (RtlEqualMemory(PackageID, &guidPackageCode, sizeof(guidPackageCode) ))
                {
                    DBGPRINT((sdlWarning, "ApphelpCheckInstallShieldPackage",
                        "Found InstallShield package matched with PackageCode: %s.\n",
                        wszPackageCode));

                    if (TRUE != ApphelpFixExe(hSDB, lpszPackageFullPath, &QueryResult, FALSE))
                    {
                        DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "Can not load additional shim dynamically for this executable.\n"));
                    }
                    goto Done;
                }
            }
        }
    } // for

    DBGPRINT((sdlError, "ApphelpCheckInstallShieldPackage", "No match found.\n"));

Done:
    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    return bPackageGood;
}


//
// =============================================================================================
//                                  MSI Support
// =============================================================================================
//

BOOL
SDBAPI
ApphelpCheckMsiPackage(
    IN GUID* pguidDB,  // database id
    IN GUID* pguidID,  // match id
    IN DWORD dwFlags,  // not used now, set to 0
    IN BOOL  bNoUI
    )
{
    WCHAR        szDatabasePath[MAX_PATH];
    DWORD        dwDatabaseType = 0;
    DWORD        dwPackageFlags = 0;
    DWORD        dwLength;
    BOOL         bInstallPackage = TRUE;
    HSDB         hSDB = NULL;
    TAGREF       trPackage = TAGREF_NULL;

    HAPPHELPINFOCONTEXT hApphelpInfoContext = NULL;
    DWORD               dwSeverity = 0;

    if (IsAppcompatInfrastructureDisabled()) {
        goto out;
    }

    hSDB = SdbInitDatabase(HID_NO_DATABASE, NULL);

    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                   "Failed to initialize database\n"));
        goto out;
    }

    SdbSetImageType(hSDB, IMAGE_FILE_MSI);

    //
    // First, we need to resolve a db
    //
    dwLength = SdbResolveDatabase(hSDB,
                                  pguidDB,
                                  &dwDatabaseType,
                                  szDatabasePath,
                                  CHARCOUNT(szDatabasePath));

    if (dwLength == 0 || dwLength > CHARCOUNT(szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to resolve database path\n"));
        goto out;
    }

    //
    // open database
    //

    if (!SdbOpenLocalDatabase(hSDB, szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to open database \"%s\"\n", szDatabasePath));
        goto out;
    }

    //
    // find the entry
    //
    trPackage = SdbFindMsiPackageByID(hSDB, pguidID);
    if (trPackage == TAGREF_NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to find msi package by guid id\n"));
        goto out;
    }

    hApphelpInfoContext = SdbOpenApphelpInformationByID(hSDB,
                                                        trPackage,
                                                        dwDatabaseType);
    if (hApphelpInfoContext == NULL) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Apphelp information has not been found\n"));
        goto out;
    }

    //
    // we have apphelp data, check to see if we have flags for this exe
    //

    if (!SdbGetEntryFlags(pguidID, &dwPackageFlags)) {
        DBGPRINT((sdlWarning, "ApphelpCheckMsiPackage",
                  "No flags for trPackage 0x%x\n", trPackage));
        dwPackageFlags = 0;
    }

    //
    // Check whether the disable bit is set (the dwFlags has been retrieved from the
    // registry via the SdbReadApphelpData call)
    //
    if (dwPackageFlags & SHIMREG_DISABLE_APPHELP) {
        goto out;
    }


    bNoUI |= !!(dwPackageFlags & SHIMREG_APPHELP_NOUI);
    if (bNoUI) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "NoUI flag is set, apphelp UI disabled for this app.\n"));
    }

    SdbQueryApphelpInformation(hApphelpInfoContext,
                               ApphelpProblemSeverity,
                               &dwSeverity,
                               sizeof(dwSeverity));

    //
    // depending on severity of the problem...
    //
    switch (dwSeverity) {
    case APPHELP_MINORPROBLEM:
    case APPHELP_HARDBLOCK:
    case APPHELP_NOBLOCK:
    case APPHELP_REINSTALL:

        //
        //
        //
        bInstallPackage = (APPHELP_HARDBLOCK != dwSeverity);
        if (!bNoUI) {
            DWORD dwRet;
            APPHELP_INFO AHInfo = { 0 };

            AHInfo.guidDB = *pguidDB;
            AHInfo.bMSI   = TRUE;
            SdbQueryApphelpInformation(hApphelpInfoContext,
                                       ApphelpExeTagID,
                                       &AHInfo.tiExe,
                                       sizeof(AHInfo.tiExe));
            if (AHInfo.tiExe != TAGID_NULL) {

                AHInfo.bOfflineContent = bDebugChum();

                SdbShowApphelpDialog(&AHInfo, NULL, &bInstallPackage);
                   // either we succeeded or bInstall package is treated
                   // the same way as No UI
            }
        }
        break;

    default:
        //
        // Some other case was found (e.g. VERSIONSUB which should be replaced
        // by shims in most cases).
        //
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Unhandled severity flag 0x%x.\n", dwSeverity));
        break;
    }

    //
    // at this point we know whether we want to install the package or not
    //


out:

    if (hApphelpInfoContext != NULL) {
        SdbCloseApphelpInformation(hApphelpInfoContext);
    }

    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }


    return bInstallPackage;
}

BOOL
SDBAPI
ApphelpFixMsiPackage(
    IN GUID*   pguidDB,
    IN GUID*   pguidID,
    IN LPCWSTR pszFileName,
    IN LPCWSTR pszActionName,
    IN DWORD   dwFlags
    )
{
    WCHAR          szDatabasePath[MAX_PATH];
    DWORD          dwDatabaseType = 0;
    HSDB           hSDB = NULL;
    TAGREF         trPackage = TAGREF_NULL;
    TAGREF         trAction  = TAGREF_NULL;
    SDBQUERYRESULT QueryResult;
    BOOL           bSuccess = FALSE;
    DWORD          dwLength;
    TAGREF         trLayer, trLayerRef;
    DWORD          dwLayers  = 0;

    if (IsAppcompatInfrastructureDisabled()) {
        bSuccess = TRUE;
        goto out;
    }

    //
    // open database. In this case we need to have the default database
    // for this platform being opened, later on we modify the context
    // Fixes will be looked up in a default main db though
    //

    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                   "Failed to initialize database\n"));
        goto out;
    }

    SdbSetImageType(hSDB, IMAGE_FILE_MSI);

    //
    // from this point on, all resolutions will be based on msi image type
    // however all the fixes will come from the database that is standard for
    // this platform
    //


    //
    // First, we need to resolve a db
    //
    dwLength = SdbResolveDatabase(hSDB,
                                  pguidDB,
                                  &dwDatabaseType,
                                  szDatabasePath,
                                  CHARCOUNT(szDatabasePath));

    if (dwLength == 0 || dwLength > CHARCOUNT(szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to resolve database path\n"));
        goto out;
    }

    //
    // open database
    //

    if (!SdbOpenLocalDatabase(hSDB, szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to open database \"%s\"\n", szDatabasePath));
        goto out;
    }

    //
    // find the entry
    //
    trPackage = SdbFindMsiPackageByID(hSDB, pguidID);
    if (trPackage == TAGREF_NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to find msi package by guid id\n"));
        goto out;
    }

    if (SdbGetEntryFlags(pguidID, &dwFlags) && (dwFlags & SHIMREG_DISABLE_SHIM)) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Shims for this package are disabled\n"));

        goto out;
    }

    trAction = SdbFindCustomActionForPackage(hSDB, trPackage, pszActionName);
    if (trAction == TAGREF_NULL) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Failed to find custom action \"%s\"\n", pszActionName));
        goto out;
    }

    //
    // we have custom action on our hands which appears to have fixes
    // attached to it, shim it!
    //
    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    QueryResult.guidID = *pguidID;
    QueryResult.atrExes[0] = trAction;

    //
    // get all the layers for this entry
    // also remember that tthe layers and shims alike might not be in the default
    // database initialized in the beginning of this call
    //
    trLayerRef = SdbFindFirstTagRef(hSDB, trAction, TAG_LAYER);
    while (trLayerRef != TAGREF_NULL && dwLayers < SDB_MAX_LAYERS) {
        trLayer = SdbGetNamedLayer(hSDB, trLayerRef);
        if (trLayer != TAGREF_NULL) {
            QueryResult.atrLayers[dwLayers++] = trLayer;
        }
        trLayerRef = SdbFindNextTagRef(hSDB, trAction, trLayerRef);
    }


    //
    // ready to shim
    //
    bSuccess = ApphelpFixExe(hSDB, pszFileName, &QueryResult, TRUE);
    if (bSuccess) {
        DBGPRINT((sdlInfo, "ApphelpFixMsiPackage",
                   "Custom action \"%s\" successfully shimmed file \"%s\"\n",
                   pszActionName, pszFileName));
    }

out:
    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }


    return(bSuccess);
}

BOOL
SDBAPI
ApphelpFixMsiPackageExe(
    IN GUID* pguidDB,
    IN GUID* pguidID,
    IN LPCWSTR pszActionName,
    IN OUT LPWSTR pwszEnv,
    IN OUT LPDWORD pdwBufferSize
    )
{

    WCHAR          szDatabasePath[MAX_PATH];
    DWORD          dwDatabaseType = 0;
    HSDB           hSDB = NULL;
    TAGREF         trPackage = TAGREF_NULL;
    TAGREF         trAction  = TAGREF_NULL;
    SDBQUERYRESULT QueryResult;
    DWORD          dwLength;
    DWORD          dwBufferSize;
    BOOL           bSuccess = FALSE;
    DWORD          dwFlags;
    int            i;
    TAGREF         trLayer;

    if (pwszEnv != NULL) {
        *pwszEnv = TEXT('\0');
    }

    if (IsAppcompatInfrastructureDisabled()) {
        goto out;
    }

    hSDB = SdbInitDatabaseEx(HID_NO_DATABASE, NULL, IMAGE_FILE_MSI);

    if (hSDB == NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                   "Failed to initialize database\n"));
        goto out;
    }

    //
    // First, we need to resolve a db
    //
    dwLength = SdbResolveDatabase(hSDB,
                                  pguidDB,
                                  &dwDatabaseType,
                                  szDatabasePath,
                                  CHARCOUNT(szDatabasePath));

    if (dwLength == 0 || dwLength > CHARCOUNT(szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to resolve database path\n"));
        goto out;
    }

    //
    // open database
    //

    if (!SdbOpenLocalDatabase(hSDB, szDatabasePath)) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to open database \"%s\"\n", szDatabasePath));
        goto out;
    }

    //
    // find the entry
    //
    trPackage = SdbFindMsiPackageByID(hSDB, pguidID);
    if (trPackage == TAGREF_NULL) {
        DBGPRINT((sdlError, "ApphelpCheckMsiPackage",
                  "Failed to find msi package by guid id\n"));
        goto out;
    }

    if (SdbGetEntryFlags(pguidID, &dwFlags) && (dwFlags & SHIMREG_DISABLE_SHIM)) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Shims for this package are disabled\n"));

        goto out;
    }

    trAction = SdbFindCustomActionForPackage(hSDB, trPackage, pszActionName);
    if (trAction == TAGREF_NULL) {
        DBGPRINT((sdlInfo, "ApphelpCheckMsiPackage",
                  "Failed to find custom action \"%s\"\n", pszActionName));
        goto out;
    }

    //
    // now -- this action is an exe, do it right for him
    //
    RtlZeroMemory(&QueryResult, sizeof(QueryResult));

    QueryResult.guidID = *pguidID;

    for (i = 0; i < SDB_MAX_LAYERS; ++i) {
        //
        // check to see if we are doing the first layer, if so - call
        // find first to obtain the layer, else find the next applicable layer
        //

        if (i == 0) {
            trLayer = SdbFindFirstTagRef(hSDB, trAction, TAG_LAYER);
        } else {
            trLayer = SdbFindNextTagRef (hSDB, trAction, trLayer);
        }

        if (trLayer == TAGREF_NULL) {
            break;
        }

        QueryResult.atrLayers[i] = trLayer;
    }

    dwLength = 0;
    if (pdwBufferSize != NULL) {
        dwLength = *pdwBufferSize;
    }

    //
    // build compat layer
    //
    dwBufferSize = SdbBuildCompatEnvVariables(hSDB,
                                              &QueryResult,
                                              0,
                                              NULL,
                                              pwszEnv,
                                              dwLength,
                                              NULL);

    if (pdwBufferSize != NULL) {
        *pdwBufferSize = dwBufferSize;
    }

    bSuccess = TRUE;

out:

    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    return bSuccess;
}



/*++
    Function:

        CheckAppcompatInfrastructureFlags

    Description:

        Checks various registry places for infrastructure global flags (just the disabled bit for now)
        The flags are set into the global variable gdwInfrastructureFlags. Function is used via the macro
        for perf reasons

    Return:
        global infrastructure flags

--*/

DWORD
CheckAppcompatInfrastructureFlags(
    VOID
    )
{
    gdwInfrastructureFlags = 0; // initialize just in case

    if (BaseIsAppcompatInfrastructureDisabled()) {
        gdwInfrastructureFlags |= APPCOMPAT_INFRA_DISABLED;
    }

    //
    // make the bits valid
    //
    gdwInfrastructureFlags |= APPCOMPAT_INFRA_VALID_FLAG;

    return gdwInfrastructureFlags;
}

/*++
    Function:

        SdbInitDatabaseExport

    Description:

        This is "exported" version of the function SdbInitDatabase
        that checks for the "diabled" flag -- otherwise calls into SdbInitDatabase

    Return:

         see SdbInitDatabase

--*/

HSDB
SDBAPI
SdbInitDatabaseExport(
    IN  DWORD   dwFlags,        // flags that tell how the database should be
                                // initialized.
    IN  LPCWSTR pszDatabasePath // the OPTIONAL full path to the database to
                                // be used.
    )
{
    if (IsAppcompatInfrastructureDisabled()) {
        return NULL;
    }

    return SdbInitDatabase(dwFlags, pszDatabasePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\apphelp\match.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        match.c

    Abstract:

        This module implements ...

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        clupu      cleanup     12/27/2000
--*/

#include "apphelp.h"

// global Hinst
HINSTANCE           ghInstance;
CRITICAL_SECTION    g_csDynShimInfo;

BOOL
DllMain(
    HANDLE hModule,
    DWORD  ul_reason,
    LPVOID lpReserved
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   apphelp.dll entry point.
--*/
{
    switch (ul_reason) {
    case DLL_PROCESS_ATTACH:
        ghInstance = hModule;

        if (!NT_SUCCESS(RtlInitializeCriticalSectionAndSpinCount(&g_csDynShimInfo, 0x80000000))) {
            return FALSE;
        }
        
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
GetExeSxsData(
    IN  HSDB   hSDB,            // handle to the database channel
    IN  TAGREF trExe,           // tagref of an exe entry
    OUT PVOID* ppSxsData,       // pointer to the SXS data
    OUT DWORD* pcbSxsData       // pointer to the SXS data size
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets SXS (Fusion) data for the specified EXE from the database.
--*/
{
    TAGID  tiExe;
    TAGID  tiSxsManifest;
    PDB    pdb;
    WCHAR* pszManifest;
    DWORD  dwManifestLength = 0; // in chars
    PVOID  pSxsData = NULL;
    BOOL   bReturn = FALSE;

    if (trExe == TAGREF_NULL) {
        goto exit;
    }

    if (!SdbTagRefToTagID(hSDB, trExe, &pdb, &tiExe)) {
        DBGPRINT((sdlError,
                  "GetExeSxsData",
                  "Failed to get the database the TAGREF 0x%x belongs to.\n",
                  trExe));
        goto exit;
    }

    tiSxsManifest = SdbFindFirstTag(pdb, tiExe, TAG_SXS_MANIFEST);

    if (!tiSxsManifest) {
        DBGPRINT((sdlInfo,
                  "GetExeSxsData",
                  "No SXS data for TAGREF 0x%x.\n",
                  trExe));
        goto exit;
    }

    pszManifest = SdbGetStringTagPtr(pdb, tiSxsManifest);
    if (pszManifest == NULL) {
        DBGPRINT((sdlError,
                  "GetExeSxsData",
                  "Failed to get manifest string tagid 0x%lx\n",
                  tiSxsManifest));
        goto exit;
    }

    dwManifestLength = wcslen(pszManifest);

    //
    // check if this is just a query for existance of the data tag
    //
    if (ppSxsData == NULL) {
        bReturn = TRUE;
        goto exit;
    }

    //
    // Allocate the string and return it. NOTE: SXS.DLL cannot handle
    // a NULL terminator at the end of the string. We must provide the
    // string without the NULL terminator.
    //
    pSxsData = (PVOID)RtlAllocateHeap(RtlProcessHeap(),
                                      HEAP_ZERO_MEMORY,
                                      dwManifestLength * sizeof(WCHAR));
    if (pSxsData == NULL) {
        DBGPRINT((sdlError,
                  "GetExeSxsData",
                  "Failed to allocate %d bytes\n",
                  dwManifestLength * sizeof(WCHAR)));
        goto exit;
    }

    RtlMoveMemory(pSxsData, pszManifest, dwManifestLength * sizeof(WCHAR));

    bReturn = TRUE;

exit:

    if (ppSxsData != NULL) {
        *ppSxsData = pSxsData;
    }

    if (pcbSxsData != NULL) {
        *pcbSxsData = dwManifestLength * sizeof(WCHAR);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\apphelp\apphelp.h ===
#ifndef __APPHELP_LIB_H
#define __APPHELP_LIB_H

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <memory.h>
#include <malloc.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "shimdb.h"



#if DBG // make sure that apphelp_tools is defined when compiling checked
    #ifndef APPHELP_TOOLS
    #define APPHELP_TOOLS
    #endif
#endif

// 
// The critsec to protect the dynamic shim info list.
//
extern CRITICAL_SECTION g_csDynShimInfo;

//
// Routines in ahcache.c
//

BOOL
BaseUpdateAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    BOOL    bRemove
    );

BOOL
BaseFlushAppcompatCache(
    VOID
    );

BOOL
BaseCheckAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    PVOID   pEnvironment,
    DWORD*  dwReason
    );
VOID
BaseDumpAppcompatCache(
    VOID
    );

BOOL
WINAPI
BaseIsAppcompatInfrastructureDisabled(
    VOID
    );

//
// Apphelp api to update the cache
//
//

BOOL
WINAPI
ApphelpUpdateCacheEntry(
    LPCWSTR pwszPath,           // nt path or dos path (see bNTPath)
    HANDLE  hFile,              // file handle (or INVALID_HANDLE_VALUE if not needed)
    BOOL    bDeleteEntry,       // TRUE if we are to delete the entry
    BOOL    bNTPath             // if TRUE -- NT path, FALSE - dos path
    );

//
// Reasons:
//

#define SHIM_CACHE_NOT_FOUND 0x00000001
#define SHIM_CACHE_BYPASS    0x00000002 // bypass cache (either removable media or temp dir)
#define SHIM_CACHE_LAYER_ENV 0x00000004 // layer env variable set
#define SHIM_CACHE_MEDIA     0x00000008
#define SHIM_CACHE_TEMP      0x00000010
#define SHIM_CACHE_NOTAVAIL  0x00000020
#define SHIM_CACHE_UPDATE    0x00020000
#define SHIM_CACHE_ACTION    0x00010000



//
// Routines in check.c
//

INT_PTR CALLBACK
AppCompatDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );

DWORD
ShowApphelpDialog(
    PAPPHELP_DATA pApphelpData
    );


// in apphelppath.c

BOOL
ConvertToDosPath(
    OUT LPWSTR*  ppDosPath,
    IN  LPCWSTR  pwszPath
    );

BOOL
CheckStringPrefixUnicode(
   PUNICODE_STRING pStrPrefix,
   PUNICODE_STRING pString,
   BOOL CaseInSensitive);

// this function is used to free the dos path
// it checks whether the path was allocated or
// the static buffer was used
VOID
FreeDosPath(WCHAR* pDosPath);

//
// in matchApphelp.c
//


BOOL
GetExeSxsData(
    HSDB   hSDB,
    TAGREF trExe,
    PVOID* ppSxsData,
    DWORD* pcbSxsData
    );


//
// in apphelpcache.c
//

VOID ShimUpdateCache(LPCWSTR pwszPath, PSDBQUERYRESULT psdbQuery);
VOID ShimCacheProcessCleanup(VOID);
VOID ShimCacheThreadCleanup(VOID);
BOOL ShimCacheProcessInit(VOID);
VOID ShimInitCache(PVOID pCache);
VOID ShimRemoveExeFromCache(LPCWSTR pwszPath);

BOOL
LookupCache(
    LPCWSTR         pwszPath,
    PSDBQUERYRESULT psdbQuery
    );

BOOL
BypassCache(
    LPCWSTR pwszPath,
    WCHAR*  pEnvironment,
    BOOL*   pbLayer
    );

//
// in apphelpcheck.c
//
//

DWORD
ShowApphelp(
    IN OUT PAPPHELP_DATA pApphelpData,
    IN     LPCWSTR       pwszDetailsDatabasePath,
    IN     PDB           pdbDetails
    );


//
// SDBAPI internal functions that we use to obtain flags for ntvdm
//

BOOL
SDBAPI
SdbpPackCmdLineInfo(
    IN  PVOID   pvFlagInfoList,
    OUT PVOID*  ppFlagInfo
    );

BOOL
SDBAPI
SdbpFreeFlagInfoList(
    IN PVOID pvFlagInfoList
    );

//
// Alloc/free routines from dblib
//
extern void* SdbAlloc(size_t);
extern void  SdbFree(void*);

//
// Stack allocation routine
//
#ifndef STACK_ALLOC

//
//
// Exact same definition for stack-related routines is found in sdbp.h
//

VOID
SdbResetStackOverflow(
    VOID
    );

#if DBG | defined(_WIN64)

#define STACK_ALLOC(ptrVar, nSize) \
    {                                     \
        PVOID* ppVar = (PVOID*)&(ptrVar); \
        *ppVar = SdbAlloc(nSize);         \
    }

#define STACK_FREE(pMemory)  \
    SdbFree(pMemory)

#else // !DBG

//
// HACK ALERT
//
//  The code below works because when we hit a stack overflow - we catch the exception
//  and subsequently fix the stack up using a crt routine
//

//
// this routine lives in sdbapi, semi-private api
//


#define STACK_ALLOC(ptrVar, nSize) \
    __try {                                                                 \
        PVOID* ppVar = (PVOID*)&(ptrVar);                                   \
        *ppVar = _alloca(nSize);                                            \
    } __except (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ?            \
                EXCEPTION_EXECUTE_HANDLER:EXCEPTION_CONTINUE_SEARCH) {      \
        (ptrVar) = NULL;                                                    \
    }                                                                       \
                                                                            \
    if (ptrVar == NULL) {                                                   \
        SdbResetStackOverflow();                                            \
    }


#define STACK_FREE(pMemory)

#endif // DBG


#endif // !defined(STACK_ALLOC)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\apphelp\debug.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        debug.c

    Abstract:

        This module implements debug only routines.

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        clupu      cleanup     12/27/2000
--*/

#include "apphelp.h"


#if defined(APPHELP_TOOLS)


//
// this functionality will not be available (temporary)
//


DWORD
ApphelpShowUI(
    TAGREF  trExe,                  // tagref for the exe (should be a "LOCAL" tagref)
    LPCWSTR pwszDatabase,           // database path (we will make a local db out of it
    LPCWSTR pwszDetailsDatabase,
    LPCWSTR pwszApphelpPath,
    BOOL    bLocalChum,
    BOOL    bUseHtmlHelp
    )
/*++
    Return: The same as what ShowApphelp returns.

    Desc:   Given the database and the (local) tagref it procures the dialog
            with all the information in it for a given htmlhelpid.
            This api is for internal use only and it is available on
            checked builds only
--*/
{

/*
    HSDB         hSDB = NULL;
    APPHELP_DATA ApphelpData;
    DWORD        dwRet = (DWORD)-1;
    PAPPHELPCONTEXT pContext;

    pContext = InitializeApphelpContext();
    if (pContext == NULL) {
        DBGPRINT((sdlError,
                  "iShowApphelpDebug",
                  "Failed to initialize Apphelp context for thread id 0x%x\n",
                  GetCurrentThreadId()));
        goto ExitShowApphelpDebug;
    }

    hSDB = SdbInitDatabase(HID_NO_DATABASE, NULL);

    if (hSDB == NULL) {
        DBGPRINT((sdlError, "iShowApphelpDebug", "Failed to initialize database\n"));
        goto Done;
    }

    //
    // Open local database
    //
    if (!SdbOpenLocalDatabase(hSDB, pwszDatabase)) {
        DBGPRINT((sdlError,
                  "iShowApphelpDebug",
                  "Failed to open database \"%ls\"\n",
                  pwszDatabase));
        goto Done;
    }

    if (SdbIsTagrefFromMainDB(trExe)) {
        DBGPRINT((sdlError, "iShowApphelpDebug", "Can only operate on local tagrefs\n"));
        goto Done;
    }

    //
    // Now we venture out and read apphelp data
    //
    if (!SdbReadApphelpData(hSDB, trExe, &ApphelpData)) {
        DBGPRINT((sdlError,
                  "iShowApphelpDebug",
                  "Error while trying to read Apphelp data for 0x%x in \"%S\"\n",
                  trExe,
                  pwszDatabase));
        goto Done;
    }

    //
    // We have the data and everything else we need to throw a dialog,
    // set debug chum ...
    //
    pContext->bShowOfflineContent = bLocalChum;

    //
    // Should we use html help instead ?
    //
    pContext->bUseHtmlHelp = bUseHtmlHelp;

    //
    // Pointer to the local chum.
    //
    pContext->pwszApphelpPath = pwszApphelpPath;

    //
    // And now throw a dialog...
    //
    dwRet = ShowApphelp(&ApphelpData, pwszDetailsDatabase, NULL);

Done:
    if (hSDB != NULL) {
        SdbReleaseDatabase(hSDB);
    }

    //
    // Release the context for this thread/instance
    //
    ReleaseApphelpContext();

ExitShowApphelpDebug:

    return dwRet;
*/
    return TRUE;
}

BOOL
ApphelpShowDialog(
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    IN  PHANDLE         phProcess   // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.

    )
{ 
    BOOL bRunApp = TRUE;

    SdbShowApphelpDialog(pAHInfo, 
                         phProcess,
                         &bRunApp);

    return bRunApp;
    
}

//
// Get all the file's attributes
//
//


BOOL
ApphelpGetFileAttributes(
    IN  LPCWSTR    lpwszFileName,
    OUT PATTRINFO* ppAttrInfo,
    OUT LPDWORD    lpdwAttrCount
    )
/*++
    Return: The same as what SdbGetFileAttributes returns.

    Desc:   Stub to call SdbGetFileAttributes.
--*/
{
    return SdbGetFileAttributes(lpwszFileName, ppAttrInfo, lpdwAttrCount);
}

BOOL
ApphelpFreeFileAttributes(
    IN PATTRINFO pAttrInfo
    )
/*++
    Return: The same as what SdbFreeFileAttributes returns.

    Desc:   Stub to call SdbFreeFileAttributes.
--*/
{
    return SdbFreeFileAttributes(pAttrInfo);
}

#endif // APPHELP_TOOLS


void CALLBACK
ShimFlushCache(
    HWND      hwnd,
    HINSTANCE hInstance,
    LPSTR     lpszCmdLine,
    int       nCmdShow
    )
/*++
    Return: void.

    Desc:   Entry point for rundll32.exe. This is used to flush cache
            after installing a brand new shim database. Use:

                "rundll32 apphelp.dll,ShimFlushCache"
--*/
{
#ifndef WIN2K_NOCACHE
    BaseFlushAppcompatCache();
#endif
}

void CALLBACK
ShimDumpCache(
    HWND      hwnd,
    HINSTANCE hInstance,
    LPSTR     lpszCmdLine,
    int       nCmdShow
    )
{
#ifndef WIN2K_NOCACHE
    BaseDumpAppcompatCache();
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\apphelp\persistlayers.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        persistLayers.c

    Abstract:

        This module implements routines to persist layer
        information for shortcuts.

    Author:

        dmunsil     created     sometime in 2000

    Revision History:


--*/

#include "apphelp.h"


BOOL
AllowPermLayer(
    IN  LPCWSTR  pwszPath       // path to the file to check whether you
                                // can set a permanent layer on
    )
/*++
    Return: TRUE if a permanent setting of a layer is allowed for the
            specified file, FALSE otherwise.

    Desc:   Returns wether a permanent layer setting can be persisted
            for the specified file.
--*/
{
    WCHAR wszDrive[5];
    UINT  unType;

    if (pwszPath == NULL) {
        DBGPRINT((sdlError, "AllowPermLayer", "Invalid argument\n"));
        return FALSE;
    }

    if (pwszPath[1] != L':' && pwszPath[1] != L'\\') {
        //
        // Not a path we recognize.
        //
        DBGPRINT((sdlInfo,
                  "AllowPermLayer",
                  "\"%S\" not a full path we can operate on.\n",
                  pwszPath));
        return FALSE;
    }

    if (pwszPath[1] == L'\\') {
        //
        // Network path. Not allowed.
        //
        DBGPRINT((sdlInfo,
                  "AllowPermLayer",
                  "\"%S\" is a network path.\n",
                  pwszPath));
        return FALSE;
    }

    wcscpy(wszDrive, L"c:\\");
    wszDrive[0] = pwszPath[0];

    unType = GetDriveTypeW(wszDrive);

    if (unType == DRIVE_REMOTE) {
        DBGPRINT((sdlInfo,
                  "AllowPermLayer",
                  "\"%S\" is on CDROM or other removable media.\n",
                  pwszPath));
        return FALSE;
    }

    return TRUE;
}

//
// Semi-exported api from SDBAPI (ntbase.c)
//
BOOL
SDBAPI
SdbpGetLongPathName(
    IN LPCWSTR pwszPath,
    OUT PRTL_UNICODE_STRING_BUFFER pBuffer
    );

BOOL 
SDBAPI
ApphelpUpdateCacheEntry(
    LPCWSTR pwszPath,           // nt path
    HANDLE  hFile,              // file handle 
    BOOL    bDeleteEntry,       // TRUE if we are to delete the entry
    BOOL    bNTPath             // if TRUE -- NT path, FALSE - dos path
    )
{
    RTL_UNICODE_STRING_BUFFER Path;
    UCHAR                     PathBuffer[MAX_PATH*2];
    BOOL                      TranslationStatus;
    BOOL                      bSuccess = FALSE;
    UNICODE_STRING            NtPath = { 0 };
    UNICODE_STRING            DosPath = { 0 };
    BOOL                      bFreeNtPath = FALSE;
    NTSTATUS                  Status;

    RtlInitUnicodeStringBuffer(&Path, PathBuffer, sizeof(PathBuffer));

    if (bNTPath) { // if this is NT Path name, convert to dos

        RtlInitUnicodeString(&NtPath, pwszPath);
        
        Status = RtlAssignUnicodeStringBuffer(&Path, &NtPath); // NT path
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError, "ApphelpUpdateCacheEntry", "Failed to allocate temp buffer for %s\n", pwszPath));    
            goto Cleanup;
        }
        
        Status = RtlNtPathNameToDosPathName(0, &Path, NULL, NULL);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError, "ApphelpUpdateCacheEntry", 
                      "Failed to convert Path \"%s\" to dos path status 0x%lx\n", pwszPath, Status));    
            goto Cleanup;
        }

        Status = RtlDuplicateUnicodeString(RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE, &Path.String, &DosPath);
        if (!NT_SUCCESS(Status)) {
            DBGPRINT((sdlError, "ApphelpUpdateCacheEntry", 
                      "Failed to Duplicate Path \"%s\" status 0x%lx\n", Path.String.Buffer, Status));    
            goto Cleanup;
        }
            
        pwszPath = DosPath.Buffer;
    } 

    // 
    // at this point we have both NT and DOS path - buffer is available to us now
    // 
    
    if (!SdbpGetLongPathName(pwszPath, &Path)) { // in - DosPath // out -- Long DOS Path
        goto Cleanup;
    }

    //
    // convert long path name to NT Path name
    //
    TranslationStatus = RtlDosPathNameToNtPathName_U(Path.String.Buffer,
                                                     &NtPath,
                                                     NULL,
                                                     NULL);
    if (!TranslationStatus) {
         DBGPRINT((sdlError, "ApphelpUpdateCacheEntry", 
                   "Failed to Convert Path \"%s\" to NT path\n", Path.String.Buffer));    
         goto Cleanup;
    }
    //
    // update the cache (use NT Path here)
    //
    bSuccess = BaseUpdateAppcompatCache(NtPath.Buffer, hFile, bDeleteEntry);
    
    //
    // we only free this string when we successfully navigated through RtlDosPathNameToNtPathName_U
    //
    RtlFreeUnicodeString(&NtPath); 
    
    
Cleanup:

    if (bNTPath) { 
        //
        // Free DosPath if we had to convert from NT Path to DosPath first
        //
        RtlFreeUnicodeString(&DosPath);        
    }
    
    RtlFreeUnicodeStringBuffer(&Path);

    return bSuccess;

}

BOOL
SetPermLayers(
    IN  LPCWSTR pwszPath,       // path to the file to set a permanent layer on (dos path)
    IN  LPCWSTR pwszLayers,     // layers to apply to the file, separated by spaces
    IN  BOOL    bMachine        // TRUE if the layers should be persisted per machine
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Sets a permanent layer setting for the specified file.
--*/
{
    BOOL bSuccess = FALSE;
    
    if (pwszPath == NULL || pwszLayers == NULL) {
        DBGPRINT((sdlError, "SetPermLayers", "Invalid argument\n"));
        return FALSE;
    }

    bSuccess = SdbSetPermLayerKeys(pwszPath, pwszLayers, bMachine);

    // we do not care whether we were successful in the call above, clean the 
    // cache always (just in case)

    ApphelpUpdateCacheEntry(pwszPath, INVALID_HANDLE_VALUE, TRUE, FALSE);

    return bSuccess;
}

BOOL
GetPermLayers(
    IN  LPCWSTR pwszPath,       // path to the file to set a permanent layer on
    OUT LPWSTR  pwszLayers,     // layers to apply to the file, separated by spaces
    OUT DWORD*  pdwBytes,       // input: number of bytes available; output is number
                                // of bytes needed.
    IN  DWORD   dwFlags
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Returns the permanent layer setting for the specified file.
--*/
{
    if (pwszPath == NULL || pwszLayers == NULL || pdwBytes == NULL) {
        DBGPRINT((sdlError, "GetPermLayers", "Invalid argument\n"));
        return FALSE;
    }

    return SdbGetPermLayerKeys(pwszPath, pwszLayers, pdwBytes, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\ahui\ahui.cpp ===
/*--

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ahui.cpp

Abstract:

    Shows an apphelp message, and returns 0 if the program shouldn't run, and non-
    zero if the program should run

    Accepts a command line with a GUID and a TAGID, in the following format:

    {243B08D7-8CF7-4072-AF64-FD5DF4085E26} 0x0000009E

Author:

    dmunsil 04/03/2001

Revision History:

Notes:



--*/

#define _UNICODE

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <memory.h>
#include <malloc.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <htmlhelp.h>

extern "C" {
#include "shimdb.h"
}

#include "ids.h"

#include "shlobj.h"
#include "shlobjp.h"
#include "shellapi.h"
#include "shlwapi.h"

#ifndef _WIN64
#include <wow64t.h>
#endif

#include "ahmsg.h"
#include "strsafe.h"


extern "C" VOID AllowForegroundActivation(VOID);



#define APPHELP_DIALOG_FAILED ((DWORD)-1)

//
// TODO: add parameters to apphelp.exe's command line to work with these
//       variables.
//
BOOL    g_bShowOnlyOfflineContent = FALSE;
BOOL    g_bUseHtmlHelp = FALSE;
BOOL    g_bMSI         = FALSE;
USHORT  g_uExeImageType= DEFAULT_IMAGE;
WCHAR   g_wszApphelpPath[MAX_PATH];

HFONT   g_hFontBold = NULL;

HINSTANCE g_hInstance;

//
// Global variables used while parsing args
//

DWORD g_dwHtmlHelpID;
DWORD g_dwTagID;
DWORD g_dwSeverity;
LPCWSTR g_pAppName;
LPCWSTR g_pszGuid;
BOOL  g_bPreserveChoice;
WCHAR wszHtmlHelpID[]     = L"HtmlHelpID";
WCHAR wszAppName[]        = L"AppName";
WCHAR wszSeverity[]       = L"Severity";
WCHAR wszGUID[]           = L"GUID";
WCHAR wszTagID[]          = L"TagID";
WCHAR wszOfflineContent[] = L"OfflineContent";
WCHAR wszPreserveChoice[] = L"PreserveChoice";
WCHAR wszMSI[]            = L"MSI";
WCHAR wszPlatform[]       = L"Platform";
WCHAR wszX86[]            = L"X86";
WCHAR wszIA64[]           = L"IA64";

//
// FORWARD DECLARATIONS OF FUNCTIONS

DWORD
ShowApphelpDialog(
    IN  PAPPHELP_DATA pApphelpData
    );

PSID
GetCurrentUserSID(void)
{
    HANDLE hProcessToken = INVALID_HANDLE_VALUE;

    BOOL bRet = FALSE;
    DWORD dwTokenLength = 0;
    DWORD dwReturnLength = 0;
    DWORD dwSIDLength = 0;
    PTOKEN_USER pTokenUser = NULL;
    BOOL bSuccess = FALSE;
    PSID pSID = NULL;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hProcessToken)) {
        goto out;

    }

    GetTokenInformation(hProcessToken, TokenUser, NULL, dwTokenLength, &dwReturnLength);
    if (dwReturnLength == 0) {
        goto out;
    }

    dwTokenLength = dwReturnLength;
    dwReturnLength = 0;

    pTokenUser = (PTOKEN_USER)malloc(dwTokenLength);
    if (!pTokenUser) {
        goto out;
    }

    if (!GetTokenInformation(hProcessToken, TokenUser, (LPVOID)pTokenUser, dwTokenLength, &dwReturnLength)) {
        goto out;
    }

    if (!IsValidSid(pTokenUser->User.Sid)) {
        goto out;
    }
    dwSIDLength = GetLengthSid(pTokenUser->User.Sid);

    pSID = malloc(dwSIDLength);
    if (!pSID) {
        goto out;
    }

    if (!CopySid(dwSIDLength, pSID, pTokenUser->User.Sid)) {
        goto out;
    }

    bSuccess = TRUE;

out:

    if (pTokenUser) {
        free(pTokenUser);
    }
    if (hProcessToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hProcessToken);
    }
    if (!bSuccess && pSID) {
        free(pSID);
        pSID = NULL;
    }
    return pSID;
}

void
DeleteCurrentUserSID(PSID pSID)
{
    if (pSID) {
        free(pSID);
    }
}

BOOL
AppHelpLogEnabled(
    void
    )
{
    HKEY hKey;
    LONG lResult;
    DWORD dwValue, dwSize = sizeof(dwValue);
    DWORD dwType;

    // First, check for a policy.
    lResult = RegOpenKeyExW (HKEY_LOCAL_MACHINE, POLICY_KEY_APPCOMPAT_W, 0,
                            KEY_READ, &hKey);
    if (lResult == ERROR_SUCCESS) {
        dwValue = 0;
        lResult = RegQueryValueExW (hKey, POLICY_VALUE_APPHELP_LOG_W, 0, &dwType,
                                   (LPBYTE) &dwValue, &dwSize);
        RegCloseKey (hKey);
    }

    // Exit if a policy value was found.
    if (lResult == ERROR_SUCCESS && dwValue != 0) {
        return TRUE;
    }

    return FALSE;

}

VOID
LogAppHelpEvent(
    APPHELP_DATA    *pApphelpData
    )
{
    if (!AppHelpLogEnabled()) {
        return;
    }

    LPCWSTR apszMessage[1];
    HANDLE hEventLog = RegisterEventSourceW(NULL, L"apphelp");

    if (!hEventLog) {
                DWORD dwErr = GetLastError();
        } else {
        PSID pSID = GetCurrentUserSID();

        apszMessage[0] = pApphelpData->szAppName;

        if (pApphelpData->dwSeverity == APPHELP_HARDBLOCK) {
            ReportEventW(hEventLog,
                        EVENTLOG_INFORMATION_TYPE,
                        0,
                        ID_APPHELP_BLOCK_TRIGGERED,
                        pSID,
                        2,
                        0,
                        apszMessage,
                        NULL);

        } else {
            ReportEventW(hEventLog,
                        EVENTLOG_INFORMATION_TYPE,
                        0,
                        ID_APPHELP_TRIGGERED,
                        pSID,
                        2,
                        0,
                        apszMessage,
                        NULL);

        }

        DeleteCurrentUserSID(pSID);

        DeregisterEventSource(hEventLog);
    }
}


DWORD
ShowApphelp(
    IN  PAPPHELP_DATA pApphelpData,
    IN  LPCWSTR       pwszDetailsDatabasePath,
    IN  PDB           pdbDetails
    )
/*++
    Return: The return value can be one of the following based on what the user has
            selected:

                -1            - failed to show the info
                IDOK | 0x8000 - "no ui" checked, run the app
                IDCANCEL      - do not run the app
                IDOK          - run the app

    Desc:   Open the details database, collect the details info and then show it.
--*/
{
    DWORD dwRet = APPHELP_DIALOG_FAILED;
    BOOL  bCloseDetails = FALSE;

    if (pdbDetails == NULL) {
        //
        // Open the database containing the details info, if one wasn't passed in.
        //
        pdbDetails = SdbOpenApphelpDetailsDatabase(pwszDetailsDatabasePath);
        bCloseDetails = TRUE;
        if (pdbDetails == NULL) {
            DBGPRINT((sdlError, "ShowApphelp", "Failed to open the details database.\n"));
            goto Done;
        }
    }

    //
    // Read apphelp details data.
    //
    if (!SdbReadApphelpDetailsData(pdbDetails, pApphelpData)) {
        DBGPRINT((sdlError, "ShowApphelp", "Failed to read apphelp details.\n"));
        goto Done;
    }

    //
    // log an event, if necessary
    //
    LogAppHelpEvent(pApphelpData);

    //
    // Show the dialog box. The return values can be:
    //      -1            - error
    //      IDOK | 0x8000 - "no ui" checked, run the app
    //      IDCANCEL      - do not run the app
    //      IDOK          - run the app
    //
    dwRet = ShowApphelpDialog(pApphelpData);

    if (dwRet == APPHELP_DIALOG_FAILED) {
        DBGPRINT((sdlError, "ShowApphelp", "Failed to show the apphelp info.\n"));
    }

Done:
    if (pdbDetails != NULL && bCloseDetails) {
        SdbCloseDatabase(pdbDetails);
    }

    return dwRet;
}

void
FixEditControlScrollBar(
    IN  HWND hDlg,
    IN  int  nCtrlId
    )
/*++
    Return: void.

    Desc:   This function tricks the edit control to not show the vertical scrollbar
            unless absolutely necessary.
--*/
{
    HFONT       hFont = NULL;
    HFONT       hFontOld = NULL;
    HDC         hDC = NULL;
    TEXTMETRICW tm;
    RECT        rc;
    int         nVisibleLines = 0;
    int         nLines;
    DWORD       dwStyle;
    HWND        hCtl;

    //
    // Get the edit control's rectangle.
    //
    SendDlgItemMessageW(hDlg, nCtrlId, EM_GETRECT, 0, (LPARAM)&rc);

    //
    // Retrieve the number of lines.
    //
    nLines = (int)SendDlgItemMessageW(hDlg, nCtrlId, EM_GETLINECOUNT, 0, 0);

    //
    // Calculate how many lines will fit.
    //
    hFont = (HFONT)SendDlgItemMessageW(hDlg, nCtrlId, WM_GETFONT, 0, 0);

    if (hFont != NULL) {

        hDC = CreateCompatibleDC(NULL);

        if (hDC != NULL) {
            hFontOld = (HFONT)SelectObject(hDC, hFont);

            //
            // Now get the metrics
            //
            if (GetTextMetricsW(hDC, &tm)) {
                nVisibleLines = (rc.bottom - rc.top) / tm.tmHeight;
            }

            SelectObject(hDC, hFontOld);
            DeleteDC(hDC);
        }
    }

    if (nVisibleLines && nVisibleLines >= nLines) {
        hCtl = GetDlgItem(hDlg, nCtrlId);
        dwStyle = (DWORD)GetWindowLongPtrW(hCtl, GWL_STYLE);

        SetWindowLongPtrW(hCtl, GWL_STYLE, (LONG)(dwStyle & ~WS_VSCROLL));
        SetWindowPos(hCtl,
                     NULL,
                     0,
                     0,
                     0,
                     0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
    }
}




BOOL
ShowApphelpHtmlHelp(
    HWND            hDlg,
    PAPPHELP_DATA   pApphelpData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Shows html help using hhctrl.ocx
--*/
{
    WCHAR       szAppHelpURL[2048];
    WCHAR       szWindowsDir[MAX_PATH];
    WCHAR       szChmFile[MAX_PATH];
    WCHAR       szChmURL[1024];
    HINSTANCE   hInst = NULL;
    UINT        nChars;
    int         nChURL, nch;
    HRESULT     hr;
    DWORD       cch;
    LPWSTR      lpwszUnescaped = NULL;
    BOOL        bSuccess = FALSE;
    BOOL        bCustom = FALSE;
    LCID        lcid;
    size_t      nLen;
    BOOL        bFound = FALSE;

    bCustom = !(pApphelpData->dwData & SDB_DATABASE_MAIN);

    // apphelp is not in the main database, then it's custom apphelp

    nChars = GetSystemWindowsDirectoryW(szWindowsDir,
                                        CHARCOUNT(szWindowsDir));

    if (!nChars || nChars > CHARCOUNT(szWindowsDir)) {
        DBGPRINT((sdlError, "ShowApphelpHtmlHelp",
                  "Error trying to retrieve Windows Directory %d.\n", GetLastError()));
        goto errHandle;
    }

    lcid = GetUserDefaultUILanguage();

    if (lcid != MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)) {

        StringCchPrintfExW(szChmFile,
                           CHARCOUNT(szChmFile),
                           NULL,
                           &nLen,
                           0,
                           L"%s\\Help\\MUI\\%04x\\apps.chm",
                           szWindowsDir,
                           lcid);

        if (nLen > 0) {
            bFound = RtlDoesFileExists_U(szChmFile);
        }
    }

    if (!bFound) {
        StringCchPrintfW(szChmFile, CHARCOUNT(szChmFile), L"%s\\Help\\apps.chm", szWindowsDir);
    }

    if (bCustom) {
        //
        // this is a custom DB, and therefore the URL in it should be taken
        // as-is, without using the MS redirector
        //

        StringCchCopyW(szAppHelpURL, CHARCOUNT(szAppHelpURL), pApphelpData->szURL);

    } else {

        StringCchPrintfW(szAppHelpURL,
                         CHARCOUNT(szAppHelpURL),
                         L"hcp://services/redirect?online=");
        nChURL = wcslen(szAppHelpURL);

        //
        // When we are compiling retail we check for the offline content as well.
        //
        if (!g_bShowOnlyOfflineContent) {

            //
            // First thing, unescape url
            //
            if (pApphelpData->szURL != NULL) {

                //
                // Unescape the url first, using shell.
                //
                cch = wcslen(pApphelpData->szURL) + 1;

                lpwszUnescaped = (LPWSTR)malloc(cch * sizeof(WCHAR));

                if (lpwszUnescaped == NULL) {
                    DBGPRINT((sdlError,
                              "ShowApphelpHtmlHelp",
                              "Error trying to allocate memory for \"%S\"\n",
                              pApphelpData->szURL));
                    goto errHandle;
                }

                //
                // Unescape round 1 - use the shell function (same as used to encode
                // it for xml/database).
                //
                hr = UrlUnescapeW(pApphelpData->szURL, lpwszUnescaped, &cch, 0);
                if (!SUCCEEDED(hr)) {
                    DBGPRINT((sdlError,
                              "ShowApphelpHtmlHelp",
                              "UrlUnescapeW failed on \"%S\"\n",
                              pApphelpData->szURL));
                    goto errHandle;
                }

                //
                // Unescape round 2 - use our function borrowed from help center
                //
                cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);

                if (!SdbEscapeApphelpURL(szAppHelpURL + nChURL, &cch, lpwszUnescaped)) {
                    DBGPRINT((sdlError,
                              "ShowApphelpHtmlHelp",
                              "Error escaping URL \"%S\"\n",
                              lpwszUnescaped));
                    goto errHandle;
                }

                nChURL += (int)cch;
            }
        }


        //
        // At this point szAppHelpURL contains redirected URL for online usage
        // for custom db szAppHelpURL contains full URL
        //
        // If Apphelp file is provided -- use it
        //
        if (*g_wszApphelpPath) {
            StringCchPrintfW(szChmURL,
                             CHARCOUNT(szChmURL),
                             L"mk:@msitstore:%ls::/idh_w2_%d.htm",
                             g_wszApphelpPath,
                             pApphelpData->dwHTMLHelpID);
        } else {

            StringCchPrintfW(szChmURL,
                             CHARCOUNT(szChmURL),
                             L"mk:@msitstore:%ls::/idh_w2_%d.htm",
                             szChmFile,
                             pApphelpData->dwHTMLHelpID);

        }

        //
        // at this point szChmURL contains a URL pointing to the offline help file
        // we put it into the szAppHelpURL for both online and offline case
        //

        if (g_bShowOnlyOfflineContent) {
            cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);

            if (g_bUseHtmlHelp) {
                hr = UrlEscapeW(szChmURL, szAppHelpURL + nChURL, &cch, 0);
                if (SUCCEEDED(hr)) {
                    nChURL += (INT)cch;
                }
            } else {

                if (!SdbEscapeApphelpURL(szAppHelpURL+nChURL, &cch, szChmURL)) {
                    DBGPRINT((sdlError,  "ShowApphelpHtmlHelp", "Error escaping URL \"%S\"\n", szChmURL));
                    goto errHandle;
                }

                nChURL += (int)cch;
            }
        }

        //
        // now offline sequence
        //
        cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);
        StringCchPrintfW(szAppHelpURL + nChURL, cch, L"&offline=");
        nch = wcslen(szAppHelpURL + nChURL);
        nChURL += nch;

        cch = (DWORD)(CHARCOUNT(szAppHelpURL) - nChURL);

        if (!SdbEscapeApphelpURL(szAppHelpURL+nChURL, &cch, szChmURL)) {
            DBGPRINT((sdlError,  "ShowApphelpHtmlHelp", "Error escaping URL \"%S\"\n", szChmURL));
            goto errHandle;
        }

        nChURL += (int)cch;

        *(szAppHelpURL + nChURL) = L'\0';

    }

    //
    // WARNING: On Whistler execution of the following line will cause
    //          an AV (it works properly on Win2k) when it's executed twice
    //          from the same process. We should be able to just call
    //          shell with szAppHelpURL but we can't.
    //          So for now, use hh.exe as the stub.
    //
    // right before we do ShellExecute -- set current directory to windows dir
    //

    if (g_bUseHtmlHelp && !bCustom) {
        WCHAR szHHPath[MAX_PATH];

        DBGPRINT((sdlInfo,  "ShowApphelpHtmlHelp", "Opening Apphelp URL \"%S\"\n", szChmURL));

        StringCchCopyW(szHHPath, ARRAYSIZE(szHHPath), szWindowsDir);
        StringCchCatW(szHHPath, ARRAYSIZE(szHHPath), L"\\hh.exe");

        hInst = ShellExecuteW(hDlg, L"open", szHHPath, szChmURL, NULL, SW_SHOWNORMAL);
    } else if (!bCustom) {
        WCHAR szHSCPath[MAX_PATH];
        WCHAR* pszParameters;
        size_t  cchUrl = ARRAYSIZE(szAppHelpURL);
        static WCHAR szUrlPrefix[] = L"-url ";

        StringCchCopyW(szHSCPath, ARRAYSIZE(szHSCPath), szWindowsDir);
        StringCchCatW (szHSCPath, ARRAYSIZE(szHSCPath), L"\\pchealth\\helpctr\\binaries\\helpctr.exe");

        // format for parameters is " -url <our url>"
        StringCchLengthW(szAppHelpURL, ARRAYSIZE(szAppHelpURL), &cchUrl);

        cchUrl += CHARCOUNT(szUrlPrefix) + 1;
        pszParameters = new WCHAR[cchUrl];
        if (pszParameters == NULL) {
            bSuccess = FALSE;
            goto errHandle;
        }

        StringCchCopyW(pszParameters, cchUrl, szUrlPrefix);
        StringCchCatW (pszParameters, cchUrl, szAppHelpURL);

        DBGPRINT((sdlInfo,
                  "ShowApphelpHtmlHelp",
                  "Opening APPHELP URL \"%S\"\n",
                  szAppHelpURL));

        hInst = ShellExecuteW(hDlg, L"open", szHSCPath, pszParameters, NULL, SW_SHOWNORMAL);

        delete[] pszParameters;

    } else {
        DBGPRINT((sdlInfo,
                  "ShowApphelpHtmlHelp",
                  "Opening Custom APPHELP URL \"%S\"\n",
                  szAppHelpURL));

        hInst = ShellExecuteW(hDlg, L"open", szAppHelpURL, NULL, NULL, SW_SHOWNORMAL);
    }

    if (HandleToUlong(hInst) <= 32) {
        DBGPRINT((sdlError,
                  "ShowApphelpHtmlHelp",
                  "Error 0x%p trying to show help topic \"%ls\"\n",
                  hInst,
                  szAppHelpURL));
    }

    //
    // If we unload html help now we'll get weird and unpredictable behavior!
    // So don't do it :-(
    //
    bSuccess = (HandleToUlong(hInst) > 32);

errHandle:
    if (lpwszUnescaped != NULL) {
        free(lpwszUnescaped);
    }

    return bSuccess;

}


INT_PTR CALLBACK
AppCompatDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++
    Return: void.

    Desc:   This is the dialog proc for the apphelp dialog.
--*/
{
    BOOL            bReturn = TRUE;
    PAPPHELP_DATA   pApphelpData;

    pApphelpData = (PAPPHELP_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            WCHAR    wszMessage[2048];
            DWORD    dwResActionString;
            HFONT    hFont;
            LOGFONTW LogFont;
            WCHAR*   pwszAppTitle;
            INT      nChars;
            DWORD    dwDefID = IDD_DETAILS;
            DWORD    dwDefBtn; // old default button id
            HICON    hIcon;
            LPWSTR   IconID = MAKEINTRESOURCEW(IDI_WARNING);

            pApphelpData = (PAPPHELP_DATA)lParam;
            SetWindowLongPtrW(hDlg, DWLP_USER, (LONG_PTR)pApphelpData);

            //
            // Show the app icon.
            //
            hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDD_ICON_TRASH));

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)hIcon);

            mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
            SetForegroundWindow(hDlg);

            pwszAppTitle = pApphelpData->szAppTitle;

            if (pwszAppTitle == NULL) {
                pwszAppTitle = pApphelpData->szAppName;
            }

            if (pwszAppTitle != NULL) {

                SetDlgItemTextW(hDlg, IDD_APPNAME, pwszAppTitle);
                //
                // Make sure that we only utilize the first line of that text
                // for the window title.
                //
                SetWindowTextW(hDlg, pwszAppTitle);
            }

            hFont = (HFONT)SendDlgItemMessageW(hDlg,
                                               IDD_APPNAME,
                                               WM_GETFONT,
                                               0, 0);

            if (hFont && GetObjectW(hFont, sizeof(LogFont), (LPVOID)&LogFont)) {

                LogFont.lfWeight = FW_BOLD;

                hFont = CreateFontIndirectW(&LogFont);

                if (hFont != NULL) {
                    g_hFontBold = hFont;
                    SendDlgItemMessageW(hDlg,
                                        IDD_APPNAME,
                                        WM_SETFONT,
                                        (WPARAM)hFont, TRUE);
                }
            }

            //
            // By default, we have both RUN AND CANCEL
            //
            dwResActionString = IDS_APPCOMPAT_RUNCANCEL;

            switch (pApphelpData->dwSeverity) {

            case APPHELP_HARDBLOCK:
                //
                // Disable run button and "don't show this again" box
                // Reset the "defpushbutton" style from this one...
                //
                EnableWindow(GetDlgItem(hDlg, IDD_STATE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                dwResActionString = IDS_APPCOMPAT_CANCEL;
                dwDefID = IDD_DETAILS;  // set for hardblock case since RUN is not avail
                IconID = MAKEINTRESOURCEW(IDI_ERROR);
                break;

            case APPHELP_MINORPROBLEM:
                break;

            case APPHELP_NOBLOCK:
                break;

            case APPHELP_REINSTALL:
                break;
            }

            //
            // if we have no URL, or the URL begins with "null" gray out the "details" button
            //
            if (!pApphelpData->szURL || !pApphelpData->szURL[0] ||
                _wcsnicmp(pApphelpData->szURL, L"null", 4) == 0) {

                EnableWindow(GetDlgItem(hDlg, IDD_DETAILS), FALSE);
            }


            hIcon = LoadIconW(NULL, IconID);

            if (hIcon != NULL) {
                SendDlgItemMessageW(hDlg, IDD_ICON, STM_SETICON, (WPARAM)hIcon, 0);
            }

            //
            // Set the default push button
            // Reset the current default push button to a regular button.
            //
            // Update the default push button's control ID.
            //
            dwDefBtn = (DWORD)SendMessageW(hDlg, DM_GETDEFID, 0, 0);

            if (HIWORD(dwDefBtn) == DC_HASDEFID) {
                dwDefBtn = LOWORD(dwDefBtn);
                SendDlgItemMessageW(hDlg, dwDefBtn,  BM_SETSTYLE, BS_PUSHBUTTON, TRUE);
            }

            SendDlgItemMessageW(hDlg, dwDefID, BM_SETSTYLE, BS_DEFPUSHBUTTON, TRUE);
            SendMessageW(hDlg, DM_SETDEFID, (WPARAM)dwDefID, 0);

            //
            // now set the focus
            // be careful and do not mess with other focus-related messages, else use PostMessage here
            //
            SendMessageW(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, dwDefID), TRUE);

            //
            // If dwHTMLHelpID is not present disable "Details" button
            //
            if (!pApphelpData->dwHTMLHelpID) {
                EnableWindow(GetDlgItem(hDlg, IDD_DETAILS), FALSE);
            }

            wszMessage[0] = L'\0';

            LoadStringW(g_hInstance,
                        dwResActionString,
                        wszMessage,
                        sizeof(wszMessage) / sizeof(WCHAR));

            SetDlgItemTextW(hDlg, IDD_LINE_2, wszMessage);

            SetDlgItemTextW(hDlg,
                            IDD_APPHELP_DETAILS,
                            pApphelpData->szDetails ? pApphelpData->szDetails : L"");

            FixEditControlScrollBar(hDlg, IDD_APPHELP_DETAILS);

            //
            // Return false so that the default focus-setting would not apply.
            //
            bReturn = FALSE;
            break;
        }

    case WM_DESTROY:
        //
        // perform cleanup - remove the font we've had created
        //
        if (g_hFontBold != NULL) {
            DeleteObject(g_hFontBold);
            g_hFontBold = NULL;
        }

        AllowForegroundActivation();

        PostQuitMessage(0); // we just bailed out
        break;



    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
            //
            // Check the NO UI checkbox
            //
            EndDialog(hDlg, (INT_PTR)(IsDlgButtonChecked(hDlg, IDD_STATE) ? (IDOK | 0x8000) : IDOK));
            break;

        case IDCANCEL:
            EndDialog(hDlg, (INT_PTR)(IsDlgButtonChecked(hDlg, IDD_STATE) && g_bPreserveChoice ? (IDCANCEL | 0x8000) : IDCANCEL));
            break;

        case IDD_DETAILS:
            //
            // Launch details.
            //
            ShowApphelpHtmlHelp(hDlg, pApphelpData);
            break;

        default:
            bReturn = FALSE;
            break;
        }
        break;

    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}


typedef NTSTATUS (NTAPI *PFNUSERTESTTOKENFORINTERACTIVE)(HANDLE Token, PLUID pluidCaller);
PFNUSERTESTTOKENFORINTERACTIVE UserTestTokenForInteractive = NULL;

BOOL
CheckUserToken(
    )
/*++
    returns TRUE if the apphelp should be shown
            FALSE if we should not present apphelp UI
--*/
{
    NTSTATUS Status;
    HANDLE   hToken  = NULL;
    LUID     LuidUser;
    HMODULE  hWinsrv = NULL;
    BOOL     bShowUI = FALSE;
    UINT     nChars;
    WCHAR    szSystemDir[MAX_PATH];
    WCHAR    szWinsrvDll[MAX_PATH];
    static
    WCHAR    szWinsrvDllName[] = L"winsrv.dll";


    nChars = GetSystemDirectoryW(szSystemDir, CHARCOUNT(szSystemDir));
    if (nChars == 0 || nChars > CHARCOUNT(szSystemDir) - 2 - CHARCOUNT(szWinsrvDllName)) {
        DBGPRINT((sdlError, "CheckUserToken",
                 "Error trying to get systemdirectory %d.\n", GetLastError()));
        *szSystemDir = L'\0';
    } else {
        szSystemDir[nChars]     = L'\\';
        szSystemDir[nChars + 1] = L'\0';
    }

    StringCchCopyW(szWinsrvDll, ARRAYSIZE(szWinsrvDll), szSystemDir);
    StringCchCatW (szWinsrvDll, ARRAYSIZE(szWinsrvDll), szWinsrvDllName);

    hWinsrv = LoadLibraryW(szWinsrvDll);
    if (hWinsrv == NULL) {
        goto ErrHandle;
    }

    UserTestTokenForInteractive = (PFNUSERTESTTOKENFORINTERACTIVE)GetProcAddress(hWinsrv,
                                                                                 "_UserTestTokenForInteractive");
    if (UserTestTokenForInteractive == NULL) {
        goto ErrHandle;
    }


    Status = NtOpenProcessToken(NtCurrentProcess(),
                                TOKEN_QUERY,
                                &hToken);
    if (NT_SUCCESS(Status)) {

        Status = UserTestTokenForInteractive(hToken, &LuidUser);

        NtClose(hToken);

        if (NT_SUCCESS(Status)) {
            bShowUI = TRUE;
            goto ErrHandle;
        }

    }

    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_QUERY,
                               TRUE,
                               &hToken);

    if (NT_SUCCESS(Status)) {

        Status = UserTestTokenForInteractive(hToken, &LuidUser);

        NtClose(hToken);

        if (NT_SUCCESS(Status)) {
            bShowUI = TRUE;
            goto ErrHandle;
        }
    }

ErrHandle:

    if (hWinsrv) {
        FreeLibrary(hWinsrv);
    }

    return bShowUI;

}



BOOL
CheckWindowStation(
    )
/*++
    returns TRUE if the apphelp should be shown
            FALSE if we should not bother with apphelp UI


--*/

{
    HWINSTA hWindowStation;
    BOOL  bShowUI      = FALSE;
    DWORD dwLength     = 0;
    DWORD dwBufferSize = 0;
    DWORD dwError;
    BOOL  bSuccess;
    LPWSTR pwszWindowStation = NULL;

    hWindowStation = GetProcessWindowStation();
    if (hWindowStation == NULL) {
        DBGPRINT((sdlError,
                  "ApphelpCheckWindowStation",
                  "GetProcessWindowStation failed error 0x%lx\n", GetLastError()));
        goto ErrHandle;  // the app is not a Windows NT/Windows 2000 app??? try to show UI
    }

    // get the information please
    bSuccess = GetUserObjectInformationW(hWindowStation, UOI_NAME, NULL, 0, &dwBufferSize);
    if (!bSuccess) {
        dwError = GetLastError();
        if (dwError != ERROR_INSUFFICIENT_BUFFER) {
            DBGPRINT((sdlError,
                      "ApphelpCheckWindowStation",
                      "GetUserObjectInformation failed error 0x%lx\n", dwError));
            goto ErrHandle;
        }

        pwszWindowStation = (LPWSTR)malloc(dwBufferSize);
        if (pwszWindowStation == NULL) {
            DBGPRINT((sdlError,
                      "ApphelpCheckWindowStation",
                      "Failed to allocate 0x%lx bytes for Window Station name\n", dwBufferSize));
            goto ErrHandle;
        }

        // ok, call again
        bSuccess = GetUserObjectInformationW(hWindowStation,
                                             UOI_NAME,
                                             pwszWindowStation,
                                             dwBufferSize,
                                             &dwLength);
        if (!bSuccess) {
            DBGPRINT((sdlError,
                      "ApphelpCheckWindowStation",
                      "GetUserObjectInformation failed error 0x%lx, buffer size 0x%lx returned 0x%lx\n",
                      GetLastError(), dwBufferSize, dwLength));
            goto ErrHandle;
        }

        // now we have window station name, compare it to winsta0
        //
        bShowUI = (_wcsicmp(pwszWindowStation, L"Winsta0") == 0);

        if (!bShowUI) {
            DBGPRINT((sdlInfo,
                      "ApphelpCheckWindowStation",
                      "Apphelp UI will not be shown, running this process on window station \"%s\"\n",
                      pwszWindowStation));
        }
    }

    //
    // presumably we will try and check the token for interactive access
    //

ErrHandle:

    // should we do a close handle ???
    //
    if (hWindowStation != NULL) {
        CloseWindowStation(hWindowStation);
    }

    if (pwszWindowStation != NULL) {
        free(pwszWindowStation);
    }

    return bShowUI;

}

DWORD
ShowApphelpDialog(
    IN  PAPPHELP_DATA pApphelpData
    )
/*++
    Return: (IDOK | IDCANCEL) | [0x8000]
                IDOK | 0x8000 - the user has chosen to run the app and
                                checked "don't show me this anymore"
                IDOK          - the user has chosen to run the app, dialog will be shown again
                IDCANCEL      - the user has chosen not to run the app
                -1            - we have failed to import APIs necessary to show dlg box

    Desc:   Shows the dialog box with apphelp info.
--*/
{
    BOOL    bSuccess;
    INT_PTR retVal = 0;

    retVal = DialogBoxParamW(g_hInstance,
                             MAKEINTRESOURCEW(DLG_APPCOMPAT),
                             NULL,
                             AppCompatDlgProc,
                             (LPARAM)pApphelpData); // parameter happens to be a pointer of type PAPPHELP_DATA

    return (DWORD)retVal;
}

VOID
ParseCommandLineArgs(
    int argc,
    WCHAR* argv[]
    )
{
    WCHAR ch;
    WCHAR* pArg;
    WCHAR* pEnd;

    while (--argc) {
        pArg = argv[argc];
        if (*pArg == L'/' || *pArg == '-') {
            ch = *++pArg;
            switch(towupper(ch)) {
            case L'H':
                if (!_wcsnicmp(pArg, wszHtmlHelpID, CHARCOUNT(wszHtmlHelpID)-1)) {
                    pArg = wcschr(pArg, L':');
                    if (pArg) {
                        ++pArg; // skip over :
                        g_dwHtmlHelpID = (DWORD)wcstoul(pArg, &pEnd, 0);
                    }
                }
                break;
            case L'A':
                if (!_wcsnicmp(pArg, wszAppName, CHARCOUNT(wszAppName)-1)) {
                    pArg = wcschr(pArg, L':');
                    if (pArg) {
                        ++pArg;
                        g_pAppName = pArg; // this is app name, remove the quotes

                    }
                }
                break;
            case L'S':
                if (!_wcsnicmp(pArg, wszSeverity, CHARCOUNT(wszSeverity)-1)) {
                    pArg = wcschr(pArg, L':');
                    if (pArg) {
                        ++pArg;
                        g_dwSeverity = (DWORD)wcstoul(pArg, &pEnd, 0);
                    }
                }
                break;
            case L'T':
                if (!_wcsnicmp(pArg, wszTagID, CHARCOUNT(wszTagID)-1)) {
                    pArg = wcschr(pArg, L':');
                    if (pArg) {
                        ++pArg;
                        g_dwTagID = (DWORD)wcstoul(pArg, &pEnd, 0);
                    }
                }
                break;
            case L'G':
                if (!_wcsnicmp(pArg, wszGUID, CHARCOUNT(wszGUID)-1)) {
                    if ((pArg = wcschr(pArg, L':')) != NULL) {
                        ++pArg;
                        g_pszGuid = pArg;
                    }
                }
                break;
            case L'O':
                if (!_wcsnicmp(pArg, wszOfflineContent, CHARCOUNT(wszOfflineContent)-1)) {
                    g_bShowOnlyOfflineContent = TRUE;
                }
                break;
            case L'P':
                if (!_wcsnicmp(pArg, wszPreserveChoice, CHARCOUNT(wszPreserveChoice)-1)) {
                    g_bPreserveChoice = TRUE;
                } else if (!_wcsnicmp(pArg, wszPlatform, CHARCOUNT(wszPlatform) - 1)) {
                    if ((pArg = wcschr(pArg, L':')) != NULL) {
                        ++pArg;
                        //
                        // identify each of the supported platforms
                        //
                        if (!_wcsnicmp(pArg, wszX86, CHARCOUNT(wszX86) - 1)) {

                            g_uExeImageType = IMAGE_FILE_MACHINE_I386;

                        } else if (!_wcsnicmp(pArg, wszIA64, CHARCOUNT(wszIA64) - 1)) {

                            g_uExeImageType = IMAGE_FILE_MACHINE_IA64;
                        }
                    }
                }
                break;
            case L'M':
                if (!_wcsnicmp(pArg, wszMSI, CHARCOUNT(wszMSI))) {
                    g_bMSI = TRUE;
                }
                break;

            default:

                // unrecognized switch
                DBGPRINT((sdlError, "ParseCommandLineArgs",
                          "Unrecognized parameter %s\n", pArg));
                break;
            }
        } else {
            // not a switch
            if (*pArg == L'{') {
                g_pszGuid = pArg;
            } else {

                g_dwTagID = (DWORD)wcstoul(pArg, &pEnd, 0);

            }

        }
    }
}

INT_PTR CALLBACK
FeedbackDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++
    Return: void.

    Desc:   This is the dialog proc for the apphelp dialog.
--*/
{
    BOOL   bReturn = TRUE;
    LPWSTR lpszExeName;

    lpszExeName = (LPWSTR)GetWindowLongPtrW(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            HICON hIcon;

            lpszExeName = (LPWSTR)lParam;
            SetWindowLongPtrW(hDlg, DWLP_USER, (LONG_PTR)lpszExeName);

            //
            // Show the app icon.
            //
            hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDD_ICON_TRASH));

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)hIcon);

            SendDlgItemMessage(hDlg, IDC_WORKED, BM_SETCHECK, BST_CHECKED, 0);

        }
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
            EndDialog(hDlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;

        default:
            bReturn = FALSE;
            break;
        }
        break;

    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}

void
ShowFeedbackDialog(
    LPWSTR lpszAppName
    )
{
    DialogBoxParamW(g_hInstance,
                    MAKEINTRESOURCEW(DLG_FEEDBACK),
                    NULL,
                    FeedbackDlgProc,
                    (LPARAM)lpszAppName);
}


BOOL
CheckWOW64Redirection(
    int* pReturnCode
    )
/*++
    Return: TRUE if redirected
            FALSE if no redirection is needed

    Desc: Checks whether we're running on wow64, if so - redirects to 64-bit ahui.exe
--*/


{
    LPWSTR  pszCommandLine;
    UINT    nChars;
    WCHAR   szWindowsDir[MAX_PATH];
    WCHAR   szAhuiExePath[MAX_PATH];
    STARTUPINFOW        StartupInfo = { 0 };
    PROCESS_INFORMATION ProcessInfo = { 0 };
    static
    WCHAR   szPlatformX86[] = L"/Platform:X86";
    WCHAR*  pszAhuiCmdLine = NULL;
    DWORD   dwExit = 0;
    BOOL    bWow64 = FALSE;
    BOOL    bReturn = FALSE;
    BOOL    bRedirect = FALSE;
    WCHAR** argv = NULL;
    int     nArg, argc;
    size_t  cchCmd;
    size_t  cchLeft;
    WCHAR*  pchCur;

#ifndef _WIN64

    if (IsWow64Process(GetCurrentProcess(), &bWow64)) {
        if (!bWow64) {
            return FALSE;
        }
    }

    // if a check for wow64 failes, we do not redirect and will try to check
    // for interactive token. That test will fail and we won't show any UI,
    // which is better than the alternative (getting a service stuck on a
    // dialog which is invisible


#endif // _WIN64

    //
    // we are running in the context of a wow64 process, redirect to native 64-bit ahui.exe
    //

    nChars = GetSystemWindowsDirectoryW(szWindowsDir,
                                        CHARCOUNT(szWindowsDir));

    if (!nChars || nChars > CHARCOUNT(szWindowsDir) - 1) {
        DBGPRINT((sdlError, "CheckWow64Redirection",
                  "Error trying to retrieve Windows Directory %d.\n", GetLastError()));
        goto out;
    }

    StringCchPrintfW(szAhuiExePath, CHARCOUNT(szAhuiExePath), L"%s\\system32\\ahui.exe", szWindowsDir);

#ifndef _WIN64

    Wow64DisableFilesystemRedirector(szAhuiExePath);
    bRedirect = TRUE;

#endif

    pszCommandLine = GetCommandLineW();
    if (pszCommandLine == NULL) {
        goto out;
    }

    argv = CommandLineToArgvW(pszCommandLine, &argc);
    if (argv != NULL) {
        for (cchCmd = 0, nArg = 1; nArg < argc; ++nArg) {
            cchCmd += wcslen(argv[nArg]) + 2 + 1; // 2 for " " and 1 for space
        }
    }

    // now allocate space for command line, ahui exe path and additional parameter (/Platform:x86)

    nChars = wcslen(szAhuiExePath) + cchCmd + CHARCOUNT(szPlatformX86) + 3;

    pszAhuiCmdLine = new WCHAR[nChars];
    if (pszAhuiCmdLine == NULL) {
        goto out;
    }
    pchCur = pszAhuiCmdLine;
    cchLeft = nChars;

    StringCchPrintfExW(pszAhuiCmdLine, nChars, &pchCur, &cchLeft, 0, L"%s ", szAhuiExePath);
    if (argv != NULL) {
        for (nArg = 1; nArg < argc; ++nArg) {
            //
            // check for platform parameter, if it exists -- skip it
            //
            if ((*argv[nArg] == L'/' || *argv[nArg] == L'-') &&
                _wcsnicmp(argv[nArg] + 1, wszPlatform, CHARCOUNT(wszPlatform) - 1) == 0) {
                continue;
            }

            StringCchPrintfExW(pchCur, cchLeft, &pchCur, &cchLeft, 0, L" \"%s\"", argv[nArg]);
        }
    }

    StringCchPrintfExW(pchCur, cchLeft, &pchCur, &cchLeft, 0, L" %s", szPlatformX86);

    StartupInfo.cb = sizeof(StartupInfo);

    if (!CreateProcessW(szAhuiExePath,
                        pszAhuiCmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        0,
                        NULL,
                        NULL,
                        &StartupInfo, &ProcessInfo)) {
        DBGPRINT((sdlError, "CheckWow64Redirection",
                  "Failed to launch apphelp process %d.\n", GetLastError()));
        goto out;

    }

    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

    bReturn = GetExitCodeProcess(ProcessInfo.hProcess, &dwExit);
    if (bReturn) {
        *pReturnCode = (int)dwExit;
        bReturn = TRUE;
    }

out:
    if (pszAhuiCmdLine) {
        delete[] pszAhuiCmdLine;
    }

    if (argv) {
        HGLOBAL hMem = GlobalHandle(argv);
        if (hMem != NULL) {
            GlobalFree(hMem);
        }
    }

#ifndef _WIN64
    if (bRedirect) {
        Wow64EnableFilesystemRedirector();
    }

#endif
    return bReturn;
}



extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR    lpCmdLine,
    int       nCmdShow
    )
/*++
    Return: 1 if the app for which the apphelp is shown should run, 0 otherwise.

    Desc:   The command line looks like this:

            apphelp.exe GUID tagID [USELOCALCHM USEHTMLHELP APPHELPPATH]

            Ex:
                apphelp.exe {243B08D7-8CF7-4072-AF64-FD5DF4085E26} 0x0000009E

                apphelp.exe {243B08D7-8CF7-4072-AF64-FD5DF4085E26} 0x0000009E 1 1 c:\temp
--*/
{
    int             nReturn = 1;  // we always default to running, if something goes wrong
    LPWSTR          szCommandLine;
    LPWSTR*         argv;
    int             argc;
    UNICODE_STRING  ustrGuid;
    GUID            guidDB    = { 0 };
    GUID            guidExeID = { 0 };
    TAGID           tiExe = TAGID_NULL;
    TAGID           tiExeID = TAGID_NULL;
    TAGREF          trExe = TAGREF_NULL;
    WCHAR           wszDBPath[MAX_PATH];
    DWORD           dwType = 0;
    APPHELP_DATA    ApphelpData;
    WCHAR           szDBPath[MAX_PATH];
    HSDB            hSDB = NULL;
    PDB             pdb = NULL;
    DWORD           dwFlags = 0;
    BOOL            bAppHelp = FALSE;
    BOOL            bRunApp = FALSE;

    g_hInstance = hInstance;

#ifndef _WIN64

    if (CheckWOW64Redirection(&nReturn)) {
        goto out;
    }
#endif // _WIN64

    InitCommonControls();
    ZeroMemory(&ApphelpData, sizeof(ApphelpData));

    //
    // Note that this memory isn't freed because it will automatically
    // be freed on exit anyway, and there are a lot of exit cases from
    // this application.
    //
    szCommandLine = GetCommandLineW();
    argv = CommandLineToArgvW(szCommandLine, &argc);

    ParseCommandLineArgs(argc, argv);

    if (argc > 1) {
        if (_wcsicmp(L"feedback", argv[1]) == 0) {
            ShowFeedbackDialog(argc > 2 ? argv[2] : NULL);
        }
    }

    if (g_pszGuid == NULL) {
        DBGPRINT((sdlError, "AHUI!wWinMain",
                  "GUID not provided\n"));
        goto out;
    }

    if (!(g_dwTagID ^ g_dwHtmlHelpID)) {
        DBGPRINT((sdlError, "AHUI!wWinMain",
                   "Only TagID or HtmlHelpID should be provided\n"));
        goto out;
    }

    RtlInitUnicodeString(&ustrGuid, g_pszGuid);

    if (g_dwHtmlHelpID) {
        //
        // provided here: guid, severity and html help id along with app name
        //

        if (!NT_SUCCESS(RtlGUIDFromString(&ustrGuid, &guidExeID))) {
            DBGPRINT((sdlError,
                       "Ahui!wWinMain",
                       "Error getting GUID from string %s\n", g_pszGuid));
            goto out;
        }
        ApphelpData.dwSeverity   = g_dwSeverity;
        ApphelpData.dwHTMLHelpID = g_dwHtmlHelpID;
        ApphelpData.szAppName    = (LPWSTR)g_pAppName;
        bAppHelp = TRUE;
        dwType   = SDB_DATABASE_MAIN_SHIM;
        goto ProceedWithApphelp;
    }

    // non-htmlid case, guid is a database guid
    // also dwTagID is specified

    if (RtlGUIDFromString(&ustrGuid, &guidDB) != STATUS_SUCCESS) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error trying to convert GUID string %S.\n",
                  g_pszGuid));
        goto out;
    }

    tiExe = (TAGID)g_dwTagID;

    if (tiExe == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error getting TAGID from param %S\n",
                  argv[2]));
        goto out;
    }

    hSDB = SdbInitDatabaseEx(0, NULL, g_uExeImageType);

    if (!hSDB) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error initing database context.\n"));
        goto out;
    }

    if (g_bMSI) {
        SdbSetImageType(hSDB, IMAGE_FILE_MSI);
    }

    pdb = SdbGetPDBFromGUID(hSDB, &guidDB);

    if (!pdb) {
        DWORD dwLen;

        //
        // It's not one of the main DBs, try it as a local.
        //
        dwLen = SdbResolveDatabase(hSDB, &guidDB, &dwType, szDBPath, MAX_PATH);

        if (!dwLen || dwLen > MAX_PATH) {
            DBGPRINT((sdlError,
                      "AppHelp.exe!wWinMain",
                      "Error resolving database from GUID\n"));
            goto out;
        }

        //
        // We have many "main" databases -- we should limit the check
        //

        if (dwType != SDB_DATABASE_MAIN_SHIM && dwType != SDB_DATABASE_MAIN_TEST) {
            SdbOpenLocalDatabase(hSDB, szDBPath);
        }

        pdb = SdbGetPDBFromGUID(hSDB, &guidDB);
        if (!pdb) {
            DBGPRINT((sdlError,
                      "AppHelp.exe!wWinMain",
                      "Error getting pdb from GUID.\n"));
            goto out;
        }
    } else {

        dwType |= SDB_DATABASE_MAIN; // we will use details from the main db

    }

    if (!SdbTagIDToTagRef(hSDB, pdb, tiExe, &trExe)) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error converting TAGID to TAGREF.\n"));
        goto out;
    }

    tiExeID = SdbFindFirstTag(pdb, tiExe, TAG_EXE_ID);

    if (tiExeID == TAGID_NULL) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error trying to find TAG_EXE_ID.\n"));
        goto out;
    }

    if (!SdbReadBinaryTag(pdb,
                          tiExeID,
                          (PBYTE)&guidExeID,
                          sizeof(GUID))) {
        DBGPRINT((sdlError,
                  "AppHelp.exe!wWinMain",
                  "Error trying to read TAG_EXE_ID.\n"));
        goto out;
    }


    bAppHelp = SdbReadApphelpData(hSDB, trExe, &ApphelpData);

ProceedWithApphelp:
    if (SdbIsNullGUID(&guidExeID) || !SdbGetEntryFlags(&guidExeID, &dwFlags)) {
        dwFlags = 0;
    }

    if (bAppHelp) {

        //
        // Check whether the disable bit is set.
        //
        if (!(dwFlags & SHIMREG_DISABLE_APPHELP)) {

            BOOL bNoUI;

            //
            // See whether the user has checked "Don't show this anymore" box before.
            //
            bNoUI = ((dwFlags & SHIMREG_APPHELP_NOUI) != 0);

            if (!bNoUI) {
                bNoUI = !CheckWindowStation();
            }
            if (!bNoUI) {
                bNoUI = !CheckUserToken();
            }

            if (bNoUI) {
                DBGPRINT((sdlInfo,
                          "bCheckRunBadapp",
                          "NoUI flag is set, apphelp UI disabled for this app.\n"));
            }

            //
            // depending on severity of the problem...
            //
            switch (ApphelpData.dwSeverity) {
            case APPHELP_MINORPROBLEM:
            case APPHELP_HARDBLOCK:
            case APPHELP_NOBLOCK:
            case APPHELP_REINSTALL:
                if (bNoUI) {

                    bRunApp = (ApphelpData.dwSeverity != APPHELP_HARDBLOCK) && !(dwFlags & SHIMREG_APPHELP_CANCEL);

                } else {
                    DWORD dwRet;

                    //
                    // Show the UI. This function returns -1 in case of error or one
                    // of the following values on success:
                    //    IDOK | 0x8000 - "no ui" checked, run app
                    //    IDCANCEL      - do not run app
                    //    IDOK          - run app

                    ApphelpData.dwData = dwType;  // we use custom data for database type

                    dwRet = ShowApphelp(&ApphelpData, NULL, (dwType & SDB_DATABASE_MAIN) ? NULL : SdbGetLocalPDB(hSDB));

                    if (dwRet != APPHELP_DIALOG_FAILED) {
                        //
                        // The UI was shown. See whether the user has
                        // checked the "no ui" box.
                        //

                        if (dwRet & 0x8000) {
                            //
                            // "no ui" box was checked. Save the appropriate bits
                            // in the registry.
                            //
                            dwFlags |= SHIMREG_APPHELP_NOUI;

                            if ((dwRet & 0x0FFF) != IDOK) {
                                dwFlags |= SHIMREG_APPHELP_CANCEL; // we will not be hitting this path unless g_bPreserveChoice is enabled
                            }

                            if (!SdbIsNullGUID(&guidExeID)) {
                                SdbSetEntryFlags(&guidExeID, dwFlags);
                            }
                        }
                        //
                        // Check whether the user has chosen to run the app.
                        //
                        bRunApp = ((dwRet & 0x0FFF) == IDOK) && (ApphelpData.dwSeverity != APPHELP_HARDBLOCK);
                    } else {
                        //
                        // The UI was not shown (some error prevented that).
                        // If the app is not "Hardblock" run it anyway.
                        //
                        bRunApp = (APPHELP_HARDBLOCK != ApphelpData.dwSeverity);
                    }
                }
                break;
            }

        }
    }

    if (!bRunApp) {
        nReturn = 0;
    }

out:

    return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\apphelp\path.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        path.c

    Abstract:

        This module implements string utilities for dealing with NT device names.

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        clupu      cleanup     12/27/2000
--*/

#include "apphelp.h"


UNICODE_STRING DosDevicePrefix    = RTL_CONSTANT_STRING(L"\\??\\");
UNICODE_STRING DosDeviceUNCPrefix = RTL_CONSTANT_STRING(L"\\??\\UNC\\");


BOOL
CheckStringPrefixUnicode(
    IN  PUNICODE_STRING pStrPrefix,     // the prefix to check for
    IN  PUNICODE_STRING pString,        // the string
    IN  BOOL            CaseInSensitive
    )
/*++
    Return: TRUE if the specified string contains pStrPrefix at it's start.

    Desc:   Verifies if a string is a prefix in another unicode counted string.
            It is equivalent to RtlStringPrefix.
--*/
{
    PWSTR ps1, ps2;
    UINT  n;
    WCHAR c1, c2;

    n = pStrPrefix->Length;
    if (pString->Length < n) {
        return FALSE;
    }

    n /= sizeof(WCHAR); // convert to char count

    ps1 = pStrPrefix->Buffer;
    ps2 = pString->Buffer;

    if (CaseInSensitive) {
        while (n--) {
            c1 = *ps1++;
            c2 = *ps2++;

            if (c1 != c2) {
                c1 = RtlUpcaseUnicodeChar(c1);
                c2 = RtlUpcaseUnicodeChar(c2);
                if (c1 != c2) {
                    return FALSE;
                }
            }
        }
    } else {
        while (n--) {
            if (*ps1++ != *ps2++) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
DeleteCharsUnicodeString(
    OUT PUNICODE_STRING pStringDest,    // UNICODE string to operate on
    IN  USHORT          nIndexStart,    // starting byte for deletion
    IN  USHORT          nLength         // number of bytes to be removed
    )
/*++
    Return: TRUE if the characters were removed, FALSE on failure.

    Desc:   Removes the specified number of characters from a unicode string
            starting at the specified position (including starting character).
--*/
{
    if (nIndexStart > pStringDest->Length) { // start past length
        return FALSE;
    }

    if (nLength >= (pStringDest->Length - nIndexStart)) {
        pStringDest->Length = nIndexStart;
        *(PWCHAR)((PUCHAR)pStringDest->Buffer + nIndexStart) = UNICODE_NULL;
    } else {
        USHORT nNewLength;

        nNewLength = pStringDest->Length - nLength;

        RtlMoveMemory((PUCHAR)pStringDest->Buffer + nIndexStart,
                      (PUCHAR)pStringDest->Buffer + nIndexStart + nLength,
                      nNewLength - nIndexStart);

        pStringDest->Length = nNewLength;
        *(PWCHAR)((PUCHAR)pStringDest->Buffer + nNewLength) = UNICODE_NULL;
    }

    return TRUE;
}


void
InitZeroUnicodeString(
    OUT PUNICODE_STRING pStr,
    IN  PWSTR           pwsz,
    IN  USHORT          nMaximumLength
    )
/*++
    Return: void.

    Desc:   Initializes an empty UNICODE string given the pointer
            starting at the specified position (including starting character).
--*/
{
    pStr->Length = 0;
    pStr->MaximumLength = nMaximumLength;
    pStr->Buffer = pwsz;
    
    if (pwsz != NULL) {
        pwsz[0] = UNICODE_NULL;
    }
}

static WCHAR szStaticDosPathBuffer[MAX_PATH];

void
FreeDosPath(
    WCHAR* pDosPath
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    //
    // Check whether this memory points to our internal buffer.
    // If not then this was allocated. We need to free it.
    //
    if (pDosPath &&
        ((ULONG_PTR)pDosPath < (ULONG_PTR)szStaticDosPathBuffer ||
        (ULONG_PTR)pDosPath >= ((ULONG_PTR)szStaticDosPathBuffer) + sizeof(szStaticDosPathBuffer))) {
        SdbFree(pDosPath);
    }
}


BOOL
ConvertToDosPath(
    OUT LPWSTR*  ppDosPath,
    IN  LPCWSTR  pwszPath
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function can determine what sort of path has been given to it.
            If it's NT Path it returns DosPath.
            The function returns path name in a static buffer which is global 
            or allocates memory as necessary if the static buffer is not
            large enough.
--*/
{
    UNICODE_STRING ustrPath;
    UNICODE_STRING ustrDosPath;
    WCHAR*         pDosPath;

    RtlInitUnicodeString(&ustrPath, pwszPath);

    //
    // If the length is sufficient use the static buffer. If not allocate memory.
    //
    if (ustrPath.Length < sizeof(szStaticDosPathBuffer)) {
        pDosPath = szStaticDosPathBuffer;
    } else {
        //
        // Allocate an output buffer that is large enough
        //
        pDosPath = SdbAlloc(ustrPath.Length + sizeof(UNICODE_NULL));
        
        if (pDosPath == NULL) {
            DBGPRINT((sdlError,
                      "ConvertToDosPath",
                      "Failed to allocate %d bytes\n",
                      ustrPath.Length + sizeof(UNICODE_NULL)));
            return FALSE;
        }
    }
    
    InitZeroUnicodeString(&ustrDosPath, pDosPath, ustrPath.Length + sizeof(UNICODE_NULL));

    //
    // Now it's unicode string. Copy the source string into it.
    //
    RtlCopyUnicodeString(&ustrDosPath, &ustrPath);

    if (CheckStringPrefixUnicode(&DosDeviceUNCPrefix, &ustrDosPath, TRUE)) {
        //
        // UNC path name. We convert it to DosPathName.
        //
        DeleteCharsUnicodeString(&ustrDosPath,
                                 (USHORT)0,
                                 (USHORT)(DosDeviceUNCPrefix.Length - 2 * sizeof(WCHAR)));

        ustrDosPath.Buffer[0] = L'\\';

         
    } else {
        //
        // The string is not prefixed by <UNC\>
        //
        if (CheckStringPrefixUnicode(&DosDevicePrefix, &ustrDosPath, TRUE)) {

            DeleteCharsUnicodeString(&ustrDosPath,
                                     0,
                                     DosDevicePrefix.Length);
        }
    }

    *ppDosPath = pDosPath;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\appverifier.cpp ===
#include "precomp.h"

#include "dbsupport.h"
#include "viewlog.h"

using namespace ShimLib;

//#define AV_OPTIONS_KEY  L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\AppVerifier"

#define AV_OPTION_CLEAR_LOG     L"ClearLogsBeforeRun"
#define AV_OPTION_BREAK_ON_LOG  L"BreakOnLog"
#define AV_OPTION_FULL_PAGEHEAP L"FullPageHeap"
#define AV_OPTION_AV_DEBUGGER   L"UseAVDebugger"
#define AV_OPTION_DEBUGGER      L"Debugger"
#define AV_OPTION_PROPAGATE     L"PropagateTests"


//
// Forward declarations
//

CWinApp theApp;


HINSTANCE g_hInstance = NULL;

BOOL    g_bSettingsDirty = FALSE;

BOOL    g_bRefreshingSettings = FALSE;

BOOL    g_bConsoleMode = FALSE;

BOOL    g_bWin2KMode = FALSE;

BOOL    g_bInternalMode = FALSE;

//
// dialog handles
//
HWND    g_hDlgMain = NULL;
HWND    g_hDlgOptions = NULL;

// forward function declarations
INT_PTR CALLBACK
DlgMain(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
DlgRunAlone(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
DlgConflict(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    );

void
RefreshSettingsList(
    HWND hDlg,
    BOOL bForceRefresh = FALSE
    );

void
ReadOptions(
    void
    );

BOOL
GetAppTitleString(
    wstring &strTitle
    )
{
    wstring strVersion;

    if (!AVLoadString(IDS_APP_NAME, strTitle)) {
        return FALSE;
    }

#if defined(_WIN64)
    if (!AVLoadString(IDS_VERSION_STRING_64, strVersion)) {
        return FALSE;
    }
#else
    if (!AVLoadString(IDS_VERSION_STRING, strVersion)) {
        return FALSE;
    }
#endif

    strTitle += L" ";
    strTitle += strVersion;

    return TRUE;
}

void
ShowHTMLHelp(
    void
    )
{
    SHELLEXECUTEINFOW sei;
    WCHAR               szPath[MAX_PATH];
    WCHAR*              pszBackSlash;


    DWORD dwLen = GetModuleFileName(NULL, szPath, ARRAY_LENGTH(szPath));

    if (!dwLen) {
        return;
    }

    pszBackSlash = wcsrchr(szPath, L'\\');
    if (pszBackSlash) {
        pszBackSlash++;
        *pszBackSlash = 0;
    } else {
        //
        // punt and just try to find it on the path
        //
        szPath[0] = 0;
    }

    StringCchCatW(szPath, ARRAY_LENGTH(szPath), L"appverif.chm");

    ZeroMemory(&sei, sizeof(sei));

    sei.cbSize = sizeof(sei);
    sei.lpVerb = L"open";
    sei.lpFile = szPath;
    sei.nShow = SW_SHOWNORMAL;

    ShellExecuteExW(&sei);
}

BOOL
SearchGroupForSID(
    DWORD dwGroup,
    BOOL* pfIsMember
    )
{
    PSID                     pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {
        return FALSE;
    }

    if (!pSID) {
        return FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

BOOL
CanRun(
    void
    )
{
    BOOL fIsAdmin;

    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin))
    {
        return FALSE;
    }

    return fIsAdmin;
}

void
DumpResourceStringsToConsole(ULONG ulBegin, ULONG ulEnd)
{
    ULONG ulRes;
    wstring strText;

    for (ulRes = ulBegin; ulRes != ulEnd + 1; ++ulRes) {
        if (AVLoadString(ulRes, strText)) {
            printf("%ls\n", strText.c_str());
        }
    }
}

void
DumpCurrentSettingsToConsole(void)
{
    CAVAppInfo *pApp;

    DumpResourceStringsToConsole(IDS_CURRENT_SETTINGS, IDS_CURRENT_SETTINGS);

    for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
        printf("%ls:\n", pApp->wstrExeName.c_str());

        CTestInfo *pTest;

        for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
            if (pApp->IsTestActive(*pTest)) {
                printf("    %ls\n", pTest->strTestName.c_str());
            }
        }

        printf("\n");
    }

    DumpResourceStringsToConsole(IDS_DONE, IDS_DONE);
}

void
DumpHelpToConsole(void)
{

    DumpResourceStringsToConsole(IDS_HELP_INTRO_00, IDS_HELP_INTRO_10);

    CTestInfo *pTest;

    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->eTestType == TEST_KERNEL && 
            ((pTest->bInternal && g_bInternalMode) || (pTest->bExternal && !g_bInternalMode)) &&
            (pTest->bWin2KCompatible || !g_bWin2KMode)) {

            printf("    %ls\n", pTest->strTestName.c_str());
        }
    }

    DumpResourceStringsToConsole(IDS_HELP_SHIM_TESTS, IDS_HELP_SHIM_TESTS);

    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->eTestType == TEST_SHIM && 
            ((pTest->bInternal && g_bInternalMode) || (pTest->bExternal && !g_bInternalMode)) &&
            (pTest->bWin2KCompatible || !g_bWin2KMode)) {

            printf("    %ls\n", pTest->strTestName.c_str());
        }
    }

    DumpResourceStringsToConsole(IDS_HELP_EXAMPLE_00, IDS_HELP_EXAMPLE_11);
}

void
HandleCommandLine(int argc, LPWSTR *argv)
{
    WCHAR szApp[MAX_PATH];
    wstring strTemp;
    CWStringArray astrApps;

    szApp[0] = 0;

    g_bConsoleMode = TRUE;

    //
    // print the title
    //
    if (GetAppTitleString(strTemp)) {
        printf("\n%ls\n", strTemp.c_str());
    }
    if (AVLoadString(IDS_COPYRIGHT, strTemp)) {
        printf("%ls\n\n", strTemp.c_str());
    }

    //
    // check for global operations
    //
    if (_wcsnicmp(argv[0], L"/q", 2) == 0) { // querysettings
        DumpCurrentSettingsToConsole();
        return;
    }
    if (_wcsicmp(argv[0], L"/?") == 0) {  // help
        DumpHelpToConsole();
        return;
    }
    if (_wcsnicmp(argv[0], L"/r", 2) == 0) { // reset
        g_aAppInfo.clear();
        goto out;
    }

    //
    // first get a list of the app names
    //
    for (int nArg = 0 ; nArg != argc; nArg++) {
        WCHAR wc = argv[nArg][0];

        if (wc != L'/' && wc != L'-' && wc != L'+') {
            astrApps.push_back(argv[nArg]);
        }
    }

    if (astrApps.size() == 0) {
        AVErrorResourceFormat(IDS_NO_APP);
        DumpHelpToConsole();
        return;
    }

    //
    // now for each app name, parse the list and adjust its settings
    //
    for (wstring *pStr = astrApps.begin(); pStr != astrApps.end(); pStr++) {
        CAVAppInfo *pApp;
        BOOL bFound = FALSE;

        //
        // check to see if they submitted a full path
        //
        const WCHAR * pExe = NULL;
        const WCHAR * pPath = NULL;

        pExe = wcsrchr(pStr->c_str(), L'\\');
        if (!pExe) {
            if ((*pStr)[1] == L':') {
                pExe = pStr->c_str() + 2;
            }
        } else {
            pExe++;
        }

        if (pExe) {
            pPath = pStr->c_str();
        } else {
            pExe = pStr->c_str();
        }

        //
        // first, find or add the app to the list, and get a pointer to it
        //
        for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
            if (_wcsicmp(pApp->wstrExeName.c_str(), pExe) == 0) {
                bFound = TRUE;
                break;
            }
        }
        if (!bFound) {
            CAVAppInfo App;

            App.wstrExeName = pExe;
            g_aAppInfo.push_back(App);
            pApp = g_aAppInfo.end() - 1;
        }

        //
        // if they submitted a full path, update the records
        //
        if (pPath) {
            pApp->wstrExePath = pPath;
        }

        //
        // now walk the command line again and make the adjustments
        //
        for (int nArg = 0 ; nArg != argc; nArg++) {
            if (argv[nArg][0] == L'/') {
                if (_wcsnicmp(argv[nArg], L"/a", 2) == 0) {  // all

                    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
                        pApp->AddTest(*pTest);
                    }
                } else if (_wcsnicmp(argv[nArg], L"/n", 2) == 0) {  // none

                    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
                        pApp->RemoveTest(*pTest);
                    }
                } else if (_wcsnicmp(argv[nArg], L"/d", 2) == 0) {  // default

                    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
                        if (pTest->bDefault) {
                            pApp->AddTest(*pTest);
                        } else {
                            pApp->RemoveTest(*pTest);
                        }
                    }
                } else {

                    //
                    // unknown parameter
                    //
                    AVErrorResourceFormat(IDS_INVALID_PARAMETER, argv[nArg]);
                    DumpHelpToConsole();
                    return;
                }

            } else if (argv[nArg][0] == L'+' || argv[nArg][0] == L'-') {

                BOOL bAdd = (argv[nArg][0] == L'+');
                LPWSTR szParam = argv[nArg] + 1;

                //
                // see if it's a shim name
                //
                CTestInfo *pTest;
                bFound = FALSE;

                for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
                    if (_wcsicmp(szParam, pTest->strTestName.c_str()) == 0) {
                        if (bAdd) {
                            pApp->AddTest(*pTest);
                        } else {
                            pApp->RemoveTest(*pTest);
                        }
                        bFound = TRUE;
                        break;
                    }
                }

                if (!bFound) {
                    //
                    // unknown test
                    //

                    AVErrorResourceFormat(IDS_INVALID_TEST, szParam);
                    DumpHelpToConsole();
                    return;
                }
            }
            //
            // anything that doesn't begin with a slash, plus, or minus
            // is an app name, so we'll ignore it
            //

        }
    }

out:
    //
    // save them to disk/registry
    //
    SetCurrentAppSettings();

    //
    // show them the current settings, for verification
    //
    DumpCurrentSettingsToConsole();
}

BOOL
CheckWindowsVersion(void)
{
    OSVERSIONINFOEXW VersionInfo;

    ZeroMemory(&VersionInfo, sizeof(OSVERSIONINFOEXW));
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);

    GetVersionEx((LPOSVERSIONINFOW)&VersionInfo);

    if (VersionInfo.dwMajorVersion < 5 ||
		(VersionInfo.dwMajorVersion == 5 && VersionInfo.dwMinorVersion == 0 && VersionInfo.wServicePackMajor < 3)) {
        //
        // too early - can't run
        //

        AVErrorResourceFormat(IDS_INVALID_VERSION);

        return FALSE;

    } else if (VersionInfo.dwMajorVersion == 5 && VersionInfo.dwMinorVersion == 0) {
        //
        // Win2K
        //
        g_bWin2KMode = TRUE;
    } else {
        //
        // WinXP or above -- all is well
        //
        g_bWin2KMode = FALSE;
    }

    return TRUE;
}


extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR    lpCmdLine,
    int       nCmdShow
    )
{
    LPWSTR* argv = NULL;
    int     argc = 0;

    g_hInstance = hInstance;

    //
    // check for appropriate version
    //
    if (!CheckWindowsVersion()) {
        return 0;
    }

    //
    // check for administrator access
    //
    if (!CanRun()) {
        AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
        return 0;
    }

    //
    // check for internal mode
    //
    g_bInternalMode = IsInternalModeEnabled();

    InitTestInfo();

    GetCurrentAppSettings();

    ReadOptions();

    if (lpCmdLine && lpCmdLine[0]) {
        argv = CommandLineToArgvW(lpCmdLine, &argc);
    }

    if (argc > 0) {
        //
        // we're in console mode, so handle everything as a console
        //
        HandleCommandLine(argc, argv);
        return 1;
    }

    FreeConsole();

    InitCommonControls();

    LinkWindow_RegisterClass();

    HACCEL hAccelMain = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDR_ACCEL_MAIN));

    HWND hMainDlg = CreateDialog(g_hInstance, (LPCTSTR)IDD_DLG_MAIN, NULL, DlgMain);

    MSG msg;

    //
    // Main message loop:
    //
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!hAccelMain || !TranslateAccelerator(hMainDlg, hAccelMain, &msg)) {
            if (!IsDialogMessage(hMainDlg, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    return 0;
}

void
RefreshAppList(
    HWND hDlg
    )
{
    CAVAppInfoArray::iterator it;

    HWND hList = GetDlgItem(hDlg, IDC_LIST_APPS);

    ListView_DeleteAllItems(hList);

    for (it = g_aAppInfo.begin(); it != g_aAppInfo.end(); it++) {
        LVITEM lvi;

        lvi.mask      = LVIF_TEXT | LVIF_PARAM;
        lvi.pszText   = (LPWSTR)it->wstrExeName.c_str();
        lvi.lParam    = (LPARAM)it;
        lvi.iItem     = 9999;
        lvi.iSubItem  = 0;

        ListView_InsertItem(hList, &lvi);
    }

    RefreshSettingsList(hDlg);
}

void
DirtySettings(
    HWND hDlg,
    BOOL bDirty
    )
{
    g_bSettingsDirty = bDirty;
}

void
SaveSettings(
    HWND hDlg
    )
{
    DirtySettings(hDlg, FALSE);

    SetCurrentAppSettings();
}

void
SaveSettingsIfDirty(HWND hDlg)
{
    if (g_bSettingsDirty) {
        SaveSettings(hDlg);
    }
}

void
DisplayLog(
    HWND hDlg
    )
{
    g_szSingleLogFile[0] = 0;

    DialogBox(g_hInstance, (LPCTSTR)IDD_VIEWLOG_PAGE, hDlg, DlgViewLog);
}

void
DisplaySingleLog(HWND hDlg)
{
    WCHAR           wszFilter[] = L"Log files (*.log)\0*.log\0";
    OPENFILENAME    ofn;
    WCHAR           wszAppFullPath[MAX_PATH];
    WCHAR           wszAppShortName[MAX_PATH];
    HRESULT         hr;

    wstring         wstrLogTitle;

    if (!AVLoadString(IDS_VIEW_EXPORTED_LOG_TITLE, wstrLogTitle)) {
        wstrLogTitle = _T("View Exported Log");
    }

    wszAppFullPath[0] = 0;

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = wszFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = wszAppFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = wszAppShortName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = wstrLogTitle.c_str();
    ofn.Flags             = OFN_PATHMUSTEXIST       |
                            OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
                            OFN_NONETWORKBUTTON     |           // no network button
                            OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
                            OFN_SHAREAWARE;                     // don't check the existance of file with OpenFile
    ofn.lpstrDefExt       = _T("log");

    if ( !GetOpenFileName(&ofn) )
    {
        goto out;
    }

    hr = StringCchCopyW(g_szSingleLogFile, ARRAY_LENGTH(g_szSingleLogFile), wszAppFullPath);
    if (FAILED(hr)) {
        AVErrorResourceFormat(IDS_PATH_TOO_LONG, wszAppFullPath);
        goto out;
    }

    DialogBox(g_hInstance, (LPCTSTR)IDD_VIEWLOG_PAGE, hDlg, DlgViewLog);

out:
    g_szSingleLogFile[0] = 0;
}

void
SelectApp(
    HWND hDlg,
    int  nWhich
    )
{
    HWND hList = GetDlgItem(hDlg, IDC_LIST_APPS);

    int nItems = ListView_GetItemCount(hList);

    if (nItems == 0) {
        return;
    }

    if (nWhich > nItems - 1) {
        nWhich = nItems - 1;
    }

    ListView_SetItemState(hList, nWhich, LVIS_SELECTED, LVIS_SELECTED);
}

void
RunSelectedApp(
    HWND hDlg
    )
{
    WCHAR wszCommandLine[MAX_PATH];
    HRESULT hr;

    SaveSettings(hDlg);

    HWND hAppList = GetDlgItem(hDlg, IDC_LIST_APPS);

    int nApp = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nApp == -1) {
        return;
    }

    LVITEM lvi;

    lvi.mask      = LVIF_PARAM;
    lvi.iItem     = nApp;
    lvi.iSubItem  = 0;

    ListView_GetItem(hAppList, &lvi);

    CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

    if (pApp->wstrExePath.size()) {

        //
        // first set the current directory properly, if possible
        //
        LPWSTR pwsz;

        hr = StringCchCopyW(wszCommandLine, ARRAY_LENGTH(wszCommandLine), pApp->wstrExePath.c_str());
        if (FAILED(hr)) {
            AVErrorResourceFormat(IDS_PATH_TOO_LONG, pApp->wstrExePath.c_str());
            goto out;
        }

        pwsz = wcsrchr(wszCommandLine, L'\\');

        if (pwsz) {
            *pwsz = 0;
            SetCurrentDirectory(wszCommandLine);
            *pwsz = L'\\';
        }

        //
        // then prepare the command line
        //

        hr = StringCchPrintfW(wszCommandLine, ARRAY_LENGTH(wszCommandLine), L"\"%s\"", pApp->wstrExePath.c_str());
        if (FAILED(hr)) {
            AVErrorResourceFormat(IDS_PATH_TOO_LONG, pApp->wstrExePath.c_str());
            goto out;
        }

    } else {
        hr = StringCchPrintfW(wszCommandLine, ARRAY_LENGTH(wszCommandLine), L"\"%s\"", pApp->wstrExeName.c_str());
        if (FAILED(hr)) {
            AVErrorResourceFormat(IDS_PATH_TOO_LONG, pApp->wstrExeName.c_str());
            goto out;
        }

    }

    PROCESS_INFORMATION ProcessInfo;
    BOOL        bRet;
    STARTUPINFO StartupInfo;

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

    bRet = CreateProcess(NULL,
                         wszCommandLine,
                         NULL,
                         NULL,
                         FALSE,
                         0,
                         NULL,
                         NULL,
                         &StartupInfo,
                         &ProcessInfo);

    if (!bRet) {
        WCHAR           wszFilter[] = L"Executable files (*.exe)\0*.exe\0";
        OPENFILENAME    ofn;
        WCHAR           wszAppFullPath[MAX_PATH];
        WCHAR           wszAppShortName[MAX_PATH];

        wstring         strCaption;

        if (!AVLoadString(IDS_LOCATE_APP, strCaption)) {
            strCaption = _T("Please locate application");
        }

        if (pApp->wstrExePath.size()) {
            hr = StringCchCopyW(wszAppFullPath, ARRAY_LENGTH(wszAppFullPath), pApp->wstrExePath.c_str());
            if (FAILED(hr)) {
                AVErrorResourceFormat(IDS_PATH_TOO_LONG, pApp->wstrExePath.c_str());
                goto out;
            }
        } else {
            hr = StringCchCopyW(wszAppFullPath, ARRAY_LENGTH(wszAppFullPath), pApp->wstrExeName.c_str());
            if (FAILED(hr)) {
                AVErrorResourceFormat(IDS_PATH_TOO_LONG, pApp->wstrExeName.c_str());
                goto out;
            }
        }

        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = hDlg;
        ofn.hInstance         = NULL;
        ofn.lpstrFilter       = wszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter    = 0;
        ofn.nFilterIndex      = 0;
        ofn.lpstrFile         = wszAppFullPath;
        ofn.nMaxFile          = MAX_PATH;
        ofn.lpstrFileTitle    = wszAppShortName;
        ofn.nMaxFileTitle     = MAX_PATH;
        ofn.lpstrInitialDir   = NULL;
        ofn.lpstrTitle        = strCaption.c_str();
        ofn.Flags             = OFN_PATHMUSTEXIST       |
                                OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
                                OFN_NONETWORKBUTTON     |           // no network button
                                OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
                                OFN_SHAREAWARE;                     // don't check the existance of file with OpenFile
        ofn.lpstrDefExt       = NULL;

        if (!GetOpenFileName(&ofn)) {
            return;
        }

        pApp->wstrExePath = wszAppFullPath;
        pApp->wstrExeName = wszAppShortName;
        hr = StringCchPrintfW(wszCommandLine, ARRAY_LENGTH(wszCommandLine), L"\"%s\"", pApp->wstrExePath.c_str());
        if (FAILED(hr)) {
            AVErrorResourceFormat(IDS_PATH_TOO_LONG, pApp->wstrExePath.c_str());
            goto out;
        }

        RefreshAppList(hDlg);

        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

        bRet = CreateProcess(NULL,
                             wszCommandLine,
                             NULL,
                             NULL,
                             FALSE,
                             0,
                             NULL,
                             NULL,
                             &StartupInfo,
                             &ProcessInfo);
        if (!bRet) {
            AVErrorResourceFormat(IDS_CANT_LAUNCH_EXE);
        }

    }
out:
    return;
}

void
AddAppToList(
    HWND hDlg
    )
{

    WCHAR           wszFilter[] = L"Executable files (*.exe)\0*.exe\0";
    OPENFILENAME    ofn;
    WCHAR           wszAppFullPath[MAX_PATH];
    WCHAR           wszAppShortName[MAX_PATH];

    wstring         wstrTitle;

    if (!AVLoadString(IDS_ADD_APPLICATION_TITLE, wstrTitle)) {
        wstrTitle = _T("Add Application");
    }

    wszAppFullPath[0] = 0;

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = wszFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = wszAppFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = wszAppShortName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = wstrTitle.c_str();
    ofn.Flags             = OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
                            OFN_NONETWORKBUTTON     |           // no network button
                            OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
                            OFN_SHAREAWARE;                     // don't check the existance of file with OpenFile
    ofn.lpstrDefExt       = _T("EXE");

    if (!GetOpenFileName(&ofn)) {
        return;
    }

    //
    // check to see if the app is already in the list
    //
    CAVAppInfo *pApp;
    BOOL bFound = FALSE;

    for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
        if (_wcsicmp(pApp->wstrExeName.c_str(), wszAppShortName) == 0) {
            //
            // the app is already in the list, so just update the full
            // path, if it's good
            //
            if (GetFileAttributes(wszAppFullPath) != -1) {
                pApp->wstrExePath = wszAppFullPath;
            }
            bFound = TRUE;
        }
    }

    //
    // if the app wasn't already in the list, add it to the list
    //
    if (!bFound) {
        CAVAppInfo AppInfo;

        AppInfo.wstrExeName = wszAppShortName;

        //
        // check to see if the file actually exists
        //
        if (GetFileAttributes(wszAppFullPath) != -1) {
            AppInfo.wstrExePath = wszAppFullPath;
        }

        //
        // init the default tests
        //
        CAVAppInfo *pDefaultApp = &g_aAppInfo[0];
        CTestInfo *pTest;
        for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
            if (pDefaultApp->IsTestActive(*pTest)) {
                AppInfo.AddTest(*pTest);
            }
        }

        g_aAppInfo.push_back(AppInfo);

        RefreshAppList(hDlg);

        SelectApp(hDlg, 9999);

        DirtySettings(hDlg, TRUE);
    }
}

void
RemoveSelectedApp(
    HWND hDlg
    )
{
    HWND hAppList = GetDlgItem(hDlg, IDC_LIST_APPS);

    int nApp = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nApp == -1) {
        return;
    }

    LVITEM lvi;

    lvi.mask      = LVIF_PARAM;
    lvi.iItem     = nApp;
    lvi.iSubItem  = 0;

    ListView_GetItem(hAppList, &lvi);

    CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

    //
    // if there is a debugger set for this app, for various reasons we want to
    // kill the debugger before removing the app, or the debugger may linger forever
    //
    if (pApp->bBreakOnLog || pApp->bUseAVDebugger) {
        pApp->bBreakOnLog = FALSE;
        pApp->bUseAVDebugger = FALSE;

        SetCurrentAppSettings();
    }

    g_aAppInfo.erase(pApp);

    RefreshAppList(hDlg);

    SelectApp(hDlg, nApp);

    DirtySettings(hDlg, TRUE);
}

typedef struct _CONFLICT_DLG_INFO {
    CTestInfo *pTest1;
    CTestInfo *pTest2;
} CONFLICT_DLG_INFO, *PCONFLICT_DLG_INFO;

void
CheckForRunAlone(
    CAVAppInfo *pApp
    )
{
    if (!pApp) {
        return;
    }

    DWORD dwTests = 0;

    //
    // count the number of tests active
    //
    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pApp->IsTestActive(*pTest)) {
            dwTests++;
        }
    }

    //
    // look for conflicts
    //
    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        //
        // if there are less than two, no chance for conflict
        //
        if (dwTests < 2) {
            return;
        }

        if (pTest->bRunAlone && pApp->IsTestActive(*pTest)) {
            CONFLICT_DLG_INFO DlgInfo;

            ZeroMemory(&DlgInfo, sizeof(DlgInfo));

            DlgInfo.pTest1 = pTest; // pTest2 is unused in this case

            INT_PTR nResult = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_MUST_RUN_ALONE), g_hDlgMain, DlgRunAlone, (LPARAM)&DlgInfo);

            switch (nResult) {
            case IDC_BTN_DISABLE1:
                pApp->RemoveTest(*pTest);
                DirtySettings(g_hDlgMain, TRUE);
                RefreshSettingsList(g_hDlgMain, TRUE);
                dwTests--;
                break;

            case IDC_BTN_DISABLE2:
                //
                // disable all the tests except the one passed in
                //
                for (CTestInfo *pTestTemp = g_aTestInfo.begin(); pTestTemp != g_aTestInfo.end(); pTestTemp++) {
                    if (pTest != pTestTemp) {
                        pApp->RemoveTest(*pTestTemp);
                    }
                }
                DirtySettings(g_hDlgMain, TRUE);
                RefreshSettingsList(g_hDlgMain, TRUE);
                dwTests = 1;
                break;

            }
        }
    }
}

void
CheckForConflictingTests(
    CAVAppInfo *pApp,
    LPCWSTR wszTest1,
    LPCWSTR wszTest2
    )
{
    CONFLICT_DLG_INFO DlgInfo;

    ZeroMemory(&DlgInfo, sizeof(DlgInfo));

    //
    // get the test pointers from the names
    //
    for (CTestInfo *pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->strTestName == wszTest1) {
            DlgInfo.pTest1 = pTest;
        }
        if (pTest->strTestName == wszTest2) {
            DlgInfo.pTest2 = pTest;
        }
    }

    //
    // if we didn't find one or the other tests, get out
    //
    if (!DlgInfo.pTest1 || !DlgInfo.pTest2) {
        return;
    }

    if (pApp->IsTestActive(*DlgInfo.pTest1) && pApp->IsTestActive(*DlgInfo.pTest2)) {
        INT_PTR nResult = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_CONFLICT), g_hDlgMain, DlgConflict, (LPARAM)&DlgInfo);

        switch (nResult) {
        case IDC_BTN_DISABLE1:
            pApp->RemoveTest(*DlgInfo.pTest1);
            DirtySettings(g_hDlgMain, TRUE);
            RefreshSettingsList(g_hDlgMain, TRUE);
            break;

        case IDC_BTN_DISABLE2:
            pApp->RemoveTest(*DlgInfo.pTest2);
            DirtySettings(g_hDlgMain, TRUE);
            RefreshSettingsList(g_hDlgMain, TRUE);
            break;

        }
    }
}

void
ScanSettingsList(
    HWND hDlg,
    int  nItem
    )
{

    HWND hSettingList = GetDlgItem(hDlg, IDC_LIST_SETTINGS);
    HWND hAppList = GetDlgItem(hDlg, IDC_LIST_APPS);
    int nBegin, nEnd;

    int nApp = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nApp == -1) {
        return;
    }

    LVITEM lvi;

    lvi.mask      = LVIF_PARAM;
    lvi.iItem     = nApp;
    lvi.iSubItem  = 0;

    ListView_GetItem(hAppList, &lvi);

    CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

    if (!pApp) {
        return;
    }

    int nItems = ListView_GetItemCount(hSettingList);

    if (!nItems) {
        //
        // nothing in list
        //
        return;
    }

    if (nItem == -1 || nItem >= nItems) {
        nBegin = 0;
        nEnd = nItems;
    } else {
        nBegin = nItem;
        nEnd = nItem + 1;
    }

    for (int i = nBegin; i < nEnd; ++i) {
        BOOL bTestEnabled = FALSE;
        BOOL bChecked = FALSE;

        lvi.iItem = i;

        ListView_GetItem(hSettingList, &lvi);

        CTestInfo *pTest = (CTestInfo*)lvi.lParam;

        bChecked = ListView_GetCheckState(hSettingList, i);

        bTestEnabled = pApp->IsTestActive(*pTest);

        if (bTestEnabled != bChecked) {
            DirtySettings(hDlg, TRUE);

            if (bChecked) {
                pApp->AddTest(*pTest);
            } else {
                pApp->RemoveTest(*pTest);
            }
        }

        CheckForRunAlone(pApp);
    }

    CheckForConflictingTests(pApp, L"LogFileChanges", L"WindowsFileProtection");
}

void
DisplaySettingsDescription(
    HWND hDlg
    )
{
    HWND hList = GetDlgItem(hDlg, IDC_LIST_SETTINGS);

    int nItem = ListView_GetNextItem(hList, -1, LVNI_SELECTED);

    if (nItem == -1) {
        WCHAR szTestDesc[256];

        LoadString(g_hInstance, IDS_VIEW_TEST_DESC, szTestDesc, ARRAY_LENGTH(szTestDesc));
        SetWindowText(GetDlgItem(hDlg, IDC_STATIC_DESC), szTestDesc);
    } else {
        LVITEM lvi;

        lvi.mask      = LVIF_PARAM;
        lvi.iItem     = nItem;
        lvi.iSubItem  = 0;

        ListView_GetItem(hList, &lvi);

        CTestInfo *pTest = (CTestInfo*)lvi.lParam;

        SetWindowText(GetDlgItem(hDlg, IDC_STATIC_DESC), pTest->strTestDescription.c_str());
    }

}

CAVAppInfo *
GetCurrentAppSelection(
    void
    )
{
    if (!g_hDlgMain) {
        return NULL;
    }

    HWND hAppList = GetDlgItem(g_hDlgMain, IDC_LIST_APPS);

    int nItem = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nItem == -1) {
        return NULL;
    }

    LVITEM lvi;

    lvi.mask      = LVIF_PARAM;
    lvi.iItem     = nItem;
    lvi.iSubItem  = 0;

    ListView_GetItem(hAppList, &lvi);

    CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

    return pApp;

}

void
RefreshSettingsList(
    HWND hDlg,
    BOOL bForceRefresh
    )
{
    g_bRefreshingSettings = TRUE;

    HWND hSettingList = GetDlgItem(hDlg, IDC_LIST_SETTINGS);
    HWND hAppList = GetDlgItem(hDlg, IDC_LIST_APPS);

    static nLastItem = -1;

    int nItem = ListView_GetNextItem(hAppList, -1, LVNI_SELECTED);

    if (nItem == -1) {

        EnableWindow(GetDlgItem(hDlg, IDC_BTN_RUN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_REMOVE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_OPTIONS), FALSE);

    } else if (nItem == 0) {
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_RUN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_REMOVE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_OPTIONS), TRUE);

    } else {
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_RUN), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_REMOVE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_OPTIONS), TRUE);
    }

    if (nItem == nLastItem && !bForceRefresh) {
        goto out;

    }

    ListView_DeleteAllItems(hSettingList);

    DisplaySettingsDescription(hDlg);

    nLastItem = nItem;

    if (nItem != -1) {
        LVITEM lvi;

        lvi.mask      = LVIF_PARAM;
        lvi.iItem     = nItem;
        lvi.iSubItem  = 0;

        ListView_GetItem(hAppList, &lvi);

        CAVAppInfo *pApp = (CAVAppInfo*)lvi.lParam;

        if (!pApp) {
            return;
        }

        CTestInfo* pTest;

        for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
            //
            // continue if this test isn't win2K compatible, and we're running on win2k
            //
            if (g_bWin2KMode && !pTest->bWin2KCompatible) {
                continue;
            }

            //
            // continue if this test is invalid for the current internal/external mode
            //
            if ((g_bInternalMode && !pTest->bInternal) || (!g_bInternalMode && !pTest->bExternal)) {
                continue;
            }

            WCHAR szText[256];

            //
            // don't check the return, because if it's truncated, that's acceptable
            //
            StringCchPrintfW(szText, ARRAY_LENGTH(szText), L"%s - %s", pTest->strTestName.c_str(), pTest->strTestFriendlyName.c_str());

            lvi.mask      = LVIF_TEXT | LVIF_PARAM;
            lvi.pszText   = (LPWSTR)szText;
            lvi.lParam    = (LPARAM)pTest;
            lvi.iItem     = 9999;
            lvi.iSubItem  = 0;

            nItem = ListView_InsertItem(hSettingList, &lvi);

            BOOL bCheck = pApp->IsTestActive(*pTest);

            ListView_SetCheckState(hSettingList, nItem, bCheck);
        }
    }
out:

    g_bRefreshingSettings = FALSE;

    return;
}

static const DWORD MAX_DEBUGGER_LEN = 1024;

void
ReadOptions(
    void
    )
{
    for (CAVAppInfo *pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); ++pApp) {
        LPCWSTR szExe = pApp->wstrExeName.c_str();


        WCHAR szDebugger[MAX_DEBUGGER_LEN];

        pApp->bBreakOnLog = GetShimSettingDWORD(L"General", szExe, AV_OPTION_BREAK_ON_LOG, FALSE);
        pApp->bFullPageHeap = GetShimSettingDWORD(L"General", szExe, AV_OPTION_FULL_PAGEHEAP, FALSE);
        pApp->bUseAVDebugger = GetShimSettingDWORD(L"General", szExe, AV_OPTION_AV_DEBUGGER, FALSE);
        pApp->bPropagateTests = GetShimSettingDWORD(L"General", szExe, AV_OPTION_PROPAGATE, FALSE);

        szDebugger[0] = 0;
        GetShimSettingString(L"General", szExe, AV_OPTION_DEBUGGER, szDebugger, MAX_DEBUGGER_LEN);
        pApp->wstrDebugger = szDebugger;
    }
}

void
SaveOptions(
    void
    )
{

    for (CAVAppInfo *pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); ++pApp) {
        LPCWSTR szExe = pApp->wstrExeName.c_str();

        SaveShimSettingDWORD(L"General", szExe, AV_OPTION_BREAK_ON_LOG, (DWORD)pApp->bBreakOnLog);
        SaveShimSettingDWORD(L"General", szExe, AV_OPTION_FULL_PAGEHEAP, (DWORD)pApp->bFullPageHeap);
        SaveShimSettingDWORD(L"General", szExe, AV_OPTION_AV_DEBUGGER, (DWORD)pApp->bUseAVDebugger);
        SaveShimSettingDWORD(L"General", szExe, AV_OPTION_PROPAGATE, (DWORD)pApp->bPropagateTests);
        SaveShimSettingString(L"General", szExe, AV_OPTION_DEBUGGER, pApp->wstrDebugger.c_str());
    }

    SetCurrentAppSettings();
}


INT_PTR CALLBACK
DlgRunAlone(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        {
            WCHAR wszTemp[256];
            WCHAR wszExpandedTemp[512];
            PCONFLICT_DLG_INFO pDlgInfo;

            pDlgInfo = (PCONFLICT_DLG_INFO)lParam;

            wszTemp[0] = 0;
            AVLoadString(IDS_RUN_ALONE_MESSAGE, wszTemp, ARRAY_LENGTH(wszTemp));

            StringCchPrintfW(
                wszExpandedTemp,
                ARRAY_LENGTH(wszExpandedTemp),
                wszTemp,
                pDlgInfo->pTest1->strTestFriendlyName.c_str()
                );

            SetDlgItemTextW(hDlg, IDC_CONFLICT_STATIC, wszExpandedTemp);

            return TRUE;
        }


    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_BTN_DISABLE1:
        case IDC_BTN_DISABLE2:
        case IDCANCEL:
            //
            // return the button that was pressed
            //
            EndDialog(hDlg, (INT_PTR)LOWORD(wParam));
            break;
        }
        break;

    }

    return FALSE;
}


INT_PTR CALLBACK
DlgConflict(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        {
            WCHAR wszTemp[256];
            WCHAR wszExpandedTemp[512];
            PCONFLICT_DLG_INFO pDlgInfo;

            pDlgInfo = (PCONFLICT_DLG_INFO)lParam;

            wszTemp[0] = 0;
            AVLoadString(IDS_CONFLICT_MESSAGE, wszTemp, ARRAY_LENGTH(wszTemp));

            StringCchPrintf(
                wszExpandedTemp,
                ARRAY_LENGTH(wszExpandedTemp),
                wszTemp,
                pDlgInfo->pTest1->strTestFriendlyName.c_str(),
                pDlgInfo->pTest2->strTestFriendlyName.c_str()
                );

            SetDlgItemTextW(hDlg, IDC_CONFLICT_STATIC, wszExpandedTemp);

            return TRUE;
        }


    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_BTN_DISABLE1:
        case IDC_BTN_DISABLE2:
        case IDCANCEL:
            //
            // return the button that was pressed
            //
            EndDialog(hDlg, (INT_PTR)LOWORD(wParam));
            break;
        }
        break;

    }

    return FALSE;
}

INT_PTR CALLBACK
DlgViewOptions(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static CAVAppInfo *pApp;

    switch (message) {
    case WM_INITDIALOG:

        g_hDlgOptions = hDlg;
        pApp = GetCurrentAppSelection();

        if (!pApp) {
            return FALSE;
        }

        ReadOptions();

        //
        // initialize the combo box options
        //
        SendDlgItemMessage(hDlg,
                           IDC_COMBO_DEBUGGER,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)L"ntsd");
        SendDlgItemMessage(hDlg,
                           IDC_COMBO_DEBUGGER,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)L"windbg");

        if (pApp->bBreakOnLog) {
            pApp->bUseAVDebugger = FALSE;
            EnableWindow(GetDlgItem(hDlg, IDC_USE_AV_DEBUGGER), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_DEBUGGER), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEBUGGER), TRUE);

            if (!pApp->wstrDebugger.size()) {
                SetDlgItemText(hDlg, IDC_COMBO_DEBUGGER, L"ntsd");
            } else {
                SetDlgItemText(hDlg, IDC_COMBO_DEBUGGER, pApp->wstrDebugger.c_str());
            }
        } else {
            EnableWindow(GetDlgItem(hDlg, IDC_USE_AV_DEBUGGER), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_DEBUGGER), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEBUGGER), FALSE);
        }

        /*SendDlgItemMessage(hDlg,
                           IDC_CLEAR_LOG_ON_CHANGES,
                           BM_SETCHECK,
                           (pApp->bClearSessionLogBeforeRun ? BST_CHECKED : BST_UNCHECKED),
                           0);*/

        SendDlgItemMessage(hDlg,
                           IDC_BREAK_ON_LOG,
                           BM_SETCHECK,
                           (pApp->bBreakOnLog ? BST_CHECKED : BST_UNCHECKED),
                           0);

        SendDlgItemMessage(hDlg,
                           IDC_FULL_PAGEHEAP,
                           BM_SETCHECK,
                           (pApp->bFullPageHeap ? BST_CHECKED : BST_UNCHECKED),
                           0);

        SendDlgItemMessage(hDlg,
                           IDC_USE_AV_DEBUGGER,
                           BM_SETCHECK,
                           (pApp->bUseAVDebugger ? BST_CHECKED : BST_UNCHECKED),
                           0);

        SendDlgItemMessage(hDlg,
                           IDC_PROPAGATE_TESTS,
                           BM_SETCHECK,
                           (pApp->bPropagateTests ? BST_CHECKED : BST_UNCHECKED),
                           0);

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_BREAK_ON_LOG:
            {
                BOOL bChecked = IsDlgButtonChecked(hDlg, IDC_BREAK_ON_LOG);
                if (bChecked) {
                    WCHAR szTemp[256];

                    CheckDlgButton(hDlg, IDC_USE_AV_DEBUGGER, BST_UNCHECKED);
                    EnableWindow(GetDlgItem(hDlg, IDC_USE_AV_DEBUGGER), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_DEBUGGER), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEBUGGER), TRUE);

                    GetDlgItemText(hDlg, IDC_COMBO_DEBUGGER, szTemp, ARRAY_LENGTH(szTemp));

                    if (!szTemp[0]) {
                        if (!pApp->wstrDebugger.size()) {
                            SetDlgItemText(hDlg, IDC_COMBO_DEBUGGER, L"ntsd");
                        } else {
                            SetDlgItemText(hDlg, IDC_COMBO_DEBUGGER, pApp->wstrDebugger.c_str());
                        }
                    }
               } else {
                    EnableWindow(GetDlgItem(hDlg, IDC_USE_AV_DEBUGGER), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_DEBUGGER), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DEBUGGER), FALSE);
                }
            }
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {

        case PSN_APPLY:
            /* pApp->bClearSessionLogBeforeRun = (SendDlgItemMessage(hDlg,
                                                              IDC_CLEAR_LOG_ON_CHANGES,
                                                              BM_GETCHECK,
                                                              0,
                                                              0) == BST_CHECKED);*/

            pApp->bBreakOnLog = (SendDlgItemMessage(hDlg,
                                                IDC_BREAK_ON_LOG,
                                                BM_GETCHECK,
                                                0,
                                                0) == BST_CHECKED);

            pApp->bFullPageHeap = (SendDlgItemMessage(hDlg,
                                                  IDC_FULL_PAGEHEAP,
                                                  BM_GETCHECK,
                                                  0,
                                                  0) == BST_CHECKED);

            pApp->bUseAVDebugger = (SendDlgItemMessage(hDlg,
                                                   IDC_USE_AV_DEBUGGER,
                                                   BM_GETCHECK,
                                                   0,
                                                   0) == BST_CHECKED);

            pApp->bPropagateTests = (SendDlgItemMessage(hDlg,
                                                    IDC_PROPAGATE_TESTS,
                                                    BM_GETCHECK,
                                                    0,
                                                    0) == BST_CHECKED);

            WCHAR szDebugger[MAX_DEBUGGER_LEN];

            szDebugger[0] = 0;
            GetDlgItemText(hDlg, IDC_COMBO_DEBUGGER, szDebugger, ARRAY_LENGTH(szDebugger));

            pApp->wstrDebugger = szDebugger;

            SaveOptions();

            g_hDlgOptions = NULL;

            break;
        }
    }

    return FALSE;
}

void
ViewOptions(
    HWND hDlg
    )
{
    HPROPSHEETPAGE *phPages = NULL;
	PROPSHEETPAGE PageGlobal;
    PROPSHEETHEADER psh;

    CTestInfo* pTest;
    DWORD dwPages = 1;
    DWORD dwPage = 0;

    CAVAppInfo *pApp = GetCurrentAppSelection();

    if (!pApp) {
        return;
    }

    LPCWSTR szExe = pApp->wstrExeName.c_str();

    //
    // count the number of pages
    //
    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->PropSheetPage.pfnDlgProc) {
            dwPages++;
        }
    }

    phPages = new HPROPSHEETPAGE[dwPages];
    if (!phPages) {
        return;
    }


    //
    // init the global page
    //
    PageGlobal.dwSize = sizeof(PROPSHEETPAGE);
    PageGlobal.dwFlags = PSP_USETITLE;
    PageGlobal.hInstance = g_hInstance;
    PageGlobal.pszTemplate = MAKEINTRESOURCE(IDD_OPTIONS);
    PageGlobal.pfnDlgProc = DlgViewOptions;
    PageGlobal.pszTitle = MAKEINTRESOURCE(IDS_GLOBAL_OPTIONS);
    PageGlobal.lParam = 0;
    PageGlobal.pfnCallback = NULL;
    phPages[0] = CreatePropertySheetPage(&PageGlobal);

    if (!phPages[0]) {
        //
        // we need the global page minimum
        //
        return;
    }

    //
    // add the pages for the various tests
    //
    dwPage = 1;
    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->PropSheetPage.pfnDlgProc) {

            //
            // we use the lParam to identify the exe involved
            //
            pTest->PropSheetPage.lParam = (LPARAM)szExe;

            phPages[dwPage] = CreatePropertySheetPage(&(pTest->PropSheetPage));
            if (!phPages[dwPage]) {
                dwPages--;
            } else {
                dwPage++;
            }
        }
    }

    wstring wstrOptions;
    AVLoadString(IDS_OPTIONS_TITLE, wstrOptions);

    wstrOptions += L" - ";
    wstrOptions += szExe;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP;
    psh.hwndParent = hDlg;
    psh.hInstance = g_hInstance;
    psh.pszCaption = wstrOptions.c_str();
    psh.nPages = dwPages;
    psh.nStartPage = 0;
    psh.phpage = phPages;
    psh.pfnCallback = NULL;

    PropertySheet(&psh);
}

// Message handler for main dialog.
INT_PTR CALLBACK
DlgMain(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        {
            wstring strTemp;

            g_hDlgMain = hDlg;

            //
            // set the caption to the appropriate version, etc.
            //
            if (GetAppTitleString(strTemp)) {
                SetWindowText(hDlg, strTemp.c_str());
            }
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_RUN), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_REMOVE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_SAVE_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_OPTIONS), FALSE);

            HWND hList = GetDlgItem(hDlg, IDC_LIST_SETTINGS);

            if (hList) {
                LVCOLUMN  lvc;

                lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
                lvc.fmt      = LVCFMT_LEFT;
                lvc.cx       = 700;
                lvc.iSubItem = 0;
                lvc.pszText  = L"xxx";

                ListView_InsertColumn(hList, 0, &lvc);
                ListView_SetExtendedListViewStyleEx(hList, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);

            }

            hList = GetDlgItem(hDlg, IDC_LIST_APPS);
            if (hList) {
                LVITEM lvi;
                LVCOLUMN  lvc;

                lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
                lvc.fmt      = LVCFMT_LEFT;
                lvc.cx       = 250;
                lvc.iSubItem = 0;
                lvc.pszText  = L"xxx";

                ListView_InsertColumn(hList, 0, &lvc);

                RefreshAppList(hDlg);

                SelectApp(hDlg, 0);
            }

            WCHAR szTestDesc[256];

            LoadString(g_hInstance, IDS_VIEW_TEST_DESC, szTestDesc, ARRAY_LENGTH(szTestDesc));
            SetWindowText(GetDlgItem(hDlg, IDC_STATIC_DESC), szTestDesc);

            //
            // Show the app icon.
            //
            HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)hIcon);

            return TRUE;
        }
        break;

    case WM_ACTIVATE:
        if (LOWORD(wParam) == WA_INACTIVE) {
            SaveSettingsIfDirty(hDlg);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_BTN_ADD:
            AddAppToList(hDlg);
            break;

        case IDC_BTN_REMOVE:
            RemoveSelectedApp(hDlg);
            break;

        case IDC_BTN_VIEW_LOG:
            DisplayLog(hDlg);
            break;

        case IDC_BTN_VIEW_EXTERNAL_LOG:
            DisplaySingleLog(hDlg);
            break;

        case IDC_BTN_OPTIONS:
            ViewOptions(hDlg);
            break;

        case IDC_BTN_RUN:
            RunSelectedApp(hDlg);
            break;

        case IDC_BTN_HELP:
            ShowHTMLHelp();
            break;

        case IDOK:
        case IDCANCEL:
            SaveSettings(hDlg);
            EndDialog(hDlg, LOWORD(wParam));
            g_hDlgMain = NULL;
            PostQuitMessage(0);
            return TRUE;
            break;
        }
        break;

    case WM_NOTIFY:
        LPNMHDR pnmh = (LPNMHDR)lParam;

        HWND hItem = pnmh->hwndFrom;

        if (hItem == GetDlgItem(hDlg, IDC_LIST_APPS)) {
            switch (pnmh->code) {
            case LVN_KEYDOWN:
                {
                    LPNMLVKEYDOWN pnmkd = (LPNMLVKEYDOWN)lParam;

                    if (pnmkd->wVKey == VK_DELETE) {
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_BTN_RUN))) {
                            RemoveSelectedApp(hDlg);
                        }
                    }
                }
                break;

            case LVN_ITEMCHANGED:
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;

                if (!g_bRefreshingSettings && (pnmv->uChanged & LVIF_STATE) && ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED)) {
                    RefreshSettingsList(hDlg);
                }

            }
        } else if (hItem == GetDlgItem(hDlg, IDC_LIST_SETTINGS)) {
            switch (pnmh->code) {
            case LVN_ITEMCHANGED:
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;

                if (!g_bRefreshingSettings) {
                    //
                    // check for change in selection
                    //
                    if ((pnmv->uChanged & LVIF_STATE) && ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED)) {
                        DisplaySettingsDescription(hDlg);
                    }

                    //
                    // check for change in checkbox
                    //
                    if ((pnmv->uChanged & LVIF_STATE) && ((pnmv->uNewState ^ pnmv->uOldState) >> 12) != 0) {
                        ScanSettingsList(hDlg, pnmv->iItem);
                    }
                }
                break;
            }
        }
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\avutil.h ===
#ifndef __APP_VERIFIER_UTIL_H__
#define __APP_VERIFIER_UTIL_H__


///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box.
// The message format string is loaded from the resources.
//

void __cdecl
AVErrorResourceFormat(
    UINT uIdResourceFormat,
    ...
    );


///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL
AVLoadString(
    ULONG  uIdResource,
    WCHAR* szBuffer,
    ULONG  uBufferLength
    );

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL
AVLoadString(
    ULONG    uIdResource,
    wstring& strText
    );


/////////////////////////////////////////////////////////////////////////////
BOOL
AVRtlCharToInteger(
    IN  LPCTSTR String,
    IN  ULONG   Base OPTIONAL,
    OUT PULONG  Value
    );

/////////////////////////////////////////////////////////////////////////////
BOOL
AVWriteStringHexValueToRegistry(
    HKEY    hKey,
    LPCTSTR szValueName,
    DWORD   dwValue
    );


#endif //#ifndef __APP_VERIFIER_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\dbsupport.h ===
#ifndef __APPVERIFIER_DBSUPPORT_H_
#define __APPVERIFIER_DBSUPPORT_H_

typedef enum {
    TEST_SHIM,
    TEST_KERNEL
} TestType;

class CIncludeInfo {
public:
    wstring     strModule;
    BOOL        bInclude;
    
    CIncludeInfo(void) :
        bInclude(TRUE) {}
};

typedef vector<CIncludeInfo> CIncludeArray;

typedef vector<wstring> CWStringArray;
          
class CTestInfo {
public:
    //
    // valid for all tests
    //
    TestType            eTestType;   
    wstring             strTestName;
    wstring             strTestDescription;
    wstring             strTestFriendlyName;
    BOOL                bDefault;           // is this test turned on by default?
    BOOL                bWin2KCompatible;   // can this test be run on Win2K?
    BOOL                bRunAlone;          // should this test be run alone?
    BOOL                bSetupOK;           // can this test be run on a setup app?
    BOOL                bNonSetupOK;        // can this test be run on a non-setup app?
    BOOL                bPseudoShim;        // this test is not a shim, and shouldn't be applied to apps
    BOOL                bNonTest;           // this is not a test at all, and is only in the list to provide an options page
    BOOL                bInternal;          // this test is appropriate for internal MS NTDEV use
    BOOL                bExternal;          // this test is appropriate for external (non MS or non NTDEV) use

    //
    // if type is TEST_SHIM, the following are valid
    //
    wstring             strDllName;
    CIncludeArray       aIncludes;
    WORD                wVersionHigh;
    WORD                wVersionLow;
    PROPSHEETPAGE       PropSheetPage;

    //
    // if type is TEST_KERNEL, the following are valid
    //
    DWORD               dwKernelFlag;

    CTestInfo(void) : 
        eTestType(TEST_SHIM), 
        dwKernelFlag(0),
        bDefault(TRUE),
        wVersionHigh(0),
        wVersionLow(0),
        bWin2KCompatible(TRUE),
        bRunAlone(FALSE),
        bSetupOK(TRUE),
        bNonSetupOK(TRUE),
        bPseudoShim(FALSE),
        bNonTest(FALSE),
        bInternal(TRUE),
        bExternal(TRUE) {

        ZeroMemory(&PropSheetPage, sizeof(PROPSHEETPAGE));
        PropSheetPage.dwSize = sizeof(PROPSHEETPAGE);
    }

};

typedef vector<CTestInfo> CTestInfoArray;

class CAVAppInfo {
public:
    wstring         wstrExeName;
    wstring         wstrExePath; // optional
    DWORD           dwRegFlags;
    CWStringArray   awstrShims;
    //BOOL            bClearSessionLogBeforeRun;
    BOOL            bBreakOnLog;
    BOOL            bFullPageHeap;
    BOOL            bUseAVDebugger;
    BOOL            bPropagateTests;
    wstring         wstrDebugger;

    CAVAppInfo() : 
        dwRegFlags(0),
        bBreakOnLog(FALSE),
        bFullPageHeap(FALSE),
        bUseAVDebugger(FALSE),
        bPropagateTests(FALSE) {}

    void
    AddTest(CTestInfo &Test) {
        if (Test.eTestType == TEST_KERNEL) {
            dwRegFlags |= Test.dwKernelFlag;
        } else {
            for (wstring *pStr = awstrShims.begin(); pStr != awstrShims.end(); ++pStr) {
                if (*pStr == Test.strTestName) {
                    return;
                }
            }
            // not found, so add
            awstrShims.push_back(Test.strTestName);
        }
    }

    void
    RemoveTest(CTestInfo &Test) {
        if (Test.eTestType == TEST_KERNEL) {
            dwRegFlags &= ~(Test.dwKernelFlag);
        } else {
            for (wstring *pStr = awstrShims.begin(); pStr != awstrShims.end(); ++pStr) {
                if (*pStr == Test.strTestName) {
                    awstrShims.erase(pStr);
                    return;
                }
            }
        }
    }

    BOOL
    IsTestActive(CTestInfo &Test) {
        if (Test.eTestType == TEST_KERNEL) {
            return (dwRegFlags & Test.dwKernelFlag) == Test.dwKernelFlag;
        } else {
            for (wstring *pStr = awstrShims.begin(); pStr != awstrShims.end(); ++pStr) {
                if (*pStr == Test.strTestName) {
                    return TRUE;
                }
            }
            return FALSE;
        }
    }

};

typedef vector<CAVAppInfo> CAVAppInfoArray;

typedef struct _KERNEL_TEST_INFO
{
    ULONG   m_uFriendlyNameStringId;
    ULONG   m_uDescriptionStringId;
    DWORD   m_dwBit;
    BOOL    m_bDefault;
    LPWSTR  m_szCommandLine;
    BOOL    m_bWin2KCompatible;
} KERNEL_TEST_INFO, *PKERNEL_TEST_INFO;


extern CAVAppInfoArray g_aAppInfo;

extern CTestInfoArray g_aTestInfo;

void 
ResetVerifierLog(void);

BOOL 
InitTestInfo(void);

void
GetCurrentAppSettings(void);

void
SetCurrentAppSettings(void);

BOOL 
AppCompatWriteShimSettings(
    CAVAppInfoArray&    arrAppInfo,
    BOOL                b32bitOnly
    );

BOOL
AppCompatDeleteSettings(
    void
    );



#endif // __APPVERIFIER_DBSUPPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\ids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppVerifier.rc
//
#define IDD_DLG_MAIN                    101
#define IDD_DIALOG1                     102
#define IDD_OPTIONS                     102
#define IDD_VIEW_LOG_DETAIL             106
#define IDD_CONFLICT                    107
#define IDR_ACCEL_MAIN                  108
#define IDC_LIST_APPS                   1000
#define IDC_LIST_SETTINGS               1001
#define IDC_BTN_SAVE_SETTINGS           1002
#define IDC_BTN_OPTIONS                 1003
#define IDC_BTN_VIEW_LOG                1004
#define IDC_BTN_ADD                     1005
#define IDC_BTN_REMOVE                  1006
#define IDC_BTN_RUN                     1007
#define IDC_STATIC_DESC                 1008
#define IDC_BTN_DELETE_ALL              1009
#define IDC_CLEAR_LOG_ON_CHANGES        1009
#define IDC_BTN_DELETE_LOG              1010
#define IDC_BREAK_ON_LOG                1010
#define IDC_LIGHT_PAGEHEAP              1011
#define IDC_FULL_PAGEHEAP               1011
#define IDC_BTN_VIEW_EXTERNAL_LOG       1012
#define IDC_PRE_GUARD                   1012
#define IDC_BTN_EXPORT_LOG              1013
#define IDC_USE_AV_DEBUGGER             1015
#define IDC_ISSUE_DESCRIPTION           1016
#define IDC_ISSUES                      1017
#define IDC_SOLUTIONS_STATIC            1018
#define IDC_COMBO_DEBUGGER              1020
#define IDC_STATIC_DEBUGGER             1021
#define IDC_PROPAGATE_TESTS             1022
#define IDC_LIST_DETAILS                1023
#define IDC_BTN_VIEW_DETAILS            1024
#define IDC_BTN_DISABLE2                1025
#define IDC_BTN_DISABLE1                1026
#define IDC_CONFLICT_STATIC             1027
#define IDC_SHOW_ALL                    1028
#define IDC_SHOW_ERRORS                 1029
#define IDC_BTN_HELP                    1030
#define IDS_APPTITLE                    1202
#define IDS_CANNOT_LOAD_APP_TITLE       1203
#define IDS_NOT_ENOUGH_MEMORY           1204
#define IDS_PATH_TOO_LONG               1205
#define IDS_ACCESS_IS_DENIED            1220
#define IDS_REGOPENKEYEX_FAILED         1221
#define IDS_REGENUMKEYEX_FAILED         1222
#define IDS_REGQUERYVALUEEX_FAILED      1224
#define IDS_INVALID_PARAMETER           1225
#define IDS_INVALID_TEST                1226
#define IDS_NO_APP                      1227
#define IDR_MAINFRAME                   1228
#define IDS_VERIFY_LOCKS_CHECKS         1231
#define IDS_VERIFY_HANDLE_CHECKS        1232
#define IDS_PAGE_HEAP                   1233
#define IDS_VERIFY_STACK_CHECKS         1234
#define IDS_VERIFY_LOCKS_CHECKS_DESC    1235
#define IDS_VERIFY_RPC_CHECKS           1236
#define IDS_VERIFY_RPC_CHECKS_DESC      1237
#define IDS_VERIFY_HANDLE_CHECKS_DESC   1306
#define IDS_PAGE_HEAP_DESC              1307
#define IDS_VERIFY_STACK_CHECKS_DESC    1308
#define IDS_CANT_LAUNCH_EXE             1309
#define IDS_VIEW_TEST_DESC              1310
#define IDS_CANT_COPY                   1311
#define IDS_INVALID_VERSION             1312
#define IDS_LOG_TITLE_SINGLE            1500
#define IDS_LOG_TITLE_LOCAL             1501
#define IDS_APP_NAME                    1600
#define IDS_VERSION_STRING              1601
#define IDS_COPYRIGHT                   1602
#define IDS_VIEW_EXPORTED_LOG_TITLE     1603
#define IDS_ADD_APPLICATION_TITLE       1604
#define IDS_EXPORT_LOG_TITLE            1605
#define IDS_SOLUTION_DEFAULT            1606
#define IDS_VERSION_STRING_64           1607
#define IDS_GLOBAL_OPTIONS              1700
#define IDS_OPTIONS_TITLE               1701
#define IDD_VIEWLOG_PAGE                2007
#define IDD_MUST_RUN_ALONE              2008
#define IDI_ICON                        3001
#define IDB_BULLETS                     3002
#define IDS_HELP_INTRO_00               5000
#define IDS_HELP_INTRO_01               5001
#define IDS_HELP_INTRO_02               5002
#define IDS_HELP_INTRO_03               5003
#define IDS_HELP_INTRO_04               5004
#define IDS_HELP_INTRO_05               5005
#define IDS_HELP_INTRO_06               5006
#define IDS_HELP_INTRO_07               5007
#define IDS_HELP_INTRO_08               5008
#define IDS_HELP_INTRO_09               5009
#define IDS_HELP_INTRO_10               5010
#define IDS_HELP_INTRO_11               5011
#define IDS_HELP_INTRO_12               5012
#define IDS_HELP_INTRO_13               5013
#define IDS_HELP_INTRO_14               5014
#define IDS_HELP_INTRO_15               5015
#define IDS_HELP_INTRO_16               5016
#define IDS_HELP_INTRO_17               5017
#define IDS_HELP_INTRO_18               5018
#define IDS_HELP_INTRO_19               5019
#define IDS_HELP_EXAMPLE_00             5100
#define IDS_HELP_EXAMPLE_01             5101
#define IDS_HELP_EXAMPLE_02             5102
#define IDS_HELP_EXAMPLE_03             5103
#define IDS_HELP_EXAMPLE_04             5104
#define IDS_HELP_EXAMPLE_05             5105
#define IDS_HELP_EXAMPLE_06             5106
#define IDS_HELP_EXAMPLE_07             5107
#define IDS_HELP_EXAMPLE_08             5108
#define IDS_HELP_EXAMPLE_09             5109
#define IDS_HELP_EXAMPLE_10             5110
#define IDS_HELP_EXAMPLE_11             5111
#define IDS_HELP_EXAMPLE_12             5112
#define IDS_HELP_EXAMPLE_13             5113
#define IDS_HELP_EXAMPLE_14             5114
#define IDS_HELP_EXAMPLE_15             5115
#define IDS_HELP_EXAMPLE_16             5116
#define IDS_HELP_EXAMPLE_17             5117
#define IDS_HELP_EXAMPLE_18             5118
#define IDS_HELP_EXAMPLE_19             5119
#define IDS_HELP_SHIM_TESTS             5500
#define IDS_CURRENT_SETTINGS            5501
#define IDS_DONE                        5502
#define IDS_LOCATE_APP                  5503
#define IDS_CONFLICT_MESSAGE            5504
#define IDS_RUN_ALONE_MESSAGE           5505
#define IDS_URL_INTRO                   5600
#define IDS_URL_LINK                    5601

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\avutil.cpp ===
#include "precomp.h"

#include "AVUtil.h"

VOID
DebugPrintf(
    LPCSTR pszFmt, 
    ...
    )
{
    char szT[1024];

    va_list vaArgList;
    va_start(vaArgList, pszFmt);

    StringCchVPrintfA(szT, ARRAY_LENGTH(szT), pszFmt, vaArgList);

    // make sure we have a '\n' at the end of the string

    int len = strlen(szT);

    if (len && szT[len - 1] != '\n') {
        StringCchCatA(szT, ARRAY_LENGTH(szT), "\n");
    }


    OutputDebugStringA(szT);

    va_end(vaArgList);
}

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message format string is loaded from the resources.
//

void __cdecl
AVErrorResourceFormat(
    UINT uIdResourceFormat,
    ...
    )
{
    WCHAR   szMessage[2048];
    WCHAR   strFormat[2048];
    BOOL    bResult;
    va_list prms;

    //
    // Load the format string from the resources
    //

    bResult = AVLoadString(uIdResourceFormat,
                           strFormat,
                           ARRAY_LENGTH(strFormat));

    ASSERT(bResult);

    if (bResult) {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        StringCchVPrintfW(szMessage,
                          ARRAY_LENGTH(szMessage),
                          strFormat,
                          prms);

        if (g_bConsoleMode) {
            printf("Error: %ls\n", szMessage); 

        } else {
            //
            // GUI mode
            //
            MessageBox(NULL, szMessage, L"Application Verifier", 
                       MB_OK | MB_ICONSTOP );
        }

        va_end(prms);
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL
AVLoadString(
    ULONG  uIdResource,
    WCHAR* szBuffer,
    ULONG  uBufferLength
    )
{
    ULONG uLoadStringResult;

    if (uBufferLength < 1) {
        ASSERT(FALSE);
        return FALSE;
    }

    uLoadStringResult = LoadStringW(g_hInstance,
                                    uIdResource,
                                    szBuffer,
                                    uBufferLength);

    return (uLoadStringResult > 0);
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL
AVLoadString(
    ULONG    uIdResource,
    wstring& strText
    )
{
    WCHAR szText[4096];
    BOOL  bSuccess;

    bSuccess = AVLoadString(uIdResource,
                            szText,
                            ARRAY_LENGTH(szText));

    if (bSuccess) {
        strText = szText;
    } else {
        strText = L"";
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL
AVRtlCharToInteger(
    IN  LPCWSTR String,
    IN  ULONG   Base OPTIONAL,
    OUT PULONG  Value
    )
{
    WCHAR c, Sign;
    ULONG Result, Digit, Shift;

    while ((Sign = *String++) <= L' ') {
        if (!*String) {
            String--;
            break;
        }
    }

    c = Sign;
    if (c == L'-' || c == L'+') {
        c = *String++;
    }

    if ( Base == 0 ) {
        Base = 10;
        Shift = 0;
        if (c == L'0' ) {
            c = *String++;
            if (c == L'x' || c == L'X') {
                Base = 16;
                Shift = 4;
            } else
                if (c == L'o' || c == L'O') {
                Base = 8;
                Shift = 3;
            } else
                if (c == L'b' || c == L'B') {
                Base = 2;
                Shift = 1;
            } else {
                String--;
            }

            c = *String++;
        }
    } else {
        switch ( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;
        case 10:    Shift = 0;  break;
        default:    return FALSE;
        }
    }

    Result = 0;
    while (c) {
        if (c >= _T( '0' ) && c <= _T( '9' ) ) {
            Digit = c - '0';
        } else
            if (c >= _T( 'A' ) && c <= _T( 'F' ) ) {
            Digit = c - 'A' + 10;
        } else
            if (c >= _T( 'a' ) && c <= _T( 'f' ) ) {
            Digit = c - _T( 'a' ) + 10;
        } else {
            break;
        }

        if (Digit >= Base) {
            break;
        }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
        } else {
            Result = (Result << Shift) | Digit;
        }

        c = *String++;
    }

    if (Sign == _T('-')) {
        Result = (ULONG)(-(LONG)Result);
    }

    *Value = Result;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL
AVWriteStringHexValueToRegistry(
    HKEY    hKey,
    LPCWSTR szValueName,
    DWORD   dwValue
    )
{
    LONG lResult;
    WCHAR szValue[ 32 ];

    StringCchPrintfW(szValue,
                     ARRAY_LENGTH(szValue),
                     L"0x%08X",
                     dwValue);

    lResult = RegSetValueEx(hKey,
                            szValueName,
                            0,
                            REG_SZ,
                            (BYTE *)szValue,
                            wcslen(szValue) * sizeof(WCHAR) + sizeof(WCHAR));

    return (lResult == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\dbsupport.cpp ===
#include "precomp.h"

#include "ntexapi.h"

using namespace ShimLib;

extern BOOL g_bClearSessionLogBeforeRun;
extern BOOL g_bUseAVDebugger;

#define AVDB_ID_32  _T("{448850f4-a5ea-4dd1-bf1b-d5fa285dc64b}")
#define AVDB_ID_64  _T("{64646464-a5ea-4dd1-bf1b-d5fa285dc64b}")

/////////////////////////////////////////////////////////////////////////////
//
// Registry keys/values names
//

const TCHAR g_szImageOptionsKeyName[] = _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");
const TCHAR g_szGlobalFlagValueName[] = _T("GlobalFlag");
const TCHAR g_szVerifierFlagsValueName[] = _T("VerifierFlags");
const TCHAR g_szVerifierPathValueName[] = _T("VerifierPath");
const TCHAR g_szDebuggerKeyName[] = _T("Debugger");

CAVAppInfoArray g_aAppInfo;

CTestInfoArray  g_aTestInfo;


BOOL
SetAppVerifierFlagsForKey(
    HKEY  hKey,
    DWORD dwDesiredFlags
    )
{
    BOOL  bRet = FALSE;
    DWORD dwValueType = 0;
    DWORD dwDataSize = 0;
    TCHAR szOldGlobalFlagValue[32];
    BOOL  bSuccesfullyConverted;
    BOOL  bDesireEnabled = (dwDesiredFlags != 0);
    LONG  lResult;
    DWORD dwFlags = 0;
    DWORD dwEnableFlag;

    //
    // Read the GlobalFlag value
    //
    dwDataSize = sizeof(szOldGlobalFlagValue);

    lResult = RegQueryValueEx(hKey,
                              g_szGlobalFlagValueName,
                              NULL,
                              &dwValueType,
                              (LPBYTE) &szOldGlobalFlagValue[0],
                              &dwDataSize);

    if (ERROR_SUCCESS == lResult) {
        bSuccesfullyConverted = AVRtlCharToInteger(szOldGlobalFlagValue,
                                                   0,
                                                   &dwFlags);
        if (!bSuccesfullyConverted) {
            dwFlags = 0;
        }
    }

    //
    // handle Win2K differently.
    //
    if (g_bWin2KMode) {

        //
        // we can only do PageHeap on Win2K, so just check that flag
        //
        bDesireEnabled = ((dwDesiredFlags & RTL_VRF_FLG_FULL_PAGE_HEAP) != 0);
        dwEnableFlag = FLG_HEAP_PAGE_ALLOCS;
    } else {
        dwEnableFlag = FLG_APPLICATION_VERIFIER;
    }

    BOOL bEnabled = (dwFlags & dwEnableFlag) != 0;

    //
    // write the new global flags, if necessary
    //
    if (bDesireEnabled != bEnabled) {
        if (bDesireEnabled) {
            dwFlags |= dwEnableFlag;
        } else {
            dwFlags &= ~dwEnableFlag;
        }

        BOOL bSuccess = AVWriteStringHexValueToRegistry(hKey,
                                                        g_szGlobalFlagValueName,
                                                        dwFlags);
        if (!bSuccess) {
            goto out;
        }
    }

    //
    // we only write the special app verifier settings if we're not in Win2K mode
    //
    if (!g_bWin2KMode) {
        //
        // now write the app verifier settings
        //
        if (bDesireEnabled) {
            lResult = RegSetValueEx(hKey,
                                    g_szVerifierFlagsValueName,
                                    0,
                                    REG_DWORD,
                                    (PBYTE) &dwDesiredFlags,
                                    sizeof(dwDesiredFlags));
            if (lResult != ERROR_SUCCESS) {
                goto out;
            }
        } else {
            lResult = RegDeleteValue(hKey, g_szVerifierFlagsValueName);
            if (lResult != ERROR_SUCCESS) {
                goto out;
            }
        }

    }

    bRet = TRUE;

out:
    return bRet;
}

DWORD
GetAppVerifierFlagsFromKey(
    HKEY hKey
    )
{
    DWORD   dwRet = 0;
    DWORD   dwValueType = 0;
    DWORD   dwDataSize = 0;
    TCHAR   szOldGlobalFlagValue[32];
    BOOL    bSuccesfullyConverted;
    LONG    lResult;
    DWORD   dwFlags = 0;

    //
    // Read the GlobalFlag value
    //
    dwDataSize = sizeof(szOldGlobalFlagValue);

    lResult = RegQueryValueEx(hKey,
                              g_szGlobalFlagValueName,
                              NULL,
                              &dwValueType,
                              (LPBYTE)&szOldGlobalFlagValue[0],
                              &dwDataSize);

    if (ERROR_SUCCESS == lResult) {
        bSuccesfullyConverted = AVRtlCharToInteger(szOldGlobalFlagValue,
                                                   0,
                                                   &dwFlags);

        if (g_bWin2KMode) {
            //
            // special check for Win2K
            //
            if ((FALSE != bSuccesfullyConverted) &&
                 ((dwFlags & FLG_HEAP_PAGE_ALLOCS) != 0)) {

                dwRet = RTL_VRF_FLG_FULL_PAGE_HEAP;
            }
        } else {
            if ((FALSE != bSuccesfullyConverted) &&
                 ((dwFlags & FLG_APPLICATION_VERIFIER) != 0)) {
                //
                // App verifier is enabled for this app - read the verifier flags
                //

                dwDataSize = sizeof(dwRet);

                lResult = RegQueryValueEx(hKey,
                                          g_szVerifierFlagsValueName,
                                          NULL,
                                          &dwValueType,
                                          (LPBYTE)&dwRet,
                                          &dwDataSize);

                if (ERROR_SUCCESS != lResult || REG_DWORD != dwValueType) {
                    //
                    // couldn't get them, for one reason or another
                    //
                    dwRet = 0;
                }
            }
        }
    }

    return dwRet;
}

void
SetAppVerifierFullPathForKey(
    HKEY     hKey,
    wstring& strPath
    )
{
    if (strPath.size() == 0) {
        RegDeleteValue(hKey, g_szVerifierPathValueName);
    } else {
        RegSetValueEx(hKey,
                        g_szVerifierPathValueName,
                        0,
                        REG_SZ,
                        (PBYTE) strPath.c_str(),
                        (strPath.size() + 1) * sizeof(WCHAR));
    }
}

void
SetDebuggerOptionsForKey(
    HKEY    hKey,
    CAVAppInfo *pApp
    )
{
    WCHAR szName[MAX_PATH];

    StringCchCopyW(szName, ARRAY_LENGTH(szName), L"\"");

    GetModuleFileName(NULL, szName + 1, MAX_PATH - 10);

    StringCchCatW(szName, ARRAY_LENGTH(szName), L"\" /debug");

    if (pApp && pApp->bBreakOnLog && pApp->wstrDebugger.size()) {

        RegSetValueEx(hKey,
                        g_szDebuggerKeyName,
                        0,
                        REG_SZ,
                        (PBYTE)pApp->wstrDebugger.c_str(),
                        (pApp->wstrDebugger.size() + 1) * sizeof(WCHAR));


    } else {

        WCHAR szDbgName[MAX_PATH];
        DWORD cbSize;

        cbSize = sizeof(szDbgName);

        szDbgName[0] = 0;

        RegQueryValueEx(hKey,
                        g_szDebuggerKeyName,
                        0,
                        NULL,
                        (PBYTE)szDbgName,
                        &cbSize);
        //
        // if the current debugger matches either our own debugger or the user selected one,
        // delete it, but leave alone any other debugger
        //
        if ((_wcsicmp(szName, szDbgName) == 0) || (pApp && (_wcsicmp(pApp->wstrDebugger.c_str(), szDbgName) == 0))) {
            RegDeleteValue(hKey, g_szDebuggerKeyName);
        }
    }
}


void
GetAppVerifierFullPathFromKey(
    HKEY     hKey,
    wstring& strPath
    )
{
    DWORD   dwValueType = 0;
    DWORD   dwDataSize = 0;
    TCHAR   szVerifierPath[MAX_PATH];
    LONG    lResult;

    //
    // Read the GlobalFlag value
    //
    dwDataSize = sizeof(szVerifierPath);

    szVerifierPath[0] = 0;

    lResult = RegQueryValueEx(hKey,
                              g_szVerifierPathValueName,
                              NULL,
                              &dwValueType,
                              (LPBYTE)szVerifierPath,
                              &dwDataSize);

    if (ERROR_SUCCESS == lResult && dwValueType == REG_SZ) {
        strPath = szVerifierPath;
    }
}

void
GetCurrentAppSettingsFromRegistry(
    void
    )
{
    HKEY        hImageOptionsKey;
    HKEY        hSubKey;
    DWORD       dwSubkeyIndex;
    DWORD       dwDataSize;
    DWORD       dwValueType;
    DWORD       dwFlags;
    LONG        lResult;
    FILETIME    LastWriteTime;
    TCHAR       szOldGlobalFlagValue[32];
    TCHAR       szKeyNameBuffer[256];

    //
    // Open the Image File Execution Options regkey
    //
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           g_szImageOptionsKeyName,
                           0,
                           KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                           &hImageOptionsKey);

    if (lResult != ERROR_SUCCESS) {
        if (lResult == ERROR_ACCESS_DENIED) {
            AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
        } else {
            AVErrorResourceFormat(IDS_REGOPENKEYEX_FAILED,
                                  g_szImageOptionsKeyName,
                                  (DWORD)lResult);
        }

        return;
    }

    //
    // Enumerate all the existing subkeys for app execution options
    //
    for (dwSubkeyIndex = 0; TRUE; dwSubkeyIndex += 1) {
        wstring wstrPath;

        dwDataSize = ARRAY_LENGTH(szKeyNameBuffer);

        lResult = RegEnumKeyEx(hImageOptionsKey,
                               dwSubkeyIndex,
                               szKeyNameBuffer,
                               &dwDataSize,
                               NULL,
                               NULL,
                               NULL,
                               &LastWriteTime);

        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_NO_MORE_ITEMS) {
                //
                // We finished looking at all the existing subkeys
                //
                break;
            } else {
                if (lResult == ERROR_ACCESS_DENIED) {
                    AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
                } else {
                    AVErrorResourceFormat(IDS_REGENUMKEYEX_FAILED,
                                          g_szImageOptionsKeyName,
                                          (DWORD)lResult);
                }

                goto CleanUpAndDone;
            }
        }

        //
        // Open the subkey
        //
        lResult = RegOpenKeyEx(hImageOptionsKey,
                               szKeyNameBuffer,
                               0,
                               KEY_QUERY_VALUE | KEY_SET_VALUE,
                               &hSubKey);

        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_ACCESS_DENIED) {
                AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
            } else {
                AVErrorResourceFormat(IDS_REGOPENKEYEX_FAILED,
                                      szKeyNameBuffer,
                                      (DWORD)lResult);
            }

            goto CleanUpAndDone;
        }

        dwFlags = GetAppVerifierFlagsFromKey(hSubKey);
        GetAppVerifierFullPathFromKey(hSubKey, wstrPath);

        if (dwFlags || wstrPath.size()) {
            //
            // Update the info in the array, or add it if necessary
            //
            CAVAppInfo* pApp;
            BOOL        bFound = FALSE;

            for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
                if (_wcsicmp(pApp->wstrExeName.c_str(), szKeyNameBuffer) == 0) {
                    bFound = TRUE;
                    pApp->dwRegFlags = dwFlags;
                    pApp->wstrExePath = wstrPath;
                    break;
                }
            }

            if (!bFound) {
                CAVAppInfo  AppInfo;
                AppInfo.wstrExeName = szKeyNameBuffer;
                AppInfo.dwRegFlags = dwFlags;
                AppInfo.wstrExePath = wstrPath;

                g_aAppInfo.push_back(AppInfo);
            }
        }

        VERIFY(ERROR_SUCCESS == RegCloseKey(hSubKey));
    }

CleanUpAndDone:

    VERIFY(ERROR_SUCCESS == RegCloseKey(hImageOptionsKey));
}

void
GetCurrentAppSettingsFromSDB(
    void
    )
{
    CAVAppInfo  AppInfo;
    TCHAR       szPath[MAX_PATH];
    PDB         pdb = NULL;
    TAGID       tiDB = TAGID_NULL;
    TAGID       tiExe = TAGID_NULL;

    //
    // go find the SDB
    //
    szPath[0] = 0;
    GetSystemWindowsDirectory(szPath, MAX_PATH);

#if defined(_WIN64)
    StringCchCatW(szPath, ARRAY_LENGTH(szPath), _T("\\AppPatch\\Custom\\IA64\\") AVDB_ID_64 _T(".sdb"));
#else
    StringCchCatW(szPath, ARRAY_LENGTH(szPath), _T("\\AppPatch\\Custom\\") AVDB_ID_32 _T(".sdb"));
#endif // _WIN64

    pdb = SdbOpenDatabase(szPath, DOS_PATH);
    if (!pdb) {
        //
        // no current DB
        //
        goto out;
    }

    //
    // enumerate all the apps and the shims applied to them
    //
    tiDB = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    if (!tiDB) {
        goto out;
    }

    tiExe = SdbFindFirstTag(pdb, tiDB, TAG_EXE);

    while (tiExe) {
        WCHAR* wszName = NULL;
        TAGID  tiShim = TAGID_NULL;
        TAGID  tiName = SdbFindFirstTag(pdb, tiExe, TAG_NAME);

        if (!tiName) {
            goto nextExe;
        }
        wszName = SdbGetStringTagPtr(pdb, tiName);
        if (!wszName) {
            goto nextExe;
        }

        CAVAppInfoArray::iterator it;
        BOOL bFound = FALSE;

        for (it = g_aAppInfo.begin(); it != g_aAppInfo.end(); it++) {
            if (_wcsicmp(it->wstrExeName.c_str(), wszName) == 0) {
                bFound = TRUE;
                break;
            }
        }

        if (!bFound) {
            AppInfo.wstrExeName = wszName;
            g_aAppInfo.push_back(AppInfo);
            it = g_aAppInfo.end() - 1;
        }

        tiShim = SdbFindFirstTag(pdb, tiExe, TAG_SHIM_REF);

        while (tiShim) {
            WCHAR* wszShimName = NULL;
            TAGID  tiShimName = SdbFindFirstTag(pdb, tiShim, TAG_NAME);

            if (!tiShimName) {
                goto nextShim;
            }

            wszShimName = SdbGetStringTagPtr(pdb, tiShimName);

            it->awstrShims.push_back(wstring(wszShimName));

            nextShim:
            tiShim = SdbFindNextTag(pdb, tiExe, tiShim);
        }

nextExe:

        tiExe = SdbFindNextTag(pdb, tiDB, tiExe);
    }

out:

    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    return;
}

void
InitDefaultAppSettings(
    void
    )
{

    BOOL bFound = FALSE;

    //
    // see if it's already in the list
    //

    for (CAVAppInfo *pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
        if (pApp->wstrExeName == AVRF_DEFAULT_SETTINGS_NAME_W) {
            if (pApp != g_aAppInfo.begin()) {
                //
                // it's not at the beginning, so move it to the beginning
                //
                CAVAppInfo AppTemp;

                AppTemp = *pApp;
                g_aAppInfo.erase(pApp);

                g_aAppInfo.insert(g_aAppInfo.begin(), AppTemp);
            }

            bFound = TRUE;
            break;
        }
    }

    //
    // it's not, so add it to the beginning
    //
    if (!bFound) {
        CAVAppInfo  AppInfo;
        AppInfo.wstrExeName = AVRF_DEFAULT_SETTINGS_NAME_W;

        CTestInfo *pTest;
        for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
            if (pTest->bDefault) {
                AppInfo.AddTest(*pTest);
            }
        }

        g_aAppInfo.insert(g_aAppInfo.begin(), AppInfo);
    }
}

void
GetCurrentAppSettings(
    void
    )
{
    g_aAppInfo.clear();

    //
    // make sure default is in the first position
    //
    CAVAppInfo  AppInfo;
    AppInfo.wstrExeName = AVRF_DEFAULT_SETTINGS_NAME_W;

    g_aAppInfo.push_back(AppInfo);

    GetCurrentAppSettingsFromRegistry();
    GetCurrentAppSettingsFromSDB();

    InitDefaultAppSettings();
}


void
SetCurrentRegistrySettings(
    void
    )
{
    HKEY        hImageOptionsKey;
    HKEY        hSubKey = NULL;
    DWORD       dwSubkeyIndex;
    DWORD       dwDataSize;
    DWORD       dwValueType;
    DWORD       dwFlags;
    LONG        lResult;
    FILETIME    LastWriteTime;
    TCHAR       szKeyNameBuffer[ 256 ];
    CAVAppInfo* pApp;
    wstring     wstrEmpty = L"";

    //
    // Open the Image File Execution Options regkey
    //
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           g_szImageOptionsKeyName,
                           0,
                           KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                           &hImageOptionsKey);

    if (lResult != ERROR_SUCCESS) {
        if (lResult == ERROR_ACCESS_DENIED) {
            AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
        } else {
            AVErrorResourceFormat(IDS_REGOPENKEYEX_FAILED,
                                  g_szImageOptionsKeyName,
                                  (DWORD)lResult);
        }

        return;
    }

    //
    // Enumerate all the existing subkeys for app execution options
    //

    for (dwSubkeyIndex = 0; TRUE; dwSubkeyIndex += 1) {
        dwDataSize = ARRAY_LENGTH(szKeyNameBuffer);

        lResult = RegEnumKeyEx(hImageOptionsKey,
                               dwSubkeyIndex,
                               szKeyNameBuffer,
                               &dwDataSize,
                               NULL,
                               NULL,
                               NULL,
                               &LastWriteTime);

        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_NO_MORE_ITEMS) {
                //
                // We finished looking at all the existing subkeys
                //
                break;
            } else {
                if (lResult == ERROR_ACCESS_DENIED) {
                    AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
                } else {
                    AVErrorResourceFormat(IDS_REGENUMKEYEX_FAILED,
                                          g_szImageOptionsKeyName,
                                          (DWORD)lResult);
                }

                goto CleanUpAndDone;
            }
        }

        //
        // Open the subkey
        //
        lResult = RegOpenKeyEx(hImageOptionsKey,
                               szKeyNameBuffer,
                               0,
                               KEY_QUERY_VALUE | KEY_SET_VALUE,
                               &hSubKey);

        if (lResult != ERROR_SUCCESS) {
            if (lResult == ERROR_ACCESS_DENIED) {
                AVErrorResourceFormat(IDS_ACCESS_IS_DENIED);
            } else {
                AVErrorResourceFormat(IDS_REGOPENKEYEX_FAILED,
                                      szKeyNameBuffer,
                                      (DWORD)lResult);
            }

            goto CleanUpAndDone;
        }

        dwFlags = GetAppVerifierFlagsFromKey(hSubKey);

        DWORD dwDesiredFlags = 0;
        BOOL bFound = FALSE;

        for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
            if (_wcsicmp(pApp->wstrExeName.c_str(), szKeyNameBuffer) == 0) {
                dwDesiredFlags = pApp->dwRegFlags;
                bFound = TRUE;

                //
                // we found it, so update the full path
                //
                SetAppVerifierFullPathForKey(hSubKey, pApp->wstrExePath);

                //
                // and add the debugger as well
                //
                SetDebuggerOptionsForKey(hSubKey, pApp);

                break;
            }
        }

        if (!bFound) {
            //
            // if this one isn't in our list, make sure it doesn't
            // have a full path or our debugger set
            //
            SetAppVerifierFullPathForKey(hSubKey, wstrEmpty);
            SetDebuggerOptionsForKey(hSubKey, NULL);
        }

        if (dwFlags != dwDesiredFlags) {
            SetAppVerifierFlagsForKey(hSubKey, dwDesiredFlags);
        }



        VERIFY(ERROR_SUCCESS == RegCloseKey(hSubKey));
        hSubKey = NULL;
    }

    //
    // and now go through the list the other way, looking for new ones to add
    //
    for (pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); pApp++) {
        lResult = RegOpenKeyEx(hImageOptionsKey,
                               pApp->wstrExeName.c_str(),
                               0,
                               KEY_QUERY_VALUE | KEY_SET_VALUE,
                               &hSubKey);

        //
        // if it exists, we've already dealt with it above
        //
        if (lResult != ERROR_SUCCESS) {
            //
            // it doesn't exist. Try to create it.
            //
            lResult = RegCreateKeyEx(hImageOptionsKey,
                                     pApp->wstrExeName.c_str(),
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_QUERY_VALUE | KEY_SET_VALUE,
                                     NULL,
                                     &hSubKey,
                                     NULL);

            if (lResult == ERROR_SUCCESS) {
                SetAppVerifierFlagsForKey(hSubKey, pApp->dwRegFlags);
                SetAppVerifierFullPathForKey(hSubKey, pApp->wstrExePath);

                SetDebuggerOptionsForKey(hSubKey, pApp);
            }
        }

        if (hSubKey) {
            RegCloseKey(hSubKey);
            hSubKey = NULL;
        }
    }

CleanUpAndDone:

    VERIFY(ERROR_SUCCESS == RegCloseKey(hImageOptionsKey));
}

void
SetCurrentAppSettings(
    void
    )
{
    SetCurrentRegistrySettings();
    AppCompatWriteShimSettings(g_aAppInfo, TRUE);
#if defined(_WIN64)
    AppCompatWriteShimSettings(g_aAppInfo, FALSE);
#endif
}

KERNEL_TEST_INFO g_KernelTests[] =
{
    {
        IDS_PAGE_HEAP,
        IDS_PAGE_HEAP_DESC,
        RTL_VRF_FLG_FULL_PAGE_HEAP,
        TRUE,
        L"PageHeap",
        TRUE
    },
    {
        IDS_VERIFY_LOCKS_CHECKS,
        IDS_VERIFY_LOCKS_CHECKS_DESC,
        RTL_VRF_FLG_LOCK_CHECKS,
        TRUE,
        L"Locks",
        FALSE
    },
    {
        IDS_VERIFY_HANDLE_CHECKS,
        IDS_VERIFY_HANDLE_CHECKS_DESC,
        RTL_VRF_FLG_HANDLE_CHECKS,
        TRUE,
        L"Handles",
        FALSE
    },
    {
        IDS_VERIFY_STACK_CHECKS,
        IDS_VERIFY_STACK_CHECKS_DESC,
        RTL_VRF_FLG_STACK_CHECKS,
        FALSE,
        L"Stacks",
        FALSE
    },
    {
        IDS_VERIFY_RPC_CHECKS,
        IDS_VERIFY_RPC_CHECKS_DESC,
        RTL_VRF_FLG_RPC_CHECKS,
        FALSE,
        L"RPC Checks",
        FALSE
    }
};

BOOL
GetKernelTestInfo(
    CTestInfoArray& TestArray
    )
{
    CTestInfo ti;
    TCHAR     szTemp[256];
    int       i;

    ti.eTestType = TEST_KERNEL;

    for (i = 0; i < ARRAY_LENGTH(g_KernelTests); ++i) {
        ti.strTestName = g_KernelTests[i].m_szCommandLine;

        if (AVLoadString(g_KernelTests[i].m_uFriendlyNameStringId, szTemp, ARRAY_LENGTH(szTemp))) {
            ti.strTestFriendlyName = szTemp;
        } else {
            ti.strTestFriendlyName = ti.strTestName;
        }

        if (AVLoadString(g_KernelTests[i].m_uDescriptionStringId, szTemp, ARRAY_LENGTH(szTemp))) {
            ti.strTestDescription = szTemp;
        } else {
            ti.strTestDescription = L"";
        }

        ti.dwKernelFlag = g_KernelTests[i].m_dwBit;
        ti.bDefault =  g_KernelTests[i].m_bDefault;
        ti.bWin2KCompatible = g_KernelTests[i].m_bWin2KCompatible;

        TestArray.push_back(ti);
    }

    return TRUE;
}

void
ParseIncludeList(
    WCHAR*          szList,
    CIncludeArray&  aArray
    )
{
    if (!szList) {
        return;
    }

    BOOL bInclude = TRUE;

    WCHAR *szBegin = szList;
    WCHAR *szEnd = NULL;
    DWORD dwLen = 0;

    while (1) {

        //
        // skip space
        //
        while (*szBegin == L' ') {
            szBegin++;
        }

        //
        // check for end
        //
        if (*szBegin == 0) {
            break;
        }

        //
        // check for E: or I:
        //
        if (_wcsnicmp(szBegin, L"E:", 2) == 0) {
            bInclude = FALSE;
            szBegin += 2;
            continue;
        }
        if (_wcsnicmp(szBegin, L"I:", 2) == 0) {
            bInclude = TRUE;
            szBegin += 2;
            continue;
        }

        szEnd = wcschr(szBegin, L' ');
        if (szEnd) {
            dwLen = szEnd - szBegin;
        } else {
            dwLen = wcslen(szBegin);
        }

        if (dwLen) {
            WCHAR szTemp[MAX_PATH];
            CIncludeInfo Include;

            memcpy(szTemp, szBegin, dwLen * sizeof(WCHAR));
            szTemp[dwLen] = 0;

            Include.bInclude = bInclude;
            Include.strModule = szTemp;

            aArray.push_back(Include);

            szBegin += dwLen;
        } else {

            //
            // just in case
            //
            break;
        }

    }
}

BOOL
GetShimInfo(
    CTestInfoArray& TestInfoArray
    )
{
    HKEY hKey = NULL;
    BOOL bRet = FALSE;
    int nWhich = 0;
    TCHAR szAppPatch[MAX_PATH];
    TCHAR szShimFullPath[MAX_PATH];
    HMODULE hMod = NULL;
    _pfnGetVerifierMagic pGetVerifierMagic = NULL;
    _pfnQueryShimInfo pQueryShimInfo = NULL;
    LPWSTR *pShimNames = NULL;
    DWORD dwShims = 0;

    WIN32_FIND_DATA FindData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    TCHAR szDllSearch[MAX_PATH];

    szAppPatch[0] = 0;
    GetSystemWindowsDirectory(szAppPatch, MAX_PATH);

#if defined(_WIN64)
    StringCchCatW(szAppPatch, ARRAY_LENGTH(szAppPatch), _T("\\AppPatch\\IA64\\"));
#else
    StringCchCatW(szAppPatch, ARRAY_LENGTH(szAppPatch), _T("\\AppPatch\\"));
#endif // defined(_WIN64)

    StringCchCopyW(szDllSearch, ARRAY_LENGTH(szDllSearch), szAppPatch);
    StringCchCatW(szDllSearch, ARRAY_LENGTH(szDllSearch), _T("*.dll"));

    //
    // enumerate all the DLLs and look for ones that have Verification
    // shims in them
    //
    hFind = FindFirstFile(szDllSearch, &FindData);
    while (hFind != INVALID_HANDLE_VALUE) {

        BOOL bVerifierShim = FALSE;

        StringCchCopyW(szShimFullPath, ARRAY_LENGTH(szShimFullPath), szAppPatch);
        StringCchCatW(szShimFullPath, ARRAY_LENGTH(szShimFullPath), FindData.cFileName);

        hMod = LoadLibrary(szShimFullPath);
        if (!hMod) {
            goto nextKey;
        }

        pGetVerifierMagic = (_pfnGetVerifierMagic)GetProcAddress(hMod, "GetVerifierMagic");
        if (!pGetVerifierMagic) {
            //
            // not a real verifier shim
            //
            goto nextKey;
        }

        if (pGetVerifierMagic() != VERIFIER_SHIMS_MAGIC) {
            //
            // not a real verifier shim
            //
            goto nextKey;
        }

        pQueryShimInfo = (_pfnQueryShimInfo)GetProcAddress(hMod, "QueryShimInfo");
        if (!pQueryShimInfo) {
            //
            // not a real verifier shim
            //
            goto nextKey;
        }
        dwShims = 0;
        if (!pQueryShimInfo(NULL, AVRF_INFO_NUM_SHIMS, (PVOID)&dwShims) || dwShims == 0) {
            //
            // no shims available
            //
            goto nextKey;
        }

        bVerifierShim = TRUE;

        pShimNames = new LPWSTR[dwShims];
        if (!pShimNames) {
            goto out;
        }

        if (!pQueryShimInfo(NULL, AVRF_INFO_SHIM_NAMES, (PVOID)pShimNames)) {
            goto nextKey;
        }

        for (DWORD i = 0; i < dwShims; ++i) {
            CTestInfo ti;
            LPWSTR szTemp = NULL;
            DWORD dwFlags = 0;
            DWORD dwVersion = 0;

            ti.eTestType = TEST_SHIM;
            ti.strDllName = FindData.cFileName;
            ti.strTestName = pShimNames[i];

            szTemp = NULL;
            if (pQueryShimInfo(pShimNames[i], AVRF_INFO_FRIENDLY_NAME, (PVOID)&szTemp) && szTemp) {
                ti.strTestFriendlyName = szTemp;
            } else {
                //
                // default to the shim name
                //
                ti.strTestFriendlyName = pShimNames[i];
            }

            if (pQueryShimInfo(pShimNames[i], AVRF_INFO_VERSION, (PVOID)&dwVersion)) {
                WCHAR szVersion[40];

                ti.wVersionHigh = HIWORD(dwVersion);
                ti.wVersionLow = LOWORD(dwVersion);

                StringCchPrintfW(szVersion, ARRAY_LENGTH(szVersion), L" (%d.%d)", ti.wVersionHigh, ti.wVersionLow);

                ti.strTestFriendlyName += szVersion;
            }

            szTemp = NULL;
            if (pQueryShimInfo(pShimNames[i], AVRF_INFO_DESCRIPTION, (PVOID)&szTemp) && szTemp) {
                ti.strTestDescription = szTemp;
            }
            if (pQueryShimInfo(pShimNames[i], AVRF_INFO_FLAGS, (PVOID)&dwFlags)) {
                ti.bDefault = !(dwFlags & AVRF_FLAG_NO_DEFAULT) && !(dwFlags & AVRF_FLAG_RUN_ALONE);
                ti.bWin2KCompatible = !(dwFlags & AVRF_FLAG_NO_WIN2K);
                ti.bSetupOK = !(dwFlags & AVRF_FLAG_NOT_SETUP);
                ti.bNonSetupOK = !(dwFlags & AVRF_FLAG_ONLY_SETUP);
                ti.bRunAlone = !!(dwFlags & AVRF_FLAG_RUN_ALONE);
                ti.bPseudoShim = !!(dwFlags & AVRF_FLAG_NO_SHIM);
                ti.bNonTest = !!(dwFlags & AVRF_FLAG_NO_TEST);
                ti.bInternal = !(dwFlags & AVRF_FLAG_EXTERNAL_ONLY);
                ti.bExternal = !(dwFlags & AVRF_FLAG_INTERNAL_ONLY);
            } else {
                ti.bDefault = TRUE;
                ti.bWin2KCompatible = TRUE;
                ti.bSetupOK = TRUE;
                ti.bNonSetupOK = TRUE;
                ti.bRunAlone = FALSE;
                ti.bPseudoShim = FALSE;
                ti.bNonTest = FALSE;
                ti.bInternal = TRUE;
                ti.bExternal = TRUE;
            }

            szTemp = NULL;
            if (pQueryShimInfo(pShimNames[i], AVRF_INFO_INCLUDE_EXCLUDE, (PVOID)&szTemp) && szTemp) {
                ParseIncludeList(szTemp, ti.aIncludes);
            }

            //
            // now get the PropSheetPage
            //
            if (pQueryShimInfo(pShimNames[i], AVRF_INFO_OPTIONS_PAGE, (PVOID)&(ti.PropSheetPage))) {
                ti.PropSheetPage.dwFlags |= PSP_USETITLE;
                ti.PropSheetPage.pszTitle = ti.strTestName.c_str();

            } else {
                ZeroMemory(&(ti.PropSheetPage), sizeof(PROPSHEETPAGE));
            }


            //
            // add it to the end
            //
            TestInfoArray.push_back(ti);
        }



nextKey:
        if (pShimNames) {
            delete [] pShimNames;
            pShimNames = NULL;
        }

        if (hMod) {
            //
            // if it's a verifier shim, we need to keep it around
            //
            if (!bVerifierShim) {
                FreeLibrary(hMod);
            }
            hMod = NULL;
        }
        if (!FindNextFile(hFind, &FindData)) {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }


    bRet = TRUE;

    out:

    if (hMod) {
        FreeLibrary(hMod);
        hMod = NULL;
    }
    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }
    return bRet;
}

BOOL
InitTestInfo(
    void
    )
{
    g_aTestInfo.clear();

    if (!GetKernelTestInfo(g_aTestInfo)) {
        return FALSE;
    }
    if (!GetShimInfo(g_aTestInfo)) {
        return FALSE;
    }

    return TRUE;
}

void
ResetVerifierLog(
    void
    )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    BOOL bFound;
    DWORD cchSize;
    TCHAR szVLogPath[MAX_PATH];
    TCHAR szVLogSearch[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    HANDLE hFile;

    cchSize = GetAppVerifierLogPath(szVLogPath, ARRAY_LENGTH(szVLogPath));

    if (cchSize > ARRAY_LENGTH(szVLogPath) || cchSize == 0) {
        return;
    }

    StringCchCopyW(szVLogSearch, ARRAY_LENGTH(szVLogSearch), szVLogPath);
    StringCchCatW(szVLogSearch, ARRAY_LENGTH(szVLogSearch), _T("\\"));
    StringCchCatW(szVLogSearch, ARRAY_LENGTH(szVLogSearch), _T("*.log"));

    //
    // kill all the .log files
    //
    hFind = FindFirstFile(szVLogSearch, &FindData);
    while (hFind != INVALID_HANDLE_VALUE) {

        StringCchCopyW(szPath, ARRAY_LENGTH(szPath), szVLogPath);
        StringCchCatW(szPath, ARRAY_LENGTH(szPath), _T("\\"));
        StringCchCatW(szPath, ARRAY_LENGTH(szPath), FindData.cFileName);

        DeleteFile(szPath);

        if (!FindNextFile(hFind, &FindData)) {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    //
    // recreate session.log
    //
    CreateDirectory(szVLogPath, NULL);

    StringCchCopyW(szPath, ARRAY_LENGTH(szPath), szVLogPath);
    StringCchCatW(szPath, ARRAY_LENGTH(szPath), _T("\\"));
    StringCchCatW(szPath, ARRAY_LENGTH(szPath), _T("session.log"));

    hFile = CreateFile(szPath,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return;
}

void EnableVerifierLog(void)
{
    HANDLE hFile;
    TCHAR szPath[MAX_PATH];
    TCHAR szVLogPath[MAX_PATH];
    DWORD cchSize;

    cchSize = GetAppVerifierLogPath(szVLogPath, ARRAY_LENGTH(szVLogPath));

    if (cchSize > ARRAY_LENGTH(szVLogPath) || cchSize == 0) {
        return;
    }

    //
    // make sure log dir and session.log exists
    //
    CreateDirectory(szVLogPath, NULL);

    StringCchCopyW(szPath, ARRAY_LENGTH(szPath), szVLogPath);
    StringCchCatW(szPath, ARRAY_LENGTH(szPath), _T("\\"));
    StringCchCatW(szPath, ARRAY_LENGTH(szPath), _T("session.log"));

    hFile = CreateFile(szPath,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}

CTestInfo*
FindShim(
    wstring& wstrName
    )
{
    CTestInfoArray::iterator it;

    for (it = g_aTestInfo.begin(); it != g_aTestInfo.end(); it++) {
        if (it->strTestName == wstrName) {
            return &(*it);
        }
    }

    return NULL;
}

extern "C" BOOL
ShimdbcExecute(
    LPCWSTR lpszCmdLine
    );

BOOL
AppCompatWriteShimSettings(
    CAVAppInfoArray& arrAppInfo,
    BOOL             b32bitOnly
    )
{
    TCHAR               szTempPath[MAX_PATH] = _T("");
    TCHAR               szXmlFile[MAX_PATH]  = _T("");
    TCHAR               szSdbFile[MAX_PATH]  = _T("");
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               bytesWritten;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    BOOL                bReturn = FALSE;
    TCHAR               szUnicodeHdr[2] = { 0xFEFF, 0};
    wstring             wstrXML;
    static WCHAR        wszTemp[2048];
    static WCHAR        wszCmd[1024];


    if (0 == arrAppInfo.size()) {
        return AppCompatDeleteSettings();
    }

    wszTemp[0] = 0;

    //
    // Construct the XML...
    //
#if defined(_WIN64)
    if (!b32bitOnly) {
        StringCchPrintfW(wszTemp,
                         ARRAYSIZE(wszTemp),
                         _T("%s<?xml version=\"1.0\"?>\r\n")
                         _T("<DATABASE NAME=\"Application Verifier Database (64 bit)\" ID=\"%s\">\r\n")
                         _T("    <LIBRARY>\r\n"),
                         szUnicodeHdr,
                         AVDB_ID_64);
    } else
#endif
    {
        StringCchPrintfW(wszTemp,
                         ARRAYSIZE(wszTemp),
                         _T("%s<?xml version=\"1.0\"?>\r\n")
                         _T("<DATABASE NAME=\"Application Verifier Database\" ID=\"%s\">\r\n")
                         _T("    <LIBRARY>\r\n"),
                         szUnicodeHdr,
                         AVDB_ID_32);
    }

    wstrXML += wszTemp;

    CTestInfoArray::iterator it;

    for (it = g_aTestInfo.begin(); it != g_aTestInfo.end(); it++) {
        if (it->eTestType != TEST_SHIM) {
            continue;
        }
        StringCchPrintfW(wszTemp,
                         ARRAYSIZE(wszTemp),
                         _T("        <SHIM NAME=\"%s\" FILE=\"%s\">\r\n")
                         _T("            <DESCRIPTION>\r\n")
                         _T("                %s\r\n")
                         _T("            </DESCRIPTION>\r\n"),
                         it->strTestName.c_str(),
                         it->strDllName.c_str(),
                         it->strTestDescription.c_str());

        wstrXML += wszTemp;

        CIncludeArray::iterator iait;

        for (iait = it->aIncludes.begin(); iait != it->aIncludes.end(); ++iait) {
            if (iait->bInclude) {
                StringCchPrintfW(wszTemp,
                                 ARRAYSIZE(wszTemp),
                                 _T("            <INCLUDE MODULE=\"%s\"/>\r\n"),
                                 iait->strModule.c_str());
            } else {
                StringCchPrintfW(wszTemp,
                                 ARRAYSIZE(wszTemp),
                                 _T("            <EXCLUDE MODULE=\"%s\"/>\r\n"),
                                 iait->strModule.c_str());
            }

            wstrXML += wszTemp;

        }

        //
        // make sure the EXE is included
        //
        wstrXML += _T("            <INCLUDE MODULE=\"%EXE%\"/>\r\n");

        wstrXML += _T("        </SHIM>\r\n");

    }

    //
    // put in layers for handling propagation of shims -- one layer per EXE
    //
    CAVAppInfo* aiit;

    for (aiit = arrAppInfo.begin(); aiit != arrAppInfo.end(); aiit++) {

        //
        // if there are no shims, we're done
        //
        if (aiit->awstrShims.size() == 0) {
            continue;
        }

        if (aiit->bPropagateTests) {
            StringCchPrintfW(wszTemp,
                             ARRAYSIZE(wszTemp),
                             _T("        <LAYER NAME=\"LAYER_%s\">\r\n"),
                             aiit->wstrExeName.c_str());
            wstrXML += wszTemp;

            CWStringArray::iterator wsit;

            for (wsit = aiit->awstrShims.begin();
                wsit != aiit->awstrShims.end();
                wsit++) {

                CTestInfo* pTestInfo = FindShim(*wsit);

                if (pTestInfo) {
                    StringCchPrintfW(wszTemp,
                                     ARRAYSIZE(wszTemp),
                                     _T("            <SHIM NAME=\"%s\"/>\r\n"),
                                     pTestInfo->strTestName.c_str());

                    wstrXML += wszTemp;
                }
            }

            wstrXML += _T("        </LAYER>\r\n");
        }
    }

    wstrXML += _T("    </LIBRARY>\r\n\r\n");
    wstrXML += _T("    <APP NAME=\"All EXEs to be verified\" VENDOR=\"Various\">\r\n");

    for (aiit = arrAppInfo.begin(); aiit != arrAppInfo.end(); aiit++) {

        //
        // if there are no shims, we're done
        //
        if (aiit->awstrShims.size() == 0) {
            continue;
        }

        StringCchPrintfW(wszTemp,
                         ARRAYSIZE(wszTemp),
                         _T("        <EXE NAME=\"%s\">\r\n"),
                         aiit->wstrExeName.c_str());
        wstrXML += wszTemp;

        if (aiit->bPropagateTests) {

            //
            // we need to fill in the layer name
            //
            StringCchPrintfW(wszTemp,
                             ARRAYSIZE(wszTemp),
                             _T("            <LAYER NAME=\"LAYER_%s\"/>\r\n"),
                             aiit->wstrExeName.c_str());

            wstrXML += wszTemp;
        }

        //
        // we still need to save the shim names, so they won't be lost when we
        // load appverifier again. It's redundant, but doesn't hurt anything.
        //
        CWStringArray::iterator wsit;

        for (wsit = aiit->awstrShims.begin();
            wsit != aiit->awstrShims.end();
            wsit++) {

            CTestInfo* pTestInfo = FindShim(*wsit);

            if (pTestInfo) {
                StringCchPrintfW(wszTemp,
                                 ARRAYSIZE(wszTemp),
                                 _T("            <SHIM NAME=\"%s\"/>\r\n"),
                                 pTestInfo->strTestName.c_str());

                wstrXML += wszTemp;
            }
        }

        wstrXML += _T("        </EXE>\r\n");
    }

    wstrXML +=
            _T("    </APP>\r\n")
            _T("</DATABASE>");

    if (GetTempPath(MAX_PATH, szTempPath) == 0) {
        DPF("[AppCompatSaveSettings] GetTempPath failed.");
        goto cleanup;
    }

    //
    // Obtain a temp name for the XML file
    //
    if (GetTempFileName(szTempPath, _T("XML"), NULL, szXmlFile) == 0) {
        DPF("[AppCompatSaveSettings] GetTempFilePath for XML failed.");
        goto cleanup;
    }

    hFile = CreateFile(szXmlFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DPF("[AppCompatSaveSettings] CreateFile '%s' failed 0x%X.",
            szXmlFile, GetLastError());
        goto cleanup;
    }

    if (WriteFile(hFile, wstrXML.c_str(), wstrXML.length() * sizeof(TCHAR), &bytesWritten, NULL) == 0) {
        DPF("[AppCompatSaveSettings] WriteFile \"%s\" failed 0x%X.",
            szXmlFile, GetLastError());
        goto cleanup;
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    //
    // Obtain a temp name for the SDB file
    //
    StringCchPrintfW(szSdbFile, ARRAY_LENGTH(szSdbFile), _T("%stempdb.sdb"), szTempPath);

    DeleteFile(szSdbFile);

    //
    // Invoke the compiler to generate the SDB file
    //

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    StringCchPrintfW(wszCmd, ARRAY_LENGTH(wszCmd), _T("shimdbc.exe fix -q \"%s\" \"%s\""), szXmlFile, szSdbFile);

    if (!ShimdbcExecute(wszCmd)) {
        DPF("[AppCompatSaveSettings] CreateProcess \"%s\" failed 0x%X.",
            wszCmd, GetLastError());
        goto cleanup;
    }

    //
    // The SDB file is generated. Install the database now.
    //
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

#if defined(_WIN64)
    if (b32bitOnly) {
        
        WCHAR wszSys[MAX_PATH] = L"";
        int   nLen;
        
        GetSystemWindowsDirectory(wszSys, MAX_PATH);

        nLen = wcslen(wszSys);
        
        if (wszSys[nLen - 1] == L'\\') {
            wszSys[nLen - 1] = 0;
        }

        StringCchPrintfW(wszCmd,
                         ARRAY_LENGTH(wszCmd),
                         _T("%s\\syswow64\\sdbinst.exe -q \"%s\""),
                         wszSys,
                         szSdbFile);
    }
#endif
    {
        StringCchPrintfW(wszCmd, ARRAY_LENGTH(wszCmd), _T("sdbinst.exe -q \"%s\""), szSdbFile);
    }

    if (!CreateProcess(NULL,
                        wszCmd,
                        NULL,
                        NULL,
                        FALSE,
                        NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                        NULL,
                        NULL,
                        &si,
                        &pi)) {

        DPF("[AppCompatSaveSettings] CreateProcess \"%s\" failed 0x%X.",
            wszCmd, GetLastError());
        goto cleanup;
    }

    CloseHandle(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);

    //
    // ensure we've got a fresh log session started
    //
    EnableVerifierLog();

    bReturn = TRUE;

    cleanup:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    DeleteFile(szXmlFile);
    DeleteFile(szSdbFile);

    return bReturn;
}

BOOL
AppCompatDeleteSettings(
    void
    )
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               wszCmd[MAX_PATH];

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

#if defined(_WIN64)
    StringCchPrintfW(wszCmd, ARRAY_LENGTH(wszCmd), _T("sdbinst.exe -q -u -g ") AVDB_ID_64);
#else
    StringCchPrintfW(wszCmd, ARRAY_LENGTH(wszCmd), _T("sdbinst.exe -q -u -g ") AVDB_ID_32);
#endif

    if (!CreateProcess(NULL,
                         wszCmd,
                         NULL,
                         NULL,
                         FALSE,
                         NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                         NULL,
                         NULL,
                         &si,
                         &pi)) {

        DPF("[AppCompatDeleteSettings] CreateProcess \"%s\" failed 0x%X.",
            wszCmd, GetLastError());
        return FALSE;
    }

    CloseHandle(pi.hThread);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\precomp.h ===
#ifndef __APPVERIFIER_PRECOMP_H__
#define __APPVERIFIER_PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT

#include "afxwin.h"
#include <shellapi.h>
#include <commdlg.h>
#include <commctrl.h>
#include <shlobj.h>
#include <shlobjp.h>    // needed for Link Window support
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <algorithm>
#include <vector>

using namespace std;


#include "ids.h"

extern "C" {
#include "shimdb.h"
}

#include "avrfutil.h"
#include "avutil.h"
#include "dbsupport.h"
#include "strsafe.h"


VOID
DebugPrintf(
    LPCSTR pszFmt,
    ...
    );

#if DBG
#define DPF DebugPrintf
#else
#define DPF if (0) DebugPrintf
#endif



///////////////////////////////////////////////////////////////////////////
//
// ARRAY_LENGTH macro
//

#ifndef ARRAY_LENGTH
#define ARRAY_LENGTH( array )   ( sizeof( array ) / sizeof( array[ 0 ] ) )
#endif //#ifndef ARRAY_LENGTH


//
// Application name ("Application Verifier Manager")
//

extern wstring      g_strAppName;

extern HINSTANCE    g_hInstance;

extern BOOL         g_bConsoleMode;

extern BOOL         g_bWin2KMode;

extern WCHAR        g_szDebugger[];

extern BOOL         g_bBreakOnLog;

extern BOOL         g_bPropagateTests;

extern BOOL         g_bInternalMode;

#endif // __APPVERIFIER_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\viewlog.h ===
#ifndef __APPVERIFIER_VIEWLOG_H_
#define __APPVERIFIER_VIEWLOG_H_

extern TCHAR   g_szSingleLogFile[MAX_PATH];

class CProcessLogEntry;

class CProcessLogInstance {
public:
    wstring     strText;
    VLOG_LEVEL  eLevel;
    wstring     strModule;
    DWORD       dwOffset;

    DWORD       dwProcessLogEntry;   // parent index pointer
    DWORD       dwNumRepeats;

    BOOL        bDuplicate;         // is this a dupe of a previous entry (so no need to display)?

    CProcessLogInstance(void) :
        dwOffset(0),
        eLevel(VLOG_LEVEL_ERROR),
        dwProcessLogEntry(0),
        dwNumRepeats(1),
        bDuplicate(FALSE) {}
};

typedef vector<CProcessLogInstance> CProcessLogInstanceArray;
typedef vector<DWORD> CIndexArray;

class CProcessLogEntry {
public:
    wstring     strShimName;
    DWORD       dwLogNum;

    wstring     strLogTitle;
    wstring     strLogDescription;
    wstring     strLogURL;
    DWORD       dwOccurences;

    CIndexArray    arrLogInstances; // array indexes of instances

    HTREEITEM   hTreeItem;
    
    VLOG_LEVEL  eLevel;

    CProcessLogEntry(void) : 
        dwLogNum(0),
        dwOccurences(0),
        eLevel(VLOG_LEVEL_INFO) {}

};

typedef vector<CProcessLogEntry> CProcessLogEntryArray;

class CSessionLogEntry {
public:
    wstring     strExeName;  // just name and ext
    wstring     strExePath;  // full path to exe
    SYSTEMTIME  RunTime;
    wstring     strLogPath;  // full path to log

    HTREEITEM   hTreeItem;

    CProcessLogEntryArray       arrProcessLogEntries;
    CProcessLogInstanceArray    arrProcessLogInstances;

    CSessionLogEntry(void) :
        hTreeItem(NULL)
    
    {
        ZeroMemory(&RunTime, sizeof(SYSTEMTIME));
    }
};

typedef vector<CSessionLogEntry> CSessionLogEntryArray;

INT_PTR CALLBACK DlgViewLog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif // #ifndef __APPVERIFIER_VIEWLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\addin.cpp ===
// AddIn.cpp
// DLL server exported functions, global ATL module stuff.

#include <initguid.h>
#include "precomp.h"
#include "resource.h"
#include "AddIn.h"
#include "Connect.h"
#include "TestSettingsCtrl.h"
#include "logviewer.h"
#include "avoptions.h"
#include "viewlog.h"
#include <assert.h>

extern CSessionLogEntryArray g_arrSessionLog;
// Global heap so we don't corrupt VS's heap (or vice-versa)
HANDLE  g_hHeap = NULL;

// Global ATL module
CComModule _Module;

// All the class objects this server exports.
BEGIN_OBJECT_MAP(g_ObjectMap)
    OBJECT_ENTRY(CLSID_Connect, CConnect)
    OBJECT_ENTRY(CLSID_LogViewer, CLogViewer)
    OBJECT_ENTRY(CLSID_TestSettingsCtrl, CTestSettingsCtrl)
    OBJECT_ENTRY(CLSID_AVOptions, CAppVerifierOptions)
END_OBJECT_MAP()

// DLL Entry Point
extern "C" BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/)
{   
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:

        g_hInstance = hInstance;
        // Create our heap
        g_hHeap = HeapCreate(0,0,0);
        if (g_hHeap == NULL)
        {
            return FALSE;
        }

        // Initialize the ATL module
        _Module.Init(g_ObjectMap, hInstance, &LIBID_AppVerifierLib);

        g_psTests = new std::set<CTestInfo*, CompareTests>;

        // Prevent thread attach/detach messages
        DisableThreadLibraryCalls(hInstance);
        break;

    case DLL_PROCESS_DETACH:        
        g_aAppInfo.clear();
        g_aAppInfo.resize(0);

        // Ugly, force call to destructor.
        // This is because we delete the heap here, but the C Run-time destroys
        // all the objects after this point, which uses the heap.
        g_aAppInfo.CAVAppInfoArray::~CAVAppInfoArray();
        g_aTestInfo.clear();
        g_aTestInfo.resize(0);
        g_aTestInfo.CTestInfoArray::~CTestInfoArray();
        g_arrSessionLog.clear();
        g_arrSessionLog.resize(0);
        g_arrSessionLog.CSessionLogEntryArray::~CSessionLogEntryArray();
        delete g_psTests;

        // Shutdown ATL module
        _Module.Term();

        // Delete our heap.
        if (g_hHeap)
        {
            HeapDestroy(g_hHeap);
        }

        break;
    }
    return TRUE;
}


// Used to determine whether the DLL can be unloaded by OLE
STDAPI
DllCanUnloadNow()
{
    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv );
}

// DllRegisterServer - Adds entries to the system registry
STDAPI
DllRegisterServer()
{    
    return _Module.RegisterServer(TRUE);
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI
DllUnregisterServer()
{
    return _Module.UnregisterServer();	
}

// Overloaded new and deletes to go through our allocator.
void* __cdecl
operator new(
    size_t size)
{
    assert(g_hHeap);

    return HeapAlloc(g_hHeap, 0, size);
}

void __cdecl
operator delete(
    void* pv)
{
    assert(g_hHeap);
    HeapFree(g_hHeap, 0, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\avoptions.cpp ===
// AVOptions.cpp : Implementation of CAppVerifierOptions
#include "precomp.h"
#include "avoptions.h"
#include <commctrl.h>
#include <cassert>

extern BOOL g_bBreakOnLog;
extern BOOL g_bFullPageHeap;
extern BOOL g_bPropagateTests;
extern wstring g_wstrExeName;

BOOL
CALLBACK
CAppVerifierOptions::DlgViewOptions(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {

        case PSN_APPLY:
            ::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            break;

        case PSN_QUERYCANCEL:
            return FALSE;
        }
    }

    return FALSE;
}

void
CAppVerifierOptions::CreatePropertySheet(
    HWND hWndParent
    )
{
    CTestInfo*      pTest;
    DWORD           dwPages = 1;
    DWORD           dwPage = 0;

    LPCWSTR szExe = g_wstrExeName.c_str();

    //
    // count the number of pages
    //
    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->PropSheetPage.pfnDlgProc) {
            dwPages++;
        }
    }

    m_phPages = new HPROPSHEETPAGE[dwPages];
    if (!m_phPages) {
        return;
    }

    //
    // init the global page
    //
    m_PageGlobal.dwSize         = sizeof(PROPSHEETPAGE);
    m_PageGlobal.dwFlags        = PSP_USETITLE;
    m_PageGlobal.hInstance      = g_hInstance;
    m_PageGlobal.pszTemplate    = MAKEINTRESOURCE(IDD_AV_OPTIONS);
    m_PageGlobal.pfnDlgProc     = DlgViewOptions;
    m_PageGlobal.pszTitle       = MAKEINTRESOURCE(IDS_GLOBAL_OPTIONS);
    m_PageGlobal.lParam         = 0;
    m_PageGlobal.pfnCallback    = NULL;
    m_phPages[0]                = CreatePropertySheetPage(&m_PageGlobal);

    if (!m_phPages[0]) {
        //
        // we need the global page minimum
        //
        return;
    }

    //
    // add the pages for the various tests
    //
    dwPage = 1;
    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->PropSheetPage.pfnDlgProc) {

            //
            // we use the lParam to identify the exe involved
            //
            pTest->PropSheetPage.lParam = (LPARAM)szExe;

            m_phPages[dwPage] = CreatePropertySheetPage(&(pTest->PropSheetPage));
            if (!m_phPages[dwPage]) {
                dwPages--;
            } else {
                dwPage++;
            }
        }
    }

    //wstring wstrOptions;
    //AVLoadString(IDS_OPTIONS_TITLE, wstrOptions);

    //wstrOptions += L" - ";
    //wstrOptions += szExe;

    m_psh.dwSize      = sizeof(PROPSHEETHEADER);
    m_psh.dwFlags     = PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP;
    m_psh.hwndParent  = hWndParent;
    m_psh.hInstance   = g_hInstance;
    m_psh.pszCaption  = L"Options";
    m_psh.nPages      = dwPages;
    m_psh.nStartPage  = 0;
    m_psh.phpage      = m_phPages;
    m_psh.pfnCallback = NULL;
}

HWND
CAppVerifierOptions::CreateControlWindow(
    HWND  hwndParent,
    RECT& rcPos
    )
{    
    //HWND hwnd =
        //CComCompositeControl<CAppVerifierOptions>::CreateControlWindow(hwndParent, rcPos);

    //
    // Now would be a good time to check all the global options.
    //
    /*if (g_bBreakOnLog) {
        SendMessage(GetDlgItem(IDC_BREAK_ON_LOG), BM_SETCHECK, BST_CHECKED, 0);
    }

    if (g_bFullPageHeap) {
        SendMessage(GetDlgItem(IDC_FULL_PAGEHEAP), BM_SETCHECK, BST_CHECKED, 0);
    }

    if (g_bPropagateTests) {
        SendMessage(GetDlgItem(IDC_PROPAGATE_TESTS_TO_CHILDREN), BM_SETCHECK, BST_CHECKED, 0);
    }*/

    //m_hWndOptionsDlg = hwnd;
    m_hWndParent = hwndParent;

    return NULL;
}

LRESULT
CAppVerifierOptions::OnInitDialog(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    CreatePropertySheet(m_hWndParent);
    
    bHandled = TRUE;

    return 0;
}

LRESULT
CAppVerifierOptions::OnClose(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    bHandled = FALSE;

    return 0;
}

//
// We receive this when the dialog is being displayed.
//
LRESULT
CAppVerifierOptions::OnSetFocus(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    PropertySheet(&m_psh);

    bHandled = TRUE;

    return 0;
}

LRESULT
CAppVerifierOptions::OnItemChecked(
    WORD  wNotifyCode,
    WORD  wID,
    HWND  hWndCtl,
    BOOL& bHandled
    )
{
    bHandled = TRUE;
    BOOL bCheck = (SendMessage(hWndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED) ? TRUE : FALSE;
    
    switch (wID) {
    case IDC_BREAK_ON_LOG:
        g_bBreakOnLog = bCheck;
        break;

    case IDC_FULL_PAGEHEAP:
        g_bFullPageHeap = bCheck;
        break;

    case IDC_PROPAGATE_TESTS_TO_CHILDREN:
        g_bPropagateTests = bCheck;
        break;

    default:
        bHandled = FALSE;
        break;
    }    

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\viewlog.cpp ===
#include "precomp.h"

#include "viewlog.h"

using namespace ShimLib;

CSessionLogEntryArray g_arrSessionLog;

TCHAR   g_szSingleLogFile[MAX_PATH] = _T("");

HWND g_hwndIssues = NULL;
int  g_cWidth;
int  g_cHeight;

HWND g_hwndDetails = NULL;
int  g_cWidthDetails;
int  g_cHeightDetails;

VLOG_LEVEL g_eMinLogLevel = VLOG_LEVEL_WARNING;

CSessionLogEntry *g_pDetailsEntry = NULL;

const int MAX_INSTANCE_REPEAT = 10;

//
// forward function declarations
//
INT_PTR CALLBACK
DlgViewLogDetails(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    );


TCHAR*
fGetLine(
    TCHAR* szLine,
    int    nChars,
    FILE*  file
    )
{
    if (_fgetts(szLine, nChars, file)) {
        int nLen = _tcslen(szLine);
        while (nLen && (szLine[nLen - 1] == _T('\n') || szLine[nLen - 1] == _T('\r'))) {
            szLine[nLen - 1] = 0;
            nLen--;
        }
        return szLine;
    } else {
        return NULL;
    }
}

BOOL
IsModuleInSystem32(
    LPCTSTR szModule
    )
{
    TCHAR szSysDir[MAX_PATH];
    TCHAR szPath[MAX_PATH];

    if (!GetSystemDirectory(szSysDir, MAX_PATH)) {
        return FALSE;
    }

    if (FAILED(StringCchPrintf(szPath,
                               ARRAY_LENGTH(szPath),
                               _T("%s\\%s"),
                               szSysDir,
                               szModule))) {
        return FALSE;
    }

    if (GetFileAttributes(szPath) == INVALID_FILE_ATTRIBUTES) {
        return FALSE;
    }

    return TRUE;

}

BOOL
GetSessionLogEntry(
    HWND    hDlg,
    LPCTSTR szLogFullPath,
    CSessionLogEntryArray& arrEntries
    )
{
    TCHAR szLine[4096];
    FILE * file = NULL;
    SYSTEMTIME stime;
    CSessionLogEntry *pEntryTemp = NULL;
    TCHAR *szBegin = NULL;
    TCHAR *szEnd = NULL;
    BOOL bSuccess = FALSE;

    HWND hTree = GetDlgItem(hDlg, IDC_ISSUES);

    file = _tfopen(szLogFullPath, _T("rt"));

    if (!file) {
        goto out;
    }

    if (fGetLine(szLine, 4096, file)) {

        ZeroMemory(&stime, sizeof(SYSTEMTIME));

        int nFields = _stscanf(szLine, _T("# LOG_BEGIN %hd/%hd/%hd %hd:%hd:%hd"),
                               &stime.wMonth,
                               &stime.wDay,
                               &stime.wYear,
                               &stime.wHour,
                               &stime.wMinute,
                               &stime.wSecond);

        //
        // if we parsed that line properly, then we've got a valid line.
        // Parse it.
        //
        if (nFields != 6) {
            DPF("[GetSessionLogEntry] '%ls' does not appear to be a AppVerifier log file.",
                szLogFullPath);

            goto out;
        }

        {
            CSessionLogEntry EntryTemp;

            EntryTemp.RunTime = stime;
            EntryTemp.strLogPath = szLogFullPath;

            //
            // get the log file and exe path
            //
            szBegin = _tcschr(szLine, _T('\''));
            if (szBegin) {
                szBegin++;
                szEnd = _tcschr(szBegin, _T('\''));
                if (szEnd) {
                    TCHAR szName[MAX_PATH];
                    TCHAR szExt[_MAX_EXT];
                    *szEnd = 0;

                    EntryTemp.strExePath = szBegin;

                    *szEnd = 0;

                    //
                    // split the path and get the name and extension
                    //
                    _tsplitpath(EntryTemp.strExePath.c_str(), NULL, NULL, szName, szExt);

                    EntryTemp.strExeName = szName;
                    EntryTemp.strExeName += szExt;
                }
            }

            arrEntries.push_back(EntryTemp);

            bSuccess = TRUE;
        }
    }

out:

    if (file) {
        fclose(file);
        file = NULL;
    }

    return bSuccess;
}


DWORD
ReadSessionLog(
    HWND hDlg,
    CSessionLogEntryArray& arrEntries
    )
{
    TCHAR szLine[4096];
    FILE * file = NULL;
    SYSTEMTIME stime;
    DWORD dwEntries = 0;
    DWORD cchSize;
    TCHAR *szBegin = NULL;
    TCHAR *szEnd = NULL;

    HWND hTree = GetDlgItem(hDlg, IDC_ISSUES);

    TCHAR szVLog[MAX_PATH];
    TCHAR szLogFullPath[MAX_PATH];

    WIN32_FIND_DATA FindData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    TCHAR szLogSearch[MAX_PATH];

    //
    // BUGBUG -- this is cheesy, but it's the fastest way to make the change
    // to remove session.log. Going forward, we should combine these two functions
    // into one, and switch to vectors instead of linked lists
    //
    cchSize = GetAppVerifierLogPath(szVLog, ARRAY_LENGTH(szVLog));

    if (cchSize > ARRAY_LENGTH(szVLog) || cchSize == 0) {
        return 0;
    }

    StringCchCopy(szLogSearch, ARRAY_LENGTH(szLogSearch), szVLog);
    StringCchCatW(szLogSearch, ARRAY_LENGTH(szLogSearch), _T("\\"));
    StringCchCat(szLogSearch, ARRAY_LENGTH(szLogSearch), _T("*.log"));

    //
    // enumerate all the logs and make entries for them
    //
    hFind = FindFirstFile(szLogSearch, &FindData);
    while (hFind != INVALID_HANDLE_VALUE) {

        //
        // make sure to exclude session.log, in case we're using older shims
        //
        if (_tcsicmp(FindData.cFileName, _T("session.log")) == 0) {
            goto nextFile;
        }

        StringCchCopy(szLogFullPath, ARRAY_LENGTH(szLogFullPath), szVLog);
        StringCchCat(szLogFullPath, ARRAY_LENGTH(szLogFullPath), _T("\\"));
        StringCchCat(szLogFullPath, ARRAY_LENGTH(szLogFullPath), FindData.cFileName);

        BOOL bSuccess = GetSessionLogEntry(hDlg, szLogFullPath, arrEntries);
        if (bSuccess) {
            dwEntries++;
        }

nextFile:

        if (!FindNextFile(hFind, &FindData)) {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    return dwEntries;
}

void
FillTreeView(
    HWND hDlg
    )
{
    HWND hTree = GetDlgItem(hDlg, IDC_ISSUES);
    CProcessLogEntry *pProcessEntry = NULL;

    if (!hTree) {
        return;
    }

    TreeView_DeleteAllItems(hTree);

    for (CSessionLogEntry* pSLogEntry = g_arrSessionLog.begin();
         pSLogEntry != g_arrSessionLog.end();
         pSLogEntry++) {

        //
        // Add it to the tree.
        //
        TVINSERTSTRUCT is;

        WCHAR szItem[256];

        StringCchPrintf(szItem,
                        ARRAY_LENGTH(szItem),
                        L"%ls - %d/%d/%d %d:%02d",
                        pSLogEntry->strExeName.c_str(),
                        pSLogEntry->RunTime.wMonth,
                        pSLogEntry->RunTime.wDay,
                        pSLogEntry->RunTime.wYear,
                        pSLogEntry->RunTime.wHour,
                        pSLogEntry->RunTime.wMinute);

        is.hParent      = TVI_ROOT;
        is.hInsertAfter = TVI_LAST;
        is.item.lParam  = 0;
        is.item.mask    = TVIF_TEXT;
        is.item.pszText = szItem;

        pSLogEntry->hTreeItem = TreeView_InsertItem(hTree, &is);

        //
        // Add it to the tree
        //
        for (pProcessEntry = pSLogEntry->arrProcessLogEntries.begin();
             pProcessEntry != pSLogEntry->arrProcessLogEntries.end();
             pProcessEntry++ ) {

            if (pProcessEntry->dwOccurences > 0 && pProcessEntry->eLevel >= g_eMinLogLevel) {

                is.hParent      = pSLogEntry->hTreeItem;
                is.hInsertAfter = TVI_LAST;
                is.item.lParam  = (LPARAM)pProcessEntry;
                is.item.mask    = TVIF_TEXT | TVIF_PARAM;
                is.item.pszText = (LPWSTR)pProcessEntry->strLogTitle.c_str();

                pProcessEntry->hTreeItem = TreeView_InsertItem(hTree, &is);

                TreeView_SetItemState(hTree,
                                      pProcessEntry->hTreeItem,
                                      INDEXTOSTATEIMAGEMASK(pProcessEntry->eLevel + 1),
                                      TVIS_STATEIMAGEMASK);

                DWORD * pdwInstance;
                DWORD dwInstances = 0;

                for (pdwInstance = pProcessEntry->arrLogInstances.begin();
                     pdwInstance != pProcessEntry->arrLogInstances.end();
                     pdwInstance++ ) {

                    wstring strInstText;
                    WCHAR szTemp[50];

                    CProcessLogInstance *pInstance = &(pSLogEntry->arrProcessLogInstances[*pdwInstance]);

                    //
                    // check to see if we should filter out the logs from system DLLs
                    // Complicated test - we filter system dlls, but not the EXE under test.
                    // Filtering is only performed if we're not in NTDEV internal mode
                    //
                    BOOL bFilterSystem = FALSE;
                    
                    if (!g_bInternalMode &&
                        IsModuleInSystem32(pInstance->strModule.c_str()) &&
                        (_tcsicmp(pInstance->strModule.c_str(), pSLogEntry->strExeName.c_str()) != 0)) {

                        bFilterSystem = TRUE;
                    }

                    if (!pInstance->bDuplicate && pInstance->eLevel >= g_eMinLogLevel && !bFilterSystem) {
                        if (pInstance->strModule != L"?" && pInstance->dwOffset != 0) {
                            StringCchPrintf(szTemp, ARRAY_LENGTH(szTemp), L"(%s:%08X) ", pInstance->strModule.c_str(), pInstance->dwOffset);
                            strInstText += szTemp;
                        }
                        strInstText += pInstance->strText;

                        if (pInstance->dwNumRepeats > 1) {
                            StringCchPrintf(szTemp, ARRAY_LENGTH(szTemp), L" [%dx]", pInstance->dwNumRepeats);
                            strInstText += szTemp;
                        }

                        is.hParent      = pProcessEntry->hTreeItem;
                        is.hInsertAfter = TVI_LAST;
                        is.item.lParam  = 0;
                        is.item.mask    = TVIF_TEXT;
                        is.item.pszText = (LPWSTR)(strInstText.c_str());

                        HTREEITEM hItem = TreeView_InsertItem(hTree, &is);
                        dwInstances++;

                        TreeView_SetItemState(hTree,
                                  hItem,
                                  INDEXTOSTATEIMAGEMASK(pInstance->eLevel + 1),
                                  TVIS_STATEIMAGEMASK);
                    }
                }

                if (dwInstances == 0) {
                    //
                    // we didn't end up adding any children, so delete this entry
                    //
                    TreeView_DeleteItem(hTree, pProcessEntry->hTreeItem);
                    pProcessEntry->hTreeItem = NULL;
                }
            }
        }
    }
}

DWORD
ReadProcessLog(HWND hDlg, CSessionLogEntry* pSLogEntry)
{
    static TCHAR szLine[4096];
    FILE * file = NULL;
    CProcessLogEntry *pProcessEntry = NULL;
    static TCHAR szShimName[4096];
    DWORD dwEntries = 0;
    TCHAR * szTemp = NULL;
    DWORD dwEntry = 0;
    TCHAR *szBegin = NULL;

    HWND hTree = GetDlgItem(hDlg, IDC_ISSUES);

    if (!pSLogEntry) {
        return 0;
    }

    file = _tfopen(pSLogEntry->strLogPath.c_str(), _T("rt"));

    if (!file) {
        return 0;
    }

    //
    // first get the headers
    //
    szTemp = fGetLine(szLine, ARRAY_LENGTH(szLine), file);
    while (szTemp) {

        if (szLine[0] != _T('#')) {
            goto nextLine;
        }

        //
        // relatively simplistic guard against overflow in szShimName in the scanf, below
        //
        if (_tcslen(szLine) >= ARRAY_LENGTH(szShimName)) {
            goto nextLine;
        }

        if (_stscanf(szLine, _T("# LOGENTRY %s %d '"), szShimName, &dwEntry) == 2) {
            if (pProcessEntry) {
                pSLogEntry->arrProcessLogEntries.push_back(*pProcessEntry);

                delete pProcessEntry;
                pProcessEntry = NULL;
                dwEntries++;
            }

            pProcessEntry = new CProcessLogEntry;
            if (!pProcessEntry) {
                goto out;
            }
            pProcessEntry->strShimName = szShimName;
            pProcessEntry->dwLogNum = dwEntry;

            szBegin = _tcschr(szLine, _T('\''));
            if (szBegin) {
                szBegin++;
                pProcessEntry->strLogTitle = szBegin;
            }
        } else if (_tcsncmp(szLine, _T("# DESCRIPTION BEGIN"), 19) == 0) {
            szTemp = fGetLine(szLine, 4096, file);
            while (szTemp) {
                if (_tcsncmp(szLine, _T("# DESCRIPTION END"), 17) == 0) {
                    break;
                }
                if (pProcessEntry) {

                    //
                    // throw in a carriage return if necessary
                    //
                    if (pProcessEntry->strLogDescription.size()) {
                        pProcessEntry->strLogDescription += _T("\n");
                    }
                    pProcessEntry->strLogDescription += szLine;
                }
                szTemp = fGetLine(szLine, 4096, file);
            }
        } else if (_tcsncmp(szLine, _T("# URL '"), 7) == 0) {
            szBegin = _tcschr(szLine, _T('\''));
            if (szBegin) {
                szBegin++;
                pProcessEntry->strLogURL = szBegin;
            }
        }

nextLine:
        szTemp = fGetLine(szLine, ARRAY_LENGTH(szLine), file);

    }

    //
    // if we've still got an entry in process, save it
    //
    if (pProcessEntry) {
        pSLogEntry->arrProcessLogEntries.push_back(*pProcessEntry);

        delete pProcessEntry;
        pProcessEntry = NULL;

        dwEntries++;
    }

    //
    // go back to the beginning and read the log lines
    //
    if (fseek(file, 0, SEEK_SET) != 0) {
        return 0;
    }

    szTemp = fGetLine(szLine, ARRAY_LENGTH(szLine), file);

    while (szTemp) {
        CProcessLogEntry *pEntry;
        static TCHAR szName[4096];
        DWORD dwOffset = 0;
        static TCHAR szModule[4096];
        VLOG_LEVEL eLevel = VLOG_LEVEL_ERROR;
        DWORD dwLen;

        StringCchCopyW(szModule, ARRAY_LENGTH(szModule), L"<unknown>");

        if (szLine[0] != _T('|')) {
            goto nextInstance;
        }

        //
        // relatively simplistic guard against overflow in the scanf, below
        //
        dwLen = _tcslen(szLine);
        if (dwLen >= ARRAY_LENGTH(szName) || dwLen >= ARRAY_LENGTH(szModule) ) {
            goto nextLine;
        }

        int nFields = _stscanf(szLine, _T("| %s %d | %d %s %x"), szName, &dwEntry, &eLevel, szModule, &dwOffset);
        if (nFields >= 2) {
            BOOL bFound = FALSE;
            CProcessLogInstance Instance;

            Instance.strModule = szModule;
            Instance.eLevel = eLevel;
            Instance.dwOffset = dwOffset;

            szBegin = _tcschr(szLine, _T('\''));
            if (szBegin) {
                szBegin++;

                Instance.strText = szBegin;
            }

            //
            // Get the associated entry (header) for this log instance
            //
            for (pEntry = pSLogEntry->arrProcessLogEntries.begin();
                 pEntry != pSLogEntry->arrProcessLogEntries.end();
                 pEntry++ ) {

                if (pEntry->strShimName == szName && pEntry->dwLogNum == dwEntry) {
                    bFound = TRUE;

                    break;
                }

            }
            if (!bFound) {
                //
                // no matching log entry found
                //
                DPF("[ReadProcessLog] Mo matching log header found for log instance '%ls'.",
                    Instance.strText.c_str());
                pEntry = NULL;
                goto nextInstance;
            }

            Instance.dwProcessLogEntry = pEntry - pSLogEntry->arrProcessLogEntries.begin();

            //
            // check to see if this is a repeat of a previous entry
            //
            for (CProcessLogInstance *pInstance = pSLogEntry->arrProcessLogInstances.begin();
                 pInstance != pSLogEntry->arrProcessLogInstances.end();
                 pInstance++) {
                if (pInstance->strModule == Instance.strModule &&
                    pInstance->dwOffset == Instance.dwOffset &&
                    pInstance->strText == Instance.strText &&
                    pInstance->dwProcessLogEntry == Instance.dwProcessLogEntry &&
                    pInstance->bDuplicate == FALSE) {

                    //
                    // we won't save more than a certain number of repeats
                    //
                    if (pInstance->dwNumRepeats >= MAX_INSTANCE_REPEAT) {
                        goto nextInstance;
                    }

                    //
                    // it's a match, so count up the repeats on the one we found, and mark
                    // this one duplicate
                    //
                    pInstance->dwNumRepeats++;
                    Instance.bDuplicate = TRUE;

					break;
                }
            }


            //
            // save the instance in the chronological log
            //
            pSLogEntry->arrProcessLogInstances.push_back(Instance);

            //
            // update the cross-pointer in the entry object
            //
            pEntry->arrLogInstances.push_back(pSLogEntry->arrProcessLogInstances.size() - 1);

            //
            // now update the entry object's count of instances
            //
            pEntry->dwOccurences++;

            //
            // update the level
            //
            if (pEntry->eLevel < Instance.eLevel) {
                pEntry->eLevel = Instance.eLevel;
            }
        }

nextInstance:

        szTemp = fGetLine(szLine, ARRAY_LENGTH(szLine), file);

    }

out:
    if (file) {
        fclose(file);
        file = NULL;
    }

    return dwEntries;

}

void
SetLogDialogCaption(HWND hDlg, ULONG ulCaptionID, LPCWSTR szAdditional)
{
    wstring wstrCaption;

    if (AVLoadString(ulCaptionID, wstrCaption)) {
        if (szAdditional) {
            wstrCaption += szAdditional;
        }

        SetWindowText(hDlg, wstrCaption.c_str());
    }
}

void
RefreshLog(HWND hDlg)
{
    TreeView_DeleteAllItems(g_hwndIssues);

    g_arrSessionLog.clear();

    if (g_szSingleLogFile[0]) {
        GetSessionLogEntry(hDlg, g_szSingleLogFile, g_arrSessionLog);
        SetLogDialogCaption(hDlg, IDS_LOG_TITLE_SINGLE, g_szSingleLogFile);
    } else {
        ReadSessionLog(hDlg, g_arrSessionLog);
        SetLogDialogCaption(hDlg, IDS_LOG_TITLE_LOCAL, NULL);
    }

    for (CSessionLogEntry* pEntry = g_arrSessionLog.begin();
         pEntry != g_arrSessionLog.end();
         pEntry++ ) {

        ReadProcessLog(hDlg, pEntry);
    }

    FillTreeView(hDlg);

    EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), FALSE);

}

void
InitListViewDetails(HWND hDlg)
{
    DWORD dwLine;

    static const WCHAR *aszSeverity[3] = {
        L"Info",
        L"Warning",
        L"Error"
    };

    if (!g_pDetailsEntry || !g_hwndDetails) {
        return;
    }

    ListView_SetExtendedListViewStyleEx(g_hwndDetails, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);


    LVCOLUMN  lvc;

    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.cx       = 40;
    lvc.iSubItem = 0;
    lvc.pszText  = L"Line";

    ListView_InsertColumn(g_hwndDetails, 0, &lvc);

    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.cx       = 80;
    lvc.iSubItem = 1;
    lvc.pszText  = L"Module";

    ListView_InsertColumn(g_hwndDetails, 1, &lvc);

    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.cx       = 70;
    lvc.iSubItem = 2;
    lvc.pszText  = L"Offset";

    ListView_InsertColumn(g_hwndDetails, 2, &lvc);

    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.cx       = 70;
    lvc.iSubItem = 3;
    lvc.pszText  = L"Severity";

    ListView_InsertColumn(g_hwndDetails, 3, &lvc);

    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.cx       = 900;
    lvc.iSubItem = 4;
    lvc.pszText  = L"Text";

    ListView_InsertColumn(g_hwndDetails, 4, &lvc);


    CProcessLogInstance* pInstance;

    for (pInstance = g_pDetailsEntry->arrProcessLogInstances.begin(), dwLine = 0;
         pInstance != g_pDetailsEntry->arrProcessLogInstances.end();
         pInstance++, dwLine++ ) {

        WCHAR szTemp[1024];
        LVITEM lvi;

        //
        // if we're in external mode, filter out logs from modules in system32
        //
        if (!g_bInternalMode &&
            IsModuleInSystem32(pInstance->strModule.c_str()) &&
            (_tcsicmp(pInstance->strModule.c_str(), g_pDetailsEntry->strExeName.c_str()) != 0)) {

            dwLine--;

            continue;
        }

        szTemp[0] = 0;

        StringCchPrintf(szTemp, ARRAY_LENGTH(szTemp), L"%04d", dwLine);

        lvi.mask      = LVIF_TEXT | LVIF_PARAM;
        lvi.pszText   = szTemp;
        lvi.lParam    = (LPARAM)pInstance;
        lvi.iItem     = 99999;
        lvi.iSubItem  = 0;

        int nItem = ListView_InsertItem(g_hwndDetails, &lvi);

        if (nItem == -1) {
            DPF("[InitListViewDetails] Couldn't add line %d.",
                dwLine);
            return;
        }

        if (pInstance->strModule != L"?" && pInstance->dwOffset != 0) {
            ListView_SetItemText(g_hwndDetails, nItem, 1, (LPWSTR)pInstance->strModule.c_str());
        }

        if (pInstance->dwOffset != 0) {
            StringCchPrintf(szTemp, ARRAY_LENGTH(szTemp), L"%08X", pInstance->dwOffset);

            ListView_SetItemText(g_hwndDetails, nItem, 2, szTemp);
        }

        if (pInstance->eLevel <= VLOG_LEVEL_ERROR) {
            StringCchCopy(szTemp, ARRAY_LENGTH(szTemp), aszSeverity[pInstance->eLevel]);
        } else {
            StringCchCopy(szTemp, ARRAY_LENGTH(szTemp), L"<unknown>");
        }

        ListView_SetItemText(g_hwndDetails, nItem, 3, szTemp);

        CProcessLogEntry* pEntry = &(g_pDetailsEntry->arrProcessLogEntries[pInstance->dwProcessLogEntry]);

        StringCchPrintf(szTemp,
                        ARRAY_LENGTH(szTemp),
                        L"%s - %s",
                        pEntry->strLogTitle.c_str(),
                        pInstance->strText.c_str());

        ListView_SetItemText(g_hwndDetails, nItem, 4, szTemp);
    }

}


void
HandleSizing(
    HWND hDlg
    )
{
    int  nWidth;
    int  nHeight;
    RECT rDlg;

    HDWP hdwp = BeginDeferWindowPos(0);

    if (!hdwp) {
        return;
    }

    GetWindowRect(hDlg, &rDlg);

    nWidth = rDlg.right - rDlg.left;
    nHeight = rDlg.bottom - rDlg.top;

    int deltaW = nWidth - g_cWidth;
    int deltaH = nHeight - g_cHeight;

    HWND hwnd;
    RECT r;

    hwnd = GetDlgItem(hDlg, IDC_ISSUES);

    GetWindowRect(hwnd, &r);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   0,
                   0,
                   r.right - r.left + deltaW,
                   r.bottom - r.top + deltaH,
                   SWP_NOMOVE | SWP_NOZORDER);

    hwnd = GetDlgItem(hDlg, IDC_SOLUTIONS_STATIC);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top + deltaH,
                   0,
                   0,
                   SWP_NOSIZE | SWP_NOZORDER);

    hwnd = GetDlgItem(hDlg, IDC_ISSUE_DESCRIPTION);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top + deltaH,
                   r.right - r.left + deltaW,
                   r.bottom - r.top,
                   SWP_NOZORDER);

    EndDeferWindowPos(hdwp);

    g_cWidth = nWidth;
    g_cHeight = nHeight;
}

void
HandleSizingDetails(
    HWND hDlg
    )
{
    int  nWidth;
    int  nHeight;
    RECT rDlg;

    HDWP hdwp = BeginDeferWindowPos(0);

    if (!hdwp) {
        return;
    }

    GetWindowRect(hDlg, &rDlg);

    nWidth = rDlg.right - rDlg.left;
    nHeight = rDlg.bottom - rDlg.top;

    int deltaW = nWidth - g_cWidthDetails;
    int deltaH = nHeight - g_cHeightDetails;

    HWND hwnd;
    RECT r;

    hwnd = GetDlgItem(hDlg, IDC_LIST_DETAILS);

    GetWindowRect(hwnd, &r);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   0,
                   0,
                   r.right - r.left + deltaW,
                   r.bottom - r.top + deltaH,
                   SWP_NOMOVE | SWP_NOZORDER);


    EndDeferWindowPos(hdwp);

    g_cWidthDetails = nWidth;
    g_cHeightDetails = nHeight;
}

CSessionLogEntry*
GetSessionLogEntryFromHItem(
    HTREEITEM hItem
    )
{
    for (CSessionLogEntry* pEntry = g_arrSessionLog.begin();
         pEntry != g_arrSessionLog.end();
         pEntry++ ) {

        if (pEntry->hTreeItem == hItem) {
            return pEntry;
        }
    }

    return NULL;
}

void
DeleteAllLogs(
    HWND hDlg
    )
{
    ResetVerifierLog();

    RefreshLog(hDlg);
}

void
ExportSelectedLog(
    HWND hDlg
    )
{
    HTREEITEM hItem = TreeView_GetSelection(g_hwndIssues);
    WCHAR szName[MAX_PATH];
    WCHAR szExt[MAX_PATH];
    wstring wstrName;

    if (hItem == NULL) {
        return;
    }

    CSessionLogEntry* pSession;
    TVITEM            ti;

    //
    // first check if this is a top-level item
    //
    pSession = GetSessionLogEntryFromHItem(hItem);
    if (!pSession) {
        return;
    }

    _wsplitpath(pSession->strLogPath.c_str(), NULL, NULL, szName, szExt);

    wstrName = szName;
    wstrName += szExt;

    WCHAR           wszFilter[] = L"Log files (*.log)\0*.log\0";
    OPENFILENAME    ofn;
    WCHAR           wszAppFullPath[MAX_PATH];
    WCHAR           wszAppShortName[MAX_PATH];
    wstring         wstrTitle;

    if (!AVLoadString(IDS_EXPORT_LOG_TITLE, wstrTitle)) {
        wstrTitle = _T("Export Log");
    }

    StringCchCopy(wszAppFullPath, ARRAY_LENGTH(wszAppFullPath), wstrName.c_str());

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = wszFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = wszAppFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = wszAppShortName;
    ofn.nMaxFileTitle     = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = wstrTitle.c_str();
    ofn.Flags             = OFN_HIDEREADONLY;     // hide the "open read-only" checkbox
    ofn.lpstrDefExt       = _T("log");

    if ( !GetSaveFileName(&ofn) )
    {
        return;
    }


    if (CopyFile(pSession->strLogPath.c_str(), wszAppFullPath, FALSE) == 0) {
        DWORD dwErr = GetLastError();

        AVErrorResourceFormat(IDS_CANT_COPY, dwErr);
    }
}

void
DeleteSelectedLog(
    HWND hDlg
    )
{
    HTREEITEM hItem = TreeView_GetSelection(g_hwndIssues);

    if (hItem == NULL) {
        return;
    }

    CSessionLogEntry* pSession;
    TVITEM            ti;

    //
    // first check if this is a top-level item
    //
    pSession = GetSessionLogEntryFromHItem(hItem);
    if (!pSession) {
        return;
    }

    DeleteFile(pSession->strLogPath.c_str());

    RefreshLog(hDlg);


}

void
OpenSelectedLogDetails(
    HWND hDlg
    )
{
    HTREEITEM hItem = TreeView_GetSelection(g_hwndIssues);

    if (hItem == NULL) {
        return;
    }

    CSessionLogEntry* pSession;
    TVITEM            ti;

    //
    // first check if this is a top-level item
    //
    g_pDetailsEntry = GetSessionLogEntryFromHItem(hItem);
    if (!g_pDetailsEntry) {
        return;
    }

    DialogBox(g_hInstance, (LPCTSTR)IDD_VIEW_LOG_DETAIL, hDlg, DlgViewLogDetails);

    g_pDetailsEntry = NULL;
}

void
SetDescriptionText(
    HWND                hDlg,
    CProcessLogEntry*   pEntry
    )
{
    wstring strText;

    if (pEntry) {
        strText = pEntry->strLogDescription;
        if (pEntry->strLogURL.size()) {
            wstring strIntro, strLink;

            if (AVLoadString(IDS_URL_INTRO, strIntro) && AVLoadString(IDS_URL_LINK, strLink)) {
                strText += L" " + strIntro + L" <A HREF=\"" + pEntry->strLogURL + L"\">" + strLink + L"</A>";
            }
        }
    }

    if (strText.size() == 0) {
        AVLoadString(IDS_SOLUTION_DEFAULT, strText);
    }

    SetDlgItemText(hDlg, IDC_ISSUE_DESCRIPTION, strText.c_str());
}

void
HandleSelectionChanged(
    HWND      hDlg,
    HTREEITEM hItem
    )
{
    CProcessLogEntry*   pEntry = NULL;
    CSessionLogEntry*   pSession = NULL;
    TVITEM              ti;
    wstring             strText;

    if (!hDlg) {
        return;
    }
    if (!hItem) {
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_VIEW_DETAILS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_EXPORT_LOG), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), FALSE);
        goto out;
    }

    //
    // first check if this is a top-level item
    //
    pSession = GetSessionLogEntryFromHItem(hItem);
    if (pSession) {
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_VIEW_DETAILS), TRUE);
        if (!g_szSingleLogFile[0]) {
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_EXPORT_LOG), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), TRUE);
        } else {
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_EXPORT_LOG), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), FALSE);
        }
    } else {
        EnableWindow(GetDlgItem(hDlg, IDC_BTN_VIEW_DETAILS), FALSE);
    }


    ti.mask  = TVIF_HANDLE | TVIF_PARAM;
    ti.hItem = hItem;

    TreeView_GetItem(g_hwndIssues, &ti);

    if (ti.lParam == 0) {

        hItem = TreeView_GetParent(g_hwndIssues, hItem);

        ti.mask  = TVIF_HANDLE | TVIF_PARAM;
        ti.hItem = hItem;

        TreeView_GetItem(g_hwndIssues, &ti);

        if (ti.lParam == 0) {
            goto out;
        }
    }

    pEntry = (CProcessLogEntry*)ti.lParam;

out:

    SetDescriptionText(hDlg, pEntry);
}

// Message handler for log view dialog.
INT_PTR CALLBACK
DlgViewLog(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HDC hDC;

    switch (message) {
    case WM_INITDIALOG:
        {
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_LOG), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_EXPORT_LOG), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BTN_VIEW_DETAILS), FALSE);

            if (g_eMinLogLevel == VLOG_LEVEL_INFO) {
                CheckRadioButton(hDlg, IDC_SHOW_ALL, IDC_SHOW_ERRORS, IDC_SHOW_ALL);
            } else {
                CheckRadioButton(hDlg, IDC_SHOW_ALL, IDC_SHOW_ERRORS, IDC_SHOW_ERRORS);
            }

            if (g_szSingleLogFile[0]) {
                EnableWindow(GetDlgItem(hDlg, IDC_BTN_DELETE_ALL), FALSE);
            }

            g_hwndIssues = GetDlgItem(hDlg, IDC_ISSUES);

            HIMAGELIST hImage = ImageList_LoadImage(g_hInstance,
                                                    MAKEINTRESOURCE(IDB_BULLETS),
                                                    16,
                                                    0,
                                                    CLR_DEFAULT,
                                                    IMAGE_BITMAP,
                                                    LR_LOADTRANSPARENT);

            if (hImage != NULL) {
                TreeView_SetImageList(g_hwndIssues,
                                      hImage,
                                      TVSIL_STATE);
            }

            RECT r;

            GetWindowRect(hDlg, &r);

            g_cWidth = r.right - r.left;
            g_cHeight = r.bottom - r.top;

            RefreshLog(hDlg);

            return TRUE;
        }
        break;

    case WM_SIZE:
        HandleSizing(hDlg);
        break;

    case WM_GETMINMAXINFO:
        {
            MINMAXINFO* pmmi = (MINMAXINFO*)lParam;

            pmmi->ptMinTrackSize.y = 300;

            return 0;
            break;
        }

    case WM_NOTIFY:
        if (wParam == IDC_ISSUES) {

            LPNMHDR pnm = (LPNMHDR)lParam;

            if (g_hwndIssues == NULL) {
                break;
            }

            switch (pnm->code) {
            case NM_CLICK:
                {
                    TVHITTESTINFO ht;
                    HTREEITEM     hItem;

                    GetCursorPos(&ht.pt);

                    ScreenToClient(g_hwndIssues, &ht.pt);

                    TreeView_HitTest(g_hwndIssues, &ht);

                    HandleSelectionChanged(hDlg, ht.hItem);
                    break;
                }
            case TVN_SELCHANGED:
                {
                    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pnm;

                    HandleSelectionChanged(hDlg, pnmtv->itemNew.hItem);
                    break;
                }
            }
        } else if (wParam == IDC_ISSUE_DESCRIPTION) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            if (g_hwndIssues == NULL) {
                break;
            }

            switch (pnm->code) {
            case NM_CLICK:
                {
                    SHELLEXECUTEINFO sei = { 0};

                    HTREEITEM hItem = TreeView_GetSelection(g_hwndIssues);

                    if (hItem == NULL) {
                        break;
                    }

                    CProcessLogEntry* pEntry = NULL;
                    TVITEM            ti;

                    ti.mask  = TVIF_HANDLE | TVIF_PARAM;
                    ti.hItem = hItem;

                    TreeView_GetItem(g_hwndIssues, &ti);

                    if (ti.lParam == 0) {
                        hItem = TreeView_GetParent(g_hwndIssues, hItem);

                        ti.mask  = TVIF_HANDLE | TVIF_PARAM;
                        ti.hItem = hItem;

                        TreeView_GetItem(g_hwndIssues, &ti);

                        if (ti.lParam == 0) {
                            break;
                        }
                    }

                    pEntry = (CProcessLogEntry*)ti.lParam;

                    SetDescriptionText(hDlg, pEntry);

                    if (pEntry) {
                        sei.cbSize = sizeof(SHELLEXECUTEINFO);
                        sei.fMask  = SEE_MASK_DOENVSUBST;
                        sei.hwnd   = hDlg;
                        sei.nShow  = SW_SHOWNORMAL;
                        sei.lpFile = (LPWSTR)(pEntry->strLogURL.c_str());

                        ShellExecuteEx(&sei);
                    }
                }
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDC_SHOW_ERRORS:
            g_eMinLogLevel = VLOG_LEVEL_WARNING;
            FillTreeView(hDlg);
            break;

        case IDC_SHOW_ALL:
            g_eMinLogLevel = VLOG_LEVEL_INFO;
            FillTreeView(hDlg);
            break;

        case IDC_BTN_DELETE_LOG:
            DeleteSelectedLog(hDlg);
            break;

        case IDC_BTN_DELETE_ALL:
            DeleteAllLogs(hDlg);
            break;

        case IDC_BTN_EXPORT_LOG:
            ExportSelectedLog(hDlg);
            break;

        case IDC_BTN_VIEW_DETAILS:
            OpenSelectedLogDetails(hDlg);
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
            break;
        }
        break;

    }
    return FALSE;
}

int CALLBACK
DetailsCompareFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    WCHAR szTemp1[256], szTemp2[256];

    szTemp1[0] = 0;
    szTemp2[0] = 0;

    ListView_GetItemText(g_hwndDetails, lParam1, lParamSort, szTemp1, ARRAY_LENGTH(szTemp1));
    ListView_GetItemText(g_hwndDetails, lParam2, lParamSort, szTemp2, ARRAY_LENGTH(szTemp2));

    return _wcsicmp(szTemp1, szTemp2);
}

// Message handler for details log view dialog.
INT_PTR CALLBACK
DlgViewLogDetails(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HDC hDC;

    switch (message) {
    case WM_INITDIALOG:
        {
            g_hwndDetails = GetDlgItem(hDlg, IDC_LIST_DETAILS);

            RECT r;

            GetWindowRect(hDlg, &r);

            g_cWidthDetails = r.right - r.left;
            g_cHeightDetails = r.bottom - r.top;

            InitListViewDetails(hDlg);

            return TRUE;
        }
        break;

    case WM_SIZE:
        HandleSizingDetails(hDlg);
        break;

    case WM_GETMINMAXINFO:
        {
            MINMAXINFO* pmmi = (MINMAXINFO*)lParam;

            pmmi->ptMinTrackSize.y = 300;

            return 0;
            break;
        }

    case WM_NOTIFY:
        if (wParam == IDC_LIST_DETAILS) {

            LPNMHDR pnm = (LPNMHDR)lParam;

            if (g_hwndIssues == NULL) {
                break;
            }

            switch (pnm->code) {
            case LVN_COLUMNCLICK:
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;

                    ListView_SortItemsEx(g_hwndDetails, DetailsCompareFunc, pnmv->iSubItem);
                    break;
                }
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
            break;
        }
        break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\userdump.cpp ===
#include "precomp.h"

#include <crash.h>

#include "Debugger.h"
#include "UserDumpp.h"

#define MEM_SIZE (64*1024)


//
// Private data structure used for communcating
// crash dump data to the callback function.
//
typedef struct _CRASH_DUMP_INFO
{
    PPROCESS_INFO               pProcess;
    EXCEPTION_DEBUG_INFO*       ExceptionInfo;
    DWORD                       MemoryCount;
    DWORD_PTR                   Address;
    PUCHAR                      MemoryData;
    MEMORY_BASIC_INFORMATION    mbi;
    SIZE_T                      MbiOffset;
    SIZE_T                      MbiRemaining;
    PTHREAD_INFO                pCurrentThread;
    IMAGEHLP_MODULE             mi;
    PCRASH_MODULE               CrashModule;
} CRASH_DUMP_INFO, *PCRASH_DUMP_INFO;

//
// Local function prototypes
//

DWORD_PTR GetTeb( HANDLE hThread )
{
    NTSTATUS                   Status;
    THREAD_BASIC_INFORMATION   ThreadBasicInfo;
    DWORD_PTR                  Address = 0;

    Status = NtQueryInformationThread( hThread,
                                       ThreadBasicInformation,
                                       &ThreadBasicInfo,
                                       sizeof( ThreadBasicInfo ),
                                       NULL );
    if ( NT_SUCCESS(Status) )
    {
        Address = (DWORD_PTR)ThreadBasicInfo.TebBaseAddress;
    }

    return Address;
}



BOOL
CrashDumpCallback(
    IN     DWORD   DataType,        // requested data type
    OUT    PVOID*  DumpData,        // pointer to a pointer to the data
    OUT    LPDWORD DumpDataLength,  // pointer to the data length
    IN OUT PVOID   cdi              // private data
    )
/*++
    Return: TRUE on success, FALSE otherwise.
    
    Desc:   This function is the callback used by crashlib.
            Its purpose is to provide data to CreateUserDump()
            for writting to the crashdump file.
--*/

{
    PCRASH_DUMP_INFO CrashdumpInfo = (PCRASH_DUMP_INFO)cdi;

    switch ( DataType )
    {
    case DMP_DEBUG_EVENT:
        *DumpData = &CrashdumpInfo->pProcess->DebugEvent;
        *DumpDataLength = sizeof(DEBUG_EVENT);
        break;

    case DMP_THREAD_STATE:
        {
            static CRASH_THREAD CrashThread;
            PTHREAD_INFO        pCurrentThread;

            *DumpData = &CrashThread;

            if ( CrashdumpInfo->pCurrentThread == NULL )
            {
                pCurrentThread = CrashdumpInfo->pProcess->pFirstThreadInfo;
            }
            else
            {
                pCurrentThread = CrashdumpInfo->pCurrentThread->pNext;
            }

            CrashdumpInfo->pCurrentThread = pCurrentThread;

            if ( pCurrentThread == NULL )
            {
                return FALSE;
            }

            ZeroMemory(&CrashThread, sizeof(CrashThread));

            CrashThread.ThreadId = pCurrentThread->dwThreadId;
            CrashThread.SuspendCount = SuspendThread(pCurrentThread->hThread);

            if ( CrashThread.SuspendCount != (DWORD)-1 )
            {
                ResumeThread(pCurrentThread->hThread);
            }

            CrashThread.PriorityClass = GetPriorityClass(CrashdumpInfo->pProcess->hProcess);
            CrashThread.Priority = GetThreadPriority(pCurrentThread->hThread);
            CrashThread.Teb = GetTeb(pCurrentThread->hThread);

            *DumpDataLength = sizeof(CRASH_THREAD);
            break;
        }

    case DMP_MEMORY_BASIC_INFORMATION:
        while ( TRUE )
        {
            CrashdumpInfo->Address += CrashdumpInfo->mbi.RegionSize;

            if ( !VirtualQueryEx(CrashdumpInfo->pProcess->hProcess,
                                 (LPVOID)CrashdumpInfo->Address,
                                 &CrashdumpInfo->mbi,
                                 sizeof(MEMORY_BASIC_INFORMATION)) )
            {
                return FALSE;
            }

            if ( (CrashdumpInfo->mbi.Protect & PAGE_GUARD) ||
                 (CrashdumpInfo->mbi.Protect & PAGE_NOACCESS) )
            {
                continue;
            }

            if ( (CrashdumpInfo->mbi.State & MEM_FREE) ||
                 (CrashdumpInfo->mbi.State & MEM_RESERVE) )
            {
                continue;
            }

            break;
        }

        *DumpData = &CrashdumpInfo->mbi;
        *DumpDataLength = sizeof(MEMORY_BASIC_INFORMATION);
        break;

    case DMP_THREAD_CONTEXT:
        {
            PTHREAD_INFO pCurrentThread;

            if ( CrashdumpInfo->pCurrentThread == NULL )
            {
                pCurrentThread = CrashdumpInfo->pProcess->pFirstThreadInfo;
            }
            else
            {
                pCurrentThread = CrashdumpInfo->pCurrentThread->pNext;
            }

            CrashdumpInfo->pCurrentThread = pCurrentThread;

            if ( pCurrentThread == NULL )
            {
                return FALSE;
            }

            *DumpData = &CrashdumpInfo->pCurrentThread->Context;
            *DumpDataLength = sizeof(CONTEXT);
            break;
        }

    case DMP_MODULE:
        if ( CrashdumpInfo->mi.BaseOfImage == 0 )
        {
            return FALSE;
        }

        CrashdumpInfo->CrashModule->BaseOfImage = CrashdumpInfo->mi.BaseOfImage;
        CrashdumpInfo->CrashModule->SizeOfImage = CrashdumpInfo->mi.ImageSize;
        CrashdumpInfo->CrashModule->ImageNameLength = strlen(CrashdumpInfo->mi.ImageName) + 1;
        strcpy( CrashdumpInfo->CrashModule->ImageName, CrashdumpInfo->mi.ImageName );

        *DumpData = CrashdumpInfo->CrashModule;
        *DumpDataLength = sizeof(CRASH_MODULE) + CrashdumpInfo->CrashModule->ImageNameLength;

        if ( !SymGetModuleInfo(CrashdumpInfo->pProcess->hProcess,
                               (DWORD_PTR)-1,
                               &CrashdumpInfo->mi) )
        {
            CrashdumpInfo->mi.BaseOfImage = 0;
        }
        break;

    case DMP_MEMORY_DATA:
        if ( !CrashdumpInfo->MemoryCount )
        {

            CrashdumpInfo->Address = 0;
            CrashdumpInfo->MbiOffset = 0;
            CrashdumpInfo->MbiRemaining = 0;

            ZeroMemory( &CrashdumpInfo->mbi, sizeof(MEMORY_BASIC_INFORMATION) );

            CrashdumpInfo->MemoryData = (PUCHAR)VirtualAlloc(NULL,
                                                             MEM_SIZE,
                                                             MEM_COMMIT,
                                                             PAGE_READWRITE);
        }

        if ( !CrashdumpInfo->MbiRemaining )
        {
            while ( TRUE )
            {
                CrashdumpInfo->Address += CrashdumpInfo->mbi.RegionSize;

                if ( !VirtualQueryEx(CrashdumpInfo->pProcess->hProcess,
                                     (LPVOID)CrashdumpInfo->Address,
                                     &CrashdumpInfo->mbi,
                                     sizeof(MEMORY_BASIC_INFORMATION)) )
                {

                    if ( CrashdumpInfo->MemoryData )
                    {
                        VirtualFree(CrashdumpInfo->MemoryData, MEM_SIZE, MEM_RELEASE);
                    }

                    return FALSE;
                }

                if ( (CrashdumpInfo->mbi.Protect & PAGE_GUARD) ||
                     (CrashdumpInfo->mbi.Protect & PAGE_NOACCESS) )
                {
                    continue;
                }

                if ( (CrashdumpInfo->mbi.State & MEM_FREE) ||
                     (CrashdumpInfo->mbi.State & MEM_RESERVE) )
                {
                    continue;
                }

                CrashdumpInfo->MbiOffset = 0;
                CrashdumpInfo->MbiRemaining = CrashdumpInfo->mbi.RegionSize;
                CrashdumpInfo->MemoryCount += 1;
                break;
            }
        }

        *DumpDataLength = (DWORD)__min( CrashdumpInfo->MbiRemaining, MEM_SIZE );
        CrashdumpInfo->MbiRemaining -= *DumpDataLength;

        ReadProcessMemory(CrashdumpInfo->pProcess->hProcess,
                          (PUCHAR)((DWORD_PTR)CrashdumpInfo->mbi.BaseAddress + CrashdumpInfo->MbiOffset),
                          CrashdumpInfo->MemoryData,
                          *DumpDataLength,
                          NULL);

        *DumpData = CrashdumpInfo->MemoryData;
        CrashdumpInfo->MbiOffset += *DumpDataLength;
        break;
    }

    return TRUE;
}

BOOL
CreateUserDump(
    IN  LPTSTR                             pszFileName,
    IN  PDBGHELP_CREATE_USER_DUMP_CALLBACK DmpCallback,
    IN  PVOID                              lpv
    )

/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Creates the dump file.
--*/
{
#if 0
    OSVERSIONINFOW              OsVersion = {0};
    USERMODE_CRASHDUMP_HEADER   DumpHeader = {0};
    DWORD                       cb;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    BOOL                        rval;
    PVOID                       DumpData;
    DWORD                       DumpDataLength;
    SECURITY_ATTRIBUTES         SecAttrib;
    SECURITY_DESCRIPTOR         SecDescript;

    //
    // Create a DACL that allows all access to the directory.
    //
    SecAttrib.nLength               = sizeof(SECURITY_ATTRIBUTES);
    SecAttrib.lpSecurityDescriptor  = &SecDescript;
    SecAttrib.bInheritHandle        = FALSE;

    InitializeSecurityDescriptor(&SecDescript, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SecDescript, TRUE, NULL, FALSE);

    hFile = CreateFile(pszFileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       &SecAttrib,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    //
    // Write out an empty header.
    //
    if ( !WriteFile(hFile, &DumpHeader, sizeof(DumpHeader), &cb, NULL) )
    {
        goto bad_file;
    }

    //
    // Write the debug event.
    //
    DumpHeader.DebugEventOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    DmpCallback(DMP_DEBUG_EVENT, &DumpData, &DumpDataLength, lpv);

    if ( !WriteFile(hFile, DumpData, sizeof(DEBUG_EVENT), &cb, NULL) )
    {
        goto bad_file;
    }

    //
    // Write the memory map.
    //
    DumpHeader.MemoryRegionOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MEMORY_BASIC_INFORMATION,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            DumpHeader.MemoryRegionCount += 1;

            if ( !WriteFile(hFile, DumpData, sizeof(MEMORY_BASIC_INFORMATION), &cb, NULL) )
            {
                goto bad_file;
            }
        }
    } while ( rval );

    //
    // Write the thread contexts.
    //
    DumpHeader.ThreadOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_THREAD_CONTEXT,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, DumpDataLength, &cb, NULL) )
            {
                goto bad_file;
            }

            DumpHeader.ThreadCount += 1;
        }

    } while ( rval );

    //
    // Write the thread states.
    //
    DumpHeader.ThreadStateOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_THREAD_STATE,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, sizeof(CRASH_THREAD), &cb, NULL) )
            {
                goto bad_file;
            }
        }

    } while ( rval );

    //
    // Write the module table.
    //
    DumpHeader.ModuleOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MODULE,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile,
                            DumpData,
                            sizeof(CRASH_MODULE) + ((PCRASH_MODULE)DumpData)->ImageNameLength,
                            &cb,
                            NULL) )
            {
                goto bad_file;
            }

            DumpHeader.ModuleCount += 1;
        }
    } while ( rval );

    //
    // Write the virtual memory
    //
    DumpHeader.DataOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MEMORY_DATA,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, DumpDataLength, &cb, NULL) )
            {
                goto bad_file;
            }
        }
    } while ( rval );

    //
    // The VersionInfo is optional.
    //
    DumpHeader.VersionInfoOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    //
    // re-write the dump header with some valid data.
    //
    GetVersionEx(&OsVersion);

    DumpHeader.Signature        = USERMODE_CRASHDUMP_SIGNATURE;
    DumpHeader.MajorVersion     = OsVersion.dwMajorVersion;
    DumpHeader.MinorVersion     = OsVersion.dwMinorVersion;

#if defined(_X86_)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_I386;
    DumpHeader.ValidDump        = USERMODE_CRASHDUMP_VALID_DUMP32;

#elif defined(_AMD64_)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_AMD64;
    DumpHeader.ValidDump        = USERMODE_CRASHDUMP_VALID_DUMP64;

#elif defined(_IA64_)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_IA64;
    DumpHeader.ValidDump        = USERMODE_CRASHDUMP_VALID_DUMP64;

#else
#error "No Target Architecture"
#endif

    SetFilePointer(hFile, 0, 0, FILE_BEGIN);

    if ( !WriteFile(hFile, &DumpHeader, sizeof(DumpHeader), &cb, NULL) )
    {
        goto bad_file;
    }

    CloseHandle(hFile);

    return TRUE;

    bad_file:

    CloseHandle(hFile);

    DeleteFile(pszFileName);

#endif
    return FALSE;
}



BOOL
GenerateUserModeDump(
    LPTSTR                  pszFileName,
    PPROCESS_INFO           pProcess,
    LPEXCEPTION_DEBUG_INFO  ed
    )
{
    CRASH_DUMP_INFO CrashdumpInfo = {0};
    BOOL            bRet;
    PTHREAD_INFO    pThread;

    CrashdumpInfo.mi.SizeOfStruct = sizeof(CrashdumpInfo.mi);
    CrashdumpInfo.pProcess        = pProcess;
    CrashdumpInfo.ExceptionInfo   = ed;

    //
    // Get the thread context for all the threads.
    //
    pThread = pProcess->pFirstThreadInfo;

    while ( pThread != NULL )
    {
        pThread->Context.ContextFlags = CONTEXT_FULL;
        GetThreadContext(pThread->hThread, &pThread->Context);
        pThread = pThread->pNext;
    }

    //
    // Get first entry in the module list.
    //
    if ( !SymInitialize(pProcess->hProcess, NULL, FALSE) )
    {
        return FALSE;
    }

    if ( !SymGetModuleInfo(pProcess->hProcess, 0, &CrashdumpInfo.mi) )
    {
        return FALSE;
    }

    CrashdumpInfo.CrashModule = (PCRASH_MODULE)LocalAlloc(LPTR, 4096);

    bRet = CreateUserDump(pszFileName, CrashDumpCallback, &CrashdumpInfo);

    LocalFree(CrashdumpInfo.CrashModule);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\avoptions.h ===
// TestSettingsCtrl.h : Declaration of the CTestSettingsCtrl
#pragma once
#include "resource.h"       // main symbols
#include <atlctl.h>
#include "AddIn.h"

// CTestSettingsCtrl
class ATL_NO_VTABLE CAppVerifierOptions : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IAVOptions, &IID_IAVOptions, &LIBID_AppVerifierLib, /*wMajor =*/ 1, /*wMinor =*/ 0>,
	public IPersistStreamInitImpl<CAppVerifierOptions>,
	public IOleControlImpl<CAppVerifierOptions>,
	public IOleObjectImpl<CAppVerifierOptions>,
	public IOleInPlaceActiveObjectImpl<CAppVerifierOptions>,
	public IViewObjectExImpl<CAppVerifierOptions>,
	public IOleInPlaceObjectWindowlessImpl<CAppVerifierOptions>,
	public CComCoClass<CAppVerifierOptions, &CLSID_AVOptions>,
	public CComCompositeControl<CAppVerifierOptions>
{

private:
    void CreatePropertySheet(HWND hWndParent);
    
    LRESULT OnSetFocus(
        UINT   uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL&  bHandled
        );

    LRESULT OnClose(
        UINT   uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL&  bHandled
        );

    LRESULT OnInitDialog(
        UINT   uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL&  bHandled
        );
    
    static BOOL CALLBACK DlgViewOptions(
        HWND   hDlg,
        UINT   message,
        WPARAM wParam,
        LPARAM lParam
        );

    HWND            m_hWndParent;
    HWND            m_hWndOptionsDlg;
    BOOL            m_bPropSheetCreated;
    HPROPSHEETPAGE* m_phPages;
	PROPSHEETPAGE   m_PageGlobal;
    PROPSHEETHEADER m_psh;

public:

	CAppVerifierOptions()
	{
        m_bCreated = false;
		m_bWindowOnly = TRUE;
		CalcExtent(m_sizeExtent);
	}

    virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

DECLARE_REGISTRY_RESOURCEID(IDR_AV_OPTIONS)

BEGIN_COM_MAP(CAppVerifierOptions)
	COM_INTERFACE_ENTRY(IAVOptions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CAppVerifierOptions)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()


BEGIN_MSG_MAP(CAppVerifierOptions)
    COMMAND_HANDLER(IDC_CLEAR_LOG_ON_CHANGES, BN_CLICKED, OnItemChecked)
    COMMAND_HANDLER(IDC_BREAK_ON_LOG, BN_CLICKED, OnItemChecked)
    COMMAND_HANDLER(IDC_FULL_PAGEHEAP, BN_CLICKED, OnItemChecked)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_DESTROY, OnClose)

	CHAIN_MSG_MAP(CComCompositeControl<CAppVerifierOptions>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnItemChecked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

BEGIN_SINK_MAP(CAppVerifierOptions)
	//Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		if (dispid == DISPID_AMBIENT_BACKCOLOR)
		{
			SetBackgroundColorFromAmbient();
			FireViewChange();
		}
		return IOleControlImpl<CAppVerifierOptions>::OnAmbientPropertyChange(dispid);
	}
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ITestSettingsCtrl

	enum { IDD = IDD_AV_OPTIONS };

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

    bool m_bCreated;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\connect.h ===
// Connect.h : Declaration of the CConnect

#pragma once
#include "resource.h"       // main symbols

#include <set>

#pragma warning( disable : 4278 )

#include "dte.tlh"

#pragma warning( default : 4278 )

// CConnect
class CConnect : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CConnect, &CLSID_Connect>,
    public IDispatchImpl<EnvDTE::IDTCommandTarget, &EnvDTE::IID_IDTCommandTarget,
        &EnvDTE::LIBID_EnvDTE, 7, 0>,
    public IDispatchImpl<AddInDesignerObjects::_IDTExtensibility2,
        &AddInDesignerObjects::IID__IDTExtensibility2,
        &AddInDesignerObjects::LIBID_AddInDesignerObjects, 1, 0>
{

public:
    CConnect()
	{
	}

private:
    void CreatePropertySheet(HWND hWndParent);
    
    static BOOL CALLBACK DlgViewOptions(
        HWND   hDlg,
        UINT   message,
        WPARAM wParam,
        LPARAM lParam
        );

    HPROPSHEETPAGE* m_phPages;
	PROPSHEETPAGE   m_PageGlobal;
    PROPSHEETHEADER m_psh;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ADDIN)
DECLARE_NOT_AGGREGATABLE(CConnect)


BEGIN_COM_MAP(CConnect)
	COM_INTERFACE_ENTRY(AddInDesignerObjects::IDTExtensibility2)
	COM_INTERFACE_ENTRY(EnvDTE::IDTCommandTarget)
	COM_INTERFACE_ENTRY2(IDispatch, AddInDesignerObjects::IDTExtensibility2)
END_COM_MAP()



	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

public:
	//IDTExtensibility2 implementation:
	STDMETHOD(OnConnection)(IDispatch * Application,
        AddInDesignerObjects::ext_ConnectMode ConnectMode,
        IDispatch *AddInInst, SAFEARRAY **custom);
	STDMETHOD(OnDisconnection)(AddInDesignerObjects::ext_DisconnectMode RemoveMode, SAFEARRAY **custom );
	STDMETHOD(OnAddInsUpdate)(SAFEARRAY **custom );
	STDMETHOD(OnStartupComplete)(SAFEARRAY **custom );
	STDMETHOD(OnBeginShutdown)(SAFEARRAY **custom );
	
	//IDTCommandTarget implementation:
	STDMETHOD(QueryStatus)(BSTR CmdName, EnvDTE::vsCommandStatusTextWanted NeededText,
        EnvDTE::vsCommandStatus *StatusOption, VARIANT *CommandText);
	STDMETHOD(Exec)(BSTR CmdName, EnvDTE::vsCommandExecOption ExecuteOption,
        VARIANT *VariantIn, VARIANT *VariantOut, VARIANT_BOOL *Handled);

private:

    // Event sinks
    class CDTEEventsSink :
        public IDispEventImpl<1, CDTEEventsSink, &__uuidof(EnvDTE::_dispDTEEvents),
        &EnvDTE::LIBID_EnvDTE, 7, 0>
    {
        friend class CConnect;

    private:
        CConnect* m_pParent;
    public:
        CDTEEventsSink()
        {}
        
        BEGIN_SINK_MAP(CDTEEventsSink)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispDTEEvents), 1, OnStartupComplete)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispDTEEvents), 2, OnBeginShutdown)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispDTEEvents), 3, ModeChanged)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispDTEEvents), 4, OnMacrosRuntimeReset)
		END_SINK_MAP()

        void __stdcall OnStartupComplete()
        {
        }

        void __stdcall OnBeginShutdown()
        {            
        }

        void __stdcall ModeChanged(EnvDTE::vsIDEMode LastMode)
        {
            ::MessageBox(NULL, TEXT("Mode changed!"), 
                TEXT("Mode Changed!"), MB_OK);
            if (LastMode == EnvDTE::vsIDEModeDebug)
            {
                ::MessageBox(NULL, TEXT("Mode changed from dbg"), 
                TEXT("Mode Changed!"), MB_OK);
                // Refresh log
                CComPtr<EnvDTE::Window> pWindow;

                pWindow = m_pParent->GetToolWindow(CLSID_LogViewer);
                if (pWindow)
                {
                    CComPtr<IDispatch> pObj;
                    HRESULT hr = pWindow->get_Object(&pObj);
                    if (SUCCEEDED(hr))
                    {
                        CComQIPtr<ILogViewer, &__uuidof(ILogViewer)> pLogViewer;
                        if (pLogViewer)
                        {
                            pLogViewer->Refresh();
                        }
                    }        
                }
            }
        }

        void __stdcall OnMacrosRuntimeReset()
        {
        }
    };

    class CSolutionEventsSink :
        public IDispEventImpl<1, CSolutionEventsSink,
        &__uuidof(EnvDTE::_dispSolutionEvents), &EnvDTE::LIBID_EnvDTE, 7, 0>
    {
        friend class CConnect;
    private:
        CConnect* m_pParent;

    public:
        CSolutionEventsSink()
        {}

        BEGIN_SINK_MAP(CSolutionEventsSink)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispSolutionEvents), 1, Opened)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispSolutionEvents), 2, BeforeClosing)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispSolutionEvents), 3, AfterClosing)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispSolutionEvents), 4, QueryCloseSolution)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispSolutionEvents), 5, Renamed)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispSolutionEvents), 6, ProjectAdded)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispSolutionEvents), 7, ProjectRemoved)
			SINK_ENTRY_EX(1, __uuidof(EnvDTE::_dispSolutionEvents), 8, ProjectRenamed)
        END_SINK_MAP()

        HRESULT __stdcall AfterClosing();
        HRESULT __stdcall BeforeClosing();
        HRESULT __stdcall Opened();
        HRESULT __stdcall ProjectAdded(EnvDTE::Project* proj);        
        HRESULT __stdcall ProjectRemoved(EnvDTE::Project* proj);
        HRESULT __stdcall ProjectRenamed(EnvDTE::Project* proj, BSTR bstrOldName);
        HRESULT __stdcall QueryCloseSolution(VARIANT_BOOL* fCancel);
        HRESULT __stdcall Renamed(BSTR bstrOldName);
    };

    CDTEEventsSink      m_dteEventsSink;
    CSolutionEventsSink m_solutionEventsSink;


	CComPtr<EnvDTE::_DTE>m_pDTE;
	CComPtr<EnvDTE::AddIn>m_pAddInInstance;
    CComPtr<Office::CommandBarControl>m_pEnableControl;
    CComPtr<Office::CommandBarControl>m_pOptionControl;
    CComPtr<Office::CommandBarControl>m_pLogViewControl;
    CComPtr<Office::CommandBarControl>m_pTestsControl;
    
    bool m_bEnabled;
 
    CComPtr<EnvDTE::Window>GetToolWindow(CLSID clsid);
    void CreateToolWindow(const CLSID& clsid);

    void GetNativeVCExecutableNames(EnvDTE::Project* pProject);    

    std::set<std::wstring>m_sExeList;
    BOOL GetAppExeNames();
    BOOL GetAppInfo();  

    void SetEnabledUI();
    void SetDisabledUI();
    void ClearCurrentAppSettings();
    void SetCurrentAppSettings();
    void DisableVerificationBtn();
    void EnableVerificationBtn();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\connect.cpp ===
// Connect.cpp : Implementation of CConnect
#include "precomp.h"
#include "AddIn.h"
#include "Connect.h"
#include "addin_i.c"
#include "testsettingsctrl.h"
#include "avrfutil.h"
#include <assert.h>

using namespace ShimLib;

// Globals needed by AppVerifier
wstring     g_strAppName;
BOOL        gp_bConsoleMode;
BOOL        gp_bWin2KMode;
BOOL        g_bBreakOnLog;
BOOL        g_bFullPageHeap;
BOOL        g_bPropagateTests;

extern BOOL CheckWindowsVersion(void);

//
// Holds the name of the active EXE.
//
wstring     g_wstrExeName;

//
// Indicates if it's okay to run.
//
BOOL g_bCorrectOSVersion = FALSE;

#define AV_OPTION_BREAK_ON_LOG  L"BreakOnLog"
#define AV_OPTION_FULL_PAGEHEAP L"FullPageHeap"
#define AV_OPTION_AV_DEBUGGER   L"UseAVDebugger"
#define AV_OPTION_DEBUGGER      L"Debugger"
#define AV_OPTION_PROPAGATE     L"PropagateTests"

void
pReadOptions(
    void
    )
{
    for (CAVAppInfo *pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); ++pApp) {
        LPCWSTR szExe = pApp->wstrExeName.c_str();

        static const DWORD MAX_DEBUGGER_LEN = 1024;

        WCHAR szDebugger[MAX_DEBUGGER_LEN];

        g_bBreakOnLog = pApp->bBreakOnLog = GetShimSettingDWORD(L"General", szExe, AV_OPTION_BREAK_ON_LOG, FALSE);
        g_bFullPageHeap = pApp->bFullPageHeap = GetShimSettingDWORD(L"General", szExe, AV_OPTION_FULL_PAGEHEAP, FALSE);
        pApp->bUseAVDebugger = TRUE;
        g_bPropagateTests = pApp->bPropagateTests = GetShimSettingDWORD(L"General", szExe, AV_OPTION_PROPAGATE, FALSE);

        pApp->wstrDebugger = L"";
    }
}

HPALETTE CreateDIBPalette(
    LPBITMAPINFO lpbmi,
    LPINT        lpiNumColors
    )
{ 
    LPBITMAPINFOHEADER  lpbi;
    LPLOGPALETTE     lpPal;
    HANDLE           hLogPal;
    HPALETTE         hPal = NULL;
    int              i;

    lpbi = (LPBITMAPINFOHEADER)lpbmi;
    if (lpbi->biBitCount <= 8)
        *lpiNumColors = (1 << lpbi->biBitCount);
    else
        *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

    if (lpbi->biClrUsed > 0)
        *lpiNumColors = lpbi->biClrUsed;  // Use biClrUsed

    if (*lpiNumColors)
    {
        hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * (*lpiNumColors));
        lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
        lpPal->palVersion    = 0x300;
        lpPal->palNumEntries = (WORD)*lpiNumColors;

        for (i = 0;  i < *lpiNumColors;  i++)
        {
            lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
            lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
            lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
            lpPal->palPalEntry[i].peFlags = 0;
        }
        hPal = CreatePalette (lpPal);
        GlobalUnlock (hLogPal);
        GlobalFree   (hLogPal);
    }
    return hPal;
}

HBITMAP LoadResourceBitmap(
    HINSTANCE     hInstance,
    TCHAR*        pszString,
    HPALETTE FAR* lphPalette
    )
{
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;
    HRSRC hRsrc = FindResource(hInstance, pszString, RT_BITMAP);
    if (hRsrc)
    {
        hGlobal = LoadResource(hInstance, hRsrc);
        lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

        hdc = GetDC(NULL);
        *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);
        if (*lphPalette)
        {
            SelectPalette(hdc,*lphPalette,FALSE);
            RealizePalette(hdc);
        }

        hBitmapFinal = CreateDIBitmap(hdc, (LPBITMAPINFOHEADER)lpbi, (LONG)CBM_INIT, (LPSTR)lpbi + lpbi->biSize + iNumColors * sizeof(RGBQUAD), (LPBITMAPINFO)lpbi, DIB_RGB_COLORS );

        ReleaseDC(NULL,hdc);
        UnlockResource(hGlobal);
        FreeResource(hGlobal);
    }
    return (hBitmapFinal);
} 

CComPtr<IPictureDisp>GetPicture(PTSTR szResource)
{
    CComPtr<IPictureDisp> picture;
    
    PICTDESC pictDesc;
    pictDesc.cbSizeofstruct=sizeof(PICTDESC);
    pictDesc.picType=PICTYPE_BITMAP;

    pictDesc.bmp.hbitmap = LoadResourceBitmap(_Module.GetResourceInstance(), szResource, &pictDesc.bmp.hpal);
    OleCreatePictureIndirect(&pictDesc, IID_IPictureDisp, TRUE, (void**)(static_cast<IPictureDisp**>(&picture)));

    return picture;
}

// Called when the add-in is loaded into the environment.
STDMETHODIMP
CConnect::OnConnection(
    IDispatch *pApplication,
    AddInDesignerObjects::ext_ConnectMode ConnectMode,
    IDispatch *pAddInInst,
    SAFEARRAY ** custom
    )
{
    HRESULT                 hr;
    INITCOMMONCONTROLSEX    icc;
    
    // Initialize AppVerifier settings
    g_strAppName                    = L"";
    gp_bConsoleMode                 = FALSE;
    gp_bWin2KMode                   = FALSE;
    g_bBreakOnLog                   = FALSE;
    g_bFullPageHeap                 = FALSE;
    g_bPropagateTests               = FALSE;

    try {
        if (CheckWindowsVersion()) {
            g_bCorrectOSVersion = TRUE;

            //
            // Add our tests to the listview.
            //
            InitTestInfo();
        
            //
            // Load the common control library and set up the link
            // window class.
            //
            icc.dwSize = sizeof(icc);
            icc.dwICC = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES;
            InitCommonControlsEx(&icc);
            LinkWindow_RegisterClass();
        
    
            //
            // Get the development environment instance and our add-in instance.
            //
            hr = pApplication->QueryInterface(__uuidof(EnvDTE::_DTE),
                                              (LPVOID*)&m_pDTE);
            if (FAILED(hr)) {
                return hr;
            }
        
            hr = pAddInInst->QueryInterface(__uuidof(EnvDTE::AddIn),
                                            (LPVOID*)&m_pAddInInstance);
            
            if (FAILED(hr)) {
                return hr;
            }
        
            //
            // OnStartupComplete contains actual connection code.
            //
            if (ConnectMode != AddInDesignerObjects::ext_cm_Startup) {
                return OnStartupComplete(custom);
            }   
        }
    } // try

    catch(HRESULT err) {
        hr = err;
    }

    return hr;
}

//
// Called when the add-in is unloaded from the environment.
//
STDMETHODIMP
CConnect::OnDisconnection(
    AddInDesignerObjects::ext_DisconnectMode /*RemoveMode*/,
    SAFEARRAY ** /*custom*/ )
{   
    m_pDTE.Release();
    m_pAddInInstance.Release();
    m_pEnableControl.Release();
    m_pTestsControl.Release();
    m_pOptionControl.Release();
    m_pLogViewControl.Release();

    return S_OK;
}

//
// Called when there is a change to the add-in's loaded into the environment.
//
STDMETHODIMP
CConnect::OnAddInsUpdate(
    SAFEARRAY ** /*custom*/ )
{
    //
    // We don't care about these changes.
    //
    return S_OK;
}

STDMETHODIMP
CConnect::OnStartupComplete(
    SAFEARRAY ** /*custom*/
    )
/*++
    Return: S_OK on success, or an HRESULT on failure.

    Desc:   This is called when the environment has finished
            loading or by OnConnection() in other instances.
            This is where we add our buttons to the Debug
            toolbar and such.
--*/
{
    HRESULT                             hr = E_FAIL;
    CComPtr<EnvDTE::Commands>           pCommands;
    CComPtr<Office::_CommandBars>       pCommandBars;
    CComPtr<Office::CommandBar>         pDebugBar;
    CComPtr<EnvDTE::Command>            pOptionsCmd;
    CComPtr<EnvDTE::Command>            pTestsCmd;
    CComPtr<EnvDTE::Command>            pEnableCmd;
    CComPtr<EnvDTE::Command>            pLogViewCmd;
    CComPtr<EnvDTE::Events>             pEventSet;
    CComPtr<EnvDTE::_DTEEvents>         pDTEEvents;
    CComPtr<EnvDTE::_SolutionEvents>    pSolutionEvents;
    WCHAR                               wszCommandId[64];
    WCHAR                               wszCommandText[64];
    WCHAR                               wszCommandTooltip[64];

    m_solutionEventsSink.m_pParent = this;
    m_dteEventsSink.m_pParent = this;

    //
    // Read settings in from SDB and registry.
    //
    if (g_bCorrectOSVersion) {
        GetCurrentAppSettings();
        pReadOptions();
    }
    
    try {
        //
        // Get the main menu bars.
        //
        hr = m_pDTE->get_CommandBars(&pCommandBars);
        
        if (FAILED(hr)) {
            throw hr;
        }            

        hr = m_pDTE->get_Commands(&pCommands);
        
        if (FAILED(hr)) {
            throw hr;
        }         

        //
        // Delete existing named commands and menus.
        //
        hr = pCommands->Item(CComVariant(L"AppVerifier.Connect.Enable"),
                             0,
                             &pEnableCmd);
        
        if (SUCCEEDED(hr)) {
            pEnableCmd->Delete();
            pEnableCmd.Release();
        }

        hr = pCommands->Item(CComVariant(L"AppVerifier.Connect.Tests"),
                             0,
                             &pTestsCmd);
        
        if (SUCCEEDED(hr)) {
            pTestsCmd->Delete();
            pTestsCmd.Release();
        }

        hr = pCommands->Item(CComVariant(L"AppVerifier.Connect.Options"),
                             0,
                             &pOptionsCmd);
        
        if (SUCCEEDED(hr)) {
            pOptionsCmd->Delete();
            pOptionsCmd.Release();
        }

        hr = pCommands->Item(CComVariant(L"AppVerifier.Connect.ViewLog"),
                             0,
                             &pLogViewCmd);
        
        if (SUCCEEDED(hr)) {
            pLogViewCmd->Delete();
            pLogViewCmd.Release();
        }

        //
        // Get the 'Debug' toolbar.
        //
        hr = pCommandBars->get_Item(CComVariant(L"Debug"), &pDebugBar);
        
        if (FAILED(hr)) {
            throw hr;
        }

        //
        // Create the commands. These will show as buttons on the 'Debug'
        // toolbar.
        //
        LoadString(g_hInstance,
                   IDS_TB_VERIFICATION_CMD_ID,
                   wszCommandId,
                   ARRAYSIZE(wszCommandId));

        LoadString(g_hInstance,
                   IDS_TB_VERIFICATION_CMD_TEXT,
                   wszCommandText,
                   ARRAYSIZE(wszCommandText));

        LoadString(g_hInstance,
                   IDS_TB_VERIFICATION_CMD_TOOLTIP,
                   wszCommandTooltip,
                   ARRAYSIZE(wszCommandTooltip));

        //
        // First one is 'Verification Off'.
        //
        hr = pCommands->AddNamedCommand(
            m_pAddInInstance,
            CComBSTR(wszCommandId),
            CComBSTR(wszCommandText),
            CComBSTR(wszCommandTooltip),
            VARIANT_TRUE,
            0,
            NULL,
            EnvDTE::vsCommandStatusSupported|EnvDTE::vsCommandStatusEnabled,
            &pEnableCmd);

        //
        // Add the bitmap for this button including the mask associated
        // with it.
        //
        if (SUCCEEDED(hr)) {
            hr = pEnableCmd->AddControl(pDebugBar, 1, &m_pEnableControl);

            if (FAILED(hr)) {
                throw hr;
            }

            CComQIPtr<Office::_CommandBarButton,
                &_uuidof(Office::_CommandBarButton)>pButton(m_pEnableControl);

            CComPtr<IPictureDisp>picture = GetPicture(MAKEINTRESOURCE(IDB_ENABLED));

            if (pButton && picture) {
                pButton->put_Picture(picture);

                CComPtr<IPictureDisp>pictureMask = GetPicture(MAKEINTRESOURCE(IDB_ENABLED_MASK));
                
                if (pictureMask) {
                    pButton->put_Mask(pictureMask);
                }
            }
        }

        //
        // Second one is 'Tests'.
        //
        LoadString(g_hInstance,
                   IDS_TB_TESTS_CMD_ID,
                   wszCommandId,
                   ARRAYSIZE(wszCommandId));

        LoadString(g_hInstance,
                   IDS_TB_TESTS_CMD_TEXT,
                   wszCommandText,
                   ARRAYSIZE(wszCommandText));

        LoadString(g_hInstance,
                   IDS_TB_TESTS_CMD_TOOLTIP,
                   wszCommandTooltip,
                   ARRAYSIZE(wszCommandTooltip));

        hr = pCommands->AddNamedCommand(
            m_pAddInInstance,
            CComBSTR(wszCommandId),
            CComBSTR(wszCommandText),
            CComBSTR(wszCommandTooltip),
            VARIANT_FALSE,
            IDB_TESTSETTINGS_BTN,
            NULL,
            EnvDTE::vsCommandStatusSupported|EnvDTE::vsCommandStatusEnabled,
            &pTestsCmd);
        
        if (SUCCEEDED(hr)) {
            //
            // Add a button to the app verifier menu.
            //
            hr = pTestsCmd->AddControl(pDebugBar, 2, &m_pTestsControl);
            
            if (FAILED(hr)) {
                throw hr;
            }
        }

        //
        // Third one is 'Options'.
        //
        LoadString(g_hInstance,
                   IDS_TB_OPTIONS_CMD_ID,
                   wszCommandId,
                   ARRAYSIZE(wszCommandId));

        LoadString(g_hInstance,
                   IDS_TB_OPTIONS_CMD_TEXT,
                   wszCommandText,
                   ARRAYSIZE(wszCommandText));

        LoadString(g_hInstance,
                   IDS_TB_OPTIONS_CMD_TOOLTIP,
                   wszCommandTooltip,
                   ARRAYSIZE(wszCommandTooltip));

        hr = pCommands->AddNamedCommand(
            m_pAddInInstance,
            CComBSTR(wszCommandId),
            CComBSTR(wszCommandText),
            CComBSTR(wszCommandTooltip),
            VARIANT_FALSE,
            IDB_OPTIONS_BTN,
            NULL,
            EnvDTE::vsCommandStatusSupported|EnvDTE::vsCommandStatusEnabled,
            &pOptionsCmd);

        if (SUCCEEDED(hr)) {
            //
            // Add a button to the app verifier menu.
            //
            hr = pOptionsCmd->AddControl(pDebugBar, 3, &m_pOptionControl);
            
            if (FAILED(hr)) {
                throw hr;
            }
        }

        //
        // Fourth one is 'View Log.'
        //
        LoadString(g_hInstance,
                   IDS_TB_VIEWLOG_CMD_ID,
                   wszCommandId,
                   ARRAYSIZE(wszCommandId));

        LoadString(g_hInstance,
                   IDS_TB_VIEWLOG_CMD_TEXT,
                   wszCommandText,
                   ARRAYSIZE(wszCommandText));

        LoadString(g_hInstance,
                   IDS_TB_VIEWLOG_CMD_TOOLTIP,
                   wszCommandTooltip,
                   ARRAYSIZE(wszCommandTooltip));

        hr = pCommands->AddNamedCommand(
            m_pAddInInstance,
            CComBSTR(wszCommandId),
            CComBSTR(wszCommandText),
            CComBSTR(wszCommandTooltip),
            VARIANT_FALSE,
            IDB_VIEWLOG_BTN,
            NULL,
            EnvDTE::vsCommandStatusSupported|EnvDTE::vsCommandStatusEnabled,
            &pLogViewCmd);

        if (SUCCEEDED(hr)) {
            //
            // Add a button to the app verifier menu.
            //
            hr = pLogViewCmd->AddControl(pDebugBar, 4, &m_pLogViewControl);
            
            if (FAILED(hr)) {
                throw hr;
            }
        }

        //
        // Hookup to environment events.
        //
        hr = m_pDTE->get_Events(&pEventSet);
        
        if (FAILED(hr)) {
            throw hr;
        }

        hr = pEventSet->get_DTEEvents(&pDTEEvents);
        
        if (FAILED(hr)) {
            throw hr;
        }

        hr = m_dteEventsSink.DispEventAdvise((IUnknown*)pDTEEvents.p);
        
        if (FAILED(hr)) {
            throw hr;
        }

        hr = pEventSet->get_SolutionEvents(&pSolutionEvents);
        
        if (FAILED(hr)) {
            throw hr;
        }

        hr = m_solutionEventsSink.DispEventAdvise((IUnknown*)pSolutionEvents.p);
        
        if (FAILED(hr)) {
            throw hr;
        }

        //
        // Setup for current solution.
        //
        m_solutionEventsSink.Opened();

    } // try

    catch(HRESULT err) {
        hr = err;
    }
    
    catch(...) {
        hr = E_FAIL;
    }
    
    return hr;
}

//
// Called when the environment starts to shutdown.
//
STDMETHODIMP
CConnect::OnBeginShutdown(
    SAFEARRAY ** /*custom*/ )
{
    return S_OK;
}

//
// Called when the status of a command is queried.
//
STDMETHODIMP
CConnect::QueryStatus(
    BSTR bstrCmdName,
    EnvDTE::vsCommandStatusTextWanted NeededText,
    EnvDTE::vsCommandStatus *pStatusOption,
    VARIANT * /*pvarCommandText*/)
{
    if (NeededText == EnvDTE::vsCommandStatusTextWantedNone) {
        if ((_wcsicmp(bstrCmdName, L"AppVerifier.Connect.Tests")==0) ||
            (_wcsicmp(bstrCmdName, L"AppVerifier.Connect.Options")==0)) {
            if (m_bEnabled) {
                *pStatusOption = (EnvDTE::vsCommandStatus)
                    (EnvDTE::vsCommandStatusEnabled | EnvDTE::vsCommandStatusSupported);
            } else {
                *pStatusOption = (EnvDTE::vsCommandStatus)
                    (EnvDTE::vsCommandStatusEnabled | EnvDTE::vsCommandStatusSupported);
            }
        }
        else if (_wcsicmp(bstrCmdName, L"AppVerifier.Connect.ViewLog")==0) {
            *pStatusOption = (EnvDTE::vsCommandStatus)
                (EnvDTE::vsCommandStatusEnabled | EnvDTE::vsCommandStatusSupported);
        }
        else if (_wcsicmp(bstrCmdName, L"AppVerifier.Connect.Enable")==0) {
            *pStatusOption = (EnvDTE::vsCommandStatus)
                (EnvDTE::vsCommandStatusEnabled | EnvDTE::vsCommandStatusSupported);
        }
    }

    return S_OK;
}

BOOL
CALLBACK
CConnect::DlgViewOptions(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
    case WM_INITDIALOG:
        if (g_bBreakOnLog) {
            CheckDlgButton(hDlg, IDC_BREAK_ON_LOG, BST_CHECKED);
        }

        if (g_bFullPageHeap) {
            CheckDlgButton(hDlg, IDC_FULL_PAGEHEAP, BST_CHECKED);
        }

        if (g_bPropagateTests) {
            CheckDlgButton(hDlg, IDC_PROPAGATE_TESTS_TO_CHILDREN, BST_CHECKED);
        }

        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_APPLY:
            g_bBreakOnLog     = FALSE;
            g_bFullPageHeap   = FALSE;
            g_bPropagateTests = FALSE;

            //
            // Determine which options the user has enabled.
            //
            if (IsDlgButtonChecked(hDlg, IDC_BREAK_ON_LOG) == BST_CHECKED) {
                g_bBreakOnLog = TRUE;
            }

            if (IsDlgButtonChecked(hDlg, IDC_FULL_PAGEHEAP) == BST_CHECKED) {
                g_bFullPageHeap = TRUE;
            }

            if (IsDlgButtonChecked(hDlg, IDC_PROPAGATE_TESTS_TO_CHILDREN) == BST_CHECKED) {
                g_bPropagateTests = TRUE;
            }

            ::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            break;

        case PSN_QUERYCANCEL:
            return FALSE;
        }
    }

    return FALSE;
}

void
CConnect::CreatePropertySheet(
    HWND hWndParent
    )
{
    CTestInfo*  pTest;
    DWORD       dwPages = 1;
    DWORD       dwPage = 0;
    WCHAR       wszTitle[MAX_PATH];    

    LPCWSTR szExe = g_wstrExeName.c_str();

    //
    // count the number of pages
    //
    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->PropSheetPage.pfnDlgProc) {
            dwPages++;
        }
    }

    m_phPages = new HPROPSHEETPAGE[dwPages];
    if (!m_phPages) {
        return;
    }

    //
    // init the global page
    //
    m_PageGlobal.dwSize         = sizeof(PROPSHEETPAGE);
    m_PageGlobal.dwFlags        = PSP_USETITLE;
    m_PageGlobal.hInstance      = g_hInstance;
    m_PageGlobal.pszTemplate    = MAKEINTRESOURCE(IDD_AV_OPTIONS);
    m_PageGlobal.pfnDlgProc     = DlgViewOptions;
    m_PageGlobal.pszTitle       = MAKEINTRESOURCE(IDS_GLOBAL_OPTIONS);
    m_PageGlobal.lParam         = 0;
    m_PageGlobal.pfnCallback    = NULL;
    m_phPages[0]                = CreatePropertySheetPage(&m_PageGlobal);

    if (!m_phPages[0]) {
        //
        // we need the global page minimum
        //
        return;
    }

    //
    // add the pages for the various tests
    //
    dwPage = 1;
    for (pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); pTest++) {
        if (pTest->PropSheetPage.pfnDlgProc) {

            //
            // we use the lParam to identify the exe involved
            //
            pTest->PropSheetPage.lParam = (LPARAM)szExe;

            m_phPages[dwPage] = CreatePropertySheetPage(&(pTest->PropSheetPage));
            if (!m_phPages[dwPage]) {
                dwPages--;
            } else {
                dwPage++;
            }
        }
    }

    LoadString(g_hInstance,
               IDS_OPTIONS_TITLE,
               wszTitle,
               ARRAYSIZE(wszTitle));

    wstring wstrOptions = wszTitle;

    wstrOptions += L" - ";
    wstrOptions += szExe;

    m_psh.dwSize      = sizeof(PROPSHEETHEADER);
    m_psh.dwFlags     = PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP;
    m_psh.hwndParent  = hWndParent;
    m_psh.hInstance   = g_hInstance;
    m_psh.pszCaption  = wstrOptions.c_str();
    m_psh.nPages      = dwPages;
    m_psh.nStartPage  = 0;
    m_psh.phpage      = m_phPages;
    m_psh.pfnCallback = NULL;

    PropertySheet(&m_psh);
}

//
// Called to execute a command.
//
STDMETHODIMP
CConnect::Exec(
    BSTR bstrCmdName,
    EnvDTE::vsCommandExecOption ExecuteOption,
    VARIANT * /*pvarVariantIn*/,
    VARIANT * /*pvarVariantOut*/,
    VARIANT_BOOL *pvbHandled
    )
{
    HRESULT hr;
    CComPtr<IDispatch> pObject;    
    *pvbHandled = VARIANT_FALSE;
    
    if (ExecuteOption == EnvDTE::vsCommandExecOptionDoDefault) {
        *pvbHandled = VARIANT_TRUE;
        if (_wcsicmp(bstrCmdName, L"AppVerifier.Connect.Tests")==0) {
            CreateToolWindow(CLSID_TestSettingsCtrl);
        }
        else if (_wcsicmp(bstrCmdName, L"AppVerifier.Connect.Options")==0) {
            //CreateToolWindow(CLSID_AVOptions);
            CreatePropertySheet(NULL);
        }
        else if (_wcsicmp(bstrCmdName, L"AppVerifier.Connect.ViewLog")==0) {            
            CreateToolWindow(CLSID_LogViewer);
        }
        else if (_wcsicmp(bstrCmdName, L"AppVerifier.Connect.Enable")==0) {
            m_bEnabled = !m_bEnabled;

            CComQIPtr<Office::_CommandBarButton,
                &_uuidof(Office::_CommandBarButton)>pButton(m_pEnableControl);

            if (m_bEnabled) {
                SetEnabledUI();
            } else {
                SetDisabledUI();
            }
            GetCurrentAppSettings();
            CConnect::SetCurrentAppSettings();            
        } else {
            *pvbHandled = VARIANT_FALSE;
        }
    }
    return S_OK;
}

CComPtr<EnvDTE::Window>CConnect::GetToolWindow(
    CLSID clsid
    )
{
    HRESULT hr;
    CComPtr<EnvDTE::Windows>pWindows;
    CComPtr<EnvDTE::Window>pToolWindow;
    CComBSTR guidPosition;

    hr = m_pDTE->get_Windows(&pWindows);
    
    if (FAILED(hr)) {
        return NULL;
    }

    if(clsid == CLSID_LogViewer) {     
        guidPosition = L"{D39B1B7A-EFF3-42ae-8F2B-8EEE78154187}";     
    }
    else if (clsid == CLSID_TestSettingsCtrl) {        
        guidPosition = L"{71CD7261-A72E-4a93-AB5F-3EBCFDEAE842}";
    }
    else if (clsid == CLSID_AVOptions) {
        guidPosition = L"{dc878f00-ac86-4813-8ca9-384fa07cefbf}";
    } else {
        return NULL;
    }
    
    hr = pWindows->Item(CComVariant(guidPosition), &pToolWindow);
    
    if (SUCCEEDED(hr)) {
        return pToolWindow;
    } else {
        return NULL;
    }
}

void
CConnect::CreateToolWindow(
    const CLSID& clsid
    )
{
    HRESULT     hr;
    CComBSTR    progID;
    CComBSTR    caption;
    CComBSTR    guidPosition;
    long        lMinWidth, lMinHeight;
    long        lWidth, lHeight;
    BOOL        bCreated = FALSE;

    CComPtr<IDispatch>pObject;
    CComPtr<EnvDTE::Windows>pWindows;
    CComPtr<EnvDTE::Window>pToolWindow;

    //
    // Bail if verifier is enabled, except for logviewer.
    //
    if (m_bEnabled && clsid != CLSID_LogViewer) {
        return;
    }

    //
    // Check if window has been already created.
    //
    pToolWindow = GetToolWindow(clsid);
    
    if (pToolWindow == NULL) {
        bCreated = TRUE;
        CComPtr<IPictureDisp> picture;
        if(clsid == CLSID_LogViewer) {
            progID = L"AppVerifier.LogViewer.1";
            caption = L"AppVerifier Log";
            guidPosition = L"{D39B1B7A-EFF3-42ae-8F2B-8EEE78154187}";
            lMinWidth = 600;
            lMinHeight = 400;

            picture = GetPicture(MAKEINTRESOURCE(IDB_VIEWLOG));
        }
        else if (clsid == CLSID_TestSettingsCtrl) {
            progID = L"AppVerifier.TestSettingsCtrl.1";
            caption = L"AppVerifier Test Settings";
            guidPosition = L"{71CD7261-A72E-4a93-AB5F-3EBCFDEAE842}";

            lMinWidth = 600;
            lMinHeight = 400;

            picture = GetPicture(MAKEINTRESOURCE(IDB_TESTSETTINGS));
        }
        else if (clsid == CLSID_AVOptions) {
            progID = L"AppVerifier.AVOptions.1";
            caption = L"AppVerifier Options";
            guidPosition = L"{dc878f00-ac86-4813-8ca9-384fa07cefbf}";
            lMinWidth = 300;
            lMinHeight = 100;

            picture = GetPicture(MAKEINTRESOURCE(IDB_OPTIONS));
        } else {
            return;
        }        

        hr = m_pDTE->get_Windows(&pWindows);
        
        if (FAILED(hr)) {
            return;
        }
        
        hr = pWindows->CreateToolWindow(
            m_pAddInInstance,
            progID,
            caption,
            guidPosition,
            &pObject,
            &pToolWindow);    

        if (FAILED(hr)) {
            return;
        }
        
        CComQIPtr<IUnknown, &IID_IUnknown>pictUnk(picture);

        if (pictUnk) {
            pToolWindow->SetTabPicture(CComVariant(pictUnk));
        }
    }
    
    //
    // Make the window visible and activate it.
    //
    hr = pToolWindow->put_Visible(VARIANT_TRUE);
    
    if (FAILED(hr)) {
        return;
    }

    hr = pToolWindow->Activate();

    if (FAILED(hr)) {        
        return;
    }
    
    if (bCreated) {
        hr = pToolWindow->get_Width(&lWidth);
        if (SUCCEEDED(hr) && (lWidth < lMinWidth)) {
            pToolWindow->put_Width(lMinWidth);
        }

        hr = pToolWindow->get_Height(&lHeight);
        if (SUCCEEDED(hr) && (lHeight < lMinHeight)) {
            pToolWindow->put_Height(lMinHeight);
        }
    }
}

void
CConnect::GetNativeVCExecutableNames(
    EnvDTE::Project* pProject
    )
{
    HRESULT hr;
    assert(pProject);

    // Get the DTE object associated with this project.    
    CComPtr<IDispatch> vcProjectObject;
    hr = pProject->get_Object(&vcProjectObject);
    if (SUCCEEDED(hr))
    {
        // Cast that object to a VCProject object.
        CComQIPtr<VCProjectEngineLibrary::VCProject,
            &__uuidof(VCProjectEngineLibrary::VCProject)> vcProject(vcProjectObject);
        if (vcProject)
        {
            // Get the configuration set associated with this project.
            CComPtr<IDispatch> vcConfigSetObject;
            hr = vcProject->get_Configurations(&vcConfigSetObject);
            if (SUCCEEDED(hr))
            {
                // Cast to IVCCollection
                CComQIPtr<VCProjectEngineLibrary::IVCCollection,
                    &__uuidof(VCProjectEngineLibrary::IVCCollection)>
                    vcConfigurationSet(vcConfigSetObject);

                if (vcConfigurationSet)
                {                    
                    long lVCConfigCount;
                    hr = vcConfigurationSet->get_Count(&lVCConfigCount);
                    if (SUCCEEDED(hr))
                    {
                        // Loop through all configurations for this project.
                        for(long j = 1; j <= lVCConfigCount; j++)
                        {
                            CComVariant vtConfigSetIdx(j);
                            CComPtr<IDispatch> vcConfigObject;
                            hr = vcConfigurationSet->Item(
                                vtConfigSetIdx, &vcConfigObject);
                            if (SUCCEEDED(hr))
                            {                                
                                CComQIPtr<
                                    VCProjectEngineLibrary::
                                    VCConfiguration,
                                    &__uuidof(VCProjectEngineLibrary::
                                    VCConfiguration)>
                                    vcConfig(vcConfigObject);
                                if (vcConfig)
                                {
                                    // First, verify that this is
                                    // a native executable.
                                    VARIANT_BOOL bIsManaged;
                                    VCProjectEngineLibrary::ConfigurationTypes
                                        configType;

                                    hr = vcConfig->get_ManagedExtensions(&bIsManaged);
                                    if (FAILED(hr)) {
                                        continue;
                                    }

                                    hr = vcConfig->get_ConfigurationType(&configType);
                                    
                                    if (FAILED(hr)) {
                                        continue;
                                    }

                                    if (configType !=
                                        VCProjectEngineLibrary::typeApplication &&
                                        bIsManaged != VARIANT_FALSE) {
                                        continue;
                                    }

                                    CComBSTR bstrOutput;

                                    hr = vcConfig->get_PrimaryOutput(&bstrOutput);
                                    if (SUCCEEDED(hr)) {
                                        std::wstring wsFullPath = bstrOutput;

                                        int nPos = wsFullPath.rfind(L'\\');

                                        std::wstring wsShortName = wsFullPath.substr(nPos + 1);

                                        g_wstrExeName = wsShortName;
                                        
                                        m_sExeList.insert(wsShortName);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

BOOL
CConnect::GetAppExeNames(
    void
    )
{
    HRESULT hr;
    CComPtr<EnvDTE::_Solution>pSolution;
    CComPtr<EnvDTE::SolutionBuild>pSolBuild;
    CComPtr<EnvDTE::Projects>projectSet;
    CComVariant     varStartupProjects;
    
    m_sExeList.clear();

    //
    // Get the current solution, there is at most one of these.
    //
    hr = m_pDTE->get_Solution(&pSolution);
    
    if (FAILED(hr)) {
        return FALSE;
    }
    
    //
    // Get the set of all projects in the solution.
    //
    hr = pSolution->get_Projects(&projectSet);
    
    if (FAILED(hr)) {
        return FALSE;
    }

    hr = pSolution->get_SolutionBuild(&pSolBuild);

    if (FAILED(hr)) {
        return FALSE;
    }

    //
    // Get the safe array containing all projects that will be
    // launched when the solution is run.
    // This may return nothing, if the current solution is empty.
    //
    hr = pSolBuild->get_StartupProjects(&varStartupProjects);
    
    if (FAILED(hr)){
        return FALSE;
    }
    
    if((varStartupProjects.vt & VT_ARRAY) && (varStartupProjects.vt & VT_VARIANT)) {
        UINT cDim = SafeArrayGetDim(varStartupProjects.parray);
        if (cDim == 1) {
            long lowerBound, upperBound;
            SafeArrayGetLBound(varStartupProjects.parray, 1, &lowerBound);
            SafeArrayGetUBound(varStartupProjects.parray, 1, &upperBound);

            // Loop through the safe array, getting each startup project.
            for (long i = lowerBound; i <= upperBound; i++) {
                CComVariant vtStartupProjectName;
                hr = SafeArrayGetElement(varStartupProjects.parray, &i,
                    (VARIANT*)&vtStartupProjectName);
                if (SUCCEEDED(hr)) {
                    CComPtr<EnvDTE::Project> project;
                    hr = projectSet->Item(vtStartupProjectName,&project);
                    if (SUCCEEDED(hr)) {
                        GetNativeVCExecutableNames(project);
                    }
                }
            }            
        }
    }

    return TRUE;
}

BOOL
CConnect::GetAppInfo(
    void
    )
{
    g_psTests->clear();
    m_bEnabled = FALSE;
    
    if (GetAppExeNames()) {
        
        if (m_sExeList.empty()) {
            return FALSE;
        }

        std::set<std::wstring>::iterator iter;
        iter = m_sExeList.begin();
        
        for(; iter != m_sExeList.end(); iter++) {
            //
            // Locate this exe in the list of apps.
            //
            for (int i = 0; i < g_aAppInfo.size(); i++) {                
                if ((*iter) == g_aAppInfo[i].wstrExeName) {
                    m_bEnabled = TRUE;

                    //
                    // Add this app's tests to the set of tests to run.
                    //
                    CTestInfoArray::iterator test;
                    test = g_aTestInfo.begin();
                    
                    for (; test != g_aTestInfo.end(); test++) {
                        if (g_aAppInfo[i].IsTestActive(*test)) {
                            g_psTests->insert(test);
                        }
                    }
                    break;
                }
            }            
        }

        return TRUE;
    }
    
    SetCurrentAppSettings();

    return FALSE;
}

void
CConnect::SetEnabledUI(
    void
    )
{
    WCHAR   wszCommandText[64];
    WCHAR   wszTooltip[64];

    LoadString(g_hInstance,
               IDS_TB_VERIFY_ENABLED_TEXT,
               wszCommandText,
               ARRAYSIZE(wszCommandText));

    LoadString(g_hInstance,
               IDS_TB_VERIFY_ENABLED_TOOLTIP,
               wszTooltip,
               ARRAYSIZE(wszTooltip));
    
    //
    // Change the text on the button.
    //
    CComQIPtr<Office::_CommandBarButton,
        &_uuidof(Office::_CommandBarButton)>pButton(m_pEnableControl);
    m_pEnableControl->put_Caption(CComBSTR(wszCommandText));

    //
    // Set the picture so we show the button as enabled.
    //
    CComPtr<IPictureDisp>picture = GetPicture(MAKEINTRESOURCE(IDB_DISABLED));
    pButton->put_Picture(picture);

    CComPtr<IPictureDisp>pictureMask = GetPicture(MAKEINTRESOURCE(IDB_ENABLED_MASK));
    pButton->put_Mask(pictureMask);

    //
    // Change the tooltip so that it corresponds to the change
    // in the button text.
    //
    m_pEnableControl->put_TooltipText(CComBSTR(wszTooltip));

    m_pEnableControl->put_Enabled(VARIANT_TRUE);
    m_pTestsControl->put_Enabled(VARIANT_FALSE);
    m_pOptionControl->put_Enabled(VARIANT_FALSE);

    //
    // Hide all of our settings windows.
    //
    CComPtr<EnvDTE::Window>pWindow;

    pWindow = GetToolWindow(CLSID_TestSettingsCtrl);
    
    if (pWindow) {
        pWindow->put_Visible(VARIANT_FALSE);
    }
    pWindow = GetToolWindow(CLSID_AVOptions);
    
    if (pWindow) {
        pWindow->put_Visible(VARIANT_FALSE);
    }
}

void
CConnect::DisableVerificationBtn(
    void
    )
{
    CComQIPtr<Office::_CommandBarButton,
         &_uuidof(Office::_CommandBarButton)>pButton(m_pEnableControl);

    m_pEnableControl->put_Enabled(VARIANT_FALSE);
}

void
CConnect::EnableVerificationBtn(
    void
    )
{
    CComQIPtr<Office::_CommandBarButton,
         &_uuidof(Office::_CommandBarButton)>pButton(m_pEnableControl);

    m_pEnableControl->put_Enabled(VARIANT_TRUE);
}

void
CConnect::SetDisabledUI(
    void
    )
{
    WCHAR   wszCommandText[64];
    WCHAR   wszTooltip[64];

    LoadString(g_hInstance,
               IDS_TB_VERIFICATION_CMD_TEXT,
               wszCommandText,
               ARRAYSIZE(wszCommandText));

    LoadString(g_hInstance,
               IDS_TB_VERIFICATION_CMD_TOOLTIP,
               wszTooltip,
               ARRAYSIZE(wszTooltip));

    //
    // Change the text on the button.
    //
    CComQIPtr<Office::_CommandBarButton,
         &_uuidof(Office::_CommandBarButton)>pButton(m_pEnableControl);
    m_pEnableControl->put_Caption(CComBSTR(wszCommandText));

    //
    // Set the picture so we show the button as disabled.
    //
    CComPtr<IPictureDisp> picture = GetPicture(MAKEINTRESOURCE(IDB_ENABLED));
    pButton->put_Picture(picture);

    CComPtr<IPictureDisp> pictureMask = GetPicture(MAKEINTRESOURCE(IDB_ENABLED_MASK));
    pButton->put_Mask(pictureMask);

    //
    // Change the tooltip so that it corresponds to the change
    // in the button text.
    //
    m_pEnableControl->put_TooltipText(CComBSTR(wszTooltip));

    m_pEnableControl->put_Enabled(VARIANT_TRUE);
    m_pTestsControl->put_Enabled(VARIANT_TRUE);
    m_pOptionControl->put_Enabled(VARIANT_TRUE);
}

void
CConnect::SetCurrentAppSettings(
    void
    )
{
    if (m_bEnabled) {
        //
        // Insert exes into app array.
        //
        std::set<std::wstring>::iterator exe;
        exe = m_sExeList.begin();
        
        for (; exe != m_sExeList.end(); exe++) {
            CAVAppInfo* pApp = NULL;
            
            for (int i = 0; i < g_aAppInfo.size(); i++) {
                if (g_aAppInfo[i].wstrExeName==*exe) {
                    pApp = &g_aAppInfo[i];
                    break;
                }
            }

            if (pApp == NULL) {
                CAVAppInfo app;
                app.wstrExeName = *exe;
                
                g_aAppInfo.push_back(app);
                pApp = &g_aAppInfo.back();
            }
            
            std::set<CTestInfo*, CompareTests>::iterator iter;
            iter = g_psTests->begin();
            
            for(; iter != g_psTests->end(); iter++) {
                pApp->AddTest(**iter);                
            }

            //
            // Add flags.
            //
            pApp->bBreakOnLog       = g_bBreakOnLog;
            pApp->bFullPageHeap     = g_bFullPageHeap;
            pApp->bUseAVDebugger    = FALSE;
            pApp->bPropagateTests   = g_bPropagateTests;
            pApp->wstrDebugger      = L"";
        }
    } else {
        std::set<std::wstring>::iterator exe;
        exe = m_sExeList.begin();
        
        for (; exe != m_sExeList.end(); exe++) {
            CAVAppInfoArray::iterator app;
            app = g_aAppInfo.begin();
            
            for (; app != g_aAppInfo.end(); app++) {
                if (app->wstrExeName==*exe) {
                    //
                    // Before we erase this app, remove all kernel tests
                    // and write app data.
                    //
                    app->dwRegFlags = 0;
                    ::SetCurrentAppSettings();
                    g_aAppInfo.erase(app);
                    break;
                }
            }
        }
    }

    if (!g_aAppInfo.empty()) {
        //
        // Persist Options.
        //
        for (CAVAppInfo *pApp = g_aAppInfo.begin(); pApp != g_aAppInfo.end(); ++pApp) {
            
            LPCWSTR szExe = pApp->wstrExeName.c_str();
        
            SaveShimSettingDWORD(L"General", szExe, AV_OPTION_BREAK_ON_LOG, (DWORD)pApp->bBreakOnLog);
            SaveShimSettingDWORD(L"General", szExe, AV_OPTION_FULL_PAGEHEAP, (DWORD)pApp->bFullPageHeap);
            SaveShimSettingDWORD(L"General", szExe, AV_OPTION_AV_DEBUGGER, (DWORD)pApp->bUseAVDebugger);
            SaveShimSettingDWORD(L"General", szExe, AV_OPTION_PROPAGATE, (DWORD)pApp->bPropagateTests);
            SaveShimSettingString(L"General", szExe, AV_OPTION_DEBUGGER, pApp->wstrDebugger.c_str());
        }

        ::SetCurrentAppSettings();
    }
}

HRESULT
CConnect::CSolutionEventsSink::AfterClosing(
    void
    )
{
    // We're done, cleanup.

    // Disable our controls
    m_pParent->m_pOptionControl->put_Enabled(VARIANT_FALSE);
    m_pParent->m_pTestsControl->put_Enabled(VARIANT_FALSE);
    m_pParent->m_pEnableControl->put_Enabled(VARIANT_FALSE);

    return S_OK;
}

HRESULT
CConnect::CSolutionEventsSink::BeforeClosing(
    void
    )
{
    return S_OK;
}
HRESULT
CConnect::CSolutionEventsSink::Opened(
    void
    )
{
    CComPtr<EnvDTE::_Solution>pSolution;
    CComPtr<EnvDTE::Globals>pGlobals;

    if (!g_bCorrectOSVersion) {
        m_pParent->m_pOptionControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pTestsControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pEnableControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pLogViewControl->put_Enabled(VARIANT_FALSE);
        return S_OK;
    }
    
    //
    // Change in config.
    //
    if (m_pParent->GetAppInfo()) {
        if (m_pParent->m_bEnabled) {
            m_pParent->SetEnabledUI();
        } else {
            m_pParent->SetDisabledUI();
        }        
    } else {
        m_pParent->m_pOptionControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pTestsControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pEnableControl->put_Enabled(VARIANT_FALSE);
    }

    return S_OK;
}

HRESULT
CConnect::CSolutionEventsSink::ProjectAdded(
    EnvDTE::Project* /*proj*/
    )
{
    if (!g_bCorrectOSVersion) {
        m_pParent->m_pOptionControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pTestsControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pEnableControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pLogViewControl->put_Enabled(VARIANT_FALSE);
        return S_OK;
    }

    //
    // Change in config.
    //
    if (m_pParent->GetAppInfo()) {
        if (m_pParent->m_bEnabled) {
            m_pParent->SetEnabledUI();
        } else {
            m_pParent->SetDisabledUI();
        }
    } else {
        m_pParent->m_pOptionControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pTestsControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pEnableControl->put_Enabled(VARIANT_FALSE);
    }

    return S_OK;
}

HRESULT
CConnect::CSolutionEventsSink::ProjectRemoved(
    EnvDTE::Project* /*proj*/
    )
{
    if (!g_bCorrectOSVersion) {
        m_pParent->m_pOptionControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pTestsControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pEnableControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pLogViewControl->put_Enabled(VARIANT_FALSE);
        return S_OK;
    }

    // Change in config.
    if (m_pParent->GetAppInfo()) {
        if (m_pParent->m_bEnabled) {
            m_pParent->SetEnabledUI();
        } else {
            m_pParent->SetDisabledUI();
        }
    } else {
        m_pParent->m_pOptionControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pTestsControl->put_Enabled(VARIANT_FALSE);
        m_pParent->m_pEnableControl->put_Enabled(VARIANT_FALSE);
    }
    return S_OK;
}

HRESULT
CConnect::CSolutionEventsSink::ProjectRenamed(
    EnvDTE::Project* /*proj*/,
    BSTR /*bstrOldName*/
    )
{
    return S_OK;
}

HRESULT
CConnect::CSolutionEventsSink::QueryCloseSolution(
    VARIANT_BOOL* fCancel
    )
{
    *fCancel = VARIANT_FALSE;
    return S_OK;
}

HRESULT
CConnect::CSolutionEventsSink::Renamed(
    BSTR /*bstrOldName*/
    )
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\logviewer.cpp ===
// LogViewer.cpp : Implementation of CLogViewer
#include "precomp.h"
#include "LogViewer.h"
#include "viewlog.h"

extern HWND g_hwndIssues;
extern BOOL g_bInternalMode;

extern void RefreshLog(HWND hDlg);
extern void ExportSelectedLog(HWND hDlg);
extern void DeleteSelectedLog(HWND hDlg);
extern void DeleteAllLogs(HWND hDlg);
extern void FillTreeView(HWND hDlg);
extern void SetDescriptionText(HWND hDlg, CProcessLogEntry* pEntry);

//
// Stores information about children windows within
// the logviewer window.
//
CHILDINFO g_rgChildInfo[NUM_CHILDREN];

//
// Used to show error messages versus showing all messages.
//
extern VLOG_LEVEL g_eMinLogLevel;

// CLogViewer
HWND
CLogViewer::CreateControlWindow(
    HWND  hwndParent,
    RECT& rcPos
    )
{
    UINT    uIndex;
    RECT    rcTemp = {0};
    HWND    hWnd;

    hWnd = CComCompositeControl<CLogViewer>::CreateControlWindow(hwndParent, rcPos);

    g_hwndIssues = GetDlgItem(IDC_ISSUES);

    //
    // Store the coordinates for the parent in the first element.
    //
    g_rgChildInfo[0].uChildId   = 0;
    g_rgChildInfo[0].hWnd       = hWnd;
    ::GetWindowRect(hWnd, &g_rgChildInfo[0].rcParent);

    //
    // Fill in the array of CHILDINFO structs which helps handle sizing
    // of the child controls.
    //
    g_rgChildInfo[VIEW_EXPORTED_LOG_INDEX].uChildId = IDC_VIEW_EXPORTED_LOG;
    g_rgChildInfo[DELETE_LOG_INDEX].uChildId        = IDC_BTN_DELETE_LOG;
    g_rgChildInfo[DELETE_ALL_LOGS_INDEX].uChildId   = IDC_BTN_DELETE_ALL;
    g_rgChildInfo[ISSUES_INDEX].uChildId            = IDC_ISSUES;
    g_rgChildInfo[SOLUTIONS_STATIC_INDEX].uChildId  = IDC_SOLUTIONS_STATIC;
    g_rgChildInfo[ISSUE_DESCRIPTION_INDEX].uChildId = IDC_ISSUE_DESCRIPTION;

    for (uIndex = 1; uIndex <= NUM_CHILDREN; uIndex++) {
        g_rgChildInfo[uIndex].hWnd = GetDlgItem(g_rgChildInfo[uIndex].uChildId);

        ::GetWindowRect(g_rgChildInfo[uIndex].hWnd,
                        &g_rgChildInfo[uIndex].rcChild);
        ::MapWindowPoints(NULL,
                          hWnd,
                          (LPPOINT)&g_rgChildInfo[uIndex].rcChild,
                          2);
    }

    CheckDlgButton(IDC_SHOW_ERRORS, BST_CHECKED);

    return hWnd;
}

LRESULT
CLogViewer::OnInitDialog(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    HWND hWndTree = GetDlgItem(IDC_ISSUES);
    ::SetFocus(hWndTree);

    bHandled = TRUE;

    return FALSE;
}

LRESULT
CLogViewer::OnButtonDown(
    WORD  wNotifyCode,
    WORD  wID,
    HWND  hWndCtl,
    BOOL& bHandled
    )
{
    bHandled = TRUE;
    
    switch(wID) {
    case IDC_EXPORT_LOG:
        ExportSelectedLog(static_cast<HWND>(*this));
        break;

    case IDC_BTN_DELETE_LOG:
        DeleteSelectedLog(static_cast<HWND>(*this));
        SetDescriptionText(static_cast<HWND>(*this), NULL);
        break;

    case IDC_BTN_DELETE_ALL:
        DeleteAllLogs(static_cast<HWND>(*this));
        SetDescriptionText(static_cast<HWND>(*this), NULL);
        break;

    case IDC_SHOW_ERRORS:
        g_eMinLogLevel = VLOG_LEVEL_WARNING;
        *g_szSingleLogFile = TEXT('\0');
        RefreshLog(static_cast<HWND>(*this));
        break;

    case IDC_SHOW_ALL:
        g_eMinLogLevel = VLOG_LEVEL_INFO;
        *g_szSingleLogFile = TEXT('\0');
        RefreshLog(static_cast<HWND>(*this));
        break;

    default:
        bHandled = FALSE;
    }

    return TRUE;
}

LRESULT
CLogViewer::OnNotify(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    LRESULT lResult = DlgViewLog(static_cast<HWND>(*this),
                                 uMsg,
                                 wParam,
                                 lParam);

    bHandled = (lResult) ? TRUE : FALSE;

    return lResult;
}

//
// We receive this when the dialog is being displayed.
//
LRESULT
CLogViewer::OnSetFocus(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    *g_szSingleLogFile = TEXT('\0');
    RefreshLog(static_cast<HWND>(*this));

    bHandled = FALSE;

    return 0;
}

LRESULT
CLogViewer::OnSize(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    HDC         hdc;
    TEXTMETRIC  tm;
    RECT        rcViewSessionLog, rcDeleteAllLogs;
    RECT        rcViewExportedLog, rcExportLog;
    RECT        rcDeleteLog, rcDlg;
    int         nWidth, nHeight;
    int         nCurWidth, nCurHeight;
    int         nDeltaW, nDeltaH;

    nWidth  = LOWORD(lParam);
    nHeight = HIWORD(lParam);

    GetWindowRect(&rcDlg);

    nCurWidth  = rcDlg.right  - rcDlg.left;
    nCurHeight = rcDlg.bottom - rcDlg.top;

    nDeltaW = (g_rgChildInfo[0].rcParent.right -
               g_rgChildInfo[0].rcParent.left) -
               nCurWidth;

    nDeltaH = (g_rgChildInfo[0].rcParent.bottom -
               g_rgChildInfo[0].rcParent.top)   -
               nCurHeight;
    
    //
    // If below a certain size, just proceed as if that size.
    // This way, if the user makes the window really small, all our
    // controls won't just scrunch up. Better way would be to make it
    // impossible for the user to make the window this small, but devenv
    // doesn't pass the WM_SIZING message to the ActiveX control.
    //
    if (nWidth < 550) {
        nWidth = 550;
    }

    if (nHeight < 225) {
        nHeight = 225;
    }

    hdc = GetDC();
    GetTextMetrics(hdc, &tm);
    ReleaseDC(hdc);

    //
    // Adjust the treeview. The top left corner does not move.
    // It either gets wider/more narrow or taller/shorter.
    //
    /*::SetWindowPos(g_rgChildInfo[ISSUES_INDEX].hWnd,
                   NULL,
                   0,
                   0,
                   (g_rgChildInfo[ISSUES_INDEX].rcChild.right -
                    g_rgChildInfo[ISSUES_INDEX].rcChild.left) +
                    nDeltaW,
                   (g_rgChildInfo[ISSUES_INDEX].rcChild.bottom -
                    g_rgChildInfo[ISSUES_INDEX].rcChild.top)   +
                    nDeltaH,
                   SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);*/

    //
    // Move description window and to bottom of screen.
    //
    ::MoveWindow(GetDlgItem(IDC_ISSUE_DESCRIPTION), tm.tmMaxCharWidth,
        nHeight - (nHeight/4 + tm.tmHeight),
        nWidth - 2*tm.tmMaxCharWidth, nHeight/4, FALSE);

    //
    // Move caption to right above that.
    //
    ::MoveWindow(GetDlgItem(IDC_SOLUTIONS_STATIC), tm.tmMaxCharWidth,
        nHeight - (2*tm.tmHeight + nHeight/4),
        nWidth-2*tm.tmMaxCharWidth, tm.tmHeight, FALSE);

    //
    // Expand treeview to fill in empty space.
    //
    ::MoveWindow(GetDlgItem(IDC_ISSUES), tm.tmMaxCharWidth,
        tm.tmHeight*4, nWidth-2*tm.tmMaxCharWidth, nHeight - (6*tm.tmHeight+nHeight/4), FALSE);
    InvalidateRect(NULL);
    bHandled = TRUE;

    //::GetWindowRect(g_hWndLogViewer, &g_rgChildInfo[0].rcParent);

    return 0;
}

HRESULT
STDMETHODCALLTYPE
CLogViewer::Refresh(
    void
    )
{
    *g_szSingleLogFile = TEXT('\0');
    RefreshLog(static_cast<HWND>(*this));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\logviewer.h ===
// LogViewer.h : Declaration of the CLogViewer
#pragma once
#include "resource.h"       // main symbols
#include <atlctl.h>
#include "AddIn.h"

// CLogViewer
class ATL_NO_VTABLE CLogViewer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ILogViewer, &IID_ILogViewer, &LIBID_AppVerifierLib, /*wMajor =*/ 1, /*wMinor =*/ 0>,
	public IPersistStreamInitImpl<CLogViewer>,
	public IOleControlImpl<CLogViewer>,
	public IOleObjectImpl<CLogViewer>,
	public IOleInPlaceActiveObjectImpl<CLogViewer>,
	public IViewObjectExImpl<CLogViewer>,
	public IOleInPlaceObjectWindowlessImpl<CLogViewer>,
	public CComCoClass<CLogViewer, &CLSID_LogViewer>,
	public CComCompositeControl<CLogViewer>
{
public:

	CLogViewer()
	{
		m_bWindowOnly = TRUE;
		CalcExtent(m_sizeExtent);
	}

    HWND CreateControlWindow(HWND hwndParent, RECT& rcPos);

DECLARE_REGISTRY_RESOURCEID(IDR_LOGVIEWER)

BEGIN_COM_MAP(CLogViewer)
	COM_INTERFACE_ENTRY(ILogViewer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CLogViewer)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()


BEGIN_MSG_MAP(CLogViewer)
    COMMAND_HANDLER(IDC_SHOW_ERRORS, BN_CLICKED, OnButtonDown)
    COMMAND_HANDLER(IDC_SHOW_ALL, BN_CLICKED, OnButtonDown)
    COMMAND_HANDLER(IDC_EXPORT_LOG, BN_CLICKED, OnButtonDown)
    COMMAND_HANDLER(IDC_BTN_DELETE_LOG, BN_CLICKED, OnButtonDown)
    COMMAND_HANDLER(IDC_BTN_DELETE_ALL, BN_CLICKED, OnButtonDown)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)

	CHAIN_MSG_MAP(CComCompositeControl<CLogViewer>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CLogViewer)
	//Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		if (dispid == DISPID_AMBIENT_BACKCOLOR)
		{
			SetBackgroundColorFromAmbient();
			FireViewChange();
		}
		return IOleControlImpl<CLogViewer>::OnAmbientPropertyChange(dispid);
	}
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ILogViewer
    HRESULT STDMETHODCALLTYPE Refresh();

	enum { IDD = IDD_LOGVIEWER };

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnNotify(UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\precomp.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

// Overload operator new & delete globally to go through our heap
void* __cdecl operator new(size_t size);
void __cdecl operator delete(void* pv);

#define STRSAFE_NO_DEPRECATE
#include "..\precomp.h"

#undef IDC_ISSUES

#ifndef STRICT
#define STRICT
#endif

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400	// Change this to the appropriate value to target Windows 2000 or later.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off ATL's hiding of some common and often safely ignored warning messages
#define _ATL_ALL_WARNINGS

#include "resource.h"
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>

// Visual Studio Extensibility Interfaces
#include "mso.tlh"
#include "dte.tlh"
#include "vcprojectengine.tlh"
#include "msaddndr.tlh"

class DECLSPEC_UUID("361F419C-04B3-49EC-B4E5-FFD812346A8A") AppVerifierLib;

using namespace ATL;

template<typename T>
inline void SafeRelease(T& obj)
{
    if (obj)
    {
        obj->Release();
        obj = NULL;
    }
}

//
// Used to help handle sizing in the logviewer window.
//
#define NUM_CHILDREN 7

#define VIEW_EXPORTED_LOG_INDEX 1
#define DELETE_LOG_INDEX        2
#define DELETE_ALL_LOGS_INDEX   3
#define ISSUES_INDEX            4
#define SOLUTIONS_STATIC_INDEX  5
#define ISSUE_DESCRIPTION_INDEX 6

typedef struct _CHILDINFO {
    UINT    uChildId;
    HWND    hWnd;
    RECT    rcParent;
    RECT    rcChild;
} CHILDINFO, *PCHILDINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// AddIn.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by addin.rc
//
#include "..\ids.h"

#define IDR_ADDIN                       101
#define IDR_TESTSETTINGSCTRL            104
#define IDD_TESTSETTINGSCTRL            105
#define IDR_LOGVIEWER                   107
#define IDD_LOGVIEWER                   108
#define IDC_SETTINGS_LIST               110
#define IDI_APPICON                     111
#define IDC_EXPORT_LOG                  114
#define IDC_VIEW_SESSION_LOG            118
#define IDC_VIEW_EXPORTED_LOG           121
#define IDD_AV_OPTIONS                  207
#define IDC_TEST_DESCRIPTION            208
#define IDC_DESCRIPTION_STATIC          209
#define IDB_TESTSETTINGS                209
#define IDR_AV_OPTIONS                  210
#define IDB_OPTIONS                     210
#define IDB_VIEWLOG                     211
#define IDB_ENABLED                     212
#define IDB_DISABLED                    213
#define IDB_TESTSETTINGS_BTN            216
#define IDB_OPTIONS_BTN                 218
#define IDB_VIEWLOG_BTN                 219
#define IDB_DISABLED_MASK               220
#define IDB_ENABLED_MASK                223
#define IDC_CLEAR_LOG_ON_CHANGES        1009
#define IDC_BREAK_ON_LOG                1010
#define IDC_FULL_PAGEHEAP               1011
#define IDC_PROPAGATE_TESTS_TO_CHILDREN 1012
#define IDC_ISSUE_DESCRIPTION           1016
#define IDC_SOLUTIONS_STATIC            1018
#define IDS_INVALID_OS_VERSION          5503
#define IDS_TB_VERIFICATION_CMD_ID      5504
#define IDS_TB_VERIFICATION_CMD_TEXT    5505
#define IDS_TB_VERIFICATION_CMD_TOOLTIP 5506
#define IDS_TB_TESTS_CMD_ID             5507
#define IDS_TB_TESTS_CMD_TEXT           5508
#define IDS_TB_TESTS_CMD_TOOLTIP        5509
#define IDS_TB_OPTIONS_CMD_ID           5510
#define IDS_TB_OPTIONS_CMD_TEXT         5511
#define IDS_TB_OPTIONS_CMD_TOOLTIP      5512
#define IDS_TB_VIEWLOG_CMD_ID           5513
#define IDS_TB_VIEWLOG_CMD_TEXT         5514
#define IDS_TB_VIEWLOG_CMD_TOOLTIP      5515
#define IDS_TB_VERIFY_ENABLED_TEXT      5516
#define IDS_TB_VERIFY_ENABLED_TOOLTIP   5517
#define IDS_TESTS_CONFLICT              5518
#define IDS_MUST_RUN_ALONE              5519

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\testsettingsctrl.cpp ===
// TestSettingsCtrl.cpp : Implementation of CTestSettingsCtrl
#include "precomp.h"
#include "TestSettingsCtrl.h"
#include "connect.h"
#include <commctrl.h>
#include <cassert>

std::set<CTestInfo*, CompareTests>* g_psTests;

// CTestSettingsCtrl
HWND
CTestSettingsCtrl::CreateControlWindow(
    HWND  hwndParent,
    RECT& rcPos
    )
{
    CTestInfo*  pTest = NULL;
    WCHAR       wszDescription[MAX_PATH];
    LVCOLUMN    lvc;
    LVITEM      lvi;
    HWND        hWndListView;
    UINT        uCount;

    assert(!g_aAppInfo.empty());

    HWND hwnd =
        CComCompositeControl<CTestSettingsCtrl>::CreateControlWindow(hwndParent, rcPos);

    hWndListView = GetDlgItem(IDC_SETTINGS_LIST);
    
    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.cx       = 300;
    lvc.iSubItem = 0;
    lvc.pszText  = L"xxx";

    ListView_InsertColumn(hWndListView, 0, &lvc);
    ListView_SetExtendedListViewStyleEx(hWndListView,
                                        LVS_EX_CHECKBOXES,
                                        LVS_EX_CHECKBOXES);

    ListView_DeleteAllItems(hWndListView);
    
    for (uCount = 0, pTest = g_aTestInfo.begin(); pTest != g_aTestInfo.end(); uCount++, pTest++) {
        if (g_bWin2KMode && !pTest->bWin2KCompatible) {
            continue;
        }

        lvi.mask      = LVIF_TEXT | LVIF_PARAM;
        lvi.pszText   = (LPWSTR)pTest->strTestFriendlyName.c_str();
        lvi.lParam    = (LPARAM)pTest;
        lvi.iItem     = uCount;
        lvi.iSubItem  = 0;

        int nItem = ListView_InsertItem(hWndListView, &lvi);

        std::set<CTestInfo*, CompareTests>::iterator iter;
        iter = g_psTests->find(pTest);
        BOOL bCheck = (iter != g_psTests->end()) ? TRUE : FALSE;

        ListView_SetCheckState(hWndListView, nItem, bCheck);
    }

    LoadString(g_hInstance,
               IDS_VIEW_TEST_DESC,
               wszDescription,
               ARRAYSIZE(wszDescription));

    //
    // Initially, our description tells them to select a test
    // to view it's description.
    //
    SetDlgItemText(IDC_TEST_DESCRIPTION, wszDescription);

    m_bLVCreated = TRUE;

    return hwnd;
}

//
// We receive this when the dialog is being displayed.
//
LRESULT
CTestSettingsCtrl::OnSetFocus(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    HWND    hWndList;

    hWndList = GetDlgItem(IDC_SETTINGS_LIST);

    ListView_SetItemState(hWndList,
                          0,
                          LVIS_FOCUSED | LVIS_SELECTED,
                          0x000F);

    bHandled = TRUE;

    return 0;
}

void
CTestSettingsCtrl::DisplayRunAloneError(
    IN LPCWSTR pwszTestName
    )
{
    WCHAR   wszWarning[MAX_PATH];
    WCHAR   wszTemp[MAX_PATH];
    
    LoadString(g_hInstance,
               IDS_MUST_RUN_ALONE,
               wszTemp,
               ARRAYSIZE(wszTemp));

    StringCchPrintf(wszWarning,
                    ARRAYSIZE(wszWarning),
                    wszTemp,
                    pwszTestName);

    MessageBox(wszWarning,
               0,
               MB_OK | MB_ICONEXCLAMATION);

}

//
// Ensures that we warn the user for tests that are
// marked 'run alone'. 
//
BOOL
CTestSettingsCtrl::CheckForRunAlone(
    IN HWND       hWndListView,
    IN CTestInfo* pTest
    )
{
    int     nCount, cItems, cItemsChecked;
    LVITEM  lvi;

    cItems = ListView_GetItemCount(hWndListView);

    //
    // First pass, determine how tests are selected.
    //
    for (nCount = 0, cItemsChecked = 0; nCount < cItems; nCount++) {
        if (ListView_GetCheckState(hWndListView, nCount)) {
            cItemsChecked++;
        }
    }

    //
    // If there aren't any tests selected, we're fine.
    //
    if (cItemsChecked == 0) {
        return FALSE;
    }

    //
    // If this test must run alone, we're in hot water
    // because somebody else is already checked.
    //
    if (pTest->bRunAlone) {
        DisplayRunAloneError(pTest->strTestFriendlyName.c_str());
        return TRUE;
    }
    
    //
    // Second pass, determine if any tests that are checked
    // must run alone.
    //
    for (nCount = 0; nCount < cItems; nCount++) {
        ZeroMemory(&lvi, sizeof(LVITEM));

        lvi.iItem       = nCount;
        lvi.iSubItem    = 0;
        lvi.mask        = LVIF_PARAM;

        ListView_GetItem(hWndListView, &lvi);
        CTestInfo* pTest = (CTestInfo*)lvi.lParam;
        
        if (pTest->bRunAlone) {
            if (ListView_GetCheckState(hWndListView, nCount)) {
                DisplayRunAloneError(pTest->strTestFriendlyName.c_str());
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL
CTestSettingsCtrl::CheckForConflictingTests(
    IN HWND    hWndListView,
    IN LPCWSTR pwszTestName
    )
{
    WCHAR   wszWarning[MAX_PATH];
    int     nCount, cItems;
    LVITEM  lvi;
    
    //
    // They're attempting to enable a test that we're concerned
    // about. Determine if the other conflicting test is already
    // enabled.
    //
    cItems = ListView_GetItemCount(hWndListView);

    for (nCount = 0; nCount < cItems; nCount++) {
        ZeroMemory(&lvi, sizeof(LVITEM));

        lvi.iItem       = nCount;
        lvi.iSubItem    = 0;
        lvi.mask        = LVIF_PARAM;

        ListView_GetItem(hWndListView, &lvi);
        CTestInfo* pTestInfo = (CTestInfo*)lvi.lParam;
        wstring strTestName = pTestInfo->strTestName;

        if (strTestName == pwszTestName) {
            if (ListView_GetCheckState(hWndListView, nCount)) {
                //
                // Display the warning.
                //
                LoadString(g_hInstance,
                           IDS_TESTS_CONFLICT,
                           wszWarning,
                           ARRAYSIZE(wszWarning));
            
                MessageBox(wszWarning,
                           0,
                           MB_OK | MB_ICONEXCLAMATION);
        
                return TRUE;
            }
        }
    }

    return FALSE; 
}

BOOL
CTestSettingsCtrl::IsChecked(
    NM_LISTVIEW* pNMListView
    )
{
    return (CHECK_BIT(pNMListView->uNewState) != 0);
}

BOOL
CTestSettingsCtrl::CheckChanged(
    NM_LISTVIEW* pNMListView
    )
{
    if (pNMListView->uOldState == 0) {
        return FALSE; // adding new items...
    }

    return CHECK_CHANGED(pNMListView) ? TRUE : FALSE;
}

LRESULT
CTestSettingsCtrl::OnNotify(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    //
    // Ensure that this is intended for the listview control.
    //
    if (wParam != IDC_SETTINGS_LIST) {
        bHandled = FALSE;
        return FALSE;
    }

    if (!m_bLVCreated) {
        bHandled = FALSE;
        return TRUE;
    }

    bHandled = FALSE;

    LPNMHDR pnmh = (LPNMHDR)lParam;
    HWND hWndListView = GetDlgItem(IDC_SETTINGS_LIST);

    switch (pnmh->code) {
    case LVN_ITEMCHANGING:
        {
            //
            // We handle this message so we can prevent the user from
            // checking items that conflict.
            //
            LPNMLISTVIEW    lpnmlv;
            CTestInfo*      pTest = NULL;
            const WCHAR     wszLogFileChanges[] = L"LogFileChanges";
            const WCHAR     wszWinFileProtect[] = L"WindowsFileProtection";
        
            lpnmlv = (LPNMLISTVIEW)lParam;
            pTest = (CTestInfo*)lpnmlv->lParam;

            bHandled = TRUE;

            //
            // Only process if someone is checking an item.
            //
            if (CheckChanged(lpnmlv) && (IsChecked(lpnmlv))) {
                if (CheckForRunAlone(hWndListView, pTest)) {
                    return TRUE;
                }
    
                //
                // Determine if the tests conflict.
                //
                if (pTest->strTestName == wszLogFileChanges) {
                    if (CheckForConflictingTests(hWndListView, wszWinFileProtect)) {
                        return TRUE;
                    }
                } else if (pTest->strTestName == wszWinFileProtect) {
                    if (CheckForConflictingTests(hWndListView, wszLogFileChanges)) {
                        return TRUE;
                    }
                }
    
                //
                // No problems - insert the test.
                //
                g_psTests->insert(pTest);
            } else if (CheckChanged(lpnmlv) && (!IsChecked(lpnmlv))) {
                //
                // Remove the test.
                //
                g_psTests->erase(pTest);
            }

            break;
        }

    case LVN_ITEMCHANGED:
        {
            LPNMLISTVIEW    lpnmlv;
            CTestInfo*      pTest = NULL;
    
            lpnmlv = (LPNMLISTVIEW)lParam;
            pTest = (CTestInfo*)lpnmlv->lParam;
    
            if ((lpnmlv->uChanged & LVIF_STATE) &&
                (lpnmlv->uNewState & LVIS_SELECTED)) {
                SetDlgItemText(IDC_TEST_DESCRIPTION,
                               pTest->strTestDescription.c_str());
                
                ListView_SetItemState(hWndListView,
                                      lpnmlv->iItem,
                                      LVIS_FOCUSED | LVIS_SELECTED,
                                      0x000F);
            }

            bHandled = TRUE;

            break;
        }
    }

    return FALSE;
}

LRESULT
CTestSettingsCtrl::OnSize(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL&  bHandled
    )
{
    TEXTMETRIC  tm;
    HDC         hdc;

    int nWidth = LOWORD(lParam);
    int nHeight = HIWORD(lParam);

    // If below a certain size, just proceed as if that size.
    // This way, if the user makes the window really small, all our controls won't just
    // scrunch up.  Better way would be to make it impossible for the user to make the window
    // this small, but devenv doesn't pass the WM_SIZING message to the ActiveX control.
    if (nWidth < 200) {
        nWidth = 200;
    }

    if (nHeight < 250) {
        nHeight = 250;
    }

    hdc = GetDC();
    GetTextMetrics(hdc, &tm);
    ReleaseDC(hdc);

    // Resize all child window controls
    ::MoveWindow(GetDlgItem(IDC_SETTINGS_LIST),
        tm.tmMaxCharWidth, tm.tmHeight, nWidth-2* tm.tmMaxCharWidth, nHeight - (2 * tm.tmHeight + 5 * tm.tmHeight) , FALSE);

    int nY = nHeight - (2 * tm.tmHeight + 5 *tm.tmHeight) + tm.tmHeight;
    ::MoveWindow(GetDlgItem(IDC_DESCRIPTION_STATIC),
        tm.tmMaxCharWidth, nY, nWidth-2*tm.tmMaxCharWidth,
        tm.tmHeight, FALSE);
    
    ::MoveWindow(GetDlgItem(IDC_TEST_DESCRIPTION),
        tm.tmMaxCharWidth, nY+tm.tmHeight, nWidth-2*tm.tmMaxCharWidth,
        tm.tmHeight*4, FALSE);

    InvalidateRect(NULL);
    bHandled = TRUE;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avrfinst.rc
//
#define IDS_NO_CLASS                    1
#define IDS_NO_MAIN_DLG                 2
#define IDS_OS_NOT_SUPPORTED            3
#define IDS_INIT_FAILED                 4
#define IDS_INSTALL_FAILED              5
#define IDS_INSTALL_COMPLETE            6
#define IDS_UNINSTALL_FAILED            7
#define IDS_UNINSTALL_COMPLETE          8
#define IDD_MAIN                        101
#define IDI_ICON                        102
#define IDC_PROGRESS                    1000
#define IDC_STATUS                      1002
#define IDC_LAUNCH                      1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst\exe\main.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Main.cpp

  Abstract:

    Provides the entry point for the application
    and the message loop.

  Notes:

    Unicode only - Windows 2000, XP & .NET Server

  History:

    01/02/2002   rparsons    Created

--*/
#include "main.h"

//
// This structure contains all the data that we'll need
// to access throughout the application.
//
APPINFO g_ai;

/*++

  Routine Description:

    Runs the message loop for the application.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK
MainWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:
    {
        HICON hIcon = LoadIcon(g_ai.hInstance, MAKEINTRESOURCE(IDI_ICON));
        
        SetClassLongPtr(hWnd, GCLP_HICON, (LONG_PTR)hIcon);
        
        if (g_ai.bQuiet) {
            ShowWindow(hWnd, SW_HIDE);
        } else {
            ShowWindow(hWnd, SW_SHOWNORMAL);
        }
        
        UpdateWindow(hWnd);
        PostMessage(hWnd, WM_CUSTOM_INSTALL, 0, 0);

        break;
     }

    case WM_CLOSE:
        EndDialog(hWnd, 0);
        PostQuitMessage(0);
        break;

    case WM_CUSTOM_INSTALL:
        PerformInstallation(hWnd);

        if (g_ai.bQuiet) {
            EndDialog(hWnd, 0);
            PostQuitMessage(0);
        }
        break;
            
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if (g_ai.bInstallSuccess) {
                InstallLaunchExe();
            }

            EndDialog(hWnd, 0);
            PostQuitMessage(0);
            break;
        
        default:
            break;                
        }

    default:
        break;

    }

    return FALSE;
}

/*++

  Routine Description:

    Application entry point.

  Arguments:

    hInstance        -    App instance handle.
    hPrevInstance    -    Always NULL.
    lpCmdLine        -    Pointer to the command line.
    nCmdShow         -    Window show flag.

  Return Value:

    0 on failure.

--*/
int
APIENTRY
wWinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPWSTR    lpCmdLine,
    IN int       nCmdShow
    )
{      
    MSG                     msg;
    WNDCLASS                wndclass;
    WCHAR                   wszError[MAX_PATH];
    INITCOMMONCONTROLSEX    icex;
            
    g_ai.hInstance = hInstance;

    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC)MainWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = APP_CLASS;

    if (lpCmdLine != NULL && lstrcmp(lpCmdLine, TEXT("q")) == 0) {
        g_ai.bQuiet = TRUE;
    }
    
    if (!RegisterClass(&wndclass) && !g_ai.bQuiet) {
        LoadString(hInstance, IDS_NO_CLASS, wszError, ARRAYSIZE(wszError));
        MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
        return 0;
    }

    //
    // Set up the common controls.
    // 
    icex.dwSize     =   sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC      =   ICC_PROGRESS_CLASS;

    if (!InitCommonControlsEx(&icex)) {
        InitCommonControls();
    }

    //
    // Initialize the installer. Get commonly used paths and save
    // them away for later.
    //
    UINT uReturn = InitializeInstaller();

    if (!g_ai.bQuiet) {
        if (-1 == uReturn) {
            LoadString(g_ai.hInstance, IDS_OS_NOT_SUPPORTED, wszError, ARRAYSIZE(wszError));
            MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
            return 0;
        } else if (0 == uReturn) {
            LoadString(g_ai.hInstance, IDS_INIT_FAILED, wszError, ARRAYSIZE(wszError));
            MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
            return 0;
        }
    }

    //
    // Initialize our structure that describes the files that
    // we're going to install.
    //
    if (!InitializeFileInfo()) {
        DPF(dlError, "[WinMain] Failed to initialize file info");
        return 0;
    }

    //
    // If the currently installed files are newer than what we have to
    // offer, launch the installed appverif.exe and quit.
    //
    if (!IsPkgAppVerifNewer() && !g_ai.bQuiet) {
        InstallLaunchExe();
        return 0;
    }

    //
    // Create the main dialog and run the message pump.
    //
    g_ai.hMainDlg = CreateDialog(hInstance,
                                 MAKEINTRESOURCE(IDD_MAIN),
                                 NULL,
                                 MainWndProc);

    if (!g_ai.hMainDlg) {
        LoadString(hInstance, IDS_NO_MAIN_DLG, wszError, ARRAYSIZE(wszError));
        MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
        return 0;
    }

    g_ai.hWndProgress = GetDlgItem(g_ai.hMainDlg, IDC_PROGRESS);
    
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) {
        if (!IsDialogMessage(g_ai.hMainDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    return (int)msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifier\vsaddin\testsettingsctrl.h ===
// TestSettingsCtrl.h : Declaration of the CTestSettingsCtrl
#pragma once
#include "resource.h"       // main symbols
#include <atlctl.h>
#include <set>
#include "AddIn.h"

// CTestSettingsCtrl
class ATL_NO_VTABLE CTestSettingsCtrl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ITestSettingsCtrl, &IID_ITestSettingsCtrl, &LIBID_AppVerifierLib, /*wMajor =*/ 1, /*wMinor =*/ 0>,
	public IPersistStreamInitImpl<CTestSettingsCtrl>,
	public IOleControlImpl<CTestSettingsCtrl>,
	public IOleObjectImpl<CTestSettingsCtrl>,
	public IOleInPlaceActiveObjectImpl<CTestSettingsCtrl>,
	public IViewObjectExImpl<CTestSettingsCtrl>,
	public IOleInPlaceObjectWindowlessImpl<CTestSettingsCtrl>,
	public CComCoClass<CTestSettingsCtrl, &CLSID_TestSettingsCtrl>,
	public CComCompositeControl<CTestSettingsCtrl>
{
public:

	CTestSettingsCtrl()
	{
        m_bLVCreated  = FALSE;
        m_bWindowOnly = TRUE;
		CalcExtent(m_sizeExtent);
	}

    virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

DECLARE_REGISTRY_RESOURCEID(IDR_TESTSETTINGSCTRL)

BEGIN_COM_MAP(CTestSettingsCtrl)
	COM_INTERFACE_ENTRY(ITestSettingsCtrl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CTestSettingsCtrl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()


BEGIN_MSG_MAP(CTestSettingsCtrl)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)

	CHAIN_MSG_MAP(CComCompositeControl<CTestSettingsCtrl>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

BEGIN_SINK_MAP(CTestSettingsCtrl)
	//Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		if (dispid == DISPID_AMBIENT_BACKCOLOR)
		{
			SetBackgroundColorFromAmbient();
			FireViewChange();
		}
		return IOleControlImpl<CTestSettingsCtrl>::OnAmbientPropertyChange(dispid);
	}
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ITestSettingsCtrl

	enum { IDD = IDD_TESTSETTINGSCTRL };

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

    BOOL m_bLVCreated;

    BOOL CheckForConflictingTests(
        IN HWND    hWndListView,
        IN LPCWSTR pwszTestName
        );

    BOOL CheckForRunAlone(
        IN HWND       hWndListView,
        IN CTestInfo* pTest
        );

    void DisplayRunAloneError(
        IN LPCWSTR pwszTestName
        );

    #define CHECK_BIT(x) ((x >> 12) - 1)
    
    #define CHECK_CHANGED(pNMListView) \
    (CHECK_BIT(pNMListView->uNewState) ^ CHECK_BIT(pNMListView->uOldState))

    BOOL IsChecked(
        NM_LISTVIEW* pNMListView
        );

    BOOL CheckChanged(
        NM_LISTVIEW* pNMListView
        );
};

struct CompareTests
{
  bool operator()(const CTestInfo* p1, const CTestInfo* p2) const
  {
    return p1 < p2;
  }
};

extern std::set<CTestInfo*, CompareTests>* g_psTests;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst\exe\fns.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Fns.cpp

  Abstract:

    Contains all of the functions used by the
    application.

  Notes:

    Unicode only - Windows 2000, XP & Server 2003

  History:

    01/02/2002  rparsons    Created
    01/08/2002  rparsons    Restructured a bit to add some
                            required functionality
    01/10/2002  rparsons    Change wsprintf to snwprintf
    01/18/2002  rparsons    Major changes - made more installer like
    02/15/2002  rparsons    Install SDBInst on W2K.
                            Include strsafe.
    04/19/2002  rparsons    Install different catalogs for Server 2003 & XP.                            

--*/
#include "main.h"

extern APPINFO g_ai;

/*++

Routine Description:

    Retrieve file version info from a file.

    The version is specified in the dwFileVersionMS and dwFileVersionLS fields
    of a VS_FIXEDFILEINFO, as filled in by the win32 version APIs.

    If the file is not a coff image or does not have version resources,
    the function fails.

Arguments:

    pwszFileName     -   Supplies the full path of the file whose version
                         data is desired.

    pdwlVersion      -   Receives the version stamp of the file.
                         If the file is not a coff image or does not contain
                         the appropriate version resource data, the function fails.
Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
GetVersionInfoFromImage(
    IN  LPWSTR     pwszFileName,
    OUT PDWORDLONG pdwlVersion
    )
{
    UINT                cchSize;
    DWORD               cbSize, dwIgnored;
    BOOL                bResult = FALSE;
    PVOID               pVersionBlock = NULL;
    VS_FIXEDFILEINFO*   pffi = NULL;

    if (!pwszFileName || !pdwlVersion) {
        DPF(dlError, "[GetVersionInfoFromImage] Invalid arguments");
        return FALSE;
    }

    cbSize = GetFileVersionInfoSize(pwszFileName, &dwIgnored);

    if (0 == cbSize) {
        DPF(dlError,
            "[GetVersionInfoFromImage] 0x%08X Failed to get version size",
            GetLastError());
        return FALSE;
    }

    //
    // Allocate memory block of sufficient size to hold version info block.
    //
    pVersionBlock = HeapAlloc(GetProcessHeap(),
                              HEAP_ZERO_MEMORY,
                              cbSize);

    if (!pVersionBlock) {
        DPF(dlError, "[GetVersionInfoFromImage] Unable to allocate memory");
        return FALSE;
    }

    //
    // Get the version block from the file.
    //
    if (!GetFileVersionInfo(pwszFileName,
                            0,
                            cbSize,
                            pVersionBlock)) {
        DPF(dlError,
            "[GetVersionInfoFromImage] 0x%08X Failed to get version info",
            GetLastError());
        goto exit;
    }

    //
    // Get fixed version info.
    //
    if (!VerQueryValue(pVersionBlock,
                       L"\\",
                       (LPVOID*)&pffi,
                       &cchSize)) {
        DPF(dlError,
            "[GetVersionInfoFromImage] 0x%08X Failed to fixed version info",
            GetLastError());
        goto exit;
    }

    //
    // Return version to caller.
    //
    *pdwlVersion = (((DWORDLONG)pffi->dwFileVersionMS) << 32) +
                    pffi->dwFileVersionLS;

    bResult = TRUE;

exit:

    if (pVersionBlock) {
        HeapFree(GetProcessHeap(), 0, pVersionBlock);
    }

    return bResult;
}

/*++

  Routine Description:

    Initializes our data structures with information about
    the files that we're installing/uninstalling.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
InitializeFileInfo(
    void
    )
{
    UINT    uCount = 0;
    HRESULT hr;

    //
    // Set up the information for each file.
    // I realize that a for loop seems much more suitable here,
    // but we have to match up the destination for each file.
    // Ideally, we would have a INF file to read from that tells
    // us where to install each file.
    // For now, copying and pasting is all we need to do.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_APPVERIF_EXE);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (1)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_APPVERIF_EXE,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (2)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\"FILENAME_APPVERIF_EXE,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (3)");
        return FALSE;
    }

    if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszSrcFileName,
                                 &g_ai.rgFileInfo[uCount].dwlSrcFileVersion)) {
        DPF(dlError,
            "[InitializeFileInfo] Failed to get version info for %ls",
            g_ai.rgFileInfo[uCount].wszSrcFileName);
            return FALSE;
    }

    if (GetFileAttributes(g_ai.rgFileInfo[uCount].wszDestFileName) != -1) {
        if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszDestFileName,
                                     &g_ai.rgFileInfo[uCount].dwlDestFileVersion)) {
            DPF(dlError,
                "[InitializeFileInfo] Failed to get version info for %ls",
                g_ai.rgFileInfo[uCount].wszDestFileName);
            return FALSE;
        }
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_APPVERIF_EXE_PDB);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (4)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_APPVERIF_EXE_PDB,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (5)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\"FILENAME_APPVERIF_EXE_PDB,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (6)");
        return FALSE;
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_APPVERIF_CHM);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (7)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                        ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                        L"%ls\\"FILENAME_APPVERIF_CHM,
                        g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (8)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\"FILENAME_APPVERIF_CHM,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (9)");
        return FALSE;
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_ACVERFYR_DLL);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (10)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_ACVERFYR_DLL,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (11)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\AppPatch\\"FILENAME_ACVERFYR_DLL,
                         g_ai.wszWinDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (12)");
        return FALSE;
    }

    if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszSrcFileName,
                                 &g_ai.rgFileInfo[uCount].dwlSrcFileVersion)) {
        DPF(dlError,
            "[InitializeFileInfo] Failed to get version info for %ls",
            g_ai.rgFileInfo[uCount].wszSrcFileName);
            return FALSE;
    }

    if (GetFileAttributes(g_ai.rgFileInfo[uCount].wszDestFileName) != -1) {
        if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszDestFileName,
                                     &g_ai.rgFileInfo[uCount].dwlDestFileVersion)) {
            DPF(dlError,
                "[InitializeFileInfo] Failed to get version info for %ls",
                g_ai.rgFileInfo[uCount].wszDestFileName);
            return FALSE;
        }
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_ACVERFYR_DLL_PDB);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (13)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_ACVERFYR_DLL_PDB,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (14)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\AppPatch\\"FILENAME_ACVERFYR_DLL_PDB,
                         g_ai.wszWinDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (15)");
        return FALSE;
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_ACVERFYR_DLL);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (16)");
        return FALSE;
    }

    g_ai.rgFileInfo[uCount].bWin2KOnly = TRUE;

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_ACVERFYR_DLL_W2K,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (17)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\AppPatch\\"FILENAME_ACVERFYR_DLL,
                         g_ai.wszWinDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (18)");
        return FALSE;
    }

    if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszSrcFileName,
                                 &g_ai.rgFileInfo[uCount].dwlSrcFileVersion)) {
        DPF(dlError,
            "[InitializeFileInfo] Failed to get version info for %ls",
            g_ai.rgFileInfo[uCount].wszSrcFileName);
            return FALSE;
    }

    if (GetFileAttributes(g_ai.rgFileInfo[uCount].wszDestFileName) != -1) {
        if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszDestFileName,
                                     &g_ai.rgFileInfo[uCount].dwlDestFileVersion)) {
            DPF(dlError,
                "[InitializeFileInfo] Failed to get version info for %ls",
                g_ai.rgFileInfo[uCount].wszDestFileName);
            return FALSE;
        }
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_ACVERFYR_DLL_PDB);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (19)");
        return FALSE;
    }

    g_ai.rgFileInfo[uCount].bWin2KOnly = TRUE;

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_ACVERFYR_DLL_W2K_PDB,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (20)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\AppPatch\\"FILENAME_ACVERFYR_DLL_PDB,
                         g_ai.wszWinDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (21)");
        return FALSE;
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_MSVCP60_DLL);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (22)");
        return FALSE;
    }

    g_ai.rgFileInfo[uCount].bWin2KOnly = TRUE;

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_MSVCP60_DLL,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (23)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\"FILENAME_MSVCP60_DLL,
                         g_ai.wszWinDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (24)");
        return FALSE;
    }

    if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszSrcFileName,
                                 &g_ai.rgFileInfo[uCount].dwlSrcFileVersion)) {
        DPF(dlError,
            "[InitializeFileInfo] Failed to get version info for %ls",
            g_ai.rgFileInfo[uCount].wszSrcFileName);
            return FALSE;
    }

    if (GetFileAttributes(g_ai.rgFileInfo[uCount].wszDestFileName) != -1) {
        if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszDestFileName,
                                     &g_ai.rgFileInfo[uCount].dwlDestFileVersion)) {
            DPF(dlError,
                "[InitializeFileInfo] Failed to get version info for %ls",
                g_ai.rgFileInfo[uCount].wszDestFileName);
            return FALSE;
        }
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_SDBINST_EXE);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (25)");
        return FALSE;
    }

    g_ai.rgFileInfo[uCount].bWin2KOnly = TRUE;

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_SDBINST_EXE,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (26)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\"FILENAME_SDBINST_EXE,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (27)");
        return FALSE;
    }

    if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszSrcFileName,
                                 &g_ai.rgFileInfo[uCount].dwlSrcFileVersion)) {
        DPF(dlError,
            "[InitializeFileInfo] Failed to get version info for %ls",
            g_ai.rgFileInfo[uCount].wszSrcFileName);
            return FALSE;
    }

    if (GetFileAttributes(g_ai.rgFileInfo[uCount].wszDestFileName) != -1) {
        if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszDestFileName,
                                     &g_ai.rgFileInfo[uCount].dwlDestFileVersion)) {
            DPF(dlError,
                "[InitializeFileInfo] Failed to get version info for %ls",
                g_ai.rgFileInfo[uCount].wszDestFileName);
            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Determines if any of the files we have to offer
    are newer than ones already installed.

  Arguments:

    None.

  Return Value:

    TRUE if we have at least one new file to offer.
    FALSE if we don't have at least one new file to offer.

--*/
BOOL
InstallCheckFileVersions(
    void
    )
{
    UINT    uCount;
    BOOL    bReturn = FALSE;

    for (uCount = 0; uCount < NUM_FILES; uCount++) {
        if (g_ai.rgFileInfo[uCount].dwlSrcFileVersion >=
            g_ai.rgFileInfo[uCount].dwlDestFileVersion) {
            g_ai.rgFileInfo[uCount].bInstall = TRUE;
            bReturn = TRUE;
        }
    }

    return bReturn;
}

/*++

  Routine Description:

    Determines if we have a newer version of appverif.exe
    or acverfyr.dll to offer.

  Arguments:

    None.

  Return Value:

    TRUE if our version is newer than the one installed.
    or if there is no version installed.
    FALSE otherwise.

--*/
BOOL
IsPkgAppVerifNewer(
    void
    )
{
    //
    // Check appverif.exe first.
    //
    if (g_ai.rgFileInfo[0].dwlSrcFileVersion >=
        g_ai.rgFileInfo[0].dwlDestFileVersion) {
        return TRUE;
    }

    //
    // Check acverfyr.dll if appverif.exe didn't pan out.
    // Do this based on the platform.
    //
    if (g_ai.ePlatform == osWindowsXP || g_ai.ePlatform == osWindowsDotNet) {
        if (g_ai.rgFileInfo[1].dwlSrcFileVersion >=
            g_ai.rgFileInfo[1].dwlDestFileVersion) {
            return TRUE;
        }
    } else {
        if (g_ai.rgFileInfo[2].dwlSrcFileVersion >=
            g_ai.rgFileInfo[2].dwlDestFileVersion) {
            return TRUE;
        }
    }

    //
    // Perhaps we have a newer version of sdbinst to offer.
    //
    if (g_ai.ePlatform == osWindows2000) {
        if (g_ai.rgFileInfo[8].dwlSrcFileVersion >=
            g_ai.rgFileInfo[8].dwlDestFileVersion) {
            return TRUE;
        }
    }

    return FALSE;
}

/*++

  Routine Description:

    Performs a file copy, even if it's in use.

  Arguments:

    pwszSourceFileName  -   Name of the source file to copy.
    pwszDestFileName    -   Name of the destination file to replace.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
ForceCopy(
    IN LPCWSTR pwszSourceFileName,
    IN LPCWSTR pwszDestFileName
    )
{
    WCHAR wszTempPath[MAX_PATH];
    WCHAR wszDelFileName[MAX_PATH];
    DWORD cchSize;

    if (!pwszSourceFileName || !pwszDestFileName) {
        DPF(dlError, "[ForceCopy] Invalid parameters");
        return FALSE;
    }

    DPF(dlInfo, "[ForceCopy] Source file: %ls", pwszSourceFileName);
    DPF(dlInfo, "[ForceCopy] Destination file: %ls", pwszDestFileName);

    if (!CopyFile(pwszSourceFileName, pwszDestFileName, FALSE)) {

        cchSize = GetTempPath(ARRAYSIZE(wszTempPath), wszTempPath);

        if (cchSize > ARRAYSIZE(wszTempPath) || cchSize == 0) {
            DPF(dlError, "[ForceCopy] Buffer for temp path is too small");
            return FALSE;
        }

        if (!GetTempFileName(wszTempPath, L"del", 0, wszDelFileName)) {
            DPF(dlError,
                "[ForceCopy] 0x%08X Failed to get temp file",
                GetLastError());
            return FALSE;
        }

        if (!MoveFileEx(pwszDestFileName,
                        wszDelFileName,
                        MOVEFILE_REPLACE_EXISTING)) {
            DPF(dlError,
                "[ForceCopy] 0x%08X Failed to replace file",
                GetLastError());
            return FALSE;
        }

        if (!MoveFileEx(wszDelFileName,
                        NULL,
                        MOVEFILE_DELAY_UNTIL_REBOOT)) {
            DPF(dlError,
                "[ForceCopy] 0x%08X Failed to delete file",
                GetLastError());
            return FALSE;
        }

        if (!CopyFile(pwszSourceFileName, pwszDestFileName, FALSE)) {
            DPF(dlError,
                "[ForceCopy] 0x%08X Failed to copy file",
                GetLastError());
            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Prints a formatted string to the debugger.

  Arguments:

    dwDetail    -   Specifies the level of the information provided.
    pszFmt      -   The string to be displayed.
    ...         -   A va_list of insertion strings.

  Return Value:

    None.

--*/
void
__cdecl
DebugPrintfEx(
    IN DEBUGLEVEL dwDetail,
    IN LPSTR      pszFmt,
    ...
    )
{
    char    szT[1024];
    va_list arglist;
    int     len;

    va_start(arglist, pszFmt);

    //
    // Reserve one character for the potential '\n' that we may be adding.
    //
    StringCchVPrintfA(szT, sizeof(szT) - 1, pszFmt, arglist);

    va_end(arglist);

    //
    // Make sure we have a '\n' at the end of the string
    //
    len = strlen(szT);

    if (len > 0 && szT[len - 1] != '\n')  {
        szT[len] = '\n';
        szT[len + 1] = 0;
    }

    switch (dwDetail) {
    case dlPrint:
        DbgPrint("[MSG ] ");
        break;

    case dlError:
        DbgPrint("[FAIL] ");
        break;

    case dlWarning:
        DbgPrint("[WARN] ");
        break;

    case dlInfo:
        DbgPrint("[INFO] ");
        break;

    default:
        DbgPrint("[XXXX] ");
        break;
    }

    DbgPrint("%s", szT);
}

/*++

  Routine Description:

    Initializes the installer. Sets up paths, version
    information, etc.

  Arguments:

    None.

  Return Value:

    TRUE on success.
    FALSE on failure.
    -1 if the operating system is not supported.

--*/
int
InitializeInstaller(
    void
    )
{
    OSVERSIONINFO   osvi;
    WCHAR*          pTemp = NULL;
    UINT            cchSize;
    DWORD           cchReturned;
    HRESULT         hr;

    //
    // Find out what operating system we're running on.
    //
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi)) {
        DPF(dlError,
            "[InitializeInstaller] 0x%08X Failed to get OS version info",
            GetLastError());
        return FALSE;
    }

    //
    // No support for Win9x or NT4.
    //
    if (osvi.dwMajorVersion == 4) {
        DPF(dlInfo, "[InitializeInstaller] OS not supported");
        return -1;
    }

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {
        g_ai.ePlatform = osWindows2000;
    } else if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1) {
        g_ai.ePlatform = osWindowsXP;
    } else if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion >= 2) {
        g_ai.ePlatform = osWindowsDotNet;
    }

    //
    // Find out where we're running from.
    //
    g_ai.wszModuleName[ARRAYSIZE(g_ai.wszModuleName) - 1] = 0;
    cchReturned = GetModuleFileName(NULL,
                                    g_ai.wszModuleName,
                                    ARRAYSIZE(g_ai.wszModuleName));

    if (g_ai.wszModuleName[ARRAYSIZE(g_ai.wszModuleName) - 1] != 0 ||
        cchReturned == 0) {
        DPF(dlError,
            "[InitializeInstaller] 0x%08X Failed to get module file name",
            GetLastError());
        return FALSE;
    }

    //
    // Save away our current directory for later use.
    //
    hr = StringCchCopy(g_ai.wszCurrentDir,
                       ARRAYSIZE(g_ai.wszCurrentDir),
                       g_ai.wszModuleName);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeInstaller] 0x%08X String copy failed", hr);
        return FALSE;
    }

    pTemp = wcsrchr(g_ai.wszCurrentDir, '\\');

    if (pTemp) {
        *pTemp = 0;
    }

    //
    // Save away paths to the Windows & System32 directories for later use.
    //
    cchSize = GetSystemWindowsDirectory(g_ai.wszWinDir,
                                        ARRAYSIZE(g_ai.wszWinDir));

    if (cchSize > ARRAYSIZE(g_ai.wszWinDir) || cchSize == 0) {
        DPF(dlError,
            "[InitializeInstaller] 0x%08X Failed to get Windows directory",
            GetLastError());
        return FALSE;
    }

    cchSize = GetSystemDirectory(g_ai.wszSysDir, ARRAYSIZE(g_ai.wszSysDir));

    if (cchSize > ARRAYSIZE(g_ai.wszSysDir) || cchSize == 0) {
        DPF(dlError,
            "[InitializeInstaller] 0x%08X Failed to get system directory",
            GetLastError());
        return FALSE;
    }

    return TRUE;
}

/*++

  Routine Description:

    Launches the Application Verifier.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
InstallLaunchExe(
    void
    )
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               wszAppVerifExe[MAX_PATH];
    HRESULT             hr;

    hr = StringCchPrintf(wszAppVerifExe,
                         ARRAYSIZE(wszAppVerifExe),
                         L"%ls\\"FILENAME_APPVERIF_EXE,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InstallLaunchExe] Buffer too small");
        return;
    }

    ZeroMemory(&si, sizeof(STARTUPINFO));
    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

    si.cb = sizeof(STARTUPINFO);

    if (!CreateProcess(wszAppVerifExe,
                       NULL,
                       NULL,
                       NULL,
                       FALSE,
                       0,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {
        DPF(dlError,
            "[InstallLaunchExe] 0x%08X Failed to launch %ls",
            GetLastError(),
            wszAppVerifExe);
        return;
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

/*++

  Routine Description:

    Installs the catalog file.

  Arguments:

    pwszCatFileName -   Name of the catalog file to install.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
InstallCatalogFile(
    IN LPWSTR pwszCatFileName
    )
{
    HCATADMIN   hCatAdmin;
    HCATINFO    hCatInfo;
    GUID        guidCatRoot;

    if (!pwszCatFileName) {
        DPF(dlError, "[InstallCatalogFile] Invalid parameter");
        return FALSE;
    }

    StringToGuid(L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}", &guidCatRoot);

    if (!CryptCATAdminAcquireContext(&hCatAdmin, &guidCatRoot, 0)) {
        DPF(dlError,
            "[InstallCatalogFile] 0x%08X Failed to acquire context",
            GetLastError());
        return FALSE;
    }

    hCatInfo = CryptCATAdminAddCatalog(hCatAdmin,
                                       pwszCatFileName,
                                       NULL,
                                       0);

    if (hCatInfo) {
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        CryptCATAdminReleaseContext(hCatAdmin, 0);
        return TRUE;
    }

    CryptCATAdminReleaseContext(hCatAdmin, 0);

    DPF(dlError,
        "[InstallCatalogFile] 0x%08X Failed to add catalog %ls",
        GetLastError(),
        pwszCatFileName);

    return FALSE;
}

/*++

  Routine Description:

    Installs a certificate into the certificate store.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
InstallCertificateFile(
    void
    )
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               wszCertMgrName[MAX_PATH];
    WCHAR               wszCertMgrCmdLine[MAX_PATH];
    HRESULT             hr;

    ZeroMemory(&si, sizeof(STARTUPINFO));
    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

    si.cb = sizeof(STARTUPINFO);

    //
    // Set up the path to certmgr.exe.
    //
    hr = StringCchPrintf(wszCertMgrName,
                         ARRAYSIZE(wszCertMgrName),
                         L"%ls\\"CERTMGR_EXE,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InstallCertificateFile] Buffer too small (1)");
        return FALSE;
    }

    //
    // Set up the command-line for certmgr.exe.
    //
    hr = StringCchPrintf(wszCertMgrCmdLine,
                         ARRAYSIZE(wszCertMgrCmdLine),
                         L"%ls\\%ls %ls",
                         g_ai.wszCurrentDir,
                         CERTMGR_EXE,
                         CERTMGR_CMD);

    if (FAILED(hr)) {
        DPF(dlError, "[InstallCertificateFile] Buffer too small (2)");
        return FALSE;
    }

    if (!CreateProcess(wszCertMgrName,
                       wszCertMgrCmdLine,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_NO_WINDOW | NORMAL_PRIORITY_CLASS,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {

        DPF(dlError,
            "[InstallCertificateFile] 0x%08X Failed to launch '%ls %ls'",
            GetLastError(),
            wszCertMgrName,
            wszCertMgrCmdLine);
        return FALSE;
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return TRUE;
}

/*++

  Routine Description:

    Performs the installation of the catalog file
    on Windows XP or Windows Server 2003.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
PerformCatalogInstall(
    void
    )
{
    WCHAR   wszCatalog[MAX_PATH];
    HRESULT hr;

    if (g_ai.ePlatform == osWindowsXP) {
        hr = StringCchPrintf(wszCatalog,
                             ARRAYSIZE(wszCatalog),
                             L"%ls\\"FILENAME_DELTA_CAT_XP,
                             g_ai.wszCurrentDir);
    
    } else if (g_ai.ePlatform == osWindowsDotNet) {
        hr = StringCchPrintf(wszCatalog,
                             ARRAYSIZE(wszCatalog),
                             L"%ls\\"FILENAME_DELTA_CAT_DOTNET,
                             g_ai.wszCurrentDir);
    }

    if (FAILED(hr)) {
        DPF(dlError, "[PerformCatalogInstall] Buffer too small");
        return FALSE;
    }

    return (InstallCatalogFile(wszCatalog));
}

/*++

  Routine Description:

    Copies the files that we've determined are
    newer to their specified destination.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
InstallCopyFiles(
    void
    )
{
    UINT    uCount;

    while (TRUE) {
        for (uCount = 0; uCount < NUM_FILES; uCount++) {
            if (g_ai.rgFileInfo[uCount].bInstall) {
                //
                // If we're on XP and the file is not specifically for
                // Windows 2000, copy it over.
                //
                if (g_ai.ePlatform != osWindows2000 &&
                    g_ai.rgFileInfo[uCount].bWin2KOnly) {
                    break;
                }

                if (!ForceCopy(g_ai.rgFileInfo[uCount].wszSrcFileName,
                               g_ai.rgFileInfo[uCount].wszDestFileName)) {
                    DPF(dlError,
                        "[InstallCopyFiles] Failed to copy %ls to %ls",
                        g_ai.rgFileInfo[uCount].wszSrcFileName,
                        g_ai.rgFileInfo[uCount].wszDestFileName);
                    return FALSE;
                }
            }
        }

        break;
    }

    return TRUE;
}

/*++

  Routine Description:

    Performs the installation. This is the main routine
    for the install.

  Arguments:

    hWndParent  -   Parent window handle for message boxes.

  Return Value:

    None.

--*/
void
PerformInstallation(
    IN HWND hWndParent
    )
{
    WCHAR   wszError[MAX_PATH];

    SendMessage(g_ai.hWndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, NUM_PB_STEPS));
    SendMessage(g_ai.hWndProgress, PBM_SETSTEP, 1, 0);

    //
    // Initialize our structure with new files that need to be installed.
    // This should not fail because we've already performed a check and
    // it told us that we had new files to install.
    //
    if (!InstallCheckFileVersions()) {
        DPF(dlError, "[PerformInstallation] Failed to check file versions");
        goto InstallError;
    }

    //
    // If we're running on Windows XP or Server 2003, install a catalog file
    // and our certificate. We have different catalogs for XP versus Server 2003.
    //
    if (g_ai.ePlatform == osWindowsXP || g_ai.ePlatform == osWindowsDotNet) {
        if (!PerformCatalogInstall()) {
            DPF(dlError, "[PerformInstallation] Failed to install catalog");
            goto InstallError;
        }

        SendMessage(g_ai.hWndProgress, PBM_STEPIT, 0, 0);

        if (!InstallCertificateFile()) {
            DPF(dlError, "[PerformInstallation] Failed to install certificate");
            goto InstallError;
        }
    }

    SendMessage(g_ai.hWndProgress, PBM_STEPIT, 0, 0);

    if (!InstallCopyFiles()) {
        DPF(dlError, "[PerformInstallation] Failed to copy files");
        goto InstallError;
    }

    SendMessage(g_ai.hWndProgress, PBM_STEPIT, 0, 0);

    DPF(dlInfo, "[PerformInstallation] Installation completed successfully");

    g_ai.bInstallSuccess = TRUE;

    //
    // Install successful.
    //
    SendMessage(g_ai.hWndProgress, PBM_SETPOS, NUM_PB_STEPS, 0);
    LoadString(g_ai.hInstance, IDS_INSTALL_COMPLETE, wszError, ARRAYSIZE(wszError));
    SetDlgItemText(hWndParent, IDC_STATUS, wszError);
    EnableWindow(GetDlgItem(hWndParent, IDOK), TRUE);
    ShowWindow(GetDlgItem(hWndParent, IDC_LAUNCH), SW_SHOW);

    return;

InstallError:
    SendMessage(g_ai.hWndProgress, PBM_SETPOS, NUM_PB_STEPS, 0);
    LoadString(g_ai.hInstance, IDS_INSTALL_FAILED, wszError, ARRAYSIZE(wszError));
    SetDlgItemText(hWndParent, IDC_STATUS, wszError);
    EnableWindow(GetDlgItem(hWndParent, IDCANCEL), TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst\exe\guid.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Guid.cpp

  Abstract:

    Functions for converting strings to GUIDs.

    Taken from \\index2\sdnt\ds\security\cryptoapi\common\unicode\guid.cpp

  Notes:

    Unicode only - Windows 2000, XP & .NET Server

  History:

    01/02/2002   rparsons    Created

--*/
#include "main.h"

static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR wszDigits[] = L"0123456789ABCDEF";

static
BOOL
HexStringToDword(
    IN LPCWSTR FAR& pwsz,
    IN DWORD   FAR& Value,
    IN int          cDigits,
    IN WCHAR        chDelim
    )
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, pwsz++)
    {
        if (*pwsz >= '0' && *pwsz <= '9')
        {
            Value = (Value << 4) + *pwsz - '0';
        }
        else if (*pwsz >= 'A' && *pwsz <= 'F')
        {
            Value = (Value << 4) + *pwsz - 'A' + 10;
        }
        else if (*pwsz >= 'a' && *pwsz <= 'f')
        {
            Value = (Value << 4) + *pwsz - 'a' + 10;
        }
        else
        {
            return(FALSE);
        }
    }

    if (chDelim != 0)
    {
        return *pwsz++ == chDelim;
    }
    else
    {
        return(TRUE);
    }
}

BOOL
StringToGuid(
    IN  LPCWSTR pwszIn,
    OUT GUID*   pgOut
    )
{
    if (!(pwszIn) || !(pgOut))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (*pwszIn != '{') // only support v2 guids!
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (wcslen(pwszIn) != 38)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    WCHAR   *pwsz;

    pwsz = (WCHAR *)&pwszIn[1];  // pass the first {

    memset(pgOut, 0x00, sizeof(GUID));

    DWORD dw;

    if (!(HexStringToDword(pwsz, pgOut->Data1, sizeof(DWORD)*2, '-')))
    {
        return(FALSE);
    }

    if (!(HexStringToDword(pwsz, dw, sizeof(WORD)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data2 = (WORD)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(WORD)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data3 = (WORD)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[0] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data4[1] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[2] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[3] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[4] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[5] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[6] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[7] = (BYTE)dw;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst\package\makefile.inc ===
copyfiles:   
   copyreqfiles.cmd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst64\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avrfinst.rc
//
#define IDS_NO_CLASS                    1
#define IDS_NO_MAIN_DLG                 2
#define IDS_OS_NOT_SUPPORTED            3
#define IDS_INIT_FAILED                 4
#define IDS_INSTALL_FAILED              5
#define IDS_INSTALL_COMPLETE            6
#define IDS_UNINSTALL_FAILED            7
#define IDS_UNINSTALL_COMPLETE          8
#define IDD_MAIN                        101
#define IDI_ICON                        102
#define IDC_PROGRESS                    1000
#define IDC_STATUS                      1002
#define IDC_LAUNCH                      1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst64\package\makefile.inc ===
copyfiles:   
   copyreqfiles.cmd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst\exe\main.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

	Main.h

  Abstract:

	Contains constants, function prototypes,
    structures, and other items used by
    the application.

  Notes:

	Unicode only - Windows 2000, XP & .NET Server

  History:

	01/02/2002   rparsons    Created

--*/
#ifndef _AVRFINST_H
#define _AVRFINST_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <capi.h>       // Crypto API functions
#include <wincrypt.h>   // Crypto API functions
#include <mscat.h>      // Catalog functions
#include <mssip.h>      // Catalog functions
#include <stdio.h>
#include <strsafe.h>
#include "resource.h"

//
// Macro to calculate the size of a buffer.
//
#define ARRAYSIZE(a)                    (sizeof(a)/sizeof(a[0]))

//
// Number of progress bar steps.
//
#define NUM_PB_STEPS                    3

//
// Custom message for installation.
//
#define WM_CUSTOM_INSTALL               WM_APP + 0x500

//
// General constants.
//
#define APP_CLASS                       L"AVRFINST"
#define APP_NAME                        L"Application Verifier Installer"

//
// Catalog related filenames.
//
#define FILENAME_DELTA_CDF_DOTNET       L"delta_net.cdf"
#define FILENAME_DELTA_CAT_DOTNET       L"delta_net.cat"

#define FILENAME_DELTA_CDF_XP           L"delta_xp.cdf"
#define FILENAME_DELTA_CAT_XP           L"delta_xp.cat"

//
// The number of files that we'll be installing.
//
#define NUM_FILES                       9

//
// Source and destination filenames.
//
#define FILENAME_APPVERIF_EXE           L"appverif.exe"
#define FILENAME_APPVERIF_EXE_PDB       L"appverif.pdb"
#define FILENAME_APPVERIF_CHM           L"appverif.chm"
#define FILENAME_ACVERFYR_DLL           L"acverfyr.dll"
#define FILENAME_ACVERFYR_DLL_PDB       L"acverfyr.pdb"
#define FILENAME_ACVERFYR_DLL_W2K       L"acverfyr_w2K.dll"
#define FILENAME_ACVERFYR_DLL_W2K_PDB   L"acverfyr_w2K.pdb"
#define FILENAME_MSVCP60_DLL            L"msvcp60.dll"
#define FILENAME_SDBINST_EXE            L"sdbinst.exe"

//
// Command to execute to install the certificate file.
//
#define CERTMGR_EXE L"certmgr.exe"
#define CERTMGR_CMD L"-add testroot.cer -r localMachine -s root"

typedef enum {
    dlNone     = 0,
    dlPrint,
    dlError,
    dlWarning,
    dlInfo
} DEBUGLEVEL;

void
__cdecl
DebugPrintfEx(
    IN DEBUGLEVEL dwDetail,
    IN LPSTR      pszFmt,
    ...
    );

#define DPF DebugPrintfEx

//
// Contains information about the files that will be installed/uninstalled
// by the application.
//
typedef struct _FILEINFO {
    BOOL        bInstall;                   // indicates that this file should be installed
    BOOL        bWin2KOnly;                 // indicates that the file should be installed on W2K only
    WCHAR       wszFileName[MAX_PATH];      // the name of the file (no path)
    WCHAR       wszSrcFileName[MAX_PATH];   // the full path and name of the source file
    WCHAR       wszDestFileName[MAX_PATH];  // the full path and name of the destination file
    DWORDLONG   dwlSrcFileVersion;          // the version information of the source file
    DWORDLONG   dwlDestFileVersion;         // the version information of the destination file
} FILEINFO, *LPFILEINFO;

typedef enum {
    osWindows2000 = 0,
    osWindowsXP,
    osWindowsDotNet
} PLATFORM;

//
// Contains all the information that we'll need to access throughout
// the application.
//
typedef struct _APPINFO {
    BOOL        bQuiet;                     // if TRUE the install should run quietly
    BOOL        bInstallSuccess;            // if TRUE the install was successful; if FALSE it was not
    HWND        hMainDlg;                   // main dialog handle
    HWND        hWndProgress;               // progress bar handle
    HINSTANCE   hInstance;                  // main instance handle
    WCHAR       wszModuleName[MAX_PATH];    // directory that we're running from (includes module name)
    WCHAR       wszCurrentDir[MAX_PATH];    // directory that we're running from (no module name)
    WCHAR       wszWinDir[MAX_PATH];        // path to the Windows directory
    WCHAR       wszSysDir[MAX_PATH];        // path to the (terminal server aware) Windows\System32 directory
    FILEINFO    rgFileInfo[NUM_FILES];      // array of FILEINFO structs that describe files to install
    PLATFORM    ePlatform;                  // indicates that platform we're running on
} APPINFO, *LPAPPINFO;

int
InitializeInstaller(
    void
    );

BOOL
InitializeFileInfo(
    void
    );

void
PerformInstallation(
    IN HWND hWndParent
    );

BOOL
StringToGuid(
    IN  LPCWSTR pwszIn,
    OUT GUID*   pgOut
    );

void
InstallLaunchExe(
    void
    );

BOOL
IsPkgAppVerifNewer(
    void
    );

#endif // _AVRFINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst64\exe\guid.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Guid.cpp

  Abstract:

    Functions for converting strings to GUIDs.

    Taken from \\index2\sdnt\ds\security\cryptoapi\common\unicode\guid.cpp

  Notes:

    Unicode only - Windows 2000 & XP

  History:

    01/02/2002   rparsons    Created

--*/
#include "main.h"

static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR wszDigits[] = L"0123456789ABCDEF";

static
BOOL
HexStringToDword(
    IN LPCWSTR FAR& pwsz,
    IN DWORD   FAR& Value,
    IN int          cDigits,
    IN WCHAR        chDelim
    )
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, pwsz++)
    {
        if (*pwsz >= '0' && *pwsz <= '9')
        {
            Value = (Value << 4) + *pwsz - '0';
        }
        else if (*pwsz >= 'A' && *pwsz <= 'F')
        {
            Value = (Value << 4) + *pwsz - 'A' + 10;
        }
        else if (*pwsz >= 'a' && *pwsz <= 'f')
        {
            Value = (Value << 4) + *pwsz - 'a' + 10;
        }
        else
        {
            return(FALSE);
        }
    }

    if (chDelim != 0)
    {
        return *pwsz++ == chDelim;
    }
    else
    {
        return(TRUE);
    }
}

BOOL
StringToGuid(
    IN  LPCWSTR pwszIn,
    OUT GUID*   pgOut
    )
{
    if (!(pwszIn) || !(pgOut))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (*pwszIn != '{') // only support v2 guids!
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (wcslen(pwszIn) != 38)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    WCHAR   *pwsz;

    pwsz = (WCHAR *)&pwszIn[1];  // pass the first {

    memset(pgOut, 0x00, sizeof(GUID));

    DWORD dw;

    if (!(HexStringToDword(pwsz, pgOut->Data1, sizeof(DWORD)*2, '-')))
    {
        return(FALSE);
    }

    if (!(HexStringToDword(pwsz, dw, sizeof(WORD)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data2 = (WORD)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(WORD)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data3 = (WORD)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[0] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data4[1] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[2] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[3] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[4] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[5] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[6] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[7] = (BYTE)dw;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst64\exe\fns.cpp ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

    Fns.cpp

  Abstract:

    Contains all of the functions used by the
    application.

  Notes:

    Unicode only - Windows 2000 & XP

  History:

    01/02/2002  rparsons    Created
    01/08/2002  rparsons    Restructured a bit to add some
                            required functionality
    01/10/2002  rparsons    Change wsprintf to snwprintf
    01/18/2002  rparsons    Major changes - made more installer like
    02/15/2002  rparsons    Install SDBInst on W2K.
                            Include strsafe.

--*/
#include "main.h"

extern APPINFO g_ai;

/*++

Routine Description:

    Retrieve file version info from a file.

    The version is specified in the dwFileVersionMS and dwFileVersionLS fields
    of a VS_FIXEDFILEINFO, as filled in by the win32 version APIs.

    If the file is not a coff image or does not have version resources,
    the function fails.

Arguments:

    pwszFileName     -   Supplies the full path of the file whose version
                         data is desired.

    pdwlVersion      -   Receives the version stamp of the file.
                         If the file is not a coff image or does not contain
                         the appropriate version resource data, the function fails.
Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
GetVersionInfoFromImage(
    IN  LPWSTR     pwszFileName,
    OUT PDWORDLONG pdwlVersion
    )
{
    UINT                cchSize;
    DWORD               cbSize, dwIgnored;
    BOOL                bResult = FALSE;
    PVOID               pVersionBlock = NULL;
    VS_FIXEDFILEINFO*   pffi = NULL;

    if (!pwszFileName || !pdwlVersion) {
        DPF(dlError, "[GetVersionInfoFromImage] Invalid arguments");
        return FALSE;
    }

    cbSize = GetFileVersionInfoSize(pwszFileName, &dwIgnored);

    if (0 == cbSize) {
        DPF(dlError,
            "[GetVersionInfoFromImage] 0x%08X Failed to get version size",
            GetLastError());
        return FALSE;
    }

    //
    // Allocate memory block of sufficient size to hold version info block.
    //
    pVersionBlock = HeapAlloc(GetProcessHeap(),
                              HEAP_ZERO_MEMORY,
                              cbSize);

    if (!pVersionBlock) {
        DPF(dlError, "[GetVersionInfoFromImage] Unable to allocate memory");
        return FALSE;
    }

    //
    // Get the version block from the file.
    //
    if (!GetFileVersionInfo(pwszFileName,
                            0,
                            cbSize,
                            pVersionBlock)) {
        DPF(dlError,
            "[GetVersionInfoFromImage] 0x%08X Failed to get version info",
            GetLastError());
        goto exit;
    }

    //
    // Get fixed version info.
    //
    if (!VerQueryValue(pVersionBlock,
                       L"\\",
                       (LPVOID*)&pffi,
                       &cchSize)) {
        DPF(dlError,
            "[GetVersionInfoFromImage] 0x%08X Failed to fixed version info",
            GetLastError());
        goto exit;
    }

    //
    // Return version to caller.
    //
    *pdwlVersion = (((DWORDLONG)pffi->dwFileVersionMS) << 32) +
                    pffi->dwFileVersionLS;

    bResult = TRUE;

exit:

    if (pVersionBlock) {
        HeapFree(GetProcessHeap(), 0, pVersionBlock);
    }

    return bResult;
}

/*++

  Routine Description:

    Initializes our data structures with information about
    the files that we're installing/uninstalling.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
InitializeFileInfo(
    void
    )
{
    UINT    uCount = 0;
    HRESULT hr;

    //
    // Set up the information for each file.
    // I realize that a for loop seems much more suitable here,
    // but we have to match up the destination for each file.
    // Ideally, we would have a INF file to read from that tells
    // us where to install each file.
    // For now, copying and pasting is all we need to do.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_APPVERIF_EXE);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (1)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_APPVERIF_EXE,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (2)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\"FILENAME_APPVERIF_EXE,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (3)");
        return FALSE;
    }

    if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszSrcFileName,
                                 &g_ai.rgFileInfo[uCount].dwlSrcFileVersion)) {
        DPF(dlError,
            "[InitializeFileInfo] Failed to get version info for %ls",
            g_ai.rgFileInfo[uCount].wszSrcFileName);
            return FALSE;
    }

    if (GetFileAttributes(g_ai.rgFileInfo[uCount].wszDestFileName) != -1) {
        if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszDestFileName,
                                     &g_ai.rgFileInfo[uCount].dwlDestFileVersion)) {
            DPF(dlError,
                "[InitializeFileInfo] Failed to get version info for %ls",
                g_ai.rgFileInfo[uCount].wszDestFileName);
            return FALSE;
        }
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_APPVERIF_EXE_PDB);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (4)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_APPVERIF_EXE_PDB,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (5)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\"FILENAME_APPVERIF_EXE_PDB,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (6)");
        return FALSE;
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_APPVERIF_CHM);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (7)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                        ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                        L"%ls\\"FILENAME_APPVERIF_CHM,
                        g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (8)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\"FILENAME_APPVERIF_CHM,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (9)");
        return FALSE;
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_ACVERFYR_DLL);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (10)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_ACVERFYR_DLL,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (11)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\AppPatch\\IA64\\"FILENAME_ACVERFYR_DLL,
                         g_ai.wszWinDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (12)");
        return FALSE;
    }

    if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszSrcFileName,
                                 &g_ai.rgFileInfo[uCount].dwlSrcFileVersion)) {
        DPF(dlError,
            "[InitializeFileInfo] Failed to get version info for %ls",
            g_ai.rgFileInfo[uCount].wszSrcFileName);
            return FALSE;
    }

    if (GetFileAttributes(g_ai.rgFileInfo[uCount].wszDestFileName) != -1) {
        if (!GetVersionInfoFromImage(g_ai.rgFileInfo[uCount].wszDestFileName,
                                     &g_ai.rgFileInfo[uCount].dwlDestFileVersion)) {
            DPF(dlError,
                "[InitializeFileInfo] Failed to get version info for %ls",
                g_ai.rgFileInfo[uCount].wszDestFileName);
            return FALSE;
        }
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_ACVERFYR_DLL_PDB);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (13)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_ACVERFYR_DLL_PDB,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (14)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\AppPatch\\ia64\\"FILENAME_ACVERFYR_DLL_PDB,
                         g_ai.wszWinDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (15)");
        return FALSE;
    }

    uCount++;

    //
    // Next file.
    //
    hr = StringCchCopy(g_ai.rgFileInfo[uCount].wszFileName,
                       ARRAYSIZE(g_ai.rgFileInfo[uCount].wszFileName),
                       FILENAME_SYSMAIN_SDB);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (13)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszSrcFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszSrcFileName),
                         L"%ls\\"FILENAME_SYSMAIN_SDB,
                         g_ai.wszCurrentDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (14)");
        return FALSE;
    }

    hr = StringCchPrintf(g_ai.rgFileInfo[uCount].wszDestFileName,
                         ARRAYSIZE(g_ai.rgFileInfo[uCount].wszDestFileName),
                         L"%ls\\AppPatch\\ia64\\"FILENAME_SYSMAIN_SDB,
                         g_ai.wszWinDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeFileInfo] Buffer too small (15)");
        return FALSE;
    }

    return TRUE;
}

/*++

  Routine Description:

    Determines if any of the files we have to offer
    are newer than ones already installed.

  Arguments:

    None.

  Return Value:

    TRUE if we have at least one new file to offer.
    FALSE if we don't have at least one new file to offer.

--*/
BOOL
InstallCheckFileVersions(
    void
    )
{
    UINT    uCount;
    BOOL    bReturn = FALSE;

    for (uCount = 0; uCount < NUM_FILES; uCount++) {
        if (g_ai.rgFileInfo[uCount].dwlSrcFileVersion >=
            g_ai.rgFileInfo[uCount].dwlDestFileVersion) {
            g_ai.rgFileInfo[uCount].bInstall = TRUE;
            bReturn = TRUE;
        }
    }

    return bReturn;
}

/*++

  Routine Description:

    Determines if we have a newer version of appverif.exe
    or acverfyr.dll to offer.

  Arguments:

    None.

  Return Value:

    TRUE if our version is newer than the one installed.
    or if there is no version installed.
    FALSE otherwise.

--*/
BOOL
IsPkgAppVerifNewer(
    void
    )
{
    //
    // Check appverif.exe first.
    //
    if (g_ai.rgFileInfo[0].dwlSrcFileVersion >=
        g_ai.rgFileInfo[0].dwlDestFileVersion) {
        return TRUE;
    }

    //
    // Check acverfyr.dll if appverif.exe didn't pan out.
    // Do this based on the platform.
    //
    if (g_ai.rgFileInfo[1].dwlSrcFileVersion >=
        g_ai.rgFileInfo[1].dwlDestFileVersion) {
        return TRUE;
    }

    return FALSE;
}

/*++

  Routine Description:

    Performs a file copy, even if it's in use.

  Arguments:

    pwszSourceFileName  -   Name of the source file to copy.
    pwszDestFileName    -   Name of the destination file to replace.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
ForceCopy(
    IN LPCWSTR pwszSourceFileName,
    IN LPCWSTR pwszDestFileName
    )
{
    WCHAR wszTempPath[MAX_PATH];
    WCHAR wszDelFileName[MAX_PATH];
    DWORD cchSize;

    if (!pwszSourceFileName || !pwszDestFileName) {
        DPF(dlError, "[ForceCopy] Invalid parameters");
        return FALSE;
    }

    DPF(dlInfo, "[ForceCopy] Source file: %ls", pwszSourceFileName);
    DPF(dlInfo, "[ForceCopy] Destination file: %ls", pwszDestFileName);

    if (!CopyFile(pwszSourceFileName, pwszDestFileName, FALSE)) {

        cchSize = GetTempPath(ARRAYSIZE(wszTempPath), wszTempPath);

        if (cchSize > ARRAYSIZE(wszTempPath) || cchSize == 0) {
            DPF(dlError, "[ForceCopy] Buffer for temp path is too small");
            return FALSE;
        }

        if (!GetTempFileName(wszTempPath, L"del", 0, wszDelFileName)) {
            DPF(dlError,
                "[ForceCopy] 0x%08X Failed to get temp file",
                GetLastError());
            return FALSE;
        }

        if (!MoveFileEx(pwszDestFileName,
                        wszDelFileName,
                        MOVEFILE_REPLACE_EXISTING)) {
            DPF(dlError,
                "[ForceCopy] 0x%08X Failed to replace file",
                GetLastError());
            return FALSE;
        }

        if (!MoveFileEx(wszDelFileName,
                        NULL,
                        MOVEFILE_DELAY_UNTIL_REBOOT)) {
            DPF(dlError,
                "[ForceCopy] 0x%08X Failed to delete file",
                GetLastError());
            return FALSE;
        }

        if (!CopyFile(pwszSourceFileName, pwszDestFileName, FALSE)) {
            DPF(dlError,
                "[ForceCopy] 0x%08X Failed to copy file",
                GetLastError());
            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Prints a formatted string to the debugger.

  Arguments:

    dwDetail    -   Specifies the level of the information provided.
    pszFmt      -   The string to be displayed.
    ...         -   A va_list of insertion strings.

  Return Value:

    None.

--*/
void
__cdecl
DebugPrintfEx(
    IN DEBUGLEVEL dwDetail,
    IN LPSTR      pszFmt,
    ...
    )
{
    char    szT[1024];
    va_list arglist;
    int     len;

    va_start(arglist, pszFmt);

    //
    // Reserve one character for the potential '\n' that we may be adding.
    //
    StringCchVPrintfA(szT, sizeof(szT) - 1, pszFmt, arglist);

    va_end(arglist);

    //
    // Make sure we have a '\n' at the end of the string
    //
    len = strlen(szT);

    if (len > 0 && szT[len - 1] != '\n')  {
        szT[len] = '\n';
        szT[len + 1] = 0;
    }

    switch (dwDetail) {
    case dlPrint:
        DbgPrint("[MSG ] ");
        break;

    case dlError:
        DbgPrint("[FAIL] ");
        break;

    case dlWarning:
        DbgPrint("[WARN] ");
        break;

    case dlInfo:
        DbgPrint("[INFO] ");
        break;

    default:
        DbgPrint("[XXXX] ");
        break;
    }

    DbgPrint("%s", szT);
}

/*++

  Routine Description:

    Initializes the installer. Sets up paths, version
    information, etc.

  Arguments:

    None.

  Return Value:

    TRUE on success.
    FALSE on failure.
    -1 if the operating system is not supported.

--*/
int
InitializeInstaller(
    void
    )
{
    OSVERSIONINFO   osvi;
    WCHAR*          pTemp = NULL;
    UINT            cchSize;
    DWORD           cchReturned;
    HRESULT         hr;

    //
    // Find out what operating system we're running on.
    //
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi)) {
        DPF(dlError,
            "[InitializeInstaller] 0x%08X Failed to get OS version info",
            GetLastError());
        return FALSE;
    }

    //
    // Check for supported OS.
    //
    if (osvi.dwMajorVersion < 5 ||
        osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {
        DPF(dlInfo, "[InitializeInstaller] OS not supported");
        return -1;
    }
    
    //
    // Find out where we're running from.
    //
    g_ai.wszModuleName[ARRAYSIZE(g_ai.wszModuleName) - 1] = 0;
    cchReturned = GetModuleFileName(NULL,
                                    g_ai.wszModuleName,
                                    ARRAYSIZE(g_ai.wszModuleName));

    if (g_ai.wszModuleName[ARRAYSIZE(g_ai.wszModuleName) - 1] != 0 ||
        cchReturned == 0) {
        DPF(dlError,
            "[InitializeInstaller] 0x%08X Failed to get module file name",
            GetLastError());
        return FALSE;
    }

    //
    // Save away our current directory for later use.
    //
    hr = StringCchCopy(g_ai.wszCurrentDir,
                       ARRAYSIZE(g_ai.wszCurrentDir),
                       g_ai.wszModuleName);

    if (FAILED(hr)) {
        DPF(dlError, "[InitializeInstaller] 0x%08X String copy failed", hr);
        return FALSE;
    }

    pTemp = wcsrchr(g_ai.wszCurrentDir, '\\');

    if (pTemp) {
        *pTemp = 0;
    }

    //
    // Save away paths to the Windows & System32 directories for later use.
    //
    cchSize = GetSystemWindowsDirectory(g_ai.wszWinDir,
                                        ARRAYSIZE(g_ai.wszWinDir));

    if (cchSize > ARRAYSIZE(g_ai.wszWinDir) || cchSize == 0) {
        DPF(dlError,
            "[InitializeInstaller] 0x%08X Failed to get Windows directory",
            GetLastError());
        return FALSE;
    }

    cchSize = GetSystemDirectory(g_ai.wszSysDir, ARRAYSIZE(g_ai.wszSysDir));

    if (cchSize > ARRAYSIZE(g_ai.wszSysDir) || cchSize == 0) {
        DPF(dlError,
            "[InitializeInstaller] 0x%08X Failed to get system directory",
            GetLastError());
        return FALSE;
    }

    return TRUE;
}

/*++

  Routine Description:

    Launches the Application Verifier.

  Arguments:

    None.

  Return Value:

    None.

--*/
void
InstallLaunchExe(
    void
    )
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               wszAppVerifExe[MAX_PATH];
    HRESULT             hr;

    hr = StringCchPrintf(wszAppVerifExe,
                         ARRAYSIZE(wszAppVerifExe),
                         L"%ls\\"FILENAME_APPVERIF_EXE,
                         g_ai.wszSysDir);

    if (FAILED(hr)) {
        DPF(dlError, "[InstallLaunchExe] Buffer too small");
        return;
    }

    ZeroMemory(&si, sizeof(STARTUPINFO));
    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

    si.cb = sizeof(STARTUPINFO);

    if (!CreateProcess(wszAppVerifExe,
                       NULL,
                       NULL,
                       NULL,
                       FALSE,
                       0,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {
        DPF(dlError,
            "[InstallLaunchExe] 0x%08X Failed to launch %ls",
            GetLastError(),
            wszAppVerifExe);
        return;
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

/*++

  Routine Description:

    Installs the catalog file.

  Arguments:

    pwszCatFileName -   Name of the catalog file to install.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
InstallCatalogFile(
    IN LPWSTR pwszCatFileName
    )
{
    HCATADMIN   hCatAdmin;
    HCATINFO    hCatInfo;
    GUID        guidCatRoot;

    if (!pwszCatFileName) {
        DPF(dlError, "[InstallCatalogFile] Invalid parameter");
        return FALSE;
    }

    StringToGuid(L"{F750E6C3-38EE-11D1-85E5-00C04FC295EE}", &guidCatRoot);

    if (!CryptCATAdminAcquireContext(&hCatAdmin, &guidCatRoot, 0)) {
        DPF(dlError,
            "[InstallCatalogFile] 0x%08X Failed to acquire context",
            GetLastError());
        return FALSE;
    }

    hCatInfo = CryptCATAdminAddCatalog(hCatAdmin,
                                       pwszCatFileName,
                                       NULL,
                                       0);

    if (hCatInfo) {
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        CryptCATAdminReleaseContext(hCatAdmin, 0);
        return TRUE;
    }

    CryptCATAdminReleaseContext(hCatAdmin, 0);

    DPF(dlError,
        "[InstallCatalogFile] 0x%08X Failed to add catalog %ls",
        GetLastError(),
        pwszCatFileName);

    return FALSE;
}

/*++

  Routine Description:

    Copies the files that we've determined are
    newer to their specified destination.

  Arguments:

    None.

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
InstallCopyFiles(
    void
    )
{
    UINT    uCount;

    while (TRUE) {
        for (uCount = 0; uCount < NUM_FILES; uCount++) {
            if (g_ai.rgFileInfo[uCount].bInstall) {

                if (!ForceCopy(g_ai.rgFileInfo[uCount].wszSrcFileName,
                               g_ai.rgFileInfo[uCount].wszDestFileName)) {
                    DPF(dlError,
                        "[InstallCopyFiles] Failed to copy %ls to %ls",
                        g_ai.rgFileInfo[uCount].wszSrcFileName,
                        g_ai.rgFileInfo[uCount].wszDestFileName);
                    return FALSE;
                }
            }
        }

        break;
    }

    return TRUE;
}

/*++

  Routine Description:

    Performs the installation. This is the main routine
    for the install.

  Arguments:

    hWndParent  -   Parent window handle for message boxes.

  Return Value:

    None.

--*/
void
PerformInstallation(
    IN HWND hWndParent
    )
{
    WCHAR   wszError[MAX_PATH];

    SendMessage(g_ai.hWndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, NUM_PB_STEPS));
    SendMessage(g_ai.hWndProgress, PBM_SETSTEP, 1, 0);

    //
    // Initialize our structure with new files that need to be installed.
    // This should not fail because we've already performed a check and
    // it told us that we had new files to install.
    //
    if (!InstallCheckFileVersions()) {
        DPF(dlError, "[PerformInstallation] Failed to check file versions");
        goto InstallError;
    }

    SendMessage(g_ai.hWndProgress, PBM_STEPIT, 0, 0);

    if (!InstallCopyFiles()) {
        DPF(dlError, "[PerformInstallation] Failed to copy files");
        goto InstallError;
    }

    SendMessage(g_ai.hWndProgress, PBM_STEPIT, 0, 0);

    DPF(dlInfo, "[PerformInstallation] Installation completed successfully");

    g_ai.bInstallSuccess = TRUE;

    //
    // Install successful.
    //
    SendMessage(g_ai.hWndProgress, PBM_SETPOS, NUM_PB_STEPS, 0);
    LoadString(g_ai.hInstance, IDS_INSTALL_COMPLETE, wszError, ARRAYSIZE(wszError));
    SetDlgItemText(hWndParent, IDC_STATUS, wszError);
    EnableWindow(GetDlgItem(hWndParent, IDOK), TRUE);
    ShowWindow(GetDlgItem(hWndParent, IDC_LAUNCH), SW_SHOW);

    return;

InstallError:
    SendMessage(g_ai.hWndProgress, PBM_SETPOS, NUM_PB_STEPS, 0);
    LoadString(g_ai.hInstance, IDS_INSTALL_FAILED, wszError, ARRAYSIZE(wszError));
    SetDlgItemText(hWndParent, IDC_STATUS, wszError);
    EnableWindow(GetDlgItem(hWndParent, IDCANCEL), TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst64\exe\main.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights reserved.

  Module Name:

	Main.h

  Abstract:

	Contains constants, function prototypes,
    structures, and other items used by
    the application.

  Notes:

	Unicode only - Windows 2000 & XP

  History:

	01/02/2002   rparsons    Created

--*/
#ifndef _AVRFINST_H
#define _AVRFINST_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <capi.h>       // Crypto API functions
#include <wincrypt.h>   // Crypto API functions
#include <mscat.h>      // Catalog functions
#include <mssip.h>      // Catalog functions
#include <stdio.h>
#include <strsafe.h>
#include "resource.h"

//
// Macro to calculate the size of a buffer.
//
#define ARRAYSIZE(a)                    (sizeof(a)/sizeof(a[0]))

//
// Number of progress bar steps.
//
#define NUM_PB_STEPS                    3

//
// Custom message for installation.
//
#define WM_CUSTOM_INSTALL               WM_APP + 0x500

//
// General constants.
//
#define APP_CLASS                       L"AVRFINST"
#define APP_NAME                        L"Application Verifier Installer IA64"

//
// The number of files that we'll be installing.
//
#define NUM_FILES                       6

//
// Source and destination filenames.
//
#define FILENAME_APPVERIF_EXE           L"appverif.exe"
#define FILENAME_APPVERIF_EXE_PDB       L"appverif.pdb"
#define FILENAME_APPVERIF_CHM           L"appverif.chm"
#define FILENAME_ACVERFYR_DLL           L"acverfyr.dll"
#define FILENAME_ACVERFYR_DLL_PDB       L"acverfyr.pdb"
#define FILENAME_SYSMAIN_SDB            L"sysmain.sdb"


typedef enum {
    dlNone     = 0,
    dlPrint,
    dlError,
    dlWarning,
    dlInfo
} DEBUGLEVEL;

void
__cdecl
DebugPrintfEx(
    IN DEBUGLEVEL dwDetail,
    IN LPSTR      pszFmt,
    ...
    );

#define DPF DebugPrintfEx

//
// Contains information about the files that will be installed/uninstalled
// by the application.
//
typedef struct _FILEINFO {
    BOOL        bInstall;                   // indicates that this file should be installed
    WCHAR       wszFileName[MAX_PATH];      // the name of the file (no path)
    WCHAR       wszSrcFileName[MAX_PATH];   // the full path and name of the source file
    WCHAR       wszDestFileName[MAX_PATH];  // the full path and name of the destination file
    DWORDLONG   dwlSrcFileVersion;          // the version information of the source file
    DWORDLONG   dwlDestFileVersion;         // the version information of the destination file
} FILEINFO, *LPFILEINFO;

//
// Contains all the information that we'll need to access throughout
// the application.
//
typedef struct _APPINFO {
    BOOL        bQuiet;                     // if TRUE the install should run quietly
    BOOL        bInstallSuccess;            // if TRUE the install was successful; if FALSE it was not
    HWND        hMainDlg;                   // main dialog handle
    HWND        hWndProgress;               // progress bar handle
    HINSTANCE   hInstance;                  // main instance handle
    WCHAR       wszModuleName[MAX_PATH];    // directory that we're running from (includes module name)
    WCHAR       wszCurrentDir[MAX_PATH];    // directory that we're running from (no module name)
    WCHAR       wszWinDir[MAX_PATH];        // path to the Windows directory
    WCHAR       wszSysDir[MAX_PATH];        // path to the (terminal server aware) Windows\System32 directory
    FILEINFO    rgFileInfo[NUM_FILES];
} APPINFO, *LPAPPINFO;

int
InitializeInstaller(
    void
    );

BOOL
InitializeFileInfo(
    void
    );

void
PerformInstallation(
    IN HWND hWndParent
    );

BOOL
StringToGuid(
    IN  LPCWSTR pwszIn,
    OUT GUID*   pgOut
    );

void
InstallLaunchExe(
    void
    );

BOOL
IsPkgAppVerifNewer(
    void
    );

#endif // _AVRFINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\appverifinst64\exe\main.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Main.cpp

  Abstract:

    Provides the entry point for the application
    and the message loop.

  Notes:

    Unicode only - Windows 2000 & XP

  History:

    01/02/2002   rparsons    Created

--*/
#include "main.h"

//
// This structure contains all the data that we'll need
// to access throughout the application.
//
APPINFO g_ai;

/*++

  Routine Description:

    Runs the message loop for the application.

  Arguments:

    hWnd        -    Handle to the window.
    uMsg        -    Windows message.
    wParam      -    Additional message info.
    lParam      -    Additional message info.

  Return Value:

    TRUE if handled, FALSE otherwise.

--*/
INT_PTR
CALLBACK
MainWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 
    case WM_INITDIALOG:
    {
        HICON hIcon = LoadIcon(g_ai.hInstance, MAKEINTRESOURCE(IDI_ICON));
        
        SetClassLongPtr(hWnd, GCLP_HICON, (LONG_PTR)hIcon);
        
        if (g_ai.bQuiet) {
            ShowWindow(hWnd, SW_HIDE);
        } else {
            ShowWindow(hWnd, SW_SHOWNORMAL);
        }
        
        UpdateWindow(hWnd);
        PostMessage(hWnd, WM_CUSTOM_INSTALL, 0, 0);

        break;
     }

    case WM_CLOSE:
        EndDialog(hWnd, 0);
        PostQuitMessage(0);
        break;

    case WM_CUSTOM_INSTALL:
        PerformInstallation(hWnd);

        if (g_ai.bQuiet) {
            EndDialog(hWnd, 0);
            PostQuitMessage(0);
        }
        break;
            
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if (g_ai.bInstallSuccess) {
                InstallLaunchExe();
            }

            EndDialog(hWnd, 0);
            PostQuitMessage(0);
            break;
        
        default:
            break;                
        }

    default:
        break;

    }

    return FALSE;
}

/*++

  Routine Description:

    Application entry point.

  Arguments:

    hInstance        -    App instance handle.
    hPrevInstance    -    Always NULL.
    lpCmdLine        -    Pointer to the command line.
    nCmdShow         -    Window show flag.

  Return Value:

    0 on failure.

--*/
int
APIENTRY
wWinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPWSTR    lpCmdLine,
    IN int       nCmdShow
    )
{      
    MSG                     msg;
    WNDCLASS                wndclass;
    WCHAR                   wszError[MAX_PATH];
    INITCOMMONCONTROLSEX    icex;
            
    g_ai.hInstance = hInstance;

    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = MainWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = APP_CLASS;

    if (lpCmdLine != NULL && lstrcmp(lpCmdLine, TEXT("q")) == 0) {
        g_ai.bQuiet = TRUE;
    }
    
    if (!RegisterClass(&wndclass) && !g_ai.bQuiet) {
        LoadString(hInstance, IDS_NO_CLASS, wszError, ARRAYSIZE(wszError));
        MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
        return 0;
    }

    //
    // Set up the common controls.
    // 
    icex.dwSize     =   sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC      =   ICC_PROGRESS_CLASS;

    if (!InitCommonControlsEx(&icex)) {
        InitCommonControls();
    }

    //
    // Initialize the installer. Get commonly used paths and save
    // them away for later.
    //
    UINT uReturn = InitializeInstaller();

    if (!g_ai.bQuiet) {
        if (-1 == uReturn) {
            LoadString(g_ai.hInstance, IDS_OS_NOT_SUPPORTED, wszError, ARRAYSIZE(wszError));
            MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
            return 0;
        } else if (0 == uReturn) {
            LoadString(g_ai.hInstance, IDS_INIT_FAILED, wszError, ARRAYSIZE(wszError));
            MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
            return 0;
        }
    }

    //
    // Initialize our structure that describes the files that
    // we're going to install.
    //
    if (!InitializeFileInfo()) {
        DPF(dlError, "[WinMain] Failed to initialize file info");
        return 0;
    }

    //
    // If the currently installed files are newer than what we have to
    // offer, launch the installed appverif.exe and quit.
    //
    if (!IsPkgAppVerifNewer() && !g_ai.bQuiet) {
        InstallLaunchExe();
        return 0;
    }

    //
    // Create the main dialog and run the message pump.
    //
    g_ai.hMainDlg = CreateDialog(hInstance,
                                 MAKEINTRESOURCE(IDD_MAIN),
                                 NULL,
                                 MainWndProc);

    if (!g_ai.hMainDlg) {
        LoadString(hInstance, IDS_NO_MAIN_DLG, wszError, ARRAYSIZE(wszError));
        MessageBox(NULL, wszError, APP_NAME, MB_ICONERROR);
        return 0;
    }

    g_ai.hWndProgress = GetDlgItem(g_ai.hMainDlg, IDC_PROGRESS);
    
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) {
        if (!IsDialogMessage(g_ai.hMainDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    return (int)msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\compatui.cpp ===
// CompatUI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CompatUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <commctrl.h>
#include "CompatUI.h"
#include "CompatUI_i.c"
#include "ProgView.h"
#include "util.h"
#include "SelectFile.h"
#include "shfusion.h"
#include "Upload.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ProgView, CProgView)
OBJECT_ENTRY(CLSID_Util, CUtil)
OBJECT_ENTRY(CLSID_SelectFile, CSelectFile)
OBJECT_ENTRY(CLSID_Upload, CUpload)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {

#ifndef NO_FUSION
        BOOL bFusionInit;

        bFusionInit = SHFusionInitializeFromModuleID(hInstance,124);
        ATLTRACE(TEXT("Fusion init 0x%lx\n"), bFusionInit);           
#endif
        _Module.Init(ObjectMap, hInstance, &LIBID_COMPATUILib);
        
        DisableThreadLibraryCalls(hInstance);


    }
    else if (dwReason == DLL_PROCESS_DETACH) {

        _Module.Term();

#ifndef NO_FUSION
        SHFusionUninitialize();
#endif

    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\accelcontainer.h ===
// AccelContainer.h: interface for the CAccelContainer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACCELCONTAINER_H__DEBE6100_DEDC_41E0_995A_67D2922897D0__INCLUDED_)
#define AFX_ACCELCONTAINER_H__DEBE6100_DEDC_41E0_995A_67D2922897D0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

///////////////////////////////// STL 

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <algorithm>
#include <vector>
#include <set>

using namespace std;

/////////////////////////////////////

class CAccelContainer  
{
public:
    CAccelContainer() {}
    virtual ~CAccelContainer() {}


    typedef vector<ACCEL > ACCELVECTOR;

    ACCELVECTOR m_Accel;        // accelerators
    
    CAccelContainer& operator=(LPCTSTR lpszStr) {
        SetAccel(lpszStr);
        return *this;
    }

    void SetAccel(LPCTSTR lpszStr, WORD wCmd = 0) {
        ParseAccelString(lpszStr, wCmd);
    }

    void ClearAccel() {
        m_Accel.erase(m_Accel.begin(), m_Accel.end());
    }

    VOID ParseAccelString(LPCTSTR lpszStr, WORD wCmd);
    BOOL IsAccelKey(LPMSG pMsg, WORD* pCmd = NULL);

    int GetCount() {
        return m_Accel.size();
    }
    const ACCEL& GetAccel(int nPos) {
        return m_Accel[nPos];
    }

    wstring GetKeyFromAccel(const ACCEL& accel);

    wstring GetAccelString(WORD wCmd = 0) {
        ACCELVECTOR::iterator iter;
        wstring strAccel;

        for (iter = m_Accel.begin(); iter != m_Accel.end(); ++iter) {
            const ACCEL& accel = *iter;
            if (accel.cmd == wCmd) {
                strAccel += GetKeyFromAccel(accel);
            }
        }
        return strAccel;
    }

};

#endif // !defined(AFX_ACCELCONTAINER_H__DEBE6100_DEDC_41E0_995A_67D2922897D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\accelcontainer.cpp ===
// AccelContainer.cpp: implementation of the CAccelContainer class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AccelContainer.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

typedef struct _VKEYS { 
    LPCTSTR pKeyName; 
    WORD    virtKey;
} VKEYS; 
 
VKEYS vkeys[] = { 
    TEXT("BkSp"), VK_BACK,
    TEXT("PgUp"), VK_PRIOR,    
    TEXT("PgDn"), VK_NEXT,
    TEXT("End"),  VK_END,
    TEXT("Home"), VK_HOME, 
    TEXT("Left"), VK_LEFT, 
    TEXT("Up"),   VK_UP, 
    TEXT("Right"),VK_RIGHT, 
    TEXT("Down"), VK_DOWN, 
    TEXT("Ins"),  VK_INSERT, 
    TEXT("Del"),  VK_DELETE, 
    TEXT("Mult"), VK_MULTIPLY, 
    TEXT("Add"),  VK_ADD, 
    TEXT("Sub"),  VK_SUBTRACT, 
    TEXT("DecPt"),VK_DECIMAL, 
    TEXT("Div"),  VK_DIVIDE, 
    TEXT("F2"),   VK_F2, 
    TEXT("F3"),   VK_F3, 
    TEXT("F5"),   VK_F5, 
    TEXT("F6"),   VK_F6, 
    TEXT("F7"),   VK_F7, 
    TEXT("F8"),   VK_F8, 
    TEXT("F9"),   VK_F9, 
    TEXT("F10"),  VK_F10,
    TEXT("F11"),  VK_F11, 
    TEXT("F12"),  VK_F12 
}; 

wstring CAccelContainer::GetKeyFromAccel(const ACCEL& accel)
{
    int i;
    wstring strAccel((LPCTSTR)&accel.key, 1);
    
    
    for (i = 0; i < sizeof(vkeys)/sizeof(vkeys[0]); ++i) {
        if (vkeys[i].virtKey == accel.key) {
            strAccel = vkeys[i].pKeyName;
            break;
        }
    }

    return strAccel;
}


BOOL CAccelContainer::IsAccelKey(LPMSG pMsg, WORD* pCmd) 
{
    ACCELVECTOR::iterator iter;
    WORD fVirtKey = 0;
    //
    //
    if (NULL == pMsg) {
        fVirtKey |= (GetKeyState(VK_MENU)    & 0x8000) ? FALT : 0;
        fVirtKey |= (GetKeyState(VK_CONTROL) & 0x8000) ? FCONTROL : 0;
        fVirtKey |= (GetKeyState(VK_SHIFT)   & 0x8000) ? FSHIFT : 0;
        fVirtKey |= FVIRTKEY;
        
        for (iter = m_Accel.begin(); iter != m_Accel.end(); ++iter) {
            const ACCEL& accl = *iter;            
            
            if (GetKeyState(accl.key) & 0x8000) {
                //
                // pressed! see if we have a match
                //
                if (fVirtKey == accl.fVirt) {
                    // 
                    // we do have a match 
                    //
                    if (pCmd) {
                        *pCmd = accl.cmd;
                    }
                    return TRUE;

                }    
            }
        }
    } else {

        // one of the nasty messages ?
        if (pMsg->message == WM_SYSKEYDOWN || pMsg->message == WM_SYSKEYUP) {
            fVirtKey = (pMsg->lParam & 0x20000000) ? FALT : 0;
            fVirtKey |= FVIRTKEY; // always a virtkey code
                        
            for (iter = m_Accel.begin(); iter != m_Accel.end(); ++iter) {
                const ACCEL& accl = *iter;            
            
                if (pMsg->wParam == accl.key) {
                    //
                    // pressed! see if we have a match
                    //
                    if (fVirtKey == accl.fVirt) {
                        // 
                        // we do have a match 
                        //
                        if (pCmd) {
                            *pCmd = accl.cmd;
                        }
                        return TRUE;

                    }    
                }
            }            
        }

    }

    return FALSE;

}



VOID CAccelContainer::ParseAccelString(LPCTSTR lpszStr, WORD wCmd) 
{
    LPCTSTR pch = lpszStr;
    LPCTSTR pchEnd, pchb;
    ACCEL   accl;

    //
    // nuke all
    // 
    
    

    while (*pch) {

        //
        // skip whitespace 
        //
        pch += _tcsspn(pch, TEXT(" \t"));

        //
        // see what kind of key this is
        //
        if (*pch == TEXT('{')) {
            // some special key
            ++pch;
            pch += _tcsspn(pch, TEXT(" \t"));

            int i;
            for (i = 0; i < sizeof(vkeys)/sizeof(vkeys[0]); ++i) {
                int nLen = _tcslen(vkeys[i].pKeyName);
                if (!_tcsnicmp(pch, vkeys[i].pKeyName, nLen)) {
                    // aha -- we have a match
                    //
                    accl.cmd   = wCmd;
                    accl.fVirt = FALT|FVIRTKEY;
                    accl.key   = vkeys[i].virtKey;
                    m_Accel.push_back(accl);

                    pch += nLen;
                    pch += _tcsspn(pch, TEXT(" \t"));
                    break;
                }
            }

            pchEnd = _tcschr(pch, '}');
            pchb   = _tcschr(pch, '{');
            if (pchEnd != NULL && (pchb == NULL || pchEnd < pchb)) {
                pch = pchEnd + 1; // one past the bracket
            }

            // what if we have not succeeded - and no closing bracket ? 
            // we skip the bracket and go ahead as character


        } else if (_istalnum(*pch)) { // normal key

            TCHAR ch = _totupper(*pch);
            accl.cmd   = wCmd;
            accl.fVirt = FALT|FVIRTKEY;
            accl.key   = ch; 
            
            m_Accel.push_back(accl);
            ++pch;
        } else {
            ++pch; // skip the char, we can't recognize it
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\ntutil.c ===
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _WINDOWS
#include <windows.h>
#include "shimdb.h"


//
// Routine in ahcache.c
//

BOOL 
SDBAPI
ApphelpUpdateCacheEntry(
    LPCWSTR pwszPath,           // nt path
    HANDLE  hFile,              // file handle 
    BOOL    bDeleteEntry,       // TRUE if we are to delete the entry
    BOOL    bNTPath             // if TRUE -- NT path, FALSE - dos path
    );

//
//
// Global stuff used elsewhere
//

VOID
InvalidateAppcompatCacheEntry(
    LPCWSTR pwszDosPath
    )
{
    ApphelpUpdateCacheEntry(pwszDosPath, INVALID_HANDLE_VALUE, TRUE, FALSE);
}

//
// Determine if a file is in the root or if the file is in the leaf
//

BOOL
WINAPI
CheckFileLocation(
    LPCWSTR pwszDosPath,
    BOOL* pbRoot,
    BOOL* pbLeaf
    )
{
    BOOL            TranslationStatus;
    UNICODE_STRING  PathName;
    PWSTR           FileName = NULL;
    RTL_PATH_TYPE   PathType;
    WIN32_FIND_DATA FindData;
    BOOL            bLeaf;
    BOOL            bSuccess = FALSE;
    WCHAR           wszFileName[MAX_PATH];  
    PWSTR           FreeBuffer = NULL;
    NTSTATUS        Status;
    ULONG           Length;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    static LPCWSTR  pwszPrefixWin32 = TEXT("\\??\\"); // std win32 path prefix
    static LPCWSTR  pwszPrefixUNC   = TEXT("\\UNC\\");
    UCHAR           DosPathBuffer[MAX_PATH*2];
    RTL_UNICODE_STRING_BUFFER DosPath;

    RtlInitUnicodeStringBuffer(&DosPath, DosPathBuffer, sizeof(DosPathBuffer));
    
    TranslationStatus = RtlDosPathNameToNtPathName_U(pwszDosPath,
                                                     &PathName,
                                                     &FileName,
                                                     NULL);
    if (!TranslationStatus) {
        goto cleanup;
    }

    FreeBuffer = PathName.Buffer;

    if (FileName == NULL) {
        goto cleanup;
    }

    PathName.Length = (USHORT)((ULONG_PTR)FileName - (ULONG_PTR)PathName.Buffer);
    wcscpy(wszFileName, FileName);

    //
    // path name is ready for open -- sanitize the '\\'
    //
    if (PathName.Length > 2 * sizeof(WCHAR)) {
        if (RTL_STRING_GET_LAST_CHAR(&PathName) == L'\\' &&
            RTL_STRING_GET_AT(&PathName, RTL_STRING_GET_LENGTH_CHARS(&PathName) - 2) != L':') {
            PathName.Length -= sizeof(UNICODE_NULL);
        }
    }

   
    Status = RtlGetLengthWithoutLastFullDosOrNtPathElement(0, &PathName, &Length);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (Length == wcslen(pwszPrefixWin32)) { // this is root path of whatever kind you think it is
        *pbRoot = TRUE;
    }

    //
    // check if this is a leaf node in fact
    // the way we know is this:
    // - if it's the only file in that node
    // - there are no other files / subdirectories in this directory
    //

    // append * to the path name

    if (PathName.MaximumLength < PathName.Length + 2 * sizeof(WCHAR)) {
        goto cleanup;
    }

    RtlAppendUnicodeToString(&PathName, 
                             RTL_STRING_GET_LAST_CHAR(&PathName) == TEXT('\\') ? TEXT("*") : TEXT("\\*"));

    // convert the string to dos path
    Status = RtlAssignUnicodeStringBuffer(&DosPath, &PathName);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }
    
    Status = RtlNtPathNameToDosPathName(0, &DosPath, NULL, NULL);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    hFind = FindFirstFileW(DosPath.String.Buffer, &FindData);
    if (hFind == INVALID_HANDLE_VALUE) {
        // we should at least have found a file we came here with
        goto cleanup;
    }

    bLeaf = TRUE;
    do {
        // check for . and ..
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (wcscmp(FindData.cFileName, TEXT(".")) == 0 || wcscmp(FindData.cFileName, TEXT(".."))) {
                continue;
            }
            bLeaf = FALSE;
            break;
        }

        // ok, we are the file, make sure we're not the same file
        //
        if (_wcsicmp(FindData.cFileName, FileName) != 0) {
            bLeaf = FALSE;
            break;
        }

    } while (FindNextFileW(hFind, &FindData));

    *pbLeaf = bLeaf;
    bSuccess = TRUE;

cleanup:


    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
    }

    if (FreeBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }

    RtlFreeUnicodeStringBuffer(&DosPath);
    
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\compatuicp.h ===
#ifndef _COMPATUICP_H_
#define _COMPATUICP_H_

template <class T>
class CProxy_IProgViewEvents : public IConnectionPointImpl<T, &DIID__IProgViewEvents, CComDynamicUnkArray>
{
    //Warning this class may be recreated by the wizard.
public:
    HRESULT Fire_DblClk(LONG lFlags)
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[1];

        if (pvars == NULL) {
            return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        varResult.scode = S_OK;

        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                pvars[0] = lFlags;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        delete[] pvars;
        return varResult.scode;

    }


    HRESULT Fire_ProgramListReady()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        varResult.scode = S_OK;

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        return varResult.scode;

    }
};

template <class T>
class CProxy_ISelectFileEvents : public IConnectionPointImpl<T, &DIID__ISelectFileEvents, CComDynamicUnkArray>
{
    //Warning this class may be recreated by the wizard.
public:
    HRESULT Fire_SelectionComplete()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        varResult.scode = S_OK;

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        return varResult.scode;

    }
    HRESULT Fire_StateChanged(LONG lState)
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[1];

        if (pvars == NULL) {
            return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        varResult.scode = S_OK;

        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                pvars[0] = lState;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        delete[] pvars;
        return varResult.scode;

    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\progview.cpp ===
// ProgView.cpp : Implementation of CProgView

#include "stdafx.h"
#include <commctrl.h>
#include "CompatUI.h"
#include "ProgView.h"

/////////////////////////////////////////////////////////////////////////////
// CProgView

HRESULT
CProgView::InPlaceActivate(
    LONG iVerb,
    const RECT* prcPosRect
    )
{
    HRESULT hr = CComCompositeControl<CProgView>::InPlaceActivate(iVerb, prcPosRect);


/*
    //
    // this code below might be useful in order to deal with accelerators
    // but ie host does not appear to be paying any attention
    //

    CComPtr<IOleControlSite> spCtlSite;
    HRESULT hRet = InternalGetSite(IID_IOleControlSite, (void**)&spCtlSite);
    if (SUCCEEDED(hRet)) {
        spCtlSite->OnControlInfoChanged();
    }
*/

    return hr;
}

LRESULT
CProgView::OnNotifyListView(
    int     idCtrl,
    LPNMHDR pnmh,
    BOOL&   bHandled
    )
{

    if (idCtrl != IDC_LISTPROGRAMS) {
        bHandled = FALSE;
        return 0;
    }

    // see that we get the notification to fill-in the details
    return NotifyProgramList(m_pProgramList, pnmh, bHandled);
}

LRESULT
CProgView::OnDblclkListprograms(
    int      idCtrl,
    LPNMHDR  pnmh,
    BOOL&    bHandled)
{
    LPNMITEMACTIVATE lpnmh;

    if (idCtrl != IDC_LISTPROGRAMS) {
        bHandled = FALSE;
        return 0;
    }

    // we have a double-click !

    lpnmh = (LPNMITEMACTIVATE)pnmh;

    Fire_DblClk((LONG)lpnmh->uKeyFlags);
    bHandled = TRUE;
    return 0;
}



STDMETHODIMP CProgView::GetSelectedItem()
{

    GetProgramListSelection(m_pProgramList);
    return S_OK;
}

STDMETHODIMP CProgView::get_SelectionName(VARIANT*pVal)
{
    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    GetProgramListSelectionDetails(m_pProgramList, 0, pVal);

    return S_OK;
}


STDMETHODIMP CProgView::GetSelectionInformation(LONG lInformationClass, VARIANT *pVal)
{
    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    GetProgramListSelectionDetails(m_pProgramList, lInformationClass, pVal);
    return S_OK;
}

VOID
CProgView::ShowProgressWindows(BOOL bProgress)
{
    HDWP hDefer = ::BeginDeferWindowPos(4);

    if (!hDefer){
        return;
    }

    DWORD dwProgressFlag = bProgress ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;
    DWORD dwListFlag     = bProgress ? SWP_HIDEWINDOW : SWP_SHOWWINDOW;

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(IDC_ANIMATEFIND), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(IDC_STATUSLINE1), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(IDC_STATUSLINE2), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(IDC_LISTPROGRAMS), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwListFlag);


    EndDeferWindowPos(hDefer);

}

STDMETHODIMP CProgView::PopulateList()
{
    HANDLE hThread;

    ResetEvent(m_hEventCancel);
    ResetEvent(m_hEventCmd);

    if (!m_bInPlaceActive) {
        InPlaceActivate(OLEIVERB_INPLACEACTIVATE);
    }
    if (m_hThreadPopulate == NULL) {
        m_hThreadPopulate = CreateThread(NULL, 0, _PopulateThreadProc, (LPVOID)this, 0, NULL);
    }

    if (m_hThreadPopulate != NULL && !IsScanInProgress()) {
        m_nCmdPopulate = CMD_SCAN;
        SetEvent(m_hEventCmd);
    }

    return S_OK;
}

BOOL CProgView::PopulateListInternal()
{

    if (InterlockedCompareExchange(&m_PopulateInProgress, TRUE, FALSE) == TRUE) {
        //
        // populate in progress -- quit
        //
        return FALSE;
    }

    if (m_pProgramList != NULL) {
        CleanupProgramList(m_pProgramList);
        m_pProgramList = NULL;

    }

    ShowProgressWindows(TRUE);
    Animate_OpenEx(GetDlgItem(IDC_ANIMATEFIND), _Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_FINDANIM));
    Animate_Play(GetDlgItem(IDC_ANIMATEFIND), 0, -1, -1);

    PostMessage(WM_VIEW_CHANGED);

    // FireViewChange();

//    if (m_bInPlaceActive) {
/*    HCURSOR hcWait = (HCURSOR)::LoadImage(NULL,
                                          MAKEINTRESOURCE(IDC_WAIT),
                                          IMAGE_CURSOR,
                                          0, 0,
                                          LR_DEFAULTSIZE|LR_SHARED);

//    HCURSOR hcWait = ::LoadCursor(_Module.GetResourceInstance(),
//                                 MAKEINTRESOURCE(IDC_WAIT));


    HCURSOR hcSave = SetCursor(hcWait);
*/

    //
    // malloc used on this thread should NOT be used on UI thread
    //

    InitializeProgramList(&m_pProgramList, GetDlgItem(IDC_LISTPROGRAMS));
    PopulateProgramList(m_pProgramList, this, m_hEventCancel);

//    SetCursor(hcSave);

    Animate_Stop(GetDlgItem(IDC_ANIMATEFIND));
    Animate_Close(GetDlgItem(IDC_ANIMATEFIND));
    ShowProgressWindows();

    InterlockedCompareExchange(&m_PopulateInProgress, FALSE, TRUE);

    PostMessage(WM_VIEW_CHANGED);
    PostMessage(WM_LIST_POPULATED); // we are done, signal to the main thread


//    FireViewChange();

//    } else {
//        m_bPendingPopulate = TRUE;
//    }


    return TRUE;
}

DWORD WINAPI
CProgView::_PopulateThreadProc(
    LPVOID lpvParam
    )
{
    CProgView* pProgView = (CProgView*)lpvParam;
    DWORD      dwWait;
    BOOL       bExit = FALSE;
    HRESULT hr = CoInitialize(NULL);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    //
    // keep this thread alive, block it on a command event
    //
    while(!bExit) {
        dwWait = WaitForSingleObject(pProgView->m_hEventCmd, INFINITE);
        if (dwWait != WAIT_OBJECT_0) {
            break; // get out, we are being killed
        }
        //
        // get the command
        //
        switch(pProgView->m_nCmdPopulate) {
        case CMD_NONE:
            break;

        case CMD_EXIT:
            bExit = TRUE;
            //
            // intentional fall-through
            //

        case CMD_CLEANUP:
            if (pProgView->m_pProgramList) {
                CleanupProgramList(pProgView->m_pProgramList);
                pProgView->m_pProgramList = NULL;
            }
            break;

        case CMD_SCAN:
            pProgView->PopulateListInternal();
            break;
        }

        pProgView->m_nCmdPopulate = CMD_NONE;
    }
    CoUninitialize();
    return TRUE;
}

STDMETHODIMP
CProgView::UpdateListItem(
    BSTR pTarget,
    VARIANT *pKeys,
    BOOL *pResult
    )
{
    VARIANT vKeys;
    VariantInit(&vKeys);
    CComBSTR bstrKeys;
    HRESULT  hr;

    if (!m_pProgramList) {
        return S_OK;
    }

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    if (pKeys->vt == VT_NULL || pKeys->vt == VT_EMPTY) {
        *pResult = UpdateProgramListItem(m_pProgramList, pTarget, NULL);
        return S_OK;
    }

    hr = VariantChangeType(&vKeys, pKeys, 0, VT_BSTR);
    if (SUCCEEDED(hr)) {
        bstrKeys = vKeys.bstrVal;

        if (bstrKeys.Length()) {
            *pResult = UpdateProgramListItem(m_pProgramList, pTarget, bstrKeys);
        } else {
            *pResult = FALSE;
        }
    }

    VariantClear(&vKeys);
    return S_OK;
}

BOOL
CProgView::PreTranslateAccelerator(
    LPMSG pMsg,
    HRESULT& hRet
    )
{
    HWND hWndCtl;
    HWND hwndList = GetDlgItem(IDC_LISTPROGRAMS);

    hRet = S_OK;
    hWndCtl = ::GetFocus();
    if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)    {
        do {
            hWndCtl = ::GetParent(hWndCtl);
        } while (::GetParent(hWndCtl) != m_hWnd);
    }

    if (hWndCtl == hwndList &&
        pMsg->message == WM_KEYDOWN &&
            (LOWORD(pMsg->wParam) == VK_RETURN ||
            LOWORD(pMsg->wParam) == VK_EXECUTE)) {

        if (ListView_GetNextItem(hwndList, -1, LVNI_SELECTED) >= 0) {
            Fire_DblClk(0);
            return TRUE;
        }

    }


    //
    // check for external accelerators because the next call is going to eat the message
    //
    if (m_ExternAccel.IsAccelKey(pMsg)) { // we do not touch external accel messages
        return FALSE;
    }

    return CComCompositeControl<CProgView>::PreTranslateAccelerator(pMsg, hRet);
}


STDMETHODIMP CProgView::CancelPopulateList()
{
    if (m_hEventCancel && InterlockedCompareExchange(&m_PopulateInProgress, TRUE, TRUE) == TRUE) {
        SetEvent(m_hEventCancel);
    }
    return S_OK;
}

STDMETHODIMP CProgView::get_AccelCmd(LONG lCmd, BSTR *pVal)
{
    CComBSTR bstrAccel = m_Accel.GetAccelString((WORD)lCmd).c_str();
    *pVal = bstrAccel.Copy();
    return S_OK;
}

STDMETHODIMP CProgView::put_AccelCmd(LONG lCmd, BSTR newVal)
{
    m_Accel.SetAccel(newVal);
    return S_OK;
}

STDMETHODIMP CProgView::ClearAccel()
{
    m_Accel.ClearAccel();
    return S_OK;
}


STDMETHODIMP CProgView::get_ExternAccel(BSTR *pVal)
{
    CComBSTR bstrAccel = m_ExternAccel.GetAccelString().c_str();
    *pVal = bstrAccel.Copy();
    return S_OK;
}

STDMETHODIMP CProgView::put_ExternAccel(BSTR newVal)
    {
    m_ExternAccel.SetAccel(newVal);
    return S_OK;
}

STDMETHODIMP CProgView::ClearExternAccel()
{
    m_ExternAccel.ClearAccel();
    return S_OK;
}

STDMETHODIMP CProgView::get_ItemCount(VARIANT* pVal)
{
    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    pVal->vt = VT_I4;
    pVal->intVal = (int)ListView_GetItemCount(GetDlgItem(IDC_LISTPROGRAMS));

    return S_OK;
}

//
// in upload.c
//
wstring StrUpCase(wstring& wstr);

//
// expand env -- lives in util.cpp
// we have a bit differing implementation here
//

wstring
ExpandEnvironmentVars(
    LPCTSTR lpszCmd
    )
{
    DWORD   dwLength;
    LPTSTR  lpBuffer = NULL;
    BOOL    bExpanded = FALSE;
    wstring strCmd;
    TCHAR   szBuffer[MAX_PATH];

    if (_tcschr(lpszCmd, TEXT('%')) == NULL) {
        goto out;
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, NULL, 0);
    if (!dwLength) {
        goto out;
    }

    if (dwLength < CHARCOUNT(szBuffer)) {
        lpBuffer = szBuffer;
    } else {
        lpBuffer = new TCHAR[dwLength];
        if (NULL == lpBuffer) {
            goto out;
        }
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, lpBuffer, dwLength);
    if (!dwLength) {
        goto out;
    }

    strCmd = lpBuffer;
    bExpanded = TRUE;

 out:
    if (!bExpanded) {
        strCmd = lpszCmd;
    }
    if (lpBuffer && lpBuffer != szBuffer) {
        delete[] lpBuffer;
    }
    return strCmd;
}

STDMETHODIMP CProgView::put_ExcludeFiles(BSTR newVal)
{
    // parse exclude files, put them into our blacklist
    wstring strFile;
    LPCWSTR pch = newVal;
    LPCWSTR pend;

    m_ExcludedFiles.clear();

    while (pch != NULL && *pch != TEXT('\0')) {

        pch += _tcsspn(pch, TEXT(" \t"));
        // begining
        // find the ;
        pend = _tcschr(pch, TEXT(';'));
        if (pend == NULL) {
            // from pch to the end
            strFile = pch;
            pch = NULL; // will bail out
        } else {
            strFile = wstring(pch, (wstring::size_type)(pend - pch));
            pch = pend + 1; // one past ;
        }

        // add
        if (strFile.length()) {
            strFile = ExpandEnvironmentVars(strFile.c_str());
            m_ExcludedFiles.insert(StrUpCase(strFile));
        }
    }

    return S_OK;
}

STDMETHODIMP CProgView::get_ExcludeFiles(BSTR* pVal)
{
    // parse exclude files, put them into our blacklist
    STRSET::iterator iter;
    CComBSTR bstrFiles;

    for (iter = m_ExcludedFiles.begin(); iter != m_ExcludedFiles.end(); ++iter) {
        if (bstrFiles.Length()) {
            bstrFiles += TEXT(';');
        }
        bstrFiles += (*iter).c_str();
    }

    *pVal = bstrFiles.Copy();

    return S_OK;
}

BOOL CProgView::IsFileExcluded(LPCTSTR pszFile)
{
    wstring strFile = pszFile;
    STRSET::iterator iter;

    iter = m_ExcludedFiles.find(StrUpCase(strFile));
    return iter != m_ExcludedFiles.end();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\progview.h ===
// ProgView.h : Declaration of the CProgView

#ifndef __PROGVIEW_H_
#define __PROGVIEW_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <shlobj.h>
#include "CompatUICP.h"

/////////////////// SHIMDB

extern "C" {
    #include "shimdb.h"
}

/////////////////// STL

#include "AccelContainer.h"

class CProgramList;
class CProgView;


#define IDC_REFRESH 0x1234
//
// Program list stuff
//

BOOL
GetProgramListSelection(
    CProgramList* pProgramList
    );


BOOL
InitializeProgramList(
    CProgramList** ppProgramList,
    HWND hwndListView
    );

BOOL
CleanupProgramList(
    CProgramList* pProgramList
    );

BOOL
PopulateProgramList(
    CProgramList* pProgramList,
    CProgView*    pProgView,
    HANDLE        hEventCancel
    );

BOOL
GetProgramListSelectionDetails(
    CProgramList* pProgramList,
    INT iInformationClass,
    VARIANT* pVal
    );

LRESULT
NotifyProgramList(
    CProgramList* pProgramList,
    LPNMHDR       pnmhdr,
    BOOL&         bHandled
    );

BOOL
GetProgramListEnabled(
    CProgramList* pProgramList
    );

VOID
EnableProgramList(
    CProgramList* pProgramList,
    BOOL bEnable
    );

BOOL
UpdateProgramListItem(
    CProgramList* pProgramList,
    LPCWSTR pwszPath,
    LPCWSTR pwszKeys
    );


#define WM_VIEW_CHANGED   (WM_USER+500)
#define WM_LIST_POPULATED (WM_USER+501)

//
// wait for the thread to cleanup
//

#define POPULATE_THREAD_TIMEOUT 1000

/////////////////////////////////////////////////////////////////////////////
// CProgView
class ATL_NO_VTABLE CProgView :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CProgView, IProgView, &IID_IProgView, &LIBID_COMPATUILib>,
    public CComCompositeControl<CProgView>,
    public IPersistStreamInitImpl<CProgView>,
    public IOleControlImpl<CProgView>,
    public IOleObjectImpl<CProgView>,
    public IOleInPlaceActiveObjectImpl<CProgView>,
    public IViewObjectExImpl<CProgView>,
    public IOleInPlaceObjectWindowlessImpl<CProgView>,
    public CComCoClass<CProgView, &CLSID_ProgView>,
    public ISupportErrorInfo,
    public IPersistPropertyBagImpl<CProgView>,
    public IConnectionPointContainerImpl<CProgView>,
    public CProxy_IProgViewEvents< CProgView >,
    public IPropertyNotifySinkCP< CProgView >,
    public IProvideClassInfo2Impl<&CLSID_ProgView, &DIID__IProgViewEvents, &LIBID_COMPATUILib>,
    public CProxy_ISelectFileEvents< CProgView >
{
public:
    typedef enum {
        CMD_EXIT,
        CMD_CLEANUP,
        CMD_SCAN,
        CMD_NONE
    } PopulateCmdType;


    CProgView() : m_Safe(this)
    {
        m_bWindowOnly = TRUE;
        m_pProgramList = NULL;
        m_bPendingPopulate = FALSE;
        m_bRecomposeOnResize = TRUE;
        m_PopulateInProgress = FALSE;
        m_nCmdPopulate = CMD_NONE;
        CalcExtent(m_sizeExtent);

        m_hEventCancel = CreateEvent(NULL, TRUE, FALSE, NULL);
        //
        // handle error -- we are big time in trouble if this fails
        //
        m_hEventCmd    = CreateEvent(NULL, FALSE, FALSE, NULL);
        //
        // same
        //

        m_hThreadPopulate = NULL;

        m_pMallocUI = NULL;

        //
        // create accelerator
        //

        ACCEL rgAccel[] = { { FVIRTKEY, VK_F5, IDC_REFRESH } };
        m_hAccel = CreateAcceleratorTable(rgAccel, ARRAYSIZE(rgAccel));

    }

    ~CProgView() {
        if (m_hAccel) {
            DestroyAcceleratorTable(m_hAccel);
        }
        if (m_hEventCancel) {
            SetEvent(m_hEventCancel);
            CloseHandle(m_hEventCancel);
        }
        if (m_hEventCmd) {
            m_nCmdPopulate = CMD_EXIT;
            SetEvent(m_hEventCmd);
            CloseHandle(m_hEventCmd);
        }
        if (m_hThreadPopulate) {
            WaitForSingleObject(m_hThreadPopulate, POPULATE_THREAD_TIMEOUT);
            CloseHandle(m_hThreadPopulate);
        }
        if (m_pMallocUI) {
            m_pMallocUI->Release();
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_PROGVIEW)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CProgView)
    COM_INTERFACE_ENTRY(IProgView)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
END_COM_MAP()

BEGIN_PROP_MAP(CProgView)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)

    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
//    PROP_ENTRY("BorderStyle", DISPID_BORDERSTYLE, CLSID_NULL)
    PROP_ENTRY("Enabled", DISPID_ENABLED, CLSID_NULL)
//    PROP_ENTRY("ForeColor", DISPID_FORECOLOR, CLSID_StockColorPage)
//    PROP_ENTRY("Text", DISPID_TEXT, CLSID_NULL)
//    PROP_ENTRY("Tabstop", DISPID_TABSTOP, CLSID_NULL)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)

    PROP_ENTRY("Accel",        7,       CLSID_NULL) // the numbers should match .idl file!
    PROP_ENTRY("ExternAccel",  8,       CLSID_NULL)
    PROP_ENTRY("ExcludeFiles", 9,       CLSID_NULL)

END_PROP_MAP()

BEGIN_MSG_MAP(CProgView)
    NOTIFY_ID_HANDLER(IDC_LISTPROGRAMS,  OnNotifyListView)
    NOTIFY_HANDLER(IDC_LISTPROGRAMS, NM_DBLCLK, OnDblclkListprograms)
    MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_VIEW_CHANGED, OnViewChanged)
    MESSAGE_HANDLER(WM_LIST_POPULATED, OnListPopulated)
    MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)

    //    COMMAND_ID_HANDLER(IDC_REFRESH, OnRefreshListCmd)

    CHAIN_MSG_MAP(CComCompositeControl<CProgView>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CProgView)
    //Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

BEGIN_CONNECTION_POINT_MAP(CProgView)
CONNECTION_POINT_ENTRY(DIID__IProgViewEvents)
CONNECTION_POINT_ENTRY(DIID__ISelectFileEvents)
END_CONNECTION_POINT_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
    {
        static const IID* arr[] =
        {
            &IID_IProgView,
        };
        for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
        {
            if (InlineIsEqualGUID(*arr[i], riid))
                return S_OK;
        }
        return S_FALSE;
    }

    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
    {
        if (dispid == DISPID_AMBIENT_BACKCOLOR)
        {
            SetBackgroundColorFromAmbient();
            FireViewChange();
        }

        return IOleControlImpl<CProgView>::OnAmbientPropertyChange(dispid);
    }

    HRESULT FireOnChanged(DISPID dispID) {
        if (dispID == DISPID_ENABLED) {
            HWND hwndList = GetDlgItem(IDC_LISTPROGRAMS);
            if (::IsWindow(hwndList)) {
                ::EnableWindow(hwndList, m_bEnabled);
            }
        }
        return S_OK;
    }

    STDMETHOD(GetControlInfo)(CONTROLINFO* pCI) {
        if (NULL == pCI) {
            return E_POINTER;
        }
        pCI->cb      = sizeof(*pCI);
        pCI->hAccel  = m_hAccel;
        pCI->cAccel  = 1;
        pCI->dwFlags = 0;
        return S_OK;
    }

    STDMETHOD(OnMnemonic)(LPMSG pMsg) {
        if (pMsg->message == WM_COMMAND || pMsg->message == WM_SYSCOMMAND) {
            if (LOWORD(pMsg->wParam) == IDC_REFRESH) {
                PopulateList();
            }
        }
        return S_OK;
    }

    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);

    LRESULT OnNotifyListView(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDblclkListprograms(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnMouseActivate(UINT, WPARAM, LPARAM, BOOL&) {
        // Manually activate the control
        InPlaceActivate(OLEIVERB_UIACTIVATE);
        return 0;
    }


    STDMETHOD(InPlaceDeactivate)(VOID) {
        HRESULT hr = IOleInPlaceObjectWindowlessImpl<CProgView>::InPlaceDeactivate();
        //
        // make sure we cancel first if we are scanning
        //
        return hr;
    }

#if 0
    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL* psizel) {


        if (IsWindow()) {
            HWND hlvPrograms = GetDlgItem(IDC_LISTPROGRAMS);
            SIZEL sizePix;
            AtlHiMetricToPixel(psizel, &sizePix);
            ::SetWindowPos(hlvPrograms, NULL, 0, 0,
                           sizePix.cx, sizePix.cy,
                           SWP_NOZORDER|SWP_NOACTIVATE);
            /*
            ::SetWindowPos(hlvPrograms, NULL, 0, 0,
                           m_rcPos.right - m_rcPos.left,
                           m_rcPos.bottom - m_rcPos.top,
                           SWP_NOZORDER|SWP_NOACTIVATE);
            */

        }
        HRESULT hr = IOleObjectImpl<CProgView>::SetExtent(dwDrawAspect, psizel);

        return hr;
    }

#endif

    LRESULT OnGetDlgCode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        // TODO : Add Code for message handler. Call DefWindowProc if necessary.
        if (lParam) {
            LPMSG pMsg = (LPMSG)lParam;
            if (pMsg->message == WM_SYSKEYDOWN || pMsg->message == WM_SYSCHAR) { // eat accel ?
                bHandled = TRUE;
                return DLGC_WANTMESSAGE;
            }
        }

        bHandled = TRUE;
        return DLGC_WANTTAB|DLGC_WANTARROWS|DLGC_WANTALLKEYS;
    }


    STDMETHOD(SetObjectRects)(LPCRECT prcPos, LPCRECT prcClip) {
        HWND hlvPrograms = GetDlgItem(IDC_LISTPROGRAMS);
        IOleInPlaceObjectWindowlessImpl<CProgView>::SetObjectRects(prcPos, prcClip);
        ::SetWindowPos(hlvPrograms, NULL, 0, 0,
                       prcPos->right - prcPos->left,
                       prcPos->bottom - prcPos->top,
                       SWP_NOZORDER|SWP_NOACTIVATE);

        HWND hwnd;
        RECT rc;

        hwnd = GetDlgItem(IDC_STATUSLINE1);
        ::GetWindowRect(hwnd, &rc);

        //
        // we are happy with location, just set the width
        //
        ScreenToClient((LPPOINT)&rc);
        ScreenToClient(((LPPOINT)&rc) + 1);

        ::SetWindowPos(hwnd, NULL,
                       rc.left, rc.top,
                       prcPos->right - prcPos->left - rc.left,
                       rc.bottom - rc.top,
                       SWP_NOZORDER|SWP_NOACTIVATE);

        hwnd = GetDlgItem(IDC_STATUSLINE2);
        ::GetWindowRect(hwnd, &rc);

        //
        // we are happy with location, just set the width
        //
        ScreenToClient((LPPOINT)&rc);
        ScreenToClient(((LPPOINT)&rc) + 1);

        ::SetWindowPos(hwnd, NULL,
                       rc.left, rc.top,
                       prcPos->right - prcPos->left - rc.left,
                       rc.bottom - rc.top,
                       SWP_NOZORDER|SWP_NOACTIVATE);

        return S_OK;

    }

    BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hrRet);

#if 0

    static CWndClassInfo& GetWndClassInfo() {
        DebugBreak();
        static CWndClassInfo wc = CWindowImpl<CProgView>::GetWndClassInfo();
        wc.m_wc.style &= ~(CS_HREDRAW|CS_VREDRAW);
        return wc;
    }


    BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hrRet) {

        HWND hwndList  = GetDlgItem(IDC_LISTPROGRAMS);
        HWND hwndFocus = GetFocus();

        if (hwndList != hwndFocus || !::IsWindowEnabled(hwndList)) {
            goto PropagateAccel;
        }

        if (pMsg->message == WM_KEYDOWN) {

            if (pMsg->wParam == VK_LEFT ||
                pMsg->wParam == VK_RIGHT ||
                pMsg->wParam == VK_UP ||
                pMsg->wParam == VK_DOWN) {

                SendDlgItemMessage(IDC_LISTPROGRAMS, pMsg->message, pMsg->wParam, pMsg->lParam);
                hrRet = S_OK;
                return TRUE;
            }

            if (LOWORD(pMsg->wParam) == VK_RETURN || LOWORD(pMsg->wParam) == VK_EXECUTE) {

                if (ListView_GetNextItem(hwndList, -1, LVNI_SELECTED) >= 0) {
                    Fire_DblClk(0);
                    hrRet = S_OK;
                    return TRUE;
                }
            }

            if (LOWORD(pMsg->wParam) == VK_TAB) {
                goto PropagateAccel;
            }
        }

        if (IsDialogMessage(pMsg)) {
            hrRet = S_OK;
            return TRUE;
        }

        if (::TranslateAccelerator(m_hWnd, NULL, pMsg)) {
            hrRet = S_OK;
            return TRUE;
        }

        PropagateAccel:
        return FALSE;
    }
#endif




// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IProgView
public:
    STDMETHOD(get_ExcludeFiles)(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(put_ExcludeFiles)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ExternAccel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ExternAccel)(/*[in]*/ BSTR newVal);
#if 0
    STDMETHOD(get_Accel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Accel)(/*[in]*/ BSTR newVal);
#endif
    STDMETHOD(CancelPopulateList)();
    STDMETHOD(UpdateListItem)(/*[in]*/BSTR pTarget, /*[in]*/VARIANT* pKeys, /*[out, retval]*/ BOOL* pResult);
    STDMETHOD(PopulateList)();
    STDMETHOD(GetSelectionInformation)(LONG, VARIANT* pVal);
    STDMETHOD(get_SelectionName)(/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(GetSelectedItem)();

    STDMETHOD(ClearAccel)();
    STDMETHOD(ClearExternAccel)();
    STDMETHOD(get_AccelCmd)(/*[in]*/ LONG lCmd, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_AccelCmd)(/*[in]*/ LONG lCmd, /*[in]*/ BSTR newVal);
    STDMETHOD(get_ItemCount)(/*[out, retval]*/VARIANT* pItemCount);

    BOOL m_bEnabled;

    CSafeObject m_Safe;     // set to true if we were able to verify the host

    BOOL m_bPendingPopulate;
    CProgramList* m_pProgramList;


    enum { IDD = IDD_PROGVIEW };

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
        // TODO : Add Code for message handler. Call DefWindowProc if necessary.
/*
        DWORD dwStyle = (DWORD)GetClassLong(m_hWnd, GCL_STYLE);
        dwStyle &= ~(CS_HREDRAW | CS_VREDRAW);
        SetClassLong(m_hWnd, GCL_STYLE, dwStyle);
*/

        //
        // before we start messing around with this... obtain malloc for the UI thread
        //
        HRESULT hr = SHGetMalloc(&m_pMallocUI);
        if (!SUCCEEDED(hr)) {
            //
            // aww -- ui malloc will not be available -- we're pretty much hosed
            //
            m_pMallocUI = NULL;
        }

        PopulateList();

        return 0;

    }

    static DWORD WINAPI _PopulateThreadProc(LPVOID lpvParam);

    VOID UpdatePopulateStatus(LPCTSTR lpszName, LPCTSTR lpszPath) {
        SetDlgItemText(IDC_STATUSLINE1, lpszName);
        ::PathSetDlgItemPath(m_hWnd, IDC_STATUSLINE2, lpszPath);
    }

    VOID ShowProgressWindows(BOOL bProgress = FALSE);

    LRESULT OnViewChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
        FireViewChange();
        bHandled = TRUE;
        return 0;
    }

    LRESULT OnListPopulated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
        Fire_ProgramListReady();
        bHandled = TRUE;
        return 0;
    }

    BOOL PopulateListInternal();

    HANDLE m_hEventCancel;
    LONG   m_PopulateInProgress;
    HANDLE m_hEventCmd;
    PopulateCmdType m_nCmdPopulate;
    HANDLE m_hThreadPopulate;

    IMalloc* m_pMallocUI;

    HACCEL m_hAccel;

    BOOL IsScanInProgress(VOID) {
        return InterlockedCompareExchange(&m_PopulateInProgress, TRUE, TRUE) == TRUE;
    }

    /*
    LRESULT OnRefreshListCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled) {
        PopulateList();
        bHandled = TRUE;
        return 0;
    }
    */

    //
    // accelerators
    //
    CAccelContainer m_Accel;       // my own accelerator
    CAccelContainer m_ExternAccel; // external accels


    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        InPlaceActivate(OLEIVERB_UIACTIVATE);
        //
        // if we are scanning then we don't need to do anything, else - set the focus to listview
        //
        if (!IsScanInProgress()) {
            ::SetFocus(GetDlgItem(IDC_LISTPROGRAMS));
        }

        return CComCompositeControl<CProgView>::OnSetFocus(uMsg, wParam, lParam, bHandled);
    }

    //
    // blacklisted files
    //
    typedef set<wstring> STRSET;

    STRSET m_ExcludedFiles;

    //
    // check whether a file is excluded
    //
    BOOL IsFileExcluded(LPCTSTR pszFile);

};



#endif //__PROGVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\proglist.cpp ===
/*++

      Implements population of a listview control with the content from
      the start menu


--*/


#include "stdafx.h"
#include "resource.h"

#include <stdio.h>
#include <stdlib.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <commctrl.h>
#include <msi.h>
#include <sfc.h>
#include "CompatUI.h"
#include "progview.h"
extern "C" {
#include "shimdb.h"
}

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <algorithm>

using namespace std;

#ifdef _UNICODE
typedef wstring tstring;
#else
typedef string tstring;
#endif

    typedef
    INSTALLSTATE (WINAPI*PMsiGetComponentPath)(
      LPCTSTR szProduct,   // product code for client product
      LPCTSTR szComponent, // component ID
      LPTSTR lpPathBuf,    // returned path
      DWORD *pcchBuf       // buffer character count
    );

    typedef
    UINT (WINAPI* PMsiGetShortcutTarget)(
      LPCTSTR szShortcutTarget,     // path to shortcut link file
      LPTSTR szProductCode,        // fixed length buffer for product code
      LPTSTR szFeatureId,          // fixed length buffer for feature id
      LPTSTR szComponentCode       // fixed length buffer for component code
    );


typedef enum tagPROGRAMINFOCLASS {
    PROGLIST_DISPLAYNAME,
    PROGLIST_LOCATION,     //
    PROGLIST_EXENAME,      // cracked exe name
    PROGLIST_CMDLINE,      // complete exe name + parameters
    PROGLIST_EXECUTABLE,   // what we should execute (link or exe, not cracked)
    PROGLIST_ARGUMENTS     // just the args
};




class CException {
public:
    CException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) {
        SetLocation(lpszFile, nLocation);
    }
    virtual ~CException() {}

    virtual VOID Delete() {
        delete this;
    }

    int __cdecl FormatV(LPCTSTR lpszFormat, va_list arg) {
        int nch = 0;

        if (lpszFormat) {
            nch = _vsntprintf(szDescription, CHARCOUNT(szDescription), lpszFormat, arg);
        } else {
            *szDescription = TEXT('\0');
        }
        return nch;
    }

    int __cdecl Format(LPCTSTR lpszFormat, ...) {
        va_list arg;
        int nch = 0;

        if (lpszFormat) {
            va_start(arg, lpszFormat);
            nch = _vsntprintf(szDescription, CHARCOUNT(szDescription), lpszFormat, arg);
            va_end(arg);
        } else {
            *szDescription = TEXT('\0');
        }
    }

    VOID SetLocation(LPCSTR lpszFile, DWORD nLocation) {
        if (lpszFile) {
            strcpy(szLocation, lpszFile);
        } else {
            *szLocation = TEXT('\0');
        }
        m_dwLocation = nLocation;
    }

    TCHAR   szDescription[MAX_PATH];
    CHAR    szLocation[MAX_PATH];
    DWORD   m_dwLocation;
};

class CMemoryException : public CException {
public:
    CMemoryException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) :
      CException(lpszFile, nLocation) {}
    VOID Delete() {}
};

class CCancelException : public CException {
public:
    CCancelException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) :
      CException(lpszFile, nLocation){}
};

static CMemoryException _MemoryExceptionStatic;

VOID __cdecl ThrowMemoryException(LPCSTR lpszFile, DWORD nLocation, LPCTSTR lpszFormat = NULL, ...) {
    va_list arg;
    CMemoryException* pMemoryException = &_MemoryExceptionStatic;

    va_start(arg, lpszFormat);
    pMemoryException->FormatV(lpszFormat, arg);
    va_end(arg);

    throw pMemoryException;
}

class CProgramList {
public:
    CProgramList(LPMALLOC pMalloc, HWND hwndListView, LPCTSTR szSystemDirectory) :
      m_pMalloc(pMalloc),
      m_hwndListView(hwndListView),
      m_hMSI(NULL),
      m_pSelectionInfo(NULL),
      m_hbmSort(NULL),
      m_pProgView(NULL),
      m_hEventCancel(NULL) {
        //
        // we are always initializing on populate thread
        //
        m_dwOwnerThreadID    = GetCurrentThreadId();
        m_strSystemDirectory = szSystemDirectory;
      }

      ~CProgramList();

    BOOL PopulateControl(CProgView* pProgView = NULL, HANDLE hEventCancel = NULL);

    LPMALLOC GetMalloc(VOID) {
        return GetCurrentThreadId() == m_dwOwnerThreadID ? m_pMalloc : m_pMallocUI;
    }

    BOOL CaptureSelection();

    BOOL GetSelectionDetails(INT iInformationClass, VARIANT* pVal);

    LRESULT LVNotifyDispInfo   (LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyColumnClick(LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyGetInfoTip (LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyRClick     (LPNMHDR pnmhdr, BOOL& bHandled);
    BOOL IsEnabled(VOID);

    VOID Enable(BOOL);

    BOOL UpdateListItem(LPCWSTR pwszPath, LPCWSTR pwszKey);

protected:
    BOOL ListFolder(LPCTSTR pszLocationParent, IShellFolder* pFolder, LPCITEMIDLIST pidlFull, LPCITEMIDLIST pidlFolder);
    BOOL ListLink(LPCTSTR pszLocationParent, LPCTSTR pszDisplayName, IShellFolder* pFolder, LPCITEMIDLIST pidlFull, LPCITEMIDLIST pidlLink);
    BOOL ListMsiLink(LPCTSTR pszLocationParent, LPCTSTR pszDisplayName, LPCTSTR pszMsiPath, IShellFolder* pFolder, LPCITEMIDLIST pidlFull);

    LPITEMIDLIST GetNextItemIDL(LPCITEMIDLIST pidl);
       UINT         GetSizeIDL    (LPCITEMIDLIST pidl);
      LPITEMIDLIST AppendIDL     (LPCITEMIDLIST pidlBase,
                                LPCITEMIDLIST pidlAdd);
    LPITEMIDLIST GetLastItemIDL(LPCITEMIDLIST pidl);

    BOOL GetDisplayName(IShellFolder* pFolder, LPCITEMIDLIST pidl, tstring& strDisplay);
    BOOL GetPathFromLink(IShellLink* pLink, WIN32_FIND_DATA* pfd, tstring& strPath);
    BOOL GetArgumentsFromLink(IShellLink* pLink, tstring& strArgs);

    BOOL AddItem(LPCTSTR pszLocation,
                 LPCTSTR pszDisplayName,
                 LPCTSTR pszPath,
                 LPCTSTR pszArguments,
                 IShellFolder* pFolder,
                 LPCITEMIDLIST pidlFull,
                 BOOL    bUsePath = FALSE); // true if we should use path for executable


    int GetIconFromLink(LPCITEMIDLIST pidlLinkFull, LPCTSTR lpszExePath);

    BOOL IsSFCItem(LPCTSTR lpszItem);
    BOOL IsItemInSystemDirectory(LPCTSTR pszPath);

private:
    LPMALLOC m_pMalloc;
    LPMALLOC m_pMallocUI;
    HWND     m_hwndListView; // list view control
    HBITMAP  m_hbmSort;
    typedef struct tagSHITEMINFO {

        tstring strDisplayName;     // descriptive name
        tstring strFolder;          // containing folder
        tstring strPath;            // actual exe, cracked
        tstring strPathExecute;     // link path (this is what we will execute)
        tstring strCmdLine;         // command line (cracked link)
        tstring strArgs;
        tstring strKeys;
        LPITEMIDLIST pidl;          // full pidl
    } SHITEMINFO, *PSHITEMINFO;
    static CALLBACK SHItemInfoCompareFunc(LPARAM lp1, LPARAM lp2, LPARAM lParamSort);

    typedef map< tstring, PSHITEMINFO, less<tstring> > MAPSTR2ITEM;
    typedef multimap< tstring, PSHITEMINFO > MULTIMAPSTR2ITEM;

    //
    // store key->item sequence, the keys are cmdlines (with args)
    //
    MAPSTR2ITEM m_mapItems;

    //
    // store key->item sequence, where the key is exe name (path)
    //
    MULTIMAPSTR2ITEM m_mmapExeItems;

    //
    // selected item
    //

    PSHITEMINFO m_pSelectionInfo;

    //
    // cached msi.dll handle
    //
    HMODULE     m_hMSI;


    PMsiGetComponentPath  m_pfnGetComponentPath;
    PMsiGetShortcutTarget m_pfnGetShortcutTarget;

    //
    // cached system directory
    //

    tstring m_strSystemDirectory;

    //
    // image list used to show icons
    //

    HIMAGELIST  m_hImageList;

    //
    // optional pointer to the parent view
    //
    CProgView* m_pProgView;


    //
    // event that we use to signal the end of scan
    //
    HANDLE m_hEventCancel;


    //
    // owner thread
    //
    DWORD m_dwOwnerThreadID;

    VOID CheckForCancel() {
        if (m_hEventCancel) {
            if (::WaitForSingleObject(m_hEventCancel, 0) != WAIT_TIMEOUT) {
                // cancelled!!!
                throw new CCancelException();
            }
        }
    }

};

//
// in upload.cpp
//

wstring StrUpCase(wstring& wstr);

//
// load the string from resources
//
wstring LoadResourceString(UINT nID)
{
    LPTSTR lpszBuffer = NULL;
    int cch;
    wstring str;

    cch = ::LoadString(_Module.GetModuleInstance(), nID, (LPTSTR)&lpszBuffer, 0);
    //
    // hack! this must work (I know it does)
    //
    if (cch && NULL != lpszBuffer) {
        str = wstring(lpszBuffer, cch);
    }

    return str;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//


BOOL
InitializeProgramList(
    CProgramList** ppProgramList,
    HWND hwndListView
    )
{
    HRESULT hr;
    BOOL bSuccess = FALSE;
    LPMALLOC pMalloc = NULL;
    TCHAR szSystemWindowsDirectory[MAX_PATH];
    CProgramList* pProgramList = NULL;
    UINT uSize;

    hr = SHGetMalloc(&pMalloc);
    if (!SUCCEEDED(hr)) {
        goto ErrHandle;
    }


    uSize = ::GetSystemWindowsDirectory(szSystemWindowsDirectory,
                                        CHARCOUNT(szSystemWindowsDirectory));
    if (uSize == 0 || uSize > CHARCOUNT(szSystemWindowsDirectory)) {
        goto ErrHandle;
    }

    pProgramList = new CProgramList(pMalloc, hwndListView, szSystemWindowsDirectory);
    if (NULL == pProgramList) {
        goto ErrHandle;
    }


    *ppProgramList = pProgramList;
    bSuccess = TRUE;

ErrHandle:

    if (!bSuccess) {

        if (NULL != pMalloc) {
            pMalloc->Release();
        }

        if (NULL != pProgramList) {
            delete pProgramList;
        }

    }

    return bSuccess;
}


BOOL
CleanupProgramList(
    CProgramList* pProgramList
    )
{
    LPMALLOC pMalloc;

    if (NULL == pProgramList) {
        return FALSE;
    }

    pMalloc = pProgramList->GetMalloc();

    delete pProgramList;

    if (NULL != pMalloc) {
        pMalloc->Release();
    }


    return TRUE;
}

BOOL
PopulateProgramList(
    CProgramList* pProgramList,
    CProgView*    pProgView,
    HANDLE        hEventCancel
    )
{
    return pProgramList->PopulateControl(pProgView, hEventCancel);
}


CProgramList::~CProgramList()
{
    //
    //
    //
    MAPSTR2ITEM::iterator iter;

    iter = m_mapItems.begin();
    while (iter != m_mapItems.end()) {
        PSHITEMINFO pInfo = (*iter).second;

        GetMalloc()->Free(pInfo->pidl); // nuke this please
        delete pInfo;

        ++iter;
    }

    if (NULL != m_hbmSort) {
        DeleteObject(m_hbmSort);
    }


//  Image list is destroyed automatically when the control is destroyed
//
//    if (NULL != m_hImageList) {
//        ImageList_Destroy(m_hImageList);
//    }

    if (NULL != m_hMSI && (HMODULE)-1 != m_hMSI) {
        FreeLibrary(m_hMSI);
    }
}

BOOL
CProgramList::GetDisplayName(
    IShellFolder* pFolder,
    LPCITEMIDLIST pidl,
    tstring&      strDisplayName
    )
{
    STRRET strName;
    HRESULT hr;
    LPTSTR pszName = NULL;


    hr = pFolder->GetDisplayNameOf(pidl, SHGDN_NORMAL, &strName);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    hr = StrRetToStr(&strName, pidl, &pszName);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    // if we have been successful, assign return result
    if (pszName != NULL) {
        strDisplayName = pszName;
        CoTaskMemFree(pszName);
    } else {
        strDisplayName.erase();
    }
    return TRUE;
}

BOOL
CProgramList::GetPathFromLink(
    IShellLink* pLink,
    WIN32_FIND_DATA* pfd,
    tstring& strPath
    )
{
    TCHAR  szPath[MAX_PATH];
    HRESULT hr;

    hr = pLink->GetPath(szPath, sizeof(szPath)/sizeof(szPath[0]), pfd, 0);
    if (hr == S_OK) {
        strPath = szPath;
    }

    return hr == S_OK;
}

BOOL
CProgramList::GetArgumentsFromLink(
    IShellLink* pLink,
    tstring& strArgs
    )
{
    TCHAR szArgs[INFOTIPSIZE];

    HRESULT hr = pLink->GetArguments(szArgs, sizeof(szArgs)/sizeof(szArgs[0]));
    if (SUCCEEDED(hr)) {
        strArgs = szArgs;
    }

    return SUCCEEDED(hr);

}



LPITEMIDLIST
CProgramList::GetNextItemIDL(
    LPCITEMIDLIST pidl
    )
{
   // Check for valid pidl.
    if (pidl == NULL) {
        return NULL;
    }

    // Get the size of the specified item identifier.
    int cb = pidl->mkid.cb;

    // If the size is zero, it is the end of the list.
    if (cb == 0) {
        return NULL;
    }

    // Add cb to pidl (casting to increment by bytes).
    pidl = (LPITEMIDLIST) (((LPBYTE) pidl) + cb);

    // Return NULL if it is null-terminating, or a pidl otherwise.
    return (pidl->mkid.cb == 0) ? NULL : (LPITEMIDLIST) pidl;
}

LPITEMIDLIST
CProgramList::GetLastItemIDL(
    LPCITEMIDLIST pidl
    )
{
    LPITEMIDLIST pidlLast = (LPITEMIDLIST)pidl;

    if (pidl == NULL) {
        return NULL;
    }

    int cb = pidl->mkid.cb;
    if (cb == 0) {
        return NULL;
    }

    do {
        pidl = GetNextItemIDL(pidlLast);
        if (pidl != NULL) {
            pidlLast = (LPITEMIDLIST)pidl;
        }
    } while (pidl != NULL);

    return pidlLast;
}


UINT
CProgramList::GetSizeIDL(
    LPCITEMIDLIST pidl
    )
{
    UINT cbTotal = 0;
    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);    // Null terminator
        while (NULL != pidl)
        {
            cbTotal += pidl->mkid.cb;
            pidl = GetNextItemIDL(pidl);
        }
    }
    return cbTotal;
}

LPITEMIDLIST
CProgramList::AppendIDL(
    LPCITEMIDLIST pidlBase,
    LPCITEMIDLIST pidlAdd
    )
{
    if (NULL == pidlBase && NULL == pidlAdd) {
        return NULL;
    }

    LPITEMIDLIST pidlNew, pidlAlloc;

    UINT cb1 = pidlBase ? GetSizeIDL(pidlBase)  : 0;
    UINT cb2 = pidlAdd  ? GetSizeIDL(pidlAdd) : 0;

    UINT size = cb1 + cb2;
    pidlAlloc =
    pidlNew = (LPITEMIDLIST)GetMalloc()->Alloc(size);
    if (pidlNew)
    {
        if (NULL != pidlBase) {
            cb1 = pidlAdd ? cb1 - sizeof(pidlBase->mkid.cb) : cb1;
            RtlMoveMemory(pidlNew, pidlBase, cb1);
            pidlNew = (LPITEMIDLIST)((PBYTE)pidlNew + cb1);
        }

        if (NULL != pidlAdd) {
            RtlMoveMemory(pidlNew, pidlAdd, cb2);
        }
    }

    return pidlAlloc;
}


BOOL
CProgramList::ListMsiLink(
    LPCTSTR pszLocationParent,
    LPCTSTR pszDisplayName,
    LPCTSTR pszMsiPath,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull
    )
{
    //
    // make sure we have msi module handle
    //

    if (NULL == m_hMSI) {
        m_hMSI = LoadLibrary(TEXT("msi.dll"));
        if (NULL == m_hMSI) {
            m_hMSI = (HMODULE)-1;
            return FALSE;
        }

#ifdef _UNICODE
        m_pfnGetComponentPath  = (PMsiGetComponentPath )GetProcAddress(m_hMSI, "MsiGetComponentPathW");
        m_pfnGetShortcutTarget = (PMsiGetShortcutTarget)GetProcAddress(m_hMSI, "MsiGetShortcutTargetW");

#else
        m_pfnGetComponentPath  = (PMsiGetComponentPath )GetProcAddress(m_hMSI, "MsiGetComponentPathA");
        m_pfnGetShortcutTarget = (PMsiGetShortcutTarget)GetProcAddress(m_hMSI, "MsiGetShortcutTargetA");
#endif

        if (m_pfnGetComponentPath == NULL || m_pfnGetShortcutTarget == NULL) {
            FreeLibrary(m_hMSI);
            m_hMSI = (HMODULE)-1;
            return FALSE;
        }

    } else if (m_hMSI == (HMODULE)-1) {
        return FALSE;
    }

    UINT  ErrCode;
    TCHAR szProduct[MAX_PATH];
    TCHAR szFeatureId[MAX_PATH];
    TCHAR szComponentCode[MAX_PATH];

    ErrCode = m_pfnGetShortcutTarget(pszMsiPath, szProduct, szFeatureId, szComponentCode);
    if (ERROR_SUCCESS != ErrCode) {
        return FALSE;
    }

    INSTALLSTATE is;
    TCHAR  szPath[MAX_PATH];
    DWORD  cchPath = sizeof(szPath)/sizeof(szPath[0]);
    *szPath = 0;

    is = m_pfnGetComponentPath(szProduct, szComponentCode, szPath, &cchPath);
    if (INSTALLSTATE_LOCAL == is) {
        //
        // add this item
        //
        return AddItem(pszLocationParent,
                       pszDisplayName,
                       szPath,
                       NULL,
                       pFolder,
                       pidlFull,
                       TRUE);
    }

    return FALSE;
}

int
CProgramList::GetIconFromLink(
    LPCITEMIDLIST pidlLinkFull,
    LPCTSTR       lpszExePath
    )
{

    HRESULT hr;
    IShellFolder* pFolder = NULL;
    IExtractIcon* pExtractIcon = NULL;
    INT iIconIndex = 0;
    UINT uFlags    = 0;
    LPCITEMIDLIST pidlLink = 0;
    HICON hIconLarge = NULL;
    HICON hIconSmall = NULL;
    UINT  nIconSize;
    int ImageIndex = -1;
    UINT uiErrorMode;
    DWORD dwAttributes;

    TCHAR szIconFile[MAX_PATH];
    *szIconFile = TEXT('\0');

    uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hr = SHBindToParent(pidlLinkFull, IID_IShellFolder, (PVOID*)&pFolder, &pidlLink);
    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }

    // get the ui please
    hr = pFolder->GetUIObjectOf(m_hwndListView, 1, (LPCITEMIDLIST*)&pidlLink, IID_IExtractIcon, NULL, (PVOID*)&pExtractIcon);

    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }


    hr = pExtractIcon->GetIconLocation(0,
                                       szIconFile,
                                       sizeof(szIconFile) / sizeof(szIconFile[0]),
                                       &iIconIndex,
                                       &uFlags);

    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }

    if (*szIconFile == TEXT('*')) { // this is batch or some such, don't bother
        goto trySysImage;
    }

    //
    // before doing an extract, check whether it's available
    //

    dwAttributes = GetFileAttributes(szIconFile);


    if (dwAttributes == (DWORD)-1) {
        goto trySysImage;
    }


    nIconSize = MAKELONG(0, ::GetSystemMetrics(SM_CXSMICON));

    //
    // this call is likely to produce a popup, beware of that
    //
    hr = pExtractIcon->Extract(szIconFile,
                               iIconIndex,
                               &hIconLarge,
                               &hIconSmall,
                               nIconSize);

    //
    // if hIconSmall was retrieved - we were successful
    //

trySysImage:

    if (hIconSmall == NULL) {
        //
        // woops -- we could not extract an icon -- what a bummer
        // use shell api then
        SHFILEINFO FileInfo;
        HIMAGELIST hImageSys;

        hImageSys = (HIMAGELIST)SHGetFileInfo(lpszExePath,
                                              0,
                                              &FileInfo, sizeof(FileInfo),
                                              SHGFI_ICON|SHGFI_SMALLICON|SHGFI_SYSICONINDEX);
        if (hImageSys) {
            hIconSmall = ImageList_GetIcon(hImageSys, FileInfo.iIcon, ILD_TRANSPARENT);
        }
    }

    //
    // now that we have an icon, we can add it to our image list ?
    //
    if (hIconSmall != NULL) {
        ImageIndex = ImageList_AddIcon(m_hImageList, hIconSmall);
    }

///////////////////////// cleanup ///////////////////////////////////////////
    SetErrorMode(uiErrorMode);

    if (hIconSmall) {
        DestroyIcon(hIconSmall);
    }

    if (hIconLarge) {
        DestroyIcon(hIconLarge);
    }

    if (pExtractIcon != NULL) {
        pExtractIcon->Release();
    }
    if (pFolder != NULL) {
        pFolder->Release();
    }


    return ImageIndex;
}



BOOL
CProgramList::ListLink(
    LPCTSTR pszLocationParent,
    LPCTSTR pszDisplayName,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull,
    LPCITEMIDLIST pidlLink
    )
{
    IShellLink* psl = NULL;
    WIN32_FIND_DATA wfd;
    HRESULT  hr;
    BOOL     bSuccess = FALSE;
    tstring  strPath;
    tstring  strArgs;
    CComBSTR bstr;
    LPCTSTR  pszArgs = NULL;

    IPersistFile* ipf = NULL;
    IShellLinkDataList* pdl;
    DWORD dwFlags;
    BOOL  bMsiLink = FALSE;

    //
    // check whether we need to cancel
    //

    CheckForCancel();

    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLink, (LPVOID*)&psl);
    if (!SUCCEEDED(hr)) {
        return FALSE; // we can't create link object
    }

    hr = psl->SetIDList(pidlFull); // set the id list
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    //
    // now the shell link is ready to rumble
    //
    if (!GetPathFromLink(psl, &wfd, strPath)) {
        goto out;
    }


    // now let's see what is inside of this link -- shall we?


    hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ipf);
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    bstr = strPath.c_str();

    hr = ipf->Load(bstr, STGM_READ);

    if (SUCCEEDED(hr)) {

        //
        // resolve the link for now
        //
        // hr = psl->Resolve(NULL, SLR_NO_UI|SLR_NOUPDATE);


        hr = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&pdl);
        if (SUCCEEDED(hr)) {
            hr = pdl->GetFlags(&dwFlags);

            bMsiLink = SUCCEEDED(hr) && (dwFlags & SLDF_HAS_DARWINID);

            pdl->Release();
        }

        if (bMsiLink) {

            bSuccess = ListMsiLink(pszLocationParent, pszDisplayName, strPath.c_str(), pFolder, pidlFull);

        } else {

            //
            // we now get the path from the link -- and that's that
            //
            if (GetPathFromLink(psl, &wfd, strPath)) {

                if (GetArgumentsFromLink(psl, strArgs)) {
                    pszArgs = strArgs.c_str();
                }

                //
                // add this to our list view
                //

                bSuccess = AddItem(pszLocationParent,
                                   pszDisplayName,
                                   strPath.c_str(),
                                   pszArgs,
                                   pFolder,
                                   pidlFull);

            }
        }

    }

    if (NULL != ipf) {
        ipf->Release();
    }


out:
    if (NULL != psl) {
        psl->Release();
    }

    return bSuccess;

}



BOOL
CProgramList::ListFolder(
    LPCTSTR       pszLocation, // ui string - where is this folder located?
    IShellFolder* pParent,     // parent folder
    LPCITEMIDLIST pidlFull,     // idl of the full path to the folder
    LPCITEMIDLIST pidlFolder    // idl of this folder relative to the pidlFull
    )
{
    LPENUMIDLIST penum = NULL;
    LPITEMIDLIST pidl  = NULL;
    HRESULT      hr;

    ULONG        celtFetched;
    ULONG        uAttr;
    tstring      strDisplayNameLocation;
    tstring      strDisplayName;

    IShellFolder* pFolder = NULL;
    BOOL bDesktop = FALSE;

    BOOL bCancel = FALSE;
    CCancelException* pCancelException = NULL;

    CheckForCancel();

    if (pParent == NULL) {
        hr = SHGetDesktopFolder(&pParent);
        bDesktop = TRUE;
    }

    hr = pParent->BindToObject(pidlFolder,
                                 NULL,
                               IID_IShellFolder,
                               (LPVOID *) &pFolder);

    if (NULL == pszLocation) {
        GetDisplayName(pParent, pidlFolder, strDisplayNameLocation);
    } else {
        strDisplayNameLocation = pszLocation;
    }

    if (bDesktop) {
        pParent->Release();
    }

    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    hr = pFolder->EnumObjects(NULL,SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum);
    if (!SUCCEEDED(hr)) {
        pFolder->Release(); // free the folder- - and go away
        return FALSE;
    }


    while( (hr = penum->Next(1,&pidl, &celtFetched)) == S_OK && celtFetched == 1 && !bCancel) {
        LPITEMIDLIST pidlCur;

        if (pidlFull == NULL) {
            pidlFull = pidlFolder;
        }

        pidlCur = AppendIDL(pidlFull, pidl);

        // get the display name of this item
        GetDisplayName(pFolder, pidl, strDisplayName);


        uAttr = SFGAO_FOLDER | SFGAO_LINK;
        hr = pFolder->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &uAttr);
        if (SUCCEEDED(hr)) {

            try {

                if (uAttr & SFGAO_FOLDER) {
                    //
                    // dump folder recursively
                    //
                    ListFolder(strDisplayName.c_str(), pFolder, pidlCur, pidl);

                } else if (uAttr & SFGAO_LINK) {

                    ListLink(strDisplayNameLocation.c_str(), strDisplayName.c_str(), pFolder, pidlCur, pidl);

                } else if (uAttr & SFGAO_FILESYSTEM) {
                    //
                    // this item is a file
                    //
                    AddItem(strDisplayNameLocation.c_str(),
                            strDisplayName.c_str(),
                            NULL,
                            NULL,
                            pFolder,
                            pidlCur,
                            TRUE);

                }

            } catch(CCancelException* pex) {
                //
                // we need to cancel -- we shall cleanup and do what we need, then re-throw
                //
                bCancel = TRUE;
                pCancelException = pex;
            }

        }
        GetMalloc()->Free(pidlCur);
        GetMalloc()->Free(pidl);

    }

    if (NULL != penum) {
        penum->Release();
    }

    if (NULL != pFolder) {
        pFolder->Release();
    }

    if (bCancel && pCancelException) {
        throw pCancelException;
    }

    return TRUE;
}


BOOL
CProgramList::IsSFCItem(
    LPCTSTR pszPath
    )
{

#ifndef _UNICODE
    WCHAR wszBuffer[1024];

    mbstowcs(wszBuffer, pszPath, sizeof(wszBuffer)/sizeof(wszBuffer[0]));
    return SfcIsFileProtected(NULL, wszBuffer);
#else

    return SfcIsFileProtected(NULL, pszPath);

#endif

}

BOOL
CProgramList::IsItemInSystemDirectory(
    LPCTSTR pszPath
    )
{
    TCHAR szCommonPath[MAX_PATH];
    int nch;
    string s;

    nch = PathCommonPrefix(m_strSystemDirectory.c_str(), pszPath, szCommonPath);
    return nch == m_strSystemDirectory.length();
}

BOOL
ValidateExecutableFile(
    LPCTSTR pszPath,
    BOOL    bValidateFileExists
    )
{
    LPTSTR rgExt[] = {
            TEXT("EXE"),
            TEXT("BAT"),
            TEXT("CMD"),
            TEXT("PIF"),
            TEXT("COM"),
            TEXT("LNK")
            };
    LPTSTR pExt;
    int i;
    BOOL bValidatedExt = FALSE;

    pExt = PathFindExtension(pszPath);
    if (pExt == NULL || *pExt == TEXT('\0')) {
        return FALSE;
    }
    ++pExt;

    for (i = 0; i < sizeof(rgExt)/sizeof(rgExt[0]) && !bValidatedExt; ++i) {
            bValidatedExt = !_tcsicmp(pExt, rgExt[i]);
    }

    if (!bValidatedExt) {
        return FALSE;
    }


    return bValidateFileExists ? PathFileExists(pszPath) : TRUE;
}


BOOL
CProgramList::AddItem(
    LPCTSTR pszLocation,
    LPCTSTR pszDisplayName,
    LPCTSTR pszPath,
    LPCTSTR pszArguments,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull,
    BOOL    bUsePath
    )
{
    //
    // first test -- is this one of the types we like?
    //
    LPTSTR  pchSlash;
    LPTSTR  pchDot;
    LPTSTR  rgExt[] = { TEXT("EXE"), TEXT("BAT"), TEXT("CMD"), TEXT("PIF"), TEXT("COM"), TEXT("LNK") };
    BOOL    bValidatedExt = FALSE;
    BOOL    bSuccess = FALSE;
    PSHITEMINFO pInfo = NULL;
    MAPSTR2ITEM::iterator Iter;
    TCHAR   szPathExecute[MAX_PATH];
    tstring strKey;
    tstring strKeyExe;
    DWORD   dwBinaryType = 0;

    LVITEM  lvi;
    int     ix;


    //
    // check for cancelling the search
    //
    CheckForCancel();

    if (NULL == pszPath) {
        pszPath = szPathExecute;

        if (!SHGetPathFromIDList(pidlFull, szPathExecute)) {
            goto out;
        }
    }

    if (pszDisplayName && m_pProgView) {
        m_pProgView->UpdatePopulateStatus(pszDisplayName, pszPath);
    }

    pchSlash = _tcsrchr(pszPath, TEXT('\\'));
    pchDot   = _tcsrchr(pszPath, TEXT('.'));

    if (NULL != pchSlash) {
        if ((ULONG_PTR)pchDot < (ULONG_PTR)pchSlash) {
            pchDot = NULL;
        }
    }

    if (NULL != pchDot) {
        ++pchDot;

        for (int i = 0; i < sizeof(rgExt)/sizeof(rgExt[0]) && !bValidatedExt; ++i) {
            bValidatedExt = !_tcsicmp(pchDot, rgExt[i]);
        }
    }

    if (!bValidatedExt) {
        goto out;
    }

    //
    // Checks whether the item is in system directory or SFC-protected
    //
#if 0
    if (IsItemInSystemDirectory(pszPath) || IsSFCItem(pszPath)) {
        goto out;
    }
#endif

    //
    // GetBinaryTypeW excludes exes on the basis of binary type
    //
    if (GetBinaryType(pszPath, &dwBinaryType) &&
        dwBinaryType == SCS_64BIT_BINARY) {
        goto out;
    }

    if (IsSFCItem(pszPath)) {
        goto out;
    }

    //
    // this is multimap key
    //
    strKeyExe = StrUpCase(wstring(pszPath));

    //
    // check whether this has been excluded
    //
    if (m_pProgView->IsFileExcluded(strKeyExe.c_str())) {
        goto out;
    }

    //
    // now compose the key string
    //
    strKey = strKeyExe;
    if (NULL != pszArguments) {
        strKey.append(TEXT(" "));
        strKey.append(pszArguments);
    }

    //
    // now check whether this item has already been listed
    //

    Iter = m_mapItems.find(strKey);
    if (Iter != m_mapItems.end()) { // found a duplicate
        goto out;
    }

    //
    // now please add this item to the list view
    //
    pInfo = new CProgramList::SHITEMINFO;
    if (pInfo == NULL) {
        ThrowMemoryException(__FILE__, __LINE__, TEXT("%s\n"), TEXT("Failed to allocate Item Information structure"));
    }

    pInfo->strDisplayName = pszDisplayName;
    pInfo->strFolder      = pszLocation;
    pInfo->strPath        = pszPath;
    pInfo->strCmdLine     = strKey;
    if (NULL != pszArguments) {
        pInfo->strArgs = pszArguments;
    }
    pInfo->pidl           = AppendIDL(NULL, pidlFull);

    if (bUsePath) {
        pInfo->strPathExecute = pszPath;
    } else {

        // finally, what are we going to launch ?
        if (SHGetPathFromIDList(pidlFull, szPathExecute)) {
            pInfo->strPathExecute = szPathExecute;
        }
    }


    m_mapItems[strKey] = pInfo;

    m_mmapExeItems.insert(MULTIMAPSTR2ITEM::value_type(strKeyExe, pInfo));

    ATLTRACE(TEXT("Adding item %s %s %s\n"), pszDisplayName, pszLocation, pszPath);

    lvi.mask = LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
    lvi.iItem = ListView_GetItemCount(m_hwndListView); // append at the end please
    lvi.iSubItem = 0;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    lvi.iImage  = I_IMAGECALLBACK;
    lvi.lParam  = (LPARAM)pInfo;
    ix = ListView_InsertItem(m_hwndListView, &lvi);

    lvi.mask = LVIF_TEXT;
    lvi.iItem = ix;
    lvi.iSubItem = 1;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    ListView_SetItem(m_hwndListView, &lvi);

    bSuccess = TRUE;

out:

    return bSuccess;
}

BOOL
CProgramList::PopulateControl(
    CProgView* pProgView,
    HANDLE     hevtCancel
    )
{
    int i;
    HRESULT hr;
    LPITEMIDLIST pidl;
    BOOL bCancel = FALSE;
    struct {
        INT csidl;
        UINT nIDDescription;
    } rgFolders[] = {
        { CSIDL_DESKTOPDIRECTORY, IDS_DESKTOP             },
        { CSIDL_COMMON_STARTMENU, IDS_COMMON_STARTMENU    },
        { CSIDL_STARTMENU,        IDS_STARTMENU           },
        { CSIDL_COMMON_PROGRAMS,  IDS_COMMON_PROGRAMS     },
        { CSIDL_PROGRAMS,         IDS_PROGRAMS            }
    };


    //
    // set the progview object pointer so we could update the status
    //
    m_pProgView = pProgView;

    m_pMallocUI = pProgView->m_pMallocUI;

    //
    // set the event so that we could cancel the scan
    //
    m_hEventCancel = hevtCancel;


    //
    // set extended style
    //

    ListView_SetExtendedListViewStyleEx(m_hwndListView,
                                        LVS_EX_INFOTIP|LVS_EX_LABELTIP,
                                        LVS_EX_INFOTIP|LVS_EX_LABELTIP);

    //
    //  fix columns
    //


    LVCOLUMN lvc;
    RECT     rc;
    SIZE_T   cxProgName;
    SIZE_T   cx;
    wstring  strCaption;

    lvc.mask = LVCF_WIDTH;
    if (!ListView_GetColumn(m_hwndListView, 2, &lvc)) {

        ::GetClientRect(m_hwndListView, &rc);
        cx = rc.right - rc.left -
                ::GetSystemMetrics(SM_CXVSCROLL) -
                ::GetSystemMetrics(SM_CXEDGE) -
                ::GetSystemMetrics(SM_CXSIZEFRAME);


        cxProgName = cx * 3 / 5;
        strCaption = LoadResourceString(IDS_PROGRAMNAME);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cxProgName;
        lvc.iSubItem= 0;
        ListView_InsertColumn(m_hwndListView, 0, &lvc);

        cx -= cxProgName;

        cxProgName = cx / 2;
        strCaption = LoadResourceString(IDS_FOLDER);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cxProgName;
        lvc.iSubItem= 1;
        ListView_InsertColumn(m_hwndListView, 1, &lvc);

        strCaption = LoadResourceString(IDS_SETTINGS);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cx - cxProgName;
        lvc.iSubItem= 2;
        ListView_InsertColumn(m_hwndListView, 2, &lvc);

    }

    HDC hDC = GetDC(m_hwndListView);
    int nBitsPixel = ::GetDeviceCaps(hDC, BITSPIXEL);
    int nPlanes    = ::GetDeviceCaps(hDC, PLANES);
    UINT flags;

    nBitsPixel *= nPlanes;
    if (nBitsPixel < 4) {
        flags = ILC_COLOR;
    } else if (nBitsPixel < 8) {
        flags = ILC_COLOR4;
    } else if (nBitsPixel < 16) {
        flags = ILC_COLOR8;
    } else if (nBitsPixel < 24) {
        flags = ILC_COLOR16;
    } else if (nBitsPixel < 32) {
        flags = ILC_COLOR24;
    } else if (nBitsPixel == 32) {
        flags = ILC_COLOR32;
    } else {
        flags = ILC_COLORDDB;
    }

    flags |= ILC_MASK;

    ReleaseDC(m_hwndListView, hDC);

    m_hImageList = ImageList_Create(::GetSystemMetrics(SM_CXSMICON),
                                    ::GetSystemMetrics(SM_CYSMICON),
                                    flags,
                                    10,
                                    25);
    if (m_hImageList == NULL) {
        ATLTRACE(TEXT("Image List creation failure, error 0x%lx\n"), GetLastError());
    }

    ImageList_SetBkColor(m_hImageList, CLR_NONE);

    ListView_SetImageList(m_hwndListView, m_hImageList, LVSIL_SMALL);

    ::SendMessage(m_hwndListView, WM_SETREDRAW, FALSE, 0);

    ListView_DeleteAllItems(m_hwndListView);

    //
    // AtlTrace(TEXT("Callback Mask: 0x%lx\n"), ListView_GetCallbackMask(m_hwndListView));
    //

    for (i = 0; i < sizeof(rgFolders)/sizeof(rgFolders[0]) && !bCancel; ++i) {
        wstring strDescription = LoadResourceString(rgFolders[i].nIDDescription);

        hr = SHGetFolderLocation(NULL, rgFolders[i].csidl, NULL, 0, &pidl);
        if (SUCCEEDED(hr)) {
            try {
                ListFolder(strDescription.c_str(), NULL, NULL, pidl);
            } catch(CCancelException* pex) {
                bCancel = TRUE;
                pex->Delete();
            } catch(CException* pex) {
                bCancel = TRUE;
                pex->Delete();
            }
            GetMalloc()->Free(pidl);
        }
    }

    ::SendMessage(m_hwndListView, WM_SETREDRAW, TRUE, 0);

    return TRUE;

}

BOOL
CProgramList::CaptureSelection(
    VOID
    )
{
    INT iSelected;
    LVITEM lvi;

    m_pSelectionInfo = NULL;

    iSelected = ListView_GetNextItem(m_hwndListView, -1, LVNI_SELECTED);

    if (iSelected == -1) {
        return FALSE;
    }

    lvi.iItem = iSelected;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;
    if (ListView_GetItem(m_hwndListView, &lvi)) {
        m_pSelectionInfo = (PSHITEMINFO)lvi.lParam;
    }

    return m_pSelectionInfo != NULL;

}

BOOL
CProgramList::GetSelectionDetails(
    INT iInformationClass,
    VARIANT* pVal
    )
{
    CComBSTR bstr;

    if (m_pSelectionInfo == NULL) {
        pVal->vt = VT_NULL;
        return TRUE;
    }

    switch(iInformationClass) {
    case PROGLIST_DISPLAYNAME:
        bstr = m_pSelectionInfo->strDisplayName.c_str();
        break;

    case PROGLIST_LOCATION:     //
        bstr = m_pSelectionInfo->strFolder.c_str();
        break;

    case PROGLIST_EXENAME:      // cracked exe name
        bstr = m_pSelectionInfo->strPath.c_str(); //
        break;

    case PROGLIST_CMDLINE:      // complete exe name + parameters
        bstr = m_pSelectionInfo->strCmdLine.c_str();
        break;

    case PROGLIST_EXECUTABLE:    // what we should execute (link or exe, not cracked)
        bstr = m_pSelectionInfo->strPathExecute.c_str();
        break;

    case PROGLIST_ARGUMENTS:
        bstr = m_pSelectionInfo->strArgs.c_str();
        break;

    default:
        pVal->vt = VT_NULL;
        return TRUE;
        break;
    }


    pVal->vt = VT_BSTR;
    pVal->bstrVal = bstr.Copy();

    return TRUE;
}

#define PROGLIST_SORT_NONE 0
#define PROGLIST_SORT_ASC  1
#define PROGLIST_SORT_DSC  2


int CALLBACK
CProgramList::SHItemInfoCompareFunc(
    LPARAM lp1,
    LPARAM lp2,
    LPARAM lParamSort
    )
{
    PSHITEMINFO pInfo1 = (PSHITEMINFO)lp1;
    PSHITEMINFO pInfo2 = (PSHITEMINFO)lp2;
    BOOL bEmpty1, bEmpty2;
    int nColSort   = (int)LOWORD(lParamSort);
    int nSortOrder = (int)HIWORD(lParamSort);
    int iRet = 0;

    switch(nColSort) {
    case 0: // SORT_APPNAME:
        iRet = _tcsicmp(pInfo1->strDisplayName.c_str(),
                        pInfo2->strDisplayName.c_str());
        break;

    case 1: // SORT_APPLOCATION:
        iRet = _tcsicmp(pInfo1->strFolder.c_str(),
                        pInfo2->strFolder.c_str());
        break;

    case 2: // SORT_LAYERS:
        bEmpty1 = pInfo1->strKeys.empty();
        bEmpty2 = pInfo2->strKeys.empty();
        if (bEmpty1 || bEmpty2) {
            if (bEmpty1) {
                iRet = bEmpty2 ? 0 : 1;
            } else {
                iRet = bEmpty1 ? 0 : -1;
            }
        } else {

            iRet = _tcsicmp(pInfo1->strKeys.c_str(),
                            pInfo2->strKeys.c_str());
        }

        break;
    }

    if (nSortOrder == PROGLIST_SORT_DSC) {
        iRet = -iRet;
    }

    return iRet;
}



LRESULT
CProgramList::LVNotifyColumnClick(
    LPNMHDR pnmhdr,
    BOOL&   bHandled
    )
{
    LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW)pnmhdr;

    // lpnmlv->iSubItem - this is what we have to sort on
    // check whether we already have something there

    HWND hwndHeader = ListView_GetHeader(m_hwndListView);
    INT  nCols;
    INT  i;
    INT  nColSort = lpnmlv->iSubItem;
    LPARAM lSortParam; // leave high word blank for now
    LPARAM lSortOrder = PROGLIST_SORT_ASC;
    HDITEM hdi;
    //
    // reset current image - wherever that is
    //
    nCols = Header_GetItemCount(hwndHeader);

    for (i = 0; i < nCols; ++i) {
        hdi.mask = HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
        if (!Header_GetItem(hwndHeader, i, &hdi)) {
            continue;
        }

        if (i == nColSort && (hdi.mask & HDI_LPARAM)) {
            switch(hdi.lParam) {
            case PROGLIST_SORT_NONE:
            case PROGLIST_SORT_DSC:
                lSortOrder = PROGLIST_SORT_ASC;
                break;
            case PROGLIST_SORT_ASC:
                lSortOrder = PROGLIST_SORT_DSC;
                break;
            }
        }

        if (hdi.mask & HDI_BITMAP) {
            DeleteObject((HGDIOBJ)hdi.hbm);
        }

        hdi.lParam = PROGLIST_SORT_NONE;
        hdi.fmt &= ~(HDF_BITMAP|HDF_BITMAP_ON_RIGHT);
        hdi.mask |= HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
        hdi.hbm = NULL;
        Header_SetItem(hwndHeader, i, &hdi);
    }

    lSortParam = MAKELONG(nColSort, lSortOrder);
    ListView_SortItems(m_hwndListView, (PFNLVCOMPARE)SHItemInfoCompareFunc, lSortParam);

    // now, load the image please
    m_hbmSort = (HBITMAP)::LoadImage(_Module.GetResourceInstance(),
                                     MAKEINTRESOURCE(lSortOrder == PROGLIST_SORT_ASC? IDB_SORTUP : IDB_SORTDN),
                                     IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
    hdi.mask = HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
    Header_GetItem(hwndHeader, nColSort,  &hdi);
    hdi.mask   |= HDI_BITMAP|HDI_FORMAT|HDI_LPARAM;
    hdi.hbm    = m_hbmSort;
    hdi.fmt    |= HDF_BITMAP|HDF_BITMAP_ON_RIGHT;
    hdi.lParam = lSortOrder;
    Header_SetItem(hwndHeader, nColSort, &hdi);


    bHandled = TRUE;
    return 0;
}

LRESULT
CProgramList::LVNotifyDispInfo(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{

    WCHAR wszPermKeys[MAX_PATH];
    DWORD cbSize;

    LV_ITEM &lvItem = reinterpret_cast<LV_DISPINFO*>(pnmhdr)->item;

    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = lvItem.iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bummer, we can't retrieve an item -- if we let it go, things will be worse
        lvItem.mask &= ~(LVIF_TEXT|LVIF_IMAGE);
        lvItem.mask |= LVIF_DI_SETITEM;
        bHandled = TRUE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    if (lvItem.mask & LVIF_TEXT) {
        switch (lvItem.iSubItem) {
        case 0:
            lvItem.pszText = (LPTSTR)pInfo->strDisplayName.c_str();
            break;
        case 1:
            lvItem.pszText = (LPTSTR)pInfo->strFolder.c_str();
            break;
        case 2:
            // check with SDB
            cbSize = sizeof(wszPermKeys);
            if (pInfo->strKeys.empty()) {

                if (SdbGetPermLayerKeys(pInfo->strPath.c_str(), wszPermKeys, &cbSize, GPLK_ALL)) {
                    pInfo->strKeys = wszPermKeys;
                }

            }

            if (!pInfo->strKeys.empty()) {
                lvItem.pszText = (LPTSTR)pInfo->strKeys.c_str();
            }

            break;

        default:
            break;
        }
    }


    if (lvItem.mask & LVIF_IMAGE) {
        lvItem.iImage = GetIconFromLink(pInfo->pidl, pInfo->strPathExecute.c_str());
    }

    lvItem.mask |= LVIF_DI_SETITEM;
    bHandled = TRUE;
    return 0;

}

LRESULT
CProgramList::LVNotifyGetInfoTip(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{
    DWORD cbSize;
    LPNMLVGETINFOTIP pGetInfoTip = (LPNMLVGETINFOTIP)pnmhdr;
    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = pGetInfoTip->iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bupkas
        bHandled = FALSE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    //
    // now we can fiddle
    //

    _tcsncpy(pGetInfoTip->pszText, pInfo->strCmdLine.c_str(), pGetInfoTip->cchTextMax);
    *(pGetInfoTip->pszText + pGetInfoTip->cchTextMax - 1) = TEXT('\0');

    bHandled = TRUE;
    return 0;

}

LRESULT
CProgramList::LVNotifyRClick(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{

    DWORD dwPos = ::GetMessagePos();
    LVHITTESTINFO hti;
    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    HRESULT hr;
    LPITEMIDLIST  pidlItem = NULL;
    IShellFolder* pFolder  = NULL;
    IContextMenu* pContextMenu = NULL;
    CMINVOKECOMMANDINFO ici;
    int nCmd;
    HMENU hMenu = NULL;
    UINT  idMin, idMax, idCmd;
    WCHAR szCmdVerb[MAX_PATH];
    int nLastSep, i, nLastItem;

    hti.pt.x = (int) LOWORD (dwPos);
    hti.pt.y = (int) HIWORD (dwPos);
    ScreenToClient (m_hwndListView, &hti.pt);

    ListView_HitTest (m_hwndListView, &hti);

    if (!(hti.flags & LVHT_ONITEM)) {
        bHandled = FALSE;
        return 0;
    }

    lvi.mask  = LVIF_PARAM;
    lvi.iItem = hti.iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bupkas
        bHandled = FALSE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    //
    // we have an item, show it's context menu then
    //

    hr = SHBindToParent(pInfo-> pidl, IID_IShellFolder, (PVOID*)&pFolder, (LPCITEMIDLIST*)&pidlItem);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    // get the ui please
    hr = pFolder->GetUIObjectOf(m_hwndListView, 1, (LPCITEMIDLIST*)&pidlItem, IID_IContextMenu, NULL, (PVOID*)&pContextMenu);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    hMenu = CreatePopupMenu();
    if (hMenu == NULL) {
        goto cleanup;
    }

    hr = pContextMenu->QueryContextMenu(hMenu,
                                        0,
                                        1,
                                        0x7FFF,
                                        CMF_EXPLORE);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }



    //
    // sanitize
    //
    idMin = 1;
    idMax = HRESULT_CODE(hr);

    for (idCmd = 0; idCmd < idMax; ++idCmd) {
        hr = pContextMenu->GetCommandString(idCmd, GCS_VERBW, NULL, (LPSTR)szCmdVerb, CHARCOUNT(szCmdVerb));
        if (SUCCEEDED(hr)) {
            if (!_wcsicmp(szCmdVerb, TEXT("cut"))    ||
                !_wcsicmp(szCmdVerb, TEXT("delete")) ||
                !_wcsicmp(szCmdVerb, TEXT("rename")) ||
                !_wcsicmp(szCmdVerb, TEXT("link"))) {
                //
                // not allowed
                //
                DeleteMenu(hMenu, idCmd + idMin, MF_BYCOMMAND);
            }
        }
    }

    //
    // after doing some basic sanitization against the destructive tendencies --
    // nuke double-separators
    //

    nLastItem = ::GetMenuItemCount(hMenu) - 1;
    nLastSep = nLastItem + 1;
    for (i = nLastItem; i >= 0; --i) {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_FTYPE;
        if (GetMenuItemInfo(hMenu, i, TRUE, &mii)) {
            if (mii.fType & MFT_SEPARATOR) {
                if (nLastSep == i + 1 || i == 0) {
                    // this sep is dead
                    DeleteMenu(hMenu, i, MF_BYPOSITION);
                }
                nLastSep = i;
            }
        }
    }



    ClientToScreen(m_hwndListView, &hti.pt);
    nCmd = TrackPopupMenu(hMenu,
                          TPM_LEFTALIGN |
                            TPM_LEFTBUTTON |
                            TPM_RIGHTBUTTON |
                            TPM_RETURNCMD,
                          hti.pt.x, hti.pt.y,
                          0,
                          m_hwndListView,
                          NULL);

    //
    // execute command
    //
    if (nCmd) {
        ici.cbSize          = sizeof (CMINVOKECOMMANDINFO);
        ici.fMask           = 0;
        ici.hwnd            = m_hwndListView;
        ici.lpVerb          = MAKEINTRESOURCEA(nCmd - 1);
        ici.lpParameters    = NULL;
        ici.lpDirectory     = NULL;
        ici.nShow           = SW_SHOWNORMAL;
        ici.dwHotKey        = 0;
        ici.hIcon           = NULL;
        hr = pContextMenu->InvokeCommand(&ici);

        //
        // requery perm layer keys -- useless here btw
        //
        /* // this code will not work since the call above is always asynchronous
           //
        if (SUCCEEDED(hr)) {
            DWORD cbSize;
            WCHAR wszPermKeys[MAX_PATH];

            cbSize = sizeof(wszPermKeys);
            if (SdbGetPermLayerKeys(pInfo->strPath.c_str(), wszPermKeys, &cbSize)) {
                pInfo->strKeys = wszPermKeys;
            } else {
                pInfo->strKeys.erase();
            }

            //
            // set the info into the list box
            //
            ListView_SetItemText(m_hwndListView, lvi.iItem, 2, (LPWSTR)pInfo->strKeys.c_str());

        }
        */


    }

cleanup:

    if (hMenu) {
        DestroyMenu(hMenu);
    }
    if (pContextMenu) {
        pContextMenu->Release();
    }
    if (pFolder) {
        pFolder->Release();
    }

    bHandled = TRUE;
    return 0;
}



BOOL
CProgramList::UpdateListItem(
    LPCWSTR pwszPath,
    LPCWSTR pwszKey
    )
{

    // find the item first

    MAPSTR2ITEM::iterator iter;
    MULTIMAPSTR2ITEM::iterator iterExe;
    MULTIMAPSTR2ITEM::iterator iterFirstExe, iterLastExe;

    tstring     strKey = pwszPath;
    tstring     strExeKey;
    PSHITEMINFO pInfo = NULL;
    PSHITEMINFO pInfoExe = NULL;

    //
    // we need to iterate through all the persisted items
    //
    StrUpCase(strKey);

    iter = m_mapItems.find(strKey);
    if (iter != m_mapItems.end()) {
        pInfo = (*iter).second;
    }

    if (pInfo == NULL) {
        return FALSE;
    }

    //
    // once we have found this single item, get the command and
    // show info for all the other affected items
    //
    strExeKey = pInfo->strPath;
    StrUpCase(strExeKey);

    iterFirstExe = m_mmapExeItems.lower_bound(strExeKey);
    iterLastExe  = m_mmapExeItems.upper_bound(strExeKey);

    for (iterExe = iterFirstExe; iterExe != m_mmapExeItems.end() && iterExe != iterLastExe; ++iterExe) {
        pInfoExe = (*iterExe).second;


        // find this item in a listview

        LVFINDINFO lvf;
        INT index;

        lvf.flags = LVFI_PARAM;
        lvf.lParam = (LPARAM)pInfoExe;

        index = ListView_FindItem(m_hwndListView, -1, &lvf);
        if (index < 0) {
            return FALSE; // inconsistent
        }

        // else we have both the item and the keys
        if (pwszKey == NULL) {
            pInfoExe->strKeys.erase();
        } else {
            pInfoExe->strKeys = pwszKey;
        }

        ListView_SetItemText(m_hwndListView, index, 2, (LPWSTR)pInfoExe->strKeys.c_str());
    }

    return TRUE;
}



BOOL
CProgramList::IsEnabled(
    VOID
    )
{

    if (::IsWindow(m_hwndListView)) {
        return ::IsWindowEnabled(m_hwndListView);
    }

    return FALSE;
}


VOID
CProgramList::Enable(
    BOOL bEnable
    )
{
    if (::IsWindow(m_hwndListView)) {

        ::EnableWindow(m_hwndListView, bEnable);
    }

}

BOOL
GetProgramListSelection(
    CProgramList* pProgramList
    )
{
    return pProgramList->CaptureSelection();
}


BOOL
GetProgramListSelectionDetails(
    CProgramList* pProgramList,
    INT iInformationClass,
    VARIANT* pVal
    )
{
    return pProgramList->GetSelectionDetails(iInformationClass, pVal);
}

LRESULT
NotifyProgramList(
    CProgramList* pProgramList,
    LPNMHDR       pnmhdr,
    BOOL&         bHandled
    )
{
    LRESULT lRet = 0;

    switch (pnmhdr->code) {
    case LVN_GETDISPINFO:
        lRet = pProgramList->LVNotifyDispInfo(pnmhdr, bHandled);
        break;

    case LVN_COLUMNCLICK:
        lRet = pProgramList->LVNotifyColumnClick(pnmhdr, bHandled);
        break;

    case LVN_GETINFOTIP:
        lRet = pProgramList->LVNotifyGetInfoTip(pnmhdr, bHandled);
        break;

    case NM_RCLICK:
        lRet = pProgramList->LVNotifyRClick(pnmhdr, bHandled);
        break;

    default:
        bHandled = FALSE;
        break;
    }

    return lRet;
}

BOOL
GetProgramListEnabled(
    CProgramList* pProgramList
    )
{
    return pProgramList->IsEnabled();
}

VOID
EnableProgramList(
    CProgramList* pProgramList,
    BOOL bEnable
    )
{
    pProgramList->Enable(bEnable);
}

BOOL
UpdateProgramListItem(
    CProgramList* pProgramList,
    LPCWSTR pwszPath,
    LPCWSTR pwszKeys
    )
{
    return pProgramList->UpdateListItem(pwszPath, pwszKeys);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\selectfile.h ===
// SelectFile.h : Declaration of the CSelectFile

#ifndef __SELECTFILE_H_
#define __SELECTFILE_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "compatuiCP.h"
extern "C" {
    #include "shimdb.h"
}

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <locale>
#include <algorithm>
#include <vector>
using namespace std;

//
// Accel containment code
//
#include "AccelContainer.h"

//
// in ProgList.cpp
//

BOOL
ValidateExecutableFile(
    LPCTSTR pszPath,
    BOOL    bValidateFileExists
    );

//
// in util.cpp
//
wstring
ShimUnquotePath(
    LPCTSTR pwszFileName
    );

BOOL
ShimExpandEnvironmentVars(
    LPCTSTR lpszCmd,
    CComBSTR& bstr
    );

/////////////////////////////////////////////////////////////////////////////
// CSelectFile
class ATL_NO_VTABLE CSelectFile :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CSelectFile, ISelectFile, &IID_ISelectFile, &LIBID_COMPATUILib>,
    public CComCompositeControl<CSelectFile>,
    public IPersistStreamInitImpl<CSelectFile>,
    public IOleControlImpl<CSelectFile>,
    public IOleObjectImpl<CSelectFile>,
    public IOleInPlaceActiveObjectImpl<CSelectFile>,
    public IViewObjectExImpl<CSelectFile>,
    public IOleInPlaceObjectWindowlessImpl<CSelectFile>,
    public CComCoClass<CSelectFile, &CLSID_SelectFile>,
    public ISupportErrorInfo,
    public IPersistPropertyBagImpl<CSelectFile>,
    public IConnectionPointContainerImpl<CSelectFile>,
    public CProxy_ISelectFileEvents< CSelectFile >,
    public IPropertyNotifySinkCP< CSelectFile >,
    public IProvideClassInfo2Impl<&CLSID_SelectFile, &DIID__ISelectFileEvents, &LIBID_COMPATUILib>,
    public CProxy_IProgViewEvents< CSelectFile >
{
public:
    CSelectFile() :
      m_dwBrowseFlags(0), m_Safe(this)
    {
        m_bWindowOnly    = TRUE;
        m_bTabStop       = TRUE;
        m_bMouseActivate = FALSE;
        CalcExtent(m_sizeExtent);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SELECTFILE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSelectFile)
    COM_INTERFACE_ENTRY(ISelectFile)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
//    COM_INTERFACE_ENTRY(ISupportErrorInfo)
//    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)

    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)

END_COM_MAP()

BEGIN_PROP_MAP(CSelectFile)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("BackStyle", DISPID_BACKSTYLE, CLSID_NULL)
//    PROP_ENTRY("BorderColor", DISPID_BORDERCOLOR, CLSID_StockColorPage)
//    PROP_ENTRY("BorderVisible", DISPID_BORDERVISIBLE, CLSID_NULL)
    PROP_ENTRY("Enabled", DISPID_ENABLED, CLSID_NULL)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
    PROP_ENTRY("Accel",            7, CLSID_NULL)
    PROP_ENTRY("ExternAccel",      8, CLSID_NULL)
    PROP_ENTRY("BrowseBtnCaption", 9, CLSID_NULL)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CSelectFile)
CONNECTION_POINT_ENTRY(DIID__ISelectFileEvents)
// CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
CONNECTION_POINT_ENTRY(DIID__IProgViewEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CSelectFile)
    COMMAND_HANDLER(IDC_BROWSE, BN_CLICKED, OnClickedBrowse)

//    MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorDlg)
//    MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorDlg)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

    CHAIN_MSG_MAP(CComCompositeControl<CSelectFile>)

// ALT_MSG_MAP(1)

END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CSelectFile)
    //Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
    {
        if (dispid == DISPID_AMBIENT_BACKCOLOR)
        {
            SetBackgroundColorFromAmbient();
            FireViewChange();
        }
        return IOleControlImpl<CSelectFile>::OnAmbientPropertyChange(dispid);
    }

    HRESULT FireOnChanged(DISPID dispID) {
        if (dispID == DISPID_ENABLED) {

            ::EnableWindow(GetDlgItem(IDC_EDITFILENAME), m_bEnabled);
            ::EnableWindow(GetDlgItem(IDC_BROWSE),       m_bEnabled);

        }
        return S_OK;
    }


    STDMETHOD(GetControlInfo)(CONTROLINFO* pCI) {
        if (NULL == pCI) {
            return E_POINTER;
        }

        pCI->hAccel = NULL;
        pCI->cAccel = 0;
        pCI->dwFlags = 0;
        return S_OK;
    }



// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
    {
        static const IID* arr[] =
        {
            &IID_ISelectFile,
        };
        for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
        {
            if (InlineIsEqualGUID(*arr[i], riid))
                return S_OK;
        }
        return S_FALSE;
    }

    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL* psizel) {
        HRESULT hr = IOleObjectImpl<CSelectFile>::SetExtent(dwDrawAspect, psizel);

        PositionControls();

        return hr;
    }

    STDMETHOD(SetObjectRects)(LPCRECT prcPos, LPCRECT prcClip) {
        IOleInPlaceObjectWindowlessImpl<CSelectFile>::SetObjectRects(prcPos, prcClip);

        PositionControls(prcPos);

        return S_OK;
    }

    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL) {
        HRESULT hr = CComCompositeControl<CSelectFile>::InPlaceActivate(iVerb, prcPosRect);

        Fire_StateChanged(iVerb);

        return hr;
    }

    STDMETHOD(UIDeactivate)() {
        HRESULT hr = IOleInPlaceObjectWindowlessImpl<CSelectFile>::UIDeactivate();

        //
        // We are being deactivated
        // when we loose focus, nuke default button out of here
        //

        DWORD dwDefBtn = (DWORD)SendMessage(DM_GETDEFID, 0);

        if (HIWORD(dwDefBtn) == DC_HASDEFID) {
            // SendMessage(DM_SETDEFID, IDC_EDITFILENAME); // basically forget the default button
            dwDefBtn = LOWORD(dwDefBtn);
            DWORD dwStyle = ::GetWindowLong(GetDlgItem(dwDefBtn), GWL_STYLE);
            if (dwStyle & BS_DEFPUSHBUTTON) {
                dwStyle &= ~BS_DEFPUSHBUTTON;
                dwStyle |= BS_PUSHBUTTON;
                SendDlgItemMessage(dwDefBtn,  BM_SETSTYLE, dwStyle, TRUE);
            }
        }

        // send killfocus
        SendMessage(WM_KILLFOCUS);


        return hr;
    }


    LRESULT OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        // Manually activate the control
        LRESULT lRes = CComCompositeControl<CSelectFile>::OnMouseActivate(uMsg, wParam, lParam, bHandled);
        m_bMouseActivate = TRUE;

        return 0;
    }

    BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hrRet);


    // IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// ISelectFile
public:
    STDMETHOD(ClearAccel)();
    STDMETHOD(ClearExternAccel)();
    STDMETHOD(get_AccelCmd)(/*[in]*/ LONG lCmd, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_AccelCmd)(/*[in]*/ LONG lCmd, /*[in]*/ BSTR newVal);
    STDMETHOD(get_BrowseBtnCaption)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_BrowseBtnCaption)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ExternAccel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ExternAccel)(/*[in]*/ BSTR newVal);
#if 0
    STDMETHOD(get_Accel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Accel)(/*[in]*/ BSTR newVal);
#endif
    STDMETHOD(get_ErrorCode)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_FileName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_BrowseFlags)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BrowseFlags)(/*[in]*/ long newVal);
    STDMETHOD(get_BrowseInitialDirectory)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_BrowseInitialDirectory)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_BrowseFilter)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_BrowseFilter)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_BrowseTitle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_BrowseTitle)(/*[in]*/ BSTR newVal);
    OLE_COLOR m_clrBackColor;
    LONG m_nBackStyle;
    OLE_COLOR m_clrBorderColor;
    BOOL m_bBorderVisible;
    BOOL m_bEnabled;


    // browse dialog props
    CComBSTR m_bstrTitle;
    CComBSTR m_bstrFilter;
    CComBSTR m_bstrInitialDirectory;
    CComBSTR m_bstrFileName;
    DWORD    m_dwBrowseFlags;
    DWORD    m_dwErrorCode;

    wstring  m_BrowseBtnCaption;
    BOOL     m_bMouseActivate;

    enum { IDD = IDD_SELECTFILE };
    LRESULT OnClickedBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

protected:

    CSafeObject m_Safe;

    VOID PositionControls(LPCRECT lprc = NULL) {

        if (NULL == lprc) {
            lprc = &m_rcPos;
        }

        if (IsWindow()) {
            // position the edit ctl first
            HDWP hdwp = BeginDeferWindowPos(2);
            HWND hedit = GetDlgItem(IDC_EDITFILENAME);
            HWND hbtn  = GetDlgItem(IDC_BROWSE);
            LONG lWidthEdit;
            LONG lWidthBtn;
            RECT rcBtn;
            RECT rcEdit;
            LONG lSpace = ::GetSystemMetrics(SM_CXFRAME);

            ::GetWindowRect(hbtn,  &rcBtn); // get the rectangle for the button
            ::GetWindowRect(hedit, &rcEdit);
            lWidthBtn  = rcBtn.right - rcBtn.left; // width of the button - 1
            lWidthEdit = lprc->right - lprc->left - lSpace - lWidthBtn;

            hdwp = ::DeferWindowPos(hdwp, hedit, NULL, 0, 0, lWidthEdit, rcEdit.bottom - rcEdit.top, SWP_NOZORDER);
            hdwp = ::DeferWindowPos(hdwp, hbtn,  NULL, lWidthEdit + lSpace, 0, lWidthBtn, rcBtn.bottom - rcBtn.top, SWP_NOZORDER);
            ::EndDeferWindowPos(hdwp);
        }
    }



    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
        WORD wCmd = 0;

        //
        // determine whether we came here with accel
        //
        CComCompositeControl<CSelectFile>::OnSetFocus(uMsg, wParam, lParam, bHandled);

        if (!m_bMouseActivate) {
            DoVerbUIActivate(&m_rcPos, NULL);

            if (m_Accel.IsAccelKey(NULL, &wCmd)) {
                //
                // we are to be accelerated
                // we look into the accel cmd to see what is there
                //
                switch(wCmd) {
                case IDC_BROWSE:
                    ::SetFocus(GetDlgItem(IDC_BROWSE));
                    OnClickedBrowse(BN_CLICKED, IDC_BROWSE, GetDlgItem(IDC_BROWSE), bHandled);
                    break;

                case IDC_EDITFILENAME:
                    ::SetFocus(GetDlgItem(IDC_EDITFILENAME));
                    break;
                }
            }

            //
            // did we arrive here with the tab?
            //
            if (!IsChild(GetFocus())) {
                if (GetKeyState(VK_TAB) & 0x8000) { // was that the tab key ?
                    HWND hwndFirst = GetNextDlgTabItem(NULL, FALSE); // first
                    HWND hwndLast  = GetNextDlgTabItem(hwndFirst, TRUE);

                    if ((GetKeyState(VK_SHIFT)   & 0x8000)) {
                        // aha, came here with a shift-tab! -- what is the last control ?
                        ::SetFocus(hwndLast);
                    } else {
                        ::SetFocus(hwndFirst);
                    }
                } else {

                    ::SetFocus(GetDlgItem(IDC_EDITFILENAME));
                }
            }
        }

        //
        // set the default pushbutton
        //
        SendMessage(DM_SETDEFID, IDC_BROWSE);
        SendDlgItemMessage(IDC_BROWSE, BM_SETSTYLE, BS_DEFPUSHBUTTON);

        m_bMouseActivate = FALSE;
        bHandled = TRUE;
        return 0;
    }


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
/* // this code sets the same font as the container is using
   // we do not care for now, we're using MS Shell Dlg instead

        CComVariant varFont;
        HFONT       hFont;
        HWND        hwnd;

        HRESULT hr = GetAmbientProperty(DISPID_AMBIENT_FONT, varFont);

        if (SUCCEEDED(hr)) {

            CComQIPtr<IFont, &IID_IFont> pFont (varFont.pdispVal);
            if (SUCCEEDED(pFont->get_hFont(&hFont))) {
                for (hwnd = GetTopWindow(); hwnd != NULL;
                hwnd = ::GetNextWindow(hwnd, GW_HWNDNEXT)) {
                         ::SendMessage(hwnd, WM_SETFONT, (WPARAM)hFont, TRUE);
                }

            }

        }
*/

        SHAutoComplete(GetDlgItem(IDC_EDITFILENAME), SHACF_FILESYSTEM);
        if (m_BrowseBtnCaption.length()) {
            SetDlgItemText(IDC_BROWSE, m_BrowseBtnCaption.c_str());
        }

        //
        // show ui hints
        //

        SendMessage(WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS));

        return 0;
    }

    //
    // Accelerators
    //
    CAccelContainer m_Accel;
    CAccelContainer m_ExternAccel;

    BOOL GetFileNameFromUI(wstring& sFileName) {
        BSTR bstrFileName = NULL;
        BOOL bReturn = FALSE;
        bReturn = GetDlgItemText(IDC_EDITFILENAME, bstrFileName);
        if (bReturn) {
            sFileName = ShimUnquotePath(bstrFileName);
            //
            // now also expand environment variables
            //
            if (!sFileName.empty()) {
                CComBSTR bstrExpanded;
                ShimExpandEnvironmentVars(sFileName.c_str(), bstrExpanded);
                sFileName = bstrExpanded;
            }

        } else {
            sFileName.erase();
        }
        if (bstrFileName) {
            ::SysFreeString(bstrFileName);
        }
        return bReturn;
    }


};

#endif //__SELECTFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\selectfile.cpp ===
// SelectFile.cpp : Implementation of CSelectFile

#include "stdafx.h"
#include "CompatUI.h"
#include "SelectFile.h"

#include "commdlg.h"
#include "cderr.h"
/////////////////////////////////////////////////////////////////////////////
// CSelectFile

//
// in upload.c
//

wstring StrUpCase(wstring& wstr);



STDMETHODIMP CSelectFile::get_BrowseTitle(BSTR *pVal)
{
    *pVal = m_bstrTitle.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseTitle(BSTR newVal)
{
    m_bstrTitle = newVal;
    return S_OK;
}

STDMETHODIMP CSelectFile::get_BrowseFilter(BSTR *pVal)
{
    *pVal = m_bstrFilter.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseFilter(BSTR newVal)
{
    m_bstrFilter = newVal;
    return S_OK;
}

STDMETHODIMP CSelectFile::get_BrowseInitialDirectory(BSTR *pVal)
{
    *pVal = m_bstrInitialDirectory;
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseInitialDirectory(BSTR newVal)
{
    m_bstrInitialDirectory = newVal;
    return S_OK;
}

STDMETHODIMP CSelectFile::get_BrowseFlags(long *pVal)
{
    *pVal = (LONG)m_dwBrowseFlags;
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseFlags(long newVal)
{
    m_dwBrowseFlags = (DWORD)newVal;
    return S_OK;
}

STDMETHODIMP CSelectFile::get_FileName(BSTR *pVal)
{
    wstring sFileName;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    GetFileNameFromUI(sFileName);
    m_bstrFileName = sFileName.c_str();

    *pVal = m_bstrFileName.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_FileName(BSTR newVal)
{
    m_bstrFileName = newVal;
    SetDlgItemText(IDC_EDITFILENAME, m_bstrFileName);

    return S_OK;
}

STDMETHODIMP CSelectFile::get_ErrorCode(long *pVal)
{
    *pVal = (LONG)m_dwErrorCode;
    return S_OK;
}


#define MAX_BUFFER 2048

LRESULT CSelectFile::OnClickedBrowse(
    WORD wNotifyCode,
    WORD wID,
    HWND hWndCtl,
    BOOL& bHandled)
{
    LRESULT lRes = 0;

    // TODO: Add your implementation code here
    OPENFILENAME ofn;
    LPTSTR pszFileName = NULL;
    DWORD  dwFileNameLength = 0;
    DWORD  dwLen;
    LPTSTR pszFilter = NULL, pch;

    m_dwErrorCode = 0;

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;

    //
    // part one (straight) - title
    //
    ofn.lpstrTitle = (LPCTSTR)m_bstrTitle; // assumes we're unicode (and we are)

    //
    // recover the filename from the edit box
    //
    wstring sFileName;

    if (GetFileNameFromUI(sFileName)) {
        m_bstrFileName = sFileName.c_str();
    }

    //
    // part two - init filename
    //
    dwFileNameLength = __max(MAX_BUFFER, m_bstrFileName.Length() * 2); // in characters

    pszFileName = new TCHAR[dwFileNameLength * sizeof(*pszFileName)];
    if (pszFileName == NULL) {
        m_dwErrorCode = ERROR_OUTOFMEMORY;
        goto HandleError;
    }

    // so we have the buffer now
    //
    if (m_bstrFileName.Length () > 0) {
        // sanitize the filename with regard to quotes
        _tcscpy(pszFileName, (LPCTSTR)m_bstrFileName); // hypocritical copy, we are unicode
    } else {
        // start with the contents of the text box then
        *pszFileName = TEXT('\0');
    }

    //
    // sanity check, if pszFileName ends with \ then we will get an error
    //
    PathRemoveBackslash(pszFileName);

    ofn.lpstrFile  = pszFileName;
    ofn.nMaxFile   = dwFileNameLength;

    //
    // see if we also need to process filter
    //

    if (m_bstrFilter.Length() > 0) {
        dwLen = m_bstrFilter.Length();

        pszFilter = new TCHAR[(dwLen + 2) * sizeof(*pszFilter)];
        if (pszFilter == NULL) {
            m_dwErrorCode = ERROR_OUTOFMEMORY;
            goto HandleError;
        }

        RtlZeroMemory(pszFilter, (dwLen + 2) * sizeof(*pszFilter));
        _tcscpy(pszFilter, m_bstrFilter);

        pch = pszFilter;
        while (pch) {
            pch = _tcschr(pch, TEXT('|'));
            if (pch) {
                *pch++ = TEXT('\0');
            }
        }

        // now that the replacement is done -- assign the filter string
        ofn.lpstrFilter = pszFilter;
    }

    //
    // now check whether we have some in the initial directory
    //
    if (m_bstrInitialDirectory.Length() > 0) {
        ofn.lpstrInitialDir = (LPCTSTR)m_bstrInitialDirectory;
    }

    //
    // flags
    //

    if (m_dwBrowseFlags) {
        ofn.Flags = m_dwBrowseFlags;
    } else {
        ofn.Flags = OFN_FILEMUSTEXIST|OFN_EXPLORER;
    }

    BOOL bRetry;
    BOOL bSuccess;

    do {
        bRetry = FALSE;

        bSuccess = GetOpenFileName(&ofn);
        if (!bSuccess) {
            m_dwErrorCode = CommDlgExtendedError();
            if (m_dwErrorCode == FNERR_INVALIDFILENAME) {
                *pszFileName = TEXT('\0');
                bRetry = TRUE;
            }
        }
    } while (bRetry);

    if (!bSuccess) {
        goto HandleError;
    }

    SetDlgItemText(IDC_EDITFILENAME, pszFileName);

    m_bstrFileName = (LPCTSTR)pszFileName;
    m_dwErrorCode = 0;

HandleError:

    if (pszFileName != NULL) {
        delete[] pszFileName;
    }

    if (pszFilter != NULL) {
        delete[] pszFilter;
    }


    bHandled = TRUE;
    return lRes;
}


BOOL
CSelectFile::PreTranslateAccelerator(
    LPMSG pMsg,
    HRESULT& hRet
    )
{
    HWND hWndCtl;
    HWND hwndEdit   = GetDlgItem(IDC_EDITFILENAME);
    HWND hwndBrowse = GetDlgItem(IDC_BROWSE);
    BSTR bstrFileName = NULL;
    WORD wCmd = 0;
    BOOL bBrowseHandled;

    hRet = S_OK;
    hWndCtl = ::GetFocus();
    if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)    {
        do {
            hWndCtl = ::GetParent(hWndCtl);
        } while (::GetParent(hWndCtl) != m_hWnd);
    }

    if (pMsg->message == WM_KEYDOWN &&
            (LOWORD(pMsg->wParam) == VK_RETURN ||
            LOWORD(pMsg->wParam) == VK_EXECUTE)) {
        if (hWndCtl == hwndEdit) {
            BOOL bReturn;
            wstring sFileName;

            bReturn = GetFileNameFromUI(sFileName) &&
                      ValidateExecutableFile(sFileName.c_str(), TRUE);
            if (bReturn) {
                Fire_SelectionComplete();
                return TRUE;
            }
        }
        // this either was hwndBrowse or filename was not there -- open
        // browse dialog then

        OnClickedBrowse(BN_CLICKED, IDC_BROWSE, hwndBrowse, bBrowseHandled);
        ::SetFocus(hwndEdit);
    }

    //
    // fixup external accelerators for internal controls (in this case -- edit)
    //
    if (m_Accel.IsAccelKey(pMsg, &wCmd) && wCmd == IDC_EDITFILENAME) {
        ::SetFocus(hwndEdit);
        return TRUE;
    }


    //
    // check for external accelerators because the next call is going to eat the message
    //
    if (m_ExternAccel.IsAccelKey(pMsg)) { // we do not touch external accel messages
        return FALSE;
    }

    //
    // check whether we are tabbing out of control
    //
    if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB) {
        // check whether we're tabbing out
        // (perhaps the control wants to eat tab?
        DWORD_PTR dwDlgCode = ::SendMessage(pMsg->hwnd, WM_GETDLGCODE, 0, 0);
        if (!(dwDlgCode & DLGC_WANTTAB)) {
            // control does not want a tab
            // see whether it's the last control and we're tabbing out
            HWND hwndFirst = GetNextDlgTabItem(NULL, FALSE); // first
            HWND hwndLast  = GetNextDlgTabItem(hwndFirst, TRUE);
            BOOL bFirstOrLast;
            if (::GetKeyState(VK_SHIFT) & 0x8000) {
                // shift ?
                bFirstOrLast = (hWndCtl == hwndFirst);
            } else {
                bFirstOrLast = (hWndCtl == hwndLast);
            }

            if (bFirstOrLast) {
                IsDialogMessage(pMsg);
                return FALSE;
            }
        }
    }



    return CComCompositeControl<CSelectFile>::PreTranslateAccelerator(pMsg, hRet);
}
/*

STDMETHODIMP CSelectFile::get_Accel(BSTR *pVal)
{
    CComBSTR bstr = (LPCWSTR)m_Accel;
    *pVal = bstr.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_Accel(BSTR newVal)
{
    m_Accel = (LPCWSTR)newVal;
    return S_OK;
}
*/
STDMETHODIMP CSelectFile::get_ExternAccel(BSTR *pVal)
{
    CComBSTR bstr = m_ExternAccel.GetAccelString(0).c_str();
    *pVal = bstr.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_ExternAccel(BSTR newVal)
{
    m_ExternAccel = (LPCWSTR)newVal;
    return S_OK;
}

static TCHAR szU[]  = TEXT("<U>");
static TCHAR szUC[] = TEXT("</U>");

#define szU_Len  (CHARCOUNT(szU) - 1)
#define szUC_Len (CHARCOUNT(szUC) - 1)

STDMETHODIMP CSelectFile::get_BrowseBtnCaption(BSTR *pVal)
{
    // TODO: Add your implementation code here
    CComBSTR bstrCaption;
    wstring  strCaption = m_BrowseBtnCaption;
    wstring::size_type nPos;

    nPos = m_BrowseBtnCaption.find(TEXT('&'));
    if (nPos == wstring::npos || nPos > m_BrowseBtnCaption.length() - 1) {
        bstrCaption = m_BrowseBtnCaption.c_str();
    } else {
        bstrCaption = m_BrowseBtnCaption.substr(0, nPos).c_str();
        bstrCaption += szU;
        bstrCaption += m_BrowseBtnCaption[nPos+1];
        bstrCaption += szUC;
        if (nPos < m_BrowseBtnCaption.length() - 1) {
            bstrCaption += m_BrowseBtnCaption.substr(nPos+2).c_str();
        }
    }
    *pVal = bstrCaption.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_BrowseBtnCaption(BSTR newVal)
{

    //
    // form a caption from the string
    //
    wstring strCaption  = newVal;
    wstring strCaptionU = strCaption;
    wstring::size_type nPosU, nPosUC;
    wstring strAccel;

    StrUpCase(strCaptionU);

    //
    // find <u> </u> pair
    //
    nPosU = strCaptionU.find(szU);
    nPosUC = strCaptionU.find(szUC, nPosU);
    if (nPosUC == wstring::npos || nPosU == wstring::npos || nPosUC < nPosU || nPosUC <= (nPosU + szU_Len)) {
        goto cleanup;
    }

    // extract the char at the &
    //
    //
    strAccel = strCaption.substr(nPosU + szU_Len, nPosUC - (nPosU + szU_Len));

    //
    // add accel please -- with command id IDC_BROWSE
    //
    m_Accel.SetAccel(strAccel.c_str(), IDC_BROWSE);

    //
    // now we (presumably) found <u>accelchar</u>
    //
    m_BrowseBtnCaption = strCaption.substr(0, nPosU); // up to the <U>
    m_BrowseBtnCaption += TEXT('&');
    m_BrowseBtnCaption += strAccel.c_str();
    m_BrowseBtnCaption += strCaption.substr(nPosUC + szUC_Len); // all the rest please

    if (IsWindow()) {
        SetDlgItemText(IDC_BROWSE, m_BrowseBtnCaption.c_str());
    }

cleanup:

    return S_OK;
}

STDMETHODIMP CSelectFile::get_AccelCmd(LONG lCmd, BSTR *pVal)
{
    CComBSTR bstrVal = m_Accel.GetAccelString((WORD)lCmd).c_str();
    *pVal = bstrVal.Copy();
    return S_OK;
}

STDMETHODIMP CSelectFile::put_AccelCmd(LONG lCmd, BSTR newVal)
{
    m_Accel.SetAccel(newVal, (WORD)lCmd);
    return S_OK;
}

STDMETHODIMP CSelectFile::ClearAccel()
{
    m_Accel.ClearAccel();
    return S_OK;
}

STDMETHODIMP CSelectFile::ClearExternAccel()
{
    m_ExternAccel.ClearAccel();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6A70480E_DE84_4628_B473_C28872E61333__INCLUDED_)
#define AFX_STDAFX_H__6A70480E_DE84_4628_B473_C28872E61333__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <safe.h>

#endif // !defined(AFX_STDAFX_H__6A70480E_DE84_4628_B473_C28872E61333__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CompatUI.rc
//
#define IDS_PROJNAME                    100
#define IDB_PROGVIEW                    101
#define IDS_DESKTOP                     101
#define IDR_PROGVIEW                    102
#define IDS_COMMON_STARTMENU            102
#define IDD_PROGVIEW                    103
#define IDS_STARTMENU                   103
#define IDR_UTIL                        104
#define IDS_COMMON_PROGRAMS             104
#define IDB_SELECTFILE                  105
#define IDS_PROGRAMS                    105
#define IDR_SELECTFILE                  106
#define IDS_PROGRAMNAME                 106
#define IDD_SELECTFILE                  107
#define IDS_FOLDER                      107
#define IDS_SETTINGS                    108
#define IDR_UPLOAD                      109
#define IDS_SENDINGINFO                 109
#define IDD_UPLOADFILES                 110
#define IDS_CLEANINGUP                  110
#define IDS_SENDINGCAPTION              111
#define IDS_WAITCLEANUP                 112
#define IDS_LAUNCHINGDR                 113
#define IDS_COLLECTINGDATACAPTION       114
#define IDS_COMPATWIZARD                115
#define IDS_GRABMISTATUS_COLLECTING     116
#define IDS_WIZARD_INFOTIP              117
#define IDC_LISTPROGRAMS                201
#define IDB_SORTDN                      203
#define IDB_SORTUP                      204
#define IDC_EDITFILENAME                207
#define IDA_WATSONANIM                  207
#define IDC_BROWSE                      208
#define IDA_FINDANIM                    209
#define IDI_COMPATWIZARD                210
//
// to items below should be identical with one difference - one
// should have quotes (the string we use in .cpp file) and the
// other should not (resource compiler adds quotes)
//
#define IDR_SHOWTEMPFILESDLGRC          TempFileListTemplate.html
#define IDR_SHOWTEMPFILESDLG            TEXT("TempFileListTemplate.html")

#define IDC_UPLOADFILES                 212
#define IDC_STATUSLINE1                 213
#define IDC_STATUSLINE2                 214
#define IDC_ANIMATEFIND                 215
#define IDS_CHECKING_FILES              216

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        212
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         217
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\safe.h ===
#ifndef __SAFE_H_
#define __SAFE_H_

BOOL
CheckHost(
    IUnknown* pObject
    );

//
// safe class
//
class CSafeObject {
public:
    CSafeObject(IObjectWithSite* pObject) :
        m_bInitialized(FALSE),
        m_bSafe(FALSE) {
            m_pObjectWithSite = pObject;
            m_pOleObject      = NULL;
        }

    CSafeObject(IOleObject* pObject) :
        m_bInitialized(FALSE),
        m_bSafe(FALSE) {
            m_pOleObject      = pObject;
            m_pObjectWithSite = NULL;
        }


    BOOL operator !() {
        if (!m_bInitialized) {
            IUnknown* pObject = GetSiteObject();
            if (pObject) {
                m_bSafe = CheckHost(pObject);
                m_bInitialized = TRUE;
                pObject->Release();
            }
        }
        return m_bSafe == FALSE;
    }

    BOOL operator ==(BOOL bSafe) {
        if (!m_bInitialized) {
            IUnknown* pObject = GetSiteObject();
            if (pObject) {
                m_bSafe = CheckHost(pObject);
                m_bInitialized = TRUE;
                pObject->Release();
            }
        }
        return m_bSafe == bSafe;
    }

    IUnknown* GetSiteObject(VOID) {
        IUnknown* pObject = NULL;
        HRESULT   hr;

        if (m_pOleObject) {

            CComPtr<IOleClientSite> spClientSite;

            hr = m_pOleObject->GetClientSite(&spClientSite);
            if (SUCCEEDED(hr)) {
                pObject = spClientSite;
                pObject->AddRef();
            }


        } else if (m_pObjectWithSite) {

            IUnknown* pUnk = NULL;

            hr = m_pObjectWithSite->GetSite(IID_IUnknown,
                                            reinterpret_cast<void**>(&pUnk));
            if (SUCCEEDED(hr) && pUnk != NULL) {
                pObject = pUnk;
            }
        }

        return pObject;

    }

private:
    IObjectWithSite*   m_pObjectWithSite;
    IOleObject*        m_pOleObject;
    BOOL               m_bInitialized;
    BOOL               m_bSafe;

};


#endif // __SAFE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\uploadfiles.cpp ===
// CUploadFiles.cpp : Implementation of CCUploadFiles
#include "stdafx.h"
#include "CompatUI.h"
#include "shlobj.h"
extern "C" {
    #include "shimdb.h"
}

#include "Upload.h"
#include "Uploadfiles.h"

/////////////////////////////////////////////////////////////////////////////
// CCUploadFiles
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\upload.h ===
// Upload.h : Declaration of the CUpload

#ifndef __UPLOAD_H_
#define __UPLOAD_H_

#include "resource.h"       // main symbols

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <locale>
#include <algorithm>
#include <vector>
using namespace std;


/////////////////////////////////////////////////////////////////////////////
// CUpload
class ATL_NO_VTABLE CUpload :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUpload, &CLSID_Upload>,
    public IDispatchImpl<IUpload, &IID_IUpload, &LIBID_COMPATUILib>,
    public IObjectWithSiteImpl<CUpload>
{
public:
    CUpload() : m_Safe(this)
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_UPLOAD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUpload)
    COM_INTERFACE_ENTRY(IUpload)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IUpload
public:
    STDMETHOD(ShowTempFiles)();
    STDMETHOD(DeleteTempFiles)();
    STDMETHOD(AddDescriptionFile)(
            /*[in]*/BSTR pszApplicationName,
            /*[in]*/BSTR pszApplicationPath,
            /*[in]*/LONG lMediaType,
            /*[in]*/BOOL bCompatSuccess,
            /*[in]*/VARIANT* pvFixesApplied,
            /*[in]*/VARIANT pszKey,
            /*[out, retval]*/BOOL* pbSuccess);
    STDMETHOD(SendReport)(/*[out, retval]*/BOOL* pbSuccess);
    STDMETHOD(CreateManifestFile)(/*[out, retval]*/BOOL *pbSuccess);
    STDMETHOD(RemoveDataFile)(/*[in]*/BSTR pszDataFile);
    STDMETHOD(AddDataFile)(
            /*[in]*/BSTR pszDataFile,
            /*[in]*/VARIANT vKey,
            /*[in]*/VARIANT vDescription,
            /*[in]*/VARIANT vOwn);
    STDMETHOD(AddMatchingInfo)(
            /*[in]*/BSTR pszCommand,
            /*[in]*/VARIANT vFilter,
            /*[in]*/VARIANT vKey,
            /*[in]*/VARIANT vDescription,
            /*[in]*/VARIANT vProgress,
            /*[out, retval]*/BOOL* pbSuccess);
    STDMETHOD(GetKey)(/*[in]*/BSTR pszKey, /*[out, retval]*/VARIANT* pszValue);
    STDMETHOD(SetKey)(/*[in]*/BSTR pszKey, /*[in]*/VARIANT* pvValue);
    STDMETHOD(GetDataFile)(/*[in]*/VARIANT vKey, /*[in]*/LONG InformationClass, /*[out, retval]*/VARIANT* pVal);


protected:

    //
    // safeguard against bad host
    //
    CSafeObject m_Safe;

    //
    // map for the items, unique
    //

    VOID ListTempFiles(wstring& str);

    typedef map<wstring, wstring, less<wstring> > MAPSTR2STR;
    MAPSTR2STR m_mapManifest;


    //
    // data files collection in an embedded object
    //
    typedef struct tagMatchingFileInfo {
        wstring strDescription; // description of a matching file
        wstring strFileName;    // filename
        BOOL    bOwn;           // do we own the file?
    } MFI, *PMFI;


    typedef map<wstring, MFI > MAPSTR2MFI;
    MAPSTR2MFI m_DataFiles;



/*
    typedef vector<wstring> STRVEC;

    STRVEC m_DataFiles;
*/

    CComBSTR m_bstrManifest;

    BOOL GetDataFilesKey(CComBSTR& bstrVal);

    IProgressDialog* m_ppd;
    static BOOL CALLBACK _GrabmiCallback(
        LPVOID    lpvCallbackParam, // application-defined parameter
        LPCTSTR   lpszRoot,         // root directory path
        LPCTSTR   lpszRelative,     // relative path
        PATTRINFO pAttrInfo,        // attributes
        LPCWSTR   pwszXML           // resulting xml
        );

    BOOL IsHeadlessMode(void);

    typedef struct tagMIThreadParamBlock {
        CUpload* pThis;
        wstring  strCommand;
        HWND     hwndParent;
        DWORD    dwFilter;
        BOOL     bNoProgress;
        wstring  strKey;
        wstring  strDescription;
    } MITHREADPARAMBLK;

    typedef enum tagDATAFILESINFOCLASS {
        InfoClassCount = 0,
        InfoClassKey = 1,
        InfoClassFileName = 2,
        InfoClassDescription = 3
    } DATAFILESINFOCLASS;

    typedef pair<CUpload*, IProgressDialog*> GMEPARAMS;

    static DWORD WINAPI _AddMatchingInfoThreadProc(LPVOID lpvThis);
    BOOL AddMatchingInfoInternal(HWND hwndParent,
                                 LPCWSTR pszCommand,
                                 DWORD   dwFilter,
                                 BOOL    bNoProgress,
                                 LPCWSTR pszKey,
                                 LPCWSTR pszDescription);


};



#endif //__UPLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\upload.cpp ===
// Upload.cpp : Implementation of CUpload
#include "stdafx.h"
#include "resource.h"
#include "CompatUI.h"
#include "shlobj.h"
extern "C" {
    #include "shimdb.h"
}

#include "Upload.h"

TCHAR szKeyDataFiles[] = TEXT("DataFiles");


//
// lives in util.cpp
//
BOOL
GetExePathFromObject(
    LPCTSTR lpszPath,  // path to an arbitrary object
    CComBSTR& bstrExePath
    );


//
// lives in proglist.cpp
//

wstring
    LoadResourceString(UINT nID);

//
// lives in ntutil.c
//
extern "C"
BOOL
WINAPI
CheckFileLocation(
    LPCWSTR pwszDosPath,
    BOOL* pbRoot,
    BOOL* pbLeaf
    );


//
// conversion
//
BOOL VariantToBOOL(CComVariant& v)
{
    if (SUCCEEDED(v.ChangeType(VT_BOOL))) {
        return v.boolVal;
    }

    return FALSE;
}

wstring VariantToStr(CComVariant& v)
{
    wstring str;

    if (v.vt != VT_EMPTY && v.vt != VT_NULL) {
        if (SUCCEEDED(v.ChangeType(VT_BSTR))) {
            str = v.bstrVal;
        }
    }

    return str;
}

HRESULT StringToVariant(VARIANT* pv, const wstring& str)
{
    HRESULT hr = E_FAIL;

    pv->vt = VT_NULL;
    pv->bstrVal = ::SysAllocString(str.c_str());
    if (pv->bstrVal == NULL) {
        hr = E_OUTOFMEMORY;
    } else {
        pv->vt = VT_BSTR;
        hr = S_OK;
    }

    return hr;
}


BOOL
GetTempFile(
    LPCTSTR lpszPrefix,
    CComBSTR& bstrFile
    )
{
    DWORD dwLength;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szTempFile[MAX_PATH];

    dwLength = GetTempPath(CHARCOUNT(szBuffer), szBuffer);
    if (!dwLength || dwLength > CHARCOUNT(szBuffer)) {
        return FALSE;
    }

    //
    // we got directory, generate the file now
    //

    dwLength = GetTempFileName(szBuffer, lpszPrefix, 0, szTempFile);
    if (!dwLength) {
        return FALSE;
    }

    bstrFile = szTempFile;
    return TRUE;

}

wstring StrUpCase(wstring& wstr)
{
    ctype<wchar_t> _ct;
    wstring::iterator iter;

    for (iter = wstr.begin(); iter != wstr.end(); ++iter) {
        (*iter) = _ct.toupper(*iter);
    }

    return wstr;
}

/////////////////////////////////////////////////////////////////////////////
// CUpload


BOOL CUpload::GetDataFilesKey(CComBSTR& bstrVal)
{
    // STRVEC::iterator iter;
    MAPSTR2MFI::iterator iter;

    bstrVal.Empty();

    for (iter = m_DataFiles.begin(); iter != m_DataFiles.end(); ++iter) {
        if (bstrVal.Length()) {
            bstrVal.Append(TEXT("|"));
        }
        bstrVal.Append((*iter).second.strFileName.c_str());
    }
    return bstrVal.Length() != 0;

}

STDMETHODIMP CUpload::SetKey(BSTR pszKey, VARIANT* pvValue)
{
    wstring strKey = pszKey;
    VARIANT vStr;
    HRESULT hr;
    HRESULT hrRet = S_OK;

    //
    // dwwin is case-sensitive
    //
    // StrUpCase(strKey);

    if (strKey == szKeyDataFiles) { // data files cannot be set directly
        return E_INVALIDARG;
    }

    VariantInit(&vStr);

    hr = VariantChangeType(&vStr, pvValue, 0, VT_BSTR);
    if (SUCCEEDED(hr)) {
        wstring strVal = vStr.bstrVal;

        m_mapManifest[strKey] = strVal;
    } else if (pvValue->vt == VT_NULL || pvValue->vt == VT_EMPTY) {
        m_mapManifest.erase(strKey);
    } else {
        hrRet = E_INVALIDARG;
    }
    VariantClear(&vStr);

    return hrRet;
}

STDMETHODIMP CUpload::GetKey(BSTR pszKey, VARIANT *pValue)
{
    CComBSTR bstrVal;
    wstring  strKey = pszKey;

    // StrUpCase(strKey);

    if (strKey == szKeyDataFiles) {
        //
        // data files -- handled separately
        //
        if (GetDataFilesKey(bstrVal)) {
            pValue->vt = VT_BSTR;
            pValue->bstrVal = bstrVal.Copy();
        } else {
            pValue->vt = VT_NULL;
        }

    } else {

        MAPSTR2STR::iterator iter = m_mapManifest.find(strKey);
        if (iter != m_mapManifest.end()) {
            bstrVal = (*iter).second.c_str();
            pValue->vt = VT_BSTR;
            pValue->bstrVal = bstrVal.Copy();
        } else {
            pValue->vt = VT_NULL;
        }
    }
    return S_OK;
}

#define DWWIN_HEADLESS_MODE 0x00000080

BOOL CUpload::IsHeadlessMode(void)
{
    CComVariant varFlags;
    HRESULT     hr;
    BOOL        bHeadless = FALSE;

    GetKey(TEXT("Flags"), &varFlags);

    hr = varFlags.ChangeType(VT_I4);
    if (SUCCEEDED(hr)) {
        bHeadless = !!(varFlags.lVal & DWWIN_HEADLESS_MODE);
    }

    return bHeadless;
}


/*
DWORD CUpload::CountFiles(DWORD nLevel, LPCWSTR pszPath)
{
    WIN32_FIND_DATA wfd;
    wstring strPath = pszPath;
    wstring::size_type nPos;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    DWORD dwCount = 0;

    nPos = strPath.length();
    if (strPath[nPos-1] != TEXT('\\')) {
        strPath += TEXT('\\');
        ++nPos;
    }

    FindFirstFileExW(

    strPath += TEXT('*');

    hFind = FindFirstFile(strPath.c_str(), &wfd);
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (nLevel < 3 && wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (wcscmp(wfd.cFileName, TEXT(".")) && wcscmp(wfd.cFileName, TEXT(".."))) {
                    strPath.replace(nPos, wstring::nPos, wfd.cFileName);
                    dwCount += CountFiles(nLevel + 1, strPath.c_str());
                }
            } else { // file
                ++dwCount;
            }
        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    return dwCount;
}
*/

BOOL CALLBACK CUpload::_GrabmiCallback(
    LPVOID    lpvCallbackParam, // application-defined parameter
    LPCTSTR   lpszRoot,         // root directory path
    LPCTSTR   lpszRelative,     // relative path
    PATTRINFO pAttrInfo,        // attributes
    LPCWSTR   pwszXML           // resulting xml
    )
{
    GMEPARAMS* pParams = (GMEPARAMS*)lpvCallbackParam;

    CUpload* pT = pParams->first;
    IProgressDialog* ppd = pParams->second;

    if (ppd == NULL) {
        return TRUE;
    }

    ppd->SetLine(2, lpszRoot,     TRUE, NULL);

    // ppd->SetLine(2, lpszRelative, TRUE, NULL);

    return !ppd->HasUserCancelled();
}


STDMETHODIMP CUpload::AddMatchingInfo(
    BSTR pszCommand,
    VARIANT vFilter,
    VARIANT vKey,
    VARIANT vDescription,
    VARIANT vProgress,
    BOOL *pbSuccess)
{

/*  HANDLE hThread = NULL;
    DWORD  dwExitCode = 0;
    DWORD  dwWait;
*/

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    CComVariant varFilter(vFilter);
    DWORD  dwFilter = GRABMI_FILTER_NORMAL;
    wstring strKey;
    wstring strDescription;

    if (SUCCEEDED(varFilter.ChangeType(VT_I4))) {
        dwFilter   = (DWORD)varFilter.lVal;
    }

    strKey         = VariantToStr(CComVariant(vKey));
    strDescription = VariantToStr(CComVariant(vDescription));


    *pbSuccess = AddMatchingInfoInternal(::GetActiveWindow(),
                                         pszCommand,
                                         dwFilter,
                                         VariantToBOOL(CComVariant(vProgress)),
                                         strKey.empty()         ? NULL : strKey.c_str(),
                                         strDescription.empty() ? NULL : strDescription.c_str());

/*

    MITHREADPARAMBLK* pParam = new MITHREADPARAMBLK;
    CComVariant varFilter(vFilter);

    if (!pParam) {
        goto cleanup;
    }

    pParam->pThis          = this;
    pParam->strCommand     = pszCommand;
    pParam->hwndParent     = ::GetActiveWindow();
    pParam->dwFilter       = GRABMI_FILTER_NORMAL;

    if (SUCCEEDED(varFilter.ChangeType(VT_I4))) {
        pParam->dwFilter   = (DWORD)varFilter.lVal;
    }

    pParam->bNoProgress    = VariantToBOOL(CComVariant(vProgress));
    pParam->strKey         = VariantToStr(CComVariant(vKey));
    pParam->strDescription = VariantToStr(CComVariant(vDescription));

    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)_AddMatchingInfoThreadProc,
                           (LPVOID)pParam,
                           0,
                           NULL);
    if (!hThread) {
        goto cleanup;
    }

    dwWait = WaitForSingleObject(hThread, INFINITE);
    if (dwWait != WAIT_OBJECT_0) {
        goto cleanup;
    }

    GetExitCodeThread(hThread, &dwExitCode);

cleanup:
    if (hThread) {
        CloseHandle(hThread);
    }

    *pbSuccess = !!dwExitCode;
*/

    return S_OK;
}


DWORD WINAPI
CUpload::_AddMatchingInfoThreadProc(LPVOID lpvThis)
{
    BOOL bSuccess;
    HRESULT hr;

    MITHREADPARAMBLK* pParam = (MITHREADPARAMBLK*)lpvThis;
    if (!pParam->bNoProgress) {
        hr = CoInitialize(NULL);
        if (!SUCCEEDED(hr)) {
            pParam->bNoProgress = TRUE;
        }
    }

    bSuccess = pParam->pThis->AddMatchingInfoInternal(::GetActiveWindow(),
                                                      pParam->strCommand.c_str(),
                                                      pParam->dwFilter,
                                                      pParam->bNoProgress,
                                                      pParam->strKey.empty()         ? NULL : pParam->strKey.c_str(),
                                                      pParam->strDescription.empty() ? NULL : pParam->strDescription.c_str());
    if (!pParam->bNoProgress) {
        CoUninitialize();
    }
    delete pParam;
    return bSuccess;
}


BOOL CUpload::AddMatchingInfoInternal(
    HWND hwndParent,
    LPCWSTR pszCommand,
    DWORD   dwFilter,
    BOOL    bNoProgress,
    LPCTSTR pszKey,
    LPCTSTR pszDescription)
{
    CComBSTR bstrPath;
    CComBSTR bstrGrabmiFile;
    BOOL bSuccess = FALSE;

    IProgressDialog * ppd = NULL;
    HRESULT hr;
    GMEPARAMS GrabmiParams;
    MFI     MatchingFileInfo;
    wstring strKey;

    UINT   DriveType;
    BOOL   bLeaf = NULL;
    BOOL   bRoot = NULL;
    DWORD   dwFilters[3];
    wstring Paths[3];
    int    nDrive;
    DWORD  nPasses = 1;
    wstring DriveRoot(TEXT("X:\\"));

    //
    // this is kinda dangerous, the way it works. We collect the info while yielding to the
    // creating process (due to the start dialog
    // so the calling window needs to be disabled -- or we need to trap doing something else
    // while we're collecting data
    //


    if (!::GetExePathFromObject(pszCommand, bstrPath)) {
        return FALSE;
    }

    //
    // bstrPath is exe path, create and grab matching info
    //

    if (!GetTempFile(TEXT("ACG"), bstrGrabmiFile)) {
        goto cleanup;
    }

    //
    // we are going to run grabmi!!!
    //

    //
    // prepare callback
    //

    if (!bNoProgress) {
        hr = CoCreateInstance(CLSID_ProgressDialog,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IProgressDialog,
                              (void **)&ppd);
        if (!SUCCEEDED(hr)) {
            ppd = NULL;
        }
    }


    //
    // check to see what happened to hr
    //
    if (ppd) {
        wstring strCaption;

        strCaption = LoadResourceString(IDS_COLLECTINGDATACAPTION);
        ppd->SetTitle(strCaption.c_str());                        // Set the title of the dialog.

        ppd->SetAnimation (_Module.GetModuleInstance(), IDA_FINDANIM); // Set the animation to play.

        strCaption = LoadResourceString(IDS_WAITCLEANUP);
        ppd->SetCancelMsg (strCaption.c_str(), NULL);   // Will only be displayed if Cancel

        strCaption = LoadResourceString(IDS_GRABMISTATUS_COLLECTING);
        ppd->SetLine(1, strCaption.c_str(), FALSE, NULL);

        ppd->StartProgressDialog(hwndParent,
                                 NULL,
                                 PROGDLG_NOPROGRESSBAR|
                                    PROGDLG_MODAL|
                                    PROGDLG_NOMINIMIZE|
                                    PROGDLG_NORMAL|
                                    PROGDLG_NOTIME,
                                 NULL); // Display and enable automatic estimated time remain
    }

    //
    // this is where we have to determine whether grabmi is a going to be running wild
    // Check the drive first to see whether it's removable media
    // cases : leaf node / root node
    //       : system directory
    //       : cd-rom
    //       : temp directory
    // there could be many combinations
    //

    if (ppd) {
        wstring strCaption = LoadResourceString(IDS_CHECKING_FILES);
        ppd->SetLine(2, strCaption.c_str(), FALSE, NULL);
    }

    //
    // this is the default filter we shall use
    //
    dwFilters[0] = GRABMI_FILTER_PRIVACY;
    Paths    [0] = bstrPath;
    nPasses      = 1;

    //
    // determine if it's root/leaf node (could be both)
    //
    if (!CheckFileLocation(bstrPath, &bRoot, &bLeaf)) {
        // we cannot check the file's location
        goto GrabInformation;
    }

    DriveType = GetDriveTypeW(bstrPath); // this will give us *some* clue

    // rules:
    // cdrom and not root -- three passes
    // root - add current file
    //

    if (bRoot || DRIVE_REMOTE == DriveType) {

        dwFilters[0] |= GRABMI_FILTER_LIMITFILES;

    } else if (DRIVE_CDROM == DriveType) {

        nDrive = PathGetDriveNumber(bstrPath);
        if (nDrive >= 0) {
            dwFilters[0] |= GRABMI_FILTER_NOCLOSE|GRABMI_FILTER_APPEND;

            dwFilters[1] = GRABMI_FILTER_NORECURSE|GRABMI_FILTER_APPEND;
            Paths    [1] = DriveRoot;
            Paths    [1].at(0) = (WCHAR)(TEXT('A') + nDrive);
            nPasses = 2;
        }

    }

    if (bLeaf) {
        // we may want to do more here -- future dev
        ;
    }


GrabInformation:


    //
    // set callback context
    //
    GrabmiParams.first  = this;
    GrabmiParams.second = ppd;

    while (nPasses-- > 0) {

        if (SdbGrabMatchingInfoEx(Paths[nPasses].c_str(),
                                  dwFilters[nPasses],
                                  bstrGrabmiFile,
                                  _GrabmiCallback,
                                  (LPVOID)&GrabmiParams) == GMI_FAILED) {
            goto cleanup;
        }
    }


    //
    // figure out the key/description
    //

    if (pszDescription) {
        MatchingFileInfo.strDescription = pszDescription;
    }

    MatchingFileInfo.strFileName    = bstrGrabmiFile;
    MatchingFileInfo.bOwn           = TRUE; // we have generated this file
    //
    // key
    //

    if (pszKey == NULL) {
        strKey = MatchingFileInfo.strFileName;
    } else {
        strKey = pszKey;
    }
    StrUpCase(strKey);

    m_DataFiles[strKey] = MatchingFileInfo;

    // m_DataFiles.push_back(StrUpCase(wstring(bstrGrabmiFile)));

    //
    //
    //
    bSuccess = TRUE;

cleanup:
    if (ppd) {
        ppd->StopProgressDialog();
        ppd->Release();
    }

    return bSuccess;
}

STDMETHODIMP CUpload::AddDataFile(
    BSTR pszDataFile,
    VARIANT vKey,
    VARIANT vDescription,
    VARIANT vOwn)
{
    MFI     MatchingFileInfo;
    wstring strKey = VariantToStr(CComVariant(vKey));
    BOOL    bKeyFromName = FALSE;

    if (strKey.empty()) {
        strKey = pszDataFile;
        bKeyFromName = TRUE;
    }
    StrUpCase(strKey);

    if (m_DataFiles.find(strKey) != m_DataFiles.end() && !bKeyFromName) {
        CComBSTR bstrKey = strKey.c_str();
        RemoveDataFile(bstrKey);
    }

    MatchingFileInfo.strDescription = VariantToStr(CComVariant(vDescription));
    MatchingFileInfo.strFileName    = pszDataFile;
    MatchingFileInfo.bOwn           = VariantToBOOL(CComVariant(vOwn));

    m_DataFiles[strKey] = MatchingFileInfo;

    // m_DataFiles.push_back(StrUpCase(wstring(pszDataFile)));
    return S_OK;
}


STDMETHODIMP CUpload::RemoveDataFile(BSTR pszDataFile)
{
    // STRVEC::iterator iter;
    MAPSTR2MFI::iterator iter;
    wstring strFileName;

    wstring strDataFile = pszDataFile;

    StrUpCase(strDataFile);

    iter = m_DataFiles.find(strDataFile);
    if (iter != m_DataFiles.end()) {
        if ((*iter).second.bOwn) {
            ::DeleteFile((*iter).second.strFileName.c_str());
        }

        m_DataFiles.erase(iter);
    }

/*
    for (iter = m_DataFiles.begin(); iter != m_DataFiles.end(); ++iter) {
        if (*iter == strDataFile) {
            //
            // found it
            //
            m_DataFiles.erase(iter);
            break;
        }
    }
*/
    return S_OK;
}

STDMETHODIMP CUpload::CreateManifestFile(BOOL *pbSuccess)
{
    //
    // manifest file creation code
    //
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR  UNICODE_MARKER[] = { (WCHAR)0xFEFF, L'\r', L'\n' };
    MAPSTR2STR::iterator iter;
    DWORD  dwWritten;
    wstring strLine;
    CComBSTR bstrDataFiles;
    BOOL bResult;
    BOOL bSuccess = FALSE;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    if (!GetTempFile(TEXT("ACM"), m_bstrManifest)) {
        goto cleanup;
    }

    //
    // m_bstrManifest is our file
    //


    hFile = CreateFileW(m_bstrManifest,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    bResult = WriteFile(hFile, UNICODE_MARKER, sizeof(UNICODE_MARKER), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    //
    // done with the marker, now do the manifest strings
    //
    //
    for (iter = m_mapManifest.begin(); iter != m_mapManifest.end(); ++iter) {
        strLine = (*iter).first + TEXT('=') + (*iter).second + TEXT("\r\n");
        bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
        if (!bResult) {
            goto cleanup;
        }
    }

    //
    // done with the general stuff, do the data files
    //

    if (GetDataFilesKey(bstrDataFiles)) {
        strLine = wstring(szKeyDataFiles) + TEXT('=') + wstring(bstrDataFiles) + TEXT("\r\n");
        bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
        if (!bResult) {
            goto cleanup;
        }
    }
    bSuccess = TRUE;

cleanup:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    if (!bSuccess && m_bstrManifest.Length()) {
        DeleteFile(m_bstrManifest);
        m_bstrManifest.Empty();
    }
    *pbSuccess = bSuccess;

    return S_OK;
}

STDMETHODIMP CUpload::SendReport(BOOL *pbSuccess)
{
    UINT uSize;
    TCHAR szSystemWindowsDirectory[MAX_PATH];
    wstring strDWCmd;
    wstring strDWPath;
    STARTUPINFO         StartupInfo = { 0 };
    PROCESS_INFORMATION ProcessInfo = { 0 };
    DWORD dwWait;
    BOOL  bSuccess = FALSE;
    BOOL  bResult;
    DWORD dwExitCode;
    BOOL  bTerminated = FALSE;
    DWORD dwTimeout = 10; // 10ms per ping

    //
    // Create Progress dialog
    //
    IProgressDialog * ppd = NULL;
    HRESULT hr;


    //
    // do not allow upload unless it is hc that is hosting us
    //

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    if (IsHeadlessMode()) {

        hr = CoCreateInstance(CLSID_ProgressDialog,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IProgressDialog,
                              (void **)&ppd);
        if (!SUCCEEDED(hr)) {
            ppd = NULL;
        }
    }

    //
    // check to see what happened to hr
    //
    if (ppd) {
        wstring strCaption;

        strCaption = LoadResourceString(IDS_SENDINGCAPTION);
        ppd->SetTitle(strCaption.c_str());                        // Set the title of the dialog.

        ppd->SetAnimation (_Module.GetModuleInstance(), IDA_WATSONANIM); // Set the animation to play.

        strCaption = LoadResourceString(IDS_WAITCLEANUP);
        ppd->SetCancelMsg (strCaption.c_str(), NULL);   // Will only be displayed if Cancel

        strCaption = LoadResourceString(IDS_LAUNCHINGDR);
        ppd->SetLine (1, strCaption.c_str(), FALSE, NULL);

        ppd->StartProgressDialog(::GetActiveWindow(),
                                 NULL,
                                 PROGDLG_NOPROGRESSBAR|
                                    PROGDLG_MODAL|
                                    PROGDLG_NOMINIMIZE|
                                    PROGDLG_NORMAL|
                                    PROGDLG_NOTIME,
                                 NULL); // Display and enable automatic estimated time remain
    }

    uSize = ::GetSystemWindowsDirectory(szSystemWindowsDirectory,
                                        CHARCOUNT(szSystemWindowsDirectory));
    if (uSize == 0 || uSize > CHARCOUNT(szSystemWindowsDirectory)) {
        goto cleanup;
    }

    strDWPath = szSystemWindowsDirectory;
    if (strDWPath.at(strDWPath.length() - 1) != TCHAR('\\')) {
        strDWPath.append(TEXT("\\"));
    }

    strDWPath += TEXT("system32\\dwwin.exe");
    strDWCmd = strDWPath + TEXT(" -d ") + (LPCWSTR)m_bstrManifest;

    StartupInfo.cb = sizeof(StartupInfo);

    bResult = CreateProcess(strDWPath.c_str(),
                            (LPWSTR)strDWCmd.c_str(),
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInfo);
    if (bResult) {
        //
        // recover an exit code please
        //
        if (ppd) {
            wstring strSending = LoadResourceString(IDS_SENDINGINFO);
            ppd->SetLine(1, strSending.c_str(), FALSE, NULL);
        }
        while(TRUE) {
            dwWait = WaitForSingleObject(ProcessInfo.hProcess, dwTimeout);
            if (dwWait == WAIT_OBJECT_0) {
                if (GetExitCodeProcess(ProcessInfo.hProcess, &dwExitCode)) {
                    bSuccess = (dwExitCode == 0);
                } else {
                    bSuccess = FALSE;
                }
                break;

            } else if (dwWait == WAIT_TIMEOUT) {

                //
                // check the cancel button
                //

                if (ppd && !bTerminated && ppd->HasUserCancelled()) {
                    TerminateProcess(ProcessInfo.hProcess, (UINT)-1);
                    bTerminated = TRUE;
                    bSuccess = FALSE;
                    dwTimeout = 1000; // wait a bit longer
                }

            } else { // object somehow became abandoned
                bSuccess = FALSE;
                break;
            }
        }

    }

    if (ppd) {
        wstring strCleaningUp = LoadResourceString(IDS_CLEANINGUP);
        ppd->SetLine(1, strCleaningUp.c_str(), FALSE, NULL);
    }


cleanup:


    if (ProcessInfo.hThread) {
        CloseHandle(ProcessInfo.hThread);
    }
    if (ProcessInfo.hProcess) {
        CloseHandle(ProcessInfo.hProcess);
    }

    if (ppd) {
        ppd->StopProgressDialog();
        ppd->Release();
    }

    *pbSuccess = bSuccess;

    return S_OK;
}

wstring MakeXMLAttr(LPCTSTR lpszName, LPCTSTR lpszValue)
{
    wstring str;
    wstring strVal;
    LPCTSTR pch;
    wstring::size_type nPos = 0;
    int     nlen;

    if (NULL != lpszValue) {
        strVal = lpszValue;
    }

    // find and replace: all the instances of &quot; &amp; &lt; &gt;
    //
    while (nPos != wstring::npos && nPos < strVal.length()) {

        nPos = strVal.find_first_of(TEXT("&\"<>"), nPos);
        if (nPos == wstring::npos) {
            break;
        }

        switch(strVal.at(nPos)) {
        case TEXT('&'):
            pch = TEXT("&amp;");
            break;

        case TEXT('>'):
            pch = TEXT("&gt;");
            break;

        case TEXT('<'):
            pch = TEXT("&lt;");
            break;

        case TEXT('\"'):
            pch = TEXT("&quot;");
            break;
        default:
            // lunacy, we saw it -- and now it's gone
            pch = NULL;
            break;
        }

        if (pch) {
            strVal.replace(nPos, 1, pch); // one character
            nPos += _tcslen(pch);
        }
    }

    // once we got the string, assign
    str = lpszName;
    str += TEXT("=\"");
    str += strVal;
    str += TEXT("\"");

    return str;
}

wstring MakeXMLAttr(LPCTSTR lpszName, LONG lValue)
{
    WCHAR szBuf[32];
    wstring str;

    swprintf(szBuf, TEXT("\"0x%lx\""), lValue);

    str = lpszName;
    str += TEXT("=");
    str += szBuf;
    return str;
}

wstring MakeXMLLayers(LPCTSTR lpszLayers)
{
    wstring str;
    wstring strLayer;
    LPCTSTR pch, pbrk;

    //
    // partition the string
    //
    pch = lpszLayers;

    while (pch && *pch != TEXT('\0')) {

        pch += _tcsspn(pch, TEXT(" \t"));

        // check if we're not at the end
        if (*pch == TEXT('\0')) {
            break;
        }

        pbrk = _tcspbrk(pch, TEXT(" \t"));
        if (pbrk == NULL) {
            // from pch to the end of the string
            strLayer.assign(pch);
        } else {
            strLayer.assign(pch, (int)(pbrk-pch));
        }

        if (!str.empty()) {
            str += TEXT("\r\n");
        }
        str += TEXT("    "); // lead-in
        str += TEXT("<LAYER NAME=\"");
        str += strLayer;
        str += TEXT("\"/>");

        pch = pbrk;
    }

    return str;
}



STDMETHODIMP CUpload::AddDescriptionFile(
    BSTR     pszApplicationName,
    BSTR     pszApplicationPath,
    LONG     lMediaType,
    BOOL     bCompatSuccess,
    VARIANT* pvFixesApplied,
    VARIANT  vKey,
    BOOL     *pbSuccess
    )
{

    //
    // manifest file creation code
    //
    HANDLE   hFile = INVALID_HANDLE_VALUE;
    WCHAR    UNICODE_MARKER[] = { (WCHAR)0xFEFF, L'\r', L'\n' };
    DWORD    dwWritten;
    wstring  strLine;
    CComBSTR bstrDescriptionFile;
    BOOL     bResult;
    BOOL     bSuccess = FALSE;
    WCHAR    szBuf[32];
    VARIANT  vFixes;
    MFI      MatchingFileInfo;
    wstring  strKey = VariantToStr(CComVariant(vKey));
    wstring  strLayers;
    static   TCHAR szTab[] = TEXT("    ");
    static   TCHAR szCRTab[] = TEXT("\r\n    ");
    VariantInit(&vFixes);

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    if (!GetTempFile(TEXT("ACI"), bstrDescriptionFile)) {
        goto cleanup;
    }

    //
    // m_bstrManifest is our file
    //


    hFile = CreateFileW(bstrDescriptionFile,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    bResult = WriteFile(hFile, UNICODE_MARKER, sizeof(UNICODE_MARKER), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }


    // xml marker
    strLine = TEXT("<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    // compose compat wizard...
    strLine = TEXT("<CompatWizardResults");
    strLine += TEXT(' ');
    strLine += MakeXMLAttr(TEXT("ApplicationName"), pszApplicationName);
    strLine += szCRTab;
    strLine += MakeXMLAttr(TEXT("ApplicationPath"), pszApplicationPath);
    strLine += szCRTab;
    strLine += MakeXMLAttr(TEXT("MediaType"), lMediaType);
    strLine += szCRTab;
    strLine += MakeXMLAttr(TEXT("CompatibilityResult"), bCompatSuccess ? TEXT("Success") : TEXT("Failure"));
    strLine += TEXT(">\r\n");

    if (SUCCEEDED(VariantChangeType(&vFixes, pvFixesApplied, 0, VT_BSTR))) {
        strLayers = vFixes.bstrVal;
    }

    if (!strLayers.empty()) {
        //
        // parse the layers string and get all of them listed
        //
        strLine += MakeXMLLayers(strLayers.c_str());
        strLine += TEXT("\r\n");
    }

    strLine += TEXT("</CompatWizardResults>\r\n");

    // we are done generating data, write it all out
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }


/*

    //
    // after we get through the descriptions
    // write out data
    strLine = TEXT("[CompatWizardResults]\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    //
    // write out all the info
    //
    strLine =  TEXT("ApplicationName=");
    strLine += pszApplicationName;
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    strLine =  TEXT("ApplicationPath=");
    strLine += pszApplicationPath;
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    strLine =  TEXT("MediaType=");
    _sntprintf(szBuf, CHARCOUNT(szBuf), TEXT("0x%lx"), lMediaType);
    strLine += szBuf;
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    //
    // success
    //
    strLine = TEXT("CompatibilityResult=");
    strLine += bCompatSuccess ? TEXT("Success") : TEXT("Failure");
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }

    //
    // fixes applied
    //
    strLine = TEXT("Layers=");
    if (!SUCCEEDED(VariantChangeType(&vFixes, pvFixesApplied, 0, VT_BSTR))) {
        strLine += TEXT("none");
    } else {
        strLine += vFixes.bstrVal;
    }
    strLine += TEXT("\r\n");
    bResult = WriteFile(hFile, strLine.c_str(), strLine.length() * sizeof(WCHAR), &dwWritten, NULL);
    if (!bResult) {
        goto cleanup;
    }
*/



    // standard file -- manifesto
    MatchingFileInfo.strDescription = TEXT("Application Compatibility Description File");
    MatchingFileInfo.strFileName    = bstrDescriptionFile;
    MatchingFileInfo.bOwn           = TRUE;

    //
    // key is the filename prefixed by ACI_c:\foo\bar.exe
    //
    if (strKey.empty()) {
        strKey = TEXT("ACI_");
        strKey += pszApplicationPath;
    }
    StrUpCase(strKey);

    m_DataFiles[strKey] = MatchingFileInfo;

    // m_DataFiles.push_back(StrUpCase(wstring(bstrDescriptionFile)));
    bSuccess = TRUE;

cleanup:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    if (!bSuccess && bstrDescriptionFile.Length()) {
        DeleteFile(bstrDescriptionFile);
    }
    *pbSuccess = bSuccess;

    VariantClear(&vFixes);

    return S_OK;
}

STDMETHODIMP CUpload::DeleteTempFiles()
{
    // kill all the supplemental files

    // STRVEC::iterator iter;
    MAPSTR2MFI::iterator iter;

    for (iter = m_DataFiles.begin(); iter != m_DataFiles.end(); ++iter) {
        if ((*iter).second.bOwn) {
            ::DeleteFile((*iter).second.strFileName.c_str());
        }
    }

    m_DataFiles.clear();

    //
    // kill the manifest
    //
    if (m_bstrManifest.Length() > 0) {
        ::DeleteFile((LPCTSTR)m_bstrManifest);
    }
    m_bstrManifest.Empty();

    return S_OK;
}

VOID CUpload::ListTempFiles(wstring& str)
{
//    STRVEC::iterator iter;
    MAPSTR2MFI::iterator iter;

    str = TEXT("");

    for (iter = m_DataFiles.begin(); iter != m_DataFiles.end(); ++iter) {
        if (!str.empty()) {
            str += TEXT(";");
        }
        str += (*iter).second.strFileName.c_str();
    }

/*  // this will show the manifest file as well -- but I don't think we need to
    // do this as the manifest is irrelevant
    if (!str.empty()) {
        str += TEXT("\r\n");
    }
    str += (LPCTSTR)m_bstrManifest;
*/
}

STDMETHODIMP CUpload::ShowTempFiles()
{
    TCHAR szMshtml[] = TEXT("mshtml.dll");
    TCHAR szModuleFileName[MAX_PATH];
    LPMONIKER pmk = NULL;
    HRESULT hr;
    CComVariant vargIn;
    CComVariant vargOut;
    DWORD dwLength;
    TCHAR szUrl2[MAX_PATH];
    wstring strURL = TEXT("res://");
    wstring strArg;
    SHOWHTMLDIALOGFN* pfnShowDlg = NULL;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    HMODULE hMshtml = ::GetModuleHandle(szMshtml);
    if (NULL == hMshtml) {
        hMshtml = ::LoadLibrary(szMshtml);
        if (NULL == hMshtml) {
            goto cleanup;
        }
    }

    pfnShowDlg = (SHOWHTMLDIALOGFN*)GetProcAddress(hMshtml,
                                                   "ShowHTMLDialog");

    if (NULL == pfnShowDlg) {
        goto cleanup;
    }

    dwLength = ::GetModuleFileName(_Module.GetModuleInstance(),
                                   szModuleFileName,
                                   CHARCOUNT(szModuleFileName));

    if (dwLength == 0 || dwLength >= CHARCOUNT(szModuleFileName)) {
        goto cleanup;
    }


    _sntprintf(szUrl2, CHARCOUNT(szUrl2),
               TEXT("/#%d/%s"),
               (int)PtrToInt(RT_HTML),
               IDR_SHOWTEMPFILESDLG);

    strURL += szModuleFileName;
    strURL += szUrl2;

    hr = CreateURLMoniker(NULL, strURL.c_str(), &pmk);

    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    ListTempFiles(strArg);
    // create argument In
    vargIn = strArg.c_str();

    pfnShowDlg(::GetActiveWindow(),
               pmk,
               &vargIn,
               TEXT("center:yes"),
               &vargOut);

cleanup:

    if (NULL != pmk) {
        pmk->Release();
    }

    return S_OK;
}

STDMETHODIMP CUpload::GetDataFile(VARIANT vKey, LONG InformationClass, VARIANT* pVal)
{
    CComVariant varKey(vKey);
    LONG lIndex;
    MAPSTR2MFI::iterator iter;
    wstring str;
    HRESULT hr = S_OK;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    pVal->vt = VT_NULL;

    switch(InformationClass) {
    case InfoClassCount:
        // requested: counter
        pVal->vt = VT_I4;
        pVal->lVal = m_DataFiles.size();
        break;

    case InfoClassKey:

        if (!SUCCEEDED(varKey.ChangeType(VT_I4))) {
            break;
        }
        lIndex = varKey.lVal;
        iter = m_DataFiles.begin();
        while (iter != m_DataFiles.end() && lIndex > 0) {
            ++iter;
            --lIndex;
        }

        if (iter != m_DataFiles.end()) {
            hr = StringToVariant(pVal, (*iter).first);
        }
        break;

    case InfoClassFileName:
    case InfoClassDescription:

        if (SUCCEEDED(varKey.ChangeType(VT_I4))) {
            lIndex = varKey.lVal;
            iter = m_DataFiles.begin();
            while (iter != m_DataFiles.end() && lIndex > 0) {
                ++iter;
                --lIndex;
            }

        } else if (SUCCEEDED(varKey.ChangeType(VT_BSTR))) {
            str = varKey.bstrVal;
            iter = m_DataFiles.find(str);
        }

        if (iter != m_DataFiles.end()) {
            switch(InformationClass) {
            case InfoClassFileName:
                str = (*iter).second.strFileName;
                break;

            case InfoClassDescription:
                str = (*iter).second.strDescription;
                break;
            }

            hr = StringToVariant(pVal, str);

        }
        break;
    default:
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\util.h ===
// Util.h : Declaration of the CUtil

#ifndef __UTIL_H_
#define __UTIL_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CUtil
class ATL_NO_VTABLE CUtil :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUtil, &CLSID_Util>,
    public IDispatchImpl<IUtil, &IID_IUtil, &LIBID_COMPATUILib>,
    public IObjectWithSiteImpl<CUtil>
{
public:
    CUtil() : m_Safe(this)
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_UTIL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUtil)
    COM_INTERFACE_ENTRY(IUtil)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IUtil
public:
    STDMETHOD(IsExecutableFile)(/*[in]*/BSTR bstrPath, /*[out, retval]*/BOOL* pbExecutableFile);
    STDMETHOD(IsSystemTarget)(/*[in]*/BSTR bstrPath, /*[out, retval]*/BOOL* pbSystemTarget);
    STDMETHOD(GetExePathFromObject)(/*[in]*/BSTR pszPath, /*[out, retval]*/VARIANT* pExePath);
    STDMETHOD(CheckAdminPrivileges)(/*[out, retval]*/ BOOL* pVal);
    STDMETHOD(SetItemKeys)(/*[in]*/BSTR pszPath, /*[in]*/VARIANT* pKeys, /*[in]*/VARIANT* pKeysMachine, /*[out, retval]*/BOOL* pVal);
    STDMETHOD(GetItemKeys)(/*[in]*/BSTR pszPath, /*[out, retval]*/VARIANT* pszKeys);
    STDMETHOD(RemoveArgs)(BSTR sVar, VARIANT* pOut);
    STDMETHOD(RunApplication)(/*[in]*/BSTR pLayers, /*[in]*/BSTR pszCmdLine,
                              /*[in]*/BOOL bEnableLog, /*[out,retval]*/DWORD* pResult);
    STDMETHOD(IsCompatWizardDisabled)(/*[out, retval]*/BOOL* pbDisabled);

private:
    CSafeObject m_Safe;
};

#endif //__UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\uploadfiles.h ===
// CUploadFiles.h : Declaration of the CCUploadFiles

#ifndef __CUPLOADFILES_H_
#define __CUPLOADFILES_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
#include "CompatUI.h"
#include "upload.h"

/////////////////////////////////////////////////////////////////////////////
// CCUploadFiles
class CUploadFiles : 
    public CAxDialogImpl<CUploadFiles>
{
public:
    CUploadFiles() : m_pUpload(NULL)
    {
    }

    ~CUploadFiles()
    {
    }

    VOID SetUploadContext(CUpload* pUpload) {
        m_pUpload = pUpload;
    }


    enum { IDD = IDD_UPLOADFILES };

BEGIN_MSG_MAP(CUploadFiles)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        //
        // init text control please
        //
        
        wstring strList;
        
        m_pUpload->ListTempFiles(strList);
        SetDlgItemText(IDC_UPLOADFILES, strList.c_str());
    
        return 1;  // Let the system set the focus
    }

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

private:
    CUpload* m_pUpload;
};

#endif //__CUPLOADFILES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\compatui\util.cpp ===
// Util.cpp : Implementation of CUtil
#include "stdafx.h"
#include "CompatUI.h"
#include "Util.h"
#include <shlobj.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <msi.h>
#include <sfc.h>
#include <wininet.h>
#include "Aclapi.h"

extern "C" {
#include "shimdb.h"
}

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <locale>
#include <algorithm>
#include <vector>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CUtil
extern "C"
VOID
InvalidateAppcompatCacheEntry(
    LPCWSTR pwszDosPath
    );

BOOL
GetExePathFromObject(
    LPCTSTR lpszPath,  // path to an arbitrary object
    CComBSTR& bstrExePath
    );


    typedef
    INSTALLSTATE (WINAPI*PMsiGetComponentPath)(
      LPCTSTR szProduct,   // product code for client product
      LPCTSTR szComponent, // component ID
      LPTSTR lpPathBuf,    // returned path
      DWORD *pcchBuf       // buffer character count
    );

    typedef
    UINT (WINAPI* PMsiGetShortcutTarget)(
      LPCTSTR szShortcutTarget,     // path to shortcut link file
      LPTSTR szProductCode,        // fixed length buffer for product code
      LPTSTR szFeatureId,          // fixed length buffer for feature id
      LPTSTR szComponentCode       // fixed length buffer for component code
    );

BOOL
IsUserAdmin(
    void
    );

BOOL
GiveUsersWriteAccess(
    void
    );

BOOL
IsLUAEnabled(
    LPCWSTR pszLayers
    );

wstring
StrUpCase(
    wstring& wstr
    );

BOOL
ShimExpandEnvironmentVars(
    LPCTSTR lpszCmd,
    CComBSTR& bstr
    )
{
    DWORD dwLength;
    LPTSTR lpBuffer = NULL;
    BOOL   bExpanded = FALSE;
    if (_tcschr(lpszCmd, TEXT('%')) == NULL) {
        goto out;
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, NULL, 0);
    if (!dwLength) {
        goto out;
    }

    lpBuffer = new TCHAR[dwLength];
    if (NULL == lpBuffer) {
        goto out;
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, lpBuffer, dwLength);
    if (!dwLength) {
        goto out;
    }
    bstr = lpBuffer;
    bExpanded = TRUE;

 out:
    if (!bExpanded) {
        bstr = lpszCmd;
    }
    if (lpBuffer) {
        delete[] lpBuffer;
    }
    return bExpanded;
}

wstring
ShimUnquotePath(
    LPCTSTR pwszFileName
    )
{
    wstring sFileName;
    LPCTSTR pScan = pwszFileName;
    LPCTSTR pQuote;
    LPCTSTR pLastQuote = NULL;

    // skip over the leading spaces
    pScan += _tcsspn(pScan, TEXT(" \t"));
    while (*pScan) {
        pQuote = _tcschr(pScan, TEXT('\"'));
        if (NULL == pQuote) {
            sFileName += pScan;
            break;
        }
        //
        // we found a quote
        // is this the first quote we've found?
        if (pLastQuote == NULL) {
            pLastQuote = pQuote;
            // add the current string
            sFileName += wstring(pScan, (int)(pQuote-pScan));
        } else {
            // we have a closing quote
            ++pLastQuote;
            sFileName += wstring(pLastQuote, (int)(pQuote-pLastQuote));
            pLastQuote = NULL;
        }

        pScan = pQuote + 1;

    }

    return sFileName;
}

//
// ShimGetPathFromCmdLine
//

BOOL
ShimGetPathFromCmdLine(
    LPCTSTR pwszCmdLine,
    CComBSTR& StrPath
    )
{
    TCHAR chSave;
    LPTSTR pScan = (LPTSTR)pwszCmdLine;
    LPTSTR pAppName;
    TCHAR  szBuffer[MAX_PATH];
    DWORD  dwLength;
    DWORD  dwAttributes;
    BOOL   bScan = FALSE;
    CComBSTR bstrPathName;

    if (*pScan == TEXT('\"')) {
        // seek till we find matching "
        pAppName = ++pScan;
        while (*pScan) {
            if (*pScan == TEXT('\"')) {
                break;
            }
            ++pScan;
        }
    } else {
        pAppName = pScan;
        while (*pScan) {
            if (_istspace(*pScan)) {
                bScan = TRUE;
                break;
            }
            ++pScan;
        }
    }

    while (TRUE) {

        chSave = *pScan;
        *pScan = TEXT('\0');

        ShimExpandEnvironmentVars(pAppName, bstrPathName);

        //
        // check whether bstrPathName is valid (failure due to memory allocation is possible)
        //
        if (!bstrPathName) {
            //
            // overloaded operator ! for CComBSTR will check whether bstrPathName == NULL
            //
            break;
        }

        //
        // Check this path
        //
        dwLength = SearchPathW(NULL,
                               bstrPathName,
                               TEXT(".exe"),
                               CHARCOUNT(szBuffer),
                               szBuffer,
                               NULL);
        //
        // restore the character
        //
        *pScan = chSave;

        if (dwLength && dwLength < CHARCOUNT(szBuffer)) {
            //
            // check attributes
            //
            dwAttributes = GetFileAttributesW(szBuffer);
            if ((dwAttributes != (DWORD)-1) &&
                !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                //
                // we are mighty done
                //
                StrPath = (LPCWSTR)szBuffer;
                return TRUE;
            }
        }

        if (!bScan || *pScan == TEXT('\0')) {
            break;
        }

        ++pScan;
        while (*pScan) {
           if (_istspace(*pScan)) {
               break;
           }
           ++pScan;
        }

    }


    return FALSE;
}

//
// This class allows us to change error mode on selected apis
//
//

class CSaveErrorMode {
public:
    CSaveErrorMode() {
        m_uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    }
    ~CSaveErrorMode() {
        SetErrorMode(m_uiErrorMode);
    }
protected:
    UINT m_uiErrorMode;
};


STDMETHODIMP CUtil::IsCompatWizardDisabled(BOOL* pbDisabled)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwValue, dwSize = sizeof(dwValue);
    DWORD dwType;

    //
    // First, check for the whole engine being disabled.
    //
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            POLICY_KEY_APPCOMPAT_W,
                            0,
                            KEY_READ,
                            &hKey);
    if (lResult == ERROR_SUCCESS) {
        dwValue = 0;
        lResult = RegQueryValueExW(hKey,
                                   POLICY_VALUE_DISABLE_ENGINE_W,
                                   0,
                                   &dwType,
                                   (LPBYTE)&dwValue,
                                   &dwSize);
        RegCloseKey (hKey);
    }

    //
    // The default is enabled, so if we didn't find a value, treat it like the value is 0.
    //
    if (lResult != ERROR_SUCCESS || dwValue == 0) {
        //
        // Check for the proppage being disabled.
        //
        lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                POLICY_KEY_APPCOMPAT_W,
                                0,
                                KEY_READ,
                                &hKey);
        if (lResult == ERROR_SUCCESS) {
            dwValue = 0;
            lResult = RegQueryValueExW(hKey,
                                       POLICY_VALUE_DISABLE_WIZARD_W,
                                       0,
                                       &dwType,
                                       (LPBYTE) &dwValue, &dwSize);
            RegCloseKey (hKey);
        }

        //
        // The default is to be enabled, so if we didn't find a value, or the value is 0, then we're good to go.
        //
    }


    *pbDisabled = (lResult == ERROR_SUCCESS) && (dwValue != 0);

    return S_OK;

}

STDMETHODIMP CUtil::RemoveArgs(BSTR pVar, VARIANT* pRet)
{
    // TODO: Add your implementation code here
    CComBSTR bstr;
    CSaveErrorMode ErrMode;

    if (!ShimGetPathFromCmdLine(pVar, bstr)) {
        bstr = pVar;
    }

    pRet->vt = VT_BSTR;
    pRet->bstrVal = bstr.Copy();

    return S_OK;
}

STDMETHODIMP CUtil::GetItemKeys(BSTR pVar, VARIANT *pRet)
{
    CComBSTR bstr = pVar;
    CComBSTR bstrOut;
    LPWSTR   pwszPermKeys;
    DWORD    cbSize;
    BOOL     bLayers;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    bLayers = SdbGetPermLayerKeys(bstr, NULL, &cbSize, GPLK_ALL);
    if (bLayers) {
        pwszPermKeys = new WCHAR[cbSize / sizeof(WCHAR)];
        if (pwszPermKeys == NULL) {
            return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        bLayers = SdbGetPermLayerKeys(bstr, pwszPermKeys, &cbSize, GPLK_ALL);
        if (bLayers) {
            bstrOut = pwszPermKeys;
        }
        delete [] pwszPermKeys;
    }

    if (!bstrOut) {
        pRet->vt = VT_NULL;
    } else {
        pRet->vt = VT_BSTR;
        pRet->bstrVal = bstrOut.Copy();
    }

    return S_OK;
}


STDMETHODIMP CUtil::SetItemKeys(BSTR pszPath, VARIANT* pKeys, VARIANT* pKeysMachine, BOOL *pVal)
{
    // TODO: Add your implementation code here
    CComBSTR bstrKeys;
    CComBSTR bstrKeysMachine;
    BOOL     bSuccess = TRUE;
    VARIANT  varKeys;
    VARIANT  varKeysMachine;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    InvalidateAppcompatCacheEntry(pszPath);

    if (pKeys->vt == VT_NULL || pKeys->vt == VT_EMPTY) {
        bSuccess &= SdbDeletePermLayerKeys(pszPath, FALSE);
    } else {
        VariantInit(&varKeys);
        if (SUCCEEDED(VariantChangeType(&varKeys, pKeys, 0, VT_BSTR))) {
            bstrKeys = varKeys.bstrVal;
            VariantClear(&varKeys);
        }

        if (bstrKeys) {
            bSuccess &= SdbSetPermLayerKeys(pszPath, bstrKeys, FALSE);
        }
    }

    if (IsUserAdmin()) {
        if (pKeysMachine->vt == VT_NULL || pKeysMachine->vt == VT_EMPTY) {
            bSuccess &= SdbDeletePermLayerKeys(pszPath, TRUE);
        } else {
            VariantInit(&varKeysMachine);
            if (SUCCEEDED(VariantChangeType(&varKeysMachine, pKeysMachine, 0, VT_BSTR))) {
                bstrKeysMachine = varKeysMachine.bstrVal;
                VariantClear(&varKeysMachine);
            }
            if (bstrKeysMachine) {
                bSuccess &= SdbSetPermLayerKeys(pszPath, bstrKeysMachine, TRUE);
                //
                // find whether we need to have LUA setting handled by granting write access to a common area
                //
                if (IsLUAEnabled(bstrKeysMachine)) {
                    GiveUsersWriteAccess();
                }

            }
        }
    }

    *pVal = bSuccess;

    return S_OK;
}

BOOL
SearchGroupForSID(
    DWORD dwGroup,
    BOOL* pfIsMember
    )
{
    PSID                     pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {
        ATLTRACE(_T("[SearchGroupForSID] AllocateAndInitializeSid failed 0x%lx\n"),
                 GetLastError());

        return FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        ATLTRACE(_T("[SearchGroupForSID] CheckTokenMembership failed 0x%x\n"),
                 GetLastError());
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

BOOL
IsUserAdmin(
    void
    )
{
    BOOL fIsUser, fIsAdmin, fIsPowerUser;

    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_USERS, &fIsUser) ||
        !SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin)) {
        return FALSE;
    }

    return (fIsUser && fIsAdmin);
}


BOOL
GiveUsersWriteAccess(
    void
    )
{
    DWORD                    dwRes;
    EXPLICIT_ACCESS          ea;
    PACL                     pOldDACL;
    PACL                     pNewDACL = NULL;
    PSECURITY_DESCRIPTOR     pSD = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    PSID                     pUsersSID = NULL;
    TCHAR                    szDir[MAX_PATH];

    ExpandEnvironmentStrings(LUA_REDIR_W, szDir, MAX_PATH);

    if (!CreateDirectory(szDir, NULL)) {
        DWORD err = GetLastError();
        
        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            return FALSE; 
        }
    }
    
    dwRes = GetNamedSecurityInfo(szDir,
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 &pOldDACL,
                                 NULL,
                                 &pSD);
    
    if (ERROR_SUCCESS != dwRes) {
        goto Cleanup; 
    }  

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pUsersSID) ) {
        goto Cleanup;
    }

    //
    // Initialize an EXPLICIT_ACCESS structure for the new ACE. 
    //
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    
    ea.grfAccessPermissions = FILE_GENERIC_WRITE | FILE_GENERIC_READ | DELETE;
    ea.grfAccessMode        = GRANT_ACCESS;
    ea.grfInheritance       = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType  = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName    = (LPTSTR)pUsersSID;

    //
    // Create a new ACL that merges the new ACE
    // into the existing DACL.
    //
    dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
    
    if (ERROR_SUCCESS != dwRes)  {
        goto Cleanup; 
    }

    dwRes = SetNamedSecurityInfo(szDir,
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 pNewDACL,
                                 NULL);
    
    if (ERROR_SUCCESS != dwRes)  {
        goto Cleanup; 
    }

Cleanup:

    if (pSD) {
        LocalFree(pSD);
    }

    if (pUsersSID) {
        FreeSid(pUsersSID);
    }
    
    if (pNewDACL) {
        LocalFree(pNewDACL);
    }

    return (dwRes == ERROR_SUCCESS);
}

BOOL
IsLUAEnabled(
    LPCWSTR pszLayers
    )
{
    LPCWSTR pchStart = pszLayers;
    LPCWSTR pch;
    wstring strTok;
    BOOL    bLUAEnabled = FALSE;

    pchStart += wcsspn(pchStart, L"#!");

    while (pchStart != NULL && *pchStart != L'\0' && !bLUAEnabled) {
        pchStart += wcsspn(pchStart, L" \t");
        if (*pchStart == L'\0') {
            break;
        }

        pch = wcspbrk(pchStart, L" \t");
        if (pch == NULL) {
            strTok = pchStart;
            pchStart = NULL;
        } else {
            strTok = wstring(pchStart, (size_t)(pch - pchStart));
            StrUpCase(strTok);
            pchStart = pch;
        }
        bLUAEnabled = (strTok == L"LUA");
    }

    return bLUAEnabled;

}



// this method returns true when we should present the LUA checkbox and
// false when we should not

STDMETHODIMP CUtil::CheckAdminPrivileges(BOOL *pVal)
{
    *pVal = IsUserAdmin();
    return S_OK;
}

STDMETHODIMP CUtil::RunApplication(BSTR pLayers, BSTR pszCmdLine, BOOL bEnableLog, DWORD* pResult)
{

    LPCWSTR  pszExt;
    BOOL     bShellExecute = FALSE;
    BOOL     bSuccess = FALSE;
    DWORD    dwError  = 0;
    DWORD    dwBinaryType = 0;
    DWORD    dwCreateProcessFlags = 0;
    CSaveErrorMode ErrMode;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    CComBSTR bstrAppName = pszCmdLine;
    ShimGetPathFromCmdLine(pszCmdLine, bstrAppName);

    CComBSTR bstrExePath;

    if (!bstrAppName) {
        dwError = ERROR_BAD_PATHNAME;
        goto Done;
    }


    // check if we are using .lnk file

    pszExt = PathFindExtension(bstrAppName);
    if (pszExt != NULL) {
        bShellExecute = !_tcsicmp(pszExt, TEXT(".lnk"));
    }

    if (!bShellExecute) { // not shell exec? check the binary
        if (!pszExt || (_tcsicmp(pszExt, TEXT(".cmd")) && _tcsicmp(pszExt, TEXT(".bat")))) {
            bShellExecute = !GetBinaryTypeW(bstrAppName, &dwBinaryType);
            if (!bShellExecute && (dwBinaryType == SCS_WOW_BINARY || dwBinaryType == SCS_PIF_BINARY)) {
                dwCreateProcessFlags |= CREATE_SEPARATE_WOW_VDM;
            }
        }
    }
    //
    // invalidate cache
    //
    if (::GetExePathFromObject(bstrAppName, bstrExePath)) {
        InvalidateAppcompatCacheEntry(bstrExePath);
    }


    SetEnvironmentVariable(TEXT("__COMPAT_LAYER"), pLayers);
    SetEnvironmentVariable(TEXT("SHIM_FILE_LOG"),  bEnableLog ? TEXT("shim.log") : NULL);

    //
    // now we shall either ShellExecute or do a CreateProcess
    //
    if (bShellExecute) {
        int    nLength = bstrAppName.Length() + 3;
        LPTSTR pszCmdLineShellExec  = new TCHAR[nLength];
        SHELLEXECUTEINFO ShExecInfo = { 0 };

        if (pszCmdLineShellExec == NULL) {
            //
            // out of memory, just do a create process
            //
            goto HandleCreateProcess;
        }
        nLength = _sntprintf(pszCmdLineShellExec,
                             nLength,
                             TEXT("\"%s\""),
                             (LPCTSTR)bstrAppName);
        if (nLength < 0) {
            delete[] pszCmdLineShellExec;
            goto HandleCreateProcess;
        }

        ShExecInfo.cbSize = sizeof(ShExecInfo);
        ShExecInfo.fMask  = 0; //SEE_MASK_FLAG_NO_UI;
        ShExecInfo.lpVerb = L"open";
        ShExecInfo.lpFile = pszCmdLineShellExec;
        ShExecInfo.nShow  = SW_SHOW;

        bSuccess = ShellExecuteEx(&ShExecInfo);
        if (!bSuccess || (int)((INT_PTR)ShExecInfo.hInstApp) < 32) {
            dwError = GetLastError();
        }
        delete[] pszCmdLineShellExec;


    } else {
HandleCreateProcess:

        // get working directory
        TCHAR szWorkingDir[MAX_PATH];
        LPTSTR pAppName = (LPTSTR)bstrAppName.m_str;
        int nLength;
        LPTSTR pszWorkingDir = NULL;
        STARTUPINFO         StartupInfo;
        PROCESS_INFORMATION ProcessInfo;

        LPTSTR pBackslash = _tcsrchr(pAppName, TEXT('\\'));
        if (pBackslash != NULL) {
            //
            // check for root
            //
            nLength = (int)(pBackslash - pAppName);
            if (nLength == 2 && pAppName[1] == TEXT(':')) {
                ++nLength;
            }
            _tcsncpy(szWorkingDir, pAppName, nLength);
            szWorkingDir[nLength] = TEXT('\0');
            pszWorkingDir = szWorkingDir;
        }

        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

        bSuccess = CreateProcess(NULL,
                                 pszCmdLine,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 0,
                                 NULL,
                                 pszWorkingDir,
                                 &StartupInfo,
                                 &ProcessInfo);

        if (!bSuccess) {
            dwError = GetLastError();
        }

        if (ProcessInfo.hThread) {
            CloseHandle(ProcessInfo.hThread);
        }
        if (ProcessInfo.hProcess) {
            CloseHandle(ProcessInfo.hProcess);
        }
    }

Done:

    *pResult = dwError;

    SetEnvironmentVariable(TEXT("__COMPAT_LAYER"), NULL);
    SetEnvironmentVariable(TEXT("SHIM_FILE_LOG") , NULL);

    return S_OK;
}

BOOL
GetExePathFromLink(
    LPMALLOC      pMalloc,
    LPCITEMIDLIST pidlLinkFull,
    LPCTSTR       pszLinkFile,
    LPTSTR        pszExePath,
    DWORD         dwBufferSize
    )
{
    IShellLink* psl = NULL;
    WIN32_FIND_DATA wfd;
    HRESULT  hr;
    BOOL     bSuccess = FALSE;
    TCHAR    szPath[MAX_PATH];
    IPersistFile* ipf = NULL;
    IShellLinkDataList* pdl;
    DWORD dwFlags  = 0;
    BOOL  bMsiLink = FALSE;
    HMODULE hMSI = NULL;

    // first do the link

    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLink, (LPVOID*)&psl);
    if (!SUCCEEDED(hr)) {
        return FALSE; // we can't create link object
    }

    hr = psl->SetIDList(pidlLinkFull); // set the id list
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ipf);
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    hr = ipf->Load(pszLinkFile, STGM_READ);
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    //
    // resolve the link for now
    //
    // hr = psl->Resolve(NULL, SLR_NO_UI|SLR_NOUPDATE);
    //

    hr = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&pdl);
    if (SUCCEEDED(hr)) {
        hr = pdl->GetFlags(&dwFlags);

        bMsiLink = SUCCEEDED(hr) && (dwFlags & SLDF_HAS_DARWINID);

        pdl->Release();
    }

    if (bMsiLink) {
        //
        // this is msi link, we need to crack it using msi
        //
        UINT  ErrCode;
        TCHAR szProduct      [MAX_PATH];
        TCHAR szFeatureId    [MAX_PATH];
        TCHAR szComponentCode[MAX_PATH];
        INSTALLSTATE is;

        hMSI = LoadLibrary(TEXT("Msi.dll"));
        if (NULL == hMSI) {
            goto out;
        }

        PMsiGetComponentPath  pfnGetComponentPath  = (PMsiGetComponentPath )GetProcAddress(hMSI, "MsiGetComponentPathW");
        PMsiGetShortcutTarget pfnGetShortcutTarget = (PMsiGetShortcutTarget)GetProcAddress(hMSI, "MsiGetShortcutTargetW");

        if (!pfnGetComponentPath || !pfnGetShortcutTarget)
        {
            goto out;
        }

        ErrCode = pfnGetShortcutTarget(pszLinkFile,
                                       szProduct,
                                       szFeatureId,
                                       szComponentCode);
        if (ERROR_SUCCESS != ErrCode) {
            goto out;
        }

        *pszExePath = TEXT('\0');

        is = pfnGetComponentPath(szProduct, szComponentCode, pszExePath, &dwBufferSize);
        bSuccess = (INSTALLSTATE_LOCAL == is);

    } else {

        hr = psl->GetPath(pszExePath, dwBufferSize, &wfd, 0);
        bSuccess = SUCCEEDED(hr);
    }


out:
    if (hMSI) {
        FreeLibrary(hMSI);
    }

    if (NULL != ipf) {
        ipf->Release();
    }

    if (NULL != psl) {
        psl->Release();
    }

    return bSuccess;

}

BOOL
GetExePathFromObject(
    LPCTSTR lpszPath,  // path to an arbitrary object
    CComBSTR& bstrExePath
    )
{
    IShellFolder* psh = NULL;
    LPMALLOC      pMalloc = NULL;
    HRESULT       hr;
    LPITEMIDLIST  pidl = NULL;
    DWORD         dwAttributes;
    CComBSTR      bstr;
    BOOL          bSuccess = FALSE;

    hr = SHGetMalloc(&pMalloc);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    hr = SHGetDesktopFolder(&psh);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }


    if (!ShimGetPathFromCmdLine(lpszPath, bstr)) {
        goto cleanup;
    }

    //
    // parse display name
    //
    dwAttributes = SFGAO_LINK | SFGAO_FILESYSTEM | SFGAO_VALIDATE;

    hr = psh->ParseDisplayName(NULL,
                               NULL,
                               bstr,     // path to the executable file
                               NULL,     // number of chars eaten
                               &pidl,
                               &dwAttributes);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    //
    // display name parsed, check whether it's a link
    //
    if (dwAttributes & SFGAO_LINK) {
        TCHAR szExePath[MAX_PATH];
        //
        // it's a link, crack it
        //
        bSuccess = GetExePathFromLink(pMalloc,
                                      pidl,
                                      bstr,
                                      szExePath,
                                      CHARCOUNT(szExePath));
        // after recovering the path -- get the env vars expanded
        if (bSuccess) {
            ShimExpandEnvironmentVars(szExePath, bstrExePath);
        }

    } else if (dwAttributes & SFGAO_FILESYSTEM) {
        //
        // filesystem object (a file)
        //
        bstrExePath = bstr;
        bSuccess    = TRUE;
    }


cleanup:


    if (pidl) {
        pMalloc->Free(pidl);
    }
    if (psh) {
        psh->Release();
    }
    if (pMalloc) {
        pMalloc->Release();
    }
    return bSuccess;
}

STDMETHODIMP CUtil::GetExePathFromObject(BSTR pszPath, VARIANT* pExePath)
{
    CComBSTR bstrExePath;
    BOOL bSuccess;
    CSaveErrorMode ErrMode;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    bSuccess = ::GetExePathFromObject(pszPath, bstrExePath);
    if (bSuccess) {
        pExePath->vt = VT_BSTR;
        pExePath->bstrVal = bstrExePath.Copy();
    } else {
        pExePath->vt = VT_NULL;
    }

    return S_OK;
}

STDMETHODIMP CUtil::IsSystemTarget(BSTR bstrPath, BOOL *pbSystemTarget)
{
    CComBSTR bstrExePath;
    BOOL  bSystemTarget = FALSE;
    DWORD dwAttributes;
    CSaveErrorMode ErrMode;

/*++
    //
    // This code was used to check system directory
    //

    ULONG uSize;
    int   nch;
    TCHAR szSystemDir[MAX_PATH];
    TCHAR szCommonPath[MAX_PATH];

    uSize = ::GetSystemWindowsDirectory(szSystemDir,
                                        CHARCOUNT(szSystemDir));
    if (uSize == 0 || uSize > CHARCOUNT(szSystemDir)) {
        *pbSystemTarget = FALSE;
        return S_OK;
    }
--*/


    if (!::GetExePathFromObject(bstrPath, bstrExePath)) {
        bstrExePath = bstrPath;
    }

    if (!bstrExePath) {
        goto Done;
    }

/*++
    // this code was used before -- it checked system directory as
    // well as sfc, we are only checking sfc now

    nch = PathCommonPrefix(szSystemDir, bstrExePath, szCommonPath);
    bSystemTarget = (nch == (int)uSize);
    if (!bSystemTarget) {
        bSystemTarget = SfcIsFileProtected(NULL, bstrExePath);
    }
--*/

    bSystemTarget = SfcIsFileProtected(NULL, bstrExePath);


    if (!bSystemTarget) {
        dwAttributes = GetFileAttributes(bstrExePath);
        bSystemTarget = (dwAttributes == (DWORD)-1 || (dwAttributes & FILE_ATTRIBUTE_DIRECTORY));
    }

Done:

    *pbSystemTarget = bSystemTarget;

    return S_OK;
}


STDMETHODIMP CUtil::IsExecutableFile(BSTR bstrPath, BOOL *pbExecutableFile)
{
    BOOL bExecutable = FALSE;
    DWORD dwExeType = 0;
    CComBSTR bstrExePath;
    LPCWSTR pszExt;
    CSaveErrorMode ErrMode;

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    if (!::GetExePathFromObject(bstrPath, bstrExePath)) {
        bstrExePath = bstrPath;
    }

    if (!bstrExePath) {
        //
        // this could happen on a memory allocation failure path
        //
        goto Done;
    }

    bExecutable = GetBinaryTypeW(bstrExePath, &dwExeType);
    if (!bExecutable) {
        // is this a batch file? if not -- you are out!
        pszExt = PathFindExtension(bstrPath);
        if (pszExt != NULL) {
            bExecutable = !_tcsicmp(pszExt, TEXT(".bat")) ||
                          !_tcsicmp(pszExt, TEXT(".cmd"));
        }
    }

Done:

    *pbExecutableFile = bExecutable;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////
//
// Security: Check for invocation via the hcp protocol and system as the host
//
//
BOOL
CheckHost(
    IUnknown* pObjectClientSite
    )
{
    HRESULT                 hr;
    CComPtr<IOleClientSite> spClientSite;
    BSTR                    bstrURL = NULL;
    TCHAR                   szScheme[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR                   szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    URL_COMPONENTS          UrlComponents = { 0 };
    BOOL                    bHostVerified = FALSE;

    if (pObjectClientSite == NULL) {
        return FALSE;
    }

    CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pObjectClientSite);

    if (spServiceProvider == NULL) {
        return FALSE;
    }

    CComPtr<IWebBrowser2> spBrowser;

    hr = spServiceProvider->QueryService(SID_SWebBrowserApp,
                                         IID_IWebBrowser2,
                                         reinterpret_cast<void**>(&spBrowser));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }


    //
    // we have browser i/f -- get url now
    //

    hr = spBrowser->get_LocationURL(&bstrURL);
    if (!SUCCEEDED(hr) || bstrURL == NULL) {
        return FALSE;
    }

    //
    // crack the url
    //
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszScheme       = szScheme;
    UrlComponents.dwSchemeLength   = CHARCOUNT(szScheme);
    UrlComponents.lpszHostName     = szHostName;
    UrlComponents.dwHostNameLength = CHARCOUNT(szHostName);

    if (!InternetCrackUrl(bstrURL, 0, 0, &UrlComponents)) {
        goto cleanup;
    }

    //
    // now we should be good to go to check scheme and the host name
    //
    if (_tcsicmp(UrlComponents.lpszScheme, TEXT("hcp")) != 0 ) {
        //
        // bad protocol
        //
        goto cleanup;
    }

    if (_tcsicmp(UrlComponents.lpszHostName, TEXT("system")) != 0) {
        //
        // bad host
        //
        goto cleanup;
    }

    bHostVerified = TRUE;

cleanup:

    if (bstrURL) {
        SysFreeString(bstrURL);
    }

    return bHostVerified;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\exts\exts.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    exts.c

Abstract:

    This file implements the debugger extentions for shimeng/shims.

Environment:

    User Mode

History:

    03/14/2002 maonis Created

--*/

#include "precomp.h"

extern "C" {
#include "shimdb.h"
}

// We're using the high 4 bits of the TAGID to say what PDB the TAGID is from.
#define PDB_MAIN            0x00000000
#define PDB_TEST            0x10000000
#define PDB_LOCAL           0x20000000

// Used to get the tag ref from the tagid, the low 28 bits
#define TAGREF_STRIP_TAGID  0x0FFFFFFF

// Used to get the PDB from the tagid, the high 4 bits
#define TAGREF_STRIP_PDB    0xF0000000

BOOL
GetData(
    IN ULONG64 Address, 
    IN OUT LPVOID ptr, 
    IN ULONG size)
{
    BOOL b;
    ULONG BytesRead = 0;

    b = ReadMemory(Address, ptr, size, &BytesRead );

    if (!b || BytesRead != size ) {
        return FALSE;
    }

    return TRUE;
}

//void
//GetAndCheckFieldValue(
//    IN  ULONG64 p,
//    IN  LPCSTR pszType,
//    IN  LPCSTR pszField,
//    OUT ULONG64 value
//    )
#define GET_AND_CHECK_FIELDVALUE(p, Type, Field, value) \
{ \
    if (GetFieldValue(p, Type, Field, value)) { \
        dprintf("failed to get the value of %s for %08x of type %s\n", \
            Field, p, Type); \
        goto EXIT; \
    } \
}

#define GET_AND_CHECK_FIELDVALUE_DATA(p, Type, Field, data, length) \
{ \
    ULONG64 value; \
    GET_AND_CHECK_FIELDVALUE(p, Type, Field, value); \
    if (!GetData(value, data, length)) { \
        dprintf("failed to read in %d bytes at %08x\n", length, value); \
        goto EXIT; \
    } \
}

#define GET_AND_CHECK_DATA(value, data,length) \
{ \
    if (!GetData(value, data, length)) { \
        dprintf("failed to read in %d bytes at %08x\n", length, value); \
        goto EXIT; \
    } \
}

#define GET_SHIMINFO_eInExMode(p, eInExMode) \
    GET_AND_CHECK_FIELDVALUE(p, "shimeng!tagSHIMINFO", "eInExMode", eInExMode);

#define GET_SHIMINFO_pFirstExclude(p, pFirstExclude) \
    GET_AND_CHECK_FIELDVALUE(p, "shimeng!tagSHIMINFO", "pFirstExclude", pFirstExclude);

#define GET_SHIMINFO_pFirstInclude(p, pFirstInclude) \
    GET_AND_CHECK_FIELDVALUE(p, "shimeng!tagSHIMINFO", "pFirstExclude", pFirstInclude);

#define GET_SHIMINFO_wszName(p, wszName) \
    if (GetFieldData( \
        p, \
        "shimeng!tagSHIMINFO", \
        "wszName", \
        MAX_SHIM_NAME_LEN * sizeof(WCHAR), \
        wszName)) \
    { \
        dprintf("Failed to get the wszName field of shim info %08x\n", p); \
        goto EXIT; \
    }

#define SHIM_DEBUG_LEVEL_SYMBOL_SUFFIX "!ShimLib::g_DebugLevel"
#define SHIM_DEBUG_LEVEL_TYPE_SUFFIX "!ShimLib::DEBUGLEVEL"

typedef enum tagINEX_MODE {
    INEX_UNINITIALIZED = 0,
    EXCLUDE_SYSTEM32,
    EXCLUDE_ALL,
    INCLUDE_ALL
} INEX_MODE, *PINEX_MODE;

#define MAX_SHIM_NAME_LEN 64

#define MAX_SHIM_DLLS 8
#define MAX_SHIM_DEBUGLEVEL_SYMBOL_LEN 64
#define MAX_SHIM_DLL_BASE_NAME_LEN 32

typedef struct tagSHIMDLLINFO {
    ULONG64 pDllBase;
    char    szDllBaseName[MAX_SHIM_DLL_BASE_NAME_LEN];
} SHIMDLLINFO, *PSHIMDLLINFO;

SHIMDLLINFO g_rgShimDllNames[MAX_SHIM_DLLS];

DWORD g_dwShimDlls = 0;

#define MAX_API_NAME_LEN 32
#define MAX_MODULE_NAME_LEN 16
#define MAX_DLL_IMAGE_NAME_LEN 128

char g_szSystem32Dir[MAX_DLL_IMAGE_NAME_LEN] = "";
DWORD g_dwSystem32DirLen = 0;

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
                
//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS2       g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS3 g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

/*++

  Function Description:

    This reads a ULONG64 value for the specified variable name from the debugee.

  History:

    03/14/2002 maonis Created

--*/
BOOL
GetVarValueULONG64(
    IN  LPCSTR pszVarName,
    OUT ULONG64* pVarValue
    ) 
{
    ULONG64 VarAddr = GetExpression(pszVarName);

    if (!VarAddr) {
        dprintf("Failed to get the address of %s\n", pszVarName);
        return FALSE;
    }

    if (!ReadPointer(VarAddr, pVarValue)) {
        dprintf("Failed to read the value of %s\n", pszVarName);
        return FALSE;
    }

    return TRUE;
}

/*++

  Function Description:

    This writes a ULONG64 value for the specified variable name from the debugee.

  History:

    03/14/2002 maonis Created

--*/
BOOL
SetVarValueULONG64(
    IN  LPCSTR pszVarName,
    IN  ULONG64 VarValue
    ) 
{
    ULONG64 VarAddr = GetExpression(pszVarName);

    if (!VarAddr) {
        dprintf("Failed to get the address of %s\n", pszVarName);
        return FALSE;
    }

    if (!WritePointer(VarAddr, VarValue)) {
        dprintf("Failed to read the value of %s\n", pszVarName);
        return FALSE;
    }

    return TRUE;
}

/*++

  Function Description:

    Returns a string for the symbol that matches the value at
    address dwAddr, or "".

  History:

    03/12/2002 maonis Created

--*/
void
PrintSymbolAtAddress(ULONG64 Addr)
{
    CHAR szSymbol[128];
    ULONG64 Displacement;

    GetSymbol(Addr, szSymbol, &Displacement);

    if (strcmp(szSymbol, "") != 0) {

        dprintf(" (%s", szSymbol);

        if (Displacement) {
            dprintf("+%08x", Displacement);
        }
        
        dprintf(") ");
    }
}

BOOL
IsShimInitialized()
{
    ULONG64 Value;
    BOOL bIsShimInitialized;

    if (GetVarValueULONG64("shimeng!g_bShimInitialized", &Value)) {

        bIsShimInitialized = (BOOL)Value;

        if (bIsShimInitialized) {
            //dprintf("Shim has been initialized\n");

            return TRUE;
        }
    } 

    dprintf("Shim(s) have not been initialized\n");

    return FALSE;
}

BOOL
CheckForFullPath(
    LPSTR pszPath
    )
{
    if (pszPath) {

        LPSTR pszSlash = strchr(pszPath, L'\\');

        if (pszSlash) {
            return TRUE;
        }
    }

    dprintf("The module info is not yet fully available to us. Please "
        "do .reload -s to load the module info.\n");

    return FALSE;
}

/*++

  Function Description:
    
    Get the module and the loaded module name. The former is the base name;
    the latter has the full path.

    Note that if the symbols are not loaded correctly, or if the load module 
    event hasn't occured, we can't get the full path to some modules. In this 
    case the user will be prompted to do a .reload -s to make the full path of 
    the loaded modules available.

--*/
HRESULT
GetDllNamesByIndexAndBase(
    ULONG Index,
    ULONG64 Base,
    LPSTR pszModuleName,
    DWORD dwModuleNameSize,
    LPSTR pszImageName,
    DWORD dwImageNameSize
    )
{
    HRESULT hr = g_ExtSymbols->GetModuleNames(
        Index, 
        Base,
        pszImageName,  
        dwImageNameSize, 
        NULL,
        pszModuleName,
        dwModuleNameSize,
        NULL,
        NULL, 
        0, 
        NULL);

    if (hr == S_OK) {

        if (pszImageName && !CheckForFullPath(pszImageName)) {
            hr = E_FAIL;
        }

    } else {
        dprintf(
            "GetModuleName returned %08x for index %d, base %08x\n",
            hr,
            Index,
            Base);
    }

    return hr;
}

HRESULT
GetDllNameByOffset(
    PVOID pDllBase,
    LPSTR pszModuleName,
    DWORD dwModuleNameSize,
    LPSTR pszImageName,
    DWORD dwImageNameSize
    )
{
    ULONG64 Base = 0;
    ULONG Index = 0;
    HRESULT hr;

    hr = g_ExtSymbols->GetModuleByOffset((ULONG64)pDllBase, 0, &Index, &Base);
    
    if (hr != S_OK) {

        dprintf("GetModuleByOffset returned %08x for dll base %08x\n", hr, pDllBase);
        return hr;
    }

    if (Base) {

        hr = GetDllNamesByIndexAndBase(
            Index, 
            Base,
            pszModuleName,
            dwModuleNameSize,
            pszImageName, 
            dwImageNameSize);
    } else {

        dprintf("GetModuleByOffset succeeded but couldn't get the base address?!\n");
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT
GetDllImageNameByModuleName(
    PCSTR pszModuleName, // dll name withOUT extension
    PSTR pszImageName,
    DWORD dwImageNameSize
    )
{
    ULONG64 Base = 0;
    ULONG Index = 0;
    HRESULT hr;

    hr = g_ExtSymbols->GetModuleByModuleName(pszModuleName, 0, &Index, &Base);
    
    if (hr != S_OK) {

        dprintf("GetModuleByModuleName returned %08x for dll %s\n", hr, pszModuleName);
        return hr;
    }

    if (Base) {

        hr = GetDllNamesByIndexAndBase(
            Index, 
            Base,
            NULL,
            0,
            pszImageName, 
            dwImageNameSize);

        //dprintf("the image name is %s, the size is %d\n", pszImageName, dwImageNameSize);

    } else {

        dprintf("GetModuleByModuleName succeeded but couldn't get the base address?!\n");
        hr = E_UNEXPECTED;
    }

    return hr;
}

/*++

  Function Description:

    Prints out the names of the shims applied to this process.

  History:

    03/12/2002 maonis Created

--*/
DECLARE_API( shimnames )
{
    ULONG64 Value, CurrentShimInfo;
    DWORD  dwShimsCount = 0;
    DWORD dwShimInfoSize = 0;
    DWORD i;
    ULONG64 pDllBase; 
    DWORD dwHookedAPIs;
    char szShimDllName[MAX_SHIM_DLL_BASE_NAME_LEN];
    WCHAR wszShimName[MAX_SHIM_NAME_LEN];

    INIT_API();

    if (!IsShimInitialized()) {
        goto EXIT;
    }
    
    if (!GetVarValueULONG64("shimeng!g_dwShimsCount", &Value)) {
        dprintf("failed to get the number of shims applied to this process\n");
        goto EXIT;
    }

    //
    // The last entry is shimeng.dll which hooks getprocaddress, we don't need
    // to show this to the user.
    //
    dwShimsCount = (DWORD)Value - 1;

    dprintf("there are %d shim(s) applied to this process\n", dwShimsCount);

    //
    // Read the name of the shims.
    //
    if (!GetVarValueULONG64("shimeng!g_pShimInfo", &Value)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    CurrentShimInfo = Value;

    dwShimInfoSize = GetTypeSize("shimeng!tagSHIMINFO");

    dprintf(" #\t%-64s%-16s%-16s\n",
        "shim name",
        "shim dll",
        "# of hooks");

    for (i = 0; i < dwShimsCount; ++i) {

        GET_AND_CHECK_FIELDVALUE(
            CurrentShimInfo, 
            "shimeng!tagSHIMINFO", 
            "pDllBase", 
            pDllBase);

        if (GetDllNameByOffset(
                (PVOID)pDllBase, 
                szShimDllName, 
                sizeof(szShimDllName),
                NULL,
                0) != S_OK) {

            goto EXIT;
        }

        GET_SHIMINFO_wszName(CurrentShimInfo, wszShimName);

        GET_AND_CHECK_FIELDVALUE(
            CurrentShimInfo, 
            "shimeng!tagSHIMINFO", 
            "dwHookedAPIs", 
            dwHookedAPIs);

        dprintf("%2d\t%-64S%-16s%-16d\n\n", 
            i + 1, 
            wszShimName, 
            szShimDllName,
            dwHookedAPIs);

        CurrentShimInfo += dwShimInfoSize;
    }

EXIT:

    EXIT_API();

    return S_OK;
}

/*++

  Function Description:

    Given the value of an enum var, prints out the name of that enum value.
    
    eg:

    enum TEST {TEST0, TEST1, TEST2};

    given 0 we'll print out " ( TEST0 )".
    
--*/
void
PrintEnumVarName(
    LPCSTR pszEnumTypeName,
    ULONG ulValueOfEnum
    )
{
    ULONG64 Module;
    ULONG   ulTypeId;
    CHAR    szName[32];
    HRESULT hr;
    
    hr    = g_ExtSymbols->GetSymbolTypeId(pszEnumTypeName, &ulTypeId, &Module);

    if (hr != S_OK) {
        dprintf("GetSymbolTypeId returned %08x for %s\n", hr, pszEnumTypeName);
        return;
    }
    
    hr = g_ExtSymbols->GetConstantName(Module, ulTypeId, ulValueOfEnum, szName, MAX_PATH, NULL);
    
    if (hr != S_OK) {
        dprintf("GetConstantName failed to get the name of value %d\n", ulValueOfEnum);
        return;
    }

    dprintf(" ( %s )", szName);
}

/*++

  Function Description:

    IN OUT ppszArgs - beginning of the arguments. Upon return this is advanced to pass
                      an argument X (using ' ' as the delimiter).
    OUT pszArg - Upon return this points to the beginning of X.

  History:

    03/26/2002 maonis Created

--*/
BOOL 
GetArg(
    PCSTR* ppszArgs,
    PCSTR* ppszArg
    )
{
    BOOL bIsSuccess = FALSE;

    PCSTR pszArgs = *ppszArgs;

    while (*pszArgs && *pszArgs == ' ') {
        ++pszArgs;
    }

    if (!*pszArgs) {    
        goto EXIT;
    }

    *ppszArg = pszArgs;

    while (*pszArgs && *pszArgs != ' ') {
        ++pszArgs;
    }

    *ppszArgs = pszArgs;
    bIsSuccess = TRUE;

EXIT:

    return bIsSuccess;
}

DECLARE_API( debuglevel )
{
    ULONG64 DebugLevel;

    INIT_API();

    if (!GetExpressionEx(args, &DebugLevel, NULL)) {

        //
        // If there's no args, we print out the current debug level.
        //
        if (GetVarValueULONG64("shimeng!g_DebugLevel", &DebugLevel)) {
            dprintf("The current debug level is %d", DebugLevel);
            PrintEnumVarName("shimeng!DEBUGLEVEL", (ULONG)DebugLevel);
            dprintf("\n");
        } else {
            dprintf("Can't find shimeng!g_DebugLevel\n");
        }

        goto EXIT;
    }

    if (!DebugLevel) {
        if (SetVarValueULONG64("shimeng!g_bDbgPrintEnabled", 0)) {
            dprintf("Disabled debug spew\n");
        } else {
            dprintf("Failed to set shimeng!g_bDbgPrintEnabled to FALSE\n");
        }

        goto EXIT;
    }

    if (DebugLevel > 0) {
        if (!SetVarValueULONG64("shimeng!g_bDbgPrintEnabled", 1)) {
            dprintf("Failed to set shimeng!g_bDbgPrintEnabled to TRUE\n");
            goto EXIT;
        }
    }

    if (SetVarValueULONG64("shimeng!g_DebugLevel", DebugLevel)) {

        dprintf("Debug level changed to %d", DebugLevel);
        PrintEnumVarName("shimeng!DEBUGLEVEL", (ULONG)DebugLevel);
        dprintf("\n");
    } else {

        dprintf("Failed to change the debug level\n");
    }

EXIT:

    EXIT_API();

    return S_OK;
}

BOOL
GetAllShimDllNames()
{
    ULONG64 Value, CurrentShimInfo;
    DWORD   dwShimsCount = 0;
    DWORD   i, j, dwShimInfoSize;
    ULONG64 pDllBase;
    BOOL    bIsSuccess = FALSE;

    g_dwShimDlls = 0;

    if (!GetVarValueULONG64("shimeng!g_dwShimsCount", &Value)) {
        dprintf("failed to get the number of shims applied to this process\n");
        goto EXIT;
    }

    //
    // The last entry is shimeng.dll which hooks getprocaddress, we don't need
    // to show this to the user.
    //
    dwShimsCount = (DWORD)Value - 1;

    if (!GetVarValueULONG64("shimeng!g_pShimInfo", &Value)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    CurrentShimInfo = Value;

    dwShimInfoSize = GetTypeSize("shimeng!tagSHIMINFO");

    for (i = 0; i < dwShimsCount; ++i) {

        GET_AND_CHECK_FIELDVALUE(
            CurrentShimInfo, 
            "shimeng!tagSHIMINFO", 
            "pDllBase", 
            pDllBase);

        //
        // Check if we've seen this dll yet.
        //
        for (j = 0; j < g_dwShimDlls; ++j)
        {
            if (g_rgShimDllNames[j].pDllBase == pDllBase) {
                goto NextShim;
            }
        }

        char szShimDllBaseName[MAX_SHIM_DLL_BASE_NAME_LEN];
        if (SUCCEEDED(
            GetDllNameByOffset(
                (PVOID)pDllBase, 
                szShimDllBaseName, 
                sizeof(szShimDllBaseName),
                NULL,
                0))) {

            if (g_dwShimDlls >= MAX_SHIM_DLLS) {
                dprintf("%d shim dlls? too many\n", g_dwShimDlls);
            } else {

                g_rgShimDllNames[g_dwShimDlls].pDllBase = pDllBase;

                StringCchCopy(
                    g_rgShimDllNames[g_dwShimDlls++].szDllBaseName, 
                    MAX_SHIM_DLL_BASE_NAME_LEN, 
                    szShimDllBaseName);
            }
        } else {
            goto EXIT;
        }

NextShim:

        CurrentShimInfo += dwShimInfoSize;
    }

    bIsSuccess = TRUE;

EXIT:

    if (!bIsSuccess) {
        dprintf("Failed to get the debug level symbols for all loaded shim dlls\n");
    }

    return bIsSuccess;
}

enum SHIM_DEBUG_LEVEL_MODE {
    PRINT_SHIM_DEBUG_LEVEL,
    CHANGE_SHIM_DEBUG_LEVEL
};

void 
ProcessShimDllDebugLevel(
    PCSTR pszDllBaseName,
    SHIM_DEBUG_LEVEL_MODE eShimDebugLevelMode,
    ULONG64 DebugLevel
    )
{
    char szDebugLevelSymbol[MAX_SHIM_DEBUGLEVEL_SYMBOL_LEN];
    char szDebugLevelType[MAX_SHIM_DEBUGLEVEL_SYMBOL_LEN];

    StringCchCopy(
        szDebugLevelSymbol, 
        MAX_SHIM_DEBUGLEVEL_SYMBOL_LEN, 
        pszDllBaseName);

    StringCchCat(
        szDebugLevelSymbol, 
        MAX_SHIM_DEBUGLEVEL_SYMBOL_LEN, 
        SHIM_DEBUG_LEVEL_SYMBOL_SUFFIX);

    StringCchCopy(
        szDebugLevelType, 
        MAX_SHIM_DEBUGLEVEL_SYMBOL_LEN, 
        pszDllBaseName);

    StringCchCat(
        szDebugLevelType, 
        MAX_SHIM_DEBUGLEVEL_SYMBOL_LEN, 
        SHIM_DEBUG_LEVEL_TYPE_SUFFIX);

    if (eShimDebugLevelMode == PRINT_SHIM_DEBUG_LEVEL) {

        ULONG64 DebugLevelTemp;

        if (GetVarValueULONG64(szDebugLevelSymbol, &DebugLevelTemp)) {
            dprintf("The debug level for %s.dll is %d", pszDllBaseName, DebugLevelTemp);
            PrintEnumVarName(szDebugLevelType, (ULONG)DebugLevelTemp);
            dprintf("\n");
        } else {
            dprintf("Failed to get the value of %s\n", szDebugLevelSymbol);
        }

    } else if (eShimDebugLevelMode == CHANGE_SHIM_DEBUG_LEVEL) {

        if (SetVarValueULONG64(szDebugLevelSymbol, DebugLevel)) {
            dprintf(
                "Changed the debug level for %s.dll to %d", 
                pszDllBaseName,
                DebugLevel);
            PrintEnumVarName(szDebugLevelType, (ULONG)DebugLevel);
            dprintf("\n");
        } else {
            dprintf("Failed to set %s to %d\n", szDebugLevelSymbol, DebugLevel);
        } 

    } else {
        dprintf("%d is an invalid arg to ProcessShimDllDebugLevel\n", eShimDebugLevelMode);
    }
}

void
PrintAllShimsDebugLevel()
{
    for (DWORD i = 0; i < g_dwShimDlls; ++i) {
        ProcessShimDllDebugLevel(
            g_rgShimDllNames[i].szDllBaseName, 
            PRINT_SHIM_DEBUG_LEVEL,
            0);
    }
}

void 
ChangeAllShimsDebugLevel(
    ULONG64 DebugLevel)
{
    for (DWORD i = 0; i < g_dwShimDlls; ++i) {
        ProcessShimDllDebugLevel(
            g_rgShimDllNames[i].szDllBaseName, 
            CHANGE_SHIM_DEBUG_LEVEL,
            DebugLevel);
    }
}

DECLARE_API( sdebuglevel )
{
    ULONG64 DebugLevel;
    char szDllBaseName[MAX_SHIM_DLL_BASE_NAME_LEN];
    char szDebugLevel[2];
    PCSTR pszArg;

    INIT_API();

    if (!IsShimInitialized()) {
        goto EXIT;
    }

    if (!GetAllShimDllNames()) {
        goto EXIT;
    }

    //
    // Get the dll name.
    //
    if (!GetArg(&args, &pszArg)) {
        PrintAllShimsDebugLevel();
        goto EXIT;
    }

    if (isdigit(*pszArg) && ((args - pszArg) == 1)) {
        szDebugLevel[0] = *pszArg;
        szDebugLevel[1] = 0;
        DebugLevel = (ULONG64)atol(szDebugLevel);
        ChangeAllShimsDebugLevel(DebugLevel);
        goto EXIT;
    }

    //
    // If we get here it means we have a dll base name.
    //
    StringCchCopyN(szDllBaseName, MAX_SHIM_DLL_BASE_NAME_LEN, pszArg, args - pszArg);

    for (DWORD i = 0; i < g_dwShimDlls; ++i)
    {
        if (!_stricmp(szDllBaseName, g_rgShimDllNames[i].szDllBaseName)) {

            if (GetArg(&args, &pszArg)) {
                if (isdigit(*pszArg) && ((args - pszArg) == 1)) {
                    szDebugLevel[0] = *pszArg;
                    szDebugLevel[1] = 0;
                    DebugLevel = (ULONG64)atol(szDebugLevel);

                    ProcessShimDllDebugLevel(
                        szDllBaseName, 
                        CHANGE_SHIM_DEBUG_LEVEL, 
                        DebugLevel);
                } else {
                    dprintf("You specified an invalid debug level value\n");
                }
            } else {
                ProcessShimDllDebugLevel(
                    szDllBaseName,
                    PRINT_SHIM_DEBUG_LEVEL,
                    0);
            }

            goto EXIT;
        }
    }

    if (i == g_dwShimDlls) {
        dprintf("%s.dll is not loaded\n", szDllBaseName);
    }

EXIT:

    EXIT_API();

    return S_OK;
}

DECLARE_API( loadshims )
{
    INIT_API();

    if (GetExpression("shimeng!SeiInit")) {

        g_ExtControl->Execute(
            DEBUG_OUTCTL_IGNORE,
            "g shimeng!SeiInit;g@$ra", // stop right after SeiInit is executed.
            DEBUG_EXECUTE_DEFAULT);
    } else {

        dprintf("wrong symbols for shimeng.dll - is shimeng.dll even loaded?\n");
    }

    EXIT_API();

    return S_OK;
}

/*++

  Function Decription:

    Given a HOOKAPI pointer pHook, this gets you pHook->pHookEx->pNext.

  History:

    03/20/2002 maonis Created

--*/
BOOL
GetNextHook(
    ULONG64 Hook, 
    PULONG64 pNextHook
    )
{
    BOOL bIsSuccess = FALSE;
    ULONG64 HookEx;
    ULONG64 NextHook;

    GET_AND_CHECK_FIELDVALUE(Hook, "shimeng!tagHOOKAPI", "pHookEx", HookEx);    
    GET_AND_CHECK_FIELDVALUE(HookEx, "shimeng!tagHOOKAPIEX", "pNext", NextHook);

    *pNextHook = NextHook;

    bIsSuccess = TRUE;

EXIT:

    return bIsSuccess;
}

DECLARE_API( displaychain )
{
    ULONG64 Value;
    ULONG64 CurrentHookAPIArray;
    ULONG64 CurrentHookAPI;
    ULONG64 CurrentShimInfo;
    ULONG64 Hook;
    ULONG64 NextHook;
    ULONG64 HookEx;
    ULONG64 HookAddress;
    ULONG64 PfnNew;
    ULONG64 PfnOld;
    ULONG64 TopOfChain;
    DWORD i, j;
    DWORD dwHookAPISize;
    DWORD dwShimInfoSize;
    DWORD dwHookedAPIs;
    DWORD dwShimsCount;

    INIT_API();

    if (!IsShimInitialized()) {
        goto EXIT;
    }

    if (!GetExpressionEx(args, &HookAddress, NULL)) {
        dprintf("Usage: !displaychain address_to_check\n");
        goto EXIT;
    }

    if (!GetVarValueULONG64("shimeng!g_dwShimsCount", &Value)) {
        dprintf("failed to get the number of shims applied to this process\n");
        goto EXIT;
    }

    dwShimsCount = (DWORD)Value - 1;

    if (!GetVarValueULONG64("shimeng!g_pShimInfo", &Value)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    CurrentShimInfo = Value;

    dwShimInfoSize = GetTypeSize("shimeng!tagSHIMINFO");

    dwHookAPISize = GetTypeSize("shimeng!tagHOOKAPI");
    
    if (!dwHookAPISize) {

        dprintf("failed to get the HOOKAPI size\n");
        goto EXIT;
    }

    if (!GetVarValueULONG64("shimeng!g_pHookArray", &Value)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    CurrentHookAPIArray = Value;

    for (i = 0; i < dwShimsCount; ++i) {

        //
        // Get the number of hooks this shim has.
        //
        if (GetFieldValue(CurrentShimInfo, "shimeng!tagSHIMINFO", "dwHookedAPIs", dwHookedAPIs)) {

            dprintf("failed to get the number of hooked APIs for shim #%d\n",
                i);

            goto EXIT;
        }

        if (!ReadPointer(CurrentHookAPIArray, &CurrentHookAPI)) {
            dprintf("failed to get the begining of hook api array\n");

            goto EXIT;
        }

        for (j = 0; j < dwHookedAPIs; ++j) {

            GET_AND_CHECK_FIELDVALUE(CurrentHookAPI, "shimeng!tagHOOKAPI", "pfnNew", PfnNew);

            if (HookAddress == PfnNew) {

                //
                // We found the address, now get top of the chain so we can print it.
                //
                GET_AND_CHECK_FIELDVALUE(CurrentHookAPI, "shimeng!tagHOOKAPI", "pHookEx", HookEx);
                GET_AND_CHECK_FIELDVALUE(HookEx, "shimeng!tagHOOKAPIEX", "pTopOfChain", TopOfChain);

                //dprintf("top of chain is %08x\n", TopOfChain);

                Hook = TopOfChain;

                GET_AND_CHECK_FIELDVALUE(Hook, "shimeng!tagHOOKAPI", "pfnNew", PfnNew);

                dprintf("    %08x", PfnNew);

                PrintSymbolAtAddress(PfnNew);
                dprintf("\n");

                while (TRUE) {

                    if (!GetNextHook(Hook, &NextHook)) {
                        dprintf("failed to get next hook\n");
                        goto EXIT;
                    }

                    if (!NextHook) {

                        //
                        // We are at the end of the chain, get the original API address.
                        //
                        GET_AND_CHECK_FIELDVALUE(Hook, "shimeng!tagHOOKAPI", "pfnOld", PfnOld);
                        dprintf(" -> %08x", PfnOld);
                        PrintSymbolAtAddress(PfnOld);
                        dprintf("\n");

                        break;
                    }

                    Hook = NextHook;

                    if (Hook) {

                        GET_AND_CHECK_FIELDVALUE(Hook, "shimeng!tagHOOKAPI", "pfnNew", PfnNew);
                        dprintf(" -> %08x", PfnNew);
                        PrintSymbolAtAddress(PfnNew);
                        dprintf("\n");
                    }
                }

                dprintf("\n");

                goto EXIT;
            }

            CurrentHookAPI += dwHookAPISize;
        }

        CurrentShimInfo += dwShimInfoSize;
        CurrentHookAPIArray += sizeof(ULONG_PTR);
    }

EXIT:

    EXIT_API();

    return S_OK;
}

BOOL
CheckSymbols(
    LPCSTR pszSymbolName
    )
{
    ULONG64 Value;
    HRESULT hr = g_ExtSymbols->GetOffsetByName(pszSymbolName, &Value);

    return (hr == S_OK);
}

#define CHECKSYM(s) if (!CheckSymbols(s)) bIsSymbolGood = FALSE; goto EXIT;
#define CHECKTYPE(t) if (!GetTypeSize(t)) bIsSymbolGood = FALSE; goto EXIT;

DECLARE_API ( shimengsym ) 
{
    INIT_API();

    BOOL bIsSymbolGood = TRUE;

    //
    // Check a few important structures and stuff.
    //
    CHECKSYM("shimeng!SeiInit");
    CHECKSYM("shimeng!g_pHookArray");
    CHECKSYM("shimeng!g_pShiminfo");
    CHECKSYM("shimeng!g_dwShimsCount");
    CHECKTYPE("shimeng!tagHOOKAPI");
    CHECKTYPE("shimeng!tagSHIMINFO");

EXIT:

    EXIT_API();

    if (bIsSymbolGood) {
        dprintf("shimeng symbols look good\n");
    } else {
        dprintf("You have wrong symbols for shimeng\n");
    }

    return S_OK;
}

DECLARE_API ( displayhooks )
{
    ULONG64 Value;
    ULONG64 CurrentHookAPIArray;
    ULONG64 CurrentHookAPI;
    ULONG64 CurrentShimInfo;
    ULONG64 FunctionName;
    ULONG64 ModuleName;
    ULONG64 ShimName;
    ULONG64 PfnNew;
    DWORD i, j;
    DWORD dwHookAPISize;
    DWORD dwShimInfoSize;
    DWORD dwHookedAPIs;
    DWORD dwShimsCount;
    DWORD dwBytesRead;
    char szAPIName[MAX_API_NAME_LEN];
    char szModuleName[MAX_MODULE_NAME_LEN];
    WCHAR wszShimName[MAX_SHIM_NAME_LEN];
    char szShimName[MAX_SHIM_NAME_LEN];
    LPCSTR pszShimName = args;

    INIT_API();    

    if (!IsShimInitialized()) {
        goto EXIT;
    }

    if (!pszShimName || !*pszShimName) {

        dprintf("Usage: !displayhooks shimname\n");
        goto EXIT;
    }

    if (!GetVarValueULONG64("shimeng!g_dwShimsCount", &Value)) {
        dprintf("failed to get the number of shims applied to this process\n");
        goto EXIT;
    }

    dwShimsCount = (DWORD)Value - 1;

    if (!GetVarValueULONG64("shimeng!g_pShimInfo", &Value)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    CurrentShimInfo = Value;

    dwShimInfoSize = GetTypeSize("shimeng!tagSHIMINFO");

    dwHookAPISize = GetTypeSize("shimeng!tagHOOKAPI");
    
    if (!dwHookAPISize) {

        dprintf("failed to get the HOOKAPI size\n");
        goto EXIT;
    }

    if (!GetVarValueULONG64("shimeng!g_pHookArray", &Value)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    CurrentHookAPIArray = Value;

    dprintf("%-8s%-32s%-16s  %8s\n",
        "hook #",
        "hook name",
        "dll it's in",
        "new addr");
    
    for (i = 0; i < dwShimsCount; ++i) {

        //
        // Get the shim name.
        //
        if (GetFieldValue(CurrentShimInfo, "shimeng!tagSHIMINFO", "wszName", wszShimName)) {

            dprintf("failed to get the shim name address for shim #%d\n",
                i);

            goto EXIT;
        }

        if (!WideCharToMultiByte(CP_ACP, 0, wszShimName, -1, szShimName, MAX_SHIM_NAME_LEN, NULL, NULL)) {
            dprintf("failed to convert %S to ansi: %d\n", wszShimName, GetLastError());
            goto EXIT;
        }

        if (lstrcmpi(szShimName, pszShimName)) {
            goto TryNext;
        }

        //
        // Get the number of hooks this shim has.
        //
        if (GetFieldValue(CurrentShimInfo, "shimeng!tagSHIMINFO", "dwHookedAPIs", dwHookedAPIs)) {

            dprintf("failed to get the number of hooked APIs for shim #%d\n",
                i);

            goto EXIT;
        }

        if (!ReadPointer(CurrentHookAPIArray, &CurrentHookAPI)) {
            dprintf("failed to get the begining of hook api array\n");

            goto EXIT;
        }

        for (j = 0; j < dwHookedAPIs; ++j) {

            GET_AND_CHECK_FIELDVALUE(CurrentHookAPI, "shimeng!tagHOOKAPI", "pszFunctionName", FunctionName);

            if (!GetData(FunctionName, szAPIName, MAX_API_NAME_LEN)) {
                dprintf("failed to read in the API name at %08x\n", FunctionName);
                goto EXIT;
            }

            GET_AND_CHECK_FIELDVALUE(CurrentHookAPI, "shimeng!tagHOOKAPI", "pszModule", ModuleName);

            if (!GetData(ModuleName, szModuleName, MAX_MODULE_NAME_LEN)) {
                dprintf("failed to read in the module name at %08x\n", ModuleName);
                goto EXIT;
            }

            GET_AND_CHECK_FIELDVALUE(CurrentHookAPI, "shimeng!tagHOOKAPI", "pfnNew", PfnNew);

            dprintf("%-8d%-32s%-16s  %08x\n",
                j + 1,
                szAPIName,
                szModuleName,
                PfnNew);

            CurrentHookAPI += dwHookAPISize;
        }

TryNext:

        CurrentShimInfo += dwShimInfoSize;
        CurrentHookAPIArray += sizeof(ULONG_PTR);
    }

EXIT:

    EXIT_API();

    return S_OK;
}

/*++

  Function Description:

    This is a helper function for IsExcluded.

  History:

    03/26/2002 maonis Created

--*/
BOOL
GetModuleNameAndAPIAddress(
    IN     ULONG64  pHook,
    OUT    ULONG64* pFunctionAddress,
    IN OUT LPSTR    szModuleName
    )
{
    BOOL bIsSuccess = FALSE;
    ULONG64 FunctionAddress;

    GET_AND_CHECK_FIELDVALUE(
        pHook, 
        "shimeng!tagHOOKAPI", 
        "pszFunctionName", 
        FunctionAddress);

    GET_AND_CHECK_FIELDVALUE_DATA(
        pHook, 
        "shimeng!tagHOOKAPI", 
        "pszModule", 
        szModuleName,
        MAX_MODULE_NAME_LEN);

    *pFunctionAddress = FunctionAddress;
    bIsSuccess = TRUE;

EXIT:

    return bIsSuccess;
}

/*++
  
  Function Description:

    This is modified from the SeiIsExcluded function in 
    %sdxroot%\windows\appcompat\shimengines\engiat\shimeng.c

--*/
BOOL
IsExcluded(
    IN  LPCSTR   pszModule,     // The module to test for exclusion.
    IN  ULONG64  pTopHookAPI,   // The HOOKAPI for which we test for exclusion.
    IN  BOOL     bInSystem32    // Whether the module is located in the System32 directory.
    )
{
    BOOL     bExclude = TRUE;
    BOOL     bShimWantsToExclude = FALSE; // was there a shim that wanted to exclude?
    ULONG64  pHook = pTopHookAPI;
    ULONG64  pHookEx;
    ULONG64  pShimInfo, pCurrentShimInfo;
    ULONG64  pIncludeMod;
    ULONG64  pExcludeMod;
    ULONG64  eInExMode;
    ULONG64  ModuleName;
    ULONG64  FunctionName;
    ULONG64  Temp;
    DWORD    dwCounter;
    char     szCurrentModuleName[MAX_MODULE_NAME_LEN];
    char     szCurrentAPIName[MAX_API_NAME_LEN];
    WCHAR    wszName[MAX_SHIM_NAME_LEN];
    DWORD    dwShimInfoSize = GetTypeSize("shimeng!tagSHIMINFO");

    if (!GetVarValueULONG64("shimeng!g_pShimInfo", &pShimInfo)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    //
    // The current process is to only exclude a chain if every shim in the chain wants to
    // exclude. If one shim needs to be included, the whole chain is included.
    //
    while (pHook) {

        GET_AND_CHECK_FIELDVALUE(pHook, "shimeng!tagHOOKAPI", "pHookEx", pHookEx);

        if (!pHookEx) {
            break;
        }

        GET_AND_CHECK_FIELDVALUE(pHookEx, "shimeng!tagHOOKAPIEX", "dwShimID", dwCounter);

        //if (!GetData(pShimInfo + dwShimInfoSize * dwCounter, &si, dwShimInfoSize)) {
        //    dprintf("Failed to get the shiminfo for shim #%d\n", dwCounter + 1);
        //    goto EXIT;
        //}

        pCurrentShimInfo = pShimInfo + dwShimInfoSize * dwCounter;

        GET_SHIMINFO_eInExMode(pCurrentShimInfo, eInExMode);
        GET_SHIMINFO_wszName(pCurrentShimInfo, wszName);

        switch (eInExMode) {
        case INCLUDE_ALL:
        {
            //
            // We include everything except what's in the exclude list.
            //
            GET_SHIMINFO_pFirstExclude(pCurrentShimInfo, pExcludeMod);

            while (pExcludeMod != NULL) {

                GET_AND_CHECK_FIELDVALUE_DATA(
                    pExcludeMod, 
                    "shimeng!tagINEXMOD", 
                    "pszModule", 
                    szCurrentModuleName,
                    MAX_MODULE_NAME_LEN);

                if (lstrcmpi(szCurrentModuleName, pszModule) == 0) {

                    if (!GetModuleNameAndAPIAddress(pTopHookAPI, &FunctionName, szCurrentModuleName)) {
                        goto EXIT;
                    }

                    if ((ULONG_PTR)FunctionName < 0x0000FFFF) {
                        dprintf(
                            "Module \"%s\" excluded for shim %S, API \"%s!#%d\","
                            "because it is in the exclude list (MODE: IA).\n",
                            pszModule,
                            wszName,
                            szCurrentModuleName,
                            FunctionName);
                    } else {

                        GET_AND_CHECK_DATA(FunctionName, szCurrentAPIName, MAX_API_NAME_LEN);

                        dprintf(
                            "Module \"%s\" excluded for shim %S, API \"%s!%s\","
                            "because it is in the exclude list (MODE: IA).\n",
                            pszModule,
                            wszName,
                            szCurrentModuleName,
                            szCurrentAPIName);
                    }

                    //
                    // this wants to be excluded, so we go to the next
                    // shim, and see if it wants to be included
                    //
                    bShimWantsToExclude = TRUE;
                    goto nextShim;
                }
                
                Temp = pExcludeMod;
                GET_AND_CHECK_FIELDVALUE(Temp, "shimeng!tagINEXMOD", "pNext", pExcludeMod);
            }

            //
            // we should include this shim, and therefore, the whole chain
            //
            bExclude = FALSE;
            goto EXIT;
            break;
        }

        case EXCLUDE_SYSTEM32:
        {
            //
            // In this case, we first check the include list,
            // then exclude it if it's in System32, then exclude it if
            // it's in the exclude list.
            //
            GET_SHIMINFO_pFirstInclude(pCurrentShimInfo, pIncludeMod);
            GET_SHIMINFO_pFirstExclude(pCurrentShimInfo, pExcludeMod);

            //
            // First, check the include list.
            //
            while (pIncludeMod != NULL) {

                GET_AND_CHECK_FIELDVALUE_DATA(
                    pIncludeMod, 
                    "shimeng!tagINEXMOD", 
                    "pszModule", 
                    szCurrentModuleName,
                    MAX_MODULE_NAME_LEN);

                if (lstrcmpi(szCurrentModuleName, pszModule) == 0) {

                    //
                    // we should include this shim, and therefore, the whole chain
                    //
                    bExclude = FALSE;
                    goto EXIT;
                }

                Temp = pIncludeMod;
                GET_AND_CHECK_FIELDVALUE(Temp, "shimeng!tagINEXMOD", "pNext", pIncludeMod);
            }

            //
            // it wasn't in the include list, so is it in System32?
            //
            if (bInSystem32) {

                if (!GetModuleNameAndAPIAddress(pTopHookAPI, &FunctionName, szCurrentModuleName)) {
                    goto EXIT;
                }

                if ((ULONG_PTR)FunctionName < 0x0000FFFF) {
                    dprintf(
                        "module \"%s\" excluded for shim %S, API \"%s!#%d\", because it is in System32.\n",
                        pszModule,
                        wszName,
                        szCurrentModuleName,
                        FunctionName);
                } else {

                    GET_AND_CHECK_DATA(FunctionName, szCurrentAPIName, MAX_API_NAME_LEN);

                    dprintf(
                        "module \"%s\" excluded for shim %S, API \"%s!%s\", because it is in System32.\n",
                        pszModule,
                        wszName,
                        szCurrentModuleName,
                        szCurrentAPIName);
                }

                //
                // this wants to be excluded, so we go to the next
                // shim, and see if it wants to be included
                //
                bShimWantsToExclude = TRUE;
                goto nextShim;
            }

            //
            // it wasn't in System32, so is it in the exclude list?
            //
            while (pExcludeMod != NULL) {

                if (!GetModuleNameAndAPIAddress(pTopHookAPI, &FunctionName, szCurrentModuleName)) {
                    goto EXIT;
                }

                GET_AND_CHECK_FIELDVALUE_DATA(
                    pExcludeMod, 
                    "shimeng!tagINEXMOD", 
                    "pszModule", 
                    szCurrentModuleName,
                    MAX_MODULE_NAME_LEN);

                if (lstrcmpi(szCurrentModuleName, pszModule) == 0) {
                    if ((ULONG_PTR)FunctionName < 0x0000FFFF) {
                        dprintf(
                            "module \"%s\" excluded for shim %S, API \"%s!#%d\", because it is in the exclude list (MODE: ES).\n",
                            pszModule,
                            wszName,
                            szCurrentModuleName,
                            FunctionName);
                    } else {

                        GET_AND_CHECK_DATA(FunctionName, szCurrentAPIName, MAX_API_NAME_LEN);

                        dprintf(
                            "module \"%s\" excluded for shim %S, API \"%s!%s\", because it is in the exclude list (MODE: ES).\n",
                            pszModule,
                            wszName,
                            szCurrentModuleName,
                            szCurrentAPIName);
                    }

                    //
                    // this wants to be excluded, so we go to the next
                    // shim, and see if it wants to be included
                    //
                    bShimWantsToExclude = TRUE;
                    goto nextShim;
                }

                Temp = pExcludeMod;
                GET_AND_CHECK_FIELDVALUE(Temp, "shimeng!tagINEXMOD", "pNext", pExcludeMod);
            }

            //
            // we should include this shim, and therefore, the whole chain
            //
            bExclude = FALSE;
            goto EXIT;
            break;
        }

        case EXCLUDE_ALL:
        {
            //
            // We exclude everything except what is in the include list.
            //
            GET_SHIMINFO_pFirstInclude(pCurrentShimInfo, pIncludeMod);

            while (pIncludeMod != NULL) {

                GET_AND_CHECK_FIELDVALUE_DATA(
                    pIncludeMod, 
                    "shimeng!tagINEXMOD", 
                    "pszModule", 
                    szCurrentModuleName,
                    MAX_MODULE_NAME_LEN);

                if (lstrcmpi(szCurrentModuleName, pszModule) == 0) {
                    //
                    // we should include this shim, and therefore, the whole chain
                    //
                    bExclude = FALSE;
                    goto EXIT;
                }

                Temp = pIncludeMod;
                GET_AND_CHECK_FIELDVALUE(Temp, "shimeng!tagINEXMOD", "pNext", pIncludeMod);
            }

            if (!GetModuleNameAndAPIAddress(pTopHookAPI, &FunctionName, szCurrentModuleName)) {
                goto EXIT;
            }

            if ((ULONG_PTR)FunctionName < 0x0000FFFF) {
                dprintf(
                    "module \"%s\" excluded for shim %S, API \"%s!#%d\", because it is not in the include list (MODE: EA).\n",
                    pszModule,
                    wszName,
                    szCurrentModuleName,
                    FunctionName);
            } else {

                GET_AND_CHECK_DATA(FunctionName, szCurrentAPIName, MAX_API_NAME_LEN);

                dprintf(
                    "module \"%s\" excluded for shim %S, API \"%s!%s\", because it is not in the include list (MODE: EA).\n",
                    pszModule,
                    wszName,
                    szCurrentModuleName,
                    szCurrentAPIName);
            }

            //
            // this wants to be excluded, so we go to the next
            // shim, and see if it wants to be included
            //
            bShimWantsToExclude = TRUE;
            goto nextShim;
            break;
        }
        }

nextShim:

        Temp = pHook;
        if (!GetNextHook(Temp, &pHook)) {
            dprintf("failed to get next hook\n");
            goto EXIT;
        }
    }

EXIT:
    if (!bExclude && bShimWantsToExclude) {

        if (GetModuleNameAndAPIAddress(pTopHookAPI, &FunctionName, szCurrentModuleName)) {
            
            if ((ULONG_PTR)FunctionName < 0x0000FFFF) {
                dprintf(
                    "Module \"%s\" mixed inclusion/exclusion for "
                    "API \"%s!#%d\". Included.\n",
                    pszModule,
                    szCurrentModuleName,
                    FunctionName);
            } else {

                GET_AND_CHECK_DATA(FunctionName, szCurrentAPIName, MAX_API_NAME_LEN);

                dprintf(
                    "Module \"%s\" mixed inclusion/exclusion for "
                    "API \"%s!%s\". Included.\n",
                    pszModule,
                    szCurrentModuleName,
                    szCurrentAPIName);
            }
        }
    }

    return bExclude;
}

/*++

  Function Decription:

    The way we get the system32 directory is just to get the loaded image name for kernel32.dll.

  History:

    03/26/2002 maonis Created

--*/
BOOL
GetSystem32Directory()
{
    if (g_dwSystem32DirLen) {
        return TRUE;
    }

    BOOL bIsSuccess = FALSE;
    char szImageName[MAX_DLL_IMAGE_NAME_LEN];
    PSTR pszBaseDllName = NULL;
    DWORD dwLen = 0;

    if (GetDllImageNameByModuleName("kernel32", szImageName, MAX_DLL_IMAGE_NAME_LEN) != S_OK) {
        dprintf("can't get the dll path for kernel32.dll!!\n");
        goto EXIT;
    }

    //
    // Get the beginning of the base dll name.
    //
    dwLen = lstrlen(szImageName) - 1;
    pszBaseDllName = szImageName + dwLen;

    while (*pszBaseDllName && *pszBaseDllName != '\\') {
        --pszBaseDllName;
    }
    
    if (!*pszBaseDllName) {
        dprintf("%s doesn't contain a full path\n", szImageName);
        goto EXIT;
    }

    ++pszBaseDllName;
    *pszBaseDllName = '\0';

    StringCchCopy(g_szSystem32Dir, MAX_DLL_IMAGE_NAME_LEN, szImageName);
    g_dwSystem32DirLen = (DWORD)(pszBaseDllName - szImageName);

    bIsSuccess = TRUE;

EXIT:

    return bIsSuccess;
}

BOOL
IsInSystem32(
    PCSTR szModuleName,
    BOOL* pbInSystem32
    )
{
    BOOL bIsSuccess = FALSE;
    char szImageName[MAX_DLL_IMAGE_NAME_LEN];

    if (!GetSystem32Directory()) {
        goto EXIT;
    }

    if (GetDllImageNameByModuleName(szModuleName, szImageName, MAX_DLL_IMAGE_NAME_LEN) != S_OK) {
        goto EXIT;
    }

    dprintf("the image name is %s\n", szImageName);

    *pbInSystem32 = !_strnicmp(g_szSystem32Dir, szImageName, g_dwSystem32DirLen);

    dprintf("%s %s in system32\n", szModuleName, (*pbInSystem32 ? "is" : "is not"));

    bIsSuccess = TRUE;

EXIT:

    return bIsSuccess;
}

/*++
  
  Function Description:

    !checkinex dllname apiname

    dllname is without the .dll extention. eg:

    !checkinex kernel32 createfilea
 
  History:

    03/26/2002 maonis Created

--*/
DECLARE_API ( checkex )
{
    ULONG64 DllName;
    char szAPIName[MAX_API_NAME_LEN];
    char szCurrentAPIName[MAX_API_NAME_LEN];
    char szModuleName[MAX_MODULE_NAME_LEN];
    PCSTR pszModuleName, pszAPIName;
    BOOL bInSystem32 = FALSE;
    ULONG64 Value;
    ULONG64 CurrentHookAPIArray;
    ULONG64 CurrentHookAPI;
    ULONG64 CurrentShimInfo;
    ULONG64 FunctionName;
    ULONG64 Hook;
    ULONG64 NextHook;
    ULONG64 HookEx;
    ULONG64 HookAddress;
    ULONG64 PfnNew;
    ULONG64 PfnOld;
    ULONG64 TopOfChain;
    DWORD i, j;
    DWORD dwHookAPISize;
    DWORD dwShimInfoSize;
    DWORD dwHookedAPIs;
    DWORD dwShimsCount;

    INIT_API();

    if (!IsShimInitialized()) {
        goto EXIT;
    }

    //
    // Get the dll name.
    //
    if (!GetArg(&args, &pszModuleName)) {
        dprintf("Usage: !checkinex dllname apiname\n");
        goto EXIT;
    }

    StringCchCopyN(szModuleName, MAX_MODULE_NAME_LEN, pszModuleName, args - pszModuleName);

    //
    // Get the API name.
    //
    if (!GetArg(&args, &pszAPIName)) {
        dprintf("Usage: !checkinex dllname apiname\n");
        goto EXIT;
    }

    StringCchCopyN(szAPIName, MAX_API_NAME_LEN, pszAPIName, args - pszAPIName);

    //
    // Check to see if it's in system32.
    //
    if (!IsInSystem32(szModuleName, &bInSystem32)) {
        dprintf("Failed to determine if %s is in system32 or not\n", szModuleName);
        goto EXIT;
    }

    //
    // Get the chain with this API.
    //
    if (!GetVarValueULONG64("shimeng!g_dwShimsCount", &Value)) {
        dprintf("failed to get the number of shims applied to this process\n");
        goto EXIT;
    }

    dwShimsCount = (DWORD)Value - 1;

    if (!GetVarValueULONG64("shimeng!g_pShimInfo", &Value)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    CurrentShimInfo = Value;

    dwShimInfoSize = GetTypeSize("shimeng!tageSHIMINFO");

    dwHookAPISize = GetTypeSize("shimeng!tagHOOKAPI");
    
    if (!dwHookAPISize) {

        dprintf("failed to get the HOOKAPI size\n");
        goto EXIT;
    }

    if (!GetVarValueULONG64("shimeng!g_pHookArray", &Value)) {
        dprintf("failed to get the address of shiminfo\n");
        goto EXIT;
    }

    CurrentHookAPIArray = Value;

    for (i = 0; i < dwShimsCount; ++i) {

        //
        // Get the number of hooks this shim has.
        //
        if (GetFieldValue(CurrentShimInfo, "shimeng!tagSHIMINFO", "dwHookedAPIs", dwHookedAPIs)) {

            dprintf("failed to get the number of hooked APIs for shim #%d\n",
                i);

            goto EXIT;
        }

        if (!ReadPointer(CurrentHookAPIArray, &CurrentHookAPI)) {
            dprintf("failed to get the begining of hook api array\n");

            goto EXIT;
        }

        for (j = 0; j < dwHookedAPIs; ++j) {

            GET_AND_CHECK_FIELDVALUE(CurrentHookAPI, "shimeng!tagHOOKAPI", "pszFunctionName", FunctionName);

            if (!GetData(FunctionName, szCurrentAPIName, MAX_API_NAME_LEN)) {
                dprintf("failed to read in the API name at %08x\n", FunctionName);
            }

            if (!lstrcmpi(szAPIName, szCurrentAPIName)) {

                //
                // We found the API, now get top of the chain.
                //
                GET_AND_CHECK_FIELDVALUE(CurrentHookAPI, "shimeng!tagHOOKAPI", "pHookEx", HookEx);
                GET_AND_CHECK_FIELDVALUE(HookEx, "shimeng!tagHOOKAPIEX", "pTopOfChain", TopOfChain);
                //dprintf("top of chain is %08x\n", TopOfChain);
                
                //
                // Found the API, now see why this API is shimmed or unshimmed.
                //
                IsExcluded(szModuleName, TopOfChain, bInSystem32);
                goto EXIT;
            }

            CurrentHookAPI += dwHookAPISize;
        }

        CurrentShimInfo += dwShimInfoSize;
        CurrentHookAPIArray += sizeof(ULONG_PTR);
    }

    dprintf("No shims are hooking API %s\n", szAPIName);

EXIT:

    EXIT_API();

    return S_OK;
}

BOOL
GetExeNameWithFullPath(
    PSTR pszExeName,
    DWORD dwExeNameSize
    )
{
    BOOL bIsSuccess = FALSE;
    HRESULT hr;

    if ((hr = g_ExtSystem->GetCurrentProcessExecutableName(
            pszExeName, 
            dwExeNameSize, 
            NULL)) == S_OK) 
    {
        if (CheckForFullPath(pszExeName)) {
            bIsSuccess = TRUE;
        }
    } else {
        dprintf("GetCurrentProcessExecutableName returned %08x\n", hr);
    }

    return bIsSuccess;
}

void
ConvertMatchModeToString(
    DWORD dwMatchMode,
    LPSTR pszMatchMode,
    DWORD dwLen
    )
{
    switch (dwMatchMode)
    {
    case MATCH_NORMAL:
        StringCchCopy(pszMatchMode, dwLen, "NORMAL");
        break;

    case MATCH_EXCLUSIVE:
        StringCchCopy(pszMatchMode, dwLen, "EXCLUSIVE");
        break;

    case MATCH_ADDITIVE:
        StringCchCopy(pszMatchMode, dwLen, "ADDITIVE");
        break;

    default:
        StringCchCopy(pszMatchMode, dwLen, "UNKNOWN");
    }
}

void
ConvertDBLocationToString(
    TAGREF trExe,
    LPSTR pszDBLocation,
    DWORD dwLen
    )
{
    switch (trExe & TAGREF_STRIP_PDB) {
    case PDB_MAIN:
        
        StringCchCopy(pszDBLocation, dwLen, "MAIN");
        break;           

    case PDB_TEST:                   

        StringCchCopy(pszDBLocation, dwLen, "TEST");
        break;                                                    

    //
    // Everything else is local.
    //
    case PDB_LOCAL:
    default:

        StringCchCopy(pszDBLocation, dwLen, "CUSTOM");
        break;
    }
}

BOOL
CheckEqualGUIDs(
    const GUID* guid1, 
    const GUID* guid2
    )
{
   return (
      ((PLONG)guid1)[0] == ((PLONG)guid2)[0] &&
      ((PLONG)guid1)[1] == ((PLONG)guid2)[1] &&
      ((PLONG)guid1)[2] == ((PLONG)guid2)[2] &&
      ((PLONG)guid1)[3] == ((PLONG)guid2)[3]);
}

void
GetDBInfo(
    PDB pdb, 
    LPWSTR pwszDBInfo, 
    DWORD dwLen
    )
{
    TAGID   tiDatabase, tiDatabaseID;
    GUID*   pGuid;
    WCHAR  wszGuid[64];
    NTSTATUS status;
    
    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == TAGID_NULL) {
        dprintf("Failed to find TAG_DATABASE\n");
        return;
    }

    tiDatabaseID = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);

    if (tiDatabaseID == TAGID_NULL) {
        dprintf("Failed to find TAG_DATABASE_ID\n");
        return;
    }

    pGuid = (GUID*)SdbGetBinaryTagData(pdb, tiDatabaseID);

    if (!pGuid) {
        dprintf("Failed to read the GUID for this Database ID %08x\n", tiDatabaseID);
        return;
    }

    if (CheckEqualGUIDs(pGuid, &GUID_SYSMAIN_SDB)) {

        StringCchCopyW(pwszDBInfo, dwLen, L"sysmain.sdb");

    } else if (CheckEqualGUIDs(pGuid, &GUID_MSIMAIN_SDB)) {

        StringCchCopyW(pwszDBInfo, dwLen, L"msimain.sdb");

    } else if (CheckEqualGUIDs(pGuid, &GUID_DRVMAIN_SDB)) {

        StringCchCopyW(pwszDBInfo, dwLen, L"drvmain.sdb");

    } else if (CheckEqualGUIDs(pGuid, &GUID_APPHELP_SDB)) {

        StringCchCopyW(pwszDBInfo, dwLen, L"apphelp.sdb");

    } else if (CheckEqualGUIDs(pGuid, &GUID_SYSTEST_SDB)) {

        StringCchCopyW(pwszDBInfo, dwLen, L"systest.sdb");

    } else {
        //
        // None of the above, so it's a custom sdb.
        // 
        SdbGUIDToString(pGuid, wszGuid, CHARCOUNT(wszGuid));
    
        StringCchCopyW(pwszDBInfo, dwLen, wszGuid);
        StringCchCatW(pwszDBInfo, dwLen, L".sdb");
    }
}

void
ShowSdbEntryInfo(
    HSDB hSDB,
    PSDBQUERYRESULT psdbQuery
    )
{
    DWORD        dw, dwMatchMode;
    TAGREF       trExe;
    PDB    pdb;
    TAGID  tiExe, tiExeID, tiAppName, tiVendor, tiMatchMode;
    GUID*  pGuidExeID;
    WCHAR wszGuid[64];
    PWSTR pwszAppName, pwszVendorName;
    char  szMatchMode[8];
    char  szDBLocation[8];
    WCHAR wszDBInfo[48];

    dprintf("%-42s%-16s%-16s%-12s%-20s\n",
        "EXE GUID",
        "App Name",
        "Vendor",
        "Match Mode",
        "Database");

    for (dw = 0; dw < SDB_MAX_EXES; dw++) {

        trExe = psdbQuery->atrExes[dw];

        if (trExe == TAGREF_NULL) {
            break;
        }

        if (!SdbTagRefToTagID(hSDB, trExe, &pdb, &tiExe) || pdb == NULL) {
            dprintf("Failed to get tag id from tag ref\n");
            return;
        }

        //
        // Get the GUID of this EXE tag.
        //
        tiExeID = SdbFindFirstTag(pdb, tiExe, TAG_EXE_ID);

        if (tiExeID == TAGID_NULL) {
            dprintf("Failed to get the name tag id\n");
            return;
        }

        pGuidExeID = (GUID*)SdbGetBinaryTagData(pdb, tiExeID);

        if (!pGuidExeID) {
            dprintf("Cannot read the ID for EXE tag 0x%x.\n", tiExe);
            return;
        }

        SdbGUIDToString(pGuidExeID, wszGuid, CHARCOUNT(wszGuid));

        //
        // Get the App Name for this Exe.
        //
        tiAppName = SdbFindFirstTag(pdb, tiExe, TAG_APP_NAME);

        if (tiAppName != TAGID_NULL) {
            pwszAppName = SdbGetStringTagPtr(pdb, tiAppName);
        }

        //
        // Get the vendor Name for this Exe.
        //
        tiVendor = SdbFindFirstTag(pdb, tiExe, TAG_VENDOR);

        if (tiVendor != TAGID_NULL) {
            pwszVendorName = SdbGetStringTagPtr(pdb, tiVendor);
        }

        tiMatchMode = SdbFindFirstTag(pdb, tiExe, TAG_MATCH_MODE);

        dwMatchMode = SdbReadWORDTag(pdb, tiMatchMode, MATCHMODE_DEFAULT_MAIN);

        ConvertMatchModeToString(dwMatchMode, szMatchMode, sizeof(szMatchMode));

        ConvertDBLocationToString(trExe, szDBLocation, sizeof(szDBLocation));

        GetDBInfo(pdb, wszDBInfo, sizeof(wszDBInfo) /sizeof(wszDBInfo[0]));
        
        dprintf("%-42S%-16S%-16S%-12s%16S (%s)\n",
            wszGuid,
            pwszAppName,
            pwszVendorName,
            szMatchMode,
            wszDBInfo,
            szDBLocation);
    }
}

LPWSTR
AnsiToUnicode(
    LPCSTR psz)
{
    LPWSTR pwsz = NULL;

    if (psz) {
        int nChars = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);

        pwsz = (LPWSTR)malloc(nChars * sizeof(WCHAR));

        if (pwsz) {
            nChars = MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, nChars);

            if (!nChars) {
                dprintf("Failed to convert %s to unicode: %d\n", psz, GetLastError());
                free(pwsz);
                pwsz = NULL;
            }
        } else {
            dprintf("Failed to allocate memory to convert %s to unicode\n", psz);
        }
    }

    return pwsz;
}

DECLARE_API ( matchmode ) 
{
    HSDB  hSDB = NULL;
    SDBQUERYRESULT sdbQuery;
    BOOL  bResult;
    char szExeName[MAX_PATH];
    LPWSTR pwszExeName = NULL;

    INIT_API();

    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        dprintf("Failed to open the shim database.\n");
        return NULL;
    }

    ZeroMemory(&sdbQuery, sizeof(SDBQUERYRESULT));

    //
    // Get the full path to the exe.
    //
    if (!GetExeNameWithFullPath(szExeName, sizeof(szExeName))) {
        dprintf("failed to get exe name\n");
        goto EXIT;
    }

    //dprintf("the exe name is %s\n", szExeName);

    pwszExeName = AnsiToUnicode(szExeName);
    
    if (!pwszExeName) {
        goto EXIT;
    }

    bResult = SdbGetMatchingExe(hSDB, pwszExeName, NULL, NULL, 0, &sdbQuery);
    
    if (!bResult) {
        dprintf("Failed to get the matching info for this process\n");
        goto EXIT;
    } else {
        ShowSdbEntryInfo(hSDB, &sdbQuery);
    }

EXIT:

    if (hSDB) {
        SdbReleaseDatabase(hSDB);
    }

    if (pwszExeName) {
        free(pwszExeName);
    }

    EXIT_API();

    return S_OK;
}

DECLARE_API ( help ) 
{
    dprintf("Help for extension dll shimexts.dll\n\n"
            "   !loadshims               - This will stop right after the shims are loaded so if !shimnames\n"
            "                              says the shims are not initialized, try this then !shimnames again.\n\n"
            "   !shimnames               - It displays the name of the shims and how many APIs each shim hooks.\n\n"
            "   !debuglevel <val>        - It changes the shimeng debug level to val (0 to 9).\n\n"
            "   !sdebuglevel <shim> <val>- It changes the shim's debug level to val (0 to 9). If no shim is\n"
            "                              specified, it changes all shims'd debug level to val.\n\n"
            "   !displayhooks shim       - Given the name of a shim, it displays the APIs it hooks.\n\n"
            "   !displaychain addr       - If addr is one of the hooked API address, we print out the chain that\n"
            "                              contains that addr.\n\n"
            "   !shimengsym              - Checks if you have correct symbols for shimeng.\n\n"
            "   !checkex dllname apiname - It tells why this API called by this DLL is not shimmed.\n\n"
            "   !matchmode               - It tells why this module is shimmed with these shims.\n\n"
            "   !help                    - It displays this help.\n"
            );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\exts\extsver.h ===
//
// Increase me when you update the code!
//
#define SHIMEXTS_BIN_VERSION 1,0,0,0
        
#define SHIMEXTS_STRING_VERSION_HELPER(x) #x
#define SHIMEXTS_STRING_VERSION(x) SHIMEXTS_STRING_VERSION_HELPER(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\sdbapi\attributes.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        attributes.c

    Abstract:

        This file contains complete implementation of attribute retrieval and
        caching.

    Author:

        vadimb     created     sometime in 2000

    Revision History:

        several people contributed (clupu, dmunsil...)

--*/

//
// Obtain tag information
//
#define _WANT_TAG_INFO

#include "sdbp.h"
#include <stddef.h>
#include <time.h>



#if defined(KERNEL_MODE) && defined(ALLOC_DATA_PRAGMA)
#pragma  data_seg()
#endif // KERNEL_MODE && ALLOC_DATA_PRAGMA


//
// Attribute tags
// The attributes are checked in the order they are listed below.
//
TAG g_rgAttributeTags[] = {
    TAG_SIZE,
    TAG_CHECKSUM,
    TAG_BIN_FILE_VERSION,
    TAG_BIN_PRODUCT_VERSION,
    TAG_PRODUCT_VERSION,
    TAG_FILE_DESCRIPTION,
    TAG_COMPANY_NAME,
    TAG_PRODUCT_NAME,
    TAG_FILE_VERSION,
    TAG_ORIGINAL_FILENAME,
    TAG_INTERNAL_NAME,
    TAG_LEGAL_COPYRIGHT,
    TAG_VERDATEHI,
    TAG_VERDATELO,
    TAG_VERFILEOS,
    TAG_VERFILETYPE,
    TAG_MODULE_TYPE,
    TAG_PE_CHECKSUM,
    TAG_LINKER_VERSION,
#ifndef KERNEL_MODE
    TAG_16BIT_DESCRIPTION,
    TAG_16BIT_MODULE_NAME,
#endif
    TAG_UPTO_BIN_FILE_VERSION,
    TAG_UPTO_BIN_PRODUCT_VERSION,
    TAG_LINK_DATE,
    TAG_UPTO_LINK_DATE,
    TAG_VER_LANGUAGE
};

#define ATTRIBUTE_COUNT ARRAYSIZE(g_rgAttributeTags)

static TAG_INFO gaTagInfo[] = {
    {TAG_DATABASE           ,TEXT("DATABASE")},
    {TAG_LIBRARY            ,TEXT("LIBRARY")},
    {TAG_INEXCLUDE          ,TEXT("INEXCLUDE")},
    {TAG_SHIM               ,TEXT("SHIM")},
    {TAG_PATCH              ,TEXT("PATCH")},
    {TAG_FLAG               ,TEXT("FLAG")},
    {TAG_APP                ,TEXT("APP")},
    {TAG_EXE                ,TEXT("EXE")},
    {TAG_MATCHING_FILE      ,TEXT("MATCHING_FILE")},
    {TAG_SHIM_REF           ,TEXT("SHIM_REF")},
    {TAG_PATCH_REF          ,TEXT("PATCH_REF")},
    {TAG_FLAG_REF           ,TEXT("FLAG_REF")},
    {TAG_LAYER              ,TEXT("LAYER")},
    {TAG_FILE               ,TEXT("FILE")},
    {TAG_APPHELP            ,TEXT("APPHELP")},
    {TAG_LINK               ,TEXT("LINK")},
    {TAG_DATA               ,TEXT("DATA")},
    {TAG_ACTION             ,TEXT("ACTION")},
    {TAG_MSI_TRANSFORM      ,TEXT("MSI TRANSFORM")},
    {TAG_MSI_TRANSFORM_REF  ,TEXT("MSI TRANSFORM REF")},
    {TAG_MSI_PACKAGE        ,TEXT("MSI PACKAGE")},
    {TAG_MSI_CUSTOM_ACTION  ,TEXT("MSI CUSTOM ACTION")},

    {TAG_NAME               ,TEXT("NAME")},
    {TAG_DESCRIPTION        ,TEXT("DESCRIPTION")},
    {TAG_MODULE             ,TEXT("MODULE")},
    {TAG_API                ,TEXT("API")},
    {TAG_VENDOR             ,TEXT("VENDOR")},
    {TAG_APP_NAME           ,TEXT("APP_NAME")},
    {TAG_DLLFILE            ,TEXT("DLLFILE")},
    {TAG_COMMAND_LINE       ,TEXT("COMMAND_LINE")},
    {TAG_ACTION_TYPE        ,TEXT("ACTION_TYPE")},
    {TAG_COMPANY_NAME       ,TEXT("COMPANY_NAME")},
    {TAG_WILDCARD_NAME      ,TEXT("WILDCARD_NAME")},
    {TAG_PRODUCT_NAME       ,TEXT("PRODUCT_NAME")},
    {TAG_PRODUCT_VERSION    ,TEXT("PRODUCT_VERSION")},
    {TAG_FILE_DESCRIPTION   ,TEXT("FILE_DESCRIPTION")},
    {TAG_FILE_VERSION       ,TEXT("FILE_VERSION")},
    {TAG_ORIGINAL_FILENAME  ,TEXT("ORIGINAL_FILENAME")},
    {TAG_INTERNAL_NAME      ,TEXT("INTERNAL_NAME")},
    {TAG_LEGAL_COPYRIGHT    ,TEXT("LEGAL_COPYRIGHT")},
    {TAG_16BIT_DESCRIPTION  ,TEXT("S16BIT_DESCRIPTION")},
    {TAG_APPHELP_DETAILS    ,TEXT("PROBLEM_DETAILS")},
    {TAG_LINK_URL           ,TEXT("LINK_URL")},
    {TAG_LINK_TEXT          ,TEXT("LINK_TEXT")},
    {TAG_APPHELP_TITLE      ,TEXT("APPHELP_TITLE")},
    {TAG_APPHELP_CONTACT    ,TEXT("APPHELP_CONTACT")},
    {TAG_SXS_MANIFEST       ,TEXT("SXS_MANIFEST")},
    {TAG_DATA_STRING        ,TEXT("DATA_STRING")},
    {TAG_MSI_TRANSFORM_FILE ,TEXT("MSI_TRANSFORM_FILE")},
    {TAG_16BIT_MODULE_NAME  ,TEXT("S16BIT_MODULE_NAME")},
    {TAG_LAYER_DISPLAYNAME  ,TEXT("LAYER_DISPLAYNAME")},
    {TAG_COMPILER_VERSION   ,TEXT("COMPILER_VERSION")},
    {TAG_SIZE               ,TEXT("SIZE")},
    {TAG_OFFSET             ,TEXT("OFFSET")},
    {TAG_CHECKSUM           ,TEXT("CHECKSUM")},
    {TAG_SHIM_TAGID         ,TEXT("SHIM_TAGID")},
    {TAG_PATCH_TAGID        ,TEXT("PATCH_TAGID")},
    {TAG_LAYER_TAGID        ,TEXT("LAYER_TAGID")},
    {TAG_FLAG_TAGID         ,TEXT("FLAG_TAGID")},
    {TAG_MODULE_TYPE        ,TEXT("MODULE_TYPE")},
    {TAG_VERDATEHI          ,TEXT("VERFILEDATEHI")},
    {TAG_VERDATELO          ,TEXT("VERFILEDATELO")},
    {TAG_VERFILEOS          ,TEXT("VERFILEOS")},
    {TAG_VERFILETYPE        ,TEXT("VERFILETYPE")},
    {TAG_PE_CHECKSUM        ,TEXT("PE_CHECKSUM")},
    {TAG_LINKER_VERSION     ,TEXT("LINKER_VERSION")},
    {TAG_LINK_DATE          ,TEXT("LINK_DATE")},
    {TAG_UPTO_LINK_DATE     ,TEXT("UPTO_LINK_DATE")},
    {TAG_OS_SERVICE_PACK    ,TEXT("OS_SERVICE_PACK")},
    {TAG_VER_LANGUAGE       ,TEXT("VER_LANGUAGE")},

    {TAG_PREVOSMAJORVER     ,TEXT("PREVOSMAJORVERSION")},
    {TAG_PREVOSMINORVER     ,TEXT("PREVOSMINORVERSION")},
    {TAG_PREVOSPLATFORMID   ,TEXT("PREVOSPLATFORMID")},
    {TAG_PREVOSBUILDNO      ,TEXT("PREVOSBUILDNO")},
    {TAG_PROBLEMSEVERITY    ,TEXT("PROBLEM_SEVERITY")},
    {TAG_HTMLHELPID         ,TEXT("HTMLHELPID")},
    {TAG_INDEX_FLAGS        ,TEXT("INDEXFLAGS")},
    {TAG_LANGID             ,TEXT("APPHELP_LANGID")},
    {TAG_ENGINE             ,TEXT("ENGINE")},
    {TAG_FLAGS              ,TEXT("FLAGS") },
    {TAG_DATA_VALUETYPE     ,TEXT("VALUETYPE")},
    {TAG_DATA_DWORD         ,TEXT("DATA_DWORD")},
    {TAG_MSI_TRANSFORM_TAGID,TEXT("MSI_TRANSFORM_TAGID")},
    {TAG_RUNTIME_PLATFORM,   TEXT("RUNTIME_PLATFORM")},
    {TAG_OS_SKU,             TEXT("OS_SKU")},

    {TAG_INCLUDE            ,TEXT("INCLUDE")},
    {TAG_GENERAL            ,TEXT("GENERAL")},
    {TAG_MATCH_LOGIC_NOT    ,TEXT("MATCH_LOGIC_NOT")},
    {TAG_APPLY_ALL_SHIMS    ,TEXT("APPLY_ALL_SHIMS")},
    {TAG_USE_SERVICE_PACK_FILES
                            ,TEXT("USE_SERVICE_PACK_FILES")},

    {TAG_TIME               ,TEXT("TIME")},
    {TAG_BIN_FILE_VERSION   ,TEXT("BIN_FILE_VERSION")},
    {TAG_BIN_PRODUCT_VERSION,TEXT("BIN_PRODUCT_VERSION")},
    {TAG_MODTIME            ,TEXT("MODTIME")},
    {TAG_FLAG_MASK_KERNEL   ,TEXT("FLAG_MASK_KERNEL")},
    {TAG_FLAG_MASK_USER     ,TEXT("FLAG_MASK_USER")},
    {TAG_FLAG_MASK_SHELL    ,TEXT("FLAG_MASK_SHELL")},
    {TAG_FLAG_MASK_FUSION   ,TEXT("FLAG_MASK_FUSION")},
    {TAG_UPTO_BIN_PRODUCT_VERSION, TEXT("UPTO_BIN_PRODUCT_VERSION")},
    {TAG_UPTO_BIN_FILE_VERSION, TEXT("UPTO_BIN_FILE_VERSION")},
    {TAG_DATA_QWORD         ,TEXT("DATA_QWORD")},
    {TAG_FLAGS_NTVDM1       ,TEXT("FLAGS_NTVDM1")},
    {TAG_FLAGS_NTVDM2       ,TEXT("FLAGS_NTVDM2")},
    {TAG_FLAGS_NTVDM3       ,TEXT("FLAGS_NTVDM3")},

    {TAG_PATCH_BITS         ,TEXT("PATCH_BITS")},
    {TAG_FILE_BITS          ,TEXT("FILE_BITS")},
    {TAG_EXE_ID             ,TEXT("EXE_ID(GUID)")},
    {TAG_DATA_BITS          ,TEXT("DATA_BITS")},
    {TAG_MSI_PACKAGE_ID     ,TEXT("MSI_PACKAGE_ID(GUID)")},
    {TAG_DATABASE_ID        ,TEXT("DATABASE_ID(GUID)")},
    {TAG_MATCH_MODE         ,TEXT("MATCH_MODE")},

    //
    // Internal types defined in shimdb.h
    //
    {TAG_STRINGTABLE        ,TEXT("STRINGTABLE")},
    {TAG_INDEXES            ,TEXT("INDEXES")},
    {TAG_INDEX              ,TEXT("INDEX")},
    {TAG_INDEX_TAG          ,TEXT("INDEX_TAG")},
    {TAG_INDEX_KEY          ,TEXT("INDEX_KEY")},
    {TAG_INDEX_BITS         ,TEXT("INDEX_BITS")},
    {TAG_STRINGTABLE_ITEM   ,TEXT("STRTAB_ITEM")},
    {TAG_TAG                ,TEXT("TAG")},
    {TAG_TAGID              ,TEXT("TAGID")},

    {TAG_NULL               ,TEXT("")} // always needs to be last item
};

static MOD_TYPE_STRINGS g_rgModTypeStrings[] = {
    {MT_UNKNOWN_MODULE, TEXT("NONE")},
    {MT_W16_MODULE,     TEXT("WIN16")},
    {MT_W32_MODULE,     TEXT("WIN32")},
    {MT_DOS_MODULE,     TEXT("DOS")}
};

//
// Version Strings for stringref attributes
//
typedef struct _VER_STRINGS {
    TAG         tTag;
    LPTSTR      szName;
} VER_STRINGS;

static VER_STRINGS g_rgVerStrings[] = {
    {TAG_PRODUCT_VERSION,       TEXT("ProductVersion")   },
    {TAG_FILE_DESCRIPTION,      TEXT("FileDescription")  },
    {TAG_COMPANY_NAME,          TEXT("CompanyName")      },
    {TAG_PRODUCT_NAME,          TEXT("ProductName")      },
    {TAG_FILE_VERSION,          TEXT("FileVersion")      },
    {TAG_ORIGINAL_FILENAME,     TEXT("OriginalFilename") },
    {TAG_INTERNAL_NAME,         TEXT("InternalName")     },
    {TAG_LEGAL_COPYRIGHT,       TEXT("LegalCopyright")   }
};

//
// Binary version tags (DWORDs and QWORDs)
//
//
static TAG g_rgBinVerTags[] = {
    TAG_VERDATEHI,
    TAG_VERDATELO,
    TAG_VERFILEOS,
    TAG_VERFILETYPE,
    TAG_BIN_PRODUCT_VERSION,
    TAG_BIN_FILE_VERSION,
    TAG_UPTO_BIN_PRODUCT_VERSION,
    TAG_UPTO_BIN_FILE_VERSION
};

//
// Binary header tags (retrieval requires opening a file).
//
static TAG g_rgHeaderTags[] = {
    TAG_MODULE_TYPE,
    TAG_PE_CHECKSUM,
    TAG_LINKER_VERSION,
    TAG_CHECKSUM,
    TAG_16BIT_DESCRIPTION,
    TAG_16BIT_MODULE_NAME,
    TAG_LINK_DATE,
    TAG_UPTO_LINK_DATE
};

//
// Basic information tags (size).
//
TAG g_rgDirectoryTags[] = {
    TAG_SIZE,
    0
};


//
// Invalid tag token
//
static TCHAR s_szInvalidTag[] = _T("InvalidTag");

#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, TagToIndex)
#pragma alloc_text(PAGE, SdbTagToString)
#pragma alloc_text(PAGE, SdbpModuleTypeToString)
#pragma alloc_text(PAGE, SdbpSetAttribute)
#pragma alloc_text(PAGE, SdbpQueryStringVersionInformation)
#pragma alloc_text(PAGE, SdbpQueryBinVersionInformation)
#pragma alloc_text(PAGE, SdbpGetVersionAttributesNT)
#pragma alloc_text(PAGE, SdbpGetHeaderAttributes)
#pragma alloc_text(PAGE, SdbpGetAttribute)
#pragma alloc_text(PAGE, SdbpCheckAttribute)
#pragma alloc_text(PAGE, FindFileInfo)
#pragma alloc_text(PAGE, CreateFileInfo)
#pragma alloc_text(PAGE, SdbFreeFileInfo)
#pragma alloc_text(PAGE, SdbpCleanupAttributeMgr)
#pragma alloc_text(PAGE, SdbpCheckAllAttributes)
#pragma alloc_text(PAGE, SdbpQueryVersionString)
#pragma alloc_text(PAGE, SdbpGetModuleType)
#pragma alloc_text(PAGE, SdbpGetModulePECheckSum)
#pragma alloc_text(PAGE, SdbpGetImageNTHeader)
#pragma alloc_text(PAGE, SdbpGetFileChecksum)
#pragma alloc_text(PAGE, SdbpCheckVersion)
#pragma alloc_text(PAGE, SdbpCheckUptoVersion)

#endif // KERNEL_MODE && ALLOC_PRAGMA


int
TagToIndex(
    IN  TAG tag                 // the tag
    )
/*++
    Return: The index in the attribute info array (g_rgAttributeTags).

    Desc:   Self explanatory.
--*/
{
    int i;

    for (i = 0; i < ATTRIBUTE_COUNT; i++) {
        if (tag == g_rgAttributeTags[i]) {
            return i;
        }
    }

    DBGPRINT((sdlError, "TagToIndex", "Invalid attribute 0x%x.\n", tag));

    return -1;
}


LPCTSTR
SdbTagToString(
    TAG tag
    )
/*++
    Return: The pointer to the string name for the specified tag.

    Desc:   Self explanatory.
--*/
{
    int i;

    for (i = 0; i < ARRAYSIZE(gaTagInfo); ++i) {
        if (gaTagInfo[i].tWhich == tag) {
            return gaTagInfo[i].szName;
        }
    }

    return s_szInvalidTag;
}

LPCTSTR
SdbpModuleTypeToString(
    DWORD dwModuleType
    )
{
    int i;

    for (i = 0; i < ARRAYSIZE(g_rgModTypeStrings); ++i) {
        if (g_rgModTypeStrings[i].dwModuleType == dwModuleType) {
            return g_rgModTypeStrings[i].szModuleType;
        }
    }

    //
    // The first element is the "UNKNOWN" type -- NONE
    //
    return g_rgModTypeStrings[0].szModuleType;
}

BOOL
SdbpSetAttribute(
    OUT PFILEINFO pFileInfo,    // pointer to the FILEINFO structure.
    IN  TAG       AttrID,       // Attribute ID (tag, as in TAG_SIZE
    IN  PVOID     pValue        // value
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function sets the value for the specified attribute.
            If pValue is NULL it means that the specified attribute is not
            available for the file.
--*/
{
    int       nAttrInd;
    PATTRINFO pAttrInfo;

    nAttrInd = TagToIndex(AttrID);

    if (nAttrInd < 0) {
        DBGPRINT((sdlError, "SdbpSetAttribute", "Invalid attribute %d.\n", nAttrInd));
        return FALSE;
    }

    pAttrInfo = &pFileInfo->Attributes[nAttrInd];

    if (pValue == NULL) {
        //
        // No value. Mark and exit.
        //
        pAttrInfo->dwFlags = (pAttrInfo->dwFlags & ~ATTRIBUTE_AVAILABLE) |
                             ATTRIBUTE_FAILED;
        return TRUE;
    }

    switch (GETTAGTYPE(AttrID)) {
    case TAG_TYPE_DWORD:
        pAttrInfo->dwAttr = *(DWORD*)pValue;
        break;

    case TAG_TYPE_QWORD:
        pAttrInfo->ullAttr = *(ULONGLONG*)pValue;
        break;

    case TAG_TYPE_STRINGREF:
        pAttrInfo->lpAttr = (LPTSTR)pValue;
        break;
    }

    pAttrInfo->tAttrID = AttrID;
    pAttrInfo->dwFlags |= ATTRIBUTE_AVAILABLE;

    return TRUE;
}


//
// This is a guard against bad code in version.dll that stomps over the
// buffer size for Unicode apis on 16-bit exes.
//
#define VERSIONINFO_BUFFER_PAD 16


void
SdbpQueryStringVersionInformation(
    IN  PSDBCONTEXT pContext,
    IN  PFILEINFO   pFileInfo,
    OUT LPVOID      pVersionInfo
    )
/*++
    Return: void.

    Desc:   Sets all the version string info available for the specified file.
--*/
{
    int              i;
    LPTSTR           szVerString;
    PLANGANDCODEPAGE pLangCodePage = NULL;
    UINT             cbLangCP      = 0;
    int              nTranslations = 0;

    if (!pContext->pfnVerQueryValue(pVersionInfo,
                                    TEXT("\\VarFileInfo\\Translation"),
                                    (LPVOID)&pLangCodePage,
                                    &cbLangCP)) {
        DBGPRINT((sdlError,
                  "SdbpQueryStringVersionInformation",
                  "VerQueryValue failed for translation\n"));
        pLangCodePage = NULL;
    }

    nTranslations = cbLangCP / sizeof(*pLangCodePage);

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        szVerString = SdbpQueryVersionString(pContext,
                                             pVersionInfo,
                                             pLangCodePage,
                                             nTranslations,
                                             g_rgVerStrings[i].szName);

        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, szVerString);
    }

#ifndef KERNEL_MODE
    //
    // Set the attribute for Language
    //
    if (pLangCodePage != NULL && nTranslations == 1) {

        DWORD dwLanguage = (DWORD)pLangCodePage->wLanguage;

        SdbpSetAttribute(pFileInfo, TAG_VER_LANGUAGE, &dwLanguage);
    } else {
        SdbpSetAttribute(pFileInfo, TAG_VER_LANGUAGE, NULL);
    }

#endif // KERNEL_MODE
}

VOID
SdbpQueryBinVersionInformation(
    IN  PSDBCONTEXT       pContext,
    IN  PFILEINFO         pFileInfo,
    OUT VS_FIXEDFILEINFO* pFixedInfo
    )
/*++
    Return: void.

    Desc:   Sets all the version string info available for the specified file
            from the fixed size resources.
--*/
{
    LARGE_INTEGER liVerData;

    SdbpSetAttribute(pFileInfo, TAG_VERDATEHI,   &pFixedInfo->dwFileDateMS);
    SdbpSetAttribute(pFileInfo, TAG_VERDATELO,   &pFixedInfo->dwFileDateLS);
    SdbpSetAttribute(pFileInfo, TAG_VERFILEOS,   &pFixedInfo->dwFileOS);
    SdbpSetAttribute(pFileInfo, TAG_VERFILETYPE, &pFixedInfo->dwFileType);

    liVerData.LowPart  = pFixedInfo->dwProductVersionLS;
    liVerData.HighPart = pFixedInfo->dwProductVersionMS;
    SdbpSetAttribute(pFileInfo, TAG_BIN_PRODUCT_VERSION,      &liVerData.QuadPart);
    SdbpSetAttribute(pFileInfo, TAG_UPTO_BIN_PRODUCT_VERSION, &liVerData.QuadPart);

    liVerData.LowPart  = pFixedInfo->dwFileVersionLS;
    liVerData.HighPart = pFixedInfo->dwFileVersionMS;
    SdbpSetAttribute(pFileInfo, TAG_BIN_FILE_VERSION, &liVerData.QuadPart);
    SdbpSetAttribute(pFileInfo, TAG_UPTO_BIN_FILE_VERSION, &liVerData.QuadPart);
    
    UNREFERENCED_PARAMETER(pContext);
}


#if defined(NT_MODE) || defined(KERNEL_MODE)

BOOL
SdbpGetVersionAttributesNT(
    IN  PSDBCONTEXT    pContext,
    OUT PFILEINFO      pFileInfo,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves all of the Version-related attributes
            Imports apis from version.dll if called for the first time
--*/
{
    BOOL              bSuccess;
    LPVOID            pVersionInfo = NULL;
    VS_FIXEDFILEINFO* pFixedInfo   = NULL;
    int               i;

    //
    // First retrieve the version info.
    //
    bSuccess = SdbpGetFileVersionInformation(pImageData, &pVersionInfo, &pFixedInfo);

    if (!bSuccess) {
        DBGPRINT((sdlInfo, "SdbpGetVersionAttributesNT", "No version info.\n"));
        goto ErrHandle;
    }

    //
    // Version information available.
    //

    //
    // Set the pointer to our internal function.
    //
    pContext->pfnVerQueryValue = SdbpVerQueryValue;

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, NULL);
    }

    SdbpSetAttribute(pFileInfo, TAG_VER_LANGUAGE, NULL);

    //
    // Query binary stuff
    //
    SdbpQueryBinVersionInformation(pContext, pFileInfo, pFixedInfo);

    pFileInfo->pVersionInfo = pVersionInfo;

    return TRUE;

ErrHandle:
    //
    // Reset all the string info.
    //
    for (i = 0; i < ARRAYSIZE(g_rgBinVerTags); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgBinVerTags[i], NULL);
    }

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, NULL);
    }

    return FALSE;
}

#endif // NT_MODE || KERNEL_MODE


BOOL
SdbpGetHeaderAttributes(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves the header attributes for the
            specified file.
--*/
{
    IMAGEFILEDATA   ImageData;
    ULONG           ulPEChecksum = 0;
    ULONG           ulChecksum   = 0;
    DWORD           dwModuleType = 0;
    DWORD           dwLinkerVer;
    DWORD           dwLinkDate;
    BOOL            bSuccess;
    int             i;

    ImageData.dwFlags = 0;

    if (pFileInfo->hFile != INVALID_HANDLE_VALUE) {
        ImageData.hFile   = pFileInfo->hFile;
        ImageData.dwFlags |= IMAGEFILEDATA_HANDLEVALID;
    }

    if (pFileInfo->pImageBase != NULL) {
        ImageData.pBase    = pFileInfo->pImageBase;
        ImageData.ViewSize = (SIZE_T)   pFileInfo->dwImageSize;
        ImageData.FileSize = (ULONGLONG)pFileInfo->dwImageSize;
        ImageData.dwFlags |= IMAGEFILEDATA_PBASEVALID;
    }

    //
    // SdbpOpenAndMapFile uses DOS_PATH type as an argument
    // In kernel mode this parameter is ignored.
    //
    if (SdbpOpenAndMapFile(pFileInfo->FilePath, &ImageData, DOS_PATH)) {

        bSuccess = SdbpGetModuleType(&dwModuleType, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_MODULE_TYPE, bSuccess ? (PVOID)&dwModuleType : NULL);

        bSuccess = SdbpGetModulePECheckSum(&ulPEChecksum, &dwLinkerVer, &dwLinkDate, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_PE_CHECKSUM, bSuccess ? (PVOID)&ulPEChecksum : NULL);
        SdbpSetAttribute(pFileInfo, TAG_LINKER_VERSION, bSuccess ? (PVOID)&dwLinkerVer : NULL);
        SdbpSetAttribute(pFileInfo, TAG_LINK_DATE, bSuccess ? (PVOID)&dwLinkDate : NULL);
        SdbpSetAttribute(pFileInfo, TAG_UPTO_LINK_DATE, bSuccess ? (PVOID)&dwLinkDate : NULL);

        bSuccess = SdbpGetFileChecksum(&ulChecksum, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_CHECKSUM,   bSuccess ? (PVOID)&ulChecksum   : NULL);

#ifndef KERNEL_MODE

        //
        // Now retrieve 16-bit description string, it's max size is 256 bytes.
        //
        // This attribute is not available in kernel mode.
        //
        bSuccess = SdbpGet16BitDescription(&pFileInfo->pDescription16, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_16BIT_DESCRIPTION, pFileInfo->pDescription16);
        bSuccess = SdbpGet16BitModuleName(&pFileInfo->pModuleName16, &ImageData);
        SdbpSetAttribute(pFileInfo, TAG_16BIT_MODULE_NAME,  pFileInfo->pModuleName16);

#if defined(NT_MODE)

        //
        // Hit this case only on current platform
        //
        if (pFileInfo->hFile != INVALID_HANDLE_VALUE || pFileInfo->pImageBase != NULL) {

            SdbpGetVersionAttributesNT(pContext, pFileInfo, &ImageData);
        }
#endif  // NT_MODE

#else // KERNEL_MODE

        //
        // When we are running in kernel mode retrieve version-related
        // data now as well.
        //
        SdbpGetVersionAttributesNT(pContext, pFileInfo, &ImageData);

        //
        // Retrieve file directory attributes.
        //
        SdbpGetFileDirectoryAttributesNT(pFileInfo, &ImageData);

#endif // KERNEL_MODE

        SdbpUnmapAndCloseFile(&ImageData);

        return TRUE;
    }

    for (i = 0; i < ARRAYSIZE(g_rgHeaderTags); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgHeaderTags[i], NULL);
    }

#ifdef KERNEL_MODE

    //
    // Reset all the version attributes here as well.
    //
    for (i = 0; i < ARRAYSIZE(g_rgBinVerTags); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgBinVerTags[i], NULL);
    }

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, NULL);
    }
#endif // KERNEL_MODE

    return FALSE;
    
    UNREFERENCED_PARAMETER(pContext);
}


BOOL
SdbpGetAttribute(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo,
    IN  TAG         AttrID
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Retrieve an attribute for a given file. We retrieve all the
            attributes of the same class.
--*/
{
    BOOL bReturn = FALSE;

    switch (AttrID) {
    //
    // The tags below require checking the file and making a directory query.
    //
    case TAG_SIZE:

#ifndef KERNEL_MODE  // in kernel mode we fall through to header attributes

        bReturn = SdbpGetFileDirectoryAttributes(pFileInfo);
        break;

#endif // KERNEL_MODE

    //
    // The tags below require retrieving version resources.
    //
    case TAG_VERDATEHI:
    case TAG_VERDATELO:
    case TAG_VERFILEOS:
    case TAG_VERFILETYPE:
    case TAG_UPTO_BIN_PRODUCT_VERSION:
    case TAG_UPTO_BIN_FILE_VERSION:
    case TAG_BIN_FILE_VERSION:
    case TAG_BIN_PRODUCT_VERSION:
    case TAG_PRODUCT_VERSION:
    case TAG_FILE_DESCRIPTION:
    case TAG_COMPANY_NAME:
    case TAG_PRODUCT_NAME:
    case TAG_FILE_VERSION:
    case TAG_ORIGINAL_FILENAME:
    case TAG_INTERNAL_NAME:
    case TAG_LEGAL_COPYRIGHT:
    case TAG_VER_LANGUAGE:

        //
        // In KERNEL_MODE we fall through and do the attributes using the
        // header attributes.
        //

#ifndef KERNEL_MODE

        //
        // Version attributes are retrieved through the header attributes if
        // caller provided a handle/image base
        //
        if (pFileInfo->hFile == INVALID_HANDLE_VALUE && pFileInfo->pImageBase == NULL) {
            bReturn = SdbpGetVersionAttributes(pContext, pFileInfo);
            break;
        }

#endif // KERNEL_MODE

    //
    // The tags below require opening a file and mapping it into memory.
    //
    case TAG_CHECKSUM:
    case TAG_PE_CHECKSUM:
    case TAG_LINKER_VERSION:
    case TAG_16BIT_DESCRIPTION:
    case TAG_16BIT_MODULE_NAME:
    case TAG_MODULE_TYPE:
    case TAG_UPTO_LINK_DATE:
    case TAG_LINK_DATE:
        bReturn = SdbpGetHeaderAttributes(pContext, pFileInfo);
        break;
    }

    return bReturn;
}

BOOL
SdbpCheckAttribute(
    IN  PSDBCONTEXT pContext,   // Database Context pointer
    IN  PVOID       pFileData,  // pointer returned from CheckFile
    IN  TAG         AttrID,     // Attribute ID
    IN  PVOID       pAttribute  // attribute value ptr (see above for description)
    )
/*++
    Return: TRUE if the value for given attribute matches
            the file's attribute, FALSE otherwise.

    Desc:   Check an attribute against a given value. This function
            retrieves attributes as necessary.
--*/
{
    int       nAttrIndex;
    PATTRINFO pAttrInfo;
    BOOL      bReturn = FALSE;
    PFILEINFO pFileInfo = (PFILEINFO)pFileData;

    if (pAttribute == NULL) {
        DBGPRINT((sdlError, "SdbpCheckAttribute", "Invalid parameter.\n"));
        return FALSE;
    }

    nAttrIndex = TagToIndex(AttrID);

    if (nAttrIndex < 0) {
        DBGPRINT((sdlError, "SdbpCheckAttribute", "Bad Attribute ID 0x%x\n", AttrID));
        return FALSE;
    }

    //
    // Now see if this attribute is any good.
    //
    pAttrInfo = &pFileInfo->Attributes[nAttrIndex];

    if (!(pAttrInfo->dwFlags & ATTRIBUTE_AVAILABLE)) {
        //
        // See if we have tried already
        //
        if (pAttrInfo->dwFlags & ATTRIBUTE_FAILED) {
            DBGPRINT((sdlInfo,
                      "SdbpCheckAttribute",
                      "Already tried to get attr ID 0x%x.\n",
                      AttrID));
            return FALSE;
        }

        //
        // The attribute has not been retrieved yet, do it now then.
        //
        // Try to obtain this attribute from the file.
        //
        if (!SdbpGetAttribute(pContext, pFileInfo, AttrID)) {
            DBGPRINT((sdlWarning,
                      "SdbpCheckAttribute",
                      "Failed to get attribute \"%s\" for \"%s\"\n",
                      SdbTagToString(AttrID),
                      pFileInfo->FilePath));
            //
            // ATTRIBUTE_FAILED is set by the SdbpGetAttribute
            //

            return FALSE;
        }
    }

    //
    // Check again here in case we had to retrieve the attribute.
    //
    if (!(pAttrInfo->dwFlags & ATTRIBUTE_AVAILABLE)) {
        return FALSE;
    }

    switch (AttrID) {

    case TAG_BIN_PRODUCT_VERSION:
    case TAG_BIN_FILE_VERSION:

        bReturn = SdbpCheckVersion(*(ULONGLONG*)pAttribute, pAttrInfo->ullAttr);

        if (!bReturn) {
#ifdef _DEBUG_SPEW

            ULONGLONG qwDBFileVer  = *(ULONGLONG*)pAttribute;
            ULONGLONG qwBinFileVer = pAttrInfo->ullAttr;

            DBGPRINT((sdlInfo,
                      "SdbpCheckAttribute",
                      "\"%s\" mismatch file: \"%s\". Expected %d.%d.%d.%d, Found %d.%d.%d.%d\n",
                      SdbTagToString(AttrID),
                      pFileInfo->FilePath,
                      (WORD)(qwDBFileVer >> 48),
                      (WORD)(qwDBFileVer >> 32),
                      (WORD)(qwDBFileVer >> 16),
                      (WORD)(qwDBFileVer),
                      (WORD)(qwBinFileVer >> 48),
                      (WORD)(qwBinFileVer >> 32),
                      (WORD)(qwBinFileVer >> 16),
                      (WORD)(qwBinFileVer)));
#endif
        }
        break;

    case TAG_UPTO_BIN_PRODUCT_VERSION:
    case TAG_UPTO_BIN_FILE_VERSION:

        bReturn = SdbpCheckUptoVersion(*(ULONGLONG*)pAttribute, pAttrInfo->ullAttr);

        if (!bReturn) {
#ifdef _DEBUG_SPEW

            ULONGLONG qwDBFileVer  = *(ULONGLONG*)pAttribute;
            ULONGLONG qwBinFileVer = pAttrInfo->ullAttr;

            DBGPRINT((sdlInfo,
                      "SdbpCheckAttribute",
                      "\"%s\" mismatch file: \"%s\". Expected %d.%d.%d.%d, Found %d.%d.%d.%d\n",
                      SdbTagToString(AttrID),
                      pFileInfo->FilePath,
                      (WORD)(qwDBFileVer >> 48),
                      (WORD)(qwDBFileVer >> 32),
                      (WORD)(qwDBFileVer >> 16),
                      (WORD)(qwDBFileVer),
                      (WORD)(qwBinFileVer >> 48),
                      (WORD)(qwBinFileVer >> 32),
                      (WORD)(qwBinFileVer >> 16),
                      (WORD)(qwBinFileVer)));
#endif
        }
        break;

    case TAG_UPTO_LINK_DATE:
        bReturn = (*(DWORD*)pAttribute >= pAttrInfo->dwAttr);

        if (!bReturn) {
            DBGPRINT((sdlInfo,
                      "SdbpCheckAttribute",
                      "\"%s\" mismatch file \"%s\". Expected less than 0x%x Found 0x%x\n",
                      SdbTagToString(AttrID),
                      pFileInfo->FilePath,
                      *(DWORD*)pAttribute,
                      pAttrInfo->dwAttr));
        }
        break;

    default:

        switch (GETTAGTYPE(AttrID)) {
        case TAG_TYPE_DWORD:
            //
            // This is likely to be hit first.
            //
            bReturn = (*(DWORD*)pAttribute == pAttrInfo->dwAttr);

            if (!bReturn) {
                DBGPRINT((sdlInfo,
                          "SdbpCheckAttribute",
                          "\"%s\" mismatch file \"%s\". Expected 0x%x Found 0x%x\n",
                          SdbTagToString(AttrID),
                          pFileInfo->FilePath,
                          *(DWORD*)pAttribute,
                          pAttrInfo->dwAttr));
            }
            break;

        case TAG_TYPE_STRINGREF:
            bReturn = SdbpPatternMatch((LPCTSTR)pAttribute, (LPCTSTR)pAttrInfo->lpAttr);

            if (!bReturn) {
                DBGPRINT((sdlInfo,
                          "SdbpCheckAttribute",
                          "\"%s\" mismatch file \"%s\". Expected \"%s\" Found \"%s\"\n",
                          SdbTagToString(AttrID),
                          pFileInfo->FilePath,
                          pAttribute,
                          pAttrInfo->lpAttr));

            }
            break;

        case TAG_TYPE_QWORD:
            bReturn = (*(ULONGLONG*)pAttribute == pAttrInfo->ullAttr);

            if (!bReturn) {
                DBGPRINT((sdlInfo,
                          "SdbpCheckAttribute",
                          "\"%s\" mismatch file \"%s\". Expected 0x%I64x Found 0x%I64x\n",
                          SdbTagToString(AttrID),
                          pFileInfo->FilePath,
                          *(ULONGLONG*)pAttribute,
                          pAttrInfo->ullAttr));
            }

            break;
        }
        break;
    }

    return bReturn;
}


PFILEINFO
FindFileInfo(
    IN  PSDBCONTEXT pContext,
    IN  LPCTSTR     FilePath
    )
/*++
    Return: A pointer to the cached FILEINFO structure if one is found
            or NULL otherwise.

    Desc:   This function performs a search in the file cache to determine whether
            a given file has already been touched.
--*/
{
    PFILEINFO pFileInfo = (PFILEINFO)pContext->pFileAttributeCache; // global cache

    while (pFileInfo != NULL) {
        if (ISEQUALSTRING(pFileInfo->FilePath, FilePath)) {
            DBGPRINT((sdlInfo,
                      "FindFileInfo",
                      "FILEINFO for \"%s\" found in the cache.\n",
                      FilePath));
            return pFileInfo;
        }

        pFileInfo = pFileInfo->pNext;
    }

    return NULL;
}

PFILEINFO
CreateFileInfo(
    IN  PSDBCONTEXT pContext,
    IN  LPCTSTR     FullPath,
    IN  DWORD       dwLength OPTIONAL,  // length (in characters) of FullPath string
    IN  HANDLE      hFile OPTIONAL,   // file handle
    IN  LPVOID      pImageBase OPTIONAL,
    IN  DWORD       dwImageSize OPTIONAL,
    IN  BOOL        bNoCache
    )
/*++
    Return: A pointer to the allocated FILEINFO structure.

    Desc:   Allocates the FILEINFO structure for the specified file.
--*/
{
    PFILEINFO pFileInfo;
    SIZE_T    sizeBase;
    SIZE_T    size;
    DWORD     nPathLen;

    nPathLen  = dwLength ? dwLength : (DWORD)_tcslen(FullPath);

    sizeBase  = sizeof(*pFileInfo) + (ATTRIBUTE_COUNT - 1) * sizeof(ATTRINFO);
    size      = sizeBase + (nPathLen + 1) * sizeof(*FullPath);

    pFileInfo = (PFILEINFO)SdbAlloc(size);

    if (pFileInfo == NULL) {
        DBGPRINT((sdlError,
                  "CreateFileInfo",
                  "Failed to allocate %d bytes for FILEINFO structure.\n",
                  size));
        return NULL;
    }

    RtlZeroMemory(pFileInfo, size);

    pFileInfo->FilePath = (LPTSTR)((PBYTE)pFileInfo + sizeBase);

    RtlCopyMemory(pFileInfo->FilePath, FullPath, nPathLen * sizeof(*FullPath));

    pFileInfo->FilePath[nPathLen] = TEXT('\0');

    pFileInfo->hFile       = hFile;
    pFileInfo->pImageBase  = pImageBase;
    pFileInfo->dwImageSize = dwImageSize;

    //
    // Now link it in if we use the cache.
    //
    if (!bNoCache) {
        pFileInfo->pNext = (PFILEINFO)pContext->pFileAttributeCache;
        pContext->pFileAttributeCache = (PVOID)pFileInfo;
    }

    return pFileInfo;
}


void
SdbFreeFileInfo(
    IN  PVOID pFileData         // pointer returned from SdbpGetFileAttributes
    )
/*++
    Return: void.

    Desc:   Self explanatory. Use this only after calling GetFileInfo
            with bNoCache set to TRUE.
--*/
{
    PFILEINFO pFileInfo = (PFILEINFO)pFileData;

    if (pFileInfo == NULL) {
        DBGPRINT((sdlError, "SdbFreeFileInfo", "Invalid parameter.\n"));
        return;
    }

    if (pFileInfo->pVersionInfo != NULL) {
        SdbFree(pFileInfo->pVersionInfo);
    }

    if (pFileInfo->pDescription16 != NULL) {
        SdbFree(pFileInfo->pDescription16);
    }

    if (pFileInfo->pModuleName16 != NULL) {
        SdbFree(pFileInfo->pModuleName16);
    }

    SdbFree(pFileInfo);
}

void
SdbpCleanupAttributeMgr(
    IN  PSDBCONTEXT pContext    // database context
    )
/*++
    Return: void.

    Desc:   This function should be called afer we are done checking a given exe
            it performs cleanup tasks, such as:
            . unload dynamically linked dll (version.dll)
            . cleanup file cache
--*/
{
    PFILEINFO pFileInfo = (PFILEINFO)pContext->pFileAttributeCache;
    PFILEINFO pNext;

    while (pFileInfo != NULL) {
        pNext = pFileInfo->pNext;
        SdbFreeFileInfo(pFileInfo);
        pFileInfo = pNext;
    }

    //
    // Reset the cache pointer.
    //
    pContext->pFileAttributeCache = NULL;
}


BOOL
SdbpCheckAllAttributes(
    IN  PSDBCONTEXT pContext,   // pointer to the database channel
    IN  PDB         pdb,        // pointer to the Shim Database that we're checking against
    IN  TAGID       tiMatch,    // TAGID for a given file(exe) to be checked
    IN  PVOID       pFileData   // pointer returned from CheckFile
    )
/*++
    Return: TRUE if all the file's attributes match the ones described in the
            database for this file, FALSE otherwise.

    Desc:   TBD
--*/
{
    int         i;
    TAG         tAttrID;
    PVOID       pAttribute;
    TAGID       tiTemp;
    DWORD       dwAttribute;
    ULONGLONG   ullAttribute;
    BOOL        bReturn = TRUE;  // match by default

    assert(tiMatch != TAGID_NULL);

    if (pFileData == NULL) {
        //
        // No file was passed in. This can happen if LOGIC="NOT" is used.
        //
        return FALSE;
    }

    for (i = 0; i < ATTRIBUTE_COUNT && bReturn; ++i) {

        tAttrID = g_rgAttributeTags[i];
        tiTemp = SdbFindFirstTag(pdb, tiMatch, tAttrID);

        if (tiTemp != TAGID_NULL) {
            pAttribute = NULL;

            switch (GETTAGTYPE(tAttrID)) {

            case TAG_TYPE_DWORD:
                dwAttribute = SdbReadDWORDTag(pdb, tiTemp, 0);
                pAttribute = &dwAttribute;
                break;

            case TAG_TYPE_QWORD:
                ullAttribute = SdbReadQWORDTag(pdb, tiTemp, 0);
                pAttribute = &ullAttribute;
                break;

            case TAG_TYPE_STRINGREF:
                pAttribute = SdbGetStringTagPtr(pdb, tiTemp);
                break;
            }

            //
            // Now check the attribute.
            //
            bReturn = SdbpCheckAttribute(pContext, pFileData, tAttrID, pAttribute);

            //
            // we bail out if !bReturn via the condition in FOR loop above
            //
        }
    }

    return bReturn;
}


//
// VERSION DATA
//


/*--

  Search order is:

  - Language neutral, Unicode (0x000004B0)
  - Language neutral, Windows-multilingual (0x000004e4)
  - US English, Unicode (0x040904B0)
  - US English, Windows-multilingual (0x040904E4)

  If none of those exist, it's not likely we're going to get good
  matching info from what does exist.

--*/

LPTSTR
SdbpQueryVersionString(
    IN  PSDBCONTEXT      pContext,       // the database channel
    IN  PVOID            pVersionData,   // Version data buffer
    IN  PLANGANDCODEPAGE pTranslations,
    IN  DWORD            TranslationCount,
    IN  LPCTSTR          szString        // String to search for; see VerQueryValue in MSDN
    )
/*++
    Return: The pointer to the string if found, NULL if not.

    Desc:   Gets a pointer to a particular string in the StringFileInfo section
            of a version resource.
            Lookup is performed for known english-language resources followed up
            by a lookup in the available translations section (if such was found)
--*/
{
    TCHAR  szTemp[128];
    LPTSTR szReturn = NULL;
    int    i;

    static DWORD adwLangs[] = {0x000004B0, 0x000004E4, 0x040904B0, 0x040904E4};

    assert(pVersionData && szString);

    for (i = 0; i < ARRAYSIZE(adwLangs); ++i) {
        UINT unLen;

        StringCchPrintf(szTemp,
                        CHARCOUNT(szTemp),
                        _T("\\StringFileInfo\\%08X\\%s"),
                        adwLangs[i],
                        szString);

        if (pContext->pfnVerQueryValue(pVersionData, szTemp, (PVOID*)&szReturn, &unLen)) {
            return szReturn;
        }
    }

    if (pTranslations != NULL) {
        for (i = 0; i < (int)TranslationCount; ++i, ++pTranslations) {
            UINT unLen;

            StringCchPrintf(szTemp,
                            CHARCOUNT(szTemp),
                            _T("\\StringFileInfo\\%04X%04X\\%s"),
                            (DWORD)pTranslations->wLanguage,
                            (DWORD)pTranslations->wCodePage,
                            szString);

            if (pContext->pfnVerQueryValue(pVersionData, szTemp, (PVOID*)&szReturn, &unLen)) {
                return szReturn;
            }
        }
    }

    return NULL; // none found
}

BOOL
SdbpGetModuleType(
    OUT LPDWORD lpdwModuleType,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets a pointer to a particular string in the StringFileInfo section
            of a version resource.
--*/
{
    PIMAGE_DOS_HEADER pDosHeader;
    DWORD             dwModuleType = MT_UNKNOWN_MODULE;
    LPBYTE            lpSignature;
    DWORD             OffsetNew;

    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;
    if (pDosHeader == NULL || pDosHeader == (PIMAGE_DOS_HEADER)-1) {
        return FALSE;
    }

    //
    // Check size and read signature.
    //
    if (pImageData->ViewSize < sizeof(*pDosHeader) || pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }

    //
    // Assume DOS module.
    //
    dwModuleType = MT_DOS_MODULE;
    OffsetNew = (DWORD)pDosHeader->e_lfanew;

    //
    // New header signature. Check offset.
    //
    if (pImageData->ViewSize < OffsetNew + sizeof(DWORD)) {
        return FALSE;
    }

    lpSignature = ((LPBYTE)pImageData->pBase + OffsetNew);

    if (IMAGE_NT_SIGNATURE == *(LPDWORD)lpSignature) {
        dwModuleType = MT_W32_MODULE;
    } else if (IMAGE_OS2_SIGNATURE == *(PWORD)lpSignature) {
        dwModuleType = MT_W16_MODULE;
    }

    if (lpdwModuleType != NULL) {
        *lpdwModuleType = dwModuleType;
    }

    return TRUE;
}

BOOL
SdbpGetImageNTHeader(
    OUT PIMAGE_NT_HEADERS* ppHeader,
    IN  PIMAGEFILEDATA     pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets a pointer to the IMAGE_NT_HEADERS.
--*/
{
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;
    DWORD             ModuleType;

    if (!SdbpGetModuleType(&ModuleType, pImageData)) {
        return FALSE;
    }

    if (ModuleType != MT_W32_MODULE) {
        return FALSE;
    }

    //
    // Header is valid.
    //
    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;
    pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pImageData->pBase + pDosHeader->e_lfanew);

    if (pImageData->ViewSize >= pDosHeader->e_lfanew + sizeof(*pNtHeaders)) { // not too short?
        *ppHeader = pNtHeaders;
        return TRUE;
    }

    return FALSE;
}


BOOL
SdbpGetModulePECheckSum(
    OUT PULONG         pChecksum,
    OUT LPDWORD        pdwLinkerVersion,
    OUT LPDWORD        pdwLinkDate,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets the checksum from the PE headers.
--*/
{
    PIMAGE_NT_HEADERS pNtHeader;
    PIMAGE_DOS_HEADER pDosHeader;
    ULONG             ulChecksum = 0;

    if (!SdbpGetImageNTHeader(&pNtHeader, pImageData)) {
        DBGPRINT((sdlError, "SdbpGetModulePECheckSum", "Failed to get Image NT header.\n"));
        return FALSE;
    }

    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;

    //
    // Fill in the linker version (as it used to calculated in ntuser).
    //
    *pdwLinkerVersion = (pNtHeader->OptionalHeader.MinorImageVersion & 0xFF) +
                        ((pNtHeader->OptionalHeader.MajorImageVersion & 0xFF) << 16);

    *pdwLinkDate = pNtHeader->FileHeader.TimeDateStamp;

    switch (pNtHeader->OptionalHeader.Magic) {
    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
        if (pImageData->ViewSize >= pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS32)) {
            ulChecksum = ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.CheckSum;
            *pChecksum = ulChecksum;
            return TRUE;
        }
        break;


    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
        //
        // Do an additional check.
        //
        if (pImageData->ViewSize >= pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS64)) {
            ulChecksum = ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.CheckSum;
            *pChecksum = ulChecksum;
            return TRUE;
        }
        break;

    default:
        //
        // Unknown image type ?
        //
        DBGPRINT((sdlError,
                  "SdbpGetModulePECheckSum",
                  "Bad image type 0x%x\n",
                  pNtHeader->OptionalHeader.Magic));
        *pChecksum = 0;
        break;
    }

    return FALSE;
}

#define CHECKSUM_SIZE  4096
#define CHECKSUM_START 512


BOOL
SdbpGetFileChecksum(
    OUT PULONG         pChecksum,
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Calculates a checksum for the file.
--*/
{
    ULONG   size = CHECKSUM_SIZE;
    ULONG   StartAddress = CHECKSUM_START;
    ULONG   ulChecksum = 0;
    LPDWORD lpdw;
    int     i;

    if ((SIZE_T)pImageData->FileSize < (SIZE_T)size) {
        StartAddress = 0;
        size = (ULONG)pImageData->FileSize; // this is safe (size is rather small)
    } else if ((SIZE_T)(size + StartAddress) > (SIZE_T)pImageData->FileSize) {
        //
        // The cast here is safe (FileSize is small)
        //
        StartAddress = (ULONG)(pImageData->FileSize - size);
    }

    if (size >= sizeof(DWORD)) {

        ULONG ulCarry;

        lpdw = (LPDWORD)((LPBYTE)pImageData->pBase + StartAddress);

        for (i = 0; i < (INT)(size/sizeof(DWORD)); ++i) {

            if (PtrToUlong(lpdw) & 0x3) { // alignment fault fixup
                ulChecksum += *((DWORD UNALIGNED*)lpdw);
                lpdw++;
            } else {
                ulChecksum += *lpdw++;
            }

            ulCarry = ulChecksum & 1;
            ulChecksum >>= 1;

            if (ulCarry) {
                ulChecksum |= 0x80000000;
            }
        }
    }

    *pChecksum = ulChecksum;
    return TRUE;
}


BOOL
SdbpCheckVersion(
    IN  ULONGLONG qwDBFileVer,
    IN  ULONGLONG qwBinFileVer
    )
/*++
    Return: TRUE if the versions match, FALSE if they don't.

    Desc:   Checks a binary version from the db against the version from
            the file, including allowing for wildcards, which are represented
            in the DB by using FFFF for that word-sized portion of the version.
--*/
{
    WORD wDBSegment, wFileSegment;
    int  i;

    for (i = 3; i >= 0; --i) {
        //
        // Get the appropriate word out of the QWORD
        //
        wDBSegment = (WORD)(qwDBFileVer >> (16 * i));
        wFileSegment = (WORD)(qwBinFileVer >> (16 * i));

        //
        // The DB segment may be 0xFFFF, in which case it matches on
        // everything.
        //
        if (wDBSegment != wFileSegment && wDBSegment != 0xFFFF) {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
SdbpCheckUptoVersion(
    IN  ULONGLONG qwDBFileVer,
    IN  ULONGLONG qwBinFileVer
    )
/*++
    Return: TRUE if the versions match, FALSE if they don't.

    Desc:   Checks a binary version from the db against the version from
            the file, including allowing for wildcards, which are represented
            in the DB by using FFFF for that word-sized portion of the version.
--*/
{
    WORD wDBSegment, wFileSegment;
    BOOL bReturn = TRUE;
    int  i;

    for (i = 3; i >= 0; --i) {
        //
        // Get the appropriate word out of the QWORD
        //
        wDBSegment = (WORD)(qwDBFileVer >> (16 * i));
        wFileSegment = (WORD)(qwBinFileVer >> (16 * i));

        if (wDBSegment == wFileSegment || wDBSegment == 0xFFFF) {
            continue;
        }

        //
        // At this point we know that the two values don't match
        // the wFileSegment has to be less than wDBSegment to satisfy this
        // test - so set bReturn and exit
        //

        bReturn = (wDBSegment > wFileSegment);
        break;

    }

    return bReturn;
}


#ifndef KERNEL_MODE

BOOL
SdbFormatAttribute(
    IN  PATTRINFO pAttrInfo,    // pointer to the attribute information
    OUT LPTSTR    pchBuffer,    // receives XML corresponding to the given attribute
    IN  DWORD     dwBufferSize  // size in wide characters of the buffer pchBuffer
    )
/*++
    Return: FALSE if the buffer is too small or attribute not available.

    Desc:   TBD.
--*/
{
    size_t cchRemaining;
    TCHAR* pszEnd = NULL;
    HRESULT hr;

#if defined(WIN32A_MODE) || defined(WIN32U_MODE)
    struct tm* ptm;
    time_t tt;
#else
    LARGE_INTEGER liTime;
    TIME_FIELDS   TimeFields;
#endif

    if (!(pAttrInfo->dwFlags & ATTRIBUTE_AVAILABLE)) {
        return FALSE;
    }

    hr = StringCchPrintfEx(pchBuffer,
                           (int)dwBufferSize,
                           &pszEnd,
                           &cchRemaining,
                           0,
                           TEXT("%s="),
                           SdbTagToString(pAttrInfo->tAttrID));

    if (FAILED(hr)) {
        DBGPRINT((sdlError,
                  "SdbFormatAttribute",
                  "Buffer is too small to accomodate \"%s\"\n",
                  SdbTagToString(pAttrInfo->tAttrID)));
        return FALSE;
    }

    switch (pAttrInfo->tAttrID) {
    case TAG_BIN_PRODUCT_VERSION:
    case TAG_BIN_FILE_VERSION:
    case TAG_UPTO_BIN_PRODUCT_VERSION:
    case TAG_UPTO_BIN_FILE_VERSION:
        hr = StringCchPrintf(pszEnd,
                             cchRemaining,
                             TEXT("\"%d.%d.%d.%d\""),
                             (WORD)(pAttrInfo->ullAttr >> 48),
                             (WORD)(pAttrInfo->ullAttr >> 32),
                             (WORD)(pAttrInfo->ullAttr >> 16),
                             (WORD)(pAttrInfo->ullAttr));
        break;

    case TAG_MODULE_TYPE:
        hr = StringCchPrintf(pszEnd,
                             cchRemaining,
                             TEXT("\"%s\""),
                             SdbpModuleTypeToString(pAttrInfo->dwAttr));
        break;


    case TAG_VER_LANGUAGE:
        //
        // language is a dword attribute that we shall make a string out of
        //
        {
            TCHAR szLanguageName[MAX_PATH];
            DWORD dwLength;

            szLanguageName[0] = TEXT('\0');

            dwLength = VerLanguageName((LANGID)pAttrInfo->dwAttr,
                                       szLanguageName,
                                       CHARCOUNT(szLanguageName));

            if (dwLength) {
                hr = StringCchPrintf(pszEnd,
                                     cchRemaining,
                                     TEXT("\"%s [0x%x]\""),
                                     szLanguageName,
                                     pAttrInfo->dwAttr);
            } else {
                hr = StringCchPrintf(pszEnd,
                                     cchRemaining,
                                     TEXT("\"0x%x\""),
                                     pAttrInfo->dwAttr);
            }

        }
        break;

    case TAG_LINK_DATE:
    case TAG_UPTO_LINK_DATE:

#if defined(WIN32A_MODE) || defined(WIN32U_MODE)

        tt = (time_t) pAttrInfo->dwAttr;
        ptm = gmtime(&tt);
        if (ptm) {
            hr = StringCchPrintf(pszEnd,
                                 cchRemaining,
                                 TEXT("\"%02d/%02d/%02d %02d:%02d:%02d\""),
                                 ptm->tm_mon+1,
                                 ptm->tm_mday,
                                 ptm->tm_year+1900,
                                 ptm->tm_hour,
                                 ptm->tm_min,
                                 ptm->tm_sec);
        }
#else
        RtlSecondsSince1970ToTime((ULONG)pAttrInfo->dwAttr, &liTime);
        RtlTimeToTimeFields(&liTime, &TimeFields);
        hr = StringCchPrintf(pszEnd,
                             cchRemaining,
                             TEXT("\"%02d/%02d/%02d %02d:%02d:%02d\""),
                             TimeFields.Month,
                             TimeFields.Day,
                             TimeFields.Year,
                             TimeFields.Hour,
                             TimeFields.Minute,
                             TimeFields.Second);

#endif
        break;

    case TAG_SIZE:
        hr = StringCchPrintf(pszEnd,
                             cchRemaining,
                             TEXT("\"%ld\""),
                             pAttrInfo->dwAttr);
        break;

    default:

        switch (GETTAGTYPE(pAttrInfo->tAttrID)) {
        case TAG_TYPE_DWORD:
            hr = StringCchPrintf(pszEnd,
                                 cchRemaining,
                                 TEXT("\"0x%lX\""),
                                 pAttrInfo->dwAttr);
            break;

        case TAG_TYPE_QWORD:
            //
            // This is an unidentified QWORD attribute
            //
            DBGPRINT((sdlError, "SdbFormatAttribute", "Unexpected qword attribute found\n"));
            hr = StringCchPrintf(pszEnd,
                                 cchRemaining,
                                 TEXT("\"0x%I64X\""),
                                 pAttrInfo->ullAttr);
            break;

        case TAG_TYPE_STRINGREF:
            if (cchRemaining < 3) {
                return FALSE; // not enough room even for " ?
            }

            *pszEnd++ = TEXT('\"');
            cchRemaining--;

            if (!SdbpSanitizeXML(pszEnd, (int)cchRemaining, pAttrInfo->lpAttr)) {
                // handle error please
                return FALSE;
            }

            //
            // Once done with this, sanitize further
            //
            if (!SafeNCat(pszEnd, (int)cchRemaining, TEXT("\""), -1)) {
                return FALSE;
            }

            hr = S_OK;
            break;
        }
    }

    return (hr == S_OK); // evaluates to TRUE when we successfully printed the value into the buffer
}

BOOL
SdbpGetVersionAttributes(
    IN  PSDBCONTEXT pContext,
    OUT PFILEINFO   pFileInfo
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves all of the Version-related attributes
            Imports apis from version.dll if called for the first time
--*/
{
    DWORD               dwNull = 0;
    VS_FIXEDFILEINFO*   pFixedInfo    = NULL; // fixed info ptr
    UINT                FixedInfoSize = 0;
    PVOID               pBuffer       = NULL; // version data buffer
    DWORD               dwBufferSize;         // version data buffer size
    int                 i;

#ifdef NT_MODE
    //
    // check to see whether we need to run NT routine
    //
    if (pFileInfo->hFile != INVALID_HANDLE_VALUE || pFileInfo->pImageBase != NULL) {

        //
        // not an error -- this case is handled in header attributes
        //

        goto err;
    }

#endif // NT_MODE

    if (pContext == NULL) {
        //
        // Special case when it's called with null context.
        // In this case we use an internal structure allocated from the stack.
        //
        STACK_ALLOC(pContext, sizeof(SDBCONTEXT));

        if (pContext == NULL) {
            DBGPRINT((sdlError,
                      "SdbpGetVersionAttributes",
                      "Failed to allocate %d bytes from stack\n",
                      sizeof(SDBCONTEXT)));
            goto err;
        }

        RtlZeroMemory(pContext, sizeof(SDBCONTEXT));
    }

#ifdef WIN32A_MODE

    pContext->pfnGetFileVersionInfoSize = GetFileVersionInfoSizeA;
    pContext->pfnGetFileVersionInfo     = GetFileVersionInfoA;
    pContext->pfnVerQueryValue          = VerQueryValueA;

#else

    pContext->pfnGetFileVersionInfoSize = GetFileVersionInfoSizeW;
    pContext->pfnGetFileVersionInfo     = GetFileVersionInfoW;
    pContext->pfnVerQueryValue          = VerQueryValueW;

#endif

    dwBufferSize = pContext->pfnGetFileVersionInfoSize(pFileInfo->FilePath, &dwNull);

    if (dwBufferSize == 0) {
        DBGPRINT((sdlInfo, "SdbpGetVersionAttributes", "No version info.\n"));
        //
        // We have failed to obtain version attributes
        //
        goto err;
    }

    pBuffer = SdbAlloc(dwBufferSize + VERSIONINFO_BUFFER_PAD);

    if (pBuffer == NULL) {
        DBGPRINT((sdlError,
                  "SdbpGetVersionAttributes",
                  "Failed to allocate %d bytes for version info buffer.\n",
                  dwBufferSize + VERSIONINFO_BUFFER_PAD));
        goto err;
    }

    if (!pContext->pfnGetFileVersionInfo(pFileInfo->FilePath, 0, dwBufferSize, pBuffer)) {
        DBGPRINT((sdlError,
                  "SdbpGetVersionAttributes",
                  "Failed to retrieve version info for file \"%s\"",
                  pFileInfo->FilePath));
        goto err;
    }

    if (!pContext->pfnVerQueryValue(pBuffer,
                                    TEXT("\\"),
                                    (PVOID*)&pFixedInfo,
                                    &FixedInfoSize)) {
        DBGPRINT((sdlError,
                  "SdbpGetVersionAttributes",
                  "Failed to query for fixed version info size for \"%s\"\n",
                  pFileInfo->FilePath));
        goto err;
    }

    //
    // Retrieve string attributes.
    //
    SdbpQueryStringVersionInformation(pContext, pFileInfo, pBuffer);

    //
    // Now retrieve other attributes.
    //
    if (FixedInfoSize >= sizeof(VS_FIXEDFILEINFO)) {

        SdbpQueryBinVersionInformation(pContext, pFileInfo, pFixedInfo);

    } else {
        //
        // No other version attributes are available. Set the rest of the
        // attributes as being not available.
        //
        for (i = 0; i < ARRAYSIZE(g_rgBinVerTags); ++i) {
            SdbpSetAttribute(pFileInfo, g_rgBinVerTags[i], NULL);
        }
    }

    //
    // Store the pointer to the version info buffer.
    //
    pFileInfo->pVersionInfo = pBuffer;
    return TRUE;

err:
    //
    // We are here ONLY when we failed to obtain version info
    // through apis -- regardless of the state of other value we might have
    // obtained

    if (pBuffer != NULL) {
        SdbFree(pBuffer);
    }

    for (i = 0; i < ARRAYSIZE(g_rgBinVerTags); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgBinVerTags[i], NULL);
    }

    for (i = 0; i < ARRAYSIZE(g_rgVerStrings); ++i) {
        SdbpSetAttribute(pFileInfo, g_rgVerStrings[i].tTag, NULL);
    }

    return FALSE;
}

BOOL
SdbpGetFileDirectoryAttributes(
    OUT PFILEINFO pFileInfo
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves the file directory attributes for the
            specified file.
--*/
{
    BOOL                    bSuccess = FALSE;
    FILEDIRECTORYATTRIBUTES fda;
    int                     i;

    bSuccess = SdbpQueryFileDirectoryAttributes(pFileInfo->FilePath, &fda);

    if (!bSuccess) {
        DBGPRINT((sdlInfo,
                  "SdbpGetFileDirectoryAttributes",
                  "No file directory attributes available.\n"));
        goto Done;
    }

    if (fda.dwFlags & FDA_FILESIZE) {
        assert(fda.dwFileSizeHigh == 0);
        SdbpSetAttribute(pFileInfo, TAG_SIZE, &fda.dwFileSizeLow);
    }

Done:

    if (!bSuccess) {
        for (i = 0; g_rgDirectoryTags[i] != 0; ++i) {
            SdbpSetAttribute(pFileInfo, g_rgDirectoryTags[i], NULL);
        }
    }

    return bSuccess;
}

BOOL
SdbGetFileAttributes(
    IN  LPCTSTR    lpwszFileName,   // the file for which attributes are requested
    OUT PATTRINFO* ppAttrInfo,      // receives allocated pointer to the attribute array
    OUT LPDWORD    lpdwAttrCount    // receives the number of entries in an attributes table
    )
/*++
    Return: FALSE if the file does not exist or some other severe error had occured.
            Note that each attribute has it's own flag ATTRIBUTE_AVAILABLE that allows
            for checking whether an attribute has been retrieved successfully
            Not all attributes might be present for all files.

    Desc:   TBD
--*/
{
    PFILEINFO pFileInfo;
    BOOL      bReturn;

    //
    // The call below allocates the structure, context is not used
    //
    pFileInfo = SdbGetFileInfo(NULL, lpwszFileName, INVALID_HANDLE_VALUE, NULL, 0, TRUE);

    if (pFileInfo == NULL) {
        DBGPRINT((sdlError, "SdbGetFileAttributes", "Error retrieving FILEINFO structure\n"));
        return FALSE;
    }

    //
    // The three calls below, even when fail do not produce a fatal condition
    // as the exe may not have all the attributes available.
    //
    bReturn = SdbpGetFileDirectoryAttributes(pFileInfo);
    if (!bReturn) {
        DBGPRINT((sdlInfo, "SdbGetFileAttributes", "Error retrieving directory attributes\n"));
    }

    bReturn = SdbpGetVersionAttributes(NULL, pFileInfo);
    if (!bReturn) {
        DBGPRINT((sdlInfo, "SdbGetFileAttributes", "Error retrieving version attributes\n"));
    }

    bReturn = SdbpGetHeaderAttributes(NULL, pFileInfo);
    if (!bReturn) {
        DBGPRINT((sdlInfo, "SdbGetFileAttributes", "Error retrieving header attributes\n"));
    }

    pFileInfo->dwMagic = FILEINFO_MAGIC;

    //
    // Now that we are done, put the return pointer.
    //
    if (lpdwAttrCount != NULL) {
        *lpdwAttrCount = ATTRIBUTE_COUNT;
    }

    if (ppAttrInfo != NULL) {

        //
        // Return the pointer to the attribute info itself.
        // It is the same pointer we expect to get in a complimentary
        // call to SdbFreeFileInfo.
        //
        *ppAttrInfo = &pFileInfo->Attributes[0];

    } else {

        //
        // Pointer is not needed. Release the memory.
        //
        SdbFreeFileInfo(pFileInfo);
    }

    return TRUE;
}

BOOL
SdbFreeFileAttributes(
    IN  PATTRINFO pFileAttributes   // pointer returned by SdbGetFileAttributes
    )
/*++
    Return: FALSE if a wrong pointer was passed in (not the one
            from SdbGetFileAttributes).

    Desc:   Self explanatory.
--*/
{
    PFILEINFO pFileInfo;

    //
    // We are assuming the pointer that was passed in points inside of a
    // larger structure FILEINFO. To verify that we step back a pre-determined number
    // of bytes (calculated below as an offset) and check the "magic" signature.
    //
    pFileInfo = (PFILEINFO)((PBYTE)pFileAttributes - OFFSETOF(FILEINFO, Attributes));

    if (pFileInfo->dwMagic != FILEINFO_MAGIC) {
        DBGPRINT((sdlError, "SdbFreeFileAttributes", "Bad pointer to attributes.\n"));
        return FALSE;
    }

    SdbFreeFileInfo(pFileInfo);

    return TRUE;
}

BOOL
SdbpQuery16BitDescription(
    OUT LPSTR szBuffer,             // min length 256 chars !
    IN  PIMAGEFILEDATA pImageData
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Gets the 16 bit description for a DOS executable.
--*/
{
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_OS2_HEADER pNEHeader;
    PBYTE             pSize;
    DWORD             ModuleType;

    if (!SdbpGetModuleType(&ModuleType, pImageData)) {
        return FALSE;
    }

    if (ModuleType != MT_W16_MODULE) {
        return FALSE;
    }

    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;
    pNEHeader  = (PIMAGE_OS2_HEADER)((PBYTE)pImageData->pBase + pDosHeader->e_lfanew);

    //
    // Now we know that pNEHeader is valid, just have to make sure that
    // the next offset is valid as well, make a check against file size.
    //
    if (pImageData->ViewSize < pDosHeader->e_lfanew + sizeof(*pNEHeader)) {
        return FALSE;
    }

    if (pImageData->ViewSize < pNEHeader->ne_nrestab + sizeof(*pSize)) {
        return FALSE;
    }

    pSize = (PBYTE)((PBYTE)pImageData->pBase + pNEHeader->ne_nrestab);

    if (*pSize == 0) {
        return FALSE;
    }

    //
    // Now check for the string size.
    //
    if (pImageData->ViewSize < pNEHeader->ne_nrestab + sizeof(*pSize) + *pSize) {
        return FALSE;
    }

    RtlCopyMemory(szBuffer, pSize + 1, *pSize);
    szBuffer[*pSize] = '\0';

    return TRUE;
}

BOOL
SdbpQuery16BitModuleName(
    OUT LPSTR          szBuffer,
    IN  PIMAGEFILEDATA pImageData
    )
{
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_OS2_HEADER pNEHeader;
    PBYTE             pSize;
    DWORD             ModuleType;

    if (!SdbpGetModuleType(&ModuleType, pImageData)) {
        return FALSE;
    }

    if (ModuleType != MT_W16_MODULE) {
        return FALSE;
    }

    pDosHeader = (PIMAGE_DOS_HEADER)pImageData->pBase;
    pNEHeader  = (PIMAGE_OS2_HEADER)((PBYTE)pImageData->pBase + pDosHeader->e_lfanew);

    //
    // Now we know that pNEHeader is valid, just have to make sure that
    // the next offset is valid as well, make a check against file size.
    //
    if (pImageData->ViewSize < pDosHeader->e_lfanew + sizeof(*pNEHeader)) {
        return FALSE;
    }

    if (pImageData->ViewSize < pNEHeader->ne_restab + sizeof(*pSize)) {
        return FALSE;
    }

    pSize = (PBYTE)((PBYTE)pImageData->pBase + pDosHeader->e_lfanew + pNEHeader->ne_restab);

    if (*pSize == 0) {
        return FALSE;
    }

    //
    // Now check for the string size.
    //
    if (pImageData->ViewSize <
        pDosHeader->e_lfanew + pNEHeader->ne_restab + sizeof(*pSize) + *pSize) {

        return FALSE;
    }

    RtlCopyMemory(szBuffer, pSize + 1, *pSize);
    szBuffer[*pSize] = '\0';

    return TRUE;
}

#endif // KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\sdbapi\dbaccess.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        dbaccess.c

    Abstract:

        This module implements APIs to access the shim database.

    Author:

        dmunsil     created     sometime in 1999

    Revision History:

        several people contributed (vadimb, clupu, ...)

--*/

#include "sdbp.h"

#if defined(KERNEL_MODE) && defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, SdbReleaseDatabase)
#pragma alloc_text(PAGE, SdbGetDatabaseVersion)
#pragma alloc_text(PAGE, SdbGetDatabaseInformation)
#pragma alloc_text(PAGE, SdbGetDatabaseID)
#pragma alloc_text(PAGE, SdbFreeDatabaseInformation)
#pragma alloc_text(PAGE, SdbGetDatabaseInformationByName)
#pragma alloc_text(PAGE, SdbpGetDatabaseDescriptionPtr)
#pragma alloc_text(PAGE, SdbpReadMappedData)
#pragma alloc_text(PAGE, SdbpGetMappedData)
#pragma alloc_text(PAGE, SdbOpenDatabase)
#pragma alloc_text(PAGE, SdbpOpenDatabaseInMemory)
#pragma alloc_text(PAGE, SdbCloseDatabaseRead)
#pragma alloc_text(PAGE, SdbpOpenAndMapDB)
#pragma alloc_text(PAGE, SdbpUnmapAndCloseDB)
#pragma alloc_text(PAGE, SdbGetTagFromTagID)
#pragma alloc_text(PAGE, SdbpGetNextTagId)
#pragma alloc_text(PAGE, SdbGetFirstChild)
#pragma alloc_text(PAGE, SdbGetNextChild)
#pragma alloc_text(PAGE, SdbpCreateSearchPathPartsFromPath)
#endif // KERNEL_MODE && ALLOC_PRAGMA



void
SdbReleaseDatabase(
    IN  HSDB hSDB               // handle to the database channel
    )
/*++
    Return: void.

    Desc:   This API should be called in pair with SdbInitDatabase.
--*/
{
    PSDBCONTEXT pContext = (PSDBCONTEXT)hSDB;

    assert(pContext != NULL);

    //
    // Do everything under a try/except block so we don't screw the caller
    // if the databases are corrupt.
    //
    __try {

#ifndef KERNEL_MODE

        SdbpCleanupLocalDatabaseSupport(hSDB);

        if (pContext->rgSDB[2].dwFlags & SDBENTRY_VALID_ENTRY) {
            SdbCloseDatabaseRead(pContext->rgSDB[2].pdb);
        }

#endif // KERNEL_MODE

        if (pContext->pdbTest != NULL) {
            SdbCloseDatabaseRead(pContext->pdbTest);
        }

        if (pContext->pdbMain != NULL) {
            SdbCloseDatabaseRead(pContext->pdbMain);
        }

        //
        // Cleanup attributes.
        //
        SdbpCleanupAttributeMgr(pContext);

#ifndef KERNEL_MODE

        //
        // Cleanup user sdb cache
        //
        SdbpCleanupUserSDBCache(pContext);

#endif // KERNEL_MODE

        SdbFree(pContext);

    } __except (SHIM_EXCEPT_HANDLER) {
        ;
    }
}

BOOL
SdbGetDatabaseVersion(
    IN  LPCTSTR pszFileName,    // the file name
    OUT LPDWORD lpdwMajor,      // store the major version of the database
    OUT LPDWORD lpdwMinor       // store the minor version of the database
    )
/*++
    Return: void.

    Desc:   This API should be called in pair with SdbInitDatabase.
--*/
{
    PDB             pdb;
    SDBDATABASEINFO DBInfo;

    pdb = SdbAlloc(sizeof(DB));

    if (pdb == NULL) {
        DBGPRINT((sdlError, "SdbGetDatabaseVersion", "Can't allocate DB structure.\n"));
        return FALSE;
    }

    if (!SdbpOpenAndMapDB(pdb, pszFileName, DOS_PATH)) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseVersion",
                  "Failed to open the database \"%s\".\n",
                  pszFileName));
        goto err1;
    }

    pdb->bWrite = FALSE;
    pdb->dwSize = SdbpGetFileSize(pdb->hFile);

    if (!SdbGetDatabaseInformation(pdb, &DBInfo)) {
        DBGPRINT((sdlError, "SdbGetDatabaseVersion", "Can't read database information.\n"));
        goto err2;
    }

    *lpdwMajor = DBInfo.dwVersionMajor;
    *lpdwMinor = DBInfo.dwVersionMinor;

err2:
    SdbpUnmapAndCloseDB(pdb);

err1:
    SdbFree(pdb);

    return TRUE;
}

BOOL
SDBAPI
SdbGetDatabaseInformation(
    IN  PDB              pdb,
    OUT PSDBDATABASEINFO pSdbInfo
    )
{
    DB_HEADER DBHeader;
    BOOL      bReturn = FALSE;

    RtlZeroMemory(pSdbInfo, sizeof(*pSdbInfo));

    if (!SdbpReadMappedData(pdb, 0, &DBHeader, sizeof(DB_HEADER))) {
        DBGPRINT((sdlError, "SdbGetDatabaseInformation", "Can't read database header.\n"));
        goto errHandle;
    }

    if (DBHeader.dwMagic != SHIMDB_MAGIC) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseInformation",
                  "Magic doesn't match. Magic: 0x%08X, Expected: 0x%08X.\n",
                  DBHeader.dwMagic,
                  (DWORD)SHIMDB_MAGIC));
        goto errHandle;
    }

    pSdbInfo->dwVersionMajor = DBHeader.dwMajorVersion;
    pSdbInfo->dwVersionMinor = DBHeader.dwMinorVersion;

    //
    // Id and description are optional
    //
    if (SdbGetDatabaseID(pdb, &pSdbInfo->guidDB)) {
        pSdbInfo->dwFlags |= DBINFO_GUID_VALID;
    }

    //
    // Now try to get valid description.
    //
    pSdbInfo->pszDescription = (LPTSTR)SdbpGetDatabaseDescriptionPtr(pdb);

    bReturn = TRUE;

errHandle:

    return bReturn;
}

BOOL
SDBAPI
SdbGetDatabaseID(
    IN  PDB   pdb,
    OUT GUID* pguidDB
    )
{
    TAGID tiDatabase;
    TAGID tiGuidID;
    BOOL  bReturn = FALSE;

    if (!(pdb->dwFlags & DB_GUID_VALID)) {
        tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
        if (!tiDatabase) {
            DBGPRINT((sdlError, "SdbGetDatabaseID", "Failed to get root tag\n"));
            goto errHandle;
        }

        tiGuidID = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);
        if (!tiGuidID) {
            DBGPRINT((sdlWarning, "SdbGetDatabaseID", "Failed to get the database id\n"));
            goto errHandle;
        }

        if (!SdbReadBinaryTag(pdb, tiGuidID, (PBYTE)&pdb->guidDB, sizeof(GUID))) {
            DBGPRINT((sdlError,
                      "SdbGetDatabaseID",
                      "Failed to read database id 0x%lx\n",
                      tiGuidID));
            goto errHandle;
        }

        pdb->dwFlags |= DB_GUID_VALID;
    }

    //
    // If we are here, GUID retrieval was successful.
    //
    if (pdb->dwFlags & DB_GUID_VALID) {
        RtlMoveMemory(pguidDB, &pdb->guidDB, sizeof(GUID));
        bReturn = TRUE;
    }

errHandle:

    return bReturn;
}

VOID
SDBAPI
SdbFreeDatabaseInformation(
    IN PSDBDATABASEINFO pDBInfo
    )
{
    if (pDBInfo != NULL && (pDBInfo->dwFlags & DBINFO_SDBALLOC)) {
        SdbFree(pDBInfo);
    }
}


BOOL
SDBAPI
SdbGetDatabaseInformationByName(
    IN  LPCTSTR           pszDatabase,
    OUT PSDBDATABASEINFO* ppdbInfo
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   This function retrieves database information given the database name
            the pointer to the SDBDATABASEINFO should be freed by the caller using
            SdbFreeDatabaseInformation
--*/
{
    PDB              pdb = NULL;
    DWORD            dwDescriptionSize = 0;
    PSDBDATABASEINFO pDbInfo = NULL;
    BOOL             bReturn = FALSE;
    SDBDATABASEINFO  DbInfo;

    assert(ppdbInfo != NULL);

    pdb = SdbOpenDatabase(pszDatabase, DOS_PATH);
    if (pdb == NULL) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseInformationByName",
                  "Error opening database file \"%s\"\n",
                  pszDatabase));
        return FALSE;
    }

    //
    // Find the size of the database description
    //
    if (!SdbGetDatabaseInformation(pdb, &DbInfo)) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseInformationByName",
                  "Error Retrieving Database information for \"%s\"\n",
                  pszDatabase));
        goto HandleError;
    }

    if (DbInfo.pszDescription != NULL) {
        dwDescriptionSize = (DWORD)(_tcslen(DbInfo.pszDescription) + 1) * sizeof(TCHAR);
    }

    pDbInfo = (PSDBDATABASEINFO)SdbAlloc(sizeof(SDBDATABASEINFO) + dwDescriptionSize);
    if (pDbInfo == NULL) {
        DBGPRINT((sdlError,
                  "SdbGetDatabaseInformationByName",
                  "Error allocating 0x%lx bytes for database information \"%s\"\n",
                  sizeof(SDBDATABASEINFO) + dwDescriptionSize,
                  pszDatabase));
        goto HandleError;
    }

    RtlMoveMemory(pDbInfo, &DbInfo, sizeof(DbInfo));

    pDbInfo->dwFlags |= DBINFO_SDBALLOC;

    //
    // Make it "self-contained"
    //
    if (DbInfo.pszDescription != NULL) {
        pDbInfo->pszDescription = (LPTSTR)(pDbInfo + 1);
        RtlMoveMemory(pDbInfo->pszDescription, DbInfo.pszDescription, dwDescriptionSize);
    }

    *ppdbInfo = pDbInfo;
    bReturn = TRUE;

HandleError:
    if (pdb != NULL) {
        SdbCloseDatabaseRead(pdb);
    }

    if (!bReturn) {
        if (pDbInfo != NULL) {
            SdbFree(pDbInfo);
        }
    }

    return bReturn;
}


LPCTSTR
SdbpGetDatabaseDescriptionPtr(
    IN PDB pdb
    )
{
    TAGID   tiDatabase;
    TAGID   tiName;
    LPCTSTR lpszDescription = NULL;

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (!tiDatabase) {
        DBGPRINT((sdlError,
                  "SdbpGetDatabaseDescriptionPtr",
                  "Failed to get database tag, db is corrupt\n"));
        goto errHandle;
    }

    tiName = SdbFindFirstTag(pdb, tiDatabase, TAG_NAME);
    if (tiName) {
        lpszDescription = SdbGetStringTagPtr(pdb, tiName);
    }

errHandle:
    return lpszDescription;
}


BOOL
SdbpReadMappedData(
    IN  PDB   pdb,              // database handle
    IN  DWORD dwOffset,         // offset in the database where the data is to be copied from
    OUT PVOID pBuffer,          // destination buffer
    IN  DWORD dwSize            // the region size
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   This function reads the data (dwSize bytes) from the database
            starting at offset dwOffset into the buffer pBuffer provided
            by the caller
--*/
{

    if (pdb->dwSize < dwOffset + dwSize) {
        DBGPRINT((sdlError,
                  "SdbpReadMappedData",
                  "Attempt to read past the end of the database offset 0x%lx size 0x%lx (0x%lx)\n",
                  dwOffset,
                  dwSize,
                  pdb->dwSize));
        return FALSE;
    }

    assert(pdb->pBase != NULL);

    memcpy(pBuffer, (PBYTE)pdb->pBase + dwOffset, dwSize);
    return TRUE;
}

PVOID
SdbpGetMappedData(
    IN  PDB   pdb,              // database handle
    IN  DWORD dwOffset          // offset in the database
    )
/*++
    Return: The pointer to the data.

    Desc:   This function returns the pointer to data within the database at
            offset dwOffset. It will return FALSE if dwOffset is invalid.
--*/
{
    assert(pdb);

    assert(pdb->pBase != NULL);

    if (dwOffset >= pdb->dwSize) {
        DBGPRINT((sdlError,
                  "SdbpGetMappedData",
                  "Trying to read mapped data past the end of the database offset 0x%x size 0x%x\n",
                  dwOffset,
                  pdb->dwSize));
        assert(FALSE);
        return NULL;
    }

    return (PBYTE)pdb->pBase + dwOffset;
}


PDB
SdbOpenDatabase(
    IN  LPCTSTR   szPath,       // full path to the DB
    IN  PATH_TYPE eType         // DOS_PATH for standard paths,
                                // NT_PATH  for internal NT paths
    )
/*++
    Return: A pointer to the open DB, or NULL on failure.

    Desc:   Opens up a shim database file, checks version and magic numbers, and creates
            a DB record that is passed back as a PDB. eType can be NT_PATH or DOS_PATH,
            and tells whether we are using NTDLL internal paths, or the more familiar
            DOS paths.
--*/
{
    PDB         pdb;
    DB_HEADER   DBHeader;

    pdb = SdbAlloc(sizeof(DB));

    if (pdb == NULL) {
        DBGPRINT((sdlError, "SdbOpenDatabase", "Can't allocate DB structure.\n"));
        return NULL;
    }

    if (!SdbpOpenAndMapDB(pdb, szPath, eType)) {
        DBGPRINT((sdlInfo,
                  "SdbOpenDatabase",
                  "Failed to open the database \"%s\".\n",
                  szPath));
        goto err1;
    }

    pdb->bWrite = FALSE;
    pdb->dwSize = SdbpGetFileSize(pdb->hFile);

    //
    // Check version and magic.
    //
    if (!SdbpReadMappedData(pdb, 0, &DBHeader, sizeof(DB_HEADER))) {
        DBGPRINT((sdlError, "SdbOpenDatabase", "Can't read database header.\n"));
        goto err2;
    }

    if (DBHeader.dwMagic != SHIMDB_MAGIC) {
        DBGPRINT((sdlError, "SdbOpenDatbase", "Magic does not match 0x%lx\n", DBHeader.dwMagic));
        goto err2;
    }

    if (DBHeader.dwMajorVersion == 1) {
        DBGPRINT((sdlWarning, "SdbOpenDatabase", "Reading under hack from older database\n"));
        pdb->bUnalignedRead = TRUE;
    } else if (DBHeader.dwMajorVersion != SHIMDB_MAJOR_VERSION) {

        DBGPRINT((sdlError, "SdbOpenDatabase",
                  "MajorVersion mismatch, MajorVersion 0x%lx Expected 0x%lx\n",
                  DBHeader.dwMajorVersion, (DWORD)SHIMDB_MAJOR_VERSION));
        goto err2;
    }

    if (DBHeader.dwMagic != SHIMDB_MAGIC || DBHeader.dwMajorVersion != SHIMDB_MAJOR_VERSION) {
        DBGPRINT((sdlError,
                  "SdbOpenDatabase",
                  "Magic or MajorVersion doesn't match."
                  "Magic: %08X, Expected: %08X; MajorVersion: %08X, Expected: %08X.\n",
                  DBHeader.dwMagic,
                  (DWORD)SHIMDB_MAGIC,
                  DBHeader.dwMajorVersion,
                  (DWORD)SHIMDB_MAJOR_VERSION));
        goto err2;
    }

    return pdb;

err2:
    SdbpUnmapAndCloseDB(pdb);

err1:
    SdbFree(pdb);

    return NULL;
}


PDB
SdbpOpenDatabaseInMemory(
    IN  LPVOID pImageDatabase,  // Pointer to the image of the mapped database
    IN  DWORD  dwSize           // the size of the file in bytes
    )
/*++
    Return: BUGBUG: ?

    Desc:   BUGBUG: ?
--*/
{
    PDB       pdb = NULL;
    DB_HEADER DBHeader;

    pdb = SdbAlloc(sizeof(DB));
    if (pdb == NULL) {
        DBGPRINT((sdlError,
                  "SdbpOpenDatabaseInMemory",
                  "Failed to allocate DB structure\n"));
        return NULL;
    }

    pdb->bWrite   = FALSE;
    pdb->hFile    = INVALID_HANDLE_VALUE;
    pdb->pBase    = pImageDatabase;
    pdb->dwSize   = dwSize;
    pdb->dwFlags |= DB_IN_MEMORY;

    if (!SdbpReadMappedData(pdb, 0, &DBHeader, sizeof(DB_HEADER))) {
        DBGPRINT((sdlError,
                  "SdbpOpenDatabaseInMemory",
                  "Can't read database header\n"));
        goto ErrHandle;
    }

    if (DBHeader.dwMagic != SHIMDB_MAGIC || DBHeader.dwMajorVersion != SHIMDB_MAJOR_VERSION) {
        DBGPRINT((sdlError,
                  "SdbpOpenDatabaseInMemory",
                  "Magic or MajorVersion doesn't match."
                  "Magic: %08X, Expected: %08X; MajorVersion: %08X, Expected: %08X.\n",
                  DBHeader.dwMagic,
                  (DWORD)SHIMDB_MAGIC,
                  DBHeader.dwMajorVersion,
                  (DWORD)SHIMDB_MAJOR_VERSION));
        goto ErrHandle;
    }

    return pdb;

ErrHandle:
    if (pdb != NULL) {
        SdbFree(pdb);
    }

    return NULL;
}


void
SdbCloseDatabaseRead(
    IN  PDB pdb                 // handle to the DB to close
    )
/*++
    Return: void.

    Desc:   Closes a database that was opened for read access as it is the case
            with the majority of our run-time code.
--*/
{
    assert(pdb);
    assert(!pdb->bWrite);

    if (pdb->pBase != NULL) {

        SdbpUnmapAndCloseDB(pdb);

        CLEANUP_STRING_CACHE_READ(pdb);

        SdbFree(pdb);
    }
}

BOOL
SdbpOpenAndMapDB(
    IN  PDB       pdb,          // pdb to fill in with mapping handles and whatnot
    IN  LPCTSTR   pszPath,      // full path of file to open
    IN  PATH_TYPE eType         // DOS_PATH for standard paths, NT_PATH for nt internal paths
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   Opens a db file, maps it into memory, and sets up the global vars in the pdb.
--*/
{
    IMAGEFILEDATA ImageData;

    ImageData.dwFlags = 0;

    if (!SdbpOpenAndMapFile(pszPath, &ImageData, eType)) {
        DBGPRINT((sdlInfo, "SdbpOpenAndMapDB", "Failed to open file \"%s\"\n", pszPath));
        return FALSE;
    }

    pdb->hFile    = ImageData.hFile;
    pdb->hSection = ImageData.hSection;
    pdb->pBase    = ImageData.pBase;
    pdb->dwSize   = (DWORD)ImageData.ViewSize;

    return TRUE;
}

BOOL
SdbpUnmapAndCloseDB(
    IN  PDB pdb                 // pdb to close the files and mapping info
    )
/*++
    Return: TRUE if successful, FALSE otherwise.

    Desc:   Cleans up for the specified database.
--*/
{
    BOOL          bReturn;
    IMAGEFILEDATA ImageData;

    if (pdb->dwFlags & DB_IN_MEMORY) {
        //
        // database in memory
        //
        pdb->pBase  = NULL;
        pdb->dwSize = 0;
        return TRUE;
    }

    ImageData.dwFlags  = 0;
    ImageData.hFile    = pdb->hFile;
    ImageData.hSection = pdb->hSection;
    ImageData.pBase    = pdb->pBase;

    bReturn = SdbpUnmapAndCloseFile(&ImageData);

    //
    // once we nuke the file -- reset values
    //
    if (bReturn) {
        pdb->hFile    = INVALID_HANDLE_VALUE;
        pdb->hSection = NULL;
        pdb->pBase    = NULL;
    }

    return bReturn;
}

TAG
SdbGetTagFromTagID(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiWhich           // record to get the tag for
    )
/*++
    Return: Just the TAG (the word-sized header) of the record.

    Desc:   Returns just the TAG that a TAGID points to.
--*/
{
    TAG tWhich = TAG_NULL;

    assert(pdb && tiWhich);

    if (!SdbpReadMappedData(pdb, (DWORD)tiWhich, &tWhich, sizeof(TAG))) {
        DBGPRINT((sdlError, "SdbGetTagFromTagID", "Error reading data.\n"));
        return TAG_NULL;
    }

    return tWhich;
}


TAGID
SdbpGetNextTagId(
    IN  PDB   pdb,              // DB to look in
    IN  TAGID tiWhich           // tag to get the next sibling of
    )
/*++
    Return: The next tag after the one passed in, or one past end of file if no more.

    Desc:   Gets the TAGID of the next tag in the DB, or a virtual
            TAGID that is one past the end of the file, which means
            there are no more tags in the DB.

            This is an internal function, and shouldn't be called by
            external functions, as there's no clean way to tell you've
            walked off the end of the file. Use tiGetNextChildTag instead.
--*/
{
    //
    // If the tag is an unfinished list tag, point to the end of the file.
    //
    DWORD dwHeadSize;
    DWORD dwDataSize;

    if (GETTAGTYPE(SdbGetTagFromTagID(pdb, tiWhich)) == TAG_TYPE_LIST &&
        SdbGetTagDataSize(pdb, tiWhich) == TAG_SIZE_UNFINISHED) {

        DBGPRINT((sdlError, "SdbpGetNextTagId", "Reading from unfinished list.\n"));
        return pdb->dwSize;
    } else {
        //
        // be careful not to step off the end of the file
        //

        dwHeadSize = SdbpGetTagHeadSize(pdb, tiWhich);

        if (dwHeadSize == 0) {  // note that dwDataSize can be 0, while the head size can't
            return pdb->dwSize;
        }

        dwDataSize = SdbGetTagDataSize(pdb, tiWhich);
        if (!pdb->bUnalignedRead) {
            dwDataSize = (dwDataSize + 1) & (~1);
        }


        return (TAGID)(tiWhich + dwHeadSize + dwDataSize);
    }
}

TAGID
SdbGetFirstChild(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiParent          // parent to look in
    )
/*++
    Return: The first child of tiParent, or TAGID_NULL if there are none.

    Desc:   Returns the first child of tiParent, which must point to a tag
            of basic type LIST.
--*/
{
    TAGID tiParentEnd;
    TAGID tiReturn;

    assert(pdb);

    if (tiParent != TAGID_ROOT &&
        GETTAGTYPE(SdbGetTagFromTagID(pdb, tiParent)) != TAG_TYPE_LIST) {

        DBGPRINT((sdlError,
                  "SdbGetFirstChild",
                  "Trying to operate on non-list, non-root tag.\n"));
        return TAGID_NULL;
    }

    if (tiParent == TAGID_ROOT) {
        tiParentEnd = pdb->dwSize;

        //
        // Skip past the header.
        //
        tiReturn = sizeof(DB_HEADER);

    } else {
        tiParentEnd = SdbpGetNextTagId(pdb, tiParent);

        //
        // Just skip past the tag and size params.
        //
        tiReturn = tiParent + sizeof(TAG) + sizeof(DWORD);
    }


    if (tiReturn >= tiParentEnd) {
        tiReturn = TAGID_NULL;
    }

    return tiReturn;
}


TAGID
SdbGetNextChild(
    IN  PDB   pdb,              // DB to use
    IN  TAGID tiParent,         // parent to look in
    IN  TAGID tiPrev            // previously found child
    )
/*++
    Return: The next child of tiParent, or TAGID_NULL if there are none.

    Desc:   Returns the next child of tiParent after tiPrev. tiParent must point
            to a tag of basic type LIST.
--*/
{
    TAGID tiParentEnd;
    TAGID tiReturn;

    assert(pdb && tiPrev);

    if (tiParent != TAGID_ROOT &&
        GETTAGTYPE(SdbGetTagFromTagID(pdb, tiParent)) != TAG_TYPE_LIST) {

        DBGPRINT((sdlError,
                  "SdbGetNextChild",
                  "Trying to operate on non-list, non-root tag.\n"));
        return TAGID_NULL;
    }

    if (tiParent == TAGID_ROOT) {
        tiParentEnd = pdb->dwSize;
    } else {
        tiParentEnd = SdbpGetNextTagId(pdb, tiParent);
    }

    //
    // Get the next tag.
    //
    tiReturn = SdbpGetNextTagId(pdb, tiPrev);

    if (tiReturn >= tiParentEnd) {
        tiReturn = TAGID_NULL;
    }

    return tiReturn;
}


BOOL
SdbpCreateSearchPathPartsFromPath(
    IN  LPCTSTR           pszPath,
    OUT PSEARCHPATHPARTS* ppSearchPathParts
    )
/*++
    Return: Returns TRUE on success, FALSE on failure.

    Desc:   This function breaks down a search path (PROCESS_HISTORY) into
            parts, with each part specifying a directory where the search
            for a matching binary to take place. Directories are organized
            in such a way that the last executed binary provides the first
            search path.
--*/
{

    LPCTSTR          pszDir = pszPath;
    LPCTSTR          pszDirEnd = NULL;
    ULONG            nParts = 0;
    ULONG            i      = 0;
    PSEARCHPATHPARTS pSearchPathParts = NULL;

    if (pszPath == NULL) {
        DBGPRINT((sdlError,
                  "SdbpCreateSearchPathPartsFromPath",
                  "Invalid argument.\n"));
        return FALSE;
    }

    //
    // We count search path parts by counting semicolons in the path string
    // numberOfParts = numberOfSemicolons + 1
    //
    pszDir = pszPath;

    if (*pszDir != 0) {
        //
        // At least one part there...
        //
        nParts++;
    }

    while ((pszDir = _tcschr(pszDir, _T(';'))) != NULL) {
        pszDir++;
        nParts++;
    }

    //
    // nParts now has the number of parts in a search path.
    //
    pSearchPathParts = (PSEARCHPATHPARTS)SdbAlloc(sizeof(SEARCHPATHPARTS) +
                                                  sizeof(SEARCHPATHPART) * (nParts - 1));

    if (pSearchPathParts == NULL) {
        DBGPRINT((sdlError,
                  "SdbpCreateSearchPathPartsFromPath",
                  "Failed to allocate %d bytes.\n",
                  sizeof(SEARCHPATHPARTS) + sizeof(SEARCHPATHPART) * nParts));
        return FALSE;
    }

    pSearchPathParts->PartCount = nParts;

    pszDir = pszPath + _tcslen(pszPath);

    while (pszDir >= pszPath) {
        if (*pszDir == _T('\\') && pszDirEnd == NULL) {
            //
            // Points to the backslash
            //
            pszDirEnd = pszDir;
        }

        if ((*pszDir == _T(';') || pszPath == pszDir) && pszDirEnd != NULL) {
            //
            // At this point we should have an end to the string,
            // If not that means we are stepping from a recently found path
            //
            if (*pszDir == _T(';')) {
                pszDir++;
            }

            pSearchPathParts->Parts[i].pszPart    = pszDir;
            pSearchPathParts->Parts[i].PartLength = (ULONG)(pszDirEnd - pszDir + 1);

            i++;

            pszDirEnd = NULL;

        }

        pszDir--;
    }

    *ppSearchPathParts = pSearchPathParts;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\exts\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS2       g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS3 g_ExtSystem;



HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);


#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) ((LONG64) (LONG) PageSize - 1))))

extern ULONG PageSize;

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\sdbapi\dllmain.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        dllmain.c

    Abstract:

        BUGBUG: This module implements ...

    Author:

        clupu     created     sometime in 2000

    Revision History:

--*/

#include "sdbp.h"

BOOL APIENTRY
DllMain(
    HANDLE hModule, 
    DWORD  ul_reason, 
    LPVOID lpReserved
    )
{
    return TRUE;

    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(ul_reason);
    UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\sdbapi\dbaccessplus.c ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        dbaccessplus.c

    Abstract:

        This module implements APIs to access the shim database.

    Author:

        clupu     created     sometime in 2001

    Revision History:

        several people contributed (vadimb, dmunsil, ...)

--*/

#include "sdbp.h"

//
// This file is not included for KERNEL_MODE
//

//
// SdbInitDatabase is not used in Kernel mode. SdbInitDatabaseInMemory is used instead
//
HSDB
SdbInitDatabase(
    IN  DWORD   dwFlags,        // flags that tell how the database should be
                                // initialized.
    IN  LPCTSTR pszDatabasePath // the OPTIONAL full path to the database to be used.
    )
/*++
    Return: A handle to the database.

    Desc:   This is the first API someone needs to call to initiate comunication
            with the database. Should be paired with a call to SdbReleaseDatabase
            when finished.

            HID_DATABASE_FULLPATH indicates that pszDatabasePath points to the full path of the
                                  main database, when this flag is not present and pszDatabasePath
                                  is not NULL we treat it as the directory where sysmain.sdb and
                                  systest.sdb are to be found

            HID_DOS_PATHS         indicates the format of the pszDatabasePath: when this flag is
                                  present, we treat it as being in dos c:\blah\blah format, when
                                  it's not present - we treat pszDatabasePath as being in nt format
                                  e.g. "\SystemRoot\Apppatch"

            HID_NO_DATABASE       indicates that no database will be open at this time
                                  (pszDatabasePath is simply ignored, along with all
                                  the other flags)

            In addition to the flags above you can specify the type of the database that needs to be
            opened via the SDB_DATABASE_MAIN_* flags such as:
            SDB_DATABASE_MAIN_SHIM    - sysmain.sdb
            SDB_DATABASE_MAIN_MSI     - msimain.sdb
            SDB_DATABASE_MAIN_DRIVERS - drvmain.sdb
            This feature is not present on downlevel platforms.
            When any of the database type flags are provided, pszDatabasePath should be set to NULL

--*/
{
    // check whether the database we're trying to open is msi,
    // if so -- set the image type to msi

    USHORT uExeType = DEFAULT_IMAGE;

    if (dwFlags & HID_DATABASE_TYPE_MASK) {

        DWORD dwType = (dwFlags & HID_DATABASE_TYPE_MASK);

        //
        // check to see whether this database is msi -- if so, set image type accordingly
        //

        if (dwType == SDB_DATABASE_MAIN_MSI) {
            uExeType = (USHORT)IMAGE_FILE_MSI;
        }

        if (dwFlags & (HID_DATABASE_FULLPATH | HID_DOS_PATHS | HID_NO_DATABASE)) {
            //
            // there should be no "type" flags
            //
            dwFlags &= ~HID_DATABASE_TYPE_MASK;
        }

    }

    return SdbInitDatabaseEx(dwFlags, pszDatabasePath, uExeType);
}

HSDB
SdbInitDatabaseEx(
    IN  DWORD   dwFlags,        // flags that tell how the database should be
                                // initialized.
    IN  LPCTSTR pszDatabasePath,// the OPTIONAL full path to the database to be used.
    IN  USHORT  uExeType        // executable's image type
    )
/*++
    Return: A handle to the database.

    Desc:   This is the first API someone needs to call to initiate comunication
            with the database. Should be paired with a call to SdbReleaseDatabase
            when finished.

            HID_DATABASE_FULLPATH indicates that pszDatabasePath points to the full path of the
                                  main database, when this flag is not present and pszDatabasePath
                                  is not NULL we treat it as the directory where sysmain.sdb and
                                  systest.sdb are to be found

            HID_DOS_PATHS         indicates the format of the pszDatabasePath: when this flag is
                                  present, we treat it as being in dos c:\blah\blah format, when
                                  it's not present - we treat pszDatabasePath as being in nt format
                                  e.g. "\SystemRoot\Apppatch"

            HID_NO_DATABASE       indicates that no database will be open at this time
                                  (pszDatabasePath is simply ignored, along with all
                                  the other flags)

            In addition to the flags above you can specify the type of the database that needs to be
            opened via the SDB_DATABASE_MAIN_* flags such as:
            SDB_DATABASE_MAIN_SHIM    - sysmain.sdb
            SDB_DATABASE_MAIN_MSI     - msimain.sdb
            SDB_DATABASE_MAIN_DRIVERS - drvmain.sdb
            This feature is not present on downlevel platforms.
            When any of the database type flags are provided, pszDatabasePath should be set to NULL

--*/
{
    TCHAR       wszShimDB[MAX_PATH] = TEXT("");
    PSDBCONTEXT pContext;
    DWORD       dwFlagOpen = 0;

    //
    // Allocate the HSDB handle.
    //
    pContext = (PSDBCONTEXT)SdbAlloc(sizeof(SDBCONTEXT));

    if (pContext == NULL) {
        DBGPRINT((sdlError, "SdbInitDatabaseEx", "Failed to allocate %d bytes for HSDB\n",
                 sizeof(SDBCONTEXT)));
        return NULL;
    }

    pContext->uExeType = uExeType;

    //
    // See if we need to open db...
    //
    if (dwFlags & HID_NO_DATABASE) {
        DBGPRINT((sdlInfo, "SdbInitDatabaseEx", "No database is open\n"));
        goto InitDone;
    }

    //
    // Determine which flag to use with the OPEN call
    //
    dwFlagOpen = (dwFlags & HID_DOS_PATHS) ? DOS_PATH : NT_PATH;

    //
    // Open the main database and do this under a try/except so we don't kill
    // our caller if the database is corrupt.
    //
    __try {

        if (dwFlags & HID_DATABASE_FULLPATH) {
            // we better have the ptr
            if (pszDatabasePath == NULL) {
                DBGPRINT((sdlError, "SdbInitDatabaseEx",
                          "Database not specified with the database path flag\n"));
                goto errHandle;
            }

            StringCchCopy(wszShimDB,
                          CHARCOUNT(wszShimDB),
                          pszDatabasePath);

        } else {
            //
            // we do not have a database path
            // see if we have a database type to open as a "main" db
            //

#ifndef WIN32A_MODE
            //
            // This code works only on UNICODE
            //
            if (dwFlags & HID_DATABASE_TYPE_MASK) {

                DWORD dwDatabaseType = dwFlags;
                DWORD dwLen;

                dwLen = SdbpGetStandardDatabasePath((HSDB)pContext,
                                                    dwDatabaseType,
                                                    dwFlags,
                                                    wszShimDB,
                                                    CHARCOUNT(wszShimDB));
                if (dwLen > CHARCOUNT(wszShimDB)) {
                    DBGPRINT((sdlError,
                              "SdbInitDatabaseEx",
                              "Cannot get standard database path\n"));
                    goto errHandle;
                }

            } else

#endif // WIN32A_MODE
            {
                if (pszDatabasePath != NULL) {
                    int nLen;

                    StringCchCopy(wszShimDB,
                                  CHARCOUNT(wszShimDB),
                                  pszDatabasePath);

                    nLen = (int)_tcslen(wszShimDB);
                    if (nLen > 0 && TEXT('\\') == wszShimDB[nLen-1]) {
                        wszShimDB[nLen-1] = TEXT('\0');
                    }
                } else {  // standard database path

                    if (dwFlags & HID_DOS_PATHS) {
                        SdbpGetAppPatchDir((HSDB)pContext, wszShimDB, CHARCOUNT(wszShimDB));
                    } else {
                        if (uExeType == IMAGE_FILE_MACHINE_IA64) {
                            StringCchCopy(wszShimDB,
                                          CHARCOUNT(wszShimDB),
                                          TEXT("\\SystemRoot\\AppPatch\\IA64"));
                        } else {
                            StringCchCopy(wszShimDB,
                                          CHARCOUNT(wszShimDB),
                                          TEXT("\\SystemRoot\\AppPatch"));
                        }
                    }
                }

                StringCchCat(wszShimDB, CHARCOUNT(wszShimDB), TEXT("\\sysmain.sdb"));
            }
        }

        pContext->pdbMain = SdbOpenDatabase(wszShimDB, dwFlagOpen);

    } __except(SHIM_EXCEPT_HANDLER) {
        pContext->pdbMain = NULL;
    }

    if (pContext->pdbMain == NULL) {
        DBGPRINT((sdlError, "SdbInitDatabaseEx", "Unable to open main database sysmain.sdb.\n"));
        goto errHandle;
    }

    if (dwFlags & HID_DATABASE_FULLPATH) {
        // we are done, no test db
        goto InitDone;
    }

    //
    // Now try to open the systest.sdb if it exists.
    //
    __try {

        if (NULL != pszDatabasePath) {

            int nLen;

            StringCchCopy(wszShimDB, CHARCOUNT(wszShimDB), pszDatabasePath);

            nLen = (int)_tcslen(wszShimDB);

            if (nLen > 0 && TEXT('\\') == wszShimDB[nLen-1]) {
                wszShimDB[nLen-1] = TEXT('\0');
            }

        } else {  // standard database path

            if (dwFlags & HID_DOS_PATHS) {
                SdbpGetAppPatchDir((HSDB)pContext, wszShimDB, CHARCOUNT(wszShimDB));
            } else {
                if (uExeType == IMAGE_FILE_MACHINE_IA64) {
                    StringCchCopy(wszShimDB,
                                  CHARCOUNT(wszShimDB),
                                  TEXT("\\SystemRoot\\AppPatch\\IA64"));
                } else {
                    StringCchCopy(wszShimDB,
                                  CHARCOUNT(wszShimDB),
                                  TEXT("\\SystemRoot\\AppPatch"));
                }
            }
        }

        StringCchCat(wszShimDB, CHARCOUNT(wszShimDB), TEXT("\\systest.sdb"));

        pContext->pdbTest = SdbOpenDatabase(wszShimDB, dwFlagOpen);

    } __except(SHIM_EXCEPT_HANDLER) {
        pContext->pdbTest = NULL;
    }

    if (pContext->pdbTest == NULL) {
        DBGPRINT((sdlInfo, "SdbInitDatabaseEx", "No systest.sdb found.\n"));
    }

InitDone:

    //
    // Initialize new members (local db support)
    //
    if (pContext->pdbMain) {

        pContext->rgSDB[0].pdb     = pContext->pdbMain;
        pContext->rgSDB[0].dwFlags = SDBENTRY_VALID_ENTRY|SDBENTRY_VALID_GUID;

        RtlCopyMemory(&pContext->rgSDB[0].guidDB, &GUID_SYSMAIN_SDB, sizeof(GUID));

        SDBCUSTOM_SET_MASK(pContext, SDB_MASK_TO_INDEX(PDB_MAIN));
    }

    if (pContext->pdbTest) {

        pContext->rgSDB[1].pdb     = pContext->pdbTest;
        pContext->rgSDB[1].dwFlags = SDBENTRY_VALID_ENTRY|SDBENTRY_VALID_GUID;

        RtlCopyMemory(&pContext->rgSDB[1].guidDB, &GUID_SYSTEST_SDB, sizeof(GUID));

        SDBCUSTOM_SET_MASK(pContext, SDB_MASK_TO_INDEX(PDB_TEST));
    }

    //
    // Initialize architecture
    //
    pContext->dwRuntimePlatform = SdbpGetProcessorArchitecture(uExeType);

    //
    // Initialize OS SKU and SP
    //
    SdbpGetOSSKU(&pContext->dwOSSKU, &pContext->dwSPMask);

    return (HSDB)pContext;

errHandle:

    //
    // Cleanup on failure.
    //
    if (pContext != NULL) {
        if (pContext->pdbMain != NULL) {
            SdbCloseDatabaseRead(pContext->pdbMain);
        }

        if (pContext->pdbTest != NULL) {
            SdbCloseDatabaseRead(pContext->pdbTest);
        }

        SdbFree(pContext);
    }

    return NULL;
}


VOID
SdbSetImageType(
    IN HSDB hSDB,
    IN USHORT uExeType
    )
/*++

    This function is used to override default image type for the context
    Used by msi-related function in apphelp.dll

--*/
{
    ((PSDBCONTEXT)hSDB)->uExeType = uExeType;
}


BOOL
SdbpOpenAndMapFile(
    IN  LPCTSTR        szPath,          // Filename
    OUT PIMAGEFILEDATA pImageData,      // pointer to the structure to be filled
    IN  PATH_TYPE      ePathType        // path type, only DOS_PATH is supported on win32
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Opens a file and maps it into memory.
--*/
{
    HANDLE hFile;
    DWORD  dwFlags = 0;

    if (pImageData->dwFlags & IMAGEFILEDATA_PBASEVALID) {
        //
        // special case, only headers are valid in our assumption
        //
        return TRUE;
    }

    if (pImageData->dwFlags & IMAGEFILEDATA_HANDLEVALID) {
        hFile = pImageData->hFile;
        dwFlags |= IMAGEFILEDATA_NOFILECLOSE;
    } else {
        hFile = SdbpOpenFile(szPath, ePathType);
    }

    if (hFile == INVAL