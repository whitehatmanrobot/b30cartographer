 | MIIM_DATA;
            mii.fType = MFT_STRING;
            mii.dwTypeData = pRecentFileList[nIndex];
            mii.cch = StrLen(pRecentFileList[nIndex]);
            mii.wID = IDM_RECENTFILELIST + nIndex;
            InsertMenuItem(hMenu, 6 + nIndex, TRUE, &mii);
        }
        else
            break;
    }

    // add the seperator if menu items were added
    if (nIndex > 0)
    {
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;
        mii.wID   = IDM_RECENTFILELIST + nIndex;
        InsertMenuItem(hMenu, 6 + nIndex, TRUE, &mii);
    }

    DrawMenuBar(hWnd);
}

void ReadRecentFileList(TCHAR pRecentFileList[5][MAX_PATH])
{
    HKEY hKey;
    TCHAR szValue[20];
    DWORD dwType;
    TCHAR szData[MAX_PATH];
    DWORD dwSize;

    ZeroMemory(pRecentFileList, sizeof(pRecentFileList[0]) * 5);
    if (RegOpenKeyEx(HKEY_CURRENT_USER, RK_IEAK_SERVER TEXT("\\ProfMgr"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        // get the registry entries
        for (int nIndex = 1; nIndex < 6; nIndex++)
        {
            wsprintf(szValue, TEXT("RecentFile%d"), nIndex);
            dwSize = sizeof(szData);
            if (RegQueryValueEx(hKey, szValue, NULL, &dwType, (LPBYTE) szData, &dwSize) == ERROR_SUCCESS)
                StrCpy(pRecentFileList[nIndex - 1], szData);
            else
                break;
        }

        RegCloseKey(hKey);
    }
}

void UpdateRecentFileList(LPCTSTR pcszFile, BOOL fAdd, TCHAR pRecentFileList[5][MAX_PATH])
{
    HKEY  hKey;
    TCHAR szValue[20];
    DWORD dwType;
    DWORD dwSize;
    int   nFilenamePos = -1;

    for (int nIndex = 0; nIndex < 5; nIndex++)
    {
        if (StrCmpI(pRecentFileList[nIndex], pcszFile) == 0)
            nFilenamePos = nIndex;
    }

    if (fAdd)
    {
        if (nFilenamePos > 0)
        {                       // if the filename exists in the list bring to the top
            for (nIndex = nFilenamePos; nIndex > 0; nIndex--)
                StrCpy(pRecentFileList[nIndex], pRecentFileList[nIndex - 1]);
            StrCpy(pRecentFileList[0], pcszFile);
        }
        else if (nFilenamePos == -1)
        {                       // move the list contents i.e., 1-4 to 2-5
            for (nIndex = 3; nIndex >= 0; nIndex--)
            {
                if (*pRecentFileList[nIndex] != TEXT('\0'))
                    StrCpy(pRecentFileList[nIndex + 1], pRecentFileList[nIndex]);
            }
            StrCpy(pRecentFileList[0], pcszFile);
        }
    }
    else
    {
        if (nFilenamePos >= 0)
        {
            for (nIndex = nFilenamePos; nIndex < 4; nIndex++)
                StrCpy(pRecentFileList[nIndex], pRecentFileList[nIndex + 1]);
            ZeroMemory(pRecentFileList[4], sizeof(pRecentFileList[4]));
        }                
    }
}

void WriteRecentFileList(TCHAR pRecentFileList[5][MAX_PATH])
{
    HKEY hKey;
    TCHAR szValue[20];
    DWORD dwDisposition;
    
    if (RegCreateKeyEx(HKEY_CURRENT_USER, RK_IEAK_SERVER TEXT("\\ProfMgr"), 0, TEXT(""), REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
    {
        for (int nIndex = 0; nIndex < 5; nIndex++)
        {
            wsprintf(szValue, TEXT("RecentFile%d"), nIndex + 1);
            if (*pRecentFileList[nIndex] != TEXT('\0'))
                RegSetValueEx(hKey, szValue, 0, REG_SZ, (const BYTE *)pRecentFileList[nIndex], (StrLen(pRecentFileList[nIndex]) + 1) * sizeof(TCHAR));
            else
                RegDeleteValue(hKey, szValue);
        }

        RegCloseKey(hKey);
    }
}

BOOL IsDirty()
{
    return (InsDirty() || IsAdmDirty());
}

void ClearDirtyFlag()
{
    ClearInsDirtyFlag();
    ResetAdmDirtyFlag();
}

BOOL SaveCurrentSelItem(HWND hTreeView, DWORD dwFlags)
{
    BOOL      fRetVal = TRUE;
    HTREEITEM hItem = TreeView.GetSel();
    HTREEITEM hParentItem = TreeView_GetParent(hTreeView, hItem);
    TVITEM    tvitem;
    DWORD     dwItemFlags = 0;
    
    if (hItem != NULL && hParentItem != NULL)
    {
        if (!IsPolicyTree(hItem))
        {
            if (g_hDialog)
            {
                fRetVal = SaveInsDialog(g_hDialog, dwFlags);
                if (HasFlag(dwFlags, ITEM_DESTROY))
                    g_hDialog = NULL;
            }
        }
        else if (hParentItem != g_hPolicyRootItem)
        {
            tvitem.mask = TVIF_PARAM;
            tvitem.hItem = hItem;
            TreeView_GetItem(hTreeView, &tvitem);

            if (HasFlag(dwFlags, ITEM_CHECKDIRTY)) // for adm items checkitem for dirty
                dwFlags |= ITEM_SAVE;              // is same as saveitem
            SaveADMItem(hTreeView, &tvitem, dwFlags);
        }
    }

    return fRetVal;
}

void SetInfoWindowText(HWND hInfoWnd, LPCTSTR pcszStatusText /*= NULL*/)
{
    TCHAR szInfoText[MAX_PATH*2],
          szProfileState[MAX_PATH],
          szCabsUrlPath[MAX_PATH],
          szVersion[MAX_PATH],
          szDefaultStr[MAX_PATH],
          szStatusText[MAX_PATH],
          szCabsUrlPathText[MAX_PATH],
          szVersionText[MAX_PATH];

    if (hInfoWnd == NULL)
        return;
    
    StrCpy(szDefaultStr, Res2Str(IDS_NOTAVAILABLE));

    if (*g_szInsFile != TEXT('\0'))
    {
        if (IsDirty())
            StrCpy(szProfileState, Res2Str(IDS_PROFILE_DIRTY));
        else
            StrCpy(szProfileState, Res2Str(IDS_PROFILE_NOCHANGE));

        if (*g_szFileName != TEXT('\0') && *g_szNewVersionStr != TEXT('\0'))
            StrCpy(szVersion, g_szNewVersionStr);
        else
            GetPrivateProfileString(BRANDING, INSVERKEY, szDefaultStr, szVersion, ARRAYSIZE(szVersion), g_szInsFile);
    }
    else
    {
        StrCpy(szProfileState, szDefaultStr);
        StrCpy(szVersion, szDefaultStr);
    }

    if (pcszStatusText != NULL && *pcszStatusText != TEXT('\0'))
        StrCpy(szProfileState, pcszStatusText);
    
    if (*g_szCabsURLPath == TEXT('\0'))
        StrCpy(szCabsUrlPath, szDefaultStr);
    else
    {
        if (StrLen(g_szCabsURLPath) > 80) // 80 is the max. characters that can be displayed.
        {
            StrCpyN(szCabsUrlPath, g_szCabsURLPath, 77);
            StrCat(szCabsUrlPath, TEXT("..."));
        }
        else
#pragma prefast(suppress:202,"g_szCabsURLPath length is less than 80, dest. buffer is MAX_PATH")
            StrCpy(szCabsUrlPath, g_szCabsURLPath);
    }
   
    wsprintf(szStatusText, Res2Str(IDS_STATUS), szProfileState);
    wsprintf(szCabsUrlPathText, Res2Str(IDS_CABSURLPATH), szCabsUrlPath);
    wsprintf(szVersionText, Res2Str(IDS_VERSIONINFO), szVersion);

    wsprintf(szInfoText, TEXT("%s%s%s"), szStatusText, szCabsUrlPathText, szVersionText);
    
    SendMessage(hInfoWnd, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)szInfoText);
}

BOOL PlatformExists(HWND hWnd, LPTSTR pLang, DWORD dwPlatform, BOOL fShowError /*= FALSE*/)
{
    WIN32_FIND_DATA wfdFind;
    HANDLE hFind;
    TCHAR szLangDir[MAX_PATH],
          szPlatform[10];
    BOOL  fRetVal = FALSE;

    // get the all the directories under the ieak\iebin\<language>\Optional directory
    wsprintf(szLangDir, TEXT("%s\\iebin\\%s\\Optional"), g_szRoot, pLang);
    
    PathAppend(szLangDir, TEXT("deffav.inf"));
    if (PathFileExists(szLangDir))
        fRetVal = TRUE;

    if (!fRetVal && fShowError)
    {
        TCHAR  szPlatformText[25],
               szLangDesc[200];
        LPTSTR pMsg;
        DWORD  dwLangId;

        if (dwPlatform == PLATFORM_WIN32)
            StrCpy(szPlatformText, Res2Str(IDS_WIN32));
        else if (dwPlatform == PLATFORM_W2K)
            StrCpy(szPlatformText, Res2Str(IDS_W2K));
    
        GetLangDesc(g_szLanguage, szLangDesc, ARRAYSIZE(szLangDesc), &dwLangId);

        pMsg = FormatString(Res2Str(IDS_NOPLATFORMDIR), szPlatformText, szLangDesc);
        MessageBox(hWnd, pMsg, Res2Str(IDS_TITLE), MB_ICONINFORMATION | MB_OK);
        LocalFree(pMsg);
    }
    
    return fRetVal;   
}

BOOL EnoughDiskSpace(LPCTSTR szSrcDir, LPCTSTR szDestDir, LPDWORD pdwSpaceReq, LPDWORD pdwSpaceFree)
{
    TCHAR szDestFile[MAX_PATH];
    DWORD dwFreeSpace = 0,
          dwFlags     = 0,
          dwSrcSize   = 0,
          dwDestSize  = 0,
          dwSpaceReq  = 0;
    
    if (!GetFreeDiskSpace(szDestDir, &dwFreeSpace, &dwFlags))
        return TRUE;

    dwSrcSize  = FileSize(g_szInsFile);
    dwDestSize = FileSize(g_szFileName);
    if (dwSrcSize > dwDestSize)
    {
        dwSpaceReq = dwSrcSize - dwDestSize;
        dwSpaceReq >>= 10;              // divide by 1024 (we are interested in KBytes)
        dwSpaceReq++;
    }
    
    dwSpaceReq += FindSpaceRequired(szSrcDir, TEXT("*.cab"), szDestDir);
    if (dwSpaceReq)
        dwSpaceReq += 5;            // 5K buffer to account for random stuff

    if (dwFlags & FS_VOL_IS_COMPRESSED)
    {
        // if the destination volume is compressed, the space free returned is only
        // a guesstimate; for example, if it's a DoubleSpace volume, the system thinks
        // that it can compress by 50% and so it reports the free space as (actual free space * 2)

        // it's better to be safe when dealing with compressed volumes; so bump up the space
        // requirement by a factor 2
        dwSpaceReq <<= 1;           // multiply by 2
    }

    if (pdwSpaceReq != NULL)
        *pdwSpaceReq = dwSpaceReq;

    if (pdwSpaceFree != NULL)
        *pdwSpaceFree = dwFreeSpace;

    return dwFreeSpace > dwSpaceReq;
}

BOOL CabFilesExist(HWND hWnd, LPCTSTR pcszInsFile)
{
    TCHAR szBrandingCab[MAX_PATH];
    TCHAR szDesktopCab[MAX_PATH];
    TCHAR szCabFailStr[MAX_PATH];
    
    if (pcszInsFile == NULL || *pcszInsFile == TEXT('\0'))
        return FALSE;
    
    GetCabNameFromINS(pcszInsFile, CAB_TYPE_CONFIG, szBrandingCab);
    GetCabNameFromINS(pcszInsFile, CAB_TYPE_DESKTOP, szDesktopCab);

    *szCabFailStr = TEXT('\0');
    if (*szBrandingCab != TEXT('\0') && !PathFileExists(szBrandingCab))
        StrCpy(szCabFailStr, PathFindFileName(szBrandingCab));
    if (*szDesktopCab != TEXT('\0') && !PathFileExists(szDesktopCab))
    {
        if (*szCabFailStr != TEXT('\0'))
            StrCat(szCabFailStr, TEXT("\r\n"));
        StrCat(szCabFailStr, PathFindFileName(szDesktopCab));
    }
    if (*szCabFailStr != TEXT('\0'))
    {
        LPTSTR pMsg = NULL;

        pMsg = FormatString(Res2Str(IDS_CAB_DOESNOTEXIST), pcszInsFile, szCabFailStr);
        MessageBox(hWnd, pMsg, Res2Str(IDS_TITLE), MB_ICONEXCLAMATION | MB_OK);
        LocalFree(pMsg);
        return FALSE;
    }
    
    return TRUE;
}

BOOL IsWin32INSFile(LPCTSTR pcszIns)
{
    int   nPlatformId = 0;
    TCHAR szTemp[MAX_PATH];

    InsGetString(IS_BRANDING, TEXT("Platform"), szTemp, countof(szTemp), pcszIns);
    nPlatformId = StrToInt(szTemp);
    
    if (nPlatformId != 0 && nPlatformId != PLATFORM_WIN32 && nPlatformId != PLATFORM_W2K)
    {
        TCHAR szMsg[MAX_PATH+128];

        wsprintf(szMsg, Res2Str(IDS_UNSUPPORTED_PLATFORM), pcszIns);
        MessageBox(g_hMain, szMsg, Res2Str(IDS_TITLE), MB_ICONINFORMATION | MB_OK);
        
        return FALSE;
    }
    else if (nPlatformId == 0)
        nPlatformId = PLATFORM_WIN32;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\exe\treeview.h ===
//--------------------------------------------------------------------------
//
//  treeview.h
//
//--------------------------------------------------------------------------

class CTreeView
{
private:
	HWND hTreeView;

public:
    CTreeView();
    ~CTreeView();
    
    void      Create(HWND hwndParent, int x, int y, int nWidth, int nHeight);
    HTREEITEM AddItem(LPTSTR lpszItem, HTREEITEM hParentItem = NULL);
    void      MoveWindow(int x, int y, int nWidth, int nHeight);
    void      SetSel(HTREEITEM hItem);
    HTREEITEM GetSel();
    void      GetItemText(HTREEITEM hItem, LPTSTR szItemText, int nSize);
	HWND      GetHandle();
    void      DeleteNodes(HTREEITEM hItem);
    void      CollapseChildNodes(HTREEITEM hParentItem);
};


class CStatusWindow
{
private:
    HWND hStatusWindow;
    int  nHeight;

public:
    CStatusWindow();
    ~CStatusWindow();
    
    void Create(HWND hwndParent, int nCtlID);
    void Size(int nWidth);
    void SetText(LPTSTR szText);
    int  Height() const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\insedit\exe\treeview.cpp ===
//--------------------------------------------------------------------------
//
//  treeview.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <commctrl.h>
#include "resource.h"
#include "treeview.h"
#include <stdlib.h>

extern HINSTANCE g_hInst;
extern int g_InsSettingsOpen, g_InsSettingsClose, g_InsLeafItem, g_PolicyOpen, g_PolicyClose;

CTreeView::CTreeView()
{
    InitCommonControls();
}

CTreeView::~CTreeView()
{

}

void CTreeView::Create(HWND hwndParent, int x, int y, int nWidth, int nHeight)
{
    hTreeView = CreateWindowEx(WS_EX_CLIENTEDGE , WC_TREEVIEW, TEXT("Tree View"),
        WS_VISIBLE | WS_CHILD | WS_BORDER | WS_TABSTOP | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_SHOWSELALWAYS,
        x, y, nWidth, nHeight, hwndParent, NULL, g_hInst, NULL);
}

HTREEITEM CTreeView::AddItem(LPTSTR lpszItem, HTREEITEM hParentItem)
{
    TV_ITEM tvi;
    TV_INSERTSTRUCT tvins;
    char szTmp[MAX_PATH];
    HTREEITEM hItem;

    tvi.mask = TVIF_TEXT;

    tvi.pszText = lpszItem;
    tvi.cchTextMax = lstrlen(lpszItem);
    tvins.item = tvi;
    tvins.hInsertAfter = TVI_LAST;

    if(hParentItem == NULL)
	{
		tvins.item.mask |= TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
		tvins.item.stateMask = tvins.item.state = TVIS_BOLD;
		if(lstrcmp(lpszItem, TEXT("Ins Settings")) == 0)
		{
			tvins.item.iImage = tvins.item.iSelectedImage = g_InsSettingsClose;
		}
		else
		{
			tvins.item.iImage = tvins.item.iSelectedImage = g_PolicyClose;
		}
        tvins.hParent = TVI_ROOT;
	}
    else
	{
        tvins.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
		tvins.hParent = hParentItem;
		tvins.item.iImage = tvins.item.iSelectedImage = g_InsLeafItem;
	}

    hItem = (HTREEITEM) SendMessage(hTreeView, TVM_INSERTITEM, 0,
        (LPARAM)(LPTV_INSERTSTRUCT) &tvins);

    return hItem;
}

void CTreeView::MoveWindow(int x, int y, int nWidth, int nHeight)
{
    ::MoveWindow(hTreeView, x, y, nWidth, nHeight, TRUE);
}

void CTreeView::SetSel(HTREEITEM hItem)
{
    SendMessage(hTreeView, TVM_SELECTITEM, (WPARAM) TVGN_CARET,
        (LPARAM) hItem);
}

HTREEITEM CTreeView::GetSel()
{
    return TreeView_GetSelection(hTreeView);
}

void CTreeView::GetItemText(HTREEITEM hItem, LPTSTR szItemText, int nSize)
{
    TV_ITEM item;

    item.mask = TVIF_TEXT;
    item.pszText = szItemText;
    item.cchTextMax = nSize;
    item.hItem = hItem;

    SendMessage(hTreeView, TVM_GETITEM, 0, (LPARAM) &item);
}

HWND CTreeView::GetHandle()
{
	return hTreeView;
}

void CTreeView::DeleteNodes(HTREEITEM hParentItem)
{
    HTREEITEM hItem = TreeView_GetChild(hTreeView, hParentItem);
    HTREEITEM hNextItem = NULL;

    while(hItem != NULL) // if items present
    {
        hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item
        TreeView_DeleteItem(hTreeView, hItem);
        hItem = hNextItem;
    }
}

void CTreeView::CollapseChildNodes(HTREEITEM hParentItem)
{
    NMTREEVIEW NMTreeView;
    HTREEITEM hItem;
    TVITEM    tvitem;

    ZeroMemory(&NMTreeView, sizeof(NMTreeView));
    NMTreeView.hdr.hwndFrom = hTreeView;
    NMTreeView.hdr.code     = TVN_ITEMEXPANDED;
    NMTreeView.action       = TVE_COLLAPSE;

    hItem = (hParentItem != NULL) ? TreeView_GetChild(hTreeView, hParentItem) :
                                    TreeView_GetRoot(hTreeView);
    while (hItem != NULL)
    {
        NMTreeView.itemNew.hItem = hItem;

        TreeView_Expand(hTreeView, hItem, TVE_COLLAPSE);
        SendMessage(GetParent(hTreeView), WM_NOTIFY, 0, (LPARAM)&NMTreeView);

        hItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item
    }
}

//--------------------------------------------------------------------------
//  CStatusWindow member functions

CStatusWindow::CStatusWindow()
{
    hStatusWindow = NULL;
    nHeight       = 0;
}

CStatusWindow::~CStatusWindow()
{
}

void CStatusWindow::Create(HWND hwndParent, int nCtlID)
{
    RECT r;

    hStatusWindow = CreateStatusWindow(WS_CHILD | WS_VISIBLE,TEXT("Ready"), hwndParent, nCtlID);

    GetWindowRect(hStatusWindow, &r);
    nHeight = r.bottom - r.top;
}

void CStatusWindow::Size(int nWidth)
{
    SendMessage(hStatusWindow, WM_SIZE, 0, MAKELPARAM(nWidth, nHeight));
}

void CStatusWindow::SetText(LPTSTR szText)
{
    SendMessage(hStatusWindow, WM_SETTEXT, 0, (LPARAM) szText);
}

int CStatusWindow::Height() const
{
    return nHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\dispids.h ===
#define    DISPID_CorpKeycode 5000
#define    DISPID_ISPKeycode  5001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( keyocx )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( keyocx ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keymaker\kmmain.c ===
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>

void MakeKey(char *, int);

void usage( void )
{
    printf( "Usage:\n\n\tkeymake ( -s | -c ) file1 [file2]\n\n" );
    printf( "\tParameters:\n\t-s : ISP\n\t-c : Corp\n\tfile1 : input file\n\tfile2 : output file\n\n" );
    printf( "\tNote: if file2 is left out, output is directed to stdout\n\n" );
    printf( "\tExample: keymake -s isps.txt keys.txt\n\n" );
}

int RemoveSpaces( char *szBuffer, int isize )
{
    int i;
    int nRemoved = 0;

    for( i = 0; i < (isize - nRemoved); i++ )
    {
        if( szBuffer[i] == ' ' )
        {
            nRemoved++;
            memcpy( &szBuffer[i], &szBuffer[i] + 1, isize - i);
        }
    }
    szBuffer[isize - nRemoved] = '\0';
    return nRemoved;
}

void OutputKeys( FILE *ofile, char *szBuffer, int isize, char *szName, int itype )
{
    int i;
    int itemp = 0;
    int itemp2 = 0;
    int keycount = 0;
    char szTemp[80] = {0};
    char szClean[10] = {0};

    for( i = 0; i < isize; i++ )
    {
        if( szBuffer[i] != '\n' )
        {
            szTemp[itemp] = szBuffer[i];
            itemp++;
        }
        else
        {
            itemp = 0;
            szTemp[7] = '\0';
            strupr( szTemp );
            MakeKey( szTemp, itype );
            fprintf( ofile, "%s,%s\n", szName, szTemp );
            while( szName[0] != '\0' )
                *szName++;
            *szName++;
            szTemp[0] = '\0';
            memcpy( &szTemp, &szClean, 10 );
            keycount++;
        }
    }
}

int __cdecl main(int argc, char *argv[])
{
	char buf[80];
    char filebuffer[16384] = {0};
    char namebuffer[16384] = {0};
    int isize;
    int nSpaces;
    int itype;
    int i;
    FILE *ifile;
    FILE *ofile;

    if( argc < 3 )
    {
        usage();
        goto get_out;
    }

	if ((argv[1][0] != '-') && (argv[1][0] != '/')) goto badparm;
    if (strlen(argv[1]) != 2) goto badparm;
	switch (argv[1][1])
	{
		case 's':
		case 'S':
	        itype = 0;
			break;

		case 'c':
		case 'C':
	    	itype = 1;
			break;

		default:
		badparm:
	        printf( "\ninvalid parameter: %s\n\n", argv[1] );
	        usage();
	        goto get_out;
	}

    if( (ifile = fopen( argv[2], "r" )) != NULL )
    {
        isize = fread( filebuffer, sizeof(char), 16384, ifile );
    }
    else
    {
        printf( "Could not open input file: %s", argv[2] );
        goto get_out;
    }

    strcpy( namebuffer, filebuffer );
    for( i = 0; i < isize; i++ )
    {
        if( namebuffer[i] == '\n' )
            namebuffer[i] = '\0';
    }
    namebuffer[isize + 1] = '\0';

    nSpaces = RemoveSpaces( filebuffer, isize );

    if( argc > 3 )
    {
        if( (ofile = fopen( argv[3], "w" )) != NULL )
        {
            OutputKeys( ofile, filebuffer, isize - nSpaces, namebuffer, itype );
        }
        else
        {
            printf( "Could not open output file: %s", argv[3] );
            goto get_out;
        }
    }
    else
    {
        OutputKeys( stdout, filebuffer, isize - nSpaces, namebuffer, itype );
    }

get_out:
    _fcloseall();
    exit(0);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\keyocx.cpp ===
// keyocx.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for keyocx.idl by adding the following 
//		files to the Outputs.
//			keyocx_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f keyocxps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "keyocx.h"
#include "dlldatax.h"

#include "keyocx_i.c"
#include "keyocxCtrl.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_KeyocxCtrl, CKeyocxCtrl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\keyocxctrl.h ===
// KeyocxCtrl.h : Declaration of the CKeyocxCtrl

#ifndef __KEYOCXCTRL_H_
#define __KEYOCXCTRL_H_

#include "resource.h"       // main symbols
#include <mshtml.h>
#include <wininet.h>

/////////////////////////////////////////////////////////////////////////////
// CKeyocxCtrl
class ATL_NO_VTABLE CKeyocxCtrl :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CKeyocxCtrl,&CLSID_KeyocxCtrl>,
	public CComControl<CKeyocxCtrl>,
	public IDispatchImpl<IKeyocxCtrl, &IID_IKeyocxCtrl, &LIBID_KEYOCXLib>,
	public IPersistStreamInitImpl<CKeyocxCtrl>,
	public IOleControlImpl<CKeyocxCtrl>,
	public IOleObjectImpl<CKeyocxCtrl>,
	public IOleInPlaceActiveObjectImpl<CKeyocxCtrl>,
	public IViewObjectExImpl<CKeyocxCtrl>,
	public IOleInPlaceObjectWindowlessImpl<CKeyocxCtrl>,
    public IObjectSafetyImpl<CKeyocxCtrl>
{
public:
	CKeyocxCtrl()
	{
 
	}

DECLARE_REGISTRY_RESOURCEID(IDR_KEYOCXCTRL)

BEGIN_COM_MAP(CKeyocxCtrl) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IKeyocxCtrl)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CKeyocxCtrl)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CKeyocxCtrl)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}

// IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
    {
        ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
        if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
            return E_POINTER;
        HRESULT hr = S_OK;
        if (riid == IID_IDispatch)
        {
            *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
            *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        }
        else
        {
            *pdwSupportedOptions = 0;
            *pdwEnabledOptions = 0;
            hr = E_NOINTERFACE;
        }
        return hr;
    }
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);

// IKeyocxCtrl
public:
	HRESULT OnDraw(ATL_DRAWINFO& di);

    STDMETHOD(CorpKeycode)(BSTR bstrBaseKey, BSTR *bstrKeycode);
    STDMETHOD(ISPKeycode)(BSTR bstrBaseKey, BSTR *bstrKeycode); 

};

#endif //__KEYOCXCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\keyocx.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Mon Feb 01 11:34:11 1999
 */
/* Compiler settings for keyocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __keyocx_h__
#define __keyocx_h__

/* Forward Declarations */ 

#ifndef __IKeyocxCtrl_FWD_DEFINED__
#define __IKeyocxCtrl_FWD_DEFINED__
typedef interface IKeyocxCtrl IKeyocxCtrl;
#endif 	/* __IKeyocxCtrl_FWD_DEFINED__ */


#ifndef __KeyocxCtrl_FWD_DEFINED__
#define __KeyocxCtrl_FWD_DEFINED__

#ifdef __cplusplus
typedef class KeyocxCtrl KeyocxCtrl;
#else
typedef struct KeyocxCtrl KeyocxCtrl;
#endif /* __cplusplus */

#endif 	/* __KeyocxCtrl_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_keyocx_0000 */
/* [local] */ 

#pragma once



extern RPC_IF_HANDLE __MIDL_itf_keyocx_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_keyocx_0000_v0_0_s_ifspec;

#ifndef __IKeyocxCtrl_INTERFACE_DEFINED__
#define __IKeyocxCtrl_INTERFACE_DEFINED__

/* interface IKeyocxCtrl */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IKeyocxCtrl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48D17197-32CF-11D2-A337-00C04FD7C1FC")
    IKeyocxCtrl : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CorpKeycode( 
            /* [in] */ BSTR bstrBaseKey,
            /* [retval][out] */ BSTR __RPC_FAR *bstrKeycode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ISPKeycode( 
            /* [in] */ BSTR bstrBaseKey,
            /* [retval][out] */ BSTR __RPC_FAR *bstrKeycode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKeyocxCtrlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IKeyocxCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IKeyocxCtrl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IKeyocxCtrl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IKeyocxCtrl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IKeyocxCtrl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IKeyocxCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IKeyocxCtrl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CorpKeycode )( 
            IKeyocxCtrl __RPC_FAR * This,
            /* [in] */ BSTR bstrBaseKey,
            /* [retval][out] */ BSTR __RPC_FAR *bstrKeycode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISPKeycode )( 
            IKeyocxCtrl __RPC_FAR * This,
            /* [in] */ BSTR bstrBaseKey,
            /* [retval][out] */ BSTR __RPC_FAR *bstrKeycode);
        
        END_INTERFACE
    } IKeyocxCtrlVtbl;

    interface IKeyocxCtrl
    {
        CONST_VTBL struct IKeyocxCtrlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKeyocxCtrl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IKeyocxCtrl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IKeyocxCtrl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IKeyocxCtrl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IKeyocxCtrl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IKeyocxCtrl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IKeyocxCtrl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IKeyocxCtrl_CorpKeycode(This,bstrBaseKey,bstrKeycode)	\
    (This)->lpVtbl -> CorpKeycode(This,bstrBaseKey,bstrKeycode)

#define IKeyocxCtrl_ISPKeycode(This,bstrBaseKey,bstrKeycode)	\
    (This)->lpVtbl -> ISPKeycode(This,bstrBaseKey,bstrKeycode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IKeyocxCtrl_CorpKeycode_Proxy( 
    IKeyocxCtrl __RPC_FAR * This,
    /* [in] */ BSTR bstrBaseKey,
    /* [retval][out] */ BSTR __RPC_FAR *bstrKeycode);


void __RPC_STUB IKeyocxCtrl_CorpKeycode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IKeyocxCtrl_ISPKeycode_Proxy( 
    IKeyocxCtrl __RPC_FAR * This,
    /* [in] */ BSTR bstrBaseKey,
    /* [retval][out] */ BSTR __RPC_FAR *bstrKeycode);


void __RPC_STUB IKeyocxCtrl_ISPKeycode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IKeyocxCtrl_INTERFACE_DEFINED__ */



#ifndef __KEYOCXLib_LIBRARY_DEFINED__
#define __KEYOCXLib_LIBRARY_DEFINED__

/* library KEYOCXLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_KEYOCXLib;

EXTERN_C const CLSID CLSID_KeyocxCtrl;

#ifdef __cplusplus

class DECLSPEC_UUID("8D3032AF-2CBA-11D2-8277-00104BC7DE21")
KeyocxCtrl;
#endif
#endif /* __KEYOCXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\keyocx_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Mon Feb 01 11:34:11 1999
 */
/* Compiler settings for keyocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IKeyocxCtrl = {0x48D17197,0x32CF,0x11D2,{0xA3,0x37,0x00,0xC0,0x4F,0xD7,0xC1,0xFC}};


const IID LIBID_KEYOCXLib = {0x48D17188,0x32CF,0x11D2,{0xA3,0x37,0x00,0xC0,0x4F,0xD7,0xC1,0xFC}};


const CLSID CLSID_KeyocxCtrl = {0x8D3032AF,0x2CBA,0x11D2,{0x82,0x77,0x00,0x10,0x4B,0xC7,0xDE,0x21}};


#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Mon Feb 01 11:34:13 1999
 */
/* Compiler settings for keyocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IKeyocxCtrl = {0x48D17197,0x32CF,0x11D2,{0xA3,0x37,0x00,0xC0,0x4F,0xD7,0xC1,0xFC}};


const IID LIBID_KEYOCXLib = {0x48D17188,0x32CF,0x11D2,{0xA3,0x37,0x00,0xC0,0x4F,0xD7,0xC1,0xFC}};


const CLSID CLSID_KeyocxCtrl = {0x8D3032AF,0x2CBA,0x11D2,{0x82,0x77,0x00,0x10,0x4B,0xC7,0xDE,0x21}};


#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\keyocxctrl.cpp ===
// KeyocxCtrl.cpp : Implementation of CKeyocxCtrl
#include "stdafx.h"
#include "keyocx.h"
#include "KeyocxCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CKeyocxCtrl


HRESULT CKeyocxCtrl::OnDraw(ATL_DRAWINFO& di)
{
	RECT& rc = *(RECT*)di.prcBounds;
	Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
	DrawText(di.hdcDraw, _T("ATL 2.0"), -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	return S_OK;
}

BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}

LPSTR FAR ANSIStrChr(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}

LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

PathRemoveFileSpec(
    LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

void Strip(LPSTR pszUrl)
{
	char szTemp[MAX_PATH] ;
	int tempPtr=0, pathPtr=0 ;

	while (pszUrl[pathPtr])
	{
		if (pszUrl[pathPtr] == '%')
		{
			int value = 0 ;
			pathPtr++ ;
			while (pszUrl[pathPtr] && ((pszUrl[pathPtr] >= '0') && (pszUrl[pathPtr] <= '9')))
			{
                value = (value * 0x10) + (pszUrl[pathPtr] - '0') ;
                pathPtr++ ;
			}
			szTemp[tempPtr++] = (char)value;
		}
		else
		{
			szTemp[tempPtr++] = pszUrl[pathPtr++] ;
		}
	}
	szTemp[tempPtr] = pszUrl[pathPtr] ;

	lstrcpy(pszUrl, szTemp) ;
}

BOOL CompareDirs(LPCSTR pcszDir1, LPCSTR pcszDir2)
{
    char szDir1[MAX_PATH];
    char szDir2[MAX_PATH];

    if (GetShortPathName(pcszDir1, szDir1, sizeof(szDir1)) && GetShortPathName(pcszDir2, szDir2, sizeof(szDir2))
        && (lstrcmpi(szDir1, szDir2) == 0))
        return TRUE;

    return FALSE;
}

BOOL CheckSignupDir(LPCSTR pcszFile)
{
    char szIEPath[MAX_PATH];
    char szFilePath[MAX_PATH];
    DWORD dwSize;
    HKEY hkAppPaths;

    dwSize = sizeof(szIEPath);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\iexplore.exe",
        0, KEY_READ, &hkAppPaths) != ERROR_SUCCESS)
        return FALSE;

    if (RegQueryValueEx(hkAppPaths, "Path", 0, NULL, (LPBYTE)&szIEPath, &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hkAppPaths);
        return FALSE;
    }

    RegCloseKey(hkAppPaths);

    if (szIEPath[lstrlen(szIEPath)-1] == ';')
        szIEPath[lstrlen(szIEPath)-1] = '\0';

    if (szIEPath[lstrlen(szIEPath)-1] == '\\')
        szIEPath[lstrlen(szIEPath)-1] = '\0';

    lstrcat(szIEPath, "\\signup");

    lstrcpy(szFilePath, pcszFile);
    PathRemoveFileSpec(szFilePath);

    // check that we are writing to a file in the signup dir
    
    if (!CompareDirs(szIEPath, szFilePath))
        return FALSE;

    return TRUE;
}
STDMETHODIMP CKeyocxCtrl::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    CComBSTR strURL;
    char szURL[INTERNET_MAX_URL_LENGTH];
    char cBack;
    LPSTR pPtr, pSlash;
    ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
    
    USES_CONVERSION;
    
    // check to make sure it's a file://<drive letter> URL that we're being hosted on
    CComPtr<IOleContainer> spContainer; 
    m_spClientSite->GetContainer(&spContainer); 
    CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> spDoc(spContainer); 
    
    if (spDoc)
        spDoc->get_URL(&strURL);
    else
        return E_NOINTERFACE;
    
    lstrcpy(szURL, OLE2A(strURL));
    Strip(szURL);

    cBack = szURL[7];
    szURL[7] = '\0';
    if (lstrcmpi(szURL, "file://") != 0)
        return E_NOINTERFACE;
    
    szURL[7] = cBack;
    pPtr = &szURL[7];

    while (*pPtr == '/')
        pPtr++;

    pSlash = pPtr;
    while (pSlash = ANSIStrChr(pSlash, '/'))
        *pSlash = '\\';
    if (!CheckSignupDir(pPtr))
        return E_FAIL;

    // If we're being asked to set our safe for scripting option then oblige
    
    if (riid == IID_IDispatch )
    {
        // Store our current safety level to return in GetInterfaceSafetyOptions
        m_dwSafety = dwEnabledOptions & dwOptionSetMask;
        return S_OK;
    }
    return E_NOINTERFACE;
}

void MakeKey(LPSTR pszSeed, BOOL fCorp)
{
    int i;
    DWORD dwKey;
    CHAR szKey[5];

    i = lstrlen(pszSeed);
	
    if (i < 6)
    {
        // extend the input seed to 6 characters
        for (; i < 6; i++)
            pszSeed[i] = (char)('0' + i);
    }
	
    // let's calculate the DWORD key used for the last 4 chars of keycode

    // multiply by my first name

    dwKey = pszSeed[0] * 'O' + pszSeed[1] * 'L' + pszSeed[2] * 'I' +
        pszSeed[3] * 'V' + pszSeed[4] * 'E' + pszSeed[5] * 'R';

    // multiply the result by JONCE

    dwKey *= ('J' + 'O' + 'N' + 'C' + 'E');

    dwKey %= 10000;

    if (fCorp)
    {
        // give a separate keycode based on corp flag or not
        // 9 is chosen because is is a multiplier such that for any x,
        // (x+214) * 9 != x + 10000y
        // we have 8x = 10000y - 1926 which when y=1 gives us 8x = 8074 
        // since 8074 is not divisible by 8 where guaranteed to be OK since
        // the number on the right can only increase by 10000 increments which
        // are always divisible by 8

        dwKey += ('L' + 'E' + 'E');
        dwKey *= 9;
        dwKey %= 10000;
    }

    wsprintf(szKey, TEXT("%04lu"), dwKey);

    lstrcpy(&pszSeed[6], szKey);
}

STDMETHODIMP CKeyocxCtrl::CorpKeycode(BSTR bstrBaseKey, BSTR *bstrKeycode) 
{
    CHAR szKey[32];

    USES_CONVERSION;

    lstrcpy(szKey, OLE2A(bstrBaseKey));
    CharUpper(szKey);
    MakeKey(szKey, TRUE);
    
    *bstrKeycode = A2BSTR(szKey);
    return S_OK;
}

STDMETHODIMP CKeyocxCtrl::ISPKeycode(BSTR bstrBaseKey, BSTR *bstrKeycode) 
{
    CHAR szKey[32];

    USES_CONVERSION;

    lstrcpy(szKey, OLE2A(bstrBaseKey));
    CharUpper(szKey);
    MakeKey(szKey, FALSE);

    *bstrKeycode = A2BSTR(szKey);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning(disable : 4273)
#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by keyocx.rc
//
#define IDS_PROJNAME                    100
#define IDR_KEYOCXCTRL                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\keyocx_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Mon Feb 01 11:34:11 1999
 */
/* Compiler settings for keyocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "keyocx.h"

#define TYPE_FORMAT_STRING_SIZE   57                                
#define PROC_FORMAT_STRING_SIZE   85                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Standard interface: __MIDL_itf_keyocx_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IKeyocxCtrl, ver. 0.0,
   GUID={0x48D17197,0x32CF,0x11D2,{0xA3,0x37,0x00,0xC0,0x4F,0xD7,0xC1,0xFC}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IKeyocxCtrl_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short IKeyocxCtrl_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    42
    };

static const MIDL_SERVER_INFO IKeyocxCtrl_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IKeyocxCtrl_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IKeyocxCtrl_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IKeyocxCtrl_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(9) _IKeyocxCtrlProxyVtbl = 
{
    &IKeyocxCtrl_ProxyInfo,
    &IID_IKeyocxCtrl,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* IKeyocxCtrl::CorpKeycode */ ,
    (void *)-1 /* IKeyocxCtrl::ISPKeycode */
};


static const PRPC_STUB_FUNCTION IKeyocxCtrl_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IKeyocxCtrlStubVtbl =
{
    &IID_IKeyocxCtrl,
    &IKeyocxCtrl_ServerInfo,
    9,
    &IKeyocxCtrl_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x50200dd, /* MIDL Version 5.2.221 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows NT 5.0 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CorpKeycode */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrBaseKey */

/* 24 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 26 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 28 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrKeycode */

/* 30 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 32 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 34 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 38 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ISPKeycode */

/* 42 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 50 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 58 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 60 */	NdrFcShort( 0x1 ),	/* 1 */
/* 62 */	NdrFcShort( 0x1 ),	/* 1 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrBaseKey */

/* 66 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 68 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 70 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrKeycode */

/* 72 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 74 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 76 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 80 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x4 ),	/* 4 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 40 */	NdrFcShort( 0x6 ),	/* Offset= 6 (46) */
/* 42 */	
			0x13, 0x0,	/* FC_OP */
/* 44 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (18) */
/* 46 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x4 ),	/* 4 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (42) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _keyocx_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IKeyocxCtrlProxyVtbl,
    0
};

const CInterfaceStubVtbl * _keyocx_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IKeyocxCtrlStubVtbl,
    0
};

PCInterfaceName const _keyocx_InterfaceNamesList[] = 
{
    "IKeyocxCtrl",
    0
};

const IID *  _keyocx_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _keyocx_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _keyocx, pIID, n)

int __stdcall _keyocx_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_keyocx_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo keyocx_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _keyocx_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _keyocx_StubVtblList,
    (const PCInterfaceName * ) & _keyocx_InterfaceNamesList,
    (const IID ** ) & _keyocx_BaseIIDList,
    & _keyocx_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Mon Feb 01 11:34:13 1999
 */
/* Compiler settings for keyocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "keyocx.h"

#define TYPE_FORMAT_STRING_SIZE   57                                
#define PROC_FORMAT_STRING_SIZE   93                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Standard interface: __MIDL_itf_keyocx_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IKeyocxCtrl, ver. 0.0,
   GUID={0x48D17197,0x32CF,0x11D2,{0xA3,0x37,0x00,0xC0,0x4F,0xD7,0xC1,0xFC}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IKeyocxCtrl_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short IKeyocxCtrl_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    46
    };

static const MIDL_SERVER_INFO IKeyocxCtrl_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IKeyocxCtrl_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IKeyocxCtrl_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IKeyocxCtrl_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(9) _IKeyocxCtrlProxyVtbl = 
{
    &IKeyocxCtrl_ProxyInfo,
    &IID_IKeyocxCtrl,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* IKeyocxCtrl::CorpKeycode */ ,
    (void *)-1 /* IKeyocxCtrl::ISPKeycode */
};


static const PRPC_STUB_FUNCTION IKeyocxCtrl_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IKeyocxCtrlStubVtbl =
{
    &IID_IKeyocxCtrl,
    &IKeyocxCtrl_ServerInfo,
    9,
    &IKeyocxCtrl_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x50200dd, /* MIDL Version 5.2.221 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CorpKeycode */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0xc,		/* 12 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcLong( 0x0 ),	/* 0 */

	/* Parameter bstrBaseKey */

/* 28 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 30 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 32 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrKeycode */

/* 34 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 36 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 38 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 40 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 42 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 44 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ISPKeycode */

/* 46 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 48 */	NdrFcLong( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x8 ),	/* 8 */
/* 60 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 62 */	0xc,		/* 12 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 64 */	NdrFcShort( 0x1 ),	/* 1 */
/* 66 */	NdrFcShort( 0x1 ),	/* 1 */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
/* 70 */	NdrFcLong( 0x0 ),	/* 0 */

	/* Parameter bstrBaseKey */

/* 74 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 76 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 78 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrKeycode */

/* 80 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 82 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 84 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 86 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 88 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 90 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x8 ),	/* 8 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 40 */	NdrFcShort( 0x6 ),	/* Offset= 6 (46) */
/* 42 */	
			0x13, 0x0,	/* FC_OP */
/* 44 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (18) */
/* 46 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (42) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _keyocx_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IKeyocxCtrlProxyVtbl,
    0
};

const CInterfaceStubVtbl * _keyocx_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IKeyocxCtrlStubVtbl,
    0
};

PCInterfaceName const _keyocx_InterfaceNamesList[] = 
{
    "IKeyocxCtrl",
    0
};

const IID *  _keyocx_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _keyocx_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _keyocx, pIID, n)

int __stdcall _keyocx_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_keyocx_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo keyocx_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _keyocx_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _keyocx_StubVtblList,
    (const PCInterfaceName * ) & _keyocx_InterfaceNamesList,
    (const IID ** ) & _keyocx_BaseIIDList,
    & _keyocx_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\keyocx\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__48D1718C_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_)
#define AFX_STDAFX_H__48D1718C_32CF_11D2_A337_00C04FD7C1FC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__48D1718C_32CF_11D2_A337_00C04FD7C1FC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\parser\controls.cpp ===
//--------------------------------------------------------------------------
//
//  controls.cpp
//
//--------------------------------------------------------------------------

#include <w95wraps.h>
#include <windows.h>
#include <commctrl.h>
#include <shlwapi.h>
#include <stdlib.h>
#include "parse.h"
#include "controls.h"
#include "resource.h"

extern HINSTANCE g_hInst;

#define CHECKBOX_HEIGHT         25
#define EDITTEXT_HEIGHT         23
#define DROPDOWNLIST_HEIGHT     23
#define NUMERIC_HEIGHT          23
#define TEXT_HEIGHT             23
#define COMBOBOX_HEIGHT         23
#define EDITTEXT_WIDTH          300
#define DROPDOWNLIST_WIDTH      300
#define DROPDOWNLIST_WIDTH_LF   400
#define NUMERIC_WIDTH           75
#define COMBOBOX_WIDTH          300
#define BUTTON_HEIGHT           25
#define BUTTON_WIDTH            75

#define CHECKBOX_ONLY_WIDTH     21

extern HINSTANCE g_hInst;
extern BOOL g_fAdmDirty;

void InitFont(HWND hWnd);
INT_PTR CALLBACK ValueDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

LRESULT APIENTRY ControlWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT rectWnd;
    RECT rectControl;
    WNDPROC lpOrgControlProc;
    HWND hCategoryWnd;
    SCROLLINFO si;
    LPCONTROLINFO lpControlInfo = NULL;
    LPMSG lpmsg;
    LRESULT lRet;
 
    lpControlInfo = (LPCONTROLINFO) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    if (lpControlInfo != NULL)
        lpOrgControlProc = (WNDPROC) lpControlInfo->lpOrgControlProc;
    else
        return FALSE;
    switch(message)
    {
        case WM_GETDLGCODE: // to handle the return/enter key for push button control
            if(((LPPART)lpControlInfo->lpPart)->nType == PART_LISTBOX)
            {
                lRet = CallWindowProc(lpOrgControlProc, hWnd, message, wParam, lParam);
                if (lParam)
                {
                    lpmsg = (LPMSG) lParam;
                    if (lpmsg->message == WM_KEYDOWN)
                    {
                        if (lpmsg->wParam == VK_RETURN)
                            lRet |= DLGC_WANTMESSAGE;
                    }
                }
                return (lRet);
            }
            break;

        case WM_SETFOCUS:
            hCategoryWnd = GetParent(GetParent(hWnd));
            GetWindowRect(hCategoryWnd, &rectWnd);
            GetWindowRect(hWnd, &rectControl);
            if(rectControl.bottom + 5 > rectWnd.bottom)
            {
                if((rectControl.top > rectWnd.bottom) && GetParent((HWND) wParam) != GetParent(hWnd))
                {
                    ZeroMemory(&si, sizeof(SCROLLINFO));
                    si.cbSize = sizeof(SCROLLINFO);
                    si.fMask = SIF_RANGE;
                    GetScrollInfo(hCategoryWnd, SB_VERT, &si);
                    SendMessage(hCategoryWnd, WM_VSCROLL, MAKEWPARAM(SB_THUMBPOSITION, si.nMax), 0L);
                }
                else
                {
                    int nScrollDown = (rectControl.bottom + 5) - rectWnd.bottom;
                    do {
                        SendMessage(hCategoryWnd, WM_VSCROLL, MAKEWPARAM(SB_LINEDOWN, 0), 0L);
                    }while((nScrollDown -= SCROLL_LINE) > 0);
                }
            }
            else if(rectControl.top - 5 < rectWnd.top)
            {
                if(GetParent((HWND) wParam) != GetParent(hWnd))
                    SendMessage(hCategoryWnd, WM_VSCROLL, MAKEWPARAM(SB_THUMBPOSITION, 0), 0L);
                else
                {
                    int nScrollUp = rectWnd.top - (rectControl.top - 5);
                    do{
                        SendMessage(hCategoryWnd, WM_VSCROLL, MAKEWPARAM(SB_LINEUP, 0), 0L);
                    }while((nScrollUp -= SCROLL_LINE) > 0);
                }
            }
            break;

        case WM_KEYDOWN:
            if (wParam == VK_RETURN) // handle the return/enter key for push button control
            {
                if(((LPPART)lpControlInfo->lpPart)->nType == PART_LISTBOX)
                    DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_VALUEDLG), hWnd, ValueDialogProc, (LPARAM)hWnd);
            }
            break;

        case WM_KILLFOCUS:
            if(((LPPART)lpControlInfo->lpPart)->nType == PART_NUMERIC)
            {
                TCHAR szValue[MAX_PATH];
                int   nValue;

                GetWindowText(hWnd, szValue, ARRAYSIZE(szValue));
                nValue = StrToInt(szValue);
                if (nValue < ((LPPART)lpControlInfo->lpPart)->nMin)
                    nValue = ((LPPART)lpControlInfo->lpPart)->nMin;
                else if (((LPPART)lpControlInfo->lpPart)->nMax > 0 && nValue > ((LPPART)lpControlInfo->lpPart)->nMax)
                    nValue = ((LPPART)lpControlInfo->lpPart)->nMax;

                wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), nValue);
                SetWindowText(hWnd, szValue);
            }
            break;

        default:
            break;

    }
    return CallWindowProc(lpOrgControlProc, hWnd, message, wParam, lParam);
}

INT_PTR CALLBACK ValueDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND hList = GetDlgItem(hDlg, IDC_VALUELIST);
    TCHAR szValueName[10];
    TCHAR szValue[MAX_PATH];
    int nItem = 0;
    LPCONTROLINFO lpControlInfo;
    LPPART pPart;
    LPPARTDATA pPartData;
    TCHAR szMsg[100];
    TCHAR szTitle[20];
    
    switch(message)
    {
    case WM_INITDIALOG:
        InitFont(GetDlgItem(hDlg, IDC_VALUE_ED));
        InitFont(GetDlgItem(hDlg, IDC_VALUELIST));

        SendMessage(GetDlgItem(hDlg, IDC_VALUE_ED), EM_SETLIMITTEXT, MAX_PATH, 0L);

        EnableWindow(GetDlgItem(hDlg, IDC_DELETE), FALSE);

        LoadString(g_hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hDlg, szTitle);

        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam);   // save the show button control pointer
        lpControlInfo = (LPCONTROLINFO) GetWindowLongPtr((HWND)lParam, GWLP_USERDATA);
        pPartData = lpControlInfo->lpPartData;
        if(pPartData != NULL && pPartData->nActions != 0)
        {
            LoadString(g_hInst, IDS_LISTINSERTFAIL, szMsg, ARRAYSIZE(szMsg));
            for(int nIndex = 0; nIndex < pPartData->actionlist[0].nValues; nIndex++)
            {
                if(SendMessage(hList, LB_ADDSTRING, 0, (LPARAM) (LPCTSTR) pPartData->actionlist[0].value[nIndex].szValue) == LB_ERR)
                {
                    MessageBox(hDlg, szMsg, szTitle, MB_OK);
                    break;
                }
            }
        }

        SetWindowLongPtr(hList, GWLP_USERDATA, 0);

        SendMessage(hDlg, DM_SETDEFID, IDC_ADD, 0L);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch(LOWORD(wParam))
            {
            case IDC_ADD:
                LoadString(g_hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
                memset(szValue, 0, sizeof(szValue));
                GetDlgItemText(hDlg, IDC_VALUE_ED, szValue, ARRAYSIZE(szValue));
                if(*szValue == 0)
                {
                    LoadString(g_hInst, IDS_VALUETEXTNULL, szMsg, ARRAYSIZE(szMsg));
                    MessageBox(hDlg, szMsg, szTitle, MB_OK);
                }
                else
                {
                    if(SendMessage(hList, LB_ADDSTRING, 0, (LPARAM) (LPCTSTR) szValue) == LB_ERR)
                    {
                        LoadString(g_hInst, IDS_LISTINSERTFAIL, szMsg, ARRAYSIZE(szMsg));
                        MessageBox(hDlg, szMsg, szTitle, MB_OK);
                        break;
                    }
                    SetWindowLongPtr(hList, GWLP_USERDATA, 1);
                    SetDlgItemText(hDlg, IDC_VALUE_ED, TEXT('\0'));
                }
                break;

            case IDC_DELETE:
                if((nItem = (int) SendMessage(hList, LB_GETCURSEL, 0, 0L)) == LB_ERR)
                    break;
                SendMessage(hList, LB_DELETESTRING, (WPARAM) nItem, 0L);
                SetWindowLongPtr(hList, GWLP_USERDATA, 1);
                break;

            case IDOK:
                if (GetWindowLongPtr(hList, GWLP_USERDATA))
                {
                    lpControlInfo = (LPCONTROLINFO) GetWindowLongPtr((HWND)GetWindowLongPtr(hDlg, GWLP_USERDATA), GWLP_USERDATA);
                    pPart = lpControlInfo->lpPart;
                    pPartData = lpControlInfo->lpPartData;
                    // Free original memory
                    if(pPartData != NULL && pPartData->nActions != 0)
                    {
                        for(int nValueIndex = 0; nValueIndex < pPartData->actionlist[0].nValues; nValueIndex++)
                        {
                            if(pPartData->actionlist[0].value[nValueIndex].szKeyname)
                                LocalFree(pPartData->actionlist[0].value[nValueIndex].szKeyname);
                            if(pPartData->actionlist[0].value[nValueIndex].szValueName)
                                LocalFree(pPartData->actionlist[0].value[nValueIndex].szValueName);
                            if(pPartData->actionlist[0].value[nValueIndex].szValue)
                                LocalFree(pPartData->actionlist[0].value[nValueIndex].szValue);
                        }
                        HeapFree(GetProcessHeap(), 0, pPartData->actionlist[0].value);
                    }
                    // Reallocate memory
                    if(pPartData->nActions == 0)
                        pPartData->actionlist = (LPACTIONLIST) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ACTIONLIST) * 1);
                    if(pPartData->actionlist != NULL)
                    {
                        int nItems = (int) SendMessage(hList, LB_GETCOUNT, 0, 0L);

                        pPartData->nActions = 1;
                        pPartData->actionlist[0].value = (LPVALUE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(VALUE) * nItems);
                        if(pPartData->actionlist[0].value != NULL)
                        {
                            pPartData->actionlist[0].nValues = nItems;
                            for(int nIndex = 0; nIndex < nItems; nIndex++)
                            {
                                memset(szValue, 0, sizeof(szValue));
                                memset(szValueName, 0, sizeof(szValueName));
                                if(SendMessage(hList, LB_GETTEXT, (WPARAM) nIndex, (LPARAM) (LPCTSTR) szValue) != LB_ERR)
                                {
                                    pPartData->actionlist[0].value[nIndex].szKeyname = StrDup(pPart->value.szKeyname);
                                    wnsprintf(szValueName, ARRAYSIZE(szValueName), TEXT("%d"), (nIndex + 1));
                                    if(ISNONNULL(szValueName))
                                        pPartData->actionlist[0].value[nIndex].szValueName = StrDup(szValueName);
                                    if(ISNONNULL(szValue))
                                        pPartData->actionlist[0].value[nIndex].szValue = StrDup(szValue);
                                }
                            }
                            
                            if(nItems != 0)
                            {
                                pPartData->value.fNumeric = TRUE;
                                pPartData->value.dwValue = 1;
                            }
                        }
                    }
                    
                    g_fAdmDirty = TRUE;
                    pPartData->fSave = TRUE;
                }

                EndDialog(hDlg, 1);
                break;

            case IDCANCEL:
                EndDialog(hDlg, 1);
                break;

            default:
                break;

            }
            break;

        case LBN_SELCHANGE:
            if(SendMessage(hList, LB_GETCURSEL, 0, 0L) == LB_ERR)
                EnableWindow(GetDlgItem(hDlg, IDC_DELETE), FALSE);
            else
                EnableWindow(GetDlgItem(hDlg, IDC_DELETE), TRUE);
        }
        break;

    case WM_DESTROY:
        SendMessage(hList, LB_RESETCONTENT, 0, 0L);
        break;

    default:
        return 0;
    }

    return 1;
}

LRESULT APIENTRY FrameWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WNDPROC lpOrgFrameProc;
    HWND hwndCtl = NULL;
    LPCONTROLINFO lpControlInfo;
    LPNMUPDOWN    lpNumUpDown;

    switch(message)
    {
        case WM_COMMAND:
            if(HIWORD(wParam) == BN_CLICKED)
            {
                hwndCtl = (HWND) lParam;
                lpControlInfo = (LPCONTROLINFO) GetWindowLongPtr(hwndCtl, GWLP_USERDATA);
                if(lpControlInfo != NULL && ((LPPART)lpControlInfo->lpPart)->nType == PART_LISTBOX)
                    DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_VALUEDLG), hwndCtl, ValueDialogProc, (LPARAM)hwndCtl);
            }
            break;

        case WM_NOTIFY:
            lpNumUpDown = (LPNMUPDOWN) lParam;
            if (lpNumUpDown->hdr.code == UDN_DELTAPOS)
            {
                hwndCtl = (HWND) SendMessage(lpNumUpDown->hdr.hwndFrom, UDM_GETBUDDY, 0, 0L);
                if (hwndCtl != NULL)
                {
                    lpControlInfo = (LPCONTROLINFO) GetWindowLongPtr(hwndCtl, GWLP_USERDATA);
                    if (lpControlInfo != NULL && ((LPPART)lpControlInfo->lpPart)->nType == PART_NUMERIC)
                    {
                        int nSpin = ((LPPART)lpControlInfo->lpPart)->nSpin;

                        if (nSpin != 0)
                            lpNumUpDown->iDelta *= nSpin; // iDelta is by default 1 for increments & -1 for decrements.
                    }
                }
            }
            break;

        default:
            break;

    }
    lpOrgFrameProc = (WNDPROC) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    return CallWindowProc(lpOrgFrameProc, hWnd, message, wParam, lParam);
}


//--------------------------------------------------------------------------
//  CAdmControl member functions
//--------------------------------------------------------------------------

CAdmControl::CAdmControl( )
{
    hControl = NULL;
    hUpDown = NULL;
    nControlX = nControlY = nControlWidth = nControlHeight = 0;
    fCreated = FALSE;
    nPart = -1;
}

CAdmControl::~CAdmControl( )
{
    label.Destroy( );
}

//--------------------------------------------------------------------------
//  CAdmControl     C R E A T E
//
//--------------------------------------------------------------------------
int CAdmControl::Create( HWND hwndParent, int x, int y, int nWidth, int nHeight, int nMaxTextWidth,
                        LPPART part, LPPARTDATA pPartData, BOOL fRSoPMode)
{
    int i;
    TCHAR szValue[10];
    WNDPROC lpOrgControlProc;
    int nTextWidth = nWidth;
    BOOL bContinue = TRUE;
    DWORD dwType = CSW_LABEL;
    CONTROLINFO* lpControlInfo = NULL;
    TCHAR szMsg[MAX_PATH];
    HDC hDC;
    SIZE size;

    if(part->nType == PART_ERROR)
        return y;
    if (part->nType == PART_POLICY && !part->fRequired && StrCmp(part->szCategory, part->szName) == 0)
        return y;

    if( part->nType != PART_CHECKBOX )
    {
        if(part->nType == PART_POLICY)
        {
            if(!part->fRequired)
            {
                dwType = CSW_BOLDLABEL;
                y += 2;
            }
            else
                bContinue = FALSE;
        }

        if(bContinue)
        {
            if(!nTextWidth)
                nTextWidth = nMaxTextWidth;
            label.Create( hwndParent, x, y, nTextWidth, TEXT_HEIGHT, dwType );
            y += label.SetText( part->szName );
            if (part->nType != PART_POLICY)
                y += 2;
        }
    }

	DWORD dwDynamicStyles = 0L;
	if (fRSoPMode)
		dwDynamicStyles = WS_DISABLED;

    switch( part->nType )
    {
    case PART_EDITTEXT:
        if(!nHeight)
            nHeight = EDITTEXT_HEIGHT;
        if(!nWidth)
            nWidth = (nMaxTextWidth >= EDITTEXT_WIDTH) ? EDITTEXT_WIDTH : nMaxTextWidth;
        hControl = CreateWindowEx( WS_EX_CLIENTEDGE, TEXT("EDIT"), pPartData->value.szValue,
            WS_VISIBLE | WS_CHILD | WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL | dwDynamicStyles,
            x, y, nWidth, nHeight, hwndParent, NULL, g_hInst, NULL );
        if (hControl && part->nMax)
            SendMessage(hControl, EM_SETLIMITTEXT, part->nMax, 0L);
        y += 6;
        break;

    case PART_DROPDOWNLIST:

        if (!nHeight) 
            nHeight = DROPDOWNLIST_HEIGHT;
        if(!nWidth)
        {
            //we need to set the width to something proportionate to the font size
            int nTempWidth;
            HDC hDC;
            hDC = GetDC(hwndParent);
            int ipx = GetDeviceCaps(hDC,LOGPIXELSX);
            if (ipx <= 96)
                nTempWidth = DROPDOWNLIST_WIDTH;  //small fonts or smaller
            else 
                nTempWidth = DROPDOWNLIST_WIDTH_LF;  //large fonts--increase size
            
            nWidth = (nMaxTextWidth >= nTempWidth) ? (nTempWidth) : (nMaxTextWidth);
        }
        hControl = CreateWindowEx( WS_EX_CLIENTEDGE, TEXT("COMBOBOX"), pPartData->value.szValue,
            WS_VISIBLE | WS_CHILD | WS_BORDER | WS_TABSTOP | CBS_DROPDOWNLIST | CBS_AUTOHSCROLL |
			WS_VSCROLL | dwDynamicStyles,
            x, y, nWidth, nHeight * 4, hwndParent, NULL, g_hInst, NULL );

        for( i = 0; i < part->nActions; i++ )
        {
            int nIndex = (int) SendMessage( hControl, CB_ADDSTRING, 0, (LPARAM) part->actionlist[i].szName );

            if( StrCmp( pPartData->value.szValue, part->actionlist[i].szName ) == 0 )
            {
                SendMessage( hControl, CB_SETCURSEL, (WPARAM) nIndex, 0 );
            }
        }
        y += 6;
        break;

    case PART_NUMERIC:
        if(!nHeight)
            nHeight = NUMERIC_HEIGHT;
        if(!nWidth)
            nWidth = (nMaxTextWidth >= NUMERIC_WIDTH) ? NUMERIC_WIDTH : nMaxTextWidth;
        hControl = CreateWindowEx( WS_EX_CLIENTEDGE, TEXT("EDIT"), TEXT(""),
            WS_VISIBLE | WS_CHILD | WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL | ES_NUMBER | dwDynamicStyles,
            x, y, nWidth, nHeight, hwndParent, NULL, g_hInst, NULL );
        hUpDown = CreateUpDownControl( WS_CHILD | WS_BORDER | WS_VISIBLE | UDS_ALIGNRIGHT | UDS_SETBUDDYINT | UDS_ARROWKEYS | UDS_NOTHOUSANDS,
            x + nWidth, y, 20, nHeight, hwndParent, 5,  // BUG BUG - need real id
            g_hInst, hControl, part->nMax, part->nMin, part->nDefault );
        wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), pPartData->value.dwValue );
        SendMessage( hControl, WM_SETTEXT, 0, (LPARAM) szValue);
        y += 6;
        break;

    case PART_POLICY:
        if(!part->fRequired)
        {
            nHeight = 0;
            y += 6;
            break;
        }
        // if policy is a part continue with the next case statement

    case PART_CHECKBOX:
        if(!nHeight)
            nHeight = CHECKBOX_HEIGHT;
        if(!nWidth)
            nWidth = nMaxTextWidth;
        
        // get the height required for the checkbox
        {
            CStaticWindow label;

            label.Create( hwndParent, x, y, nWidth - CHECKBOX_ONLY_WIDTH, nHeight, CSW_LABEL );
            nHeight = label.SetText( part->szName );
        }

        hControl = CreateWindowEx( 0, TEXT("BUTTON"), part->szName,
            WS_VISIBLE | WS_CHILD  | WS_TABSTOP | BS_AUTOCHECKBOX | BS_MULTILINE | dwDynamicStyles,
            x, y, nWidth, nHeight, hwndParent, NULL, g_hInst, NULL );

        if( pPartData->value.dwValue )
            SendMessage( hControl, BM_SETCHECK, TRUE, 0 );
        else
            SendMessage( hControl, BM_SETCHECK, FALSE, 0 );
        y += 6;
        break;

    case PART_LISTBOX:
        if(!nHeight)
            nHeight = BUTTON_HEIGHT;
        if(!nWidth)
            nWidth = (nMaxTextWidth >= BUTTON_WIDTH) ? BUTTON_WIDTH : nMaxTextWidth;
        LoadString(g_hInst, IDS_SHOWBUTTON, szMsg, ARRAYSIZE(szMsg));
        hControl = CreateWindowEx( 0, TEXT("BUTTON"), szMsg,
            WS_VISIBLE | WS_CHILD | WS_TABSTOP | BS_PUSHBUTTON | BS_NOTIFY | dwDynamicStyles,
            x, y, nWidth, nHeight, hwndParent, NULL, g_hInst, NULL );
        if(hControl)
        {
            hDC = GetDC(hControl);
            if(hDC)
            {
                GetTextExtentPoint32(hDC, szMsg, lstrlen(szMsg), &size);
                MoveWindow(hControl, x, y, size.cx + 20, (size.cy > nHeight) ? size.cy + 7 : nHeight, TRUE);
            }
            y += 6;
        }
        break;

    case PART_TEXT:
            nHeight = 0;
            y += 6;
        break;

    case PART_COMBOBOX:
        if(!nHeight)
            nHeight = COMBOBOX_HEIGHT;
        if(!nWidth)
            nWidth = (nMaxTextWidth >= COMBOBOX_WIDTH) ? COMBOBOX_WIDTH : nMaxTextWidth;
        hControl = CreateWindowEx( WS_EX_CLIENTEDGE, TEXT("COMBOBOX"), pPartData->value.szValue,
            WS_VISIBLE | WS_CHILD | WS_BORDER | WS_TABSTOP | CBS_DROPDOWN | CBS_AUTOHSCROLL | dwDynamicStyles,
            x, y, nWidth, nHeight * 4, hwndParent, NULL, g_hInst, NULL );

        for( i = 0; i < part->nSuggestions; i++ )
        {
            SendMessage( hControl, CB_ADDSTRING, 0, (LPARAM) part->suggestions[i].szText );
        }
        SendMessage( hControl, WM_SETTEXT, 0, (LPARAM) pPartData->value.szValue );
        y += 6;
        break;
    }

    if(hControl != NULL)
    {
        InitFont(hControl);

        lpOrgControlProc = (WNDPROC) GetWindowLongPtr(hControl, GWLP_WNDPROC);
        SetWindowLongPtr(hControl, GWLP_WNDPROC, (LONG_PTR) &ControlWndProc);

        lpControlInfo = (LPCONTROLINFO) LocalAlloc((LPTR), sizeof(CONTROLINFO));
        lpControlInfo->lpOrgControlProc = lpOrgControlProc;
        lpControlInfo->lpPart = part;
        lpControlInfo->lpPartData = pPartData;
        SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR) lpControlInfo);
        fCreated = TRUE;
    }
    return y + nHeight;
}

//--------------------------------------------------------------------------
//  CAdmControl     D E S T R O Y
//--------------------------------------------------------------------------
void CAdmControl::Destroy( )
{
    if( hControl != NULL )
    {
        LPCONTROLINFO lpControlInfo = (LPCONTROLINFO) GetWindowLongPtr(hControl, GWLP_USERDATA);
        if (lpControlInfo != NULL)
        {
            SetWindowLongPtr(hControl, GWLP_WNDPROC, (LONG_PTR) lpControlInfo->lpOrgControlProc);
            LocalFree(lpControlInfo);
            SetWindowLongPtr(hControl, GWLP_USERDATA, 0L);
        }
        DestroyWindow( hControl );
        hControl = NULL;
    }
    if( hUpDown != NULL)
    {
        DestroyWindow( hUpDown );
        hUpDown = NULL;
    }
}

//--------------------------------------------------------------------------
//  CAdmControl     S A V E
//--------------------------------------------------------------------------
void CAdmControl::Save( LPPART part, LPPARTDATA pPartData )
{
    int nCheck;
    TCHAR szText[1024];
    DWORD dwTemp;

    ZeroMemory(szText, sizeof(szText));
    
    switch( part->nType )
    {
    case PART_EDITTEXT:
    case PART_COMBOBOX:
        GetWindowText( hControl, szText, ARRAYSIZE(szText));
        if (!pPartData->fSave ||
            (pPartData->value.szValue == NULL && *szText != TEXT('\0')) || 
            (pPartData->value.szValue != NULL && StrCmp(pPartData->value.szValue, szText) != 0))
        {
            g_fAdmDirty = TRUE;
            pPartData->fSave = TRUE;
        }
        if(pPartData->value.szValue != NULL)
            LocalFree(pPartData->value.szValue);
        pPartData->value.szValue = NULL;
        if(ISNONNULL(szText))
            pPartData->value.szValue = StrDup(szText);
        break;

    case PART_DROPDOWNLIST:
        GetWindowText( hControl, szText, ARRAYSIZE(szText));
        if (!pPartData->fSave ||
            (pPartData->value.szValue == NULL && *szText != 0) || 
            (pPartData->value.szValue != NULL && StrCmp(pPartData->value.szValue, szText) != 0))
        {
            g_fAdmDirty = TRUE;
            pPartData->fSave = TRUE;
        }
        if(pPartData->value.szValue != NULL)
            LocalFree(pPartData->value.szValue);
        pPartData->value.szValue = NULL;
        if(ISNONNULL(szText))
            pPartData->value.szValue = StrDup(szText);
        pPartData->nSelectedAction = (int) SendMessage( hControl, CB_GETCURSEL, 0, 0 );
        if( pPartData->nSelectedAction == CB_ERR )
            pPartData->nSelectedAction = NO_ACTION;
        break;

    case PART_NUMERIC:
        GetWindowText( hControl, szText, ARRAYSIZE(szText));
        {
            int   nValue;
            
            nValue = StrToInt(szText);
            if (nValue < part->nMin)
                nValue = part->nMin;
            else if (part->nMax > 0 && nValue > part->nMax)
                nValue = part->nMax;

            wnsprintf(szText, ARRAYSIZE(szText), TEXT("%d"), nValue);
        }       
        
        if(pPartData->value.szValue != NULL)
            LocalFree(pPartData->value.szValue);
        pPartData->value.szValue = NULL;
        dwTemp = pPartData->value.dwValue;
        pPartData->value.dwValue = 0;
        if(ISNONNULL(szText))
        {
            pPartData->value.szValue = StrDup(szText);
            if (pPartData->value.szValue)
               pPartData->value.dwValue = StrToInt( pPartData->value.szValue );
        }
        pPartData->value.fNumeric = TRUE;
        if (!pPartData->fSave || dwTemp != pPartData->value.dwValue)
        {
            g_fAdmDirty = TRUE;
            pPartData->fSave = TRUE;
        }
        break;

    case PART_POLICY:
        if(!part->fRequired)
            break;

    case PART_CHECKBOX:
        nCheck = (int) SendMessage( hControl, BM_GETCHECK, 0, 0 );
        pPartData->value.fNumeric = TRUE;
        switch( nCheck )
        {
        case BST_CHECKED:
            if (!pPartData->fSave || pPartData->value.dwValue != 1)
            {
                g_fAdmDirty = TRUE;
                pPartData->fSave = TRUE;
            }
            pPartData->value.dwValue = 1;
            break;
        case BST_UNCHECKED:
            if (!pPartData->fSave || pPartData->value.dwValue != 0)
            {
                g_fAdmDirty = TRUE;
                pPartData->fSave = TRUE;
            }
            pPartData->value.dwValue = 0;
            break;
        }
        break;

    case PART_LISTBOX:
        pPartData->value.fNumeric = TRUE;
        break;
    }
}
//--------------------------------------------------------------------------
//  CAdmControl     M O V E  U P
//--------------------------------------------------------------------------
void CAdmControl::MoveUp( int nValue )
{
    label.MoveUp( nValue );
    nControlY -= nValue;
    if( hUpDown != NULL )
    {
        RECT r;
        GetWindowRect( hUpDown, &r );
        ::MoveWindow( hControl, nControlX, nControlY, nControlWidth-(r.right-r.left), nControlHeight, TRUE );
        ::MoveWindow( hUpDown, nControlX+nControlWidth-(r.right-r.left), nControlY, (r.right-r.left), nControlHeight, TRUE );
    }
    else
        ::MoveWindow( hControl, nControlX, nControlY, nControlWidth, nControlHeight, TRUE );
}

//--------------------------------------------------------------------------
//  CAdmControl     M O V E  L E F T
//--------------------------------------------------------------------------
void CAdmControl::MoveLeft( int nValue )
{
    label.MoveLeft( nValue );
    nControlX -= nValue;
    if( hUpDown != NULL )
    {
        RECT r;
        GetWindowRect( hUpDown, &r );
        ::MoveWindow( hControl, nControlX, nControlY, nControlWidth-(r.right-r.left), nControlHeight, TRUE );
        ::MoveWindow( hUpDown, nControlX+nControlWidth-(r.right-r.left), nControlY, (r.right-r.left), nControlHeight, TRUE );
    }
    else
        ::MoveWindow( hControl, nControlX, nControlY, nControlWidth, nControlHeight, TRUE );
}

//--------------------------------------------------------------------------
//  CAdmControl     R E S E T
//--------------------------------------------------------------------------
void CAdmControl::Reset(LPPART part, LPPARTDATA pPartData)
{
    int nIndex = 0;
    TCHAR szValue[10];
    HWND hwndParent;
    RECT rectWnd;
    RECT rectControl;

    switch( part->nType )
    {
    case PART_EDITTEXT:
        if(pPartData->value.szValue)
            SendMessage( hControl, WM_SETTEXT, 0, (LPARAM) pPartData->value.szValue );
        else
            SendMessage( hControl, WM_SETTEXT, 0, (LPARAM) "" );
        break;

    case PART_DROPDOWNLIST:
        if(pPartData->value.szValue != NULL)
        {
            for( nIndex = 0; nIndex < part->nActions; nIndex++ )
            {
                if( part->actionlist[nIndex].szName != NULL && StrCmp( pPartData->value.szValue, part->actionlist[nIndex].szName ) == 0 )
                {
                    SendMessage( hControl, CB_SETCURSEL, (WPARAM) nIndex, 0 );
                }
            }
        }
        else if(part->nActions != 0)
            SendMessage( hControl, CB_SETCURSEL, (WPARAM) -1, 0 );
        break;

    case PART_NUMERIC:
        if(hUpDown != NULL)
        {
            hwndParent = GetParent(hUpDown);
            GetWindowRect(hwndParent, &rectWnd);
            GetWindowRect(hUpDown, &rectControl);
            DestroyWindow(hUpDown);
            hUpDown = CreateUpDownControl( WS_CHILD | WS_BORDER | WS_VISIBLE | UDS_ALIGNRIGHT | UDS_SETBUDDYINT | UDS_ARROWKEYS,
                rectControl.left - rectWnd.left, rectControl.top - rectWnd.top, rectControl.right - rectControl.left,
                rectControl.bottom - rectControl.top, hwndParent, 5,  // BUG BUG - need real id
                g_hInst, hControl, part->nMax, part->nMin, part->nDefault );
        }
        wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), pPartData->value.dwValue );
        SendMessage( hControl, WM_SETTEXT, 0, (LPARAM) szValue);
        break;

    case PART_POLICY:
        if(!part->fRequired)
            break;

    case PART_CHECKBOX:
        if( pPartData->value.dwValue )
            SendMessage( hControl, BM_SETCHECK, TRUE, 0 );
        else
            SendMessage( hControl, BM_SETCHECK, FALSE, 0 );
        break;

//    case PART_LISTBOX:
//        break;

    case PART_COMBOBOX:
        if(pPartData->value.szValue  != NULL)
            SendMessage( hControl, WM_SETTEXT, 0, (LPARAM) part->value.szValue );
        else
            SendMessage( hControl, WM_SETTEXT, 0, (LPARAM) "" );
        break;

    default:
        break;
    }
}

//--------------------------------------------------------------------------
//  CAdmControl     G E T  P A R T
//--------------------------------------------------------------------------
int CAdmControl::GetPart()
{
    return nPart;
}

//--------------------------------------------------------------------------
//  CAdmControl     S E T  P A R T
//--------------------------------------------------------------------------
void CAdmControl::SetPart(int nPartNo)
{
    nPart = nPartNo;
}

//--------------------------------------------------------------------------
//  CStaticWindow member functions

CStaticWindow::CStaticWindow( )
{
    fCreated  = FALSE;
    nControlX = nControlY = nControlWidth = nControlHeight = 0;
    hWnd      = NULL;
    dwType    = 0;
}

CStaticWindow::~CStaticWindow( )
{
    Destroy();
}

//--------------------------------------------------------------------------
//  CStaticWindow   C R E A T E
//--------------------------------------------------------------------------
void CStaticWindow::Create( HWND hwndParent, int x, int y, int nWidth, int nHeight, DWORD dwFlags )
{
    WNDPROC lpOrgFrameProc;

    nControlX = x;
    nControlY = y;
    nControlWidth = nWidth;
    nControlHeight = nHeight;

    if( HasFlag(dwFlags, CSW_BORDER) )
    {
        hWnd = CreateWindowEx( WS_EX_CLIENTEDGE | WS_EX_CONTROLPARENT, TEXT("STATIC"), TEXT(""),
            WS_VISIBLE | WS_CHILD | WS_BORDER, x, y, nWidth, nHeight, hwndParent,
            NULL, g_hInst, NULL );
    }
    if( HasFlag(dwFlags, CSW_LABEL) )
    {
        hWnd = CreateWindowEx( 0, TEXT("STATIC"), TEXT(""),
            WS_VISIBLE | WS_CHILD | SS_LEFT | SS_NOPREFIX, x, y, nWidth, nHeight, hwndParent,
            NULL, g_hInst, NULL );
    }
    if( HasFlag(dwFlags, CSW_FRAME) )
    {
        hWnd = CreateWindowEx( WS_EX_CONTROLPARENT, TEXT("STATIC"), TEXT(""),
            WS_VISIBLE | WS_CHILD, x, y, nWidth, nHeight, hwndParent,
            NULL, g_hInst, NULL );

        lpOrgFrameProc = (WNDPROC) GetWindowLongPtr(hWnd, GWLP_WNDPROC);
        SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR) FrameWndProc);
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)lpOrgFrameProc);
    }

    dwType = dwFlags;
    if(hWnd != NULL)
    {
        HFONT hFont = NULL;

        fCreated = TRUE;

        hFont = GetFont();        
        if (hFont != NULL)
            SendMessage( hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
    }
}

//--------------------------------------------------------------------------
//  CStaticWindow   M O V E  W I N D O W
//--------------------------------------------------------------------------
void CStaticWindow::MoveWindow( int x, int y, int nWidth, int nHeight )
{
    if( fCreated )
        ::MoveWindow( hWnd, x, y, nWidth, nHeight, TRUE );
}

//--------------------------------------------------------------------------
//  CStaticWindow   D E S T R O Y
//--------------------------------------------------------------------------
void CStaticWindow::Destroy( )
{
    if( fCreated )
    {
        DestroyWindow( hWnd );
        hWnd = NULL;
        fCreated = FALSE;
    }
}

//--------------------------------------------------------------------------
//  CStaticWindow   S E T  T E X T
//--------------------------------------------------------------------------
int CStaticWindow::SetText( LPTSTR szText )
{
    int nHeight = 0;

    if( fCreated )
    {
        HDC   hDC;
        RECT  rect;
        int   nWidth;
        HFONT hOldFont = NULL;
        HFONT hFont    = NULL;

        GetClientRect(hWnd, &rect);
        nWidth = rect.right;

        hFont = GetFont();
        hDC   = GetDC(hWnd);
        if (hFont != NULL)
            hOldFont = (HFONT) SelectObject(hDC, hFont);

        nHeight = DrawText(hDC, szText, -1, &rect, DT_LEFT | DT_WORDBREAK | DT_CALCRECT);

        if (hOldFont != NULL)
        {
            hFont = (HFONT)SelectObject(hDC, hOldFont);
            if (hFont)
                DeleteObject(hFont);
        }
        
        ReleaseDC(hWnd, hDC);

        SetWindowPos(hWnd, NULL, 0, 0, nWidth, nHeight, SWP_NOMOVE | SWP_NOZORDER);
        SetWindowText( hWnd, szText );
    }
    return nHeight;
}

//--------------------------------------------------------------------------
//  CStaticWindow   M O V E  U P
//--------------------------------------------------------------------------
void CStaticWindow::MoveUp( int nValue )
{
    nControlY -= nValue;
    ::MoveWindow( hWnd, nControlX, nControlY, nControlWidth, nControlHeight, TRUE );
}

//--------------------------------------------------------------------------
//  CStaticWindow   M O V E  L E F T
//--------------------------------------------------------------------------
void CStaticWindow::MoveLeft( int nValue )
{
    nControlX -= nValue;
    ::MoveWindow( hWnd, nControlX, nControlY, nControlWidth, nControlHeight, TRUE );
}

//--------------------------------------------------------------------------
//  CStaticWindow   H W N D
//--------------------------------------------------------------------------
HWND CStaticWindow::Hwnd( )
{
    return hWnd;
}

void InitFont(HWND hWnd)
{
    HFONT hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
    SendMessage( hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
}

HFONT CStaticWindow::GetFont()
{
    HFONT        hFont     = NULL;
    static TCHAR szFontName[LF_FACESIZE];
    static int   nFontSize = 0;

    if (HasOnlyFlag(dwType, CSW_BOLDLABEL) || HasOnlyFlag(dwType, CSW_ITALICLABEL))
    {
        HDC        hDC = GetDC(hWnd);
        LOGFONT    lf;
        TEXTMETRIC tm;

        ZeroMemory(&lf, sizeof(lf));

        if (nFontSize == 0)
        {
            TCHAR szFontSize[5];
            
            if (!LoadString(g_hInst, IDS_ADMBOLDFONT, szFontName, LF_FACESIZE))
                StrCpy(szFontName, TEXT("MS Sans Serif"));
            LoadString(g_hInst, IDS_ADMBOLDFONTSIZE, szFontSize, ARRAYSIZE(szFontSize));
            nFontSize = StrToInt(szFontSize);
            if (nFontSize < 8)
                nFontSize = 8;
        }
        
        StrCpy(lf.lfFaceName, szFontName);
        lf.lfHeight = -((nFontSize * GetDeviceCaps(hDC, LOGPIXELSY)) / 72);

        GetTextMetrics(hDC, &tm);
        lf.lfCharSet = tm.tmCharSet;
        
        ReleaseDC(hWnd, hDC);

        lf.lfWeight = FW_REGULAR;
        if (HasOnlyFlag(dwType, CSW_BOLDLABEL))
            lf.lfWeight = FW_BOLD;
        if (HasOnlyFlag(dwType, CSW_ITALICLABEL))
            lf.lfItalic = 1;

        hFont = CreateFontIndirect(&lf);
    }
    else
        hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);

    return hFont;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\parser\admui.cpp ===
//--------------------------------------------------------------------------
//
//              admui.cpp
//
//  IEAK Global Policy Template Functions
//
//--------------------------------------------------------------------------

#include <w95wraps.h>
#include <windows.h>
#include <stdlib.h>
#include <shlwapi.h>
#include "parse.h"
#include "controls.h"
#include "resource.h"

#define ADMUI_WIDTH     250
#define ADMUI_MARGIN    5
#define ADMUI_HEIGHT    25

#define MAX_ADM_ITEMS   100

// function prototypes from admparse.cpp

extern void ReadRegSettingsForADM(LPADMFILE admfile, LPPARTDATA pPartData,
								  BSTR bstrNamespace);
extern void ReadInfFile(LPADMFILE, LPCTSTR, LPPARTDATA);
extern BOOL ReadAdmFile(LPADMFILE, LPCTSTR);
extern void FreeAdmMemory(LPADMFILE);
extern void FreePartData(LPVOID*, int);
extern void WriteInfFile(LPADMFILE, LPCTSTR, LPPARTDATA);
extern LPCTSTR BaseFileName(LPCTSTR);
extern void FreeActionList(LPACTIONLIST pActionList, int nActions);

// private forward declarations

static HRESULT admInitHelper(LPCTSTR pcszAdmFile, LPCTSTR pcszInfFile, BSTR bstrNamespace, LPDWORD hAdm, LPVOID* pData);
static HRESULT admFinishedHelper(DWORD hAdm, LPCTSTR pcszInfFile, LPVOID pPartData);
static HRESULT createAdmUiHelper(DWORD hAdm, HWND hParent, int x, int y, int width, int height, 
                                 DWORD dwStyle, DWORD dwExStyle, LPCTSTR pcszCategory, HKEY hKeyClass,
                                 HWND *phWnd, LPVOID pPartData, LPVOID* pCategoryData, BOOL fRSoPMode);
static HRESULT getAdmCategoriesHelper(DWORD hAdm, LPTSTR pszCategories, int cchLength, int *nBytes);
static HRESULT checkDuplicateKeysHelper(DWORD hAdm, DWORD hCompareAdm, LPCTSTR pcszLogFile, BOOL bClearFile);
static HRESULT admResetHelper(DWORD hAdm, LPCTSTR pcszInfFile, LPVOID pPartData, LPVOID pCategoryData);
static void getFontInfoHelper(LPTSTR pszFontName, LPINT pnFontSize);

//--------------------------------------------------------------------------
//      Global Variables and local structure definitions
//--------------------------------------------------------------------------

typedef struct admUI
{
    HWND    hWnd;
    int     hAdm;
    int     nAdmWidth;
    int     nAdmHeight;
    CStaticWindow wndFrame;
    CStaticWindow wndCategory;
    CStaticWindow wndCategoryType;
    CAdmControl*  pControlList;
    int     nControls;
    int     nHOffset;
    int     nVOffset;
    int     nHMaxOffset;
    int     nVMaxOffset;
    int     nScrollPage;
    HKEY    hKeyClass;
    LPTSTR  pszCategory;
} ADMUI, *LPADMUI;

typedef struct admCreate
{
    LPPARTDATA  pPartData;
    LPADMUI     pAdmUI;
	BOOL		fRSoPMode;
} ADMCREATE, *LPADMCREATE;

HINSTANCE g_hInst;
ADMFILE admFile[MAX_ADM_ITEMS];
int     g_nAdmInstances = 0;
BOOL    g_fAdmDirty = FALSE;
CRITICAL_SECTION g_hAdmCriticalSection;


//--------------------------------------------------------------------------
//  D L L  M A I N
//
//  Program Entry Point
//--------------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hModule, DWORD fdwReason, LPVOID)
{
    g_hInst = hModule;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        InitializeCriticalSection(&g_hAdmCriticalSection);
        ZeroMemory(admFile, sizeof(ADMFILE) * MAX_ADM_ITEMS); // initializing the admui structure
    }
    
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        if (FindAtomA("AdmUiClass"))
        {
            for (int nIndex = 0; nIndex < g_nAdmInstances; nIndex++)
                FreeAdmMemory(&admFile[nIndex]);
        
            UnregisterClassA("AdmUiClass", g_hInst);
            DeleteAtom( FindAtomA( "AdmUiClass" ));
        }
        DeleteCriticalSection(&g_hAdmCriticalSection);
    }

    return TRUE;
}

//--------------------------------------------------------------------------
//  A D M  U I  P R O C
//
//  Window procedure used by CreateAdmUi
//--------------------------------------------------------------------------
LRESULT CALLBACK AdmUiProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    int delta;
    LPADMUI pAdmUI;

    pAdmUI = (LPADMUI)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch( msg )
    {
    case WM_CREATE:
        {
        int y = 5;
        int nControlsAlloc = 25;
        int nFrameWidth = 0;
        int nTextWidth = 0;
        int nCategoryPart = 0;
        int nControls = 0;
        BOOL bContinue = TRUE;
        RECT rect;
        TCHAR szMsg[MAX_PATH];
        LPCREATESTRUCT cs;
        TCHAR szCategoryText[MAX_PATH];
        LPADMCREATE pAdmCreate;

        cs = (LPCREATESTRUCT) lParam;
        pAdmCreate = (LPADMCREATE) cs->lpCreateParams;

        pAdmUI = pAdmCreate->pAdmUI;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pAdmUI);

        GetClientRect(hWnd, &rect);
        
        nFrameWidth = rect.right - 5;
        nTextWidth = nFrameWidth - (ADMUI_MARGIN * 4);

        pAdmUI->wndFrame.Create( hWnd, 0, 0, nFrameWidth, 8000, CSW_FRAME );
        pAdmUI->wndCategory.Create( pAdmUI->wndFrame.Hwnd(), ADMUI_MARGIN, y,
                    nFrameWidth - (ADMUI_MARGIN*2), ADMUI_HEIGHT, CSW_BOLDLABEL );
        StrCpy(szCategoryText, pAdmUI->pszCategory );
        y += pAdmUI->wndCategory.SetText( szCategoryText );
        pAdmUI->wndCategoryType.Create(pAdmUI->wndFrame.Hwnd(), ADMUI_MARGIN, y, 
                    nFrameWidth - (ADMUI_MARGIN*2), ADMUI_HEIGHT, CSW_ITALICLABEL);
        y += pAdmUI->wndCategoryType.SetText( TEXT(" ") );
        y += 6;

        pAdmUI->pControlList = (CAdmControl*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(CAdmControl) * nControlsAlloc);
        if(pAdmUI->pControlList == NULL)
            break;

        nControls = 0;
        for( int i = 0; i < admFile[pAdmUI->hAdm].nParts && bContinue; i++ )
        {
            if( StrCmpI( admFile[pAdmUI->hAdm].pParts[i].szCategory, pAdmUI->pszCategory ) == 0 &&
                admFile[pAdmUI->hAdm].pParts[i].hkClass == pAdmUI->hKeyClass)
            {
                if(nControls >= nControlsAlloc)
                {
                    LPVOID lpTemp = NULL;

                    nControlsAlloc += 20;
                    lpTemp = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pAdmUI->pControlList, sizeof(CAdmControl) * nControlsAlloc);
                    if(lpTemp == NULL)
                        bContinue = FALSE;
                    else
                        pAdmUI->pControlList = (CAdmControl*) lpTemp;
                }
                nCategoryPart = i;
                y = pAdmUI->pControlList[nControls].Create( pAdmUI->wndFrame.Hwnd(), ADMUI_MARGIN*3, y,
                                                    0, 0, nTextWidth, &(admFile[pAdmUI->hAdm].pParts[i]),
													&(pAdmCreate->pPartData[i]), pAdmCreate->fRSoPMode );
                pAdmUI->pControlList[nControls].SetPart(i);
                nControls++;
            }
        }
        pAdmUI->nControls = nControls;

        if(admFile[pAdmUI->hAdm].pParts[nCategoryPart].hkClass == HKEY_LOCAL_MACHINE)
        {
            LoadString(g_hInst, IDS_PERMACHINE, szMsg, ARRAYSIZE(szMsg));
            wnsprintf(szCategoryText, ARRAYSIZE(szCategoryText), TEXT("[ %s ]"), szMsg);
            pAdmUI->wndCategoryType.SetText(szCategoryText);

        }
        else if(admFile[pAdmUI->hAdm].pParts[nCategoryPart].hkClass == HKEY_CURRENT_USER)
        {
            LoadString(g_hInst, IDS_PERUSER, szMsg, sizeof(szMsg));
            wnsprintf(szCategoryText, ARRAYSIZE(szCategoryText), TEXT("[ %s ]"), szMsg);
            pAdmUI->wndCategoryType.SetText(szCategoryText);
        }

        if( pAdmUI->nAdmWidth < nFrameWidth )
            pAdmUI->nHMaxOffset = nFrameWidth - pAdmUI->nAdmWidth;
        else
            pAdmUI->nHMaxOffset = 0;

        SetScrollRange( hWnd, SB_HORZ, 0, pAdmUI->nHMaxOffset, TRUE );

        if( pAdmUI->nAdmHeight < (y + 5) )
            pAdmUI->nVMaxOffset = y - pAdmUI->nAdmHeight + 5;
        else
            pAdmUI->nVMaxOffset = 0;
        pAdmUI->nHOffset = 0;
        pAdmUI->nVOffset = 0;
        SetScrollRange( hWnd, SB_VERT, 0, pAdmUI->nVMaxOffset, TRUE );

        pAdmUI->nScrollPage = rect.bottom - 10;

        ShowWindow( hWnd, SW_SHOWNORMAL );
        }
        break;

    case WM_HSCROLL:
        delta = pAdmUI->nHOffset;
        switch( LOWORD(wParam) )
        {
        case SB_LINELEFT:
            if( pAdmUI->nHOffset > 0 )
                pAdmUI->nHOffset -= SCROLL_LINE;
            break;
        case SB_LINERIGHT:
            if( pAdmUI->nHOffset < pAdmUI->nHMaxOffset )
                pAdmUI->nHOffset += SCROLL_LINE;
            break;
        case SB_PAGELEFT:
            if( pAdmUI->nHOffset >= SCROLL_PAGE )
                pAdmUI->nHOffset -= SCROLL_PAGE;
            else if( pAdmUI->nHOffset < SCROLL_PAGE )
                pAdmUI->nHOffset = 0;
            break;
        case SB_PAGERIGHT:
            if( pAdmUI->nHOffset <= (pAdmUI->nHMaxOffset - SCROLL_PAGE))
                pAdmUI->nHOffset += SCROLL_PAGE;
            else if( pAdmUI->nHOffset > (pAdmUI->nHMaxOffset - SCROLL_PAGE))
                pAdmUI->nHOffset = pAdmUI->nHMaxOffset;
            break;
        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            pAdmUI->nHOffset = (short int) HIWORD(wParam);
            break;
        }

        SetScrollPos( hWnd, SB_HORZ, pAdmUI->nHOffset, TRUE );
        delta = pAdmUI->nHOffset - delta;
        if( delta != 0 )
        {
            pAdmUI->wndFrame.MoveLeft( delta );
        }
        break;

    case WM_VSCROLL:
        if( lParam == NULL )
        {
            delta = pAdmUI->nVOffset;
            switch( LOWORD(wParam) )
            {
            case SB_LINEUP:
                if( pAdmUI->nVOffset > 0 )
                    pAdmUI->nVOffset -= SCROLL_LINE;
                break;
            case SB_LINEDOWN:
                if( pAdmUI->nVOffset < pAdmUI->nVMaxOffset )
                    pAdmUI->nVOffset += SCROLL_LINE;
                break;
            case SB_PAGEUP:
                if( pAdmUI->nVOffset >= pAdmUI->nScrollPage )
                    pAdmUI->nVOffset -= pAdmUI->nScrollPage;
                else if( pAdmUI->nVOffset < pAdmUI->nScrollPage )
                    pAdmUI->nVOffset = 0;
                break;
            case SB_PAGEDOWN:
                if( pAdmUI->nVOffset <= (pAdmUI->nVMaxOffset - pAdmUI->nScrollPage ))
                    pAdmUI->nVOffset += pAdmUI->nScrollPage;
                else if( pAdmUI->nVOffset > (pAdmUI->nVMaxOffset - pAdmUI->nScrollPage ))
                    pAdmUI->nVOffset = pAdmUI->nVMaxOffset;
                break;
            case SB_THUMBTRACK:
            case SB_THUMBPOSITION:
                pAdmUI->nVOffset = (short int) HIWORD(wParam);
                break;
            }
            SetScrollPos( hWnd, SB_VERT, pAdmUI->nVOffset, TRUE );
            delta = pAdmUI->nVOffset - delta;
            if( delta != 0 )
            {
                pAdmUI->wndFrame.MoveUp( delta );
            }
        }
        break;

    case WM_DESTROY:
        if (pAdmUI != NULL)
        {
            if (pAdmUI->pszCategory != NULL)
                LocalFree(pAdmUI->pszCategory);
            GlobalFree(pAdmUI);
        }
        break;

    default:
        return DefWindowProc( hWnd, msg, wParam, lParam );
    }
    return 1;
}

//--------------------------------------------------------------------------
//  I N I T  A D M  P A R S E R
//
//  Parses an adm file and sets up memory addresses in structures
//--------------------------------------------------------------------------
BOOL InitAdmParser(DWORD hAdm, LPCTSTR szInput)
{
    if( !ReadAdmFile(&admFile[hAdm], szInput))
        return FALSE;

    return TRUE;
}

static int AdmGetNewInstance()
{
    for (int nIndex = 0; nIndex < MAX_ADM_ITEMS; nIndex++)
    {
        if (*admFile[nIndex].szFilename == TEXT('\0'))
            return nIndex;
    }

    // no more indexes available
    return -1;
}

//--------------------------------------------------------------------------
//  A D M  I N I T                          Exported Function
//
//  Parses an adm file into structures and loads an inf as defaults
//
//  Parameters:
//      szAdmFile:  full path to global policy template file
//      szInfFile:  full path to inf file
//      hAdm:       pointer to a dword to recieve an adm handle
//--------------------------------------------------------------------------
STDAPI AdmInitA(LPCSTR pcszAdmFile, LPCSTR pcszInfFile, BSTR bstrNamespace,
				LPDWORD lpdwAdm, LPVOID* pData)
{
    USES_CONVERSION;

    return admInitHelper(A2CT(pcszAdmFile), A2CT(pcszInfFile), bstrNamespace,
						lpdwAdm, pData);
}

STDAPI AdmInitW(LPCWSTR pcwszAdmFile, LPCWSTR pcwszInfFile, BSTR bstrNamespace,
				LPDWORD lpdwAdm, LPVOID* pData)
{
    USES_CONVERSION;

    return admInitHelper(W2CT(pcwszAdmFile), W2CT(pcwszInfFile), bstrNamespace,
						lpdwAdm, pData);
}

//--------------------------------------------------------------------------
//  A D M  F I N I S H E D                  Exported Function
//
//  Saves all data into an .inf file
//
//  Parameters:
//      hAdm:       adm handle
//      szInfFile:  full path name to the inf to write
//--------------------------------------------------------------------------


STDAPI AdmFinishedA(DWORD hAdm, LPCSTR pcszInfFile, LPVOID pPartData)
{
    USES_CONVERSION;

    return admFinishedHelper(hAdm, A2CT(pcszInfFile), pPartData);
}

STDAPI AdmFinishedW(DWORD hAdm, LPCWSTR pcwszInfFile, LPVOID pPartData)
{
    USES_CONVERSION;

    return admFinishedHelper(hAdm, W2CT(pcwszInfFile), pPartData);
}

//--------------------------------------------------------------------------
//  C R E A T E  A D M  U I                 Exported Function
//
//  Creates a user interface based on an adm file
//
//  Parameters:
//      hAdm:       adm handle
//      hParent:    parent window
//      x, y, width, height:    location and dimensions of window to create
//      dwStyle:    additional style flags to pass to window creation
//      dwExStyle:  additional extra style flags to pass to window creation
//      szCategory: a string specifying the adm category to display
//      hWnd:       a pointer to an HWND that receives the newly created
//                  window handle
//--------------------------------------------------------------------------

STDAPI CreateAdmUiA(DWORD hAdm, HWND hParent, int x, int y, int width, int height, 
                     DWORD dwStyle, DWORD dwExStyle, LPCSTR pcszCategory, HKEY hKeyClass,
                     HWND *phWnd, LPVOID pPartData, LPVOID* pCategoryData, BOOL fRSoPMode)
{
    USES_CONVERSION;

    return createAdmUiHelper(hAdm, hParent, x, y, width, height, dwStyle, dwExStyle, 
        A2CT(pcszCategory), hKeyClass, phWnd, pPartData, pCategoryData, fRSoPMode);
}

STDAPI CreateAdmUiW(DWORD hAdm, HWND hParent, int x, int y, int width, int height, 
                     DWORD dwStyle, DWORD dwExStyle, LPCWSTR pcwszCategory, HKEY hKeyClass,
                     HWND *phWnd, LPVOID pPartData, LPVOID* pCategoryData, BOOL fRSoPMode)
{
    USES_CONVERSION;

    return createAdmUiHelper(hAdm, hParent, x, y, width, height, dwStyle, dwExStyle, 
        W2CT(pcwszCategory), hKeyClass, phWnd, pPartData, pCategoryData, fRSoPMode);
}

//--------------------------------------------------------------------------
//  G E T  A D M  C A T E G O R I E S       Exported Function
//
//  Returns a list of available categories to the caller
//
//  Parameters:
//      hAdm:           adm handle
//      szCategories:   zero separated list of available categories
//      nLength:        size of buffer pointed to by szCategories
//      nBytes:         a pointer to an int that receives the number
//                      of bytes copied into szCategory
//--------------------------------------------------------------------------

STDAPI GetAdmCategoriesA(DWORD hAdm, LPSTR pszCategories, int cchLength, int *nBytes)
{
    LPTSTR lpCategories = (LPTSTR)CoTaskMemAlloc(StrCbFromCch(cchLength));
    HRESULT hr;

    if (lpCategories == NULL)
        hr = E_OUTOFMEMORY;
    else
    {
        hr = getAdmCategoriesHelper(hAdm, lpCategories, cchLength, nBytes);
        T2Abuf(lpCategories, pszCategories, cchLength);
        CoTaskMemFree(lpCategories);
    }
        
    return hr;
}

STDAPI GetAdmCategoriesW(DWORD hAdm, LPWSTR pwszCategories, int cchLength, int *nBytes)
{
    LPTSTR lpCategories = (LPTSTR)CoTaskMemAlloc(StrCbFromCch(cchLength));
    HRESULT hr;

    if (lpCategories == NULL)
        hr = E_OUTOFMEMORY;
    else
    {
        hr = getAdmCategoriesHelper(hAdm, lpCategories, cchLength, nBytes);
        T2Wbuf(lpCategories, pwszCategories, cchLength);
        CoTaskMemFree(lpCategories);
    }
        
    return hr;
}

//--------------------------------------------------------------------------
//  C H E C K D U P L I C A T E K E Y S                  Exported Function
//
//  Checks for duplicate key names
//
//  Parameters:
//      hAdm:           adm handle
//      hCompareAdm:    adm handle of file to be compared
//      szLogFile:      full path name to the log file
//      bClearFile:     TRUE - clear log file; FALSE - do not clear log file
//--------------------------------------------------------------------------

STDAPI CheckDuplicateKeysA(DWORD hAdm, DWORD hCompareAdm, LPCSTR pcszLogFile, BOOL bClearFile)
{
    USES_CONVERSION;

    return checkDuplicateKeysHelper(hAdm, hCompareAdm, A2CT(pcszLogFile), bClearFile);
}

STDAPI CheckDuplicateKeysW(DWORD hAdm, DWORD hCompareAdm, LPCWSTR pcwszLogFile, BOOL bClearFile)
{
    USES_CONVERSION;

    return checkDuplicateKeysHelper(hAdm, hCompareAdm, W2CT(pcwszLogFile), bClearFile);
}

//--------------------------------------------------------------------------
//  A D M  R E S E T                  Exported Function
//
//  Resets the Adm file with the data from the inf file
//  If no inf file is passed resets the adm file data to NULL.
//
//  Parameters:
//      hAdm:       adm handle
//      szInfFile:  full path name to the inf file
//--------------------------------------------------------------------------

STDAPI AdmResetA(DWORD hAdm, LPCSTR pcszInfFile, LPVOID pPartData, LPVOID pCategoryData)
{
    USES_CONVERSION;

    return admResetHelper(hAdm, A2CT(pcszInfFile), pPartData, pCategoryData);
}

STDAPI AdmResetW(DWORD hAdm, LPCWSTR pcwszInfFile, LPVOID pPartData, LPVOID pCategoryData)
{
    USES_CONVERSION;

    return admResetHelper(hAdm, W2CT(pcwszInfFile), pPartData, pCategoryData);
}

//--------------------------------------------------------------------------
//  A D M  C L O S E                  Exported Function
//
//  Releases all memory associated with this adm file
//
//  Parameters:
//      hAdm:       adm handle
//--------------------------------------------------------------------------
STDAPI AdmClose(DWORD hAdm, LPVOID* pPartData, BOOL fClear)
{
    EnterCriticalSection(&g_hAdmCriticalSection);

    FreePartData(pPartData, admFile[hAdm].nParts);
    *pPartData = NULL;
    
    if (fClear == TRUE)
    {
        FreeAdmMemory(&admFile[hAdm]);
        ZeroMemory(&admFile[hAdm], sizeof(ADMUI));
    }

    LeaveCriticalSection(&g_hAdmCriticalSection);

    return S_OK;    
}


BOOL WINAPI IsAdmDirty()
{
    return g_fAdmDirty;    
}

void WINAPI ResetAdmDirtyFlag()
{
    g_fAdmDirty = FALSE;
}

STDAPI AdmSaveData(DWORD hAdm, LPVOID pPartData, LPVOID pCategoryData, DWORD dwFlags)
{
    int i;
    int nControls = 0;
    LPPARTDATA pData = (LPPARTDATA) pPartData;
    LPADMUI pAdmUI = (LPADMUI) pCategoryData;

    if (pAdmUI != NULL && pAdmUI->pControlList != NULL)
    {
        for (i = 0; i < admFile[hAdm].nParts; i++)
        {
            if (StrCmpI(admFile[hAdm].pParts[i].szCategory, pAdmUI->pszCategory) == 0 &&
                admFile[hAdm].pParts[i].hkClass == pAdmUI->hKeyClass)
            {
                if (HasFlag(dwFlags, ADM_SAVE))
                    pAdmUI->pControlList[nControls].Save(&(admFile[hAdm].pParts[i]), &pData[i]);
                if (HasFlag(dwFlags, ADM_DESTROY))
                    pAdmUI->pControlList[nControls].Destroy();
                nControls++;
            }
        }
        if (HasFlag(dwFlags, ADM_DESTROY))
        {
            HeapFree(GetProcessHeap(), 0, pAdmUI->pControlList);
            pAdmUI->pControlList = NULL;
            pAdmUI->nControls = 0;
        }
    }

    return S_OK;
}

STDAPI GetFontInfoA(LPSTR pszFontName, LPINT pnFontSize)
{
    TCHAR szFontName[LF_FACESIZE];

    getFontInfoHelper(szFontName, pnFontSize);
    T2Abuf(szFontName, pszFontName, LF_FACESIZE);

    return S_OK;
}

STDAPI GetFontInfoW(LPWSTR pwszFontName, LPINT pnFontSize)
{
    TCHAR szFontName[LF_FACESIZE];

    getFontInfoHelper(szFontName, pnFontSize);
    T2Wbuf(szFontName, pwszFontName, LF_FACESIZE);

    return S_OK;
}

// ---------------------------------------------------------------------------
// private helper functions

static BOOL allocatePartData(DWORD hAdm, LPVOID* pData)
{
    *pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                       admFile[hAdm].nParts * sizeof(PARTDATA));

    if (*pData != NULL)
    {
        LPPARTDATA pPartData = (LPPARTDATA)*pData;

        for (int nPartIndex = 0; nPartIndex < admFile[hAdm].nParts; nPartIndex++)
        {
            if (admFile[hAdm].pParts[nPartIndex].nType != PART_LISTBOX)
            {
                if (admFile[hAdm].pParts[nPartIndex].szDefaultValue != NULL)
                    pPartData[nPartIndex].value.szValue = StrDup(admFile[hAdm].pParts[nPartIndex].szDefaultValue);
                pPartData[nPartIndex].value.dwValue = admFile[hAdm].pParts[nPartIndex].nDefault;
            }
        }
        return TRUE;
    }

    return FALSE;
}

static HRESULT admInitHelper(LPCTSTR pcszAdmFile, LPCTSTR pcszInfFile,
							 BSTR bstrNamespace, LPDWORD lpdwAdm, LPVOID* pData)
{
    EnterCriticalSection(&g_hAdmCriticalSection);

    // loop thru the existing file list and check whether this file has been parsed
    for (int nIndex = 0; nIndex < g_nAdmInstances; nIndex++)
    {
        if (StrCmpI(admFile[nIndex].szFilename, pcszAdmFile) == 0)
        {
            *lpdwAdm = nIndex;
            allocatePartData(nIndex, pData);

			if (NULL != bstrNamespace && NULL != *pData)
			{
				ReadRegSettingsForADM(&admFile[nIndex], (LPPARTDATA)*pData,
										bstrNamespace);
			}
			else if((pcszInfFile != NULL) && ISNONNULL(pcszInfFile) && *pData != NULL)
                ReadInfFile(&admFile[nIndex], pcszInfFile, (LPPARTDATA)*pData);

            LeaveCriticalSection(&g_hAdmCriticalSection);

            return (*pData == NULL) ? E_FAIL : S_OK;
        }
    }

    int nNewInstance = AdmGetNewInstance();

    if (nNewInstance == -1)
    {
        LeaveCriticalSection(&g_hAdmCriticalSection);
        return E_FAIL;
    }
    
    if( !InitAdmParser(nNewInstance, pcszAdmFile))
    {
        ZeroMemory(&admFile[nNewInstance], sizeof(ADMFILE));
        LeaveCriticalSection(&g_hAdmCriticalSection);
        return E_FAIL;
    }

    // allocate the no. of parts buffer to pData
    allocatePartData(nNewInstance, pData);
    if (*pData == NULL)
    {
        FreeAdmMemory(&(admFile[nNewInstance]));
        ZeroMemory(&admFile[nNewInstance], sizeof(ADMFILE));
        LeaveCriticalSection(&g_hAdmCriticalSection);
        return E_FAIL;
    }

	if (NULL != bstrNamespace)
	{
		ReadRegSettingsForADM(&admFile[nIndex], (LPPARTDATA)*pData, bstrNamespace);
	}
    else if((pcszInfFile != NULL) && ISNONNULL(pcszInfFile))
    {
        ReadInfFile(&admFile[nNewInstance], pcszInfFile, (LPPARTDATA)*pData);
    }

    *lpdwAdm = nNewInstance;

    if (nNewInstance >= g_nAdmInstances)
        g_nAdmInstances = nNewInstance + 1;

    LeaveCriticalSection(&g_hAdmCriticalSection);

    return S_OK;
}

static HRESULT admFinishedHelper(DWORD hAdm, LPCTSTR pcszInfFile, LPVOID pPartData)
{
    EnterCriticalSection(&g_hAdmCriticalSection);

    if(pcszInfFile != NULL && ISNONNULL(pcszInfFile))
        WriteInfFile(&admFile[hAdm], pcszInfFile, (LPPARTDATA)pPartData);

    LeaveCriticalSection(&g_hAdmCriticalSection);

    return S_OK;
}

static HRESULT createAdmUiHelper(DWORD hAdm, HWND hParent, int x, int y, int width, int height, 
                                 DWORD dwStyle, DWORD dwExStyle, LPCTSTR pcszCategory, HKEY hKeyClass,
                                 HWND *phWnd, LPVOID pPartData, LPVOID* pCategoryData, BOOL fRSoPMode)
{
    WNDCLASSA wc;
    HWND      hWnd = NULL;
    ADMCREATE admCreate;

    EnterCriticalSection(&g_hAdmCriticalSection);

    wc.style = 0;
    wc.lpfnWndProc = AdmUiProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hCursor = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = "AdmUiClass";

    if( !FindAtomA( "AdmUiClass" ))
    {
        if( !RegisterClassA( &wc ))
        {
            LeaveCriticalSection(&g_hAdmCriticalSection);
            return E_FAIL;
        }
        AddAtomA( "AdmUiClass" );
    }

    LPADMUI pAdmUI = (LPADMUI)GlobalAlloc(GPTR, sizeof(ADMUI));

    pAdmUI->nAdmWidth   = width;
    pAdmUI->nAdmHeight  = height;
    pAdmUI->hKeyClass   = hKeyClass;
    pAdmUI->pszCategory = StrDup(pcszCategory);
    pAdmUI->hWnd        = hWnd;
    pAdmUI->hAdm        = hAdm;

    admCreate.pAdmUI    = pAdmUI;
    admCreate.pPartData = (LPPARTDATA)pPartData;
	if (fRSoPMode)
		admCreate.fRSoPMode = TRUE;
	else
		admCreate.fRSoPMode = FALSE;

    hWnd = CreateWindowExA( dwExStyle | WS_EX_CONTROLPARENT, "AdmUiClass", "", WS_CHILD | WS_HSCROLL | WS_VSCROLL | WS_GROUP | dwStyle,
        x, y, width, height, hParent,
        NULL, g_hInst, (LPVOID) &admCreate );

    if (hWnd == NULL)
    {
        GlobalFree(pAdmUI);
        LeaveCriticalSection(&g_hAdmCriticalSection);
        return E_FAIL;
    }
    
    *phWnd = hWnd;
    *pCategoryData = pAdmUI;

    LeaveCriticalSection(&g_hAdmCriticalSection);

    return S_OK;
}

static HRESULT getAdmCategoriesHelper(DWORD hAdm, LPTSTR pszCategories, int cchLength, int *nBytes)
{
    EnterCriticalSection(&g_hAdmCriticalSection);

    int nCopyIndex = 0;
    int i;
    HKEY hKeyCurrentClass = HKEY_CURRENT_USER;
    TCHAR szKey[10];

    ZeroMemory(pszCategories, cchLength * sizeof(TCHAR));
    ZeroMemory(szKey, sizeof(szKey));
    
    hKeyCurrentClass = admFile[hAdm].pParts[0].hkClass;
    if(hKeyCurrentClass == HKEY_LOCAL_MACHINE)
        StrCpy(szKey, TEXT("HKLM"));
    else
        StrCpy(szKey, TEXT("HKCU"));
    StrCpy(pszCategories, szKey);
    nCopyIndex = lstrlen(szKey) + 1;
    
    CopyMemory(pszCategories + nCopyIndex, admFile[hAdm].pParts[0].szCategory, lstrlen( admFile[hAdm].pParts[0].szCategory ) * sizeof(TCHAR));
    nCopyIndex += lstrlen( admFile[hAdm].pParts[0].szCategory );
    nCopyIndex++;

    for( i = 0; i < admFile[hAdm].nParts - 1; i++ )
    {
        if( StrCmpI( admFile[hAdm].pParts[i].szCategory, admFile[hAdm].pParts[i+1].szCategory ) != 0 )
        {
            if(admFile[hAdm].pParts[i+1].hkClass != hKeyCurrentClass)
            {
                hKeyCurrentClass = admFile[hAdm].pParts[i+1].hkClass;
                if(hKeyCurrentClass == HKEY_LOCAL_MACHINE)
                    StrCpy(szKey, TEXT("HKLM"));
                else
                    StrCpy(szKey, TEXT("HKCU"));
                
                CopyMemory(pszCategories + nCopyIndex, szKey, lstrlen( szKey ) * sizeof(TCHAR));
                nCopyIndex += lstrlen(szKey);

                // skip over one byte so our list is 0 separated
                nCopyIndex++;
            }

            CopyMemory(pszCategories + nCopyIndex, admFile[hAdm].pParts[i+1].szCategory, lstrlen( admFile[hAdm].pParts[i+1].szCategory ) * sizeof(TCHAR));
            nCopyIndex += lstrlen( admFile[hAdm].pParts[i+1].szCategory );

            // skip over one byte so our list is 0 separated
            nCopyIndex++;

            // make sure we still have enough room in the buffer
            if( nCopyIndex > cchLength )
            {
                LeaveCriticalSection(&g_hAdmCriticalSection);
                return E_FAIL;
            }
        }
    }

    *nBytes = nCopyIndex;

    LeaveCriticalSection(&g_hAdmCriticalSection);

    return S_OK;
}

static HRESULT checkDuplicateKeysHelper(DWORD hAdm, DWORD hCompareAdm, LPCTSTR pcszLogFile, BOOL bClearFile)
{
    HANDLE hFile = NULL;
    DWORD dwCreationDisposition = CREATE_ALWAYS;
    DWORD dwNumberOfBytesWritten = 0;
    TCHAR szBuffer[1024];
    int nCheckIndex = 0;
    int nIndex = 0;
    DWORD admHandle = 0;
    LPTSTR pData = NULL;
    int nData = 0;
    int nSize = 1024;
    LPVOID lpTemp = NULL;
    BOOL bContinue = TRUE;
    
    pData = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, StrCbFromCch(nSize));
    if(pData == NULL)
    {
        SetLastError(STATUS_NO_MEMORY);
        return E_FAIL;
    }

    if(bClearFile == FALSE)
        dwCreationDisposition = OPEN_ALWAYS;
    
    hFile = CreateFile(pcszLogFile, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
        NULL, dwCreationDisposition, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        SetLastError( ERROR_FILE_NOT_FOUND );
        return E_FAIL;
    }

    if(bClearFile == FALSE)
        SetFilePointer(hFile, 0, NULL, FILE_END);

    LoadString(g_hInst, IDS_DUPKEY_FORMAT, szBuffer, countof(szBuffer));
    
    admHandle = hCompareAdm;
    nCheckIndex = 0;
    while( nCheckIndex < admFile[hAdm].nParts && bContinue)
    {
        if(admFile[hAdm].pParts[nCheckIndex].nType == PART_TEXT ||
           (admFile[hAdm].pParts[nCheckIndex].nType == PART_POLICY  &&
           !admFile[hAdm].pParts[nCheckIndex].fRequired) ||
           admFile[hAdm].pParts[nCheckIndex].nType == PART_ERROR ||
           admFile[hAdm].pParts[nCheckIndex].value.szValueName == NULL)
        {
            nCheckIndex++;
            continue;
        }
        
        if(hAdm == admHandle)
            nIndex = nCheckIndex + 1;
        else
            nIndex = 0;

        for(; nIndex < admFile[admHandle].nParts && bContinue; nIndex++ )
        {
            if(admFile[admHandle].pParts[nIndex].nType == PART_POLICY  && !admFile[admHandle].pParts[nCheckIndex].fRequired)
                continue;
            if(admFile[admHandle].pParts[nIndex].nType != PART_TEXT &&
                admFile[admHandle].pParts[nIndex].nType != PART_ERROR &&
                admFile[hAdm].pParts[nCheckIndex].hkClass == admFile[admHandle].pParts[nIndex].hkClass &&
                admFile[admHandle].pParts[nIndex].value.szValueName != NULL &&
                !StrCmpI(admFile[hAdm].pParts[nCheckIndex].value.szValueName, admFile[admHandle].pParts[nIndex].value.szValueName) &&
                !StrCmpI(admFile[hAdm].pParts[nCheckIndex].value.szKeyname, admFile[admHandle].pParts[nIndex].value.szKeyname))
            {
                LPTSTR pStr = NULL;

                USES_CONVERSION;
                pStr = FormatString(szBuffer,
                        BaseFileName(admFile[hAdm].szFilename), admFile[hAdm].pParts[nCheckIndex].nLine,admFile[hAdm].pParts[nCheckIndex].szName,
                        BaseFileName(admFile[admHandle].szFilename), admFile[admHandle].pParts[nIndex].nLine, admFile[admHandle].pParts[nIndex].szName);
                if((nData + lstrlen(pStr) + 1) > (nSize - 1))
                {
                    nSize += 1024;
                    lpTemp = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pData, StrCbFromCch(nSize));
                    if(lpTemp == NULL)
                        bContinue = FALSE;
                    else
                        pData = (LPTSTR) lpTemp;
                }   
                StrCat(pData, pStr);
                nData += lstrlen(pStr);
                LocalFree(pStr);
            }
        }
        nCheckIndex++;
    }

    if(ISNONNULL(pData))
    {
        LPSTR pszData;

        pszData = (LPSTR)CoTaskMemAlloc(StrCbFromCch(nData));
        T2Abuf(pData, pszData, nData);
        WriteFile(hFile, pszData, nData, &dwNumberOfBytesWritten, NULL);
        CoTaskMemFree(pszData);
    }
    CloseHandle(hFile);
    HeapFree(GetProcessHeap(), 0, pData);
    return S_OK;
}

static HRESULT admResetHelper(DWORD hAdm, LPCTSTR pcszInfFile, LPVOID pPartData, LPVOID pCategoryData)
{
    EnterCriticalSection(&g_hAdmCriticalSection);

    LPPARTDATA pData = (LPPARTDATA) pPartData;
    LPADMUI pAdmUI = (LPADMUI) pCategoryData;

    for(int nPartIndex = 0; nPartIndex < admFile[hAdm].nParts; nPartIndex++)
    {
        if(pData[nPartIndex].value.szValue != NULL)
        {
            LocalFree(pData[nPartIndex].value.szValue);
            pData[nPartIndex].value.szValue = NULL;
        }
        
        if (admFile[hAdm].pParts[nPartIndex].szDefaultValue != NULL)
            pData[nPartIndex].value.szValue = StrDup(admFile[hAdm].pParts[nPartIndex].szDefaultValue);
        pData[nPartIndex].value.dwValue = admFile[hAdm].pParts[nPartIndex].nDefault;
        pData[nPartIndex].value.fNumeric = 0;
        pData[nPartIndex].fSave = 0;

        if (pData[nPartIndex].nActions != 0)
        {
            FreeActionList(pData[nPartIndex].actionlist, pData[nPartIndex].nActions);
            if (pData[nPartIndex].actionlist != NULL)
            {
                HeapFree(GetProcessHeap(), 0, pData[nPartIndex].actionlist);
                pData[nPartIndex].actionlist = NULL;
            }

            pData[nPartIndex].nActions = 0;
        }
    }

    if(pcszInfFile != NULL && ISNONNULL(pcszInfFile))
        ReadInfFile(&admFile[hAdm], pcszInfFile, pData);

    if(pAdmUI != NULL && pAdmUI->pControlList != NULL)
    {
        for(int nControlIndex = 0; nControlIndex < pAdmUI->nControls; nControlIndex++)
        {
            int nPartIndex = pAdmUI->pControlList[nControlIndex].GetPart();
            pAdmUI->pControlList[nControlIndex].Reset(&(admFile[hAdm].pParts[nPartIndex]),
                                                      &pData[nPartIndex]);
        }
    }

    LeaveCriticalSection(&g_hAdmCriticalSection);

    return S_OK;
}

static void getFontInfoHelper(LPTSTR pszFontName, LPINT pnFontSize)
{
    TCHAR szFontSize[8];
    
    if (!LoadString(g_hInst, IDS_ADMBOLDFONT, pszFontName, LF_FACESIZE))
        StrCpy(pszFontName, TEXT("MS Sans Serif"));
    LoadString(g_hInst, IDS_ADMBOLDFONTSIZE, szFontSize, ARRAYSIZE(szFontSize));
    *pnFontSize = StrToInt(szFontSize);
    if (*pnFontSize < 8)
        *pnFontSize = 8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\parser\controls.h ===
//--------------------------------------------------------------------------
//
//  controls.h
//
//--------------------------------------------------------------------------

#include "..\ieakutil\ieakutil.h"

#define CSW_BORDER          0x00000000
#define CSW_FRAME           0x00000001
#define CSW_LABEL           0x00000002
#define CSW_BOLDLABEL       (CSW_LABEL | 0x00000010)
#define CSW_ITALICLABEL     (CSW_LABEL | 0x00000020)

#define HasOnlyFlag(dwFlags, dwMask)    (((DWORD)(dwFlags) ^ (DWORD)(dwMask)) == 0L)

#define SCROLL_PAGE     50
#define SCROLL_LINE     5

class CStaticWindow
{
private:
    BOOL fCreated;
    int nControlX, nControlY, nControlWidth, nControlHeight;
    HWND hWnd;
    DWORD dwType;

public:
    CStaticWindow( );
    ~CStaticWindow( );
    void Create( HWND hwndParent, int x, int y, int nWidth, int nHeight, DWORD dwFlags );
    void MoveWindow( int x, int y, int nWidth, int nHeight );
    void Destroy( );
    int SetText( LPTSTR szText);
    void MoveUp( int nValue );
    void MoveLeft( int nValue );
    HWND Hwnd();
    HFONT GetFont();
};

class CAdmControl
{
private:
    HWND hControl;
    HWND hUpDown;
    CStaticWindow label;
    int nControlX, nControlY, nControlWidth, nControlHeight;
    BOOL fCreated;
    int nPart;

public:
    CAdmControl( );
    ~CAdmControl( );
    int Create( HWND hwndParent, int x, int y, int nWidth, int nHeight, int nTextWidth,
                LPPART part, LPPARTDATA pPartData, BOOL fRSoPMode);
    void Destroy( );
    void Save( LPPART part, LPPARTDATA pPartData );
    void MoveUp( int nValue );
    void MoveLeft( int nValue );
    void Reset(LPPART part, LPPARTDATA pPartData);
    int GetPart();
    void SetPart(int nPartNo);
};

typedef struct ControlInfo
{
    WNDPROC lpOrgControlProc;
    LPPART lpPart;
    LPPARTDATA lpPartData;
} CONTROLINFO, *LPCONTROLINFO;

typedef struct ValueInfo
{
    TCHAR* pValueName;
    TCHAR* pValue;
} VALUEINFO, *LPVALUEINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\parser\parse.h ===
//------------------------------------------------------------------------
//  parse.h
//------------------------------------------------------------------------

#include "admparse.h"

#ifndef ARRAYSIZE                               // one definition is fine
#define ARRAYSIZE(a)     (sizeof(a)/sizeof((a)[0]))
#endif

#define KEY_ERROR           0x0FFFFFFFF
#define KEY_CLASS           0
#define KEY_CATEGORY        1
#define KEY_KEYNAME         2
#define KEY_POLICY          3
#define KEY_VALUENAME       4
#define KEY_ACTIONLISTON    5
#define KEY_ACTIONLISTOFF   6
#define KEY_PART            7
#define KEY_END             8
#define KEY_ITEMLIST        9
#define KEY_NAME            10
#define KEY_MAXLEN          11
#define KEY_DEFAULT         12
#define KEY_ACTIONLIST      13
#define KEY_SUGGESTIONS     14
#define KEY_MIN             15
#define KEY_MAX             16
#define KEY_VALUEON         17
#define KEY_VALUEOFF        18
#define KEY_VALUE           19
#define KEY_DEFCHECKED      20
#define KEY_SPIN            21
#define KEY_IF              22
#define KEY_ENDIF           23
#define KEY_VERSION         24
#define KEY_LT              25
#define KEY_LTE             26
#define KEY_GT              27
#define KEY_GTE             28

#define PART_ERROR          0x0FFFFFFFF
#define PART_EDITTEXT       0
#define PART_DROPDOWNLIST   1
#define PART_NUMERIC        2
#define PART_CHECKBOX       3
#define PART_LISTBOX        4
#define PART_TEXT           5
#define PART_COMBOBOX       6
#define PART_POLICY         7

#define CLASS_MACHINE       0
#define CLASS_USER          1

#define NO_ACTION           0xFFFFFFFF

#define ADM_VERSION         2

//------------------------------------------------------------------------
// Structures
//------------------------------------------------------------------------

typedef struct _value
{
    LPTSTR  szKeyname;
    LPTSTR  szValueName;
    LPTSTR  szValue;
    DWORD   dwValue;
    BOOL    fNumeric;
    LPTSTR  szValueOn;
    LPTSTR  szValueOff;
    int     nValueOn;
    int     nValueOff;
} VALUE, *LPVALUE;

typedef struct _actionlist
{
    LPTSTR  szName;
    LPTSTR  szValue;
    DWORD   dwValue;
    int     nValues;
    LPVALUE value;
} ACTIONLIST, *LPACTIONLIST;

typedef struct _suggestions
{
    LPTSTR  szText;
} SUGGESTIONS, *LPSUGGESTIONS;

typedef struct _part
{
    LPTSTR  szName;
    LPTSTR  szCategory;
    VALUE   value;
    int     nType;
    HKEY    hkClass;
    int     nActions;
    int     nSelectedAction;
    LPACTIONLIST actionlist;
    int     nSuggestions;
    LPSUGGESTIONS suggestions;
    int     nMin, nMax, nDefault, nSpin;
    BOOL    fRequired;
    int     nLine;
    LPTSTR  szDefaultValue;
    //BOOL    fSave;
} PART, *LPPART;

typedef struct _partData
{
    VALUE   value;
    LPACTIONLIST actionlist;
    int     nActions;
    int     nSelectedAction;
    BOOL    fNumeric;
    BOOL    fSave;
} PARTDATA, *LPPARTDATA;

typedef struct _admfile
{
    TCHAR   szFilename[MAX_PATH];
    LPPART  pParts;
    int     nParts;
} ADMFILE, *LPADMFILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\parser\admparse.cpp ===
#include <w95wraps.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "shlwapi.h"
#include "parse.h"
#include "..\ieakutil\ieakutil.h"

#define NCATEGORY        0
#define NPOLICY          1
#define NPART            2
#define NACTIONLIST      3

TCHAR *pKeyNames[29] = { TEXT("CLASS"), TEXT("CATEGORY"), TEXT("KEYNAME"), TEXT("POLICY"), TEXT("VALUENAME"),
    TEXT("ACTIONLISTON"), TEXT("ACTIONLISTOFF"), TEXT("PART"), TEXT("END"), TEXT("ITEMLIST"), TEXT("NAME"),
    TEXT("MAXLEN"), TEXT("DEFAULT"), TEXT("ACTIONLIST"), TEXT("SUGGESTIONS"), TEXT("MIN"), TEXT("MAX"), TEXT("VALUEON"),
    TEXT("VALUEOFF"), TEXT("VALUE"), TEXT("DEFCHECKED"), TEXT("SPIN"), TEXT("#if"), TEXT("#endif"), TEXT("VERSION"),
    TEXT("<"), TEXT("<="), TEXT(">"), TEXT(">=") };

TCHAR *pPartTypes[8] = { TEXT("EDITTEXT"), TEXT("DROPDOWNLIST"), TEXT("NUMERIC"), TEXT("CHECKBOX"),
    TEXT("LISTBOX"), TEXT("TEXT"), TEXT("COMBOBOX"), TEXT("POLICY") };

BOOL ReadAdmFile(LPADMFILE, LPCTSTR);
void FreeAdmMemory(LPADMFILE);
int g_nLine = 1;

#define MAX_NUMERIC     32767
#define MAX_EDITTEXTLEN 512
#define ALLOCATE        100
#define REALLOCATE      101

//-------------------------------------------------------------------------
//  F I L E  E X I S T S
//
//  Checks to see if a file exists and returns true if it does
//-------------------------------------------------------------------------
BOOL FileExists( LPCTSTR pcszFile )
{
    return (GetFileAttributes( pcszFile ) != -1 );
}

void FreeActionList(LPACTIONLIST pActionList, int nActions)
{
    if (pActionList == NULL)
        return;
    
    for(int nActionListIndex = 0; nActionListIndex < nActions; nActionListIndex++)
    {
        if(pActionList[nActionListIndex].szName != NULL)
            LocalFree(pActionList[nActionListIndex].szName);

        if(pActionList[nActionListIndex].szValue != NULL)
            LocalFree(pActionList[nActionListIndex].szValue);
    
        for(int nValueIndex = 0; nValueIndex < pActionList[nActionListIndex].nValues; nValueIndex++)
        {
            if(pActionList[nActionListIndex].value[nValueIndex].szKeyname != NULL)
                LocalFree(pActionList[nActionListIndex].value[nValueIndex].szKeyname);
            if(pActionList[nActionListIndex].value[nValueIndex].szValueName != NULL)
                LocalFree(pActionList[nActionListIndex].value[nValueIndex].szValueName);
            if(pActionList[nActionListIndex].value[nValueIndex].szValue != NULL)
                LocalFree(pActionList[nActionListIndex].value[nValueIndex].szValue);
            if(pActionList[nActionListIndex].value[nValueIndex].szValueOn != NULL)
                LocalFree(pActionList[nActionListIndex].value[nValueIndex].szValueOn);
            if(pActionList[nActionListIndex].value[nValueIndex].szValueOff != NULL)
                LocalFree(pActionList[nActionListIndex].value[nValueIndex].szValueOff);
        }

        if (pActionList[nActionListIndex].value != NULL)
            HeapFree(GetProcessHeap(), 0, pActionList[nActionListIndex].value);
    }
}

//--------------------------------------------------------------------------
//  F R E E  A D M  M E M O R Y     Exported Function
//
//  Releases memory allocated by ReadAdmFile
//--------------------------------------------------------------------------
void FreeAdmMemory( LPADMFILE pAdmFile )
{
    if (pAdmFile == NULL)
        return;

    for(int nPartIndex = 0; nPartIndex < pAdmFile->nParts; nPartIndex++ )
    {
        if(pAdmFile->pParts[nPartIndex].szName != NULL)
            LocalFree(pAdmFile->pParts[nPartIndex].szName);
        if(pAdmFile->pParts[nPartIndex].szCategory != NULL)
            LocalFree(pAdmFile->pParts[nPartIndex].szCategory);
        if(pAdmFile->pParts[nPartIndex].szDefaultValue != NULL)
            LocalFree(pAdmFile->pParts[nPartIndex].szDefaultValue);

        if(pAdmFile->pParts[nPartIndex].value.szKeyname != NULL)
            LocalFree(pAdmFile->pParts[nPartIndex].value.szKeyname);
        if(pAdmFile->pParts[nPartIndex].value.szValueName != NULL)
            LocalFree(pAdmFile->pParts[nPartIndex].value.szValueName);
        if(pAdmFile->pParts[nPartIndex].value.szValue != NULL)
            LocalFree(pAdmFile->pParts[nPartIndex].value.szValue);
        if(pAdmFile->pParts[nPartIndex].value.szValueOn != NULL)
            LocalFree(pAdmFile->pParts[nPartIndex].value.szValueOn);
        if(pAdmFile->pParts[nPartIndex].value.szValueOff != NULL)
            LocalFree(pAdmFile->pParts[nPartIndex].value.szValueOff);

        FreeActionList(pAdmFile->pParts[nPartIndex].actionlist, pAdmFile->pParts[nPartIndex].nActions);
        if (pAdmFile->pParts[nPartIndex].actionlist != NULL)
            HeapFree(GetProcessHeap(), 0, pAdmFile->pParts[nPartIndex].actionlist);

        for(int nSuggestionIndex = 0; nSuggestionIndex < pAdmFile->pParts[nPartIndex].nSuggestions; nSuggestionIndex++)
        {
            if(pAdmFile->pParts[nPartIndex].suggestions[nSuggestionIndex].szText != NULL)
                LocalFree(pAdmFile->pParts[nPartIndex].suggestions[nSuggestionIndex].szText);
        }
        if (pAdmFile->pParts[nPartIndex].suggestions != NULL)
            HeapFree(GetProcessHeap(), 0, pAdmFile->pParts[nPartIndex].suggestions);
    }
    
    if(pAdmFile->pParts != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pAdmFile->pParts);
        pAdmFile->pParts = NULL;
    }

    pAdmFile->nParts = 0;
    *pAdmFile->szFilename = TEXT('\0');
}

void FreePartData( LPVOID* pPartData, int nParts )
{
    LPPARTDATA pData = NULL;

    if (pData == NULL)
        return;

    pData = (LPPARTDATA)*pPartData;

    for(int nPartIndex = 0; nPartIndex < nParts; nPartIndex++ )
    {
        if(pData != NULL && pData[nPartIndex].value.szValue != NULL)
            LocalFree(pData[nPartIndex].value.szValue);

        FreeActionList(pData[nPartIndex].actionlist, pData[nPartIndex].nActions);
        if (pData[nPartIndex].actionlist != NULL)
            HeapFree(GetProcessHeap(), 0, pData[nPartIndex].actionlist);
    }
    
    HeapFree(GetProcessHeap(), 0, pData);
    pData = NULL;
}

//--------------------------------------------------------------------------
//  R E A D  K E Y  W O R D
//
//  Reads the next word in the string pData and copyies it into szKeyWord
//  Returns a pointer to the next character after the word
//--------------------------------------------------------------------------
TCHAR *ReadKeyword( TCHAR *pData, TCHAR *szKeyWord, int cchLength )
{
    int i;
    int nIndex;

    memset( szKeyWord, 0, cchLength*sizeof(TCHAR) );

    // remove whitespace
    i = StrSpn( pData, TEXT(" \n\t\x0d\x0a") );
    if(i)
    {
        for(nIndex = 0; nIndex < i; nIndex++)
        {
            if(*(pData + nIndex) == TEXT('\x0a'))
                g_nLine++;
        }
    }
    pData += i;

    i = StrCSpn( pData, TEXT(" \n\t\x0d\x0a") );

    if( i > cchLength )       // make sure we dont overrun our buffer
        i = cchLength - 1;

    StrCpyN( szKeyWord, pData, i+1 );

    pData += i;
    return pData;
}

//--------------------------------------------------------------------------
//  G E T  E O F
//
//  Returns the number of bytes in pFile
//--------------------------------------------------------------------------
//int GetEof( FILE *pFile )
//{
//    int i = 0;
//    char cByte;
//
//    while( !feof( pFile ))
//    {
//        fread( &cByte, 1, 1, pFile );
//        i++;
//    }
//    rewind( pFile );
//    return i;
//}

//--------------------------------------------------------------------------
//  G E T  K E Y  N A M E
//
//  Compares szKeyName to an array of available keynames and returns an
//  index into that array
//--------------------------------------------------------------------------
int GetKeyName( TCHAR *szKeyName )
{
    int i;
    for( i = 0; i < ARRAYSIZE( pKeyNames ); i++ )
    {
        if( StrCmpI( szKeyName, pKeyNames[i] ) == 0 )
            return i;
    }
    return KEY_ERROR;
}

//--------------------------------------------------------------------------
//  G E T  P A R T  N A M E
//
//  compares szParyType to an array of available part types and return an
//  index into that array
//--------------------------------------------------------------------------
int GetPartName( TCHAR *szPartType )
{
    int i;
    for( i = 0; i < ARRAYSIZE( pPartTypes ); i++ )
    {
        if( StrCmp( szPartType, pPartTypes[i] ) == 0 )
            return i;
    }
    return PART_ERROR;
}

//--------------------------------------------------------------------------
//  C H E C K  S T R I N G S
//
//  Checks to see if szString is localizable and replaces it if it is
//--------------------------------------------------------------------------
void CheckStrings( TCHAR *szString, LPCTSTR pcszFileName )
{
    TCHAR szTemp[1024];

    if( StrCmpN( szString, TEXT("!!"), 2 ) == 0 )
    {
        szString += 2; //incrememt pointer

        GetPrivateProfileString( TEXT("strings"), szString, TEXT(""), szTemp,
            ARRAYSIZE( szTemp ), pcszFileName );

        szString -= 2; //decrement pointer

        if( *szTemp )
        {
            StrCpy( szString, szTemp );
        }
    }
}

//--------------------------------------------------------------------------
//  G E T  Q U O T E D  T E X T
//
//  Checks to see if the current word is quoted and copies the entire
//  series of quoted words into szKeyWord
//--------------------------------------------------------------------------
TCHAR *GetQuotedText( TCHAR *pData, TCHAR *szKeyWord, int nLength )
{
    int i;

    pData -= lstrlen( szKeyWord );

    // if we are not quoted, return the current pointer
    if( pData[0] != TEXT('\"') )
    {
        pData += lstrlen( szKeyWord );
        return pData;
    }

    // skip over first quote
    pData++;

    // search for another quote or a newline character
    i = StrCSpn( pData, TEXT("\"\n") );
    memset( szKeyWord, 0, nLength );
    StrCpyN( szKeyWord, pData, i+1 );
    pData += i;
    return ++pData;
}

//--------------------------------------------------------------------------
//  R E A D  V A L U E
//
//  
//--------------------------------------------------------------------------
TCHAR *ReadValue( TCHAR *pCurrent, LPVALUE value, int nValue, LPCTSTR pcszFileName )
{
    TCHAR szKeyWord[1024];

    pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
    if( StrCmp( szKeyWord, TEXT("VALUE") ) == 0 )
    {
        pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
        if(value[nValue].szValue != NULL)
            LocalFree(value[nValue].szValue);
        value[nValue].szValue = NULL;
        if( StrCmp( szKeyWord, TEXT("NUMERIC") ) == 0 )
        {
            pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
            value[nValue].dwValue = StrToInt( szKeyWord );
            value[nValue].fNumeric = TRUE;
        }
        else
        {
            if( StrCmp( szKeyWord, TEXT("TEXT") ) == 0 )
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));

            if (pCurrent && (*pCurrent != TEXT('\0')))
                pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
            CheckStrings( szKeyWord, pcszFileName );
            value[nValue].szValue = StrDup(szKeyWord);
        }
    }

    return pCurrent;
}

BOOL AllocateActions(LPACTIONLIST* actionlist, int nAllocate, int nAllocType)
{
    LPVOID lpTemp = NULL;
    
    if(nAllocType == ALLOCATE)
    {
        *actionlist = (LPACTIONLIST) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ACTIONLIST) * nAllocate);
        if(*actionlist == NULL)
            return FALSE;
    }
    else
    {
        lpTemp = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *actionlist, sizeof(ACTIONLIST) * nAllocate);
        if(lpTemp == NULL)
            return FALSE;
        *actionlist = (LPACTIONLIST) lpTemp;
    }
    return TRUE;
}

BOOL AllocateValues(LPVALUE* values, int nAllocate, int nAllocType)
{
    LPVOID lpTemp = NULL;

    if(nAllocType == ALLOCATE)
    {
        *values = (LPVALUE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(VALUE) * nAllocate);
        if(*values == NULL)
            return FALSE;
    }
    else
    {
        lpTemp = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *values, sizeof(VALUE) * nAllocate);
        if(lpTemp == NULL)
            return FALSE;
        *values = (LPVALUE) lpTemp;
    }
    return TRUE;
}

BOOL AllocateSuggestions(LPSUGGESTIONS* suggestions, int nAllocate, int nAllocType)
{
    LPVOID lpTemp = NULL;

    if(nAllocType == ALLOCATE)
    {
        *suggestions = (LPSUGGESTIONS) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SUGGESTIONS) * nAllocate);
        if(*suggestions == NULL)
            return FALSE;
    }
    else
    {
        lpTemp = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *suggestions, sizeof(SUGGESTIONS) * nAllocate);
        if(lpTemp == NULL)
            return FALSE;
        *suggestions = (LPSUGGESTIONS) lpTemp;
    }
    return TRUE;
}

//--------------------------------------------------------------------------
//  R E A D  A D M  F I L E         Exported Function
//
//  Parses a global policy template into an array of PARTs.
//--------------------------------------------------------------------------
BOOL ReadAdmFile( LPADMFILE admfile, LPCTSTR pcszFileName)
{
    HANDLE hFile;
    TCHAR *pData;
    TCHAR *pCurrent;
    TCHAR szKeyWord[1024];
    int nFileSize;
    int nParts = 0;
    int nValues = 0;
    int nSuggestions = 0;
    LPPART part = NULL;
    LPVALUE value = NULL;
    LPSUGGESTIONS suggestions = NULL;
    HGLOBAL hFileMem;
    int nPartsAlloc = 100;
    int nValuesAlloc = 0;
    int nSuggestionsAlloc = 0;

    HKEY hkCurrentClass = HKEY_CURRENT_USER;
    TCHAR szCurrentCategory[1024];
    BOOL fInPart = FALSE, fInPolicy = FALSE, fInCategory = FALSE;
    BOOL fInActionList = FALSE;
    TCHAR szRegKey[4][1024];
    TCHAR szValueName[1024];
    BOOL bContinue = TRUE;

    int nActionsAlloc = 0;
    int nActions = 0;
    LPACTIONLIST actionlist = NULL;
    LPVOID lpTemp = NULL;
    int nPolicyPart = -1;
    int nKeyValue = 0;
    TCHAR szValueOn[1024];
    TCHAR szValueOff[1024];
    int nValueOn = 1;
    int nValueOff = 0;
    BOOL fInItemList = FALSE;
    int nActionListType = -1;
    BOOL fSkip = FALSE;

    if( !FileExists( pcszFileName ))
    {
        SetLastError( ERROR_FILE_NOT_FOUND );
        return FALSE;
    }

    // allocate memory
    part = (LPPART) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PART) * nPartsAlloc);

    // set up pointers and structures
    admfile->pParts = part;
    admfile->nParts = 0;

    if(part == NULL)
    {
        FreeAdmMemory( admfile );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    memset( szRegKey, 0, sizeof( szRegKey ));

    hFile = CreateFile( pcszFileName, GENERIC_READ, FILE_SHARE_READ,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        FreeAdmMemory( admfile );
        return FALSE;
    }

    nFileSize = GetFileSize( hFile, NULL );

    hFileMem = LocalAlloc( LPTR, (nFileSize + 1)*sizeof(TCHAR));

    if( hFileMem == NULL )
    {
        CloseHandle( hFile );
        FreeAdmMemory( admfile );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    pData = (LPTSTR) hFileMem;

    // read all of the data available

    ReadStringFromFile( hFile, pData, (DWORD) nFileSize);
    CloseHandle( hFile );

    // set the current pointer to the beginning of the data
    pCurrent = pData;
    g_nLine = 1;

    // main loop
    do
    {
        pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
        if( pCurrent >= pData + nFileSize )
            break;
        
        nKeyValue = GetKeyName(szKeyWord);

        if (nKeyValue != KEY_ENDIF && fSkip == TRUE)
            continue;
        
        switch((nKeyValue))
        {
        case KEY_CLASS:
            pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
            if( StrCmp( szKeyWord, TEXT("MACHINE") ) == 0 )
                hkCurrentClass = HKEY_LOCAL_MACHINE;
            if( StrCmp( szKeyWord, TEXT("USER") ) == 0 )
                hkCurrentClass = HKEY_CURRENT_USER;
            break;

        case KEY_CATEGORY:
            fInCategory = TRUE;
            pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
            pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
            CheckStrings( szKeyWord, pcszFileName );
            StrCpy( szCurrentCategory, szKeyWord );
            // patch for displaying the icon
            part[nParts].hkClass = hkCurrentClass;
            if(part[nParts].szCategory != NULL)
                LocalFree(part[nParts].szCategory);
            part[nParts].szCategory = NULL;
            part[nParts].szCategory = StrDup(szCurrentCategory);
            part[nParts].nType = PART_ERROR;
            break;

        case KEY_END:
            pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
            switch( GetKeyName( szKeyWord ))
            {
            case KEY_PART:
                if(fInPart)
                {
                    if(part[nParts].nType != PART_TEXT && part[nParts].nType != PART_ERROR)
                    {
                        if(part[nParts].value.szKeyname != NULL)
                            LocalFree(part[nParts].value.szKeyname);
                        part[nParts].value.szKeyname = NULL;
                        if( ISNONNULL( szRegKey[NPART] ))
                        {
                            part[nParts].value.szKeyname = StrDup(szRegKey[NPART]);
                            memset( szRegKey[NPART], 0, sizeof( szRegKey[NPART] ));
                        }
                        else if( ISNONNULL( szRegKey[NPOLICY] ))
                            part[nParts].value.szKeyname = StrDup(szRegKey[NPOLICY]);

                        else if( ISNONNULL( szRegKey[NCATEGORY] ))
                            part[nParts].value.szKeyname = StrDup(szRegKey[NCATEGORY]);

                        if(part[nParts].value.szValueName != NULL)
                            LocalFree(part[nParts].value.szValueName);
                        part[nParts].value.szValueName = NULL;
                        part[nParts].value.szValueName = StrDup(szValueName);

                        // using szDefaultValue variable as the storage for holding the policy key for
                        // part as a listbox only
                        if((lstrlen(szRegKey[NPOLICY]) || lstrlen(szRegKey[NCATEGORY])) && part[nParts].nType == PART_LISTBOX)
                        {
                            if(part[nParts].szDefaultValue != NULL)
                                LocalFree(part[nParts].szDefaultValue);
                            part[nParts].szDefaultValue = NULL;
                            if(ISNONNULL(szRegKey[NPOLICY]))
                                part[nParts].szDefaultValue = StrDup(szRegKey[NPOLICY]);
                            else
                                part[nParts].szDefaultValue = StrDup(szRegKey[NCATEGORY]);
                        }
                    }

                    if(nActions)
                    {
                        if(!AllocateActions(&actionlist, nActions, REALLOCATE))
                            bContinue = FALSE;
                        else
                            part[nParts].actionlist = &actionlist[0];
                    }
                    if(nSuggestions)
                    {
                        if(!AllocateSuggestions(&suggestions, nSuggestions, REALLOCATE))
                            bContinue = FALSE;
                        else
                            part[nParts].suggestions = &suggestions[0];
                    }
                
                    nParts++;
                    if(nParts >= nPartsAlloc)
                    {
                        nPartsAlloc += 50;
                        lpTemp = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, part, sizeof(PART) * nPartsAlloc);
                        if(lpTemp == NULL)
                            bContinue = FALSE;
                        else
                            part = (LPPART) lpTemp;
                    }
                    memset(szRegKey[NACTIONLIST], 0, sizeof( szRegKey[NACTIONLIST]));
                    fInPart = FALSE;
                }
                break;

            case KEY_POLICY:
                if(fInPolicy)
                {
                    if(part[nPolicyPart].fRequired == TRUE)
                    {
                        if(part[nPolicyPart].value.szKeyname != NULL)
                            LocalFree(part[nPolicyPart].value.szKeyname);
                        part[nPolicyPart].value.szKeyname = NULL;

                        if( ISNONNULL( szRegKey[NPOLICY] ))
                            part[nPolicyPart].value.szKeyname = StrDup(szRegKey[NPOLICY]);
                        else if( ISNONNULL( szRegKey[NCATEGORY] ))
                            part[nPolicyPart].value.szKeyname = StrDup(szRegKey[NCATEGORY]);

                        if(part[nPolicyPart].value.szValueName != NULL)
                            LocalFree(part[nPolicyPart].value.szValueName);
                        part[nPolicyPart].value.szValueName = NULL;
                        part[nPolicyPart].value.szValueName = StrDup(szValueName);

                        part[nPolicyPart].value.nValueOn = nValueOn;
                        part[nPolicyPart].value.nValueOff = nValueOff;
                        if(*szValueOn != TEXT('\0'))
                        {
                            if(part[nPolicyPart].value.szValueOn != NULL)
                                LocalFree(part[nPolicyPart].value.szValueOn);
                            part[nPolicyPart].value.szValueOn = NULL;
                            part[nPolicyPart].value.szValueOn = StrDup(szValueOn);
                        }
                        if(*szValueOff != TEXT('\0'))
                        {
                            if(part[nPolicyPart].value.szValueOff != NULL)
                                LocalFree(part[nPolicyPart].value.szValueOff);
                            part[nPolicyPart].value.szValueOff = NULL;
                            part[nPolicyPart].value.szValueOff = StrDup(szValueOff);
                        }
                    }

                    memset(szRegKey[NACTIONLIST], 0, sizeof(szRegKey[NACTIONLIST]));
                    memset( szRegKey[NPART], 0, sizeof( szRegKey[NPART] ));
                    memset( szRegKey[NPOLICY], 0, sizeof( szRegKey[NPOLICY] ));
                    nPolicyPart = -1;
                    fInPolicy = FALSE;
                }
                break;

            case KEY_CATEGORY:
                if(fInCategory)
                {
                    memset(szRegKey[NACTIONLIST], 0, sizeof(szRegKey[NACTIONLIST]));
                    memset( szRegKey[NPART], 0, sizeof( szRegKey[NPART] ));
                    memset( szRegKey[NPOLICY], 0, sizeof( szRegKey[NPOLICY] ));
                    memset( szRegKey[NCATEGORY], 0, sizeof( szRegKey[NCATEGORY] ));
                    fInCategory = FALSE;
                }
                break;

            case KEY_ACTIONLIST:
            case KEY_ACTIONLISTOFF:
            case KEY_ACTIONLISTON:
                if(fInActionList)
                {
                    if(nValues)
                    {
                        if(!AllocateValues(&value, nValues, REALLOCATE))
                            bContinue = FALSE;
                        else
                        {
                            part[nParts].actionlist[part[nParts].nActions - 1].value = &value[0];
                            nValuesAlloc = nValues;
                        }
                    }
                    memset(szRegKey[NACTIONLIST], 0, sizeof(szRegKey[NACTIONLIST]));
                    fInActionList = FALSE;
                }
                break;

            case KEY_ITEMLIST:
                fInItemList = FALSE;
            }
            break;
        
        case KEY_ACTIONLISTON:
        case KEY_ACTIONLISTOFF:
            if (part[nParts].nType == PART_CHECKBOX)
            {
                fInActionList = TRUE;
                nActionListType = (nKeyValue == KEY_ACTIONLISTOFF) ? 0 : 1;

                if(part[nParts].nActions == 0)
                {
                    nActionsAlloc = 1;
                    if(!AllocateActions(&actionlist, nActionsAlloc, ALLOCATE))
                        bContinue = FALSE;
                    else
                        part[nParts].actionlist = &actionlist[0];

                    part[nParts].nActions++;
                    nActions++;
                    nValues = 0;
                    nValuesAlloc = 0;
                    value = NULL;
                }
            }
            break;

        case KEY_ACTIONLIST:
            if (fInItemList)
                fInActionList = TRUE;
            break;

        case KEY_ITEMLIST:
            if (fInPart)
                fInItemList = TRUE;
            break;

        case KEY_MAXLEN:
            if(part[nParts].nType == PART_EDITTEXT)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                part[nParts].nMax = StrToInt( szKeyWord );
                if (part[nParts].nMax > MAX_EDITTEXTLEN)
                    part[nParts].nMax = MAX_EDITTEXTLEN;
            }
            break;

        case KEY_MIN:
            if(part[nParts].nType == PART_NUMERIC)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                part[nParts].nMin = StrToInt( szKeyWord );
            }
            break;

        case KEY_MAX:
            if(part[nParts].nType == PART_NUMERIC)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                part[nParts].nMax = StrToInt( szKeyWord );
            }
            break;

        case KEY_SPIN:
            if(part[nParts].nType == PART_NUMERIC)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                part[nParts].nSpin = StrToInt( szKeyWord );
            }
            break;

        case KEY_DEFCHECKED:
            if(part[nParts].nType == PART_CHECKBOX)
                part[nParts].nDefault = 1;
            else if(!fInPart && fInPolicy)
                part[nParts - 1].nDefault = 1;
            break;
        
        case KEY_DEFAULT:
            if( part[nParts].nType == PART_NUMERIC)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                part[nParts].nDefault = StrToInt( szKeyWord );
            }
            else if( part[nParts].nType == PART_EDITTEXT || part[nParts].nType == PART_COMBOBOX)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                CheckStrings( szKeyWord, pcszFileName );
                if(part[nParts].szDefaultValue != NULL)
                    LocalFree(part[nParts].szDefaultValue);
                part[nParts].szDefaultValue = NULL;
                part[nParts].szDefaultValue = StrDup(szKeyWord);
            }
            else if(part[nParts].nType == PART_DROPDOWNLIST)
            {
                if(part[nParts].szDefaultValue != NULL)
                    LocalFree(part[nParts].szDefaultValue);
                part[nParts].szDefaultValue = NULL;
                if(part[nParts].nActions != 0 && part[nParts].actionlist[part[nParts].nActions - 1].szName != NULL)
                    part[nParts].szDefaultValue = StrDup(part[nParts].actionlist[part[nParts].nActions - 1].szName);
            }
            break;

        case KEY_PART:
            if(fInPolicy)
            {
                fInPart = TRUE;
                // read the name of the part
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                CheckStrings( szKeyWord, pcszFileName );
                if(part[nParts].szName != NULL)
                    LocalFree(part[nParts].szName);
                part[nParts].szName = NULL;
                part[nParts].szName = StrDup(szKeyWord);
                // read the type of the part
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                part[nParts].nType = GetPartName( szKeyWord );
                if(part[nParts].nType != PART_TEXT && part[nParts].nType != PART_ERROR && nPolicyPart != -1)
                    part[nPolicyPart].fRequired = FALSE;
                part[nParts].hkClass = hkCurrentClass;
                if(part[nParts].szCategory != NULL)
                    LocalFree(part[nParts].szCategory);
                part[nParts].szCategory = NULL;
                part[nParts].szCategory = StrDup(szCurrentCategory);
                part[nParts].nLine = g_nLine;
                part[nParts].nMax = MAX_NUMERIC;
                if (part[nParts].nType == PART_EDITTEXT)
                    part[nParts].nMax = MAX_PATH;
                if(part[nParts].nType == PART_CHECKBOX)
                {
                    part[nParts].value.nValueOn = nValueOn;
                    part[nParts].value.nValueOff = nValueOff;
                    if(*szValueOn != 0)
                    {
                        if(part[nParts].value.szValueOn != NULL)
                            LocalFree(part[nParts].value.szValueOn);
                        part[nParts].value.szValueOn = NULL;
                        part[nParts].value.szValueOn = StrDup(szValueOn);
                    }
                    if(*szValueOff != 0)
                    {
                        if(part[nParts].value.szValueOff != NULL)
                            LocalFree(part[nParts].value.szValueOff);
                        part[nParts].value.szValueOff = NULL;
                        part[nParts].value.szValueOff = StrDup(szValueOff);
                    }
                }
                nActionsAlloc = 0;
                nActions = 0;
                actionlist = NULL;
                nSuggestions = 0;
                nSuggestionsAlloc = 0;
                suggestions = NULL;
            }
            break;

        case KEY_POLICY:
            if(fInCategory)
            {
                fInPolicy = TRUE;
                nPolicyPart = nParts;
                part[nParts].fRequired = TRUE;
                memset(szValueOn, 0, sizeof(szValueOn));
                memset(szValueOff, 0, sizeof(szValueOff));
                nValueOn = 1;
                nValueOff = 0;
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                CheckStrings( szKeyWord, pcszFileName );
                // to display policy name, add as a text
                if(part[nParts].szName != NULL)
                    LocalFree(part[nParts].szName);
                part[nParts].szName = NULL;
                part[nParts].szName = StrDup(szKeyWord);
                part[nParts].nType = GetPartName( TEXT("POLICY") );
                part[nParts].hkClass = hkCurrentClass;
                if(part[nParts].szCategory != NULL)
                    LocalFree(part[nParts].szCategory);
                part[nParts].szCategory = NULL;
                part[nParts].szCategory = StrDup(szCurrentCategory);
                part[nParts].nLine = g_nLine;
                nParts++;           
                if(nParts >= nPartsAlloc)
                {
                    nPartsAlloc += 50;
                    lpTemp = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, part, sizeof(PART) * nPartsAlloc);
                    if(lpTemp == NULL)
                        bContinue = FALSE;
                    else
                        part = (LPPART) lpTemp;
                }
            }
            break;

        case KEY_NAME:
            if(fInItemList)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                CheckStrings( szKeyWord, pcszFileName );
                if(part[nParts].nActions == 0)
                {
                    nActionsAlloc = 10;
                    if(!AllocateActions(&actionlist, nActionsAlloc, ALLOCATE))
                        bContinue = FALSE;
                    else
                        part[nParts].actionlist = &actionlist[0];
                }
                if(part[nParts].actionlist[part[nParts].nActions].szName != NULL)
                    LocalFree(part[nParts].actionlist[part[nParts].nActions].szName);
                part[nParts].actionlist[part[nParts].nActions].szName = NULL;
                part[nParts].actionlist[part[nParts].nActions].szName = StrDup(szKeyWord);
                part[nParts].nActions++;
                nActions++;
                if(nActions >= nActionsAlloc)
                {
                    nActionsAlloc += 10;
                    if(!AllocateActions(&actionlist, nActionsAlloc, REALLOCATE))
                        bContinue = FALSE;
                    else
                        part[nParts].actionlist = &actionlist[0];
                }
                nValues = 0;
                nValuesAlloc = 0;
                value = NULL;
            }
            break;

        case KEY_KEYNAME:
            pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
            pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
            if( fInActionList )
            {
                StrCpy( szRegKey[NACTIONLIST], szKeyWord );
                break;
            }
            if( fInPart )
            {
                StrCpy( szRegKey[NPART], szKeyWord );
                break;
            }
            if( fInPolicy )
            {
                StrCpy( szRegKey[NPOLICY], szKeyWord );
                break;
            }
            if( fInCategory )
            {
                StrCpy( szRegKey[NCATEGORY], szKeyWord );
                break;
            }
            break;

        case KEY_VALUENAME:
            if( fInActionList )
            {
                if(part[nParts].nActions == 0)
                    break;
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                // put the pointer to the current value into the actionlist
                if( part[nParts].actionlist[part[nParts].nActions - 1].nValues == 0)
                {
                    nValuesAlloc = 10;
                    if(!AllocateValues(&value, nValuesAlloc, ALLOCATE))
                        bContinue = FALSE;
                    else
                        part[nParts].actionlist[part[nParts].nActions - 1].value = &value[0];
                }
                else if (nValues >= nValuesAlloc)
                {
                    nValuesAlloc += 10;
                    if(!AllocateValues(&value, nValuesAlloc, REALLOCATE))
                        bContinue = FALSE;
                    else
                        part[nParts].actionlist[part[nParts].nActions - 1].value = &value[0];
                }

                if(value[nValues].szValueName != NULL)
                    LocalFree(value[nValues].szValueName);
                value[nValues].szValueName = NULL;
                value[nValues].szValueName = StrDup(szKeyWord);

                if(value[nValues].szKeyname != NULL)
                    LocalFree(value[nValues].szKeyname);
                value[nValues].szKeyname = NULL;

                if( ISNONNULL( szRegKey[NACTIONLIST] ))
                    value[nValues].szKeyname = StrDup(szRegKey[NACTIONLIST]);
                else if( ISNONNULL( szRegKey[NPART] ))
                    value[nValues].szKeyname = StrDup(szRegKey[NPART]);
                else if( ISNONNULL( szRegKey[NPOLICY] ))
                    value[nValues].szKeyname = StrDup(szRegKey[NPOLICY]);
                else if( ISNONNULL( szRegKey[NCATEGORY] ))
                    value[nValues].szKeyname = StrDup(szRegKey[NCATEGORY]);

                part[nParts].actionlist[part[nParts].nActions - 1].nValues++;

                pCurrent = ReadValue( pCurrent, &value[0], nValues, pcszFileName );

                if (part[nParts].nType == PART_CHECKBOX)
                    value[nValues].nValueOn = nActionListType;  // nValueOn is used as a buffer to hold the ACTIONLISTOFF/ON type.

                nValues++;
                break;
            }
            if( fInPolicy || fInPart )
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                StrCpy( szValueName, szKeyWord );
                break;
            }
            break;

        case KEY_SUGGESTIONS:
            if(fInPart)
            {
                while( StrCmp( szKeyWord, TEXT("END") ) != 0 && bContinue == TRUE)
                {
                    pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                    pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                    CheckStrings( szKeyWord, pcszFileName );
                    if( StrCmp( szKeyWord, TEXT("END") ) != 0 )
                    {
                        if(part[nParts].nSuggestions == 0)
                        {
                            nSuggestionsAlloc = 10;
                            if(!AllocateSuggestions(&suggestions, nSuggestionsAlloc, ALLOCATE))
                                bContinue = FALSE;
                            else
                                part[nParts].suggestions = &suggestions[0];
                        }
                        if(suggestions[nSuggestions].szText != NULL)
                            LocalFree(suggestions[nSuggestions].szText);
                        suggestions[nSuggestions].szText = NULL;
                        suggestions[nSuggestions].szText = StrDup(szKeyWord);
                        part[nParts].nSuggestions++;
                        nSuggestions++;
                        if(nSuggestions >= nSuggestionsAlloc)
                        {
                            nSuggestionsAlloc += 10;
                            if(!AllocateSuggestions(&suggestions, nSuggestionsAlloc, REALLOCATE))
                                bContinue = FALSE;
                            else
                                part[nParts].suggestions = &suggestions[0];
                        }
                    }
                }

                // throw out the word "suggestions"
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
            }
            break;

        case KEY_VALUEON:
        case KEY_VALUEOFF:
            if(fInPolicy || fInPart)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                //pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                //CheckStrings( szKeyWord, pcszFileName );
                if( StrCmp( szKeyWord, TEXT("NUMERIC") ) == 0 )
                {
                    pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                    if(nKeyValue == KEY_VALUEON)
                    {
                        if(!fInPart)
                            nValueOn = StrToInt( szKeyWord );
                        else if(fInPart && part[nParts].nType == PART_CHECKBOX)
                        {
                            part[nParts].value.nValueOn = StrToInt( szKeyWord );
                            if(part[nParts].value.szValueOn != NULL)
                                LocalFree(part[nParts].value.szValueOn);
                            part[nParts].value.szValueOn = NULL;
                        }
                    }
                    else
                    {
                        if(!fInPart)
                            nValueOff = StrToInt( szKeyWord );
                        else if(fInPart && part[nParts].nType == PART_CHECKBOX)
                        {
                            part[nParts].value.nValueOff = StrToInt( szKeyWord );
                            if(part[nParts].value.szValueOff != NULL)
                                LocalFree(part[nParts].value.szValueOff);
                            part[nParts].value.szValueOff = NULL;
                        }
                    }
                }
                else 
                {
                    if( StrCmp( szKeyWord, TEXT("TEXT") ) == 0 )
                        pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));

                    pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                    CheckStrings( szKeyWord, pcszFileName );

                    if(nKeyValue == KEY_VALUEON)
                    {
                        if(!fInPart)
                            StrCpy(szValueOn, szKeyWord);
                        else if(fInPart && part[nParts].nType == PART_CHECKBOX)
                        {
                            if(part[nParts].value.szValueOn != NULL)
                                LocalFree(part[nParts].value.szValueOn);
                            part[nParts].value.szValueOn = NULL;
                            part[nParts].value.szValueOn = StrDup(szKeyWord);
                        }
                    }
                    else
                    {
                        if (!fInPart)
                            StrCpy(szValueOff, szKeyWord);
                        else if (fInPart && part[nParts].nType == PART_CHECKBOX)
                        {
                            if(part[nParts].value.szValueOff != NULL)
                                LocalFree(part[nParts].value.szValueOff);
                            part[nParts].value.szValueOff = NULL;
                            part[nParts].value.szValueOff = StrDup(szKeyWord);
                        }
                    }
                }
            }
            break;

        case KEY_VALUE:
            if(fInItemList)
            {
                pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                //pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                //CheckStrings( szKeyWord, pcszFileName );
                
                part[nParts].actionlist[(part[nParts].nActions) - 1].dwValue = 0;
                if(part[nParts].actionlist[(part[nParts].nActions) - 1].szValue != NULL)
                    LocalFree(part[nParts].actionlist[(part[nParts].nActions) - 1].szValue);
                part[nParts].actionlist[(part[nParts].nActions) - 1].szValue = NULL;
                
                if( StrCmp( szKeyWord, TEXT("NUMERIC") ) == 0 )
                {
                    pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                    part[nParts].actionlist[(part[nParts].nActions) - 1].dwValue = StrToInt( szKeyWord );
                }
                else
                {
                    if( StrCmp( szKeyWord, TEXT("TEXT") ) == 0 )
                        pCurrent = ReadKeyword( pCurrent, szKeyWord, ARRAYSIZE( szKeyWord ));
                    
                    pCurrent = GetQuotedText( pCurrent, szKeyWord, sizeof( szKeyWord ));
                    CheckStrings( szKeyWord, pcszFileName );

                    part[nParts].actionlist[(part[nParts].nActions) - 1].szValue = StrDup( szKeyWord );
                }
            }
            break;

        case KEY_IF:
            pCurrent = ReadKeyword(pCurrent, szKeyWord, ARRAYSIZE(szKeyWord));

            if (KEY_VERSION == GetKeyName(szKeyWord))
            {
                int nVersion = 0;

                fSkip = FALSE;

                // get the operator keyword
                pCurrent = ReadKeyword(pCurrent, szKeyWord, ARRAYSIZE(szKeyWord));
                nKeyValue = GetKeyName(szKeyWord);

                // get the version number
                pCurrent = ReadKeyword(pCurrent, szKeyWord, ARRAYSIZE(szKeyWord));
                nVersion = StrToInt(szKeyWord);

                switch (nKeyValue)
                {
                    case KEY_LT:
                    case KEY_LTE:
                        break;

                    case KEY_GT:
                        if (ADM_VERSION <= nVersion)
                            fSkip = TRUE;
                        break;

                    case KEY_GTE:
                        if (ADM_VERSION < nVersion)
                            fSkip = TRUE;
                        break;                
                }
            }
            break;

        case KEY_ENDIF:
            fSkip = FALSE;
            break;

        }
    }
    while( lstrlen( pCurrent ) && bContinue);

    if (bContinue == FALSE)
    {
        FreeAdmMemory( admfile );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }
    else
    {
        admfile->pParts = part;
        admfile->nParts = nParts;

        StrCpy(admfile->szFilename, pcszFileName);
    }

    // clean up
    LocalFree( hFileMem );
    
    return bContinue;
}

#define MAX_REGLINE     1024

BOOL CopyData(LPTSTR pData, int* pnData, int* pnCopyIndex, LPTSTR szTmpData)
{
    LPVOID lpTemp = NULL;

    if ((*pnCopyIndex + lstrlen(szTmpData) + 1) > ((*pnData) - 1))
    {
        (*pnData) += MAX_REGLINE;
        lpTemp = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pData, StrCbFromCch(*pnData));
        if (lpTemp == NULL)
            return FALSE;
        else
            pData = (LPTSTR) lpTemp;
    }

    CopyMemory(pData + *pnCopyIndex, szTmpData, StrCbFromSz(szTmpData));
    (*pnCopyIndex) += lstrlen(szTmpData);
    // skip over one byte so our list is 0 separated
    (*pnCopyIndex)++;
    return TRUE;
}


//--------------------------------------------------------------------------
//  W R I T E  I N F  F I L E       Exported Function
//
//  Creates an .inf file from a PART array.
//--------------------------------------------------------------------------
void WriteInfFile( LPADMFILE admfile, LPCTSTR pcszFileName, LPPARTDATA pData )
{
    LPPART  part;
    int     nParts;
    TCHAR   szClassString[5];
    TCHAR   szTmpData[MAX_REGLINE];
    int     i, j;
    BOOL    bContinue = TRUE;
    TCHAR   szValueText[1024];
    DWORD   dwValue;
    TCHAR   szKeyName[MAX_PATH];
    BOOL    fWrite = FALSE;
    LPTSTR  pHKLMData, pHKCUData;
    int     nHKLMCopyIndex = 0, 
            nHKCUCopyIndex = 0,
            nHKLMData = ((admfile->nParts + 1) * MAX_REGLINE),
            nHKCUData = ((admfile->nParts + 1) * MAX_REGLINE);

    // allocate memory for the .inf section
    pHKLMData = (LPTSTR) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, StrCbFromCch(nHKLMData));
    pHKCUData = (LPTSTR) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, StrCbFromCch(nHKCUData));

    if (pHKLMData == NULL || pHKCUData == NULL)
        return;

    part = (LPPART) admfile->pParts;
    nParts = admfile->nParts;

    // loop through parts, adding each one to the inf section
    for( i = 0; (i < nParts) && bContinue; i++ )
    {
        if (!pData[i].fSave)
            continue;

        fWrite = TRUE;

        if( (pData[i].value.szValue != NULL && lstrlen( pData[i].value.szValue ) > 0) || 
            (pData[i].value.fNumeric == TRUE) )
        {
            // get the class
            if( part[i].hkClass == HKEY_LOCAL_MACHINE )
                StrCpy( szClassString, TEXT("HKLM") );
            else
                StrCpy( szClassString, TEXT("HKCU") );

            ZeroMemory(szTmpData, sizeof(szTmpData));
            if( !pData[i].value.fNumeric )   // value is a string
            {
                ZeroMemory(szValueText, sizeof(szValueText));
                if(part[i].nType == PART_DROPDOWNLIST)
                {
                    if(pData[i].nSelectedAction != NO_ACTION && part[i].nActions > 0)
                    {
                        LPACTIONLIST action = &part[i].actionlist[pData[i].nSelectedAction];
                        if(action->szValue != NULL)
                            StrCpy(szValueText, action->szValue);
                        else
                        {
                            if(part[i].value.szKeyname != NULL && part[i].value.szValueName != NULL)
                            {
                                if ((lstrlen(szClassString) + lstrlen(part[i].value.szKeyname) + 
                                     lstrlen(part[i].value.szValueName) + 27) < MAX_REGLINE)
                                    wnsprintf(szTmpData, ARRAYSIZE(szTmpData), TEXT("%s,\"%s\",\"%s\",0x10001,%x,%x,%x,%x"), szClassString,
                                             part[i].value.szKeyname, part[i].value.szValueName,
                                             LOBYTE(LOWORD(action->dwValue)),
                                             HIBYTE(LOWORD(action->dwValue)),
                                             LOBYTE(HIWORD(action->dwValue)),
                                             HIBYTE(HIWORD(action->dwValue)));
                            }
                        }
                    }
                }
                else
                    StrCpy(szValueText, pData[i].value.szValue);

                if(part[i].value.szKeyname != NULL && part[i].value.szValueName != NULL && ISNONNULL(szValueText))
                {
                    if ((lstrlen(szClassString) + lstrlen(part[i].value.szKeyname) + lstrlen(part[i].value.szValueName) + 
                         lstrlen(szValueText) + 12) < MAX_REGLINE)
                        wnsprintf(szTmpData, ARRAYSIZE(szTmpData), TEXT("%s,\"%s\",\"%s\",0,\"%s\""), szClassString,
                                 part[i].value.szKeyname, part[i].value.szValueName,
                                 szValueText);
                }
            }
            else                            // value is a dword
            {
                if(((part[i].nType == PART_POLICY && part->fRequired) || part[i].nType == PART_CHECKBOX) &&
                    (part[i].value.szValueOn != NULL))
                {
                    if(pData[i].value.dwValue != 0)
                        StrCpy(szValueText, part[i].value.szValueOn);
                    else
                        StrCpy(szValueText, part[i].value.szValueOff);
                    
                    if(part[i].value.szKeyname != NULL && part[i].value.szValueName != NULL)
                    {
                        if ((lstrlen(szClassString) + lstrlen(part[i].value.szKeyname) + lstrlen(part[i].value.szValueName) + 
                             lstrlen(szValueText) + 12) < MAX_REGLINE)
                            wnsprintf(szTmpData, ARRAYSIZE(szTmpData), TEXT("%s,\"%s\",\"%s\",0,\"%s\""), szClassString,
                                     part[i].value.szKeyname, part[i].value.szValueName,
                                     szValueText);
                    }
                }
                else
                {
                    if((part[i].nType == PART_POLICY && part->fRequired) || part[i].nType == PART_CHECKBOX)
                    {
                        if(pData[i].value.dwValue != 0)
                            dwValue = part[i].value.nValueOn;
                        else
                            dwValue = part[i].value.nValueOff;
                    }
                    else
                        dwValue = pData[i].value.dwValue;

                    memset(szKeyName, 0, sizeof(szKeyName));
                    if(part[i].nType == PART_LISTBOX)
                        StrCpy(szKeyName, part[i].szDefaultValue);
                    else
                        StrCpy(szKeyName, part[i].value.szKeyname);

                    if(ISNONNULL(szKeyName) && part[i].value.szValueName != NULL)
                    {
                        if ((lstrlen(szClassString) + lstrlen(szKeyName) + 
                             lstrlen(part[i].value.szValueName) + 27) < MAX_REGLINE)
                            wnsprintf(szTmpData, ARRAYSIZE(szTmpData), TEXT("%s,\"%s\",\"%s\",0x10001,%x,%x,%x,%x"), szClassString,
                                     szKeyName, part[i].value.szValueName,
                                     LOBYTE(LOWORD(dwValue)),
                                     HIBYTE(LOWORD(dwValue)),
                                     LOBYTE(HIWORD(dwValue)),
                                     HIBYTE(HIWORD(dwValue)));
                    }
                }
            }

            if(ISNONNULL(szTmpData))
            {
                if (part[i].hkClass == HKEY_LOCAL_MACHINE)
                    bContinue = CopyData(pHKLMData, &nHKLMData, &nHKLMCopyIndex, szTmpData);
                else
                    bContinue = CopyData(pHKCUData, &nHKCUData, &nHKCUCopyIndex, szTmpData);
            }
        }

        // check to see if there is an item in an actionlist selected
        if( pData[i].nSelectedAction != NO_ACTION && (part[i].nActions > 0 || pData[i].nActions > 0))
        {
            LPACTIONLIST action =  NULL;

            if(part[i].nType == PART_LISTBOX)
                action =  &pData[i].actionlist[pData[i].nSelectedAction];
            else
                action =  &part[i].actionlist[pData[i].nSelectedAction];

            // get the class
            if( part[i].hkClass == HKEY_LOCAL_MACHINE )
            {
                StrCpy( szClassString, TEXT("HKLM") );
            }
            else
            {
                StrCpy( szClassString, TEXT("HKCU") );
            }

            for( j = 0; j < action->nValues; j++ )
            {
                if (part[i].nType == PART_CHECKBOX && ((int)pData[i].value.dwValue) != action->value[j].nValueOn)
                    continue;

                ZeroMemory(szTmpData, sizeof(szTmpData));
                if( !action->value[j].fNumeric )
                {
                    if(action->value[j].szKeyname != NULL && action->value[j].szValueName != NULL && action->value[j].szValue != NULL)
                    {
                        if ((lstrlen(szClassString) + lstrlen(action->value[j].szKeyname) + lstrlen(action->value[j].szValueName) +
                             lstrlen(action->value[j].szValue) + 12) < MAX_REGLINE)
                            wnsprintf(szTmpData, ARRAYSIZE(szTmpData), TEXT("%s,\"%s\",\"%s\",0,\"%s\""), szClassString,
                                     action->value[j].szKeyname, action->value[j].szValueName,
                                     action->value[j].szValue);
                    }
                }
                else                            // value is a dword
                {
                    if(action->value[j].szKeyname != NULL && action->value[j].szValueName != NULL)
                    {
                        if ((lstrlen(szClassString) + lstrlen(action->value[j].szKeyname) + 
                             lstrlen(action->value[j].szValueName) + 27) < MAX_REGLINE)
                            wnsprintf(szTmpData, ARRAYSIZE(szTmpData), TEXT("%s,\"%s\",\"%s\",0x10001,%x,%x,%x,%x"), szClassString,
                                     action->value[j].szKeyname, action->value[j].szValueName,
                                     LOBYTE(LOWORD(action->value[j].dwValue)),
                                     HIBYTE(LOWORD(action->value[j].dwValue)),
                                     LOBYTE(HIWORD(action->value[j].dwValue)),
                                     HIBYTE(HIWORD(action->value[j].dwValue)));
                    }
                }

                if(ISNONNULL(szTmpData))
                {
                    if (part[i].hkClass == HKEY_LOCAL_MACHINE)
                        bContinue = CopyData(pHKLMData, &nHKLMData, &nHKLMCopyIndex, szTmpData);
                    else
                        bContinue = CopyData(pHKCUData, &nHKCUData, &nHKCUCopyIndex, szTmpData);
                }
            }
        }
    }

    if (fWrite)
    {
        // write default headers into the .inf file
        InsWriteString( TEXT("Version"), TEXT("Signature"), TEXT("$CHICAGO$"), pcszFileName );
        InsWriteString( TEXT("Version"), TEXT("SetupClass"), TEXT("Base"), pcszFileName );
        InsWriteString( TEXT("DefaultInstall"), TEXT("AddReg"), TEXT("AddRegSection.HKLM,AddRegSection.HKCU"), pcszFileName );
        InsWriteString( TEXT("DefaultInstall"), TEXT("RequiredEngine"), TEXT("Setupapi,\"missing setupapi.dll\""), pcszFileName );

        InsWriteString( TEXT("DefaultInstall.HKLM"), TEXT("AddReg"), TEXT("AddRegSection.HKLM"), pcszFileName );
        InsWriteString( TEXT("DefaultInstall.HKLM"), TEXT("RequiredEngine"), TEXT("Setupapi,\"missing setupapi.dll\""), pcszFileName );
        
        InsWriteString( TEXT("IEAKInstall.HKLM"), TEXT("AddReg"), TEXT("AddRegSection.HKLM"), pcszFileName );
        InsWriteString( TEXT("IEAKInstall.HKLM"), TEXT("RequiredEngine"), TEXT("Setupapi,\"missing setupapi.dll\""), pcszFileName );

        InsWriteString( TEXT("DefaultInstall.HKCU"), TEXT("AddReg"), TEXT("AddRegSection.HKCU"), pcszFileName );
        InsWriteString( TEXT("DefaultInstall.HKCU"), TEXT("RequiredEngine"), TEXT("Setupapi,\"missing setupapi.dll\""), pcszFileName );

        InsWriteString( TEXT("IEAKInstall.HKCU"), TEXT("AddReg"), TEXT("AddRegSection.HKCU"), pcszFileName );
        InsWriteString( TEXT("IEAKInstall.HKCU"), TEXT("RequiredEngine"), TEXT("Setupapi,\"missing setupapi.dll\""), pcszFileName );

        InsDeleteSection( TEXT("AddRegSection"), pcszFileName );
        InsDeleteSection( TEXT("AddRegSection.HKLM"), pcszFileName );
        InsDeleteSection( TEXT("AddRegSection.HKCU"), pcszFileName );

        WritePrivateProfileSection( TEXT("AddRegSection.HKLM"), pHKLMData, pcszFileName );
        WritePrivateProfileSection( TEXT("AddRegSection.HKCU"), pHKCUData, pcszFileName );

        InsFlushChanges(pcszFileName);
    }

    HeapFree(GetProcessHeap(), 0, pHKLMData);
    HeapFree(GetProcessHeap(), 0, pHKCUData);
}

//--------------------------------------------------------------------------
//  R E M O V E  Q U O T E S
//
//  Removes and quotes surrounding a string
//--------------------------------------------------------------------------
void RemoveQuotes( LPTSTR pText )
{
    if( pText[0] == TEXT('\"') && pText[lstrlen(pText)-1] == TEXT('\"') )
    {
        memcpy( pText, &pText[1], (lstrlen( pText ) - 2) * sizeof(TCHAR) );
        pText[lstrlen( pText ) - 2] = TEXT('\0');
    }
}

//--------------------------------------------------------------------------
//  R E A D  H E X  S T R
//
//  Reads in a hex number from a string and converts it to an int
//--------------------------------------------------------------------------
int ReadHexStr( LPTSTR szStr )
{
    int i,j;        // counter
    int n = 1;      // multiplier
    int num = 0;    // return value
    int tmp = 0;    // temporary value
    int nLen = lstrlen( szStr );

    for( i = 0; i < nLen; i++ )
    {
        n = 1;

        for( j = 0; j < (nLen - i - 1); j++ )
            n *= 0x10;

        if( szStr[i] >= TEXT('0') && szStr[i] <= TEXT('9') )
            tmp = szStr[i] - TEXT('0');

        if( szStr[i] >= TEXT('a') && szStr[i] <= TEXT('f') )
            tmp = szStr[i] - TEXT('a') + 10;

        if( szStr[i] >= TEXT('A') && szStr[i] <= TEXT('F') )
            tmp = szStr[i] - TEXT('A') + 10;

        tmp *= n;
        num += tmp;
    }
    return num;
}

//--------------------------------------------------------------------------
//  R E A D  I N F  F I L E         Exported Function
//
//  Reads an .inf file into a PART array
//--------------------------------------------------------------------------
void ReadInfFile( LPADMFILE admfile, LPCTSTR pcszFileName, LPPARTDATA pPartData )
{
    LPPART part;
    LPTSTR pData;
    LPTSTR pCurrent;
    VALUE value;
    HKEY hkClass;
    TCHAR szClass[10];
    TCHAR szType[10];
    TCHAR szValue[MAX_PATH + 1];
    int i;
    int nSize;
    int nIndex;
    
    if( !FileExists( pcszFileName ))
        return;     // bug bug

    part = admfile->pParts;

    // allocate 32KB for GetPrivateProfileSection
    pData = (LPTSTR) LocalAlloc( LPTR, (MAX_NUMERIC + 1) * sizeof(TCHAR) );
    if (pData == NULL)
        return;

    nSize = GetPrivateProfileSection( TEXT("AddRegSection"), pData, MAX_NUMERIC, pcszFileName );
    if( nSize == 0 )
    {
        nSize = GetPrivateProfileSection( TEXT("AddRegSection.HKLM"), pData, MAX_NUMERIC, pcszFileName );
        nSize += GetPrivateProfileSection( TEXT("AddRegSection.HKCU"), pData + nSize, MAX_NUMERIC - nSize, pcszFileName );
        if (nSize == 0)
        {
            LocalFree((HGLOBAL)pData);
            return;     // bug bug
        }
    }

    // convert all zeros to newlines
    for( i = 0; i < nSize; i++ )
    {
        if( pData[i] == TEXT('\0') )
        {
            pData[i] = TEXT('\n');
        }
    }

    pCurrent = pData;

    while( pCurrent < pData + nSize - 2 )
    {
        memset( &value, 0, sizeof( value ));

        // read one line from the section
        i = StrCSpn( pCurrent, TEXT(",\n") );
        StrCpyN( szClass, pCurrent, i+1 );
        pCurrent += i+1;
        i = StrCSpn( pCurrent, TEXT(",\n") );
        value.szKeyname = (TCHAR *)LocalAlloc(LPTR, sizeof(TCHAR) * (i+2));
        StrCpyN( value.szKeyname, pCurrent, i+1 );
        pCurrent += i+1;
        i = StrCSpn( pCurrent, TEXT(",\n") );
        value.szValueName = (TCHAR *)LocalAlloc(LPTR, sizeof(TCHAR) * (i+2));
        StrCpyN( value.szValueName, pCurrent, i+1 );
        pCurrent += i+1;
        i = StrCSpn( pCurrent, TEXT(",\n") );
        StrCpyN( szType, pCurrent, i+1 );
        pCurrent += i+1;
        i = StrCSpn( pCurrent, TEXT("\n") );
        StrCpyN( szValue, pCurrent, i+1 );
        pCurrent += i+1;

        RemoveQuotes( value.szKeyname );
        RemoveQuotes( value.szValueName );
        RemoveQuotes( szValue );

        if( StrCmpI( szClass, TEXT("HKLM") ) == 0 )
            hkClass = HKEY_LOCAL_MACHINE;
        else
            hkClass = HKEY_CURRENT_USER;

        if( StrCmp(szType, TEXT("0") ) == 0 )
            value.fNumeric = FALSE;
        else
            value.fNumeric = TRUE;

        if( value.fNumeric )
        {
            int a[4]={0,0,0,0},j=0;
            TCHAR *p1, *p2;
            p1 = p2 = szValue;

            while( *p1 )
            {
                if( *p1 == TEXT(',') )
                {
                    *p1 = TEXT('\0');
                    a[j] = ReadHexStr( p2 );
                    j++;
                    p2 = p1 + 1;
                }
                p1++;
            }

            a[j] = ReadHexStr( p2 );

            value.dwValue = MAKELONG(MAKEWORD(a[0],a[1]),MAKEWORD(a[2],a[3]));
        }
        else
            value.szValue = StrDup(szValue);

        for( i = 0; i < admfile->nParts; i++ )
        {
            if( hkClass == part[i].hkClass )
            {
                if( part[i].value.szKeyname != NULL && StrCmpI( value.szKeyname, part[i].value.szKeyname ) == 0 )
                {
                    // special case out LISTBOX because there is no valuenames specified for
                    // individual list items.
                    if( part[i].nType == PART_LISTBOX || part[i].value.szValueName != NULL && StrCmpI( value.szValueName, part[i].value.szValueName) == 0 )
                    {
                        if(pPartData[i].value.szValue != NULL)
                            LocalFree(pPartData[i].value.szValue);
                        pPartData[i].value.szValue = NULL;
                        if((part[i].nType == PART_POLICY && part->fRequired) || part[i].nType == PART_CHECKBOX)
                        {
                            if(value.fNumeric)
                            {
                                if(value.dwValue == (DWORD) part[i].value.nValueOn)
                                    pPartData[i].value.dwValue = 1;
                                else
                                    pPartData[i].value.dwValue = 0;
                                if (value.szValue != NULL)
                                    pPartData[i].value.szValue = StrDup(value.szValue);
                                pPartData[i].value.fNumeric = value.fNumeric;
                            }
                            else
                            {
                                if(part[i].value.szValueOn != NULL && value.szValue != NULL && StrCmp(part[i].value.szValueOn, value.szValue) == 0)
                                    pPartData[i].value.dwValue = 1;
                                else
                                    pPartData[i].value.dwValue = 0;
                                if (value.szValue != NULL)
                                    pPartData[i].value.szValue = StrDup(value.szValue);
                                pPartData[i].value.fNumeric = TRUE;
                            }
                            pPartData[i].fSave = TRUE;
                        }
                        else if(part[i].nType == PART_DROPDOWNLIST)
                        {
                            if(part[i].nSelectedAction != NO_ACTION && part[i].nActions > 0)
                            {
                                for(nIndex = 0; nIndex < part[i].nActions; nIndex++)
                                {
                                    if(value.fNumeric)
                                    {
                                        if(part[i].actionlist[nIndex].dwValue == value.dwValue && part[i].actionlist[nIndex].szName)
                                        {
                                            pPartData[i].value.szValue = StrDup(part[i].actionlist[nIndex].szName);
                                            pPartData[i].nSelectedAction = nIndex;
                                        }
                                    }
                                    else
                                    {
                                        if(part[i].actionlist[nIndex].szValue != NULL && value.szValue != NULL &&
                                            StrCmp(part[i].actionlist[nIndex].szValue, value.szValue) == 0 &&
                                            part[i].actionlist[nIndex].szName != NULL)
                                        {
                                            pPartData[i].value.szValue = StrDup(part[i].actionlist[nIndex].szName);
                                            pPartData[i].nSelectedAction = nIndex;
                                        }
                                    }
                                }
                                pPartData[i].fSave = TRUE;
                            }
                            pPartData[i].value.fNumeric = FALSE;
                        }
                        else if(part[i].nType == PART_LISTBOX && !value.fNumeric)
                        {
                            // Allocate memory
                            if(pPartData[i].nActions == 0)
                                pPartData[i].actionlist = (LPACTIONLIST) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ACTIONLIST));
                            if(pPartData[i].actionlist != NULL)
                            {
                                if(pPartData[i].nActions == 0)
                                {
                                    pPartData[i].nActions = 1;
                                    pPartData[i].actionlist[0].value = (LPVALUE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(VALUE));
                                }
                                if(pPartData[i].actionlist[0].value != NULL)
                                {
                                    TCHAR szValueName[10];
                                    int nItems = pPartData[i].actionlist[0].nValues;

                                    if(nItems != 0)
                                    {
                                        LPVOID lpTemp;

                                        lpTemp = (LPVALUE) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pPartData[i].actionlist[0].value, sizeof(VALUE) * (nItems + 1));
                                        if (lpTemp != NULL)
                                            pPartData[i].actionlist[0].value = (LPVALUE)lpTemp;
                                        else
                                            continue;
                                    }
                                    if (part[i].value.szKeyname != NULL)
                                        pPartData[i].actionlist[0].value[nItems].szKeyname = StrDup(part[i].value.szKeyname);
                                    wnsprintf(szValueName, ARRAYSIZE(szValueName), TEXT("%d"), nItems + 1);
                                    pPartData[i].actionlist[0].value[nItems].szValueName = StrDup(szValueName);
                                    if (value.szValue != NULL)
                                        pPartData[i].actionlist[0].value[nItems].szValue = StrDup(value.szValue);
                                    pPartData[i].actionlist[0].nValues++;
                                    pPartData[i].value.fNumeric = TRUE;
                                    pPartData[i].value.dwValue = 1;
                                    pPartData[i].fSave = TRUE;
                                }
                            }
                        }
                        else
                        {
                            if (value.szValue != NULL)
                                pPartData[i].value.szValue = StrDup(value.szValue);
                            pPartData[i].value.dwValue = value.dwValue;
                            pPartData[i].value.fNumeric = value.fNumeric;
                            pPartData[i].fSave = TRUE;
                        }
                    }
                }
            }
        }

        if(value.szKeyname != NULL)
            LocalFree(value.szKeyname);
        value.szKeyname = NULL;
        if(value.szValueName != NULL)
            LocalFree(value.szValueName);
        value.szValueName = NULL;
        if(value.szValue != NULL)
            LocalFree(value.szValue);
        value.szValue = NULL;
    }

    LocalFree( (HGLOBAL) pData );
}

//--------------------------------------------------------------------------
//  B A S E F I L E N A M E
//
//  Returns a pointer to the filename stripping directory path if any
//--------------------------------------------------------------------------
LPCTSTR BaseFileName(LPCTSTR pcszFileName)
{
    TCHAR* ptr = StrRChr(pcszFileName, NULL, TEXT('\\'));
    if(ptr == NULL)
        return pcszFileName;
    else
        return (LPCTSTR) ++ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\parser\resource.h ===
#define IDC_ADD                         3
#define IDC_DELETE                      4
#define IDD_VALUEDLG                    101
#define IDC_VALUELIST                   1000
#define IDC_VALUE_ED                    1001
#define IDC_STATIC                      -1

#define IDS_TITLE						2001
#define IDS_LISTINSERTFAIL				2002
#define IDS_VALUETEXTNULL				2003
#define IDS_SHOWBUTTON                  2004
#define IDS_PERUSER                     2005
#define IDS_PERMACHINE                  2006
#define IDS_ADMBOLDFONT                 2007
#define IDS_ADMBOLDFONTSIZE             2008
#define IDS_DUPKEY_FORMAT               2009
#define IDS_NOT_ENOUGH_MEMORY           2010
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\parser\rsop.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "shlwapi.h"
#include "parse.h"

#include "wbemcli.h"
#include "SComPtr.h"
#include "rsop.h"

/////////////////////////////////////////////////////////////////////
// Reads all RSOP_IERegistryPolicySetting instances in the namespace and
// stores them in a list.
/////////////////////////////////////////////////////////////////////
CRSOPRegData::CRSOPRegData():
	m_pData(NULL)	
{
}

CRSOPRegData::~CRSOPRegData()
{
    Free();
}

/////////////////////////////////////////////////////////////////////
void CRSOPRegData::Free()
{
	__try
	{
		if (NULL != m_pData)
		{
			LPRSOPREGITEM lpTemp;
			do
			{
				lpTemp = m_pData->pNext;
				if (m_pData->lpData)
					LocalFree (m_pData->lpData);

				LocalFree (m_pData);
				m_pData = lpTemp;
			} while (lpTemp);
		}
	}
	__except(TRUE)
	{
	}
}

/////////////////////////////////////////////////////////////////////
HRESULT CRSOPRegData::Initialize(BSTR bstrNamespace)
{
    HRESULT hr = S_OK;
	__try
	{
		_bstr_t bstrWQL = L"WQL";
		_bstr_t bstrQuery = L"SELECT currentUser, registryKey, valueName, valueType, value, deleted, precedence, GPOID, command FROM RSOP_IERegistryPolicySetting";
		_bstr_t bstrRegistryKey = L"registryKey";
		_bstr_t bstrCurrentUser = L"currentUser";
		_bstr_t bstrValueName = L"valueName";
		_bstr_t bstrValueType = L"valueType";
		_bstr_t bstrValue = L"value";
		_bstr_t bstrDeleted = L"deleted";
		_bstr_t bstrPrecedence = L"precedence";
		_bstr_t bstrGPOid = L"GPOID";
		_bstr_t bstrCommand = L"command";

		// Create an instance of the WMI locator service
		ComPtr<IWbemLocator> pIWbemLocator = NULL;
		hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
							  IID_IWbemLocator, (LPVOID *) &pIWbemLocator);
		if (SUCCEEDED(hr))
		{
			// Connect to the server
			ComPtr<IWbemServices> pIWbemServices = NULL;
			hr = pIWbemLocator->ConnectServer(bstrNamespace, NULL, NULL, 0L, 0L, NULL,
												NULL, &pIWbemServices);
			if (SUCCEEDED(hr))
			{
				// Execute the query
				ComPtr<IEnumWbemClassObject> pEnum = NULL;
				hr = pIWbemServices->ExecQuery (bstrWQL, bstrQuery,
												WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
												NULL, &pEnum);
				if (SUCCEEDED(hr))
				{
					// Loop through the results
					ComPtr<IWbemClassObject> pRegObj = NULL;
					ULONG ulRet = 0;
					hr = pEnum->Next(WBEM_INFINITE, 1, &pRegObj, &ulRet);
					while (S_OK == hr && 0 != ulRet) // ulRet == 0 is "data not available" case
					{
						// Get the deleted flag & registry key
						_variant_t varDeleted;
						_variant_t varRegistryKey;
						hr = pRegObj->Get (bstrDeleted, 0, &varDeleted, NULL, NULL);
						if (SUCCEEDED(hr))
							hr = pRegObj->Get (bstrRegistryKey, 0, &varRegistryKey, NULL, NULL);

						// Get the class (current user or local machine)
						_variant_t varCurUser;
						if (SUCCEEDED(hr))
							hr = pRegObj->Get (bstrCurrentUser, 0, &varCurUser, NULL, NULL);

						// Get the value name
						_variant_t varValueName;
						if (SUCCEEDED(hr))
							hr = pRegObj->Get (bstrValueName, 0, &varValueName, NULL, NULL);

						// Get the value type
						_variant_t varValueType;
						if (SUCCEEDED(hr))
							hr = pRegObj->Get (bstrValueType, 0, &varValueType, NULL, NULL);

						// Get the value data
						_variant_t varData;
						if (SUCCEEDED(hr))
							hr = pRegObj->Get (bstrValue, 0, &varData, NULL, NULL);

						// Get the precedence
						_variant_t varPrecedence;
						if (SUCCEEDED(hr))
							hr = pRegObj->Get (bstrPrecedence, 0, &varPrecedence, NULL, NULL);

						// Get the command
						_variant_t varCommand;
						if (SUCCEEDED(hr))
							hr = pRegObj->Get (bstrCommand, 0, &varCommand, NULL, NULL);

						// Get the GPO ID
						_variant_t varGPOid;
						if (SUCCEEDED(hr))
							hr = pRegObj->Get (bstrGPOid, 0, &varGPOid, NULL, NULL);

						if (SUCCEEDED(hr))
						{
							LPTSTR lpGPOName;
							hr = GetGPOFriendlyName (pIWbemServices, varGPOid.bstrVal,
													 bstrWQL, &lpGPOName);
							if (SUCCEEDED(hr))
							{
								BSTR bstrValueTemp = NULL;
								if (varValueName.vt != VT_NULL)
									bstrValueTemp = varValueName.bstrVal;

								DWORD dwDataSize = 0;
								LPBYTE lpData = NULL;
								if (varData.vt != VT_NULL)
								{
									SAFEARRAY *pSafeArray = varData.parray;
									dwDataSize = pSafeArray->rgsabound[0].cElements;
									lpData = (LPBYTE) pSafeArray->pvData;
								}

								if ((varValueType.uintVal == REG_NONE) && bstrValueTemp &&
									!lstrcmpi(bstrValueTemp, TEXT("**command")))
								{
									bstrValueTemp = varCommand.bstrVal;
									dwDataSize = 0;
									lpData = NULL;
								}

								AddNode((varCurUser.boolVal == 0) ? FALSE : TRUE,
										varRegistryKey.bstrVal, bstrValueTemp,
										varValueType.uintVal, dwDataSize, lpData,
										varPrecedence.uintVal, lpGPOName,
										(varDeleted.boolVal == 0) ? FALSE : TRUE);

								LocalFree (lpGPOName);
							}
						}

						hr = pEnum->Next(WBEM_INFINITE, 1, &pRegObj, &ulRet);
					}
				}
			}
		}
	}
	__except(TRUE)
	{
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CRSOPRegData::GetGPOFriendlyName(IWbemServices *pIWbemServices,
									   LPTSTR lpGPOID, BSTR bstrLanguage,
									   LPTSTR *pGPOName)
{
	HRESULT hr = NOERROR;
	__try
	{
		// Set the default
		*pGPOName = NULL;

		// Build the query
		ComPtr<IEnumWbemClassObject> pEnum = NULL;
		LPTSTR lpQuery = (LPTSTR) LocalAlloc (LPTR, ((lstrlen(lpGPOID) + 50) * sizeof(TCHAR)));
		if (NULL != lpQuery)
		{
			wsprintf (lpQuery, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);
			_bstr_t bstrQuery = lpQuery;

			// Execute the query
			hr = pIWbemServices->ExecQuery(bstrLanguage, bstrQuery,
											WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
											NULL, &pEnum);
		}
		else
			hr = E_OUTOFMEMORY;

		ComPtr<IWbemClassObject> pGPOObj;
		ULONG nObjects = 0;
		if (SUCCEEDED(hr))
		{
			// Loop through the results
			hr = pEnum->Next(WBEM_INFINITE, 1, &pGPOObj, &nObjects);
		}

		_bstr_t bstrName = L"name";
		_variant_t varGPOName;
		if (SUCCEEDED(hr) && nObjects > 0)
		{
			// Get the name
			hr = pGPOObj->Get(bstrName, 0, &varGPOName, NULL, NULL);
			if (SUCCEEDED(hr))
			{
				// Save the name
				*pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(varGPOName.bstrVal) + 1) * sizeof(TCHAR));
				if (*pGPOName)
				{
					_bstr_t bstrVal = varGPOName.bstrVal;
					lstrcpy (*pGPOName, (LPCTSTR)bstrVal);
					hr = S_OK;
				}
				else
					hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
			}

		}
		// Check for the "data not available case"
		else if (nObjects == 0)
			hr = S_OK;

		if (lpQuery)
			LocalFree (lpQuery);
	}
	__except(TRUE)
	{
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////
BOOL CRSOPRegData::AddNode(BOOL bHKCU, BSTR bstrKeyName, BSTR bstrValueName,
						   DWORD dwType, DWORD dwDataSize, LPBYTE lpData,
						   UINT uiPrecedence, LPTSTR lpGPOName, BOOL bDeleted)
{
	BOOL bRet = FALSE;
	__try
	{
		// Calculate the size of the new registry item
		DWORD dwSize = sizeof (RSOPREGITEM);
		if (bstrKeyName)
			dwSize += ((SysStringLen(bstrKeyName) + 1) * sizeof(WCHAR));
		if (bstrValueName)
			dwSize += ((SysStringLen(bstrValueName) + 1) * sizeof(WCHAR));
		if (lpGPOName)
			dwSize += ((SysStringLen(lpGPOName) + 1) * sizeof(TCHAR));

		// Allocate space for it
		LPRSOPREGITEM lpItem = (LPRSOPREGITEM) LocalAlloc (LPTR, dwSize);
		if (!lpItem)
			return FALSE;

		// Fill in item
		lpItem->bHKCU = bHKCU;
		lpItem->dwType = dwType;
		lpItem->dwSize = dwDataSize;
		lpItem->uiPrecedence = uiPrecedence;
		lpItem->bDeleted = bDeleted;

		if (bstrKeyName)
		{
			lpItem->lpKeyName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));
			lstrcpy (lpItem->lpKeyName, (LPCTSTR)bstrKeyName);
		}

		if (bstrValueName)
		{
			if (bstrKeyName)
				lpItem->lpValueName = lpItem->lpKeyName + lstrlen (lpItem->lpKeyName) + 1;
			else
				lpItem->lpValueName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));

			lstrcpy (lpItem->lpValueName, (LPCTSTR)bstrValueName);
		}

		if (lpGPOName)
		{
			if (bstrValueName)
				lpItem->lpGPOName = lpItem->lpValueName + lstrlen (lpItem->lpValueName) + 1;
			else
			{
				if (bstrKeyName)
					lpItem->lpGPOName = lpItem->lpKeyName + lstrlen (lpItem->lpKeyName) + 1;
				else
					lpItem->lpGPOName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));
			}

			lstrcpy (lpItem->lpGPOName, lpGPOName);
		}

		if (lpData)
		{
			lpItem->lpData = (LPBYTE) LocalAlloc (LPTR, dwDataSize);
			if (!lpItem->lpData)
			{
				LocalFree (lpItem);
				return FALSE;
			}

			CopyMemory (lpItem->lpData, lpData, dwDataSize);
		}

		// Add item to link list
		lpItem->pNext = m_pData;
		m_pData = lpItem;

		bRet = TRUE;
	}
	__except(TRUE)
	{
	}
    return bRet;
}

const TCHAR szDELETEPREFIX[]    = TEXT("**del.");

#ifndef NORM_STOP_ON_NULL
#define NORM_STOP_ON_NULL         0x10000000
#endif

/////////////////////////////////////////////////////////////////////
UINT CRSOPRegData::ReadValue(UINT uiPrecedence, BOOL bHKCU, LPTSTR pszKeyName,
							 LPTSTR pszValueName, LPBYTE pData, DWORD dwMaxSize,
							 DWORD *pdwType, LPTSTR *lpGPOName, LPRSOPREGITEM lpItem /*= NULL*/)
{
	UINT iRet = ERROR_SUCCESS;
	__try
	{
		LPRSOPREGITEM lpTemp = NULL;
		BOOL bDeleted = FALSE;
		LPTSTR lpValueNameTemp = pszValueName;

		if (!lpItem)
		{
			lpTemp = m_pData;

			if (pszValueName)
			{
				INT iDelPrefixLen = lstrlen(szDELETEPREFIX);
				if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
								   pszValueName, iDelPrefixLen,
								   szDELETEPREFIX, iDelPrefixLen) == CSTR_EQUAL)
				{
					lpValueNameTemp = pszValueName + iDelPrefixLen;
					bDeleted = TRUE;
				}
			}


			// Find the item
			while (lpTemp)
			{
				if (pszKeyName && lpValueNameTemp &&
					lpTemp->lpKeyName && lpTemp->lpValueName)
				{
					if (bDeleted == lpTemp->bDeleted)
					{
						if ((uiPrecedence == 0) || (uiPrecedence == (UINT)lpTemp->uiPrecedence))
						{
							if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp) &&
								!lstrcmpi(lpTemp->lpKeyName, pszKeyName) &&
								bHKCU == lpTemp->bHKCU)
							{
							   break;
							}
						}
					}
				}
				else if (!pszKeyName && lpValueNameTemp &&
						 !lpTemp->lpKeyName && lpTemp->lpValueName)
				{
					if (bDeleted == lpTemp->bDeleted)
					{
						if ((uiPrecedence == 0) || (uiPrecedence == (UINT)lpTemp->uiPrecedence))
						{
							if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp) &&
								bHKCU == lpTemp->bHKCU)
							{
							   break;
							}
						}
					}
				}
				else if (pszKeyName && !lpValueNameTemp &&
						 lpTemp->lpKeyName && !lpTemp->lpValueName)
				{
					if (bDeleted == lpTemp->bDeleted)
					{
						if ((uiPrecedence == 0) || (uiPrecedence == (UINT)lpTemp->uiPrecedence))
						{
							if (!lstrcmpi(lpTemp->lpKeyName, pszKeyName) &&
								bHKCU == lpTemp->bHKCU)
							{
							   break;
							}
						}
					}
				}

				lpTemp = lpTemp->pNext;
			}
		}
		else
		{
			// Read a specific item
			lpTemp = lpItem;
		}

		// Check to see if the item was found
		if (lpTemp)
		{
			// Check if the data will fit in the buffer passed in
			if (lpTemp->dwSize <= dwMaxSize)
			{
				// Copy the data
				if (lpTemp->lpData)
					CopyMemory (pData, lpTemp->lpData, lpTemp->dwSize);

				*pdwType = lpTemp->dwType;

				if (lpGPOName)
					*lpGPOName = lpTemp->lpGPOName;
			}
			else
				iRet = ERROR_NOT_ENOUGH_MEMORY;
		}
		else
			iRet = ERROR_FILE_NOT_FOUND;
	}
	__except(TRUE)
	{
	}
	return iRet;
}

#define MAXSTRLEN		1024

/////////////////////////////////////////////////////////////////////
// Reads the reg settings from WMI for a particular ADM file and stores
// them in a PART array.
/////////////////////////////////////////////////////////////////////
void ReadRegSettingsForADM(LPADMFILE admfile, LPPARTDATA pPartData,
						   BSTR bstrNamespace)
{
	__try
	{
		CRSOPRegData RegData;
		RegData.Initialize(bstrNamespace);

		LPPART part = admfile->pParts;
		for( int i = 0; i < admfile->nParts; i++ )
		{
			BOOL bHKCU = (HKEY_LOCAL_MACHINE == part[i].hkClass) ? FALSE : TRUE;
			BYTE pbData[MAXSTRLEN];
			ZeroMemory(pbData, sizeof(pbData));
			DWORD dwType = REG_NONE;
			LPTSTR lpGPOName = NULL;
			UINT uiRet = RegData.ReadValue(1, bHKCU, part[i].value.szKeyname,
											part[i].value.szValueName, pbData,
											sizeof(pbData), &dwType, &lpGPOName);

			if ( ERROR_SUCCESS == uiRet)
			{
				// store data as numeric or string
				BOOL fNumeric = FALSE;
				DWORD dwValue = 0;
				_bstr_t bstrValue;
				if (REG_SZ != dwType) // Numeric
				{
					fNumeric = TRUE;
					memcpy(&dwValue, pbData, sizeof(dwValue));
				}
				else
				{
					// string data is always stored as wide strings
					if (NULL != pbData)
						bstrValue = (LPWSTR)pbData;
				}

				if (pPartData[i].value.szValue != NULL)
					LocalFree(pPartData[i].value.szValue);
				pPartData[i].value.szValue = NULL;

				if ((part[i].nType == PART_POLICY && part->fRequired) || part[i].nType == PART_CHECKBOX)
				{
					if (fNumeric)
					{
						if (dwValue == (DWORD) part[i].value.nValueOn)
							pPartData[i].value.dwValue = 1;
						else
							pPartData[i].value.dwValue = 0;
					}
					else // String
					{
						if (NULL != part[i].value.szValueOn && NULL != pbData &&
							0 == StrCmp(part[i].value.szValueOn, (LPTSTR)bstrValue))
						{
							pPartData[i].value.dwValue = 1;
						}
						else
							pPartData[i].value.dwValue = 0;

						if (NULL != pbData)
							pPartData[i].value.szValue = StrDup((LPTSTR)bstrValue);
					}
					pPartData[i].value.fNumeric = TRUE;
					pPartData[i].fSave = TRUE;
				}
				else if (part[i].nType == PART_DROPDOWNLIST)
				{
					if (part[i].nSelectedAction != NO_ACTION && part[i].nActions > 0)
					{
						for(int nIndex = 0; nIndex < part[i].nActions; nIndex++)
						{
							if (fNumeric)
							{
								if (part[i].actionlist[nIndex].dwValue == dwValue && part[i].actionlist[nIndex].szName)
								{
									pPartData[i].value.szValue = StrDup(part[i].actionlist[nIndex].szName);
									pPartData[i].nSelectedAction = nIndex;
								}
							}
							else
							{
								if (NULL != part[i].actionlist[nIndex].szValue && NULL != pbData &&
									0 == StrCmp(part[i].actionlist[nIndex].szValue, (LPTSTR)bstrValue) &&
									NULL != part[i].actionlist[nIndex].szName)
								{
									pPartData[i].value.szValue = StrDup(part[i].actionlist[nIndex].szName);
									pPartData[i].nSelectedAction = nIndex;
								}
							}
						}
						pPartData[i].fSave = TRUE;
					}
					pPartData[i].value.fNumeric = FALSE;
				}
				else if (part[i].nType == PART_LISTBOX && fNumeric)
				{
					// Allocate memory
					if (pPartData[i].nActions == 0)
						pPartData[i].actionlist = (LPACTIONLIST) HeapAlloc(GetProcessHeap(),
																			HEAP_ZERO_MEMORY, sizeof(ACTIONLIST));

					if (pPartData[i].actionlist != NULL)
					{
						if (0 == pPartData[i].nActions)
						{
							pPartData[i].nActions = 1;
							pPartData[i].actionlist[0].value = (LPVALUE) HeapAlloc(GetProcessHeap(),
																					HEAP_ZERO_MEMORY, sizeof(VALUE));
						}

						if (pPartData[i].actionlist[0].value != NULL)
						{
							TCHAR szValueName[10];
							int nItems = pPartData[i].actionlist[0].nValues;
							if (0 != nItems)
							{
								LPVOID lpTemp = (LPVALUE) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
																		pPartData[i].actionlist[0].value,
																		sizeof(VALUE) * (nItems + 1));
								if (lpTemp != NULL)
									pPartData[i].actionlist[0].value = (LPVALUE)lpTemp;
								else
									continue;
							}

							if (part[i].value.szKeyname != NULL)
								pPartData[i].actionlist[0].value[nItems].szKeyname = StrDup(part[i].value.szKeyname);

							wnsprintf(szValueName, ARRAYSIZE(szValueName), TEXT("%d"), nItems + 1);
							pPartData[i].actionlist[0].value[nItems].szValueName = StrDup(szValueName);

							if (NULL != pbData)
								pPartData[i].actionlist[0].value[nItems].szValue = StrDup((LPTSTR)bstrValue);
							pPartData[i].actionlist[0].nValues++;
							pPartData[i].value.fNumeric = TRUE;
							pPartData[i].value.dwValue = 1;
							pPartData[i].fSave = TRUE;
						}
					}
				}
				else
				{
					if (NULL != pbData)
						pPartData[i].value.szValue = StrDup((LPTSTR)bstrValue);
					pPartData[i].value.dwValue = dwValue;
					pPartData[i].value.fNumeric = fNumeric;
					pPartData[i].fSave = TRUE;
				}
			}
		} // end for
	}
	__except(TRUE)
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\parser\rsop.h ===
#ifndef __PARSER_RSOP_H__
#define __PARSER_RSOP_H__

/////////////////////////////////////////////////////////////////////
typedef struct tagRSOPREGITEM {
	BOOL	bHKCU;
    LPTSTR  lpKeyName;
    LPTSTR  lpValueName;
    LPTSTR  lpGPOName;
    DWORD   dwType;
    DWORD   dwSize;
    LPBYTE  lpData;
    BOOL    bFoundInADM;
    UINT    uiPrecedence;
    BOOL    bDeleted;
    struct tagRSOPREGITEM * pNext;
} RSOPREGITEM, *LPRSOPREGITEM;

/////////////////////////////////////////////////////////////////////
class CRSOPRegData
{
public:
	CRSOPRegData();
	~CRSOPRegData();

// operations
public:
	HRESULT Initialize(BSTR bstrNamespace);
	UINT ReadValue(UINT uiPrecedence, BOOL bHKCU, LPTSTR pszKeyName,
					LPTSTR pszValueName, LPBYTE pData,
					DWORD dwMaxSize, DWORD *pdwType,
					LPTSTR *lpGPOName, LPRSOPREGITEM lpItem = NULL);

private:
	BOOL AddNode(BOOL bHKCU, LPTSTR lpKeyName, LPTSTR lpValueName,
					DWORD dwType, DWORD dwDataSize,
					LPBYTE lpData, UINT uiPrecedence,
					LPTSTR lpGPOName, BOOL bDeleted);
	HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
								LPTSTR lpGPOID, BSTR pLanguage, LPTSTR *pGPOName);
	void Free();

// implementation
protected:
	LPRSOPREGITEM m_pData;
};


#endif //__PARSER_RSOP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\update\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_
//
// PRECOMP.H
//
/////////////////////////////////////////////////////////////////////////
//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  ShellExecuteExWrapW when you expected to see
//  ShellExecuteExW.
//
#include <w95wraps.h>

#include <windows.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>

#include <iedkbrnd.h>
#include "..\ieakutil\ieakutil.h"

#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\adjustui.h ===
#ifndef _ADJUSTUI_H_
#define _ADJUSTUI_H_

#define CTRL_BITMAP     1
#define CTRL_TEXT       2

typedef struct tagSTATICCTRL {
    UINT  nCtrlType;
    union {
        UINT   nID;
        LPCTSTR lpcszStr;
    };
    UINT  nCtrlID;
    DWORD dwStyle;
    RECT  rect;
} STATICCTRL;
typedef STATICCTRL*       PSTATICCTRL;
typedef const STATICCTRL* PCSTATICCTRL;

typedef struct tagMODIFYDLGTEMPLATE {
    HINSTANCE        hinst;
    DWORD            dwStyle;
    SIZE             sizeCtrlsOffset;
    STATICCTRL       scBmpCtrl;
    STATICCTRL       scTextCtrl;
} MODIFYDLGTEMPLATE;
typedef MODIFYDLGTEMPLATE*       PMODIFYDLGTEMPLATE;
typedef const MODIFYDLGTEMPLATE* PCMODIFYDLGTEMPLATE;

HRESULT      PrepareDlgTemplate(PCMODIFYDLGTEMPLATE pmdt, LPCVOID pvDlg, PVOID *ppvDT, LPDWORD pcbDlg);
HRESULT      SetDlgTemplateFont(HINSTANCE hInst, UINT nDlgID, const LOGFONT *plf, PVOID *ppvDT);
BOOL         IsTahomaFontExist(HWND hWnd);
int CALLBACK PropSheetProc(HWND hDlg, UINT uMsg, LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\update\resource.h ===
#define IDD_WAIT                    1

#define IDC_DRUMICON                10
#define IDC_ANIM                    11
#define IDA_DOWNLOAD                12

#define IDS_TITLE                   100
#define IDS_RESTARTYESNO            101
#define IDD_CONFIRM                     102
#define IDS_ICP                         102
#define IDS_ISP                         103
#define IDS_CORP                        104
#define IDC_ICP                         113
#define IDC_ISP                         114
#define IDC_INTRA                       115
#define IDD_CHOOSETYPE                  116
#define IDC_STATICLICENSE               1000

#define IDC_STATIC                  -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\adjustui.cpp ===
#include "precomp.h"
#include "adjustui.h"

#pragma warning(disable: 4244)                  // disable loss of data warning since we do so
                                                // much casting in this file
#pragma pack(push, 2)
typedef struct tagDLGTEMPLATEEX {
    WORD   dlgVer;
    WORD   signature;
    DWORD  helpID;
    DWORD  exStyle;
    DWORD  style;
    WORD   cDlgItems;
    short  x;
    short  y;
    short  cx;
    short  cy;
} DLGTEMPLATEEX, *PDLGTEMPLATEEX;
typedef const DLGTEMPLATEEX* PCDLGTEMPLATEEX;

typedef struct {
    DWORD  helpID;
    DWORD  exStyle;
    DWORD  style;
    short  x;
    short  y;
    short  cx;
    short  cy;
    WORD   id;
    WORD   reserved;
} DLGITEMTEMPLATEEX, *PDLGITEMTEMPLATEEX;
typedef const DLGITEMTEMPLATEEX* PCDLGITEMTEMPLATEEX;
#pragma pack(pop)

// globals for banner
HBITMAP g_hBannerBmp = NULL;
HFONT   g_hFont = NULL;

static HWND    s_hBannerWnd = NULL;
static WNDPROC s_lpfnBannerTextCtrlProc = NULL;
static HWND    s_hBannerText = NULL;
TCHAR   s_szBannerText[MAX_PATH];
static WNDPROC s_lpfnPSWndProc = NULL;


// PrepareDlgTemplate and ChangeDlgTemplateFont helpers
BOOL    getBitmapDimensions(HINSTANCE hinstBmp, UINT nID, PSIZE psizeBmp);
BOOL    mapPixelsToDlgUnits(const LOGFONT *plf, PSIZE psize);
BOOL    createStaticControl(PCSTATICCTRL pCtrl, BOOL fEx, PVOID *ppvDIT, PDWORD pcbDIT);
HRESULT getDlgTemplateSize(LPCVOID pvDlg, LPDWORD pcbDlg);
BOOL    loadDialogTemplate (HINSTANCE hinstDlg, UINT nID, PVOID *ppvDT, PDWORD pcbDT);

PBYTE skipDlgString(PBYTE pb);
PBYTE alignDWORD(PBYTE pb);

// IsTahomaFontExist helpers
int CALLBACK enumFontFamExProc(ENUMLOGFONTEX *, NEWTEXTMETRICEX *, int, LPARAM lParam);

// PropSheetProc helpers
void initializeBannerTextCtrlFont(HWND hWnd, INT nId);
BOOL CALLBACK bannerTextCtrlProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void paintBmpInHdcRect(HBITMAP hBmp, HDC hDC, RECT rect);
void handleEraseBkgndMsg(HWND hDlg, HDC hDC);
BOOL CALLBACK propertySheetWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);



HRESULT PrepareDlgTemplate(PCMODIFYDLGTEMPLATE pmdt, LPCVOID pvDlg, PVOID *ppvDT, LPDWORD pcbDlg)
{
    LOGFONT            lf;
    SIZE               sizeBmpOffset;
    PCDLGTEMPLATEEX    pdt2;
    LPCDLGTEMPLATE     pdt;                     // for some weird reason there is no PCDLGTEMPLATE
    PDLGITEMTEMPLATEEX pdit2;
    PDLGITEMTEMPLATE   pdit;
    PBYTE              pb;
    HRESULT            hr;
    DWORD              cbDlg;
    WORD               cDlgItems,
                       cbCreateParams;
    BOOL               fEx,
                       fResult;

    USES_CONVERSION;

    //----- Initialization and parameter validation -----
    if (pmdt == NULL)
        return E_INVALIDARG;

    if (pmdt->hinst == NULL)
        return E_INVALIDARG;

    if (pmdt->scBmpCtrl.nCtrlType == CTRL_BITMAP && pmdt->scBmpCtrl.nID == 0)
        return E_INVALIDARG;

    if (pvDlg == NULL)
        return E_INVALIDARG;

    if (ppvDT == NULL)
        return E_POINTER;
    *ppvDT = NULL;

    if (pcbDlg == NULL)
        return E_INVALIDARG;
    *pcbDlg = 0;

    hr = getDlgTemplateSize(pvDlg, &cbDlg);
    if (FAILED(hr))
        return hr;

    ZeroMemory(&lf, sizeof(lf));

    //----- Resource allocation -----
    *ppvDT = CoTaskMemAlloc(cbDlg * 2);
    if (*ppvDT == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppvDT, cbDlg * 2);
    hr = S_OK;

    //----- Parse through Dialog Template -----
    UINT nStyleOffset, nDlgItemsOffset,
         nWidthOffset, nHeightOffset;

    pdt  = NULL;
    pdt2 = (PCDLGTEMPLATEEX)pvDlg;              // assume extended style

    if (pdt2->signature == 0xFFFF) {
        if (pdt2->dlgVer != 1)
            return E_UNEXPECTED;                // Chicago sanity check

        nStyleOffset    = (PBYTE)&pdt2->style     - (PBYTE)pdt2;
        nDlgItemsOffset = (PBYTE)&pdt2->cDlgItems - (PBYTE)pdt2;
        nWidthOffset    = (PBYTE)&pdt2->cx        - (PBYTE)pdt2;
        nHeightOffset   = (PBYTE)&pdt2->cy        - (PBYTE)pdt2;

        pb  = (PBYTE)(pdt2 + 1);
        fEx = TRUE;
    }
    else {
        pdt  = (LPCDLGTEMPLATE)pvDlg;
        pdt2 = NULL;

        nStyleOffset    = (PBYTE)&pdt->style - (PBYTE)pdt;
        nDlgItemsOffset = (PBYTE)&pdt->cdit  - (PBYTE)pdt;
        nWidthOffset    = (PBYTE)&pdt->cx    - (PBYTE)pdt;
        nHeightOffset   = (PBYTE)&pdt->cy    - (PBYTE)pdt;

        pb  = (PBYTE)(pdt + 1);
        fEx = FALSE;
    }

    // skip over menu, window class and window text
    pb = skipDlgString(pb);
    pb = skipDlgString(pb);
    pb = skipDlgString(pb);

    // skip over font info: point size and typeface name
    if (((*(PDWORD)((PBYTE)pvDlg + nStyleOffset)) & DS_SETFONT) != 0) {
        if (fEx) {
            lf.lfHeight =       *(PWORD)pb; pb += sizeof(WORD);
            lf.lfWeight =       *(PWORD)pb; pb += sizeof(WORD);
            lf.lfItalic = (BYTE)*(PWORD)pb; pb += sizeof(WORD);
        }
        else {
            lf.lfHeight = *(PWORD)pb; pb += sizeof(WORD);
        }

        StrCpyN(lf.lfFaceName, W2CT((LPCWSTR)pb), LF_FACESIZE);
        pb = skipDlgString(pb);
    }

    // finally, adjust to DWORD boundary
    pb = alignDWORD(pb);

    //----- Make new sence out of Dialog Template -----
    SIZE  sizeIncrease;
    DWORD cbDlgTemplate;

    cbDlgTemplate = pb - (PBYTE)pvDlg;
    CopyMemory(*ppvDT, pvDlg, cbDlgTemplate);

    fResult = getBitmapDimensions(pmdt->hinst, pmdt->scBmpCtrl.nID, &sizeBmpOffset);
    if (!fResult) {
        hr = E_FAIL;
        goto Exit;
    }

    // ok, they are in dialog units now, kinda, really ;-)
    fResult = mapPixelsToDlgUnits(&lf, &sizeBmpOffset);
    if (!fResult) {
        hr = E_FAIL;
        goto Exit;
    }

    sizeIncrease.cx = sizeIncrease.cy = 0;
    if (pmdt->sizeCtrlsOffset.cx != 0)
        sizeIncrease.cx  = pmdt->scBmpCtrl.rect.left + sizeBmpOffset.cx + pmdt->sizeCtrlsOffset.cx;

    if (pmdt->sizeCtrlsOffset.cy != 0)
        sizeIncrease.cy  = pmdt->scBmpCtrl.rect.top + sizeBmpOffset.cy + pmdt->sizeCtrlsOffset.cy;

    *(PWORD)((PBYTE)*ppvDT + nDlgItemsOffset) += 2;
    *(PWORD)((PBYTE)*ppvDT + nWidthOffset)    += (WORD)sizeIncrease.cx;
    *(PWORD)((PBYTE)*ppvDT + nHeightOffset)   += (WORD)sizeIncrease.cy;

    //----- Add control with the bitmap -----
    PVOID pvCtrl;
    DWORD cbCtrl;
    DWORD cbCtrlsOffset;

    fResult = createStaticControl(&pmdt->scBmpCtrl, fEx, &pvCtrl, &cbCtrl);
    if (!fResult) {
        hr = E_FAIL;
        goto Exit;
    }

    CopyMemory((PBYTE)*ppvDT + cbDlgTemplate, pvCtrl, cbCtrl);
    cbCtrlsOffset = cbCtrl;

    ASSERT(pvCtrl != NULL);
    CoTaskMemFree(pvCtrl);

    //----- Add static text control -----
    STATICCTRL scTextCtrl;

    scTextCtrl = pmdt->scTextCtrl;
    scTextCtrl.rect.left   = 7;
    scTextCtrl.rect.top    = (sizeBmpOffset.cy / 2) - 11;
    scTextCtrl.rect.right  = sizeBmpOffset.cx - 7;
    scTextCtrl.rect.bottom = scTextCtrl.rect.top + 18;

    fResult = createStaticControl(&scTextCtrl, fEx, &pvCtrl, &cbCtrl);
    if (!fResult) {
        hr = E_FAIL;
        goto Exit;
    }

    CopyMemory((PBYTE)*ppvDT + cbDlgTemplate + cbCtrlsOffset, pvCtrl, cbCtrl);
    cbCtrlsOffset += cbCtrl;

    ASSERT(pvCtrl != NULL);
    CoTaskMemFree(pvCtrl);

    //----- Parse through Dialog Item Templates -----
    cDlgItems = *(PWORD)((PBYTE)pvDlg + nDlgItemsOffset);
    if (cDlgItems > 0) {
    	ASSERT(cbDlg > cbDlgTemplate);
        CopyMemory((PBYTE)*ppvDT + cbDlgTemplate + cbCtrlsOffset, pb, cbDlg - cbDlgTemplate);
        pb = (PBYTE)*ppvDT + cbDlgTemplate + cbCtrlsOffset;

        while (cDlgItems-- > 0) {
            pdit = NULL; pdit2 = NULL;
            if (fEx) {
                pdit2 = (PDLGITEMTEMPLATEEX)pb;

                if (pmdt->sizeCtrlsOffset.cx != 0)
                    pdit2->x += (WORD)sizeIncrease.cx;

                if (pmdt->sizeCtrlsOffset.cy != 0)
                    pdit2->y += (WORD)sizeIncrease.cy;
            }
            else {
                pdit = (PDLGITEMTEMPLATE)pb;

                if (pmdt->sizeCtrlsOffset.cx != 0)
                    pdit->x += (WORD)sizeIncrease.cx;

                if (pmdt->sizeCtrlsOffset.cy != 0)
                    pdit->y += (WORD)sizeIncrease.cy;
            }

            pb += fEx ? sizeof(DLGITEMTEMPLATEEX) : sizeof(DLGITEMTEMPLATE);

            // skip over window class and window text
            pb = skipDlgString(pb);
            pb = skipDlgString(pb);

            // skip create parameters
            cbCreateParams = *((PWORD)pb);
            if (fEx)
                pb += sizeof(WORD) + cbCreateParams;
            else
                pb += cbCreateParams > 0 ? cbCreateParams : sizeof(WORD);

            // point at the next dialog item
            pb = alignDWORD(pb);
        }
    }

    *pcbDlg = cbDlg + cbCtrlsOffset;

Exit:
    if (FAILED(hr)) {
        CoTaskMemFree(*ppvDT);
        *ppvDT = NULL;
    }

    return hr;
}

HRESULT SetDlgTemplateFont(HINSTANCE hInst, UINT nDlgID, const LOGFONT *plf, PVOID *ppvDT)
{
    PCDLGTEMPLATEEX    pdt2;
    LPCDLGTEMPLATE     pdt;                     // for some weird reason there is no PCDLGTEMPLATE
    PBYTE              pb;
    HRESULT            hr;
    PVOID              pvDlg;
    DWORD              cbDlg;
    BOOL               fEx,
                       fResult;

    USES_CONVERSION;

    //----- Initialization and parameter validation -----
    if (plf == NULL || *plf->lfFaceName == TEXT('\0'))
        return E_INVALIDARG;

    if (plf->lfHeight == 0)
        return E_INVALIDARG;

    if (ppvDT == NULL)
        return E_POINTER;
    *ppvDT = NULL;

    //----- Resource allocation -----
    fResult = loadDialogTemplate(hInst, nDlgID, &pvDlg, &cbDlg);
    if (!fResult)
        return E_FAIL;

    *ppvDT = CoTaskMemAlloc(cbDlg * 2);
    if (*ppvDT == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppvDT, cbDlg * 2);
    hr = S_OK;

    //----- Parse through Dialog Template -----
    PBYTE pbDest;
    DWORD cbSize;
    UINT  nStyleOffset;

    pdt  = NULL;
    pdt2 = (PCDLGTEMPLATEEX)pvDlg;              // assume extended style

    if (pdt2->signature == 0xFFFF) {
        if (pdt2->dlgVer != 1)
            return E_UNEXPECTED;                // Chicago sanity check

        nStyleOffset = (PBYTE)&pdt2->style - (PBYTE)pdt2;

        pb  = (PBYTE)(pdt2 + 1);
        fEx = TRUE;
    }
    else {
        pdt  = (LPCDLGTEMPLATE)pvDlg;
        pdt2 = NULL;

        nStyleOffset = (PBYTE)&pdt->style - (PBYTE)pdt;

        pb  = (PBYTE)(pdt + 1);
        fEx = FALSE;
    }

    // skip over menu, window class and window text
    pb = skipDlgString(pb);
    pb = skipDlgString(pb);
    pb = skipDlgString(pb);

    cbSize = pb - (PBYTE)pvDlg;
    CopyMemory(*ppvDT, pvDlg, cbSize);
    pbDest = (PBYTE)*ppvDT + cbSize;

    // change font info: point size and typeface name
    if (((*(PDWORD)((PBYTE)pvDlg + nStyleOffset)) & DS_SETFONT) != 0) {
        UINT nLen;

        if (fEx) {
            *(PWORD)pbDest = (int)plf->lfHeight;
            pb     += 3 * sizeof(WORD);
            pbDest += 3 * sizeof(WORD);
        }
        else {
            *(PWORD)pbDest = (int)plf->lfHeight;
            pb     += sizeof(WORD);
            pbDest += sizeof(WORD);
        }

        nLen = StrLen(plf->lfFaceName);

        CopyMemory(pbDest, T2CW(plf->lfFaceName), (nLen + 1)*sizeof(WCHAR));

        pb      = skipDlgString(pb);            // don't know the length of the old font
        //pbDest += (nLen + 1) * sizeof(WCHAR);   // know the length of the new font already
        pbDest = skipDlgString(pbDest);
    }

    // finally, adjust to DWORD boundary
    pb     = alignDWORD(pb);
    pbDest = alignDWORD(pbDest);

    // copy rest of the template
    CopyMemory(pbDest, pb, cbDlg - (pb - (PBYTE)pvDlg));

    return hr;
}

BOOL IsTahomaFontExist(HWND hWnd)
{
    static  fFontExist   = FALSE;
    static  fFontChecked = FALSE;
    LOGFONT lf;
    HDC     hDC;

    if (!fFontChecked)
    {
        hDC = GetDC(hWnd);
        ZeroMemory(&lf, sizeof(lf));
        lf.lfCharSet = DEFAULT_CHARSET;
        StrCpy(lf.lfFaceName, TEXT("Tahoma"));
        EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)enumFontFamExProc, (LPARAM)&fFontExist, 0);
        ReleaseDC(hWnd, hDC);
        fFontChecked = TRUE;
    }
    return fFontExist;
}

int CALLBACK PropSheetProc(HWND hDlg, UINT uMsg, LPARAM lParam)
{
    MODIFYDLGTEMPLATE mdt;
    LPVOID            pvDlg;
    DWORD             cbDlg;

    if (uMsg == PSCB_PRECREATE)
    {
        ZeroMemory(&mdt, sizeof(mdt));

        mdt.hinst              = g_rvInfo.hInst;
        mdt.sizeCtrlsOffset.cy = -9;

        // bitmap control parameters
        mdt.scBmpCtrl.nCtrlType  = CTRL_BITMAP;
        mdt.scBmpCtrl.nID        = IDB_WIZARD;
        mdt.scBmpCtrl.nCtrlID    = IDC_BANNERBMPCTRL;

        // text control parameters
        mdt.scTextCtrl.nCtrlType = CTRL_TEXT;
        mdt.scTextCtrl.nCtrlID   = IDC_BANNERTXTCTRL;

        if (FAILED(PrepareDlgTemplate(&mdt, (LPCVOID)lParam, &pvDlg, &cbDlg)))
            return 1;

        // replace the old template
        CopyMemory((LPVOID)lParam, pvDlg, cbDlg);
        CoTaskMemFree(pvDlg);

        // take out the context help button

        if( lParam )
        {
            DLGTEMPLATE *pDlgTemplate;
            DLGTEMPLATEEX *pDlgTemplateEx;

            pDlgTemplateEx = (DLGTEMPLATEEX *)lParam;
            if (pDlgTemplateEx->signature == 0xFFFF)
            {
                if (pDlgTemplateEx->dlgVer == 1)
                    pDlgTemplateEx->style &= ~DS_CONTEXTHELP;
            }
            else
            {
                pDlgTemplate = (DLGTEMPLATE *)lParam;
                pDlgTemplate->style &= ~DS_CONTEXTHELP;
            }
        }
    }
    else if (uMsg == PSCB_INITIALIZED)
    {
        // BUGBUG: (a-saship) for some reason the bitmap is not loaded within the static control,
        // hence force it to display the bitmap.
        s_hBannerWnd = GetDlgItem(hDlg, IDC_BANNERBMPCTRL);
        if (s_hBannerWnd)
        {
            g_hBannerBmp = LoadBitmap(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_WIZARD));
            if (g_hBannerBmp)
                SendMessage(s_hBannerWnd, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) g_hBannerBmp);
        }

        // initialize the text control to set the required font style and subclass it
        // so that it paints itself.
        s_hBannerText = GetDlgItem(hDlg, IDC_BANNERTXTCTRL);
        if (s_hBannerText)
        {
            initializeBannerTextCtrlFont(hDlg, IDC_BANNERTXTCTRL);
            //subclass the text control
            if(s_lpfnBannerTextCtrlProc == NULL)
                s_lpfnBannerTextCtrlProc = (WNDPROC)GetWindowLongPtr(s_hBannerText, GWLP_WNDPROC);
            SetWindowLongPtr(s_hBannerText, GWLP_WNDPROC, (LONG_PTR)bannerTextCtrlProc);
        }

        // subclass propertysheet window to draw the border and bitmap
        if(s_lpfnPSWndProc == NULL)
            s_lpfnPSWndProc = (WNDPROC)GetWindowLongPtr(hDlg, GWLP_WNDPROC);
        SetWindowLongPtr(hDlg, GWLP_WNDPROC, (LONG_PTR)propertySheetWndProc);
    }
    return 0;
}

void SetBannerText(HWND hDlg)
{
    GetWindowText(hDlg, s_szBannerText, countof(s_szBannerText));
    InvalidateRect(s_hBannerWnd, NULL, TRUE);
    InvalidateRect(s_hBannerText, NULL, TRUE);
}


void ChangeBannerText(HWND hDlg)
{
    SetWindowText(hDlg, s_szBannerText);
    InvalidateRect(s_hBannerWnd, NULL, TRUE);
    InvalidateRect(s_hBannerText, NULL, TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

//----- PrepareDlgTemplate and ChangeDlgTemplateFont helpers -----

BOOL getBitmapDimensions(HINSTANCE hinstBmp, UINT nID, PSIZE psizeBmp)
{
    BITMAP  bm;
    HBITMAP hbmp;
    int     iResult;

    if (hinstBmp == NULL)
        return FALSE;

    if (psizeBmp == NULL)
        return FALSE;
    psizeBmp->cx = psizeBmp->cy = 0;

    hbmp = (HBITMAP)LoadImage(hinstBmp, MAKEINTRESOURCE(nID), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR | LR_SHARED);
    if (hbmp == NULL)
        return FALSE;

    iResult = GetObject(hbmp, sizeof(bm), &bm);
    DeleteObject(hbmp);

    if (iResult == 0)
        return FALSE;

    psizeBmp->cx = bm.bmWidth;
    psizeBmp->cy = bm.bmHeight;
    return TRUE;
}

// BUGBUG: (andrewgu) Big, big bummer!
// the limitation to this whole approach is that there is no easy way to convert pixels into
// dlg units of not yet existent dialog. i looked at the code in user32 and there is way too
// much stuff to try to duplicate here. for now i'm going to use rude and cruel method of
// multipling it by 2/3 which is good enough for english systems (no matter big fonts or not).
// will see if international or accessibility folks complain.
BOOL mapPixelsToDlgUnits(const LOGFONT *plf, PSIZE psize)
{
    if (plf == NULL)
        return FALSE;

    if (psize == NULL)
        return FALSE;

    psize->cx = MulDiv(psize->cx, 2, 3);
    psize->cy = MulDiv(psize->cy, 2, 3);

    return TRUE;
}

BOOL createStaticControl(PCSTATICCTRL pCtrl, BOOL fEx, PVOID *ppvDIT, PDWORD pcbDIT)
{
    PDLGITEMTEMPLATEEX pdit2;
    PDLGITEMTEMPLATE   pdit;
    DWORD              dwStyle,
                       cbCtrl;
    PBYTE              pb;

    if (pCtrl == NULL)
        return FALSE;

    if ((pCtrl->nCtrlType != CTRL_BITMAP && pCtrl->nCtrlType != CTRL_TEXT) ||
        (pCtrl->nCtrlType == CTRL_BITMAP && pCtrl->nID == 0))
        return FALSE;

    if (ppvDIT == NULL)
        return FALSE;
    *ppvDIT = NULL;

    if (pcbDIT == NULL)
        return FALSE;
    *pcbDIT = 0;

    // REVIEW: (andrewgu) 4 * sizeof(DWORD) is for the extra stuff
    cbCtrl  = sizeof(DLGITEMTEMPLATEEX) + 4 * sizeof(DWORD);
    dwStyle = pCtrl->dwStyle;
    if (dwStyle == 0)
        dwStyle = WS_VISIBLE | WS_CHILD | WS_GROUP;

    if (pCtrl->nCtrlType == CTRL_BITMAP)
        dwStyle |= SS_BITMAP;
    else if (pCtrl->nCtrlType == CTRL_TEXT)
        dwStyle |= SS_LEFT;

    *ppvDIT = CoTaskMemAlloc(cbCtrl);
    if (*ppvDIT == NULL)
        return FALSE;
    ZeroMemory(*ppvDIT, cbCtrl);

    pdit = NULL; pdit2 = NULL;
    if (fEx) {
        pdit2 = (PDLGITEMTEMPLATEEX)*ppvDIT;

        pdit2->helpID  = 0xFFFFFFFF;
        pdit2->exStyle = 0;
        pdit2->style   = dwStyle;
        pdit2->x       = (short)pCtrl->rect.left;
        pdit2->y       = (short)pCtrl->rect.top;
        pdit2->cx      = (short)(pCtrl->rect.right - pCtrl->rect.left);
        pdit2->cy      = (short)(pCtrl->rect.bottom - pCtrl->rect.top);
        pdit2->id      = (short)pCtrl->nCtrlID;

        pb = (PBYTE)*ppvDIT + sizeof(DLGITEMTEMPLATEEX);
    }
    else {
        pdit = (PDLGITEMTEMPLATE)*ppvDIT;

        pdit->style           = dwStyle;
        pdit->dwExtendedStyle = 0;
        pdit->x               = (short)pCtrl->rect.left;
        pdit->y               = (short)pCtrl->rect.top;
        pdit->cx              = (short)(pCtrl->rect.right - pCtrl->rect.left);
        pdit->cy              = (short)(pCtrl->rect.bottom - pCtrl->rect.top);
        pdit->id              = (short)pCtrl->nCtrlID;

        pb = (PBYTE)*ppvDIT + sizeof(DLGITEMTEMPLATE);
    }

    // class
    *(PWORD)pb = 0xFFFF;
    pb += sizeof(WORD);
    *(PWORD)pb = 0x0082;                        // static
    pb += sizeof(WORD);

    // window text
    if(pCtrl->nCtrlType == CTRL_BITMAP) {
        *(PWORD)pb = 0xFFFF;
        pb += sizeof(WORD);

        *(PWORD)pb = (WORD)pCtrl->nID;
        pb += sizeof(WORD);
    }
    else
        // skip over one WORD, it's zero initialized already
        pb += sizeof(WORD);

    // empty create parameters
    pb += sizeof(WORD);
    pb = alignDWORD(pb);

    *pcbDIT = (UINT)(pb - (PBYTE)*ppvDIT);
    return TRUE;
}

HRESULT getDlgTemplateSize(LPCVOID pvDlg, LPDWORD pcbDlg)
{
    PCDLGTEMPLATEEX pdt2;
    LPCDLGTEMPLATE  pdt;                        // for some weird reason there is no PCDLGTEMPLATE
    PBYTE           pb;
    WORD            cDlgItems,
                    cbCreateParams;
    BOOL            fEx;

    //----- Initialization and parameter validation -----
    if (pvDlg == NULL)
        return E_INVALIDARG;

    if (pcbDlg == NULL)
        return E_INVALIDARG;
    *pcbDlg = 0;

    //----- Parse through Dialog Template -----
    UINT nStyleOffset, nDlgItemsOffset;

    pdt  = NULL;
    pdt2 = (PCDLGTEMPLATEEX)pvDlg;              // assume extended style

    if (pdt2->signature == 0xFFFF) {
        if (pdt2->dlgVer != 1)
            return E_UNEXPECTED;                // Chicago sanity check

        nStyleOffset    = (PBYTE)&pdt2->style     - (PBYTE)pdt2;
        nDlgItemsOffset = (PBYTE)&pdt2->cDlgItems - (PBYTE)pdt2;

        pb  = (PBYTE)(pdt2 + 1);
        fEx = TRUE;
    }
    else {
        pdt  = (LPCDLGTEMPLATE)pvDlg;
        pdt2 = NULL;

        nStyleOffset    = (PBYTE)&pdt->style - (PBYTE)pdt;
        nDlgItemsOffset = (PBYTE)&pdt->cdit  - (PBYTE)pdt;

        pb  = (PBYTE)(pdt + 1);
        fEx = FALSE;
    }

    // skip over menu, window class and window text
    pb = skipDlgString(pb);
    pb = skipDlgString(pb);
    pb = skipDlgString(pb);

    // skip over font info: point size and typeface name
    if (((*(PDWORD)((PBYTE)pvDlg + nStyleOffset)) & DS_SETFONT) != 0) {
        pb += fEx ? sizeof(WORD) * 3 : sizeof(WORD);
        pb  = skipDlgString(pb);
    }

    // finally, adjust to DWORD boundary
    pb = alignDWORD(pb);

    //----- Parse through Dialog Item Templates -----
    cDlgItems = *(PWORD)((PBYTE)pvDlg + nDlgItemsOffset);
    if (cDlgItems > 0) {
        while (cDlgItems-- > 0) {
            pb += fEx ? sizeof(DLGITEMTEMPLATEEX) : sizeof(DLGITEMTEMPLATE);

            // skip over window class and window text
            pb = skipDlgString(pb);
            pb = skipDlgString(pb);

            // skip create parameters
            cbCreateParams = *((PWORD)pb);
            if (fEx)
                pb += sizeof(WORD) + cbCreateParams;
            else
                pb += cbCreateParams > 0 ? cbCreateParams : sizeof(WORD);

            // point at the next dialog item
            pb = alignDWORD(pb);
        }
    }

    *pcbDlg = pb - (PBYTE)pvDlg;
    return S_OK;
}

BOOL loadDialogTemplate(HINSTANCE hinstDlg, UINT nID, PVOID *ppvDT, PDWORD pcbDT)
{
    PVOID  p;
    HANDLE h;

    if (hinstDlg == NULL)
        return FALSE;

    if (ppvDT == NULL)
        return FALSE;
    *ppvDT = NULL;

    if (pcbDT == NULL)
        return FALSE;
    *pcbDT = 0;

    h = FindResource(hinstDlg, MAKEINTRESOURCE(nID), RT_DIALOG);
    if (h == NULL)
        return FALSE;

    *pcbDT = SizeofResource(hinstDlg, (HRSRC)h);
    if (*pcbDT == 0)
        return FALSE;

    h = LoadResource(hinstDlg, (HRSRC)h);
    if (h == NULL)
        return FALSE;

    p = LockResource(h);
    if (p == NULL)
        return FALSE;

    *ppvDT = p;
    return TRUE;
}


inline PBYTE skipDlgString(PBYTE pb)
{
    PWCHAR pwch;

    if (*((PWORD)pb) == 0xFFFF)
        return (pb + sizeof(DWORD));

    pwch = (PWCHAR)pb;
    while (*pwch++ != L'\0')
        ;

    return (PBYTE)pwch;
}

inline PBYTE alignDWORD(PBYTE pb)
{
    return (PBYTE)(((UINT_PTR)pb + 3) & ~((UINT_PTR)3));
}


//----- IsTahomaFontExist helpers -----

int CALLBACK enumFontFamExProc(ENUMLOGFONTEX *, NEWTEXTMETRICEX *, int, LPARAM lParam)
{
    (*(LPBOOL)lParam) = TRUE;
    return 0;
}


//----- PropSheetProc helpers -----

void initializeBannerTextCtrlFont(HWND hWnd, INT nId)
{
    NONCLIENTMETRICS ncm = {0};
    TCHAR szFontSize[24];
    INT   nBigFontSize = 0;
    LOGFONT BigBoldLogFont;
    BOOL fUpdateFont = TRUE;

    ZeroMemory(&BigBoldLogFont, sizeof(BigBoldLogFont));

    ncm.cbSize = sizeof(ncm);
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
    {
        BigBoldLogFont  = ncm.lfMessageFont;
        fUpdateFont = FALSE;
    }

    BigBoldLogFont.lfWeight = FW_NORMAL;
    if (!LoadString(g_rvInfo.hInst, IDS_BANNERFONT, BigBoldLogFont.lfFaceName, LF_FACESIZE))
        StrCpy(BigBoldLogFont.lfFaceName, TEXT("Verdana"));

    if (LoadString(g_rvInfo.hInst, IDS_BANNERFONTSIZE, szFontSize, countof(szFontSize)))
        nBigFontSize = StrToInt(szFontSize);
    if (nBigFontSize < 18)
        nBigFontSize = 18;

    HDC hdc = GetDC(hWnd);
    if (hdc != NULL)
    {
        int dyLogPixPerInch = GetDeviceCaps(hdc, LOGPIXELSY);

        BigBoldLogFont.lfHeight = -MulDiv(dyLogPixPerInch, nBigFontSize, 72);

        if (fUpdateFont)
        {
            TEXTMETRIC tm;

            GetTextMetrics(hdc, &tm); // get the current textmetrics
            BigBoldLogFont.lfCharSet = tm.tmCharSet;
        }

        g_hFont = CreateFontIndirect(&BigBoldLogFont);
        ReleaseDC(hWnd, hdc);

        if (g_hFont != NULL)
        {
            HWND hControl = GetDlgItem(hWnd, nId);

            if (hControl)
                SendMessage(hControl, WM_SETFONT, (WPARAM)g_hFont, 0);
        }
    }
}

BOOL CALLBACK bannerTextCtrlProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_PAINT)
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);

        int iBkModeOld = SetBkMode(hdc, TRANSPARENT);

        HFONT hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0);
        HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);

        COLORREF rgbSav = SetTextColor(hdc, RGB(0xff, 0xff, 0xff));
        RECT  rect;

        GetClientRect(hWnd, &rect);
        DrawText(hdc, s_szBannerText, -1, &rect, DT_WORDBREAK | DT_LEFT);

        SetTextColor(hdc, rgbSav);
        SelectObject(hdc, hfontOld);
        SetBkMode(hdc, iBkModeOld);
        EndPaint(hWnd, &ps);

        return (FALSE);
    }

    if (uMsg == WM_ERASEBKGND)
        return (FALSE);

    return (CallWindowProc(s_lpfnBannerTextCtrlProc, hWnd, uMsg, wParam, lParam));
}

void paintBmpInHdcRect(HBITMAP hBmp, HDC hDC, RECT rect)
{
    BITMAP bm;
    if(!GetObject(hBmp, sizeof(BITMAP), (LPVOID)(&bm)))
        return;

    HDC hdcMem = CreateCompatibleDC(hDC);
    SelectObject(hdcMem, hBmp);

    SetStretchBltMode(hDC, COLORONCOLOR);
    StretchBlt(hDC, 0, 0, rect.right - rect.left, rect.bottom - rect.top,
            hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

    DeleteDC(hdcMem);
}

void handleEraseBkgndMsg(HWND hDlg, HDC hDC)
{
    RECT rectBmp;

    GetClientRect(GetDlgItem(hDlg, IDC_BANNERBMPCTRL), &rectBmp);

    RECT rect;
    GetClientRect(hDlg, &rect);
    rect.top = rectBmp.bottom;

    HBRUSH hbr    = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    HBRUSH hbrSav = (HBRUSH)SelectObject(hDC, hbr);
    Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom);

    paintBmpInHdcRect(g_hBannerBmp, hDC, rectBmp);

    SelectObject(hDC, hbrSav);
    DeleteObject((HGDIOBJ)hbr);
}

BOOL CALLBACK propertySheetWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_ERASEBKGND)
    {
        handleEraseBkgndMsg(hWnd, (HDC)wParam);
        return TRUE;
    }
    else if (uMsg == WM_SIZE)
    {
        HWND hBannerWnd = GetDlgItem(hWnd, IDC_BANNERBMPCTRL);

        // set the bitmap control width to the property sheet window width
        if (hBannerWnd)
        {
            RECT rectBmp;
            RECT rectText;

            GetClientRect(s_hBannerWnd, &rectBmp);
            SetWindowPos(s_hBannerWnd, HWND_TOP, 0, 0, LOWORD(lParam), rectBmp.bottom - rectBmp.top, SWP_NOMOVE | SWP_NOZORDER);

            GetClientRect(s_hBannerText, &rectText);
            SetWindowPos(s_hBannerText, HWND_TOP, 0, 0, LOWORD(lParam) - 14, rectText.bottom - rectText.top, SWP_NOMOVE | SWP_NOZORDER);
        }
    }
    return (CallWindowProc(s_lpfnPSWndProc, hWnd, uMsg, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\autorun.cpp ===
#include "precomp.h"

extern TCHAR g_szBuildRoot[MAX_PATH];
extern TCHAR g_szWizRoot[];
extern TCHAR g_szLanguage[16];
extern TCHAR g_szCustIns[];
extern TCHAR g_szMastInf[];
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;


DWORD DetermineISKColor( LONG );

static ISKINFO s_iskInfo;                         // a structure containing isk configuration information


//---------------------------------------------------------------------------
void InsertComboString( HWND hDlg, UINT uControl, UINT uString )
{
    TCHAR szString[128];

    LoadString( g_rvInfo.hInst, uString, szString, 128 );

    SendDlgItemMessage( hDlg, uControl, CB_INSERTSTRING, (WPARAM) 0, (LPARAM) szString);

}
//---------------------------------------------------------------------------
INT_PTR CALLBACK ISKBackBitmap( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LONG lIndex;
    TCHAR szData[MAX_PATH];
    TCHAR szNormalIndex[4];
    TCHAR szHighlightIndex[4];
    TCHAR szIniPath[MAX_PATH];
    DWORD dwResult;

    PathCombine(szIniPath, g_szBuildRoot, TEXT("INS"));
    PathAppend(szIniPath, GetOutputPlatformDir());
    PathAppend(szIniPath, g_szLanguage);
    PathAppend(szIniPath, TEXT("iak.ini"));

    switch (message) {
        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDE_ISKTITLEBAR);
            EnableDBCSChars(hDlg, IDE_ISKBACKBITMAP);
            EnableDBCSChars(hDlg, IDE_ISKBUTTON);

            Edit_LimitText(GetDlgItem(hDlg, IDE_ISKTITLEBAR),   countof(s_iskInfo.szISKTitleBar)-1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ISKBACKBITMAP), countof(s_iskInfo.szISKBackBitmap)-1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ISKBUTTON),     countof(s_iskInfo.szISKBtnBitmap)-1);

            SendDlgItemMessage(hDlg, IDC_COOLBUTTON, BM_SETCHECK, 1, 0);
            GetPrivateProfileString( TEXT("ISK"), TEXT("Title"), TEXT(""), szData,
                countof(szData), szIniPath );
            StrCpy(s_iskInfo.szISKTitleBar, szData );
            GetPrivateProfileString( TEXT("ISK"), TEXT("BmpPath"), TEXT(""), szData,
                countof(szData), szIniPath );
            StrCpy(s_iskInfo.szISKBackBitmap, szData);
            GetPrivateProfileString( TEXT("ISK"), TEXT("BtnPath"), TEXT(""), szData,
                countof(szData), szIniPath );
            StrCpy(s_iskInfo.szISKBtnBitmap, szData);
            SendDlgItemMessage( hDlg, IDE_ISKBUTTON, WM_SETTEXT, 0, (LPARAM)s_iskInfo.szISKBtnBitmap);
            GetPrivateProfileString( TEXT("ISK"), TEXT("StandardColorIndex"), TEXT("6"),
                szData, countof(szData), szIniPath );
            s_iskInfo.dwNIndex = StrToLong( szData );
            GetPrivateProfileString( TEXT("ISK"), TEXT("HighlightColorIndex"), TEXT("0"),
                szData, countof(szData), szIniPath );
            s_iskInfo.dwHIndex = StrToLong( szData );
            DisableDlgItem(hDlg, IDE_ISKBUTTON);
            DisableDlgItem(hDlg, IDC_ISKBROWSE2);
            GetPrivateProfileString( TEXT("ISK"), TEXT("CustomButtonState"), TEXT(""),
                szData, countof(szData), szIniPath );
            if(!StrCmp(szData, TEXT("0")))
            {
                SendDlgItemMessage(hDlg, IDC_ISKCUST3D, BM_SETCHECK, 0, 0);
                SendDlgItemMessage(hDlg, IDC_COOLBUTTON, BM_SETCHECK, 0, 0);
                SendDlgItemMessage(hDlg, IDC_RADIO2, BM_SETCHECK, 1, 0);
            }
            else
            {
                if(s_iskInfo.szISKBtnBitmap[0])
                {
                    SendDlgItemMessage(hDlg, IDC_ISKCUST3D, BM_SETCHECK, 1, 0);
                    SendDlgItemMessage(hDlg, IDC_COOLBUTTON, BM_SETCHECK, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_RADIO2, BM_SETCHECK, 0, 0);
                    EnableDlgItem( hDlg, IDE_ISKBUTTON );
                    EnableDlgItem( hDlg, IDC_ISKBROWSE2 );
                }
                else
                {
                    SendDlgItemMessage(hDlg, IDC_ISKCUST3D, BM_SETCHECK, 0, 0);
                    SendDlgItemMessage(hDlg, IDC_COOLBUTTON, BM_SETCHECK, 1, 0);
                    SendDlgItemMessage(hDlg, IDC_RADIO2, BM_SETCHECK, 0, 0);
                }
            }
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_DARKCYAN );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_DARKYELLOW );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_DARKMAGENTA );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_DARKBLUE );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_DARKGREEN );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_DARKRED );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_DARKGRAY );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_YELLOW );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_MAGENTA );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_CYAN );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_BLUE );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_GREEN );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_RED );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_LIGHTGRAY );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_BLACK );
            InsertComboString( hDlg, IDC_ISKNORMAL, IDS_WHITE );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_DARKCYAN );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_DARKYELLOW );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_DARKMAGENTA );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_DARKBLUE );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_DARKGREEN );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_DARKRED );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_DARKGRAY );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_YELLOW );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_MAGENTA );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_CYAN );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_BLUE );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_GREEN );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_RED );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_LIGHTGRAY );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_BLACK );
            InsertComboString( hDlg, IDC_ISKHIGHLIGHT, IDS_WHITE );
            break;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {

                case IDC_ISKBROWSE:
                    GetDlgItemText(hDlg, IDE_ISKBACKBITMAP, s_iskInfo.szISKBackBitmap, countof(s_iskInfo.szISKBackBitmap));
                    if (BrowseForFile(hDlg, s_iskInfo.szISKBackBitmap, countof(s_iskInfo.szISKBackBitmap), GFN_BMP))
                        SetDlgItemText(hDlg, IDE_ISKBACKBITMAP, s_iskInfo.szISKBackBitmap);
                    break;

                case IDC_ISKBROWSE2:
                    GetDlgItemText(hDlg, IDE_ISKBUTTON, s_iskInfo.szISKBtnBitmap, countof(s_iskInfo.szISKBtnBitmap));
                    if (BrowseForFile(hDlg, s_iskInfo.szISKBtnBitmap, countof(s_iskInfo.szISKBtnBitmap), GFN_BMP))
                        SetDlgItemText(hDlg, IDE_ISKBUTTON, s_iskInfo.szISKBtnBitmap);
                    break;

                case IDC_ISKCUST3D:
                    EnableDlgItem(hDlg, IDE_ISKBUTTON);
                    EnableDlgItem(hDlg, IDC_ISKBROWSE2);
                    break;

                case IDC_COOLBUTTON:
                    DisableDlgItem(hDlg, IDE_ISKBUTTON);
                    DisableDlgItem(hDlg, IDC_ISKBROWSE2);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    break;

                case IDC_RADIO2:
                    DisableDlgItem(hDlg, IDE_ISKBUTTON);
                    DisableDlgItem(hDlg, IDC_ISKBROWSE2);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
                    SendMessage(GetDlgItem(hDlg, IDE_ISKTITLEBAR), WM_SETTEXT, 0, (LPARAM)s_iskInfo.szISKTitleBar);
                    SendMessage(GetDlgItem(hDlg, IDE_ISKBACKBITMAP), WM_SETTEXT, 0, (LPARAM)s_iskInfo.szISKBackBitmap);
                    SendMessage(GetDlgItem(hDlg, IDE_ISKBUTTON), WM_SETTEXT, 0, (LPARAM)s_iskInfo.szISKBtnBitmap);
                    SendDlgItemMessage( hDlg, IDC_ISKNORMAL, CB_SETCURSEL, (WPARAM) s_iskInfo.dwNIndex, 0);
                    SendDlgItemMessage( hDlg, IDC_ISKHIGHLIGHT, CB_SETCURSEL, (WPARAM) s_iskInfo.dwHIndex, 0);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    SendDlgItemMessage(hDlg, IDE_ISKTITLEBAR, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM) s_iskInfo.szISKTitleBar);

                    if (!IsBitmapFileValid(hDlg, IDE_ISKBACKBITMAP,
                            s_iskInfo.szISKBackBitmap, NULL,
                            540, 347, IDS_TOOBIG540x347, IDS_TOOSMALL540x347))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    else
                    {
                        WritePrivateProfileString( TEXT("ISK"), TEXT("BmpPath"),
                            s_iskInfo.szISKBackBitmap, szIniPath );
                    }

                    if(SendDlgItemMessage(hDlg,IDC_ISKCUST3D,BM_GETCHECK,0,0)==BST_CHECKED)
                    {
                        if (!CheckField(hDlg, IDE_ISKBUTTON, FC_NONNULL | FC_FILE | FC_EXISTS))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }

                        if (!IsBitmapFileValid(hDlg, IDE_ISKBUTTON,
                                s_iskInfo.szISKBtnBitmap, NULL,
                                0, 0, 0, 0))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        else
                        {
                            WritePrivateProfileString( TEXT("ISK"), TEXT("BtnPath"),
                                s_iskInfo.szISKBtnBitmap, szIniPath );
                        }
                    }
                    else
                    {
                        StrCpy(s_iskInfo.szISKBtnBitmap, TEXT("\0"));

                        WritePrivateProfileString( TEXT("ISK"), TEXT("BtnPath"), NULL, szIniPath );
                    }

                    WritePrivateProfileString( TEXT("ISK"), TEXT("Title"),
                        s_iskInfo.szISKTitleBar, szIniPath );

                    dwResult = (DWORD) SendDlgItemMessage(hDlg, IDC_COOLBUTTON, BM_GETCHECK, 0, 0);
                    if( dwResult == BST_CHECKED )
                    {
                        s_iskInfo.fCoolButtons = TRUE;
                        WritePrivateProfileString( TEXT("ISK"), TEXT("CustomButtonState"),
                            TEXT("1"), szIniPath );
                    }
                    else
                    {
                        dwResult = (DWORD) SendDlgItemMessage(hDlg, IDC_ISKCUST3D, BM_GETCHECK, 0, 0);
                        if( dwResult == BST_CHECKED )
                        {
                            s_iskInfo.fCoolButtons = TRUE;
                            WritePrivateProfileString( TEXT("ISK"), TEXT("CustomButtonState"),
                                TEXT("1"), szIniPath );
                        }
                        else
                        {
                            s_iskInfo.fCoolButtons = FALSE;
                            WritePrivateProfileString( TEXT("ISK"), TEXT("CustomButtonState"),
                                TEXT("0"), szIniPath );
                        }
                    }
                    lIndex = (LONG) SendDlgItemMessage( hDlg, IDC_ISKNORMAL, CB_GETCURSEL, 0, 0);
                    wnsprintf(szNormalIndex, countof(szNormalIndex), TEXT("%d"), lIndex);
                    WritePrivateProfileString( TEXT("ISK"), TEXT("StandardColorIndex"),
                        szNormalIndex, szIniPath );
                    s_iskInfo.dwNormalColor = DetermineISKColor( lIndex );
                    s_iskInfo.dwNIndex = (DWORD) lIndex;
                    lIndex = (LONG) SendDlgItemMessage( hDlg, IDC_ISKHIGHLIGHT, CB_GETCURSEL, 0, 0);
                    wnsprintf(szHighlightIndex, countof(szHighlightIndex), TEXT("%d"), lIndex);
                    WritePrivateProfileString( TEXT("ISK"), TEXT("HighlightColorIndex"),
                        szHighlightIndex, szIniPath );
                    s_iskInfo.dwHighlightColor = DetermineISKColor( lIndex );
                    s_iskInfo.dwHIndex = (DWORD) lIndex;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}
//---------------------------------------------------------------------------
void ISKSaveInfo( LPTSTR szIniPath )
{
    TCHAR szNormalColor[32];
    TCHAR szHighlightColor[32];

    wnsprintf(szNormalColor, countof(szNormalColor), TEXT("%d"), s_iskInfo.dwNormalColor);
    wnsprintf(szHighlightColor, countof(szHighlightColor), TEXT("%d"), s_iskInfo.dwHighlightColor);

    if(ISNONNULL(s_iskInfo.szISKTitleBar))
        WritePrivateProfileString( TEXT("Custom"), TEXT("Title"), s_iskInfo.szISKTitleBar,
            szIniPath );
    WritePrivateProfileString( TEXT("Custom"), TEXT("NormalColor"), szNormalColor,
        szIniPath );
    WritePrivateProfileString( TEXT("Custom"), TEXT("HighlightColor"), szHighlightColor,
        szIniPath );
    if( s_iskInfo.fCoolButtons )
    {
        WritePrivateProfileString( TEXT("Custom"), TEXT("CoolButtons"), TEXT("1"), szIniPath );
    }
}

//---------------------------------------------------------------------------
DWORD DetermineISKColor( LONG index )
{

    switch( index )
    {
        case 0:
            return RGB( 255, 255, 255 );    // white
            break;
        case 1:
            return RGB( 0, 0, 0 );          // black
            break;
        case 2:
            return RGB( 192, 192, 192 );    // light gray
            break;
        case 3:
            return RGB( 255, 000, 000 );    // red
            break;
        case 4:
            return RGB( 000, 255, 000 );    // green
            break;
        case 5:
            return RGB( 000, 000, 255 );    // blue
            break;
        case 6:
            return RGB( 000, 255, 255 );    // cyan
            break;
        case 7:
            return RGB( 255, 000, 255 );    // magenta
            break;
        case 8:
            return RGB( 255, 255, 000 );    // yellow
            break;
        case 9:
            return RGB( 127, 127, 127 );    // dark gray
            break;
        case 10:
            return RGB( 127, 000, 000 );    // dark red
            break;
        case 11:
            return RGB( 000, 127, 000 );    // dark green
            break;
        case 12:
            return RGB( 000, 000, 127 );    // dark blue
            break;
        case 13:
            return RGB( 127, 000, 127 );    // dark magenta
            break;
        case 14:
            return RGB( 127, 127, 000 );    // dark yellow
            break;
        case 15:
            return RGB( 000, 127, 127 );    // dark cyan
            break;
    }
    return(0);

}

void CopyCDFile(TCHAR *lpszSourceRoot,TCHAR *lpszDestRoot,TCHAR *lpszSourceFile,TCHAR *lpszDestFile)
{
    TCHAR szNewSource[MAX_PATH];
    TCHAR szNewDest[MAX_PATH];

    PathCombine(szNewSource, lpszSourceRoot, lpszSourceFile);

    PathCombine(szNewDest, lpszDestRoot, lpszDestFile);

    CopyFile(szNewSource,szNewDest,FALSE);
}

//---------------------------------------------------------------------------
// CopyISK:
//      parameters
//      ----------
//      szDestPath - destination path for copy operation - should point to
//          "cdrom" directory on the hard drive. Example: "C:\BUILD\CD".
//      szSourcePath - source path for copy operation - should point to
//          the source isk directory. Example "\\PSD1\IAK\IAK001\BUILD\ISK"
//---------------------------------------------------------------------------
BOOL CopyISK( LPTSTR szDestPath, LPTSTR szSourcePath )
{
    TCHAR szIniPath[MAX_PATH];
    TCHAR szBmpPath[MAX_PATH];
    TCHAR szNewDest[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    TCHAR szMoreInfo[MAX_PATH];
    TCHAR szStartHtm[MAX_PATH];
    BOOL res = TRUE;

    StrCpy(szNewDest,szDestPath);

    CopyCDFile(szSourcePath, szNewDest, TEXT("cdauto.inf"),TEXT("autorun.inf"));

    CopyCDFile(szSourcePath, szNewDest, TEXT("cdsetup.exe"),TEXT("cdsetup.exe"));

    PathAppend(szNewDest, GetOutputPlatformDir());
    
    CopyCDFile(szSourcePath, szNewDest, TEXT("cdie.exe"), TEXT("ie.exe"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("isk3.ico"), TEXT("isk3.ico"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("cdloc.ini"), TEXT("locale.ini"));

    PathAppend(szNewDest, g_szLanguage);
    
    PathAppend(szNewDest, TEXT("bin"));
    CreateDirectory(szNewDest,NULL);

    if (!GetPrivateProfileInt(IS_CDCUST, IK_DISABLESTART, 0, g_szCustIns))
    {
        if (GetPrivateProfileString(IS_CDCUST, IK_STARTHTM, TEXT(""), szStartHtm, countof(szStartHtm), g_szCustIns))
        {
            CopyHtmlImgs(szStartHtm, szNewDest, NULL, NULL);
            StrCpy(szTemp, szStartHtm);
            PathRemoveFileSpec(szTemp);
            CopyCDFile(szTemp, szNewDest, PathFindFileName(szStartHtm), TEXT("start.htm"));
        }
    }
    else
    {
        DeleteFileInDir(TEXT("start.htm"), szNewDest);
        DeleteHtmlImgs(TEXT("start.htm"), szNewDest, NULL, NULL);
    }

    CopyCDFile(szSourcePath, szNewDest, TEXT("iecd.exe"), TEXT("iecd.exe"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("ie3inst.exe"),TEXT("ie3inst.exe"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("closeie.exe"), TEXT("closeie.exe"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("closeie.isk"), TEXT("closeie.isk"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("icw.isk"), TEXT("icw.isk"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("isp.isk"), TEXT("isp.isk"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("runisp32.exe"), TEXT("runisp32.exe"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("isk3ro.exe"), TEXT("isk3ro.exe"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("iskrun.exe"), TEXT("iskrun.exe"));
    CopyCDFile(szSourcePath, szNewDest, TEXT("cdreadme.exe"), TEXT("readme.exe"));
    if (GetPrivateProfileString(IS_CDCUST, IK_MOREINFO, TEXT(""), szMoreInfo, countof(szMoreInfo), g_szCustIns))
    {
        StrCpy(szTemp, szMoreInfo);
        PathRemoveFileSpec(szTemp);
        CopyCDFile(szTemp, szNewDest, PathFindFileName(szMoreInfo), TEXT("moreinfo.txt"));
    }
    else
        CopyCDFile(szSourcePath, szNewDest, TEXT("cdinfo.txt"), TEXT("moreinfo.txt"));
    
    PathAppend( szDestPath, GetOutputPlatformDir() );
    
    PathCombine( szIniPath, szDestPath, TEXT("locale.ini") );
    
    WritePrivateProfileString(TEXT("Locale"), TEXT("default"), g_szLanguage, szIniPath);
    
    PathCombine(szIniPath, szNewDest, TEXT("iecd.ini"));
    
    ISKSaveInfo( szIniPath );
    
    PathCombine( szBmpPath, szNewDest, TEXT("back.bmp") );
    
    CopyFile( s_iskInfo.szISKBackBitmap, szBmpPath, FALSE );
    
    PathCombine( szBmpPath, szNewDest, TEXT("btns.bmp") );
    
    CopyFile( s_iskInfo.szISKBtnBitmap, szBmpPath, FALSE );

    return res;
}

//
//  FUNCTION: CDInfoProc(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "CD Info" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//
INT_PTR CALLBACK CDInfoProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szMoreInfo[MAX_PATH];
    TCHAR szStartHtm[MAX_PATH];
    BOOL  fDisable;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            EnableDBCSChars(hDlg, IDE_STARTHTM);
            EnableDBCSChars(hDlg, IDE_MOREINFO);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

       case WM_COMMAND:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                switch (LOWORD(wParam))
                {
                case IDC_BROWSEMOREINFO:
                    GetDlgItemText( hDlg, IDE_MOREINFO, szMoreInfo, countof(szMoreInfo));
                    if( BrowseForFile( hDlg, szMoreInfo, countof(szMoreInfo), GFN_TXT ))
                        SetDlgItemText( hDlg, IDE_MOREINFO, szMoreInfo );
                    break;
                case IDC_BROWSESTARTHTM:
                    GetDlgItemText( hDlg, IDE_STARTHTM, szStartHtm, countof(szStartHtm));
                    if( BrowseForFile( hDlg, szStartHtm, countof(szStartHtm), GFN_LOCALHTM ))
                        SetDlgItemText( hDlg, IDE_STARTHTM, szStartHtm );
                    break;
                case IDC_ENABLESTARTHTM:
                    fDisable = !(IsDlgButtonChecked(hDlg, IDC_ENABLESTARTHTM) == BST_CHECKED);
                    EnableDlgItem2(hDlg, IDE_STARTHTM, !fDisable);
                    EnableDlgItem2(hDlg, IDC_STARTHTM_TXT, !fDisable);
                    EnableDlgItem2(hDlg, IDC_BROWSESTARTHTM, !fDisable);
                    break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    // BUGBUG: <oliverl> these settings should be kept in server side file for IEAK6
                    GetPrivateProfileString(IS_CDCUST, IK_MOREINFO, TEXT(""), szMoreInfo, countof(szMoreInfo), g_szCustIns);
                    GetPrivateProfileString(IS_CDCUST, IK_STARTHTM, TEXT(""), szStartHtm, countof(szStartHtm), g_szCustIns);

                    if (ISNULL(szMoreInfo))
                    {
                        StrCpy(szMoreInfo, g_szMastInf);
                        PathRemoveFileSpec(szMoreInfo);
                        PathAppend(szMoreInfo, TEXT("cdinfo.txt"));
                    }
                    SetDlgItemText( hDlg, IDE_MOREINFO, szMoreInfo );

                    fDisable = GetPrivateProfileInt(IS_CDCUST, IK_DISABLESTART, 0, g_szCustIns);
                    if (fDisable)
                    {
                        DisableDlgItem(hDlg, IDE_STARTHTM);
                        DisableDlgItem(hDlg, IDC_STARTHTM_TXT);
                        DisableDlgItem(hDlg, IDC_BROWSESTARTHTM);
                    }
                    else
                    {
                        if (ISNULL(szStartHtm))
                        {
                            StrCpy(szStartHtm, g_szMastInf);
                            PathRemoveFileSpec(szStartHtm);
                            PathAppend(szStartHtm, TEXT("cdstart.htm"));
                        }
                        SetDlgItemText( hDlg, IDE_STARTHTM, szStartHtm );
                    }

                    CheckDlgButton(hDlg, IDC_ENABLESTARTHTM, fDisable ? BST_UNCHECKED: BST_CHECKED);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    fDisable = !(IsDlgButtonChecked(hDlg, IDC_ENABLESTARTHTM) == BST_CHECKED);

                    if (!CheckField(hDlg, IDE_MOREINFO, FC_FILE | FC_EXISTS | FC_NONNULL))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    GetDlgItemText( hDlg, IDE_MOREINFO, szMoreInfo, countof(szMoreInfo));

                    if (!fDisable)
                    {
                        DWORD dwFlags = FC_FILE | FC_EXISTS | FC_NONNULL;


                        if (!CheckField(hDlg, IDE_STARTHTM, dwFlags))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                        GetDlgItemText( hDlg, IDE_STARTHTM, szStartHtm, countof(szStartHtm));
                        WritePrivateProfileString(IS_CDCUST, IK_STARTHTM, szStartHtm, g_szCustIns);
                    }

                    WritePrivateProfileString(IS_CDCUST, IK_DISABLESTART, fDisable ? TEXT("1") : TEXT("0"), g_szCustIns);
                    WritePrivateProfileString(IS_CDCUST, IK_MOREINFO, szMoreInfo, g_szCustIns);

                    g_iCurPage = PPAGE_CDINFO;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                        PageNext(hDlg);
                    else
                        PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\update\update.cpp ===
#include "precomp.h"

HWND s_hDlg = NULL;
TCHAR s_szTempDir[MAX_PATH];
static TCHAR s_szPID[64];
static BOOL s_fSilent = FALSE;
static BOOL s_fOCW = FALSE;
static int s_iType = -1;
static HINSTANCE g_hInstance;

VOID ParseCmdLine(LPTSTR pszCmdLine)
{
    LPTSTR pszCurrArg;
    LPTSTR pszPtr;

    StrGetNextField(&pszCmdLine, TEXT("/"), 0);     // point to the first argument
    while ((pszCurrArg = StrGetNextField(&pszCmdLine, TEXT("/"), 0)) != NULL)
    {
        switch (*pszCurrArg)
        {
            case TEXT('s'):
            case TEXT('S'):
                s_fSilent = TRUE;
                break;

            case TEXT('o'):
            case TEXT('O'):
                s_fOCW = TRUE;
                break;

            case TEXT('p'):
            case TEXT('P'):
                if (*++pszCurrArg == TEXT(':'))
                    pszCurrArg++;

                // process ID for wizard
                if ((pszPtr = StrGetNextField(&pszCurrArg, TEXT(","), REMOVE_QUOTES)) != NULL)
                {
                    StrCpy(s_szPID, pszPtr);
                    StrTrim(s_szPID, TEXT("\t\n\r\v\f "));
                }
                else
                    *s_szPID = TEXT('\0');
                break;

            case TEXT('m'):
            case TEXT('M'):
                //install mode
                if (*++pszCurrArg == TEXT(':'))
                    pszCurrArg++;
                
                switch (*pszCurrArg)
                {
                    case TEXT('r'):
                    case TEXT('R'):
                        s_iType = REDIST;
                        break;

                    case TEXT('b'):
                    case TEXT('B'):
                        s_iType = BRANDED;
                        break;

                    case TEXT('i'):
                    case TEXT('I'):
                        s_iType = INTRANET;
                        break;
                }

            default:                                // ignore these arguments
                break;
        }
    }
}

BOOL WINAPI DoReboot(HWND hwndUI, HINSTANCE hInst)
{
    TCHAR szMsg[MAX_PATH];
    TCHAR szTitle[128];

    LoadString(hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(hInst, IDS_RESTARTYESNO, szMsg, ARRAYSIZE(szMsg));

    if (MessageBox(hwndUI, szMsg, szTitle, MB_YESNO) == IDNO)
        return FALSE;

    if (IsOS(OS_NT))
    {
        HANDLE hToken;
        TOKEN_PRIVILEGES tkp;

        // get a token from this process
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        {
            // get the LUID for the shutdown privilege
            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            //get the shutdown privilege for this proces
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);
        }

        ExitWindowsEx(EWX_REBOOT, 0);
    }
    else
        ExitWindowsEx(EWX_REBOOT, 0);

    return TRUE;
}

DWORD InstallThreadProc(LPVOID lpv)
{
    DWORD dwExitCode=0;

    RunAndWait((LPTSTR)lpv, s_szTempDir, SW_SHOW, &dwExitCode);
    PostMessage(s_hDlg, WM_CLOSE, 0, 0L);
    return dwExitCode;
}

INT_PTR CALLBACK UIDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM lParam)
{
    DWORD dwTid;
    static DWORD s_dwExitCode;
    static HANDLE s_hThread = NULL;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            s_hDlg = hDlg;
            Animate_Open( GetDlgItem( hDlg, IDC_ANIM ), IDA_DOWNLOAD );
            Animate_Play( GetDlgItem( hDlg, IDC_ANIM ), 0, -1, -1 );
            if ((s_hThread = CreateThread(NULL, 4096, InstallThreadProc, (LPVOID)lParam, 0, &dwTid)) == NULL)
            {
                RunAndWait((LPTSTR)lParam, s_szTempDir, SW_SHOW, &s_dwExitCode);
                PostMessage(hDlg, WM_CLOSE, 0, 0L);
            }
            break;

        case WM_CLOSE:
            if (s_hThread != NULL)
            {
                while (MsgWaitForMultipleObjects(1, &s_hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                {
                    MSG msg;

                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                GetExitCodeThread(s_hThread, &s_dwExitCode);
                CloseHandle(s_hThread);
                s_hThread = NULL;
            }
            EndDialog(hDlg, s_dwExitCode);
            break;

        default:
            return(FALSE);
    }
    return(TRUE);

}

INT_PTR CALLBACK ConfirmDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM /*lParam*/)
{
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szTmp[1024];
            DWORD dwMode;
            dwMode = (DWORD)GetWindowLongPtr(GetParent(hDlg),GWLP_USERDATA);
            switch (dwMode)
            {
                case REDIST:
                    LoadString(g_hInstance,IDS_ICP,szTmp,countof(szTmp));
                    break;
                case BRANDED:
                    LoadString(g_hInstance,IDS_ISP,szTmp,countof(szTmp));
                    break;
                case INTRANET:
                default:
                    LoadString(g_hInstance,IDS_CORP,szTmp,countof(szTmp));
                    break;
            }
            SetDlgItemText(hDlg,IDC_STATICLICENSE,szTmp);
            return TRUE;
        }

        case WM_COMMAND:
            switch (wParam)
            {
                case IDOK:
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }

    }
    return FALSE;

}

INT_PTR CALLBACK TypeDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM /*lParam*/)
{
    static DWORD dwMode = BRANDED;  //default mode

    switch(msg)
    {
        case WM_INITDIALOG:
        {
            switch (dwMode) 
            {
                case REDIST:
                    CheckDlgButton(hDlg,IDC_ICP,TRUE);  
                    break;
                case BRANDED:
                    CheckDlgButton(hDlg,IDC_ISP,TRUE);  
                    break;
                case INTRANET:
                default:
                    CheckDlgButton(hDlg,IDC_INTRA,TRUE); 
                    break;
            }

            return TRUE;
        }

        case WM_COMMAND:
            switch (wParam)
            {
                case IDC_ICP:
                    dwMode = REDIST;
                    break;

                case IDC_ISP:
                    dwMode = BRANDED;
                    break;

                case IDC_INTRA:
                    dwMode = INTRANET;
                    break;

                case IDOK:
                {
                    SetWindowLongPtr(hDlg,GWLP_USERDATA,dwMode);
                
                    if (!DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONFIRM), hDlg, ConfirmDlgProc))
                        return TRUE;  //keep trying

                    EndDialog(hDlg, dwMode);
                    return TRUE;
                }

            }
            break;
    }

    return FALSE;
}



int WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR lpCmdLine, int)
{
    HANDLE hWizard;
    DWORD dwID;
    TCHAR szCmdLine[MAX_PATH];
    TCHAR szCmd[MAX_PATH];
    DWORD dwExitCode;
    SHELLEXECUTEINFO shInfo;
    BOOL fReboot = FALSE;

    g_hInstance = hInst;

    if (lpCmdLine == NULL  || *lpCmdLine == '\0')
        return -1;

    InitCommonControls();

    dwExitCode = 0;

    A2Tbux(lpCmdLine, szCmdLine);
    ParseCmdLine(szCmdLine);

    dwID = StrToInt(s_szPID);

    if ((hWizard = OpenProcess(PROCESS_QUERY_INFORMATION | SYNCHRONIZE, FALSE, dwID)) != NULL)
    {
        while (MsgWaitForMultipleObjects(1, &hWizard, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        CloseHandle(hWizard);
    }

    if (s_iType == -1)
        s_iType = (INT) DialogBox(hInst, MAKEINTRESOURCE(IDD_CHOOSETYPE), NULL, TypeDlgProc);

    GetTempPath(ARRAYSIZE(s_szTempDir), s_szTempDir);
    
    PathCombine(szCmd, s_szTempDir, TEXT("ieak6.exe /r:N /q:a"));

    switch (s_iType)
    {
        case REDIST:
            StrCat(szCmd, TEXT("/M:R"));
            break;

        case BRANDED:
            StrCat(szCmd, TEXT("/M:B")); 
            break;

        case INTRANET:
        default:
            StrCat(szCmd, TEXT("/M:I"));
            break;
    }


    if (s_fSilent)
        RunAndWait(szCmd, s_szTempDir, SW_SHOW, &dwExitCode);
    else
        dwExitCode = (DWORD) DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_WAIT), NULL, UIDlgProc, (LPARAM)szCmd);

    PathCombine(szCmd, s_szTempDir, TEXT("ieak6.exe"));
    DeleteFile(szCmd);

    if (dwExitCode == ERROR_SUCCESS_REBOOT_REQUIRED)
        fReboot = DoReboot(GetDesktopWindow(), hInst);

    if (!fReboot)
    {
        TCHAR szIEAKDir[MAX_PATH];
        DWORD dwSize;

        dwSize = sizeof(szIEAKDir);
        if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEAK6WIZ.EXE"),
            TEXT("Path"), NULL, (LPVOID) szIEAKDir, &dwSize) != ERROR_SUCCESS)
        {
            dwSize = sizeof(szIEAKDir);
            SHGetValue(HKEY_LOCAL_MACHINE, CURRENTVERSIONKEY, TEXT("ProgramFilesDir"), NULL, (LPVOID) szIEAKDir, &dwSize);
            PathAppend(szIEAKDir, TEXT("IEAK"));
        }
        PathCombine(szCmd, szIEAKDir, TEXT("ieak6wiz.exe"));

        ZeroMemory(&shInfo, sizeof(shInfo));
        shInfo.cbSize = sizeof(shInfo);
        shInfo.hwnd = GetDesktopWindow();
        shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
        shInfo.lpVerb = TEXT("open");
        shInfo.lpFile = szCmd;
        shInfo.lpDirectory = szIEAKDir;

        if (s_fOCW)
            shInfo.lpParameters = TEXT("/o");
        shInfo.nShow = SW_SHOW;

        ShellExecuteEx(&shInfo);
        CloseHandle(shInfo.hProcess);
    }
    return 0;
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    // return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\btoolbar.cpp ===
#include "precomp.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szTempSign[];
extern BOOL g_fIntranet;
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

INT_PTR CALLBACK BToolbarProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szFeatureDir[MAX_PATH];
    TCHAR szToolbarBmp[MAX_PATH];
    TCHAR szWorkDir[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    BOOL  fToolbarBmp;
    INT iTheme = 0, iBackground = 0;
    PTSTR pszPath;

    switch (uMsg)
    {
    case WM_INITDIALOG:
// --------- Toolbar background -----------------------------------------
        EnableDBCSChars(hDlg, IDE_TOOLBARBMP);
        Edit_LimitText(GetDlgItem(hDlg, IDE_TOOLBARBMP), countof(szToolbarBmp) - 1);

// --------- Toolbar bitmaps -----------------------------------------

// --------- Toolbar buttons --------------------------------------------
        EnableDBCSChars(hDlg, IDC_BTOOLBARLIST);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

// --------- Toolbar background -----------------------------------------
            // import INS clean-up -- delete bitmap from the temp location
            InsGetString(IS_BRANDING, TOOLBAR_BMP, szToolbarBmp, countof(szToolbarBmp), 
                g_szCustIns, NULL, &fToolbarBmp);
            if (fToolbarBmp)
                DeleteFileInDir(szToolbarBmp, g_szTempSign);

            if (fToolbarBmp)
            {
                CheckRadioButton(hDlg, IDC_BGIE6, IDC_BG_CUSTOM, IDC_BG_CUSTOM);
            }
            else
            {
                CheckRadioButton(hDlg, IDC_BGIE6, IDC_BG_CUSTOM, IDC_BGIE6);
            }
            
            SetDlgItemTextTriState(hDlg, IDE_TOOLBARBMP, IDC_BG_CUSTOM, szToolbarBmp, fToolbarBmp);

// --------- Toolbar buttons --------------------------------------------
            // import INS clean-up -- delete keys that are not relevant
            if (!g_fIntranet)
                InsDeleteKey(IS_BTOOLBARS, IK_BTDELETE, g_szCustIns);

            g_cmCabMappings.GetFeatureDir(FEATURE_BTOOLBAR, szFeatureDir);
            PathCreatePath(szFeatureDir);

            if (BToolbar_Init(GetDlgItem(hDlg, IDC_BTOOLBARLIST), g_szCustIns, g_szTempSign, szFeatureDir) == 0)
            {
                EnsureDialogFocus(hDlg, IDC_EDITBTOOLBAR,   IDC_ADDBTOOLBAR);
                EnsureDialogFocus(hDlg, IDC_REMOVEBTOOLBAR, IDC_ADDBTOOLBAR);

                DisableDlgItem(hDlg, IDC_EDITBTOOLBAR);
                DisableDlgItem(hDlg, IDC_REMOVEBTOOLBAR);
            }
            else
                ListBox_SetCurSel(GetDlgItem(hDlg, IDC_BTOOLBARLIST), (WPARAM) 0);

            if (g_fIntranet)
                ReadBoolAndCheckButton(IS_BTOOLBARS, IK_BTDELETE, FALSE, g_szCustIns, hDlg, IDC_DELETEBTOOLBARS);

            EnableDlgItem2(hDlg, IDC_DELETEBTOOLBARS, g_fIntranet);
            ShowDlgItem2  (hDlg, IDC_DELETEBTOOLBARS, g_fIntranet);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:

// --------- Toolbar background -----------------------------------------
            //----- Validate the path for a bitmap -----
            iBackground = IsDlgButtonChecked(hDlg, IDC_BGIE6) ? 0 : 2;

            fToolbarBmp = GetDlgItemTextTriState(hDlg, IDE_TOOLBARBMP, IDC_BG_CUSTOM, szToolbarBmp, countof(szToolbarBmp));
            if ((iBackground==2) &&  !IsBitmapFileValid(hDlg, IDE_TOOLBARBMP, szToolbarBmp, NULL, 0, 0, 0, 0))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                break;
            }

            // toolbar bitmap
            g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szWorkDir);

            // delete the old bitmap file
            if (InsGetString(IS_BRANDING, TOOLBAR_BMP, szTemp, countof(szTemp), g_szCustIns))
                DeleteFileInDir(szTemp, szWorkDir);

            // copy the new bitmap file
            if (fToolbarBmp  &&  *szToolbarBmp)
                CopyFileToDir(szToolbarBmp, szWorkDir);

            InsWriteString(IS_BRANDING, TOOLBAR_BMP, szToolbarBmp, g_szCustIns, fToolbarBmp, NULL, INSIO_TRISTATE);

// --------- Toolbar buttons --------------------------------------------
            g_cmCabMappings.GetFeatureDir(FEATURE_BTOOLBAR, szFeatureDir);

            BToolbar_Save(GetDlgItem(hDlg, IDC_BTOOLBARLIST), g_szCustIns, szFeatureDir);

            if (g_fIntranet)
                CheckButtonAndWriteBool(hDlg, IDC_DELETEBTOOLBARS, IS_BTOOLBARS, IK_BTDELETE, g_szCustIns);

// --------- Toolbar finish -----------------------------------------
            g_iCurPage = PPAGE_BTOOLBARS;
            EnablePages();
            (((LPNMHDR) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            pszPath = (PTSTR)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if (pszPath)
            {
                CoTaskMemFree(pszPath);
                SetWindowLongPtr(hDlg, GWLP_USERDATA, NULL);
            }

            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_ADDBTOOLBAR:
            BToolbar_Edit(GetDlgItem(hDlg, IDC_BTOOLBARLIST), TRUE);
            break;

        case IDC_EDITBTOOLBAR:
            BToolbar_Edit(GetDlgItem(hDlg, IDC_BTOOLBARLIST), FALSE);
            break;

        case IDC_REMOVEBTOOLBAR:
            BToolbar_Remove(GetDlgItem(hDlg, IDC_BTOOLBARLIST));
            break;

        case IDC_BGIE6:
        case IDC_BG_CUSTOM:
            fToolbarBmp = (GET_WM_COMMAND_ID(wParam, lParam)==IDC_BG_CUSTOM);
            EnableDlgItem2(hDlg, IDE_TOOLBARBMP,     fToolbarBmp);
            EnableDlgItem2(hDlg, IDC_BROWSETBB,      fToolbarBmp);
            break;

        case IDC_BROWSETBB:
            GetDlgItemText(hDlg, IDE_TOOLBARBMP, szToolbarBmp, countof(szToolbarBmp));
            if (BrowseForFile(hDlg, szToolbarBmp, countof(szToolbarBmp), GFN_BMP))
                SetDlgItemText(hDlg, IDE_TOOLBARBMP, szToolbarBmp);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\admwizpg.cpp ===
#include "precomp.h"
#include <admparse.h>

#define NUM_ICONS 3

extern TCHAR g_szCustIns[MAX_PATH];
extern TCHAR g_szBuildRoot[MAX_PATH];
extern TCHAR g_szWizRoot[MAX_PATH];
extern TCHAR g_szLoadedIns[MAX_PATH];
extern TCHAR g_szTempSign[MAX_PATH];
extern TCHAR g_szTitle[MAX_PATH];
extern TCHAR g_szLanguage[16];
extern BOOL g_fBranded, g_fIntranet;
extern PROPSHEETPAGE g_psp[NUM_PAGES];
extern int g_iCurPage;

static int s_ADMOpen, s_ADMClose, s_ADMCategory;
DWORD g_dwADMPlatformId = PLATFORM_WIN32;

// Creates image list, adds 3 bitmaps to it, and associates the image
// list with the treeview control.
LRESULT InitImageList(HWND hTreeView)
{
    HIMAGELIST  hWndImageList;
    HICON       hIcon;

    hWndImageList = ImageList_Create(GetSystemMetrics (SM_CXSMICON),
                                     GetSystemMetrics (SM_CYSMICON),
                                     TRUE,
                                     NUM_ICONS,
                                     3);
    if(!hWndImageList)
    {
        return FALSE;
    }

    hIcon = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_ICON2));
    s_ADMOpen = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_ICON3));
    s_ADMClose = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    hIcon = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_ICON4));
    s_ADMCategory = ImageList_AddIcon(hWndImageList, hIcon);
    DestroyIcon(hIcon);

    // Fail if not all images were added.
    if (ImageList_GetImageCount(hWndImageList) < NUM_ICONS)
    {
        // ERROR: Unable to add all images to image list.
        return FALSE;
    }

    // Associate image list with treeView control.
    TreeView_SetImageList(hTreeView, hWndImageList, TVSIL_NORMAL);
    return TRUE;
}

void DeleteOldAdmFiles(LPCTSTR pcszImportIns, LPCTSTR pcszBrandDir)
{
    TCHAR szBuf[8];
    TCHAR szFile[MAX_PATH];
    LPTSTR pszDot;
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    GetPrivateProfileString(BRANDING, LANG_LOCALE, TEXT("EN"), szBuf, countof(szBuf), pcszImportIns);
    PathCombine(szFile, g_szWizRoot, TEXT("policies"));
    PathAppend(szFile, szBuf);   // language
    PathAppend(szFile, TEXT("*.adm"));

    if ((hFind = FindFirstFile(szFile, &fd)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            StrCpy(szFile, fd.cFileName);
            if ((pszDot = StrRChr(szFile, NULL, TEXT('.'))) != NULL)
            {
                *pszDot = TEXT('\0');
                WritePrivateProfileString(IS_EXTREGINF, szFile, NULL, g_szCustIns);
                StrCpy(pszDot, TEXT(".inf"));
                DeleteFileInDir(szFile, pcszBrandDir);
            }
        } while (FindNextFile(hFind, &fd));
    }
}

//  FUNCTION: ADMParse(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for ADM page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected

INT_PTR CALLBACK ADMParse(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hTreeView = GetDlgItem(hDlg, IDC_ADMTREE);
    LPNM_TREEVIEW lpNMTreeView = (LPNM_TREEVIEW) lParam;
    TV_ITEM tvitem, tvitem1;
    HTREEITEM hItem;
    HTREEITEM hParentItem;
    TCHAR szMessage[512];
    TCHAR szTemp[MAX_PATH];
    RECT rect;
    RECT rectDlg;
    RECT rectDscr;
    static TCHAR szWorkDir[MAX_PATH];

    switch (message)
    {
        case WM_INITDIALOG:
            InitSysFont( hDlg, IDC_ADMTREE);
            g_hWizard = hDlg;
            InitImageList(hTreeView);
            EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), FALSE);
#ifdef UNICODE
            TreeView_SetUnicodeFormat(hTreeView, TRUE);
#else
            TreeView_SetUnicodeFormat(hTreeView, FALSE);
#endif
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_ADMIMPORT:
                            wnsprintf(szTemp, countof(szTemp), TEXT("%sPolicies%s"), g_szWizRoot, g_szLanguage);
                            ImportADMFile(hDlg, hTreeView, szTemp, szWorkDir, GetRole(g_fBranded, g_fIntranet), g_szCustIns);

                            if((hItem = TreeView_GetSelection(hTreeView)) == NULL ||
                               TreeView_GetParent(hTreeView, hItem) != NULL ||
                               !CanDeleteADM(hTreeView, hItem)) {
                                EnsureDialogFocus(hDlg, IDC_ADMDELETE, IDC_ADMIMPORT);
                                EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), FALSE);
                            }
                            else
                                EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), TRUE);
                            break;

                        case IDC_ADMDELETE:
                            LoadString(g_rvInfo.hInst, IDS_ADMDELWARN, szMessage, countof(szMessage));
                            if(MessageBox(hDlg, szMessage, g_szTitle, MB_ICONQUESTION|MB_YESNO) == IDYES)
                            {
                                hItem = TreeView_GetSelection(hTreeView);
                                DeleteADMItem(hTreeView, hItem, szWorkDir, g_szCustIns, TRUE, TRUE);

                                if ((hItem = TreeView_GetSelection(hTreeView)) == NULL ||
                                    TreeView_GetParent(hTreeView, hItem) != NULL ||
                                    !CanDeleteADM(hTreeView, hItem)) {
                                    EnsureDialogFocus(hDlg, IDC_ADMDELETE, IDC_ADMIMPORT);
                                    EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), FALSE);
                                }
                                else
                                    EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), TRUE);
                            }
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    GetWindowRect(hDlg, &rectDlg);
                    GetWindowRect(GetDlgItem(hDlg, IDC_ADMINSTR), &rect);

                    rectDscr.left   = rect.left - rectDlg.left + 1;
                    rectDscr.top    = rect.top - rectDlg.top + 1;
                    rectDscr.right  = rectDscr.left + (rect.right - rect.left) - 2;
                    rectDscr.bottom = rectDscr.top + (rect.bottom - rect.top) - 2;

                    CreateADMWindow(hTreeView, GetDlgItem(hDlg, IDC_ADMDELETE), rectDscr.left,
                        rectDscr.top, rectDscr.right - rectDscr.left,
                        rectDscr.bottom - rectDscr.top);

                    wnsprintf(szTemp, countof(szTemp), TEXT("%sPolicies%s"), g_szWizRoot, g_szLanguage);
                    PathCombine(szWorkDir, g_szBuildRoot, TEXT("INS"));
                    PathAppend(szWorkDir, GetOutputPlatformDir());
                    PathAppend(szWorkDir, g_szLanguage);
                    PathRemoveBackslash(szWorkDir);
                    {
                    CNewCursor cur(IDC_WAIT);
                    int nRole = GetRole(g_fBranded, g_fIntranet);

                    if(!LoadADMFiles(hTreeView, NULL, szTemp, szWorkDir, g_dwADMPlatformId, nRole,
                                     s_ADMClose, s_ADMCategory))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_ADMIMPORT), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), FALSE);
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_ADMIMPORT), TRUE);
                        if(TreeView_GetSelection(hTreeView) == NULL)
                            EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), FALSE);
                        else
                            EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), TRUE);
                    }

                    // delete old adm files from an imported ins file

                    if (GetPrivateProfileInt(IS_BRANDING, TEXT("DeleteAdms"), 0, g_szCustIns))
                    {
                        TCHAR szImportInsFile[MAX_PATH];

                        if (ISNULL(g_szLoadedIns))
                        {
                            GetPrivateProfileString(IS_BRANDING, TEXT("ImportIns"), TEXT(""),
                                szImportInsFile, countof(szImportInsFile), g_szCustIns);
                        }
                        else
                            StrCpy(szImportInsFile, g_szLoadedIns);

                        // only do process if we got the path of the ins file and extreginf section
                        // is not empty

                        if (ISNONNULL(szImportInsFile) &&
                            !InsIsSectionEmpty(IS_EXTREGINF, szImportInsFile))
                            DeleteOldAdmFiles(szImportInsFile, g_szTempSign);
                    }
                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    DeleteADMItems(hTreeView, szWorkDir, g_szCustIns, TRUE);
                    TreeView_DeleteAllItems(hTreeView);
                    DestroyADMWindow(hTreeView);

                    g_iCurPage = PPAGE_ADM;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                        PageNext(hDlg);
                    else
                        PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    if(QueryCancel(hDlg) == TRUE)
                    {
                        DeleteADMItems(hTreeView, szWorkDir, g_szCustIns, FALSE);
                        DestroyADMWindow(hTreeView);
                    }
                    break;

                case TVN_SELCHANGED:
                    hParentItem = TreeView_GetParent(hTreeView, lpNMTreeView->itemNew.hItem);
                    SelectADMItem(hDlg, hTreeView, &lpNMTreeView->itemOld, FALSE, FALSE);
                    // display the information for the newly selected item
                    DisplayADMItem(hDlg, hTreeView, &lpNMTreeView->itemNew, FALSE);
                    if (hParentItem != NULL ||
                        (lpNMTreeView->itemNew.hItem != NULL && !CanDeleteADM(hTreeView, lpNMTreeView->itemNew.hItem))) {
                        EnsureDialogFocus(hDlg, IDC_ADMDELETE, IDC_ADMIMPORT);
                        EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), FALSE);
                    }
                    else
                        EnableWindow(GetDlgItem(hDlg, IDC_ADMDELETE), TRUE);
                    break;

                case TVN_ITEMEXPANDED:
                    tvitem.mask = TVIF_IMAGE;
                    tvitem.hItem = lpNMTreeView->itemNew.hItem;
                    TreeView_GetItem(hTreeView, &tvitem);

                    // If tree item is EXPANDING (opening up) and
                    // current icon == CloseFolder, change icon to OpenFolder
                    if((lpNMTreeView->action == TVE_EXPAND) &&
                        (tvitem.iImage == s_ADMClose))
                    {
                        tvitem1.hItem = lpNMTreeView->itemNew.hItem;
                        tvitem1.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                        tvitem1.iImage = s_ADMOpen;
                        tvitem1.iSelectedImage = s_ADMOpen;

                        TreeView_SetItem(hTreeView, &tvitem1);
                    }

                    // If tree item is COLLAPSING (closing up) and
                    // current icon == OpenFolder, change icon to CloseFolder
                    else if((lpNMTreeView->action == TVE_COLLAPSE) &&
                        (tvitem.iImage == s_ADMOpen))
                    {
                        tvitem1.hItem = lpNMTreeView->itemNew.hItem;
                        tvitem1.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                        tvitem1.iImage = s_ADMClose;
                        tvitem1.iSelectedImage = s_ADMClose;

                        TreeView_SetItem(hTreeView, &tvitem1);
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

// Indicates whether to display/hide the adm page in the wizard
// If the correct Roles are set or no Roles set at all in the adm file,
// the page is displayed
BOOL ADMEnablePage()
{
    TCHAR szFileName[MAX_PATH];
    TCHAR szFilePath[MAX_PATH];
    WIN32_FIND_DATA FindFileData;

    wnsprintf(szFilePath, countof(szFilePath), TEXT("%sPolicies%s*.adm"), g_szWizRoot, g_szLanguage);
    HANDLE hFind = FindFirstFile(szFilePath, &FindFileData);
    if(hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            wnsprintf(szFileName, countof(szFileName), TEXT("%sPolicies%s%s"), g_szWizRoot, g_szLanguage, FindFileData.cFileName);
            if(IsADMFileVisible(szFileName, GetRole(g_fBranded, g_fIntranet), g_dwADMPlatformId))
            {
                FindClose(hFind);
                return TRUE;
            }
        }while(FindNextFile(hFind, &FindFileData));
        FindClose(hFind);
    }
    return FALSE;
}

INT_PTR CALLBACK ADMDesc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(wParam);

    switch (message)
    {
        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_INITDIALOG:
            return(FALSE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_ADMWIN32:
                    g_dwADMPlatformId = PLATFORM_WIN32;
                    break;

                case IDC_ADMWIN2K:
                    g_dwADMPlatformId = PLATFORM_W2K;
                    break;
            }
            break;
        
        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    if (InsGetBool(IS_ADM, IK_ADMIN, 1, g_szCustIns))
                    {
                        CheckRadioButton(hDlg, IDC_ADMWIN32, IDC_ADMWIN2K, IDC_ADMWIN32);
                        g_dwADMPlatformId = PLATFORM_WIN32;
                    }
                    else
                    {
                        CheckRadioButton(hDlg, IDC_ADMWIN32, IDC_ADMWIN2K, IDC_ADMWIN2K);
                        g_dwADMPlatformId = PLATFORM_W2K;
                    }
                    
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    InsWriteBoolEx(IS_ADM, IK_ADMIN, (g_dwADMPlatformId == PLATFORM_WIN32) ? 1 : 0, g_szCustIns);
                    InsFlushChanges(g_szCustIns);

                    g_iCurPage = PPAGE_ADMDESC;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                        PageNext(hDlg);
                    else
                        PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;
            }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\cabclass.cpp ===
#include "precomp.h"
#include "cabclass.h"

extern TCHAR g_szBuildTemp[];
extern TCHAR g_szWizRoot[];
extern TCHAR g_szCustInf[];
extern TCHAR g_szCustIns[];
extern TCHAR g_szUnsignedFiles[];
extern BOOL g_fDownload;


const TCHAR *CCabMappings::c_szCabNameArray[] = {
    { TEXT("BRANDING") },
    { TEXT("CHNLS") },
    { TEXT("DESKTOP")  },
    { TEXT("")         }                        // keep the last entry the empty string
};

const FEATUREMAPPING CCabMappings::c_fmFeatureList[] = {
    { 0, TEXT("")         },
    { 0, TEXT("FAVS")     },
    { 0, TEXT("CONNECT")  },
    { 1, TEXT("BASE")     },
    { 2, TEXT("DESKCOMP") },
    { 2, TEXT("TOOLBAR")  },
    { 2, TEXT("MYCPTR")   },
    { 2, TEXT("CTLPANEL") },
    { 0, TEXT("LDAP")     },
    { 0, TEXT("OE")       },
    { 2, TEXT("WALLPAPR") },
    { 0, TEXT("BTOOLBAR") }
};

void CCabMappings::GetFeatureDir(FEATURE feature, LPTSTR pszDir, BOOL fFullyQualified)
{
    if (fFullyQualified)
    {
        PathCombine(pszDir, g_szBuildTemp, c_szCabNameArray[c_fmFeatureList[feature].index]);
        CreateDirectory(pszDir, NULL);
        PathAppend(pszDir, c_fmFeatureList[feature].szDirName);
        CreateDirectory(pszDir, NULL);
    }
    else
        PathCombine(pszDir, c_szCabNameArray[c_fmFeatureList[feature].index],
            c_fmFeatureList[feature].szDirName);

    CharLower(pszDir);
}

HRESULT CCabMappings::MakeCab(int index, LPCTSTR pcszDestDir, LPCTSTR pcszCabName)
{
    TCHAR szCmd[MAX_PATH * 3];
    TCHAR szExePath[MAX_PATH];
    TCHAR szCabPath[MAX_PATH];
    TCHAR szSrcPath[MAX_PATH];

    PathCombine(szExePath, g_szWizRoot, TEXT("TOOLS"));
    PathAppend(szExePath, TEXT("CABARC.EXE"));

    if (pcszCabName == NULL)
    {
        PathCombine(szCabPath, pcszDestDir, c_szCabNameArray[index]);
        StrCat(szCabPath, TEXT(".CAB"));
    }
    else
        PathCombine(szCabPath, pcszDestDir, pcszCabName);

    PathCombine(szSrcPath, g_szBuildTemp, c_szCabNameArray[index]);
    PathAppend(szSrcPath, TEXT("*.*"));
    wnsprintf(szCmd, countof(szCmd), TEXT("%s -r N %s %s"), szExePath, szCabPath, szSrcPath);

    if (!RunAndWait(szCmd, g_szBuildTemp, SW_HIDE))
        return E_FAIL;

    if (g_fDownload)
        SignFile(PathFindFileName(szCabPath), g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);

    return S_OK;
}

HRESULT CCabMappings::MakeCabs(LPCTSTR pcszDestDir)
{
    for (int i=0; *c_szCabNameArray[i]; i++)
    {
        if (MakeCab(i, pcszDestDir, NULL) != S_OK)
            return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\buildie.cpp ===
#include "precomp.h"
#include "ie4comp.h"
#include "ieaklite.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szMastInf[];
extern TCHAR g_szDefInf[];
extern TCHAR g_szSignup[];
extern TCHAR g_szBuildTemp[];
extern TCHAR g_szIEAKProg[];
extern TCHAR g_szWizRoot[];
extern TCHAR g_szWizPath[];
extern TCHAR g_szLanguage[];
extern TCHAR g_szActLang[];
extern TCHAR g_szTempSign[];
extern TCHAR g_szBuildRoot[];
extern TCHAR g_szSrcRoot[];
extern TCHAR g_szCustInf[];
extern TCHAR g_szAllModes[];
extern TCHAR g_szDeskTemp[];
extern TCHAR g_szUnsignedFiles[];
extern TCHAR g_szTitle[];
extern TCHAR g_szInstallFolder[];
extern TCHAR g_szCifVer[];
extern TCHAR g_szDestCif[];
extern TCHAR g_szCif[];
extern TCHAR g_szCustCif[];
extern TCHAR g_szCustItems[];
extern TCHAR g_szMyCptrPath[];
extern TCHAR g_szCtlPanelPath[];
extern TCHAR g_szCustIcmPro[];
extern TCHAR g_szKey[];
extern TCHAR g_szJobVersion[];

extern BOOL g_fIntranet, g_fNoSignup, g_fServerless, g_fServerKiosk, g_fServerICW, g_fInteg, g_fOCW, g_fBranded;
extern BOOL g_fSilent, g_fStealth;
extern BOOL g_fCD, g_fLAN, g_fDownload, g_fBrandingOnly;
extern BOOL g_fBatch;
extern BOOL g_fBatch2;
extern BOOL g_fCustomICMPro;
extern BOOL g_fDone, g_fCancelled;
extern BOOL g_fUseIEWelcomePage;

extern UINT g_uiNumCabs;
extern int g_iInstallOpt;
extern int g_nCustComp;
extern int g_iSelOpt;
extern int g_nModes;
extern int g_iSelSite;
extern int g_nDownloadUrls;

extern PCOMPONENT g_paComp;
extern COMPONENT g_aCustComponents[20];
extern SITEDATA g_aCustSites[NUMSITES];
extern SHFILEOPSTRUCT g_shfStruc;

extern HWND g_hStatusDlg;
extern HWND g_hProgress;
extern HANDLE g_hDownloadEvent;

extern HRESULT CabUpFolder(HWND hWnd, LPTSTR szFolderPath, LPTSTR szDestDir, LPTSTR szCabname,
    LPTSTR szDisplayName, LPTSTR szGuid, LPTSTR szAddReg);
extern void WriteModesToCif(CCifRWComponent_t * pCifRWComponent_t, LPCTSTR pcszModes);
extern void UpdateProgress(int);
extern BOOL AnySelection(PCOMPONENT pComp);
extern BOOL CopyISK( LPTSTR szDestPath, LPTSTR szSourcePath );
extern void BuildIE4Folders(HWND hWnd);

static TCHAR s_szIE4SetupDir[MAX_PATH];
static DWORD s_dwTicksPerUnit;


// Private forward decalarations
static void WritePIDValues(LPCTSTR pcszInsFile, LPCTSTR pcszSetupInf);
static void WriteURDComponent(CCifRWFile_t *lpCifRWFileDest, LPCTSTR pcszModes);
void SetCompSize(LPTSTR szCab, LPTSTR szSect, DWORD dwInstallSize);

// BUGBUG: <oliverl> should probably persist this server side only info in a server side file for IEAK6
void SaveSignupFiles()
{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    TCHAR szIndex[8];
    TCHAR szSignupFiles[MAX_PATH];
    int i = 0;

    WritePrivateProfileString(IS_SIGNUP, NULL, NULL, g_szCustIns);

    PathCombine(szSignupFiles, g_szSignup, TEXT("*"));
    hFind = FindFirstFile(szSignupFiles, &fd);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        while (1)
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                && (StrCmp(fd.cFileName, TEXT(".")) != 0)
                && (StrCmp(fd.cFileName, TEXT("..")) != 0))
            {
                wnsprintf(szIndex, countof(szIndex), FILE_TEXT, i++);
                WritePrivateProfileString(IS_SIGNUP, szIndex, fd.cFileName, g_szCustIns);
            }

            if (!FindNextFile(hFind, &fd))
                break;
        }

        FindClose(hFind);
    }
}


DWORD CopyIE4Files(void)
{
    DWORD res;
    HRESULT hr;
    int i;
    TCHAR szSectBuf[1024];
    PCOMPONENT pComp;
    TCHAR szTemp[MAX_PATH];
    TCHAR szTo[5 * MAX_PATH];
    TCHAR szFrom[2 * MAX_PATH];
    TCHAR szCDF[MAX_PATH];
    TCHAR szActSetupTitle[MAX_PATH];

    ZeroMemory(szFrom, sizeof(szFrom));
    SetAttribAllEx(g_szBuildTemp, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);
    g_shfStruc.pFrom = szFrom;
    PathCombine(szFrom, g_szWizRoot, TEXT("TOOLS"));
    res = CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szBuildTemp);
    if (res) return(res);
    PathCombine(szFrom, g_szWizRoot, TEXT("IEBIN"));
    PathAppend(szFrom, g_szLanguage);
    PathAppend(szFrom, TEXT("OPTIONAL"));

    PathRemoveBackslash(szFrom);
    res = CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szBuildTemp);
    if (res) return(res);

    PathCombine(szCDF, g_szBuildTemp, TEXT("bootie42.cdf"));
    if (!PathFileExists(szCDF) || !SetFileAttributes(szCDF, FILE_ATTRIBUTE_NORMAL))
        return (DWORD) -1;

    PathCombine(g_szTempSign, g_szBuildTemp, TEXT("CUSTSIGN"));
    CreateDirectory(g_szTempSign, NULL);

    if (ISNONNULL(g_szSignup))
    {
        DeleteFileInDir(TEXT("signup.txt"), g_szTempSign);

        // if ICW signup method is specified, create the signup.txt file
        if (g_fServerICW)
        {
            TCHAR szIspFile[MAX_PATH];
            TCHAR szEntryName[MAX_PATH];
            TCHAR szBuf[MAX_PATH * 2];
            HANDLE hFile;

            PathCombine(szIspFile, g_szTempSign, TEXT("signup.txt"));

            if ((hFile = CreateFile(szIspFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
            {
                HANDLE hFind;
                WIN32_FIND_DATA fd;

                LoadString(g_rvInfo.hInst, IDS_ISPINFILEHEADER, szBuf, countof(szBuf));
                WriteStringToFile(hFile, szBuf, StrLen(szBuf));

                PathCombine(szIspFile, g_szSignup, TEXT("*.isp"));

                hFind = FindFirstFile(szIspFile, &fd);

                if (hFind != INVALID_HANDLE_VALUE)
                {
                    do
                    {
                        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            || (StrCmp(fd.cFileName, TEXT(".")) == 0)
                            || (StrCmp(fd.cFileName, TEXT("..")) == 0))
                            continue;

                        PathCombine(szIspFile, g_szSignup, fd.cFileName);
                        GetPrivateProfileString(TEXT("Entry"), TEXT("Entry_Name"), TEXT(""), szEntryName,
                            countof(szEntryName), szIspFile);
                        wnsprintf(szBuf, countof(szBuf), TEXT("%s,\"%s\"\r\n"), fd.cFileName, szEntryName);
                        WriteStringToFile(hFile, szBuf, StrLen(szBuf));
                    }
                    while (FindNextFile(hFind, &fd));

                    FindClose(hFind);
                }

                CloseHandle(hFile);
            }
        }

        SaveSignupFiles();

        // NOTE: ApplyIns logic should happen *before* copying signup files to the temp folder
        // IMPORTANT (pritobla):
        // Apply INS function just appends the content of g_szCustIns to the signup ins files.
        // At this point, there are no common sections between g_szCustIns and the signup ins files.
        // Any other setting that's gonna be added (for example: WriteNoClearToINSFiles() call below),
        //   should be done *after* this call.
        ApplyINSFiles(g_szSignup, g_szCustIns);

        // should write NoClear=1 to the [Branding] section to preserve the settings applied by install.ins
        WriteNoClearToINSFiles(g_szSignup);

        // copy all the files from the signup folder to the temp dir
        res = CopyFilesSrcToDest(g_szSignup, TEXT("*.*"), g_szTempSign);

        if (g_fServerless)
        {
            TCHAR szSignupIsp[MAX_PATH];

            // (pritobla)
            // NOTE: Since the signup folder is separate for each signup mode (ICW, kiosk & serverless),
            //       there is no need to delete *.isp and *.cab files.  But I'm doing it anyways just in
            //       case they copied files from a server-based folder.  Downside of this is that even if
            //       the ISP wants to include .isp or .cab files (for whatever reason), they can't do so.

            // for serverless signup, don't need any .isp or *.cab files; so delete them.
            DeleteFileInDir(TEXT("*.isp"), g_szTempSign);
            DeleteFileInDir(TEXT("*.cab"), g_szTempSign);

            // BUGBUG: should write Serverless=1 to the INS files in the signup folder and not in the temp folder
            // should write Serverless=1 in the [Branding] section to avoid being whacked by ICW
            FixINSFiles(g_szTempSign);

            // BUGBUG: we should add signup.isp to the Signup section in install.ins for IEAKLite mode cleanup
            // write the magic number to signup.isp in the temp location so that ICW doesn't complain
            PathCombine(szSignupIsp, g_szTempSign, TEXT("signup.isp"));
            WritePrivateProfileString(IS_BRANDING, FLAGS, TEXT("16319"), szSignupIsp);

            WritePrivateProfileString(NULL, NULL, NULL, szSignupIsp);
        }
        else
        {
            // server based signup -- don't need any .ins or .cab files
            DeleteINSFiles(g_szTempSign);
            DeleteFileInDir(TEXT("*.cab"), g_szTempSign);

            // IMPORTANT: the fact that we are deleting *.ins means that copying of install.ins
            //            from the target dir should happen after this

            // For ICW signup, even though we specify icwsign.htm as the html file, inetcfg.dll checks for
            // the existence of signup.htm (old code) and if it isn't there, it will launch ICW in normal mode.
            // Hack here is to copy icwsign.htm as signup.htm if it doesn't exist already (it would exist already
            // if Single Disk Branding media and ICW signup mode are selected).
            if (g_fServerICW)
            {
                if (!PathFileExistsInDir(TEXT("signup.htm"), g_szTempSign))
                {
                    TCHAR szICWSign[MAX_PATH],
                          szSignup[MAX_PATH];

                    PathCombine(szICWSign, g_szTempSign, TEXT("icwsign.htm"));
                    PathCombine(szSignup, g_szTempSign, TEXT("signup.htm"));

                    // BUGBUG: we should add signup.htm to the Signup section in install.ins for IEAKLite mode cleanup
                    CopyFile(szICWSign, szSignup, FALSE);
                }
            }
        }
    }

    // IMPORTANT: install.ins should be copied only after signup files have been processed.
    // copy install.ins from the target dir to the temp location
    ZeroMemory(szFrom, 2*MAX_PATH);
    StrCpy(szFrom, g_szCustIns);
    PathCombine(szTo, g_szTempSign, PathFindFileName(szFrom));
    CopyFile(szFrom, szTo, FALSE);

    // write pid values and clear from the INS in the temp dir, if necessary

    if (!g_fBatch && !g_fBatch2)
        WritePIDValues(szTo, g_szCustInf);

    PathCombine(szTemp, g_szBuildRoot, TEXT("INS"));
    PathAppend(szTemp, GetOutputPlatformDir());
    PathAppend(szTemp, g_szLanguage);
    res |= CopyFilesSrcToDest(szTemp,  TEXT("*.inf"), g_szTempSign);

    PathCombine(szTemp, g_szTempSign,  TEXT("iesetup.inf"));
    DeleteFile(szTemp);

    ZeroMemory(szFrom, MAX_PATH);
    g_shfStruc.pFrom = szFrom;

    g_shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;
    g_shfStruc.pTo = g_szBuildTemp;

    if (!g_fBatch && !g_fBatch2)
    {
        ICifRWComponent * pCifRWComponent;
        CCifRWComponent_t * pCifRWComponent_t;
        DWORD dwVer, dwBuild;
        TCHAR szVersion[32];

        g_lpCifRWFileVer->Flush();
        for (pComp = g_paComp; *pComp->szSection; pComp++ )
        {
            g_lpCifRWFile->CreateComponent(pComp->szSection, &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->GetVersion(&dwVer, &dwBuild);
            ConvertDwordsToVersionStr(szVersion, dwVer, dwBuild);
            if (pComp->iImage != RED && (StrCmpI(szVersion, pComp->szVersion)))
                pCifRWComponent_t->CopyComponent(g_szCifVer);
            delete pCifRWComponent_t;
        }
        g_lpCifRWFile->Flush();
    }

    PathCombine(g_szDestCif, g_szBuildTemp, TEXT("iesetup.cif"));
    CopyFile(g_szCif, g_szDestCif, FALSE);

    hr = GetICifRWFileFromFile_t(&g_lpCifRWFileDest, g_szDestCif);

    {
        TCHAR szActSetupBitmap2[MAX_PATH];

        if (GetPrivateProfileString( IS_ACTIVESETUP, IK_WIZBMP, TEXT(""),
            szActSetupBitmap2, countof(szActSetupBitmap2), g_szCustIns ))
        {
            InsWriteQuotedString( TEXT("Strings"), TEXT("FILE15"), TEXT("ActSetup.Bmp"), szCDF );
            WritePrivateProfileString( TEXT("SourceFiles0"), TEXT("%FILE15%"), TEXT(""), szCDF );
            InsWriteQuotedString(BRANDING, IK_WIZBMP, TEXT("actsetup.bmp"), g_szCustInf);
        }

        if (GetPrivateProfileString( IS_ACTIVESETUP, IK_WIZBMP2, TEXT(""),
            szActSetupBitmap2, countof(szActSetupBitmap2), g_szCustIns ))
        {
            InsWriteQuotedString( TEXT("Strings"), TEXT("FILE16"), TEXT("topsetup.Bmp"), szCDF );
            WritePrivateProfileString( TEXT("SourceFiles0"), TEXT("%FILE16%"), TEXT(""), szCDF );
            InsWriteQuotedString(BRANDING, IK_WIZBMP2, TEXT("topsetup.bmp"), g_szCustInf);
        }

        if (GetPrivateProfileString( IS_ACTIVESETUP, IK_WIZTITLE, TEXT(""),
            szActSetupTitle, countof(szActSetupTitle), g_szCustIns ))
        {
            InsWriteQuotedString( BRANDING, IK_WIZTITLE, szActSetupTitle, g_szCustInf );
            g_lpCifRWFileDest->SetDescription(szActSetupTitle);
            WritePrivateProfileString(TEXT("Version"), TEXT("DisplayName"), szActSetupTitle, g_szCustInf);
        }

        if (InsGetBool(IS_BRANDING, IK_ALT_SITES_URL, FALSE, g_szCustIns))
            InsWriteBool(IS_CUSTOM, IK_ALT_SITES_URL, TRUE, g_szCustInf);
    }
    
    if (g_fCustomICMPro)
    {
        ICifRWComponent * pCifRWComponent;
        CCifRWComponent_t * pCifRWComponent_t;
        TCHAR szTempBuf[MAX_PATH];

        g_lpCifRWFileDest->CreateComponent(CUSTCMSECT, &pCifRWComponent);
        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
        GetPrivateProfileString( CUSTCMSECT, TEXT("DisplayName"), TEXT(""), szSectBuf, countof(szSectBuf), g_szCustCif );
        pCifRWComponent_t->SetDescription(szSectBuf);
        GetPrivateProfileString( CUSTCMSECT, TEXT("GUID"), TEXT(""),  szSectBuf, countof(szSectBuf),  g_szCustCif );
        pCifRWComponent_t->SetGUID(szSectBuf);
        GetPrivateProfileString( CUSTCMSECT, TEXT("Command1"), TEXT(""), szSectBuf,  countof(szSectBuf),g_szCustCif );
        GetPrivateProfileString( CUSTCMSECT, TEXT("Switches1"), TEXT(""), szTempBuf, countof(szTempBuf), g_szCustCif );
        pCifRWComponent_t->SetCommand(0, szSectBuf, szTempBuf, 2);
        GetPrivateProfileString( CUSTCMSECT, TEXT("URL1"), TEXT(""), szSectBuf, countof(szSectBuf), g_szCustCif );
        pCifRWComponent_t->SetUrl(0, szSectBuf, 2);
        pCifRWComponent_t->SetGroup(TEXT("BASEIE4"));
        pCifRWComponent_t->SetPriority(1);
        GetPrivateProfileString( CUSTCMSECT, VERSION, g_szJobVersion, szTempBuf, countof(szTempBuf), g_szCustCif );
        pCifRWComponent_t->SetVersion(szTempBuf);
        pCifRWComponent_t->SetUIVisible(FALSE);
        WriteModesToCif(pCifRWComponent_t, g_szAllModes);
        delete pCifRWComponent_t;
    }
    else
    {
        g_lpCifRWFileDest->DeleteComponent(CUSTCMSECT);
    }
    WritePrivateProfileString(NULL, NULL, NULL, g_szCustIns);

    WritePrivateProfileString( TEXT("SourceFiles"), TEXT("SourceFiles0"), TEXT(".\\"), szCDF );
    WritePrivateProfileString(NULL, NULL, NULL, szCDF);

    for (pComp = g_aCustComponents, i = 0; i < g_nCustComp ; pComp++, i++)
    {
        ICifRWComponent * pCifRWComponent;
        CCifRWComponent_t * pCifRWComponent_t;

        g_lpCifRWFileDest->CreateComponent(pComp->szSection, &pCifRWComponent);
        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
        pCifRWComponent_t->SetDescription(pComp->szDisplayName);

        if (pComp->iInstallType != 2)
        {
            pCifRWComponent_t->SetUrl(0, pComp->szUrl, (pComp->iType != INST_CAB) ? 2 : 3);
            pCifRWComponent_t->SetCommand(0, pComp->szCommand, pComp->szSwitches, pComp->iType);
        }
        else
        {
            TCHAR szCmd[MAX_PATH * 2];
            TCHAR szCabName[64];
            TCHAR szInf[MAX_PATH];

            wnsprintf(szCabName, countof(szCabName), TEXT("%s.cab"), pComp->szSection);
            PathCombine(szInf, g_szBuildTemp, TEXT("postinst.inf"));

            wnsprintf(szCmd, countof(szCmd), TEXT("%03d"), 2*i+1);
            InsWriteString(IS_STRINGS, TEXT("JobNumber"), szCmd, szInf);
            wnsprintf(szCmd, countof(szCmd), TEXT("%03d"), 2*i);
            InsWriteString(IS_STRINGS, TEXT("JobNumberMinusOne"), szCmd, szInf);
            WritePrivateProfileString(IS_STRINGS, TEXT("CustomFile"), PathFindFileName(pComp->szPath), szInf);
            
            if (pComp->iType != INST_CAB)
            {
                InsWriteString(DEFAULT_INSTALL, TEXT("AddReg"), TEXT("PostRebootExeJob.Add"), szInf);
                InsWriteString(DEFAULT_INSTALL, TEXT("RunPostSetupCommands"), NULL, szInf);
            }
            else
            {
                InsWriteString(DEFAULT_INSTALL, TEXT("AddReg"), TEXT("PostRebootCabJob.Add"), szInf);
                InsWriteString(DEFAULT_INSTALL, TEXT("RunPostSetupCommands"), TEXT("Cab.MoveFile"), szInf);
            }

            WritePrivateProfileString(IS_STRINGS, TEXT("Command"), pComp->szCommand, szInf);
            WritePrivateProfileString(IS_STRINGS, TEXT("Switches"), pComp->szSwitches, szInf);
            WritePrivateProfileString(NULL, NULL, NULL, szInf);

            pCifRWComponent_t->SetUrl(0, szCabName, 3);
            pCifRWComponent_t->SetCommand(0, TEXT("postinst.inf"), TEXT(""), 0);
            CopyFileToDir(pComp->szPath, g_szBuildTemp);
            wnsprintf(szCmd, countof(szCmd), TEXT("%s\\cabarc n %s postinst.inf \"%s\""), g_szBuildTemp, szCabName, PathFindFileName(pComp->szPath));
            RunAndWait(szCmd, g_szBuildTemp, SW_HIDE);
            DeleteFileInDir(pComp->szPath, g_szBuildTemp);
            SignFile(szCabName, g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);
        }
        
        pCifRWComponent_t->SetGUID(pComp->szGUID);

        pCifRWComponent_t->SetUninstallKey(pComp->szUninstall);
        pCifRWComponent_t->SetVersion(pComp->szVersion);
        pCifRWComponent_t->SetDownloadSize(pComp->dwSize);
        WriteModesToCif(pCifRWComponent_t, pComp->szModes);
        pCifRWComponent_t->SetDetails(pComp->szDesc);

        // BUGBUG: <oliverl> we should really have an inseng interface method for setting this

        if (pComp->fIEDependency)
            InsWriteString(pComp->szSection, TEXT("Dependencies"), TEXT("BASEIE40_Win:N"), g_szDestCif);

        if (pComp->iInstallType == 1)
            pCifRWComponent_t->SetGroup(TEXT("PreCustItems"));
        else
        {
            pCifRWComponent_t->SetGroup(TEXT("CustItems"));

            if (pComp->iInstallType == 2)
                pCifRWComponent_t->SetReboot(TRUE);
        }

        pCifRWComponent_t->SetPriority(500-i);
        delete pCifRWComponent_t;
    }

    if (i > 0)
    {
        if(ISNULL(g_szCustItems))
            LoadString(g_rvInfo.hInst, IDS_CUSTOMCOMPTITLE, g_szCustItems, MAX_PATH);

        ICifRWGroup * pCifRWGroup;
        CCifRWGroup_t * pCifRWGroup_t;

        g_lpCifRWFileDest->CreateGroup(TEXT("CustItems"), &pCifRWGroup);
        pCifRWGroup_t = new CCifRWGroup_t(pCifRWGroup);
        pCifRWGroup_t->SetDescription(g_szCustItems);
        pCifRWGroup_t->SetPriority(500);
        delete pCifRWGroup_t;

        g_lpCifRWFileDest->CreateGroup(TEXT("PreCustItems"), &pCifRWGroup);
        pCifRWGroup_t = new CCifRWGroup_t(pCifRWGroup);
        pCifRWGroup_t->SetDescription(g_szCustItems);
        pCifRWGroup_t->SetPriority(950);
        delete pCifRWGroup_t;
    }

    if (!g_fBatch)
    {
        PCOMPONENT pComp;
        ICifRWComponent * pCifRWComponent;


        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
        {
            if (pComp->fCustomHide)
            {
                g_lpCifRWFileDest->CreateComponent(pComp->szSection, &pCifRWComponent);
                pCifRWComponent->SetUIVisible(FALSE);
            }

        }

        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (pComp->fCustomHide)
            {
                g_lpCifRWFileDest->CreateComponent(pComp->szSection, &pCifRWComponent);
                pCifRWComponent->SetUIVisible(FALSE);
            }
            else
            {
                // aolsupp component is set invisible by default in the cif, but IEAK admins
                // can choose to make it visible

                if (StrCmpI(pComp->szSection, TEXT("AOLSUPP")) == 0)
                {
                    g_lpCifRWFileDest->CreateComponent(pComp->szSection, &pCifRWComponent);
                    pCifRWComponent->SetUIVisible(TRUE);
                }
            }
        }
    }

    if (InsGetBool(IS_HIDECUST, IK_URD_STR, FALSE, g_szCustIns))
        WriteURDComponent(g_lpCifRWFileDest, g_szAllModes);

    // -----------------------------------------
    // begin temporary copies to old locations

    if (ISNULL(g_szDeskTemp))
    {
        StrCpy(g_szDeskTemp, g_szBuildRoot);
        PathAppend(g_szDeskTemp, TEXT("Desktop"));
        CreateDirectory( g_szDeskTemp, NULL );
    }

    // connection settings files
    g_cmCabMappings.GetFeatureDir(FEATURE_CONNECT, szFrom);
    if (PathIsDirectory(szFrom))
        if (RemoveDirectory(szFrom))
            ;                                   // asta la vista
        else
            CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szTempSign);

    // desktop files
    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szFrom);
    PathCombine(szTemp, szFrom, TEXT("desktop.inf"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("desktop.inf"), g_szTempSign);

    g_cmCabMappings.GetFeatureDir(FEATURE_DESKTOPCOMPONENTS, szFrom);
    if (PathIsDirectory(szFrom)  &&  !RemoveDirectory(szFrom))
        CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szDeskTemp);

    // toolbar files
    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szFrom);
    PathCombine(szTemp, szFrom, TEXT("toolbar.inf"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("toolbar.inf"), g_szTempSign);

    g_cmCabMappings.GetFeatureDir(FEATURE_TOOLBAR, szFrom);
    if (PathIsDirectory(szFrom)  &&  !RemoveDirectory(szFrom))
        CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szDeskTemp);

    // favorites/quick links files
    g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szFrom);
    if (PathIsDirectory(szFrom))
        if (RemoveDirectory(szFrom))
            ;                                   // asta la vista
        else
            CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szTempSign);

    // ISP Root Cert
    if (GetPrivateProfileString(IS_ISPSECURITY, IK_ROOTCERT, TEXT(""),
        szTemp, countof(szTemp), g_szCustIns))
    {
        g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szFrom);
        CopyFilesSrcToDest(szFrom, PathFindFileName(szTemp), g_szTempSign);
    }

    // browser toolbar buttons
    if (GetPrivateProfileString(IS_BTOOLBARS, IK_BTCAPTION TEXT("0"), TEXT(""),
        szTemp, countof(szTemp), g_szCustIns))
    {
        g_cmCabMappings.GetFeatureDir(FEATURE_BTOOLBAR, szFrom);
        CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szTempSign);
    }

    // My Computer files
    if (ISNONNULL(g_szMyCptrPath))
    {
        g_cmCabMappings.GetFeatureDir(FEATURE_MYCPTR, szFrom);
        CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szDeskTemp);
    }

    // Control Panel files
    if (ISNONNULL(g_szCtlPanelPath))
    {
        g_cmCabMappings.GetFeatureDir(FEATURE_CTLPANEL, szFrom);
        CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szDeskTemp);
    }

    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szFrom);
    CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szTempSign);

    g_cmCabMappings.GetFeatureDir(FEATURE_WALLPAPER, szFrom);
    if (PathIsDirectory(szFrom)  &&  !RemoveDirectory(szFrom))
        CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szDeskTemp);

    // sitecert files
    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szFrom);
    PathCombine(szTemp, szFrom, TEXT("sitecert.inf"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("sitecert.inf"), g_szTempSign);
    PathCombine(szTemp, szFrom, TEXT("root.str"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("root.str"), g_szTempSign);
    PathCombine(szTemp, szFrom, TEXT("root.dis"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("root.dis"), g_szTempSign);
    PathCombine(szTemp, szFrom, TEXT("ca.str"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("ca.str"), g_szTempSign);

    // authcode files
    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szFrom);
    PathCombine(szTemp, szFrom, TEXT("authcode.inf"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("authcode.inf"), g_szTempSign);

    // seczones files
    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szFrom);
    PathCombine(szTemp, szFrom, TEXT("seczones.inf"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("seczones.inf"), g_szTempSign);

    // ratings files
    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szFrom);
    PathCombine(szTemp, szFrom, TEXT("ratings.inf"));
    if (PathFileExists(szTemp))
        CopyFilesSrcToDest(szFrom, TEXT("ratings.inf"), g_szTempSign);

    // LDAP component
    g_cmCabMappings.GetFeatureDir(FEATURE_LDAP, szFrom);
    if (PathIsDirectory(szFrom))
        if (RemoveDirectory(szFrom))
            ;                                   // asta la vista
        else
            CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szTempSign);

    // OE component
    g_cmCabMappings.GetFeatureDir(FEATURE_OE, szFrom);
    if (PathIsDirectory(szFrom))
        if (RemoveDirectory(szFrom))
            ;                                   // asta la vista
        else
            CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szTempSign);

    if (g_fBatch)
    {
        StrCpy(szFrom, g_szWizPath);
        PathAppend(szFrom, TEXT("Branding"));
        CopyFilesSrcToDest(szFrom, TEXT("*.*"), g_szTempSign);
    }

    return(0);
}


void DeleteUnusedComps(LPCTSTR pcszCompDir)
{
    PCOMPONENT pComp;
    UINT uiIndex;
    DWORD dwFlags;
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    LPTSTR pszCab;
    ICifComponent * pCifComponent;

    DeleteFileInDir(TEXT("install.ins"), pcszCompDir);
    DeleteFileInDir(TEXT("iesetup.cif"), pcszCompDir);
    DeleteFileInDir(TEXT("iesetup.inf"), pcszCompDir);

    if (g_fBatch)
        return;

    for (pComp = g_paComp; *pComp->szSection; pComp++)
    {
        if ((pComp->iCompType != COMP_OPTIONAL) || (pComp->iImage == RED) ||
            AnySelection(pComp) || !pComp->fCustomHide || !pComp->fNoCopy || pComp->fAVSDupe)
        {
            if ((pComp->iCompType == COMP_OPTIONAL) && !pComp->fVisible)
            {
                PCOMPONENT pCompDep;
                int i;

                for (pCompDep = pComp->paCompRevDeps[0], i = 0; pCompDep; pCompDep = pComp->paCompRevDeps[++i])
                {
                    if (AnySelection(pCompDep) || ((!pCompDep->fCustomHide || !pCompDep->fNoCopy) && pCompDep->fVisible))
                        break;
                }

                if (pCompDep)
                    continue;
            }
            else
                continue;

            if (pComp->fAVSDupe)
                continue;
        }
        if (SUCCEEDED(g_lpCifRWFileDest->FindComponent(pComp->szSection, &pCifComponent)))
        {
            CCifComponent_t * pCifComponent_t =
                new CCifComponent_t((ICifRWComponent *)pCifComponent);

            uiIndex = 0;
            while (SUCCEEDED(pCifComponent_t->GetUrl(uiIndex, szUrl, countof(szUrl), &dwFlags)))
            {
                if (dwFlags & URLF_RELATIVEURL)
                    pszCab = szUrl;
                else
                {
                    pszCab = StrRChr(szUrl, NULL, TEXT('/'));
                    if (pszCab)
                        pszCab++;
                    else
                        pszCab = szUrl;
                }
                DeleteFileInDir(pszCab, pcszCompDir);
                uiIndex++;
            }

            delete pCifComponent_t;
        }
    }

    for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
    {
        if (!AnySelection(pComp) && pComp->fCustomHide && pComp->fNoCopy)
        {
            pszCab = PathFindFileName(pComp->szPath);
            DeleteFileInDir(pszCab, pcszCompDir);
        }
    }
}

BOOL BuildLAN(DWORD dwTicks)
{
    TCHAR szIE4SetupTo[MAX_PATH];
    LPTSTR pszFileName;
    TCHAR szLANFrom[MAX_PATH * 10];
    TCHAR szLANTo[MAX_PATH];
    TCHAR szBuildLAN[MAX_PATH];
    PCOMPONENT pComp;
    SHELLEXECUTEINFO shInfo;
    int res;

    ZeroMemory(&shInfo, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    g_shfStruc.wFunc = FO_COPY;

    StrCpy(szBuildLAN, g_szBuildRoot);
    if (!g_fOCW)
    {
        PathAppend(szBuildLAN, TEXT("FLAT"));
        PathAppend(szBuildLAN, GetOutputPlatformDir());
    }
    PathAppend(szBuildLAN, g_szLanguage);

    PathCreatePath(szBuildLAN);

    res = CopyFilesSrcToDest(g_szIEAKProg, TEXT("*.*"), szBuildLAN, dwTicks);

    if (res)
        return FALSE;

    pszFileName = StrRChr(s_szIE4SetupDir, NULL, TEXT('\\'));

    if (pszFileName)
        pszFileName++;

    PathCombine(szIE4SetupTo, szBuildLAN, pszFileName);
    CopyFile(s_szIE4SetupDir,szIE4SetupTo,FALSE);

    // copy custom cabs

    res = CopyFilesSrcToDest(g_szBuildTemp, TEXT("*.CAB"), szBuildLAN);

    if (res)
        return FALSE;

    // copy custom components

    ZeroMemory(szLANFrom, sizeof(szLANFrom));
    for (pComp = g_aCustComponents, pszFileName = szLANFrom; ; pComp++ )
    {
        if (!(*pComp->szSection)) break;

        if (pComp->iInstallType == 2)
            continue;

        StrCpy(pszFileName, pComp->szPath);
        pszFileName += lstrlen(pszFileName) + 1;
    }

    if (ISNONNULL(szLANFrom))
    {
        g_shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;
        g_shfStruc.pFrom = szLANFrom;
        g_shfStruc.pTo = szBuildLAN;

        res = SHFileOperation(&g_shfStruc);
        if (res)
            return FALSE;
    }

    // copy URD component
    if (InsGetBool(IS_HIDECUST, IK_URD_STR, FALSE, g_szCustIns))
    {
        TCHAR szURDPath[MAX_PATH];

        PathCombine(szURDPath, g_szBuildTemp, IE55URD_EXE);
        CopyFileToDir(szURDPath, szBuildLAN);
    }


    // copy iesetup.ini

    PathCombine(szLANTo, szBuildLAN, TEXT("iesetup.ini"));
    PathCombine(szLANFrom, g_szBuildTemp, TEXT("iesetup.ini"));
    CopyFile(szLANFrom, szLANTo, FALSE);

    // copy ICM profile

    if (g_fCustomICMPro)
    {
        PathCombine(szLANTo, szBuildLAN, PathFindFileName(g_szCustIcmPro));
        CopyFile(g_szCustIcmPro, szLANTo, FALSE);
    }

    DeleteUnusedComps(szBuildLAN);

    return TRUE;
}

void SetCompSize(LPTSTR szCab, LPTSTR szSect, DWORD dwInstallSize)
{
    DWORD dwDownloadSize, dwTolerance, dwsHi, dwLowSize, dwHighSize;
    HANDLE hCab = CreateFile(szCab, GENERIC_READ, 0, NULL, OPEN_EXISTING, NULL, NULL);
    TCHAR szSize[32];

    if (hCab == INVALID_HANDLE_VALUE)
        return;

    dwDownloadSize = GetFileSize( hCab, &dwsHi ) >> 10;
    if (dwInstallSize ==0)
        dwInstallSize = dwDownloadSize << 1;
    CloseHandle(hCab);
    wnsprintf(szSize, countof(szSize), TEXT("%i,%i"), dwDownloadSize, dwInstallSize);

    ICifRWComponent * pCifRWComponent;

    if (SUCCEEDED(g_lpCifRWFileDest->CreateComponent(szSect, &pCifRWComponent)))
    {
        pCifRWComponent->SetDownloadSize(dwDownloadSize);
        pCifRWComponent->SetExtractSize(dwInstallSize);
        pCifRWComponent->SetInstalledSize(0, dwInstallSize);
        return;
    }

    if (dwDownloadSize <= 7)
        dwTolerance = 100;
    else
    {
        if (dwDownloadSize > 60)
            dwTolerance = 10;
        else
            dwTolerance = (600 / dwDownloadSize);
    }

    wnsprintf(szSize, countof(szSize), TEXT("0,%i"), dwInstallSize);
    WritePrivateProfileString( szSect, TEXT("InstalledSize"), szSize, g_szDestCif );
    dwTolerance = (dwDownloadSize * dwTolerance) / 100;
    dwLowSize = dwDownloadSize - dwTolerance;
    dwHighSize = dwDownloadSize + dwTolerance;
    wnsprintf(szSize, countof(szSize), TEXT("%i,%i"), dwLowSize, dwHighSize);
    WritePrivateProfileString( szSect, TEXT("Size1"), szSize, g_szDestCif );
}

BOOL BuildBrandingOnly(DWORD dwTicks)
{
    HANDLE hFile;
    LPSTR lpszBuf;
    DWORD dwBytesToWrite, dwBytesWritten;

    CCifRWFile_t *pCifRWFile;
    ICifRWGroup *pCifRWGroup;
    CCifRWGroup_t * pCifRWGroup_t;
    ICifRWComponent *pCifRWComponent;
    CCifRWComponent_t * pCifRWComponent_t;
    ICifComponent *pCifComponent;

    TCHAR szDesc[MAX_PATH];
    DWORD dwPriority;

    TCHAR szSrc[MAX_PATH], szDst[MAX_PATH];
    TCHAR szBrndOnlyPath[MAX_PATH];
    TCHAR szCDF[MAX_PATH];

    SHELLEXECUTEINFO shInfo;

    // create a cif that has only the custom sections (branding, desktop, etc.)
    PathCombine(szSrc, g_szBuildTemp, TEXT("iesetup.cif"));
    PathCombine(szDst, g_szBuildTemp, TEXT("brndonly.cif"));

    if ((hFile = CreateFile(szDst, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
        return FALSE;

    lpszBuf = "[Version]\r\nSignature=$Chicago$\r\n";
    dwBytesToWrite = lstrlenA(lpszBuf);
    WriteFile(hFile, (LPCVOID) lpszBuf, dwBytesToWrite, &dwBytesWritten, NULL);

    CloseHandle(hFile);

    if (dwBytesToWrite != dwBytesWritten)
        return FALSE;

    GetICifRWFileFromFile_t(&pCifRWFile, szDst);
    if (pCifRWFile == NULL)
        return FALSE;

    // g_lpCifRWFileDest points to iesetup.cif
    g_lpCifRWFileDest->GetDescription(szDesc, countof(szDesc));
    pCifRWFile->SetDescription(szDesc);

    // read Description and Priority for BASEIE4 Group from iesetup.cif and set them in brndonly.cif
    g_lpCifRWFileDest->CreateGroup(TEXT("BASEIE4"), &pCifRWGroup);        // iesetup.cif
    pCifRWGroup_t = new CCifRWGroup_t(pCifRWGroup);
    pCifRWGroup_t->GetDescription(szDesc, countof(szDesc));
    dwPriority = pCifRWGroup_t->GetPriority();
    delete pCifRWGroup_t;

    pCifRWFile->CreateGroup(TEXT("BASEIE4"), &pCifRWGroup);               // brndonly.cif
    pCifRWGroup_t = new CCifRWGroup_t(pCifRWGroup);
    pCifRWGroup_t->SetDescription(szDesc);
    pCifRWGroup_t->SetPriority(dwPriority);
    delete pCifRWGroup_t;

    if (SUCCEEDED(g_lpCifRWFileDest->FindComponent(TEXT("BRANDING.CAB"), &pCifComponent)))
    {
        pCifRWFile->CreateComponent(TEXT("BRANDING.CAB"), &pCifRWComponent);
        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);

        pCifRWComponent_t->CopyComponent(szSrc);
        pCifRWComponent_t->SetReboot(TRUE);
        pCifRWComponent_t->DeleteDependency(NULL, TEXT('\0'));
        delete pCifRWComponent_t;
    }

    if (SUCCEEDED(g_lpCifRWFileDest->FindComponent(TEXT("DESKTOP.CAB"), &pCifComponent)))
    {
        pCifRWFile->CreateComponent(TEXT("DESKTOP.CAB"), &pCifRWComponent);
        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
        pCifRWComponent_t->CopyComponent(szSrc);
        pCifRWComponent_t->SetReboot(TRUE);
        pCifRWComponent_t->DeleteDependency(NULL, TEXT('\0'));
        delete pCifRWComponent_t;
    }

    pCifRWFile->Flush();

    delete pCifRWFile;

    // copy brndonly.cif to iesetup.cif
    if (!CopyFile(szDst, szSrc, FALSE))
        return FALSE;

    // write LocalInstall = 1 in iesetup.ini
    // write MultiFloppy = 1 so JIT is handled properly as download install
    PathCombine(szDst, g_szBuildTemp, TEXT("iesetup.ini"));
    WritePrivateProfileString(TEXT("Options"), TEXT("LocalInstall"), TEXT("1"), szDst);
    WritePrivateProfileString(OPTIONS, TEXT("MultiFloppy"), TEXT("1"), szDst);
    WritePrivateProfileString(NULL, NULL, NULL, szDst);

    PathCombine(szDst, g_szBuildTemp, TEXT("iesetup.inf"));
#if 0
    /***
    // pritobla: since we decided to do a reboot for single disk branding,
    // there's no need to call rundll32 on iedkcs32.dll and launch iexplore.exe.

    // I'm keeping the following code commented out for now (just in case we change our minds).

    // write some sections specific to single disk branding in iesetup.inf
    WritePrivateProfileString(TEXT("IE4Setup.Success.Win"), TEXT("RunPostSetupCommands"),
            TEXT("RunPostSetupCommands1.Success,RunPostSetupCommands2.Success:2"), szDst);
    WritePrivateProfileString(TEXT("IE4Setup.Success.NTx86"), TEXT("RunPostSetupCommands"),
            TEXT("RunPostSetupCommands1.Success,RunPostSetupCommands2.Success:2"), szDst);
    WritePrivateProfileString(TEXT("IE4Setup.Success.NTAlpha"), TEXT("RunPostSetupCommands"),
            TEXT("RunPostSetupCommands1.Success,RunPostSetupCommands2.Success:2"), szDst);

    ZeroMemory(szSrc, sizeof(szSrc));
    StrCpy(szSrc, TEXT("rundll32.exe iedkcs32.dll,BrandIE4 "));
    StrCat(szSrc, g_fIntranet ? TEXT("CUSTOM") : TEXT("SIGNUP"));

    // (!g_fIntranet  &&  g_fBranded) ==> ISP
    if (!g_fIntranet  &&  g_fBranded  &&  !g_fNoSignup)
    {
        TCHAR szSrc2[MAX_PATH];
        // launch iexplore.exe so that the signup process happens automatically

        // custom ldid for the ie path in iesetup.inf is %50000%
        ZeroMemory(szSrc2, sizeof(szSrc2));
        StrCpy(szSrc2, TEXT("%50000%\\iexplore.exe"));
        WritePrivateProfileSection(TEXT("RunPostSetupCommands2.Success"), szSrc2, szDst);

        // write the custom ldid for the extracted files path
        WritePrivateProfileString(TEXT("CustInstDestSection2"), TEXT("40000"), TEXT("SourceDir,5"), szDst);

        StrCpy(szSrc + StrLen(szSrc) + 1, TEXT("rundll32.exe advpack.dll,LaunchINFSection %40000%\\iesetup.inf,IEAK.Signup.CleanUp"));

        // for single disk branding we spawn the iexplorer.exe when the iesetup.inf is processed (for down level compatibility).
        // So we do not want to spawn iexplore.exe from the branding dll automatically.
        AppendValueToKey(TEXT("IE4Setup.Success.Win"), TEXT("AddReg"), TEXT(",IEAK.Signup.reg"), szDst);
        AppendValueToKey(TEXT("IE4Setup.Success.NTx86"), TEXT("AddReg"), TEXT(",IEAK.Signup.reg"), szDst);
        AppendValueToKey(TEXT("IE4Setup.Success.NTAlpha"), TEXT("AddReg"), TEXT(",IEAK.Signup.reg"), szDst);

        WritePrivateProfileString(TEXT("IEAK.Signup.CleanUp"), TEXT("DelReg"), TEXT("IEAK.Signup.reg"), szDst);

        ZeroMemory(szSrc2, sizeof(szSrc2));
        StrCpy(szSrc2, TEXT("HKCU,\"Software\\Microsoft\\IEAK\",\"NoAutomaticSignup\",,\"1\""));
        WritePrivateProfileSection(TEXT("IEAK.Signup.reg"), szSrc2, szDst);
    }
    WritePrivateProfileSection(TEXT("RunPostSetupCommands1.Success"), szSrc, szDst);
    ***/
#endif

    // delete sections that are not relevant to single disk branding from iesetup.inf
    WritePrivateProfileString(TEXT("Company.reg"), NULL, NULL, szDst);
    WritePrivateProfileString(TEXT("MSIE4Setup.File"), NULL, NULL, szDst);
    WritePrivateProfileString(TEXT("Ani.File"), NULL, NULL, szDst);
    WritePrivateProfileString(TEXT("ie40cif.copy"), NULL, NULL, szDst);
    WritePrivateProfileString(TEXT("AddonPages.Reg"), NULL, NULL, szDst);
    WritePrivateProfileString(NULL, NULL, NULL, szDst);

    // write the appropriate entries in the batch file for ie6wzd.exe
    PathCombine(szDst, g_szBuildTemp, TEXT("iebatch.txt"));
    WritePrivateProfileString(TEXT("SetupChoice"), TEXT("Display"), TEXT("0"), szDst);
    WritePrivateProfileString(TEXT("SetupChoice"), TEXT("SetupChoice"), TEXT("0"), szDst);
    WritePrivateProfileString(TEXT("PrepareSetup"), TEXT("Display"), TEXT("0"), szDst);
    WritePrivateProfileString(NULL, NULL, NULL, szDst);

    // include iebatch.txt in ie6setup.exe, i.e., add iebatch.txt to bootie42.cdf
    PathCombine(szCDF, g_szBuildTemp, TEXT("bootie42.cdf"));
    InsWriteQuotedString(STRINGS, TEXT("FILE100"), TEXT("iebatch.txt"), szCDF);
    WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE100%"), TEXT(""), szCDF);

    // delete the files we don't need from bootie42.cdf
    /***
        [Strings]
        FILE1="Wininet.dll"     // don't need
        FILE2="Urlmon.dll"      // don't need
        FILE3="ie5wzd.exe"
        FILE4="advpack.dll"
        FILE5="iesetup.inf"
        FILE6="inseng.dll"
        FILE7="iesetup.cif"
        FILE8="globe.ani"
        FILE9="homepage.inf"
        FILE10="content.inf"    // don't need
        FILE11="iesetup.hlp"
        FILE12="w95inf16.dll"
        FILE13="w95inf32.dll"
        FILE14="license.txt"
        FILE17="this.txt"       // don't need
        FILE19="iedetect.dll"   // don't need
        FILE20="pidgen.dll"
    ***/
    WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE1%"), NULL, szCDF);
    WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE2%"), NULL, szCDF);
    WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE10%"), NULL, szCDF);
    WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE17%"), NULL, szCDF);
    WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE19%"), NULL, szCDF);

    // clear out any possible special custom command line flags
    InsWriteQuotedString(OPTIONS, APP_LAUNCHED, TEXT("ie6wzd.exe /S:\"#e\""), szCDF);

    WritePrivateProfileString(NULL, NULL, NULL, szCDF);

    // build the slim down version of ie6setup.exe
    SetCurrentDirectory(g_szBuildTemp);

    ZeroMemory(&shInfo, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    shInfo.hwnd = g_hWizard;
    shInfo.lpVerb = TEXT("open");
    shInfo.lpFile = TEXT("iexpress.exe");
    shInfo.lpParameters =TEXT("/n bootie42.cdf /m");
    shInfo.lpDirectory = g_szBuildTemp;
    shInfo.nShow = SW_MINIMIZE;

    SetWindowPos(g_hStatusDlg, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

    ShellExecAndWait(shInfo);

    // find out which cabs are present and delete the ones that don't exist from brndonly.cdf
    /***
        [Strings]
        FILE2="branding.cab"
        FILE3="desktop.cab"
    ***/
    PathCombine(szDst, g_szBuildTemp, TEXT("brndonly.cdf"));

    PathCombine(szSrc, g_szBuildTemp, TEXT("BRANDING.CAB"));
    if (!PathFileExists(szSrc))
        WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE2%"), NULL, szDst);

    PathCombine(szSrc, g_szBuildTemp, TEXT("DESKTOP.CAB"));
    if (!PathFileExists(szSrc))
        WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE3%"), NULL, szDst);

    // nuke the ICW check in the cdf if this is a corp or no signup/ICP package
    if (g_fIntranet || g_fNoSignup || !g_fBranded)
        WritePrivateProfileString(TEXT("FileSectionList"), TEXT("2"), NULL, szDst);

    WritePrivateProfileString(NULL, NULL, NULL, szDst);

    // build the mongo setup.exe that includes ie6setup.exe, iesetup.ini and the cabs
    ZeroMemory(&shInfo, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    shInfo.hwnd = g_hWizard;
    shInfo.lpVerb = TEXT("open");
    shInfo.lpFile = TEXT("iexpress.exe");
    shInfo.lpParameters =TEXT("/n brndonly.cdf /m");
    shInfo.lpDirectory = g_szBuildTemp;
    shInfo.nShow = SW_MINIMIZE;

    SetWindowPos(g_hStatusDlg, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

    ShellExecAndWait(shInfo);

    // sign the mongo setup.exe
    SignFile(TEXT("setup.exe"), g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);

    // create the output dir structure for brndonly, e.g., brndonly\win32\en
    PathCombine(szBrndOnlyPath, g_szBuildRoot, TEXT("BrndOnly"));
    PathAppend(szBrndOnlyPath, GetOutputPlatformDir());
    PathAppend(szBrndOnlyPath, g_szLanguage);

    PathCreatePath(szBrndOnlyPath);

    // copy the mongo setup.exe to the brndonly path
    if (CopyFilesSrcToDest(g_szBuildTemp, TEXT("setup.exe"), szBrndOnlyPath))
        return FALSE;

    UpdateProgress(dwTicks);
    return TRUE;
}

#define NUMDEFINST 3

static TCHAR s_aszDefInstSect[NUMDEFINST][32] =
{
    DEFAULT_INSTALL, DEFAULT_INSTALL_NT, DEFAULT_INSTALL_ALPHA
};

DWORD BuildCDandMflop(LPVOID pParam)
{
    SHELLEXECUTEINFO shInfo;
    TCHAR szDest[MAX_PATH];
    HWND hWnd;
    int res;

    hWnd=(HWND) pParam;
    ZeroMemory(&shInfo, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;

    CoInitialize(NULL);

    if (g_fCD || g_fLAN)
    {
        PathCombine(szDest, g_szBuildTemp, TEXT("iesetup.ini"));

        WritePrivateProfileString(OPTIONS, TEXT("LocalInstall"), TEXT("1"), szDest);
        InsWriteBool(OPTIONS, TEXT("Shell_Integration"), g_fInteg, szDest);
        InsFlushChanges(szDest);
    }

    if(g_fCD)
    {
        TCHAR szIE4SetupTo[MAX_PATH];
        LPTSTR pszFileName;
        TCHAR szCDFrom[MAX_PATH * 10];
        TCHAR szCDTo[MAX_PATH];
        TCHAR szBuildCD[MAX_PATH];
        PCOMPONENT pComp;

        g_shfStruc.wFunc = FO_COPY;

        PathCombine(szBuildCD, g_szBuildRoot, TEXT("CD"));
        PathAppend(szBuildCD, GetOutputPlatformDir());
        PathCreatePath(szBuildCD);
        PathAppend(szBuildCD, g_szActLang);
        CreateDirectory(szBuildCD, NULL);

        PathCombine(szIE4SetupTo, szBuildCD, TEXT("bin"));
        PathCreatePath(szIE4SetupTo);
        PathAppend(szIE4SetupTo, TEXT("INSTALL.INS"));
        CopyFile(g_szCustIns, szIE4SetupTo, FALSE);

        StrCpy(szCDFrom, g_szMastInf);
        PathRemoveFileSpec(szCDFrom);
        PathAppend(szCDFrom, TEXT("welc.exe"));
        PathCombine(szCDTo, szBuildCD, TEXT("bin"));
        PathAppend(szCDTo, TEXT("welc.exe"));
        CopyFile(szCDFrom, szCDTo, FALSE);

        res = CopyFilesSrcToDest(g_szIEAKProg, TEXT("*.*"), szBuildCD, s_dwTicksPerUnit*2);

        if (res)
        {
            TCHAR szMsg[MAX_PATH];
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
            DoCancel();
            CoUninitialize();
            return FALSE;
        }

        pszFileName = StrRChr(s_szIE4SetupDir, NULL, TEXT('\\'));

        if (pszFileName)
            pszFileName++;

        PathCombine(szIE4SetupTo, szBuildCD, pszFileName);
        CopyFile(s_szIE4SetupDir,szIE4SetupTo,FALSE);

        // copy custom cabs

        res = CopyFilesSrcToDest(g_szBuildTemp, TEXT("*.CAB"), szBuildCD);

        if (res)
        {
            TCHAR szMsg[MAX_PATH];
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
            DoCancel();
            CoUninitialize();
            return FALSE;
        }

        // copy custom components

        ZeroMemory(szCDFrom, sizeof(szCDFrom));
        for (pComp = g_aCustComponents, pszFileName = szCDFrom; ; pComp++ )
        {
            if (!(*pComp->szSection)) break;

            if (pComp->iInstallType == 2)
                continue;

            StrCpy(pszFileName, pComp->szPath);
            pszFileName += lstrlen(pszFileName) + 1;
        }

        if (ISNONNULL(szCDFrom))
        {
            g_shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;
            g_shfStruc.pFrom = szCDFrom;
            g_shfStruc.pTo = szBuildCD;

            res = SHFileOperation(&g_shfStruc);
            if (res)
            {
                TCHAR szMsg[MAX_PATH];
                LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
                MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
                DoCancel();
                CoUninitialize();
                return FALSE;
            }
        }

        // copy iesetup.ini

        PathCombine(szCDTo, szBuildCD, TEXT("iesetup.ini"));
        PathCombine(szCDFrom, g_szBuildTemp, TEXT("iesetup.ini"));
        CopyFile(szCDFrom, szCDTo, FALSE);

        // copy ICM profile

        if (g_fCustomICMPro)
        {
            PathCombine(szCDTo, szBuildCD, PathFindFileName(g_szCustIcmPro));
            CopyFile(g_szCustIcmPro, szCDTo, FALSE);
        }

        DeleteUnusedComps(szBuildCD);

        PathCombine(szBuildCD, g_szBuildRoot, TEXT("CD"));

        CopyISK(szBuildCD, g_szBuildTemp);
    }

    if (g_fLAN)
    {
        if(!BuildLAN(s_dwTicksPerUnit*2))
        {
            TCHAR szMsg[MAX_PATH];
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
            CoUninitialize();
            DoCancel();
            return FALSE;
        }
    }

    CoUninitialize();
    return(TRUE);
}

DWORD BuildIE4(LPVOID pParam)
{
    DWORD res, erc;
    TCHAR szSource[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    TCHAR szNulls[8];
    SHELLEXECUTEINFO shInfo;
    SECURITY_ATTRIBUTES sa;
    int i;
    HANDLE hSiteDat, hFind, hThread;
    WIN32_FIND_DATA fd;
    PSITEDATA psd;
    LPVOID pBuf;
    DWORD dwsSiteDat = 0;
    DWORD dwsSDH, sBuf;
    TCHAR szSiteData[MAX_PATH];
    TCHAR szCompBuf[10 * MAX_PATH];
    LPTSTR pCompBuf;
    PCOMPONENT pComp;
    TCHAR szUrl[MAX_URL];
    TCHAR szCustName[MAX_PATH], szBrandGuid[128] = TEXT(""), szOrderGuid[129];
    TCHAR szHomeInf[MAX_PATH];
    TCHAR szHomeUrl[MAX_URL];
    TCHAR szBootieFile[MAX_PATH];
    TCHAR szIE4ExeName[MAX_PATH];
    TCHAR szSelMode[4] = TEXT("0");
    LPTSTR pIE4ExeName = NULL;
    TCHAR szSiteDest[MAX_PATH];
    TCHAR szSiteRoot[MAX_PATH];
    TCHAR szCDF[MAX_PATH];
    DWORD dwTotalUnits;
    DWORD dwTid;
    HWND hWnd = (HWND)pParam;
    GUID guid;

    g_hWizard = hWnd;
    g_hStatusDlg = hWnd;
    g_hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
    StatusDialog( SD_STEP1 );
    g_fDone = TRUE;
    SetEvent(g_hDownloadEvent);
    SetAttribAllEx(g_szBuildTemp, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);
    SetAttribAllEx(g_szBuildRoot, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);

    // figure out costing metrics. Two units is roughly the time required to create all custom
    // cabs(iecif.cab, branding.cab, desktop.cab, ie6setup.exe) which we assume is
    // approximately equal to the time required to copy all files for a standard media type
    // (CD, LAN, download) as well. Single branding takes
    // one unit.  Ticks represent one percent on the status bar.  The number of ticks per unit
    // depend on how many media types are being built. The two units for the custom cabs will be
    // split as follows: 1/3 after desktop.cab, 2/3 after ie6setup.exe, and
    // 2/3 after branding.cab.  For standard media, all the progress updates will be made when
    // copying the base cabs.

    dwTotalUnits = 2 + (g_fDownload ? 2 : 0) + (g_fLAN ? 2 : 0) + (g_fCD ? 2 : 0) + (g_fBrandingOnly ? 1 : 0);

    s_dwTicksPerUnit = 100 / dwTotalUnits;


    *szUrl = TEXT('\0');
    if (g_fBatch)
    {
        if (GetPrivateProfileString(TEXT("BatchMode"), IK_URL, TEXT(""), szUrl, countof(szUrl), g_szCustIns))
            InsWriteQuotedString( IS_STRINGS, IK_URL, szUrl, g_szCustInf);

        if (GetPrivateProfileString(TEXT("BatchMode"), TEXT("URL2"), TEXT(""), szUrl, countof(szUrl), g_szCustIns))
            InsWriteQuotedString( IS_STRINGS, TEXT("URL2"), szUrl, g_szCustInf);
    }
    else
    {
        TCHAR szSitePath[INTERNET_MAX_URL_LENGTH];
        ICifRWComponent * pCifRWComponent;
        CCifRWComponent_t * pCifRWComponent_t;

        StrCpy(szSitePath, g_aCustSites->szUrl);
        StrCat(szSitePath, TEXT("/IE6SITES.DAT"));

        // if g_aCustSites->szUrl is NULL we're in a single disk branding only case so
        // we shouldn't write out this entry and nuke the default sites location needed
        // for JIT
        if (ISNONNULL(g_aCustSites->szUrl))
            InsWriteQuotedString( IS_STRINGS, TEXT("URL2"), szSitePath, g_szCustInf );
        
        if (GetPrivateProfileInt(BRANDING, TEXT("NoIELite"), 0, g_szCustIns))
            WritePrivateProfileString(OPTIONS, TEXT("IELiteModes"), NULL, g_szCustInf);
        else
        {
            TCHAR szIELiteModes[16];
            
            GetPrivateProfileString(OPTIONS, TEXT("IELiteModes"), TEXT(""), szIELiteModes,
                countof(szIELiteModes), g_szMastInf);
            WritePrivateProfileString(OPTIONS, TEXT("IELiteModes"), szIELiteModes, g_szCustInf);
        }

        if (g_fNoSignup || g_fIntranet || !g_fBranded)
        {
            if (SUCCEEDED(g_lpCifRWFile->CreateComponent(TEXT("ICW"), &pCifRWComponent)))
            {
                pCifRWComponent->DeleteFromModes(NULL);
                pCifRWComponent->SetUIVisible(FALSE);
            }
            
            if (SUCCEEDED(g_lpCifRWFile->CreateComponent(TEXT("ICW_NTx86"), &pCifRWComponent)))
            {
                pCifRWComponent->DeleteFromModes(NULL);
                pCifRWComponent->SetUIVisible(FALSE);
            }
        }
        else
        {
            if (SUCCEEDED(g_lpCifRWFile->CreateComponent(TEXT("ICW"), &pCifRWComponent)))
            {
                TCHAR szGuid[128] = TEXT("");
                
                pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
                pCifRWComponent_t->GetGUID(szGuid, countof(szGuid));
                pCifRWComponent_t->SetUIVisible(FALSE);
                if (ISNONNULL(szGuid))
                    WritePrivateProfileString(TEXT("IELITE"), szGuid, NULL, g_szCustInf);
                delete pCifRWComponent_t;
            }
            
            if (SUCCEEDED(g_lpCifRWFile->CreateComponent(TEXT("ICW_NTx86"), &pCifRWComponent)))
            {
                TCHAR szGuid[128] = TEXT("");
                
                pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
                pCifRWComponent_t->GetGUID(szGuid, countof(szGuid));
                pCifRWComponent_t->SetUIVisible(FALSE);
                if (ISNONNULL(szGuid))
                    WritePrivateProfileString(TEXT("IELITE"), szGuid, NULL, g_szCustInf);
                delete pCifRWComponent_t;
            }
        }

        if (SUCCEEDED(g_lpCifRWFile->CreateComponent(TEXT("MobilePk"), &pCifRWComponent)))
        {
            TCHAR szGuid[128] = TEXT("");
            
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->GetGUID(szGuid, countof(szGuid));
            if (ISNONNULL(szGuid))
                WritePrivateProfileString(TEXT("IELITE"), szGuid, NULL, g_szCustInf);
            delete pCifRWComponent_t;
        }
    }

    g_shfStruc.hwnd = hWnd;
    g_shfStruc.wFunc = FO_COPY;
    if (!g_fBatch && !g_fBatch2)
    {
        TCHAR szDefaultMode[2];
        BOOL bDefaultPresent = FALSE;

        GetPrivateProfileString(STRINGS, INSTALLMODE, TEXT("1"), szDefaultMode, countof(szDefaultMode), g_szCustInf);
        
        for (i=0; g_szAllModes[i]; i++)
        {
            if (g_szAllModes[i] == szDefaultMode[0])
                bDefaultPresent = TRUE;
        }
        if (!bDefaultPresent)
        {
            szDefaultMode[0] = g_szAllModes[0];
            szDefaultMode[1] = TEXT('\0');
        }

        WritePrivateProfileString(OPTIONS_WIN, INSTALLMODE, szDefaultMode, g_szCustInf);
        WritePrivateProfileString(OPTIONS_WIN, TEXT("CustomMode"), szDefaultMode, g_szCustInf);
        WritePrivateProfileString(OPTIONS_NTX86, INSTALLMODE, szDefaultMode, g_szCustInf);
        WritePrivateProfileString(OPTIONS_NTX86, TEXT("CustomMode"), szDefaultMode, g_szCustInf);
        WritePrivateProfileString(OPTIONS_NTALPHA, INSTALLMODE, szDefaultMode, g_szCustInf);
    }

    res  = CopyIE4Files();
    UpdateProgress(s_dwTicksPerUnit / 3);
    if (res)
    {
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
        MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
        DoCancel();
        return (DWORD)-1;
    }

    BuildIE4Folders(hWnd);
    UpdateProgress(s_dwTicksPerUnit / 3);

    PathCombine(szDest, g_szBuildTemp, PathFindFileName(g_szCustIns));
    CopyFile( g_szCustIns, szDest, FALSE );

    PathCombine(szCDF, g_szBuildTemp, TEXT("bootie42.cdf"));
    
    PathCombine( szSource, g_szBuildTemp, TEXT("ie6setup.exe"));
    SetFileAttributes(szSource, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(szSource);

    if (g_fIntranet)
    {
        TCHAR szInstallPath[MAX_PATH];
        TCHAR szInstallDest[MAX_PATH];
        TCHAR szCmd[MAX_PATH];
        TCHAR szBatchFile[MAX_PATH];
        int iDefaultBrowserCheck;

        szSelMode[0] = (TCHAR)(g_iSelOpt + TEXT('0'));
        
        PathCombine(szBatchFile, g_szBuildTemp, TEXT("iebatch.txt"));
        DeleteFile(szBatchFile);
        
        if (g_fSilent || g_fStealth)
        {
            TCHAR szDownloadSite[INTERNET_MAX_URL_LENGTH];
            
            wnsprintf(szDownloadSite, countof(szDownloadSite), TEXT("%s/%s"), g_aCustSites[g_iSelSite].szUrl, g_szActLang);
            WritePrivateProfileString(TEXT("Options"), TEXT("Quiet"), g_fStealth ? TEXT("A") : TEXT("C"), szBatchFile);
            WritePrivateProfileString(TEXT("DownloadSite"), TEXT("Display"), TEXT("0"), szBatchFile);
            WritePrivateProfileString(TEXT("DownloadSite"), TEXT("DownloadLocation"), szDownloadSite, szBatchFile);
            WritePrivateProfileString(TEXT("Upgrade"), TEXT("ReinstallAll"), TEXT("1"), szBatchFile);
            WritePrivateProfileString(NULL, NULL, NULL, szBatchFile);
            wnsprintf(szCmd, countof(szCmd), TEXT("ie6wzd.exe /S:\"#e\" /m:%s /i:%s"),
                szSelMode, g_fInteg ? TEXT("Y") : TEXT("N"));
            InsWriteQuotedString( OPTIONS, APP_LAUNCHED, szCmd, szCDF );
        }
        else
        {
            wnsprintf(szCmd, countof(szCmd), TEXT("ie6wzd.exe /S:\"#e\" /i:%s"), g_fInteg ? TEXT("Y") : TEXT("N"));
            InsWriteQuotedString( OPTIONS, APP_LAUNCHED, szCmd, szCDF );
            
            if (GetPrivateProfileInt(IS_BRANDING, TEXT("HideCustom"), 0, g_szCustIns))
            {
                WritePrivateProfileString(TEXT("SetupChoice"), TEXT("Display"), TEXT("0"), szBatchFile);
                WritePrivateProfileString(TEXT("SetupChoice"), TEXT("SetupChoice"), TEXT("0"), szBatchFile);
            }
            
            if (GetPrivateProfileInt(IS_BRANDING, TEXT("HideCompat"), 0, g_szCustIns))
                WritePrivateProfileString(TEXT("Custom"), TEXT("IECompatShow"), TEXT("0"), szBatchFile);
        }

        if (GetPrivateProfileInt(IS_BRANDING, TEXT("NoBackup"), 0, g_szCustIns))
            WritePrivateProfileString(TEXT("Options"), TEXT("SaveUninstallInfo"), TEXT("0"), szBatchFile);
        
        if ((iDefaultBrowserCheck = GetPrivateProfileInt(IS_BRANDING, TEXT("BrowserDefault"), 2, g_szCustIns)) != 2)
        {
            WritePrivateProfileString(TEXT("Custom"), TEXT("IEDefaultRO"), TEXT("1"), szBatchFile);
            WritePrivateProfileString(TEXT("Custom"), TEXT("IEDefault"),
                iDefaultBrowserCheck ? TEXT("0") : TEXT("1"), szBatchFile);
        }
        
        WritePrivateProfileString(TEXT("Custom"), TEXT("UseInfInstallDir"), TEXT("1"), szBatchFile);
        
        if(!GetPrivateProfileInt(IS_BRANDING, TEXT("AllowInstallDir"), 0, g_szCustIns))
            WritePrivateProfileString(TEXT("Custom"), TEXT("InstallDirRO"), TEXT("1"), szBatchFile);
        
        WritePrivateProfileString(NULL, NULL, NULL, szBatchFile);
        
        if (PathFileExists(szBatchFile))
        {
            // package up batch file into ie6setup exe in file100 position
            InsWriteQuotedString(IS_STRINGS, TEXT("FILE100"), TEXT("iebatch.txt"), szCDF);
            WritePrivateProfileString(TEXT("SourceFiles0"), TEXT("%FILE100%"), TEXT(""), szCDF);
        }

        InsWriteQuotedString( STRINGS, DEFAULT_EXPLORER_PATH, g_szInstallFolder, g_szCustInf );
        WritePrivateProfileString( OPTIONS, DISPLAY_LICENSE, TEXT(""), szCDF);
        
        switch (g_iInstallOpt)
        {
            case INSTALL_OPT_PROG:
            default:
                wnsprintf(szInstallPath, countof(szInstallPath), TEXT("%%49001%%\\%%%s%%"), DEFAULT_EXPLORER_PATH);
                wnsprintf(szInstallDest, countof(szInstallDest), TEXT("49001,%%%s%%"), DEFAULT_EXPLORER_PATH);
                break;
            case INSTALL_OPT_FULL:
                wnsprintf(szInstallPath, countof(szInstallPath), TEXT("%%%s%%"), DEFAULT_EXPLORER_PATH);
                wnsprintf(szInstallDest, countof(szInstallDest), TEXT("%%%s%%"), DEFAULT_EXPLORER_PATH);
                break;
        }
        
        WritePrivateProfileString( OPTIONS_WIN, INSTALL_DIR, szInstallPath, g_szCustInf );
        WritePrivateProfileString( DESTINATION_DIRS, OPTIONS_WIN, szInstallDest, g_szCustInf);
        WritePrivateProfileString( OPTIONS_NTX86, INSTALL_DIR, szInstallPath, g_szCustInf );
        WritePrivateProfileString( DESTINATION_DIRS, OPTIONS_NTX86, szInstallDest, g_szCustInf);
        WritePrivateProfileString( OPTIONS_NTALPHA, INSTALL_DIR, szInstallPath, g_szCustInf );
        WritePrivateProfileString( DESTINATION_DIRS, OPTIONS_NTALPHA, szInstallDest, g_szCustInf);
        WritePrivateProfileString( NULL, NULL, NULL, g_szCustInf);
    }

    GetPrivateProfileString(IS_STRINGS, TEXT("CustomName"), TEXT(""), szCustName, countof(szCustName), g_szDefInf);
    if (ISNULL(szCustName)) LoadString( g_rvInfo.hInst, IDS_CUSTNAME, szCustName, MAX_PATH );

    // for batch mode builds, always used the old branding guid

    if (!g_fBatch)
    {
        if (CoCreateGuid(&guid) == NOERROR)
            CoStringFromGUID(guid, szBrandGuid, countof(szBrandGuid));
    }

    if (ISNULL(szBrandGuid))
        CoStringFromGUID(GUID_BRANDING, szBrandGuid, countof(szBrandGuid));

    StrNCat(szBrandGuid, g_szKey, 7);
    wnsprintf(szOrderGuid, countof(szOrderGuid), TEXT("%s%s"), TEXT(">"), szBrandGuid);

    res = CabUpFolder(NULL, g_szTempSign, g_fIntranet ? TEXT("49100,CUSTOM") : TEXT("49100,SIGNUP"),
        TEXT("BRANDING.CAB"), szCustName, szOrderGuid, g_fIntranet ?
        TEXT("\"RunDLL32 IEDKCS32.DLL,BrandIE4 CUSTOM\"") : TEXT("\"RunDLL32 IEDKCS32.DLL,BrandIE4 SIGNUP\"") );

    UpdateProgress(s_dwTicksPerUnit * 2 / 3);
    if (res)
    {
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
        MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
        DoCancel();
        return (DWORD)-1;
    }
    
    SignFile(TEXT("BRANDING.CAB"), g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);

    // NOTE: Copying of signup files to the output folder should happen after branding.cab has been built.

    // for server-based signup, if specified, copy branding.cab to the signup folder.
    // copy *.ins and *.cab from the signup folder to the output dir; e.g., <output dir>\ispserv\win32\en\kiosk
    if (ISNONNULL(g_szSignup)  &&  (g_fServerICW || g_fServerKiosk))
    {
        TCHAR szOutDir[MAX_PATH];

        // first, copy branding.cab to the signup folder
        // NOTE: szOutDir is used as a temp buffer
        PathCombine(szOutDir, g_szBuildTemp, TEXT("BRANDING.CAB"));
        CopyCabFiles(g_szSignup, szOutDir);

        PathCombine(szOutDir, g_szBuildRoot, TEXT("ispserv"));
        PathAppend(szOutDir, GetOutputPlatformDir());
        PathAppend(szOutDir, g_szLanguage);

        // get the sub-dir based on signup mode from g_szSignup
        PathAppend(szOutDir, PathFindFileName(g_szSignup));

        // clean-up the content in the output folder before copying
        PathRemovePath(szOutDir);

        CopyINSFiles(g_szSignup, szOutDir);
        CopyFilesSrcToDest(g_szSignup, TEXT("*.cab"), szOutDir);
    }

    PathCombine( szDest, g_szBuildTemp, TEXT("IESETUP.INF") );
    CopyFile( g_szCustInf, szDest, FALSE );

    ZeroMemory(&shInfo, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    SetCurrentDirectory(g_szBuildTemp);
    if (!g_fUseIEWelcomePage)
    {
        TCHAR szHomepageRegSect[80];
        *szNulls = szNulls[1] = TEXT('\0');
        PathCombine(szHomeInf, g_szBuildTemp, TEXT("Homepage.inf"));
        GetPrivateProfileString( DEFAULT_INSTALL, ADDREG, INITHOMEPAGE,
            szHomepageRegSect, countof(szHomepageRegSect), szHomeInf );
        GetPrivateProfileString(IS_URL, IK_FIRSTHOMEPAGE, TEXT(""), szHomeUrl, countof(szHomeUrl), g_szCustIns);
        InsWriteQuotedString( STRINGS, INITHOMEPAGE, szHomeUrl, szHomeInf );
        if (ISNULL(szHomeUrl))
        {
            int i;
            for (i = 0; i < NUMDEFINST; i++ )
            {
                WritePrivateProfileString(s_aszDefInstSect[i], ADDREG, NULL, szHomeInf );
                WritePrivateProfileString(s_aszDefInstSect[i], DELREG, INIT_HOME_DEL, szHomeInf );
            }
        }
    }

    if (g_fCustomICMPro)
        SetCompSize(g_szCustIcmPro, CUSTCMSECT, 0);

    g_lpCifRWFileDest->Flush();

    InsFlushChanges(g_szCustInf);

    shInfo.hwnd = hWnd;
    shInfo.lpVerb = TEXT("open");
    shInfo.lpFile = TEXT("IEXPRESS.EXE");
    shInfo.lpDirectory = g_szBuildTemp;
    shInfo.nShow = SW_MINIMIZE;
    shInfo.lpParameters = TEXT("/n bootie42.CDF /m");
    shInfo.nShow = SW_MINIMIZE;
    SetWindowPos(g_hStatusDlg, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
    ShellExecAndWait(shInfo);
    
    PathCombine( szSource, g_szBuildTemp, TEXT("IECIF.CAB") );
    SetFileAttributes(szSource, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(szSource);
    
    shInfo.lpParameters = TEXT("/n ie40cif.CDF /m");
    SetWindowPos(g_hStatusDlg, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
    ShellExecAndWait(shInfo);
    SetWindowPos(g_hStatusDlg, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
    SignFile(PathFindFileName(szSource), g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);

    UpdateProgress(s_dwTicksPerUnit * 2 / 3);
    ZeroMemory(szDest, sizeof(szDest));
    StrCpy( szDest, g_szBuildRoot );
    if(!g_fOCW)
    {
        PathAppend( szDest, TEXT("DOWNLOAD") );
        PathAppend(szDest, GetOutputPlatformDir());
        PathAppend(szDest, g_szLanguage);
        if (g_fDownload)
        {
            erc = PathCreatePath(szDest);
            SetAttribAllEx(szDest, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);
        }
    }
    else
    {
        TCHAR szIniFile[MAX_PATH];
        TCHAR szDestIniFile[MAX_PATH];
        TCHAR szFileName[MAX_PATH];

        // write office data to HKCU\Software\Microsoft\IEAK registry branch since office
        // reads/writes data from/to this location.
        SHSetValue(HKEY_CURRENT_USER, RK_IEAK, TEXT("TargetDir"), REG_SZ, (LPBYTE)szDest,
            (StrLen(szDest)+1)*sizeof(TCHAR));
        SHSetValue(HKEY_CURRENT_USER, RK_IEAK, TEXT("LangFolder"), REG_SZ, (LPBYTE)g_szActLang,
            (StrLen(g_szActLang)+1)*sizeof(TCHAR));
        StrCpy(szFileName, TEXT("ie6setup.exe"));
        SHSetValue(HKEY_CURRENT_USER, RK_IEAK, TEXT("FileName"), REG_SZ, (LPBYTE)szFileName,
            (StrLen(szFileName)+1)*sizeof(TCHAR));

        PathAppend(szDest, g_szLanguage);
        erc = PathCreatePath( szDest );
        PathCombine(szIniFile, g_szBuildTemp, TEXT("iesetup.ini"));
        PathCombine(szDestIniFile, szDest, TEXT("iesetup.ini"));
        WritePrivateProfileString(OPTIONS, TEXT("LocalInstall"), TEXT("1"), szIniFile);
        WritePrivateProfileString(NULL, NULL, NULL, szIniFile);
        CopyFile(szIniFile, szDestIniFile, FALSE);
    }

    TCHAR szTo[MAX_PATH];

    ZeroMemory(szIE4ExeName, sizeof(szIE4ExeName));
    PathCombine(szBootieFile, g_szBuildTemp, TEXT("bootie42.cdf"));
    GetPrivateProfileString(OPTIONS, TEXT("TargetName"), TEXT(""), szIE4ExeName, countof(szIE4ExeName), szBootieFile);

    if(ISNONNULL(szIE4ExeName))
    {
        pIE4ExeName = StrRChr(szIE4ExeName, NULL, TEXT('\\'));
        if(pIE4ExeName)
            pIE4ExeName = pIE4ExeName + 1;
        else
            pIE4ExeName = szIE4ExeName;
    }
    else
        pIE4ExeName = TEXT("IE6Setup.exe\0\0");

    SignFile(pIE4ExeName, g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);

    PathCombine(s_szIE4SetupDir, g_szBuildTemp, pIE4ExeName);
    
    TCHAR szSignLoc[MAX_PATH];
    DWORD dwAttrib;
    
    if (g_fCustomICMPro)
    {
        PathCombine(szSignLoc, g_szBuildTemp, PathFindFileName(g_szCustIcmPro));
        CopyFile(g_szCustIcmPro, szSignLoc, FALSE);
        StrCpy(g_szCustIcmPro, szSignLoc);
        dwAttrib = GetFileAttributes(g_szCustIcmPro);
        SetFileAttributes(g_szCustIcmPro, FILE_ATTRIBUTE_NORMAL);
        SignFile(PathFindFileName(g_szCustIcmPro), g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);
        SetFileAttributes(g_szCustIcmPro, dwAttrib);
    }
    
    for (pComp = g_aCustComponents; ; pComp++ )
    {
        if (!(*pComp->szSection)) break;

        if (pComp->iInstallType == 2)
            continue;

        PathCombine(szSignLoc, g_szBuildTemp, PathFindFileName(pComp->szPath));
        CopyFile(pComp->szPath, szSignLoc, FALSE);
        StrCpy(pComp->szPath, szSignLoc);
        dwAttrib = GetFileAttributes(pComp->szPath);
        SetFileAttributes(pComp->szPath, FILE_ATTRIBUTE_NORMAL);
        SignFile(PathFindFileName(pComp->szPath), g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);
        SetFileAttributes(pComp->szPath, dwAttrib);
    }

    // Copy URDComponent
    if (InsGetBool(IS_HIDECUST, IK_URD_STR, FALSE, g_szCustIns))
    {
        TCHAR szURDPath[MAX_PATH];

        // IE55URD.EXE is under iebin\<lang>\optional
        StrCpy(szURDPath, g_szMastInf);
        PathRemoveFileSpec(szURDPath);
        PathAppend(szURDPath, IE55URD_EXE);
        CopyFileToDir(szURDPath, g_szBuildTemp);
    
        PathCombine(szURDPath, g_szBuildTemp, IE55URD_EXE);
        dwAttrib = GetFileAttributes(szURDPath);
        SetFileAttributes(szURDPath, FILE_ATTRIBUTE_NORMAL);
        SignFile(IE55URD_EXE, g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);
        SetFileAttributes(szURDPath, dwAttrib);
    }

    StatusDialog( SD_STEP2 );

    ZeroMemory(szDest, sizeof(szDest));

    sa.nLength=sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor=NULL;
    sa.bInheritHandle=TRUE;

    hThread=CreateThread(&sa, 4096, BuildCDandMflop, hWnd, 0, &dwTid);
    while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if (hThread != NULL) CloseHandle(hThread);

    StrCpy( szDest, g_szBuildRoot );
    if(!g_fOCW)
    {
        PathAppend( szDest, TEXT("INS") );
        PathAppend(szDest, GetOutputPlatformDir());
        StrCpy(szSiteRoot, szDest);
        PathAppend(szDest, g_szLanguage);

        PathCombine(szSiteDest, g_szBuildRoot, TEXT("DOWNLOAD"));
        PathAppend(szSiteDest, GetOutputPlatformDir());
    }
    if (g_fDownload)
    {
        PathAppend(szDest, TEXT("IE6SITES.DAT"));
        SetFileAttributes(szDest, FILE_ATTRIBUTE_NORMAL);
        DeleteFile( szDest );
        hSiteDat = CreateFile(szDest, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        for (i = 0, psd=g_aCustSites; i < g_nDownloadUrls ; i++, psd++ )
        {
            SITEDATA sd;
            TCHAR szSite[2 * MAX_URL];

            ZeroMemory(szSite, sizeof(szSite));
            ZeroMemory((void *) &sd, sizeof(sd));
            if (g_fBatch)
            {
                TCHAR szBaseUrlParm[32];

                wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteName%i"), i);
                GetPrivateProfileString(TEXT("BatchMode"), szBaseUrlParm, TEXT(""), sd.szName, 80, g_szCustIns );

                wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteUrl%i"), i);
                GetPrivateProfileString(TEXT("BatchMode"), szBaseUrlParm, TEXT(""), sd.szUrl, MAX_URL, g_szCustIns );

                wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteRegion%i"), i);
                GetPrivateProfileString(TEXT("BatchMode"), szBaseUrlParm, TEXT(""), sd.szRegion, 80, g_szCustIns );

                if (*sd.szName && *sd.szUrl && *sd.szRegion)
                    wnsprintf(szSite, countof(szSite), TEXT("\"%s\",\"%s\",\"%s\",\"%s\"\r\n"), sd.szUrl, sd.szName, g_szActLang, sd.szRegion);
            }

            if (*szSite == TEXT('\0'))
            {
                if(!g_fOCW)
                {
                    wnsprintf(szSite, countof(szSite), TEXT("\"%s/%s\",\"%s\",\"%s\",\"%s\"\r\n"), psd->szUrl, g_szActLang, psd->szName,
                        g_szActLang, psd->szRegion);
                }
                else
                {
                    wnsprintf(szSite, countof(szSite), TEXT("\"%s\",\"%s\",\"%s\",\"%s\"\r\n"), psd->szUrl, psd->szName,
                        g_szActLang, psd->szRegion);
                }
            }
            WriteStringToFile( hSiteDat, szSite, StrLen(szSite) );
        }
        dwsSiteDat = GetFileSize( hSiteDat, &dwsSDH );
        CloseHandle(hSiteDat);
    }

    if(!g_fOCW && g_fDownload)
    {
        PathCombine(szDest, szSiteRoot, TEXT("*."));
        PathCombine(szSiteData, szSiteDest, TEXT("IE6SITES.DAT"));
        SetFileAttributes(szSiteData, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (szSiteData);
        hSiteDat = CreateFile(szSiteData, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        sBuf = 2 * dwsSiteDat;
        pBuf = LocalAlloc(LPTR, sBuf );
        hFind = FindFirstFile( szDest, &fd );
        while (hFind != INVALID_HANDLE_VALUE)
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (lstrlen(fd.cFileName) == 2))
            {
                TCHAR szLangSiteDat[MAX_PATH];
                HANDLE hLangSiteDat;
                DWORD dwsLangSite;

                PathCombine(szLangSiteDat, szSiteRoot, fd.cFileName);
                PathAppend(szLangSiteDat, TEXT("IE6SITES.DAT"));
                hLangSiteDat = CreateFile(szLangSiteDat, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                if (hLangSiteDat != INVALID_HANDLE_VALUE)
                {
                    DWORD dwsRead;
                    dwsLangSite = GetFileSize( hLangSiteDat, &dwsSDH );
                    if (dwsLangSite > sBuf)
                    {
                        LocalFree(pBuf);
                        sBuf = 2 * dwsLangSite;
                        pBuf = LocalAlloc(LPTR, sBuf);
                    }
                    ReadFile( hLangSiteDat, pBuf, dwsLangSite, &dwsRead, NULL );
                    WriteFile( hSiteDat, pBuf, dwsLangSite, &dwsRead, NULL );
                    CloseHandle(hLangSiteDat);
                }
            }
            if (!FindNextFile( hFind, &fd ))
            {
                FindClose(hFind);
                break;
            }
        }
        CloseHandle(hSiteDat);
        LocalFree(pBuf);
    }
    SetCurrentDirectory(g_szIEAKProg);

    PathCombine(szCompBuf, g_szIEAKProg, TEXT("new"));
    PathRemovePath(szCompBuf);
    ZeroMemory(szCompBuf, sizeof(szCompBuf));

    if(g_fOCW)
        PathCombine(szDest, g_szBuildRoot, g_szActLang);
    else
    {
        PathCombine(szDest, g_szBuildRoot, TEXT("DOWNLOAD"));
        PathAppend(szDest, GetOutputPlatformDir());
        PathAppend(szDest, g_szActLang);
    }

    TCHAR szSourceDir[MAX_PATH];
    TCHAR szTargetDir[MAX_PATH];

    StrCpy(szSourceDir, g_szIEAKProg);
    StrCpy(szTargetDir, g_szBuildRoot);
    PathRemoveBackslash(szSourceDir);
    PathRemoveBackslash(szTargetDir);

    if((!g_fOCW && g_fDownload) || (g_fOCW && StrCmpI(szSourceDir, szTargetDir)))
        res = CopyFilesSrcToDest(g_szIEAKProg, TEXT("*.*"), szDest, s_dwTicksPerUnit*2);

    if (g_fDownload || g_fOCW)
    {
        res |= CopyFilesSrcToDest(g_szBuildTemp, TEXT("*.CAB"), szDest);
        PathCombine(szTo, szDest, pIE4ExeName);
        SetFileAttributes(szTo, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTo);
        CopyFile(s_szIE4SetupDir, szTo, FALSE);

        if (res)
        {
            TCHAR szMsg[MAX_PATH];
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
            DoCancel();
            return (DWORD)-1;
        }
    }

    // remove the .cif file that was copied from the download\optional directory
    TCHAR szCifFile[MAX_PATH];

    PathCombine(szCifFile, szDest, TEXT("IESetup.cif"));
    DeleteFile(szCifFile);

    if (g_fOCW || g_fDownload)
    {
        if (g_fCustomICMPro)
        {
            ZeroMemory(szSource, sizeof(szSource));
            StrCpy(szSource, g_szCustIcmPro);

            g_shfStruc.pFrom = szSource;
            g_shfStruc.pTo = szDest;
            g_shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;
            res |= SHFileOperation(&g_shfStruc);
        }
    }
    if (res)
    {
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
        MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
        DoCancel();
        return (DWORD)-1;
    }
    if (g_fOCW || g_fDownload)
    {
        ZeroMemory(szCompBuf, sizeof(szCompBuf));
        for (pComp = g_aCustComponents, pCompBuf = szCompBuf; ; pComp++ )
        {
            if (!(*pComp->szSection)) break;

            if (pComp->iInstallType == 2)
                continue;

            StrCpy(pCompBuf, pComp->szPath);
            pCompBuf += lstrlen(pCompBuf) + 1;
        }
    }

    if (g_fOCW || g_fDownload)
    {
        if (*szCompBuf)
        {
            g_shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;
            g_shfStruc.pFrom = szCompBuf;
            g_shfStruc.pTo = szDest;
            res = SHFileOperation(&g_shfStruc);
            if (res)
            {
                TCHAR szMsg[MAX_PATH];
                LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
                MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
                DoCancel();
                return (DWORD)-1;
            }
        }

        DeleteUnusedComps(szDest);
    }

    // copy custom cab files to ins directory for IEAKLite

    if (!g_fBatch)
    {
        StrCpy(szDest, g_szCustIns);
        PathRemoveFileSpec(szDest);
        CopyFilesSrcToDest(g_szBuildTemp, TEXT("*.CAB"), szDest);
        CopyFilesSrcToDest(g_szBuildTemp, TEXT("IE6SETUP.EXE"), szDest);

        // clear out the deleteadms flags if it's there so adms can be disabled in IEAKLite

        WritePrivateProfileString(IS_BRANDING, TEXT("DeleteAdms"), NULL, g_szCustIns);
    }

    // NOTE: BuildBrandingOnly should be the last one because it munges
    // iesetup.inf, iesetup.cif, bootie42.cdf, etc.
    if (g_fBrandingOnly)
    {
        if(!BuildBrandingOnly(s_dwTicksPerUnit))
        {
            TCHAR szMsg[MAX_PATH];
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hWnd, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
            DoCancel();
            return (DWORD)-1;
        }
    }

    UpdateProgress(-1);
    StrCpy( szDest, g_szBuildTemp );
    SetCurrentDirectory(g_szWizPath);
#ifndef DBG
    PathRemovePath(szDest);
#endif

    if (ISNONNULL(g_szUnsignedFiles))
    {
        TCHAR szMessage[MAX_BUF];
        TCHAR szMsg[512];

        LoadString(g_rvInfo.hInst, IDS_CABSIGN_ERROR, szMsg, countof(szMsg));
        wnsprintf(szMessage, countof(szMessage), szMsg, g_szUnsignedFiles);
        MessageBox(hWnd, szMessage, g_szTitle, MB_OK | MB_SETFOREGROUND);
    }

    if (!g_fBatch && !g_fBatch2)
    {
        SetFocus(hWnd);
        SetCurrentDirectory( g_szWizRoot );
    }

    return 0;
}

DWORD ProcessINSFiles(LPCTSTR pcszDir, DWORD dwFlags, LPCTSTR pcszOutDir)
// Except the .INS files that have Cancel=Yes in the [Entry] section, do this:
// return the number of INS files found in pcszDir;
// if (HasFlag(dwFlags, PINSF_DELETE)), delete them from pcszDir;
// else if (HasFlag(dwFlags, PINSF_COPY)), copy them to pcszOutDir;
// else if (HasFlag(dwFlags, PINSF_APPLY)), append pcszOutDir (actually points to INSTALL.INS) to them;
// else if (HasFlag(dwFlags, PINSF_COPYCAB)), copy pcszOutDir (actually points to BRANDING.CAB) to pcszDir;
// else if (HasFlag(dwFlags, PINSF_FIXINS)), write Serverless=1 to the [Branding] section;
// else if (HasFlag(dwFlags, PINSF_NOCLEAR)), write NoClear=1 to the [Branding] section.
{
    DWORD nFiles = 0;
    TCHAR szFile[MAX_PATH], szCabName[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFind;
    LPTSTR pszFile, pszCabName = NULL;

    if (pcszDir == NULL  ||  ISNULL(pcszDir))
        return 0;

    if (HasFlag(dwFlags, PINSF_COPY)  ||  HasFlag(dwFlags, PINSF_APPLY)  ||  HasFlag(dwFlags, PINSF_COPYCAB))
        if (pcszOutDir == NULL  ||  ISNULL(pcszOutDir))
            return 0;

    StrCpy(szFile, pcszDir);
    pszFile = PathAddBackslash(szFile);
    StrCpy(pszFile, TEXT("*.ins"));

    if (HasFlag(dwFlags, PINSF_COPYCAB))
    {
        StrCpy(szCabName, pcszDir);
        pszCabName = PathAddBackslash(szCabName);
    }

    if ((hFind = FindFirstFile(szFile, &fd)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                continue;

            StrCpy(pszFile, fd.cFileName);
            if (!InsGetYesNo(TEXT("Entry"), TEXT("Cancel"), 0, szFile))
            {
                nFiles++;

                if (HasFlag(dwFlags, PINSF_DELETE))
                {
                    SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(szFile);
                }
                else if (HasFlag(dwFlags, PINSF_COPY))
                {
                    CopyFileToDir(szFile, pcszOutDir);
                }
                else if (HasFlag(dwFlags, PINSF_APPLY))
                {
                    // append install.ins only if ApplyIns is TRUE
                    if (InsGetBool(IS_APPLYINS, IK_APPLYINS, 0, szFile))
                    {
                        // IMPORTANT: (pritobla) On Win9x, should flush the content before
                        // mixing file operations (CreateFile, ReadFile, WriteFile, DeleteFile, etc)
                        // with PrivateProfile function calls.
                        WritePrivateProfileString(NULL, NULL, NULL, szFile);

                        AppendFile(pcszOutDir, szFile);     // pcszOutDir actually points to INSTALL.INS

                        if (g_fServerICW  ||  g_fServerKiosk)
                        {
                            TCHAR szCabURL[MAX_URL];
                            LPTSTR pszCabName;

                            // for server-based signup, write the following entries so that ICW doesn't
                            // close the RAS connection after downloading the INS file
                            WritePrivateProfileString(TEXT("Custom"), TEXT("Keep_Connection"), TEXT("Yes"), szFile);
                            WritePrivateProfileString(TEXT("Custom"), TEXT("Run"), TEXT("rundll32.exe"), szFile);
                            WritePrivateProfileString(TEXT("Custom"), TEXT("Argument"), TEXT("IEDKCS32.DLL,CloseRASConnections"), szFile);

                            // write the URL to the branding cab
                            // BUGBUG: should probably use InternetComineUrl()
                            GetPrivateProfileString(IS_APPLYINS, IK_BRAND_URL, TEXT(""), szCabURL, countof(szCabURL), szFile);
                            ASSERT(ISNONNULL(szCabURL));

                            pszCabName = szCabURL + StrLen(szCabURL);
                            if (*CharPrev(szCabURL, pszCabName) != TEXT('/'))
                                *pszCabName++ = TEXT('/');

                            GetPrivateProfileString(IS_APPLYINS, IK_BRAND_NAME, TEXT(""), pszCabName,
                                                        countof(szCabURL) - (DWORD) (pszCabName - szCabURL), szFile);
                            ASSERT(ISNONNULL(pszCabName));

                            WritePrivateProfileString(IS_CUSTOMBRANDING, IK_BRANDING, szCabURL, szFile);

                            WritePrivateProfileString(NULL, NULL, NULL, szFile);
                        }
                    }
                }
                else if (HasFlag(dwFlags, PINSF_COPYCAB))
                {
                    // for server-based signup, copy branding.cab only if ApplyIns is TRUE
                    if ((g_fServerICW || g_fServerKiosk)  &&
                        InsGetBool(IS_APPLYINS, IK_APPLYINS, 0, szFile))
                    {
                        GetPrivateProfileString(IS_APPLYINS, IK_BRAND_NAME, TEXT(""), pszCabName,
                                                    countof(szCabName) - (DWORD) (pszCabName - szCabName), szFile);
                        ASSERT(ISNONNULL(pszCabName));

                        CopyFile(pcszOutDir, szCabName, FALSE);     // pcszOutDir actually points to BRANDING.CAB
                    }
                }
                else if (HasFlag(dwFlags, PINSF_FIXINS))
                {
                    InsWriteBool(IS_BRANDING, IK_SERVERLESS, TRUE, szFile);
                    WritePrivateProfileString(NULL, NULL, NULL, szFile);
                }
                else if (HasFlag(dwFlags, PINSF_NOCLEAR))
                {
                    InsWriteBool(IS_BRANDING, TEXT("NoClear"), TRUE, szFile);
                    WritePrivateProfileString(NULL, NULL, NULL, szFile);
                }
            }
        } while (FindNextFile(hFind, &fd));

        FindClose(hFind);
    }

    return nFiles;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

static void WritePIDValues(LPCTSTR pcszInsFile, LPCTSTR pcszSetupInf)
{
    TCHAR szValue[32];

    // MS1 is the MPC code and MS2 is the 6-8 position chars that are replaced in the PID
    // we check to see if there are custom values in the INS file and make sure these are
    // cleared before cabbing into the branding cab.
    // the values are writen to the iesetup.inf that goes into ie6setup.exe with the default
    // MS2 value always being OEM

    if (GetPrivateProfileString(IS_BRANDING, TEXT("MS1"), TEXT(""), szValue, countof(szValue), pcszInsFile))
    {
        WritePrivateProfileString(IS_BRANDING, TEXT("MS1"), szValue, pcszSetupInf);
        WritePrivateProfileString(IS_BRANDING, TEXT("MS1"), NULL, pcszInsFile);
    }

    // pass size as 4 since MS2 can only be 3 chars long

    if (GetPrivateProfileString(IS_BRANDING, TEXT("MS2"), TEXT(""), szValue, 4, pcszInsFile))
    {
        WritePrivateProfileString(IS_BRANDING, TEXT("MS2"), szValue, pcszSetupInf);
        WritePrivateProfileString(IS_BRANDING, TEXT("MS2"), NULL, pcszInsFile);
    }
    else
        WritePrivateProfileString(IS_BRANDING, TEXT("MS2"), TEXT("OEM"), pcszSetupInf);

    WritePrivateProfileString(NULL, NULL, NULL, pcszInsFile);
}

static void WriteURDComponent(CCifRWFile_t *lpCifRWFileDest, LPCTSTR pcszModes)
{
    ICifRWGroup * pCifRWGroup = NULL;
    CCifRWGroup_t * pCifRWGroup_t = NULL;
    ICifRWComponent * pCifRWComponent = NULL;
    CCifRWComponent_t * pCifRWComponent_t = NULL;
    BOOL fGroup = FALSE;

    if (lpCifRWFileDest == NULL)
        return;

    lpCifRWFileDest->CreateGroup(POSTCUSTITEMS, &pCifRWGroup);
    if (pCifRWGroup != NULL)
    {
        pCifRWGroup_t = new CCifRWGroup_t(pCifRWGroup);
        if (pCifRWGroup_t != NULL)
        {
            TCHAR szCustDesc[MAX_PATH];

            LoadString(g_rvInfo.hInst, IDS_CUSTOMCOMPTITLE, szCustDesc, countof(szCustDesc));
            pCifRWGroup_t->SetDescription(szCustDesc);
            pCifRWGroup_t->SetPriority(1);
            delete pCifRWGroup_t;
            fGroup = TRUE;
        }
    }

    if (fGroup)
    {
        lpCifRWFileDest->CreateComponent(URDCOMP, &pCifRWComponent);
        if (pCifRWComponent != NULL)
        {
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            if (pCifRWComponent_t != NULL)
            {
                DWORD dwSize = 0;
                HANDLE hFile;
                TCHAR szURDPath[MAX_PATH];

                pCifRWComponent_t->SetGroup(POSTCUSTITEMS);
                pCifRWComponent_t->SetGUID(URD_GUID_STR);
                pCifRWComponent_t->SetDescription(TEXT("URD Component"));
                pCifRWComponent_t->SetDetails(TEXT(""));
                pCifRWComponent_t->SetCommand(0, IE55URD_EXE, TEXT("/s"), INST_EXE);
                pCifRWComponent_t->SetUrl(0, IE55URD_EXE, 2);
                pCifRWComponent_t->SetPriority(1);
                pCifRWComponent_t->SetVersion(TEXT(""));
                pCifRWComponent_t->SetUninstallKey(TEXT(""));
                pCifRWComponent_t->SetUIVisible(FALSE);
    
                StrCpy(szURDPath, g_szMastInf);
                PathRemoveFileSpec(szURDPath);
                PathAppend(szURDPath, IE55URD_EXE);
                if ((hFile = CreateFile(szURDPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
                {
                    dwSize = ((dwSize = GetFileSize(hFile, NULL)) != 0xffffffff) ? (dwSize >> 10) : 0;
                    CloseHandle(hFile);
                }
                pCifRWComponent_t->SetDownloadSize(dwSize);

                WriteModesToCif(pCifRWComponent_t, pcszModes);
                delete pCifRWComponent_t;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\cabclass.h ===
#ifndef _CABCLASS_H_
#define _CABCLASS_H_

// enumerated type for mapping features to directories, this corresponds
// directly to our mappings array in the class so make sure you add your
// feature and its mapping in the same order

typedef enum tagFEATURE {
    FEATURE_BRAND = 0,
    FEATURE_FAVORITES,
    FEATURE_CONNECT,
    FEATURE_CHANNELS,
    FEATURE_DESKTOPCOMPONENTS,
    FEATURE_TOOLBAR,
    FEATURE_MYCPTR,
    FEATURE_CTLPANEL,
    FEATURE_LDAP,
    FEATURE_OE,
    FEATURE_WALLPAPER,
    FEATURE_BTOOLBAR
} FEATURE;

typedef struct tagFEATUREMAPPING
{
    INT index;                  // index into cab name array
    TCHAR szDirName[32];
} FEATUREMAPPING, *PFEATUREMAPPING;

class CCabMappings
{
private:
    static const TCHAR *c_szCabNameArray[];
    static const FEATUREMAPPING c_fmFeatureList[];

public:
    void GetFeatureDir(FEATURE feature, LPTSTR pszDir, BOOL fFullyQualified = TRUE);
    HRESULT MakeCab(int index, LPCTSTR pcszDestDir, LPCTSTR pcszCabName = NULL);
    HRESULT MakeCabs(LPCTSTR pcszDestDir);
};

extern CCabMappings g_cmCabMappings;       // defined in wizard.cpp

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\ie4comp.h ===
// shared defines between ie4comp.cpp and buildie.cpp

// AVS states and base components
#define COMP_OPTIONAL 0
#define COMP_CORE 1
#define COMP_SERVER 2

#define BROWN  0
#define BROWN2 1
#define BLUE   2
#define BLUE2  3
#define RED    4
#define YELLOW 5
#define GREEN  6

// custom components

#define INST_CAB 0
#define INST_EXE 2
#define MAXCUST 16

//Indicates the last predefined sourcefiles section in ie4cust.sed + 1
#define SED_START_INDEX 5

#define PLAT_I386 0
#define PLAT_W98 1
#define PLAT_NTx86 2
#define PLAT_ALPHA 3

// download sites

#define NUMSITES 50

typedef struct tag_sitedata
{
    TCHAR szName[80];
    TCHAR szUrl[MAX_URL];       // BUBUG: should dynamically allocate
    TCHAR szRegion[80];
} SITEDATA, *PSITEDATA;

typedef struct component_version
{
    TCHAR szID[MAX_PATH];
    TCHAR szVersion[MAX_PATH];
} COMP_VERSION, *PCOMP_VERSION;

void GetUpdateSite();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\ie4chnl.cpp ===
#include "precomp.h"

#define NSUBGRPS 10
#define CSOF_FAILIFTHERE   0x80000000L   // dependent on shellp.h value

extern TCHAR g_szDestCif[];
extern TCHAR g_szBuildTemp[];
extern TCHAR g_szCustIns[];
extern TCHAR g_szBuildRoot[];
extern BOOL g_fBatch, g_fIntranet;
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

void SetCompSize(LPTSTR szCab, LPTSTR szSect, DWORD dwInstallSize)
{
    DWORD dwDownloadSize, dwTolerance, dwsHi, dwLowSize, dwHighSize;
    HANDLE hCab = CreateFile(szCab, GENERIC_READ, 0, NULL, OPEN_EXISTING, NULL, NULL);
    TCHAR szSize[32];

    if (hCab == INVALID_HANDLE_VALUE)
        return;

    dwDownloadSize = GetFileSize( hCab, &dwsHi ) >> 10;
    if (dwInstallSize ==0)
        dwInstallSize = dwDownloadSize << 1;
    CloseHandle(hCab);
    wnsprintf(szSize, countof(szSize), TEXT("%i,%i"), dwDownloadSize, dwInstallSize);

    ICifRWComponent * pCifRWComponent;

    if (SUCCEEDED(g_lpCifRWFileDest->CreateComponent(szSect, &pCifRWComponent)))
    {
        pCifRWComponent->SetDownloadSize(dwDownloadSize);
        pCifRWComponent->SetExtractSize(dwInstallSize);
        pCifRWComponent->SetInstalledSize(0, dwInstallSize);
        return;
    }

    if (dwDownloadSize <= 7)
        dwTolerance = 100;
    else
    {
        if (dwDownloadSize > 60)
            dwTolerance = 10;
        else
            dwTolerance = (600 / dwDownloadSize);
    }

    wnsprintf(szSize, countof(szSize), TEXT("0,%i"), dwInstallSize);
    WritePrivateProfileString( szSect, TEXT("InstalledSize"), szSize, g_szDestCif );
    dwTolerance = (dwDownloadSize * dwTolerance) / 100;
    dwLowSize = dwDownloadSize - dwTolerance;
    dwHighSize = dwDownloadSize + dwTolerance;
    wnsprintf(szSize, countof(szSize), TEXT("%i,%i"), dwLowSize, dwHighSize);
    WritePrivateProfileString( szSect, TEXT("Size1"), szSize, g_szDestCif );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\guids.cpp ===
#include "precomp.h"

#define INITGUID
#include <initguid.h>

// {BFC880F1-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(CLSID_DownloadSiteMgr,
0xbfc880f1, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

// {BFC880F0-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(IID_IDownloadSiteMgr,
0xbfc880f0, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

// {71F159B0-139A-4555-BE78-D728734BB5D4}
DEFINE_GUID(URD_GUID,
0x71f159b0, 0x139a, 0x4555, 0xbe, 0x78, 0xd7, 0x28, 0x73, 0x4b, 0xb5, 0xd4);

#include "iedkbrnd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\customoe.cpp ===
#include "precomp.h"

extern PROPSHEETPAGE g_psp[NUM_PAGES];
extern TCHAR         g_szCustIns[MAX_PATH];
extern TCHAR         g_szTempSign[];
extern int           g_iCurPage;
extern BOOL          g_fDisableIMAPPage;
extern BOOL          g_fIntranet;

#define MAX_SERVER  256

static const TCHAR c_sz1[] = TEXT("1");
static const TCHAR c_sz0[] = TEXT("0");
static const TCHAR c_szYes[] = TEXT("Yes");
static const TCHAR c_szNo[] = TEXT("No");
static const TCHAR c_szEmpty[] = TEXT("");
static const TCHAR c_szNULL[] = TEXT("NULL");

/////////////////////////////////////////////////////////////////////////////
// MailServer

INT_PTR CALLBACK MailServer(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR   szMailServer[MAX_SERVER],
            szSMTPServer[MAX_SERVER],
            szNewsServer[MAX_SERVER],
            szChoice[16];
    LPCTSTR pszKey;
    HWND    hComboBox;
    BOOL    fIMAP,
            fSPAMail, fSPASMTP, fSPANNTP,
            fAcctRO, fNoModify;

    UNREFERENCED_PARAMETER(wParam);

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_MAILSERVER);
        EnableDBCSChars(hDlg, IDE_SMTPSERVER);
        EnableDBCSChars(hDlg, IDE_NEWSERVER);

        Edit_LimitText(GetDlgItem(hDlg, IDE_MAILSERVER), countof(szMailServer)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SMTPSERVER), countof(szSMTPServer)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_NEWSERVER),  countof(szNewsServer)-1);

        hComboBox = GetDlgItem(hDlg, IDC_POPIMAP);
        ComboBox_ResetContent(hComboBox);

        LoadString(g_rvInfo.hInst, IDS_POP3, szChoice, countof(szChoice));
        ComboBox_AddString(hComboBox, szChoice);

        LoadString(g_rvInfo.hInst, IDS_IMAP, szChoice, countof(szChoice));
        ComboBox_AddString(hComboBox, szChoice);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields -----

            // only allow branding of news server fields if OCW is running us and they're installing
            // outlook

            fIMAP  = InsGetYesNo(IS_INTERNETMAIL, IK_USEIMAP, FALSE, g_szCustIns);
            pszKey = fIMAP ? IK_IMAPSERVER : IK_POPSERVER;

            GetPrivateProfileString(IS_INTERNETMAIL, pszKey,        c_szEmpty, szMailServer, countof(szMailServer), g_szCustIns);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_SMTPSERVER, c_szEmpty, szSMTPServer, countof(szSMTPServer), g_szCustIns);

            StrRemoveWhitespace(szMailServer);
            StrRemoveWhitespace(szSMTPServer);

            fSPAMail   = InsGetYesNo(IS_INTERNETMAIL, IK_USESPA,        FALSE, g_szCustIns);
            fSPASMTP   = InsGetYesNo(IS_INTERNETMAIL, IK_SMTPUSESPA,    FALSE, g_szCustIns);

            fAcctRO    = InsGetYesNo(IS_OEGLOBAL,     IK_READONLY,      FALSE, g_szCustIns);
            fNoModify  = InsGetYesNo(IS_OEGLOBAL,     IK_NOMODIFYACCTS, FALSE, g_szCustIns);

            SetDlgItemText(hDlg, IDE_MAILSERVER, szMailServer);
            SetDlgItemText(hDlg, IDE_SMTPSERVER, szSMTPServer);

            CheckDlgButton(hDlg, IDC_USESPAMAIL,    fSPAMail);
            CheckDlgButton(hDlg, IDC_USESPASMTP,    fSPASMTP);

            CheckDlgButton(hDlg, IDC_ACCTRO,        fAcctRO);
            if (g_fIntranet)
                CheckDlgButton(hDlg, IDC_ACCTNOCONFIG,  fNoModify);

            ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_POPIMAP), fIMAP ? 1 : 0);

            GetPrivateProfileString(IS_INTERNETNEWS, IK_NNTPSERVER, c_szEmpty, szNewsServer, countof(szNewsServer), g_szCustIns);
            StrRemoveWhitespace(szNewsServer);

            fSPANNTP   = InsGetYesNo(IS_INTERNETNEWS, IK_USESPA,        FALSE, g_szCustIns);

            SetDlgItemText(hDlg, IDE_NEWSERVER,  szNewsServer);
            CheckDlgButton(hDlg, IDC_USESPANNTP,    fSPANNTP);

            CheckBatchAdvance(hDlg);            // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //----- Read data from controls into internal variables -----

            fIMAP = (ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_POPIMAP)) > 0);
            g_fDisableIMAPPage = !fIMAP;

            GetDlgItemText(hDlg, IDE_MAILSERVER, szMailServer, countof(szMailServer));
            GetDlgItemText(hDlg, IDE_SMTPSERVER, szSMTPServer, countof(szSMTPServer));

            StrRemoveWhitespace(szMailServer);
            StrRemoveWhitespace(szSMTPServer);

            fSPAMail   = IsDlgButtonChecked(hDlg, IDC_USESPAMAIL);
            fSPASMTP   = IsDlgButtonChecked(hDlg, IDC_USESPASMTP);

            fAcctRO     = IsDlgButtonChecked(hDlg, IDC_ACCTRO);
            fNoModify   = IsDlgButtonChecked(hDlg, IDC_ACCTNOCONFIG);

            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_INTERNETMAIL, IK_USEIMAP, fIMAP ? c_szYes : c_szNo, g_szCustIns);
            if (fIMAP)
            {
                WritePrivateProfileString(IS_INTERNETMAIL, IK_IMAPSERVER, szMailServer, g_szCustIns);
                WritePrivateProfileString(IS_INTERNETMAIL, IK_POPSERVER,  NULL,         g_szCustIns);
            }
            else
            {
                WritePrivateProfileString(IS_INTERNETMAIL, IK_IMAPSERVER, NULL,         g_szCustIns);
                WritePrivateProfileString(IS_INTERNETMAIL, IK_POPSERVER,  szMailServer, g_szCustIns);
            }

            WritePrivateProfileString(IS_INTERNETMAIL, IK_SMTPSERVER, szSMTPServer, g_szCustIns);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_USESPA,       fSPAMail ? c_szYes : c_szNo, g_szCustIns);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_SMTPUSESPA,   fSPASMTP ? c_szYes : c_szNo, g_szCustIns);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_SMTPREQLOGON, fSPASMTP ? c_sz1   : c_sz0,  g_szCustIns);

            WritePrivateProfileString(IS_OEGLOBAL,     IK_READONLY,     fAcctRO  ? c_sz1   : c_sz0,  g_szCustIns);
            if (g_fIntranet)
                WritePrivateProfileString(IS_OEGLOBAL,     IK_NOMODIFYACCTS,fNoModify? c_sz1   : c_sz0,  g_szCustIns);

            GetDlgItemText(hDlg, IDE_NEWSERVER,  szNewsServer, countof(szNewsServer));

            StrRemoveWhitespace(szNewsServer);

            fSPANNTP   = IsDlgButtonChecked(hDlg, IDC_USESPANNTP);

            WritePrivateProfileString(IS_INTERNETNEWS, IK_NNTPSERVER, szNewsServer, g_szCustIns);

            WritePrivateProfileString(IS_INTERNETNEWS, IK_USESPA,       fSPANNTP ? c_szYes : c_szNo, g_szCustIns);
            WritePrivateProfileString(IS_INTERNETNEWS, IK_REQLOGON,     fSPANNTP ? c_sz1   : c_sz0,  g_szCustIns);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_MAIL;
            EnablePages();

            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// IMAPSettings

INT_PTR CALLBACK IMAPSettings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR   szRFP[MAX_PATH], szSentPath[MAX_PATH], szDrafts[MAX_PATH];
    BOOL    fSpecial, fCheckNew;

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_ROOTPATH);
        EnableDBCSChars(hDlg, IDE_SENTPATH);
        EnableDBCSChars(hDlg, IDE_DRAFTSPATH);

        Edit_LimitText(GetDlgItem(hDlg, IDE_ROOTPATH), countof(szRFP)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SENTPATH), countof(szSentPath)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_DRAFTSPATH),  countof(szDrafts)-1);
        break;

    case WM_COMMAND:
        if (BN_CLICKED == HIWORD(wParam))
        {
            switch (LOWORD(wParam))
            {
            case IDC_STORESPECIAL:
                fSpecial = IsDlgButtonChecked(hDlg, IDC_STORESPECIAL);
                EnableDlgItem2(hDlg, IDE_SENTPATH, fSpecial);
                EnableDlgItem2(hDlg, IDC_SENTPATH_TXT, fSpecial);
                EnableDlgItem2(hDlg, IDE_DRAFTSPATH, fSpecial);
                EnableDlgItem2(hDlg, IDC_DRAFTSPATH_TXT, fSpecial);
                break;
            }
            break;
        }

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields -----
            GetPrivateProfileString(IS_INTERNETMAIL, IK_RFP,        c_szEmpty, szRFP,        countof(szRFP),        g_szCustIns);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_SENTITEMS,  c_szEmpty, szSentPath,   countof(szSentPath),   g_szCustIns);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_DRAFTS,     c_szEmpty, szDrafts,     countof(szDrafts),     g_szCustIns);

            StrRemoveWhitespace(szRFP);
            StrRemoveWhitespace(szSentPath);
            StrRemoveWhitespace(szDrafts);

            fCheckNew  = GetPrivateProfileInt(IS_INTERNETMAIL, IK_CHECKFORNEW,   FALSE, g_szCustIns);
            fSpecial   = GetPrivateProfileInt(IS_INTERNETMAIL, IK_USESPECIAL,    FALSE, g_szCustIns);

            SetDlgItemText(hDlg, IDE_ROOTPATH,   szRFP);
            SetDlgItemText(hDlg, IDE_SENTPATH,   szSentPath);
            SetDlgItemText(hDlg, IDE_DRAFTSPATH, szDrafts);

            CheckDlgButton(hDlg, IDC_STORESPECIAL,  fSpecial);
            CheckDlgButton(hDlg, IDC_CHECKNEW,      fCheckNew);

            EnableDlgItem2(hDlg, IDE_SENTPATH, fSpecial);
            EnableDlgItem2(hDlg, IDC_SENTPATH_TXT, fSpecial);
            EnableDlgItem2(hDlg, IDE_DRAFTSPATH, fSpecial);
            EnableDlgItem2(hDlg, IDC_DRAFTSPATH_TXT, fSpecial);

            CheckBatchAdvance(hDlg);            // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //----- Read data from controls into internal variables -----
            GetDlgItemText(hDlg, IDE_ROOTPATH,   szRFP,        countof(szRFP));
            GetDlgItemText(hDlg, IDE_SENTPATH,   szSentPath,   countof(szSentPath));
            GetDlgItemText(hDlg, IDE_DRAFTSPATH, szDrafts,     countof(szDrafts));

            StrRemoveWhitespace(szRFP);
            StrRemoveWhitespace(szSentPath);
            StrRemoveWhitespace(szDrafts);

            fCheckNew  = IsDlgButtonChecked(hDlg, IDC_CHECKNEW);
            fSpecial   = IsDlgButtonChecked(hDlg, IDC_STORESPECIAL);

            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_INTERNETMAIL, IK_RFP,          szRFP,      g_szCustIns);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_SENTITEMS,    szSentPath, g_szCustIns);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_DRAFTS,       szDrafts,   g_szCustIns);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_CHECKFORNEW,  fCheckNew ? c_sz1 : c_sz0, g_szCustIns);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_USESPECIAL,   fSpecial ? c_sz1 : c_sz0, g_szCustIns);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_IMAP;
            EnablePages();
            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void SetTimeoutString(HWND hwnd, UINT pos)
{
    UINT cch, csec, cmin;
    TCHAR szOut[128], sz[128];

    csec = TIMEOUT_SEC_MIN + (pos * TIMEOUT_DSEC);
    ASSERT(csec >= TIMEOUT_SEC_MIN && csec <= TIMEOUT_SEC_MAX);

    cmin = csec / 60;
    csec = csec % 60;
    if (cmin > 1)
    {
        LoadString(g_rvInfo.hInst, IDS_XMINUTES, sz, countof(sz));
        wnsprintf(szOut, countof(szOut), sz, cmin);
        cch = lstrlen(szOut);
    }
    else if (cmin == 1)
    {
        cch = LoadString(g_rvInfo.hInst, IDS_1MINUTE, szOut, countof(szOut));
    }
    else
    {
        cch = 0;
    }

    if (csec != 0)
    {
        if (cmin > 0)
        {
            szOut[cch] = TEXT(' ');
            cch++;
        }

        LoadString(g_rvInfo.hInst, IDS_XSECONDS, sz, countof(sz));
        wnsprintf(&szOut[cch], countof(szOut) - cch, sz, csec);
    }

    SetWindowText(hwnd, szOut);
}

/////////////////////////////////////////////////////////////////////////////
// LDAPServer

INT_PTR CALLBACK LDAPServer(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szLDAPServer[MAX_SERVER],
          szLDAPHome[INTERNET_MAX_URL_LENGTH],
          szLDAPBitmap[MAX_PATH],
          szWorkDir[MAX_PATH],
          szLDAPFriendly[MAX_SERVER],
          szLDAPBase[128],
          szTmp[MAX_PATH];
    BOOL  fLDAPCheck,
          fTrans;
    UINT  uTimeout,
          uMatches,
          uAuthType;
    DWORD dwFlags;

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_FRIENDLYNAME);
        EnableDBCSChars(hDlg, IDE_SEARCHBASE);
        EnableDBCSChars(hDlg, IDE_LDAPBITMAP);
        EnableDBCSChars(hDlg, IDE_DIRSERVICE);
        EnableDBCSChars(hDlg, IDE_LDAPHOMEPAGE);

        Edit_LimitText(GetDlgItem(hDlg, IDE_FRIENDLYNAME), countof(szLDAPFriendly) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_DIRSERVICE),   countof(szLDAPServer) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_LDAPHOMEPAGE), countof(szLDAPHome) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SEARCHBASE),   countof(szLDAPBase) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_LDAPBITMAP),   countof(szLDAPBitmap) - 1);

        SendDlgItemMessage(hDlg, IDC_TIMEOUTSLD, TBM_SETRANGE, 0, (LPARAM)MAKELONG(0, CTIMEOUT - 1));

        SendDlgItemMessage(hDlg, IDC_SPIN1, UDM_SETRANGE, 0, MAKELONG(MATCHES_MAX, MATCHES_MIN));
        Edit_LimitText(GetDlgItem(hDlg, IDE_MATCHES),   4);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_HSCROLL:
        SetTimeoutString(GetDlgItem(hDlg, IDC_TIMEOUT), (UINT) SendMessage((HWND)lParam, TBM_GETPOS, 0, 0));
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            switch (LOWORD(wParam))
            {
            case IDC_BROWSELDAP:
                GetDlgItemText(hDlg, IDE_LDAPBITMAP, szLDAPBitmap, countof(szLDAPBitmap));

                if (BrowseForFile(hDlg, szLDAPBitmap, countof(szLDAPBitmap), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_LDAPBITMAP, szLDAPBitmap);
                break;

            default:
                return FALSE;
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

            //----- Initialization of fields -----
            GetPrivateProfileString(IS_LDAP, IK_FRIENDLYNAME, c_szEmpty,        szLDAPFriendly, countof(szLDAPFriendly), g_szCustIns);
            GetPrivateProfileString(IS_LDAP, IK_SERVER,       c_szEmpty,        szLDAPServer,   countof(szLDAPServer),   g_szCustIns);
            GetPrivateProfileString(IS_LDAP, IK_LDAPHOMEPAGE, c_szEmpty,        szLDAPHome,     countof(szLDAPHome),     g_szCustIns);
            GetPrivateProfileString(IS_LDAP, IK_SEARCHBASE,   c_szNULL,         szLDAPBase,     countof(szLDAPBase),     g_szCustIns);
            GetPrivateProfileString(IS_LDAP, IK_BITMAP,       c_szEmpty,        szLDAPBitmap,   countof(szLDAPBitmap),   g_szCustIns);

            StrRemoveWhitespace(szLDAPFriendly);
            StrRemoveWhitespace(szLDAPServer);
            StrRemoveWhitespace(szLDAPHome);
            StrRemoveWhitespace(szLDAPBase);
            StrRemoveWhitespace(szLDAPBitmap);

            fLDAPCheck    = (BOOL)GetPrivateProfileInt(IS_LDAP, IK_CHECKNAMES, FALSE, g_szCustIns);

            uTimeout      = GetPrivateProfileInt(IS_LDAP, IK_TIMEOUT, TIMEOUT_SEC_DEFAULT, g_szCustIns);
            if (uTimeout < TIMEOUT_SEC_MIN)
                uTimeout = TIMEOUT_SEC_MIN;
            else if (uTimeout > TIMEOUT_SEC_MAX)
                uTimeout = TIMEOUT_SEC_MAX;

            uMatches      = GetPrivateProfileInt(IS_LDAP, IK_MATCHES, MATCHES_DEFAULT, g_szCustIns);
            if (uMatches < MATCHES_MIN)
                uMatches = MATCHES_MIN;
            else if (uMatches > MATCHES_MAX)
                uMatches = MATCHES_MAX;

            uAuthType     = GetPrivateProfileInt(IS_LDAP, IK_AUTHTYPE, AUTH_ANONYMOUS, g_szCustIns);
            if (uAuthType != AUTH_ANONYMOUS && uAuthType != AUTH_SPA)
                uAuthType = AUTH_ANONYMOUS;

            SetDlgItemText(hDlg, IDE_FRIENDLYNAME, szLDAPFriendly);
            SetDlgItemText(hDlg, IDE_DIRSERVICE,   szLDAPServer);
            SetDlgItemText(hDlg, IDE_LDAPHOMEPAGE, szLDAPHome);
            SetDlgItemText(hDlg, IDE_SEARCHBASE,   szLDAPBase);
            SetDlgItemText(hDlg, IDE_LDAPBITMAP,   szLDAPBitmap);

            uTimeout = (uTimeout / TIMEOUT_DSEC) - 1;
            SendDlgItemMessage(hDlg, IDC_TIMEOUTSLD, TBM_SETPOS, TRUE, (LPARAM)uTimeout);
            SetTimeoutString(GetDlgItem(hDlg, IDC_TIMEOUT), uTimeout);

            SetDlgItemInt(hDlg, IDE_MATCHES, uMatches, FALSE);

            CheckDlgButton(hDlg, IDC_CHECKNAMES, fLDAPCheck ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_SPA, uAuthType == AUTH_SPA ? BST_CHECKED : BST_UNCHECKED);

            PathCombine(szTmp, g_szTempSign, PathFindFileName(szLDAPBitmap));
            DeleteFile(szTmp);

            CheckBatchAdvance(hDlg);            // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //----- Read data from controls into internal variables -----
            GetDlgItemText(hDlg, IDE_FRIENDLYNAME, szLDAPFriendly, countof(szLDAPFriendly));
            GetDlgItemText(hDlg, IDE_DIRSERVICE,   szLDAPServer,   countof(szLDAPServer));
            GetDlgItemText(hDlg, IDE_LDAPHOMEPAGE, szLDAPHome,     countof(szLDAPHome));
            GetDlgItemText(hDlg, IDE_SEARCHBASE,   szLDAPBase,     countof(szLDAPBase));
            GetDlgItemText(hDlg, IDE_LDAPBITMAP,   szLDAPBitmap,   countof(szLDAPBitmap));

            StrRemoveWhitespace(szLDAPFriendly);
            StrRemoveWhitespace(szLDAPServer);
            StrRemoveWhitespace(szLDAPHome);
            StrRemoveWhitespace(szLDAPBase);
            StrRemoveWhitespace(szLDAPBitmap);

            fLDAPCheck    = IsDlgButtonChecked(hDlg, IDC_CHECKNAMES);
            uAuthType     = IsDlgButtonChecked(hDlg, IDC_SPA) ? AUTH_SPA : AUTH_ANONYMOUS;

            uTimeout = (UINT) SendDlgItemMessage(hDlg, IDC_TIMEOUTSLD, TBM_GETPOS, 0, 0);
            uTimeout = TIMEOUT_SEC_MIN + (uTimeout * TIMEOUT_DSEC);

            uMatches = GetDlgItemInt(hDlg, IDE_MATCHES, &fTrans, FALSE);
            // TODO: we should probably display an error msg here
            if (!fTrans)
                uMatches = MATCHES_DEFAULT;
            else if (uMatches < MATCHES_MIN)
                uMatches = MATCHES_MIN;
            else if (uMatches > MATCHES_MAX)
                uMatches = MATCHES_MAX;

            //----- Validate the input -----
            dwFlags = FC_FILE | FC_EXISTS;

            if (!CheckField(hDlg, IDE_LDAPBITMAP, dwFlags))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                break;
            }

            if (!CheckField(hDlg, IDE_LDAPHOMEPAGE, FC_URL))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                break;
            }

            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_LDAP, IK_FRIENDLYNAME, szLDAPFriendly, g_szCustIns);
            WritePrivateProfileString(IS_LDAP, IK_SERVER,       szLDAPServer,   g_szCustIns);
            WritePrivateProfileString(IS_LDAP, IK_LDAPHOMEPAGE, szLDAPHome,     g_szCustIns);
            InsWriteQuotedString (IS_LDAP, IK_SEARCHBASE,   szLDAPBase,     g_szCustIns);
            WritePrivateProfileString(IS_LDAP, IK_BITMAP,       szLDAPBitmap,   g_szCustIns);

            WritePrivateProfileString(IS_LDAP, IK_CHECKNAMES, fLDAPCheck ? c_sz1 : c_sz0, g_szCustIns);

            wnsprintf(szWorkDir, countof(szWorkDir), TEXT("%i"), uTimeout);
            WritePrivateProfileString(IS_LDAP, IK_TIMEOUT, szWorkDir, g_szCustIns);

            wnsprintf(szWorkDir, countof(szWorkDir), TEXT("%i"), uMatches);
            WritePrivateProfileString(IS_LDAP, IK_MATCHES, szWorkDir, g_szCustIns);

            wnsprintf(szWorkDir, countof(szWorkDir), TEXT("%i"), uAuthType);
            WritePrivateProfileString(IS_LDAP, IK_AUTHTYPE, szWorkDir, g_szCustIns);

            g_cmCabMappings.GetFeatureDir(FEATURE_LDAP, szWorkDir);
            ImportLDAPBitmap(g_szCustIns, szWorkDir, TRUE);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_LDAP;
            EnablePages();
            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CustomizeOE

INT_PTR CALLBACK CustomizeOE(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szInfopane[INTERNET_MAX_URL_LENGTH],
          szInfopaneBmp[MAX_PATH],
          szHTMLPath[MAX_PATH],
          szWorkDir[MAX_PATH],
          szSender[255],
          szReply[255],
          szTmp[MAX_PATH];
    UINT  nID;
    BOOL  fURL;
    DWORD dwFlags;

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_OELOCALPATH);
        EnableDBCSChars(hDlg, IDE_OEIMAGEPATH);
        EnableDBCSChars(hDlg, IDE_OEWMPATH);
        EnableDBCSChars(hDlg, IDE_OEWMSENDER);

        EnableDBCSChars(hDlg, IDE_OEPANEURL);
        EnableDBCSChars(hDlg, IDE_OEWMREPLYTO);

        Edit_LimitText(GetDlgItem(hDlg, IDE_OEPANEURL),   countof(szInfopane) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OELOCALPATH), MAX_PATH);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OEIMAGEPATH), countof(szInfopaneBmp) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OEWMPATH),    countof(szHTMLPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OEWMSENDER),  countof(szSender) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_OEWMREPLYTO), countof(szReply) - 1);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            switch (LOWORD(wParam))
            {
            case IDC_OEPANEURL:
            case IDC_OEPANELOCAL:
                fURL = (LOWORD(wParam) == IDC_OEPANEURL);
                
                EnableDlgItem2(hDlg, IDE_OEPANEURL,      fURL);
                EnableDlgItem2(hDlg, IDE_OELOCALPATH,   !fURL);
                EnableDlgItem2(hDlg, IDC_BROWSEOEHTML,  !fURL);
                EnableDlgItem2(hDlg, IDC_OELOCALPATH_TXT, !fURL);
                EnableDlgItem2(hDlg, IDE_OEIMAGEPATH,   !fURL);
                EnableDlgItem2(hDlg, IDC_BROWSEOEIMAGE, !fURL);
                EnableDlgItem2(hDlg, IDC_OEIMAGEPATH_TXT, !fURL);
                break;

            case IDC_BROWSEOEHTML:
                GetDlgItemText(hDlg, IDE_OELOCALPATH, szInfopane, countof(szInfopane));

                if (BrowseForFile(hDlg, szInfopane, countof(szInfopane), GFN_LOCALHTM))
                    SetDlgItemText(hDlg, IDE_OELOCALPATH, szInfopane);
                break;

            case IDC_BROWSEOEIMAGE:
                GetDlgItemText(hDlg, IDE_OEIMAGEPATH, szInfopaneBmp, countof(szInfopaneBmp));

                if (BrowseForFile(hDlg, szInfopaneBmp, countof(szInfopaneBmp), GFN_PICTURE))
                    SetDlgItemText(hDlg, IDE_OEIMAGEPATH, szInfopaneBmp);
                break;

            case IDC_BROWSEOEWM:
                GetDlgItemText(hDlg, IDE_OEWMPATH, szHTMLPath, countof(szHTMLPath));

                if (BrowseForFile(hDlg, szHTMLPath, countof(szHTMLPath), GFN_LOCALHTM))
                    SetDlgItemText(hDlg, IDE_OEWMPATH, szHTMLPath);
                break;

            default:
                break;
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields (1st phase) -----
            GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE,       c_szEmpty, szInfopane,    countof(szInfopane),    g_szCustIns);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP,    c_szEmpty, szInfopaneBmp, countof(szInfopaneBmp), g_szCustIns);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, c_szEmpty, szHTMLPath,    countof(szHTMLPath),    g_szCustIns);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMENAME,    c_szEmpty, szSender,      countof(szSender),      g_szCustIns);
            GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEADDR,    c_szEmpty, szReply,       countof(szReply),       g_szCustIns);

            StrRemoveWhitespace(szInfopane);
            StrRemoveWhitespace(szInfopaneBmp);
            StrRemoveWhitespace(szHTMLPath);
            StrRemoveWhitespace(szSender);
            StrRemoveWhitespace(szReply);

            //----- Initialization of fields (2nd phase) -----
            nID = PathIsURL(szInfopane) ?  IDC_OEPANEURL : IDC_OEPANELOCAL;

            //----- Set read values in the controls -----
            CheckRadioButton(hDlg, IDC_OEPANEURL, IDC_OEPANELOCAL, nID);
            SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(nID, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, nID));

            if (nID == IDC_OEPANEURL)
            {
                SetDlgItemText(hDlg, IDE_OEPANEURL, szInfopane);
                SetDlgItemText(hDlg, IDE_OELOCALPATH, NULL);
            }
            else
            {
                SetDlgItemText(hDlg, IDE_OEPANEURL, NULL);
                SetDlgItemText(hDlg, IDE_OELOCALPATH, szInfopane);
            }
            SetDlgItemText(hDlg, IDE_OEIMAGEPATH, szInfopaneBmp);
            SetDlgItemText(hDlg, IDE_OEWMPATH,    szHTMLPath);
            SetDlgItemText(hDlg, IDE_OEWMSENDER,  szSender);
            SetDlgItemText(hDlg, IDE_OEWMREPLYTO, szReply);

            if ((nID != IDC_OEPANEURL) && ISNONNULL(szInfopane))
            {
                PathCombine(szTmp, g_szTempSign, PathFindFileName(szInfopane));
                DeleteFile(szTmp);
            }

            if (ISNONNULL(szInfopaneBmp))
            {
                PathCombine(szTmp, g_szTempSign, PathFindFileName(szInfopaneBmp));
                DeleteFile(szTmp);
            }

            if (ISNONNULL(szHTMLPath))
            {
                PathCombine(szTmp, g_szTempSign, PathFindFileName(szHTMLPath));
                DeleteFile(szTmp);
            }
            CheckBatchAdvance(hDlg);        // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //----- Read data from controls into internal variables -----
            nID = IsDlgButtonChecked(hDlg, IDC_OEPANEURL) == BST_CHECKED ? IDE_OEPANEURL : IDE_OELOCALPATH;

            GetDlgItemText(hDlg, nID,             szInfopane,    countof(szInfopane));
            GetDlgItemText(hDlg, IDE_OEWMSENDER,  szSender,      countof(szSender));
            GetDlgItemText(hDlg, IDE_OEWMREPLYTO, szReply,       countof(szReply));
            GetDlgItemText(hDlg, IDE_OEWMPATH,    szHTMLPath,    countof(szHTMLPath));
            GetDlgItemText(hDlg, IDE_OEIMAGEPATH, szInfopaneBmp, countof(szInfopaneBmp));

            StrRemoveWhitespace(szInfopane);
            StrRemoveWhitespace(szInfopaneBmp);
            StrRemoveWhitespace(szHTMLPath);
            StrRemoveWhitespace(szSender);
            StrRemoveWhitespace(szReply);

            //----- Validate the input -----
            dwFlags = FC_FILE | FC_EXISTS;

            if (nID == IDE_OEPANEURL)
            {
                if (!CheckField(hDlg, IDE_OEPANEURL, FC_URL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }
            }
            else
            { /* if (nID == IDE_OELOCALPATH) */
                if (!CheckField(hDlg, nID, dwFlags))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                if (!CheckField(hDlg, IDE_OEIMAGEPATH, dwFlags))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }
            }


            if (!CheckField(hDlg, IDE_OEWMPATH, dwFlags))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                break;
            }

            if (*szHTMLPath != TEXT('\0') && (!CheckField(hDlg, IDE_OEWMSENDER, FC_NONNULL) ||
                                              !CheckField(hDlg, IDE_OEWMREPLYTO, FC_NONNULL)))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                break;
            }

            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE,       szInfopane,    g_szCustIns);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP,    szInfopaneBmp, g_szCustIns);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, szHTMLPath,    g_szCustIns);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMENAME,    szSender,      g_szCustIns);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEADDR,    szReply,       g_szCustIns);

            g_cmCabMappings.GetFeatureDir(FEATURE_OE, szWorkDir);
            ImportOEInfo(g_szCustIns, szWorkDir, TRUE);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_OE;
            EnablePages();
            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    default:
        return FALSE;

    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Signature

INT_PTR CALLBACK Signature(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf1[1024],
          szBuf2[1024];
    BOOL  fUseMailForNews,
          fDoSig,
          fHtmlMail,
          fHtmlNews, fEnable;

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_MAILSIGTEXT);
        EnableDBCSChars(hDlg, IDE_NEWSSIGTEXT);

        Edit_LimitText(GetDlgItem(hDlg, IDE_MAILSIGTEXT), countof(szBuf1)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_NEWSSIGTEXT), countof(szBuf1)-1);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_MAILSIGTEXT:
            case IDC_NEWSSIGTEXT:
                fEnable = (IsDlgButtonChecked(hDlg, IDC_MAILSIGTEXT) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_MAILSIGTEXT, fEnable);
                EnableDlgItem2(hDlg, IDC_NEWSSIGTEXT, fEnable);

                fEnable &= (IsDlgButtonChecked(hDlg, IDC_NEWSSIGTEXT) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_NEWSSIGTEXT, fEnable);
                break;
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields -----
            fUseMailForNews = (BOOL)GetPrivateProfileInt(IS_MAILSIG, IK_USEMAILFORNEWS, FALSE, g_szCustIns);
            fDoSig          = (BOOL)GetPrivateProfileInt(IS_MAILSIG, IK_USESIG,         FALSE, g_szCustIns);

            fHtmlMail       = (BOOL)GetPrivateProfileInt(IS_INTERNETMAIL, IK_HTMLMSGS,  TRUE,  g_szCustIns);
            fHtmlNews       = (BOOL)GetPrivateProfileInt(IS_INTERNETNEWS, IK_HTMLMSGS,  FALSE, g_szCustIns);

            GetPrivateProfileString(IS_MAILSIG, IK_SIGTEXT, c_szEmpty, szBuf1, countof(szBuf1), g_szCustIns);
            EncodeSignature(szBuf1, szBuf2, FALSE);
            SetDlgItemText(hDlg, IDE_MAILSIGTEXT, szBuf2);

            if (!fUseMailForNews)
            {
                GetPrivateProfileString(IS_SIG, IK_SIGTEXT, c_szEmpty, szBuf1, countof(szBuf1), g_szCustIns);
                EncodeSignature(szBuf1, szBuf2, FALSE);
                SetDlgItemText(hDlg, IDE_NEWSSIGTEXT, szBuf2);
            }

            //----- Set up dialog controls -----
            // Note. Some of it is done above already;
            CheckDlgButton(hDlg, IDC_MAILSIGTEXT, fDoSig ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_NEWSSIGTEXT, (fDoSig && !fUseMailForNews) ? BST_CHECKED : BST_UNCHECKED);


            EnableDlgItem2(hDlg, IDE_MAILSIGTEXT, fDoSig);
            EnableDlgItem2(hDlg, IDC_NEWSSIGTEXT, fDoSig);
            EnableDlgItem2(hDlg, IDE_NEWSSIGTEXT, fDoSig && !fUseMailForNews);

            CheckDlgButton(hDlg, IDC_HTMLMAIL, fHtmlMail ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_HTMLNEWS, fHtmlNews ? BST_CHECKED : BST_UNCHECKED);

            CheckBatchAdvance(hDlg);        // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //----- Read data from controls into internal variables -----
            fUseMailForNews = (IsDlgButtonChecked(hDlg, IDC_NEWSSIGTEXT) != BST_CHECKED);
            fDoSig          = (IsDlgButtonChecked(hDlg, IDC_MAILSIGTEXT) == BST_CHECKED);

            fHtmlMail       = (IsDlgButtonChecked(hDlg, IDC_HTMLMAIL)    == BST_CHECKED);
            fHtmlNews       = (IsDlgButtonChecked(hDlg, IDC_HTMLNEWS)    == BST_CHECKED);

            GetDlgItemText(hDlg, IDE_MAILSIGTEXT, szBuf1, countof(szBuf1));
            EncodeSignature(szBuf1, szBuf2, TRUE);
            WritePrivateProfileString(IS_MAILSIG, IK_SIGTEXT, szBuf2, g_szCustIns);

            GetDlgItemText(hDlg, IDE_NEWSSIGTEXT, szBuf1, countof(szBuf1));
            EncodeSignature(szBuf1, szBuf2, TRUE);
            WritePrivateProfileString(IS_SIG, IK_SIGTEXT, szBuf2, g_szCustIns);

            //----- Serialize data to the *.ins file -----
            // Note. Some of it is done above already.
            WritePrivateProfileString(IS_MAILSIG, IK_USEMAILFORNEWS, fUseMailForNews ? c_sz1 : c_sz0, g_szCustIns);
            WritePrivateProfileString(IS_MAILSIG, IK_USESIG,         fDoSig          ? c_sz1 : c_sz0, g_szCustIns);
            WritePrivateProfileString(IS_SIG,     IK_USESIG,         fDoSig          ? c_sz1 : c_sz0, g_szCustIns);

            WritePrivateProfileString(IS_INTERNETMAIL, IK_HTMLMSGS,  fHtmlMail       ? c_sz1 : c_sz0, g_szCustIns);
            WritePrivateProfileString(IS_INTERNETNEWS, IK_HTMLMSGS,  fHtmlNews       ? c_sz1 : c_sz0, g_szCustIns);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_SIG;
            EnablePages();
            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    default:
        return FALSE;

    }

    return TRUE;
}

#define CBSECTION 1024

void InitializeNewsgroups(HWND hwnd, LPCTSTR pszSection, LPCTSTR pszValue, LPCTSTR pszFile)
{
    LPTSTR pszGroups, psz, pszDest;
    TCHAR szGroupSection[256];
    DWORD dw;

    dw =  GetPrivateProfileString(pszSection, pszValue, c_szEmpty, szGroupSection, countof(szGroupSection), pszFile);
    if (dw > 0)
    {
        pszGroups = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * CBSECTION);
        if (pszGroups != NULL)
        {
            dw = GetPrivateProfileSection(szGroupSection, pszGroups, CBSECTION, pszFile);
            if (dw > 0)
            {
                psz = pszGroups;
                pszDest = pszGroups;
                while (*psz != 0)
                {
                    while (*psz != 0 && *psz != '=')
                    {
                        *pszDest = *psz;
                        psz++;
                        pszDest++;
                    }

                    if (*psz != 0)
                    {
                        psz++;
                        while (*psz != 0)
                            psz++;
                    }
                    psz++;

                    *pszDest = 0x0d;
                    pszDest++;
                    *pszDest = 0x0a;
                    pszDest++;
                }

                *pszDest = 0;
            }

            SetWindowText(hwnd, pszGroups);

            LocalFree(pszGroups);
        }
    }
}

void SaveNewsgroups(HWND hwnd, LPCTSTR pszSection, LPCTSTR pszValue, LPCTSTR pszFile)
{
    LPTSTR pszGroups, psz, pszDest, pszDestT;
    TCHAR szGroupSection[256];
    DWORD dw, cch;
    BOOL fGroups;

    fGroups = FALSE;

    cch = GetWindowTextLength(hwnd);
    if (cch > 0)
    {
        cch += 4;
        pszGroups = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * cch);
        if (pszGroups != NULL)
        {
            cch = GetWindowText(hwnd, pszGroups, cch);
            psz = pszGroups;
            pszDest = pszGroups;
            pszDestT = pszDest;

            while (*psz != 0)
            {
                if (*psz == '\r' && *(psz + 1) == '\n')
                {
                    psz += 2;
                    if (pszDest > pszDestT)
                    {
                        *pszDest = '=';
                        pszDest++;
                        *pszDest = 0;
                        pszDest++;

                        pszDestT = pszDest;
                        fGroups = TRUE;
                    }
                    continue;
                }
                else if (*psz != '\t' && *psz != ' ' && *psz != '\r' && *psz != '\n')
                {
                    *pszDest = *psz;
                    pszDest++;
                }

                psz++;
            }

            if (pszDest > pszDestT)
            {
                *pszDest = '=';
                pszDest++;
                *pszDest = 0;
                pszDest++;
            }
            *pszDest = 0;

            if (fGroups)
            {
                dw =  GetPrivateProfileString(pszSection, pszValue, c_szEmpty, szGroupSection, countof(szGroupSection), pszFile);
                if (dw == 0)
                    StrCpy(szGroupSection, IK_NEWSGROUPLIST);

                WritePrivateProfileString(pszSection, pszValue, szGroupSection, pszFile);
                WritePrivateProfileSection(szGroupSection, pszGroups, pszFile);
            }

            LocalFree(pszGroups);
        }
    }

    if (!fGroups)
    {
        dw =  GetPrivateProfileString(pszSection, pszValue, c_szEmpty, szGroupSection, countof(szGroupSection), pszFile);
        if (dw > 0)
            WritePrivateProfileSection(szGroupSection, NULL, pszFile);

        WritePrivateProfileString(pszSection, pszValue, NULL, pszFile);
    }
}

/////////////////////////////////////////////////////////////////////////////
// PreConfigSettings
INT_PTR CALLBACK PreConfigSettings(HWND hDlg, UINT message, WPARAM, LPARAM lParam)
{
    BOOL    fDefMail,
#if defined(CONDITIONAL_JUNKMAIL)
            fJunkMail,
#endif
            fDefNews,
            fDeleteLinks;
    TCHAR   szServiceName[MAX_PATH],
            szServiceURL[INTERNET_MAX_URL_LENGTH];

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----
        // EnableDBCSChars(hDlg, IDE_NGROUPS);
        EnableDBCSChars(hDlg, IDE_SERVICENAME);
        EnableDBCSChars(hDlg, IDE_SERVICEURL);

        Edit_LimitText(GetDlgItem(hDlg, IDE_SERVICENAME),   countof(szServiceName)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SERVICEURL),    countof(szServiceURL)-1);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields -----
            fDefMail   = InsGetYesNo(IS_INTERNETMAIL, IK_DEFAULTCLIENT, FALSE, g_szCustIns);
            fDefNews   = InsGetYesNo(IS_INTERNETNEWS, IK_DEFAULTCLIENT, FALSE, g_szCustIns);
#if defined(CONDITIONAL_JUNKMAIL)
            fJunkMail  = InsGetYesNo(IS_INTERNETMAIL, IK_JUNKMAIL,      FALSE, g_szCustIns);
#endif
            fDeleteLinks = InsGetBool(IS_OUTLKEXP, IK_DELETELINKS, FALSE, g_szCustIns);

            GetPrivateProfileString(IS_OEGLOBAL,     IK_SERVICENAME, c_szEmpty, szServiceName, countof(szServiceName), g_szCustIns);
            GetPrivateProfileString(IS_OEGLOBAL,     IK_SERVICEURL, c_szEmpty, szServiceURL, countof(szServiceURL), g_szCustIns);

            StrRemoveWhitespace(szServiceName);
            StrRemoveWhitespace(szServiceURL);

#if defined(CONDITIONAL_JUNKMAIL)
            //----- Set up dialog controls -----
            CheckDlgButton(hDlg, IDC_JUNKMAIL,fJunkMail? BST_CHECKED : BST_UNCHECKED);
#endif
            CheckDlgButton(hDlg, IDC_DEFMAIL, fDefMail ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_DEFNEWS, fDefNews ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_DELETELINKS, fDeleteLinks ? BST_CHECKED : BST_UNCHECKED);

            InitializeNewsgroups(GetDlgItem(hDlg, IDE_NGROUPS), IS_INTERNETNEWS, IK_NEWSGROUPS, g_szCustIns);

            SetDlgItemText(hDlg, IDE_SERVICENAME,   szServiceName);
            SetDlgItemText(hDlg, IDE_SERVICEURL,    szServiceURL);

            CheckBatchAdvance(hDlg);            // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //----- Read data from controls into internal variables -----
            fDefMail = (IsDlgButtonChecked(hDlg, IDC_DEFMAIL)     == BST_CHECKED);
            fDefNews = (IsDlgButtonChecked(hDlg, IDC_DEFNEWS)     == BST_CHECKED);
#if defined(CONDITIONAL_JUNKMAIL)
            fJunkMail= (IsDlgButtonChecked(hDlg, IDC_JUNKMAIL)    == BST_CHECKED);
#endif
            fDeleteLinks = (IsDlgButtonChecked(hDlg, IDC_DELETELINKS) == BST_CHECKED);

            GetDlgItemText(hDlg, IDE_SERVICENAME, szServiceName, countof(szServiceName));
            GetDlgItemText(hDlg, IDE_SERVICEURL,  szServiceURL,  countof(szServiceURL));

            StrRemoveWhitespace(szServiceName);
            StrRemoveWhitespace(szServiceURL);

            //----- Validate the input -----
            if (ISNONNULL(szServiceName) || ISNONNULL(szServiceURL))
            {
                if (!CheckField(hDlg, IDE_SERVICENAME, FC_NONNULL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                if (!CheckField(hDlg, IDE_SERVICEURL, FC_URL | FC_NONNULL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }
            }

            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_INTERNETMAIL, IK_DEFAULTCLIENT, fDefMail ? c_szYes : c_szNo, g_szCustIns);
            WritePrivateProfileString(IS_INTERNETNEWS, IK_DEFAULTCLIENT, fDefNews ? c_szYes : c_szNo, g_szCustIns);
#if defined(CONDITIONAL_JUNKMAIL)
            WritePrivateProfileString(IS_INTERNETMAIL, IK_JUNKMAIL,      fJunkMail? c_sz1   : c_sz0,  g_szCustIns);
#endif
            InsWriteBool(IS_OUTLKEXP, IK_DELETELINKS, fDeleteLinks? c_sz1 : NULL, g_szCustIns);

            SaveNewsgroups(GetDlgItem(hDlg, IDE_NGROUPS), IS_INTERNETNEWS, IK_NEWSGROUPS, g_szCustIns);

            WritePrivateProfileString(IS_OEGLOBAL,     IK_SERVICENAME,  szServiceName, g_szCustIns);
            WritePrivateProfileString(IS_OEGLOBAL,     IK_SERVICEURL,   szServiceURL,  g_szCustIns);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_PRECONFIG;
            EnablePages();

            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// ViewSettings
INT_PTR CALLBACK ViewSettings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL    fFolderBar,
            fFolderList,
            fContacts,
            fTip,
            fStatus,
            fToolbar,
            fToolbarText,
            fOutlook,
            fPreview,
            fPreviewHdr,
            fPreviewSide;
    LPCTSTR  psz;

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----

        break;

    case WM_COMMAND:
        if (BN_CLICKED == HIWORD(wParam))
        {
            switch (LOWORD(wParam))
            {
            case IDC_TOOLBAR:
                fToolbar = IsDlgButtonChecked(hDlg, IDC_TOOLBAR);
                EnableDlgItem2(hDlg, IDC_TBARTEXT, fToolbar);
                break;

            case IDC_PREVIEW:
                fPreview = IsDlgButtonChecked(hDlg, IDC_PREVIEW);
                EnableDlgItem2(hDlg, IDC_SPLITVERT, fPreview);
                EnableDlgItem2(hDlg, IDC_SPLITHORZ, fPreview);
                EnableDlgItem2(hDlg, IDC_PREVIEWHDR, fPreview);
                break;
            }
            break;
        }
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields -----
            fFolderBar   = GetPrivateProfileInt(IS_OUTLKEXP, IK_FOLDERBAR,      TRUE,  g_szCustIns);
            fFolderList  = GetPrivateProfileInt(IS_OUTLKEXP, IK_FOLDERLIST,     TRUE,  g_szCustIns);
            fOutlook     = GetPrivateProfileInt(IS_OUTLKEXP, IK_OUTLOOKBAR,     FALSE, g_szCustIns);
            fStatus      = GetPrivateProfileInt(IS_OUTLKEXP, IK_STATUSBAR,      TRUE,  g_szCustIns);
            fContacts    = GetPrivateProfileInt(IS_OUTLKEXP, IK_CONTACTS,       TRUE,  g_szCustIns);
            fTip         = GetPrivateProfileInt(IS_OUTLKEXP, IK_TIPOFTHEDAY,    TRUE,  g_szCustIns);

            fToolbar = GetPrivateProfileInt(IS_OUTLKEXP, IK_TOOLBAR, TRUE,  g_szCustIns);
            if (fToolbar)
                fToolbarText = GetPrivateProfileInt(IS_OUTLKEXP, IK_TOOLBARTEXT, TRUE, g_szCustIns);
            else
                fToolbarText = TRUE;

            fPreview = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWPANE, TRUE, g_szCustIns);
            if (fPreview)
            {
                fPreviewHdr = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWHDR, TRUE, g_szCustIns);
                fPreviewSide = GetPrivateProfileInt(IS_OUTLKEXP, IK_PREVIEWSIDE, FALSE, g_szCustIns);
            }
            else
            {
                fPreviewHdr = TRUE;
                fPreviewSide = FALSE;
            }

            //----- Set up dialog controls -----
            CheckDlgButton(hDlg, IDC_FOLDERBAR,  fFolderBar  ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_FOLDERLIST, fFolderList ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_OUTLOOKBAR, fOutlook    ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_STATUSBAR,  fStatus     ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_CONTACTS,   fContacts   ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_TIPOFDAY,   fTip        ? BST_CHECKED : BST_UNCHECKED);

            CheckDlgButton(hDlg, IDC_TOOLBAR, fToolbar ? BST_CHECKED : BST_UNCHECKED);
            if (!fToolbar)
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_TOOLBAR, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_TOOLBAR));
            CheckDlgButton(hDlg, IDC_TBARTEXT, fToolbarText ? BST_CHECKED : BST_UNCHECKED);

            CheckDlgButton(hDlg, IDC_PREVIEW, fPreview ? BST_CHECKED : BST_UNCHECKED);
            if (!fPreview)
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_PREVIEW, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_PREVIEW));
            CheckDlgButton(hDlg, fPreviewSide ? IDC_SPLITVERT : IDC_SPLITHORZ, BST_CHECKED);
            CheckDlgButton(hDlg, IDC_PREVIEWHDR, fPreviewHdr ? BST_CHECKED : BST_UNCHECKED);

            CheckBatchAdvance(hDlg);            // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //----- Read data from controls into internal variables -----
            fFolderBar  = (IsDlgButtonChecked(hDlg, IDC_FOLDERBAR)  == BST_CHECKED);
            fFolderList = (IsDlgButtonChecked(hDlg, IDC_FOLDERLIST) == BST_CHECKED);
            fOutlook    = (IsDlgButtonChecked(hDlg, IDC_OUTLOOKBAR) == BST_CHECKED);
            fStatus     = (IsDlgButtonChecked(hDlg, IDC_STATUSBAR)  == BST_CHECKED);
            fContacts   = (IsDlgButtonChecked(hDlg, IDC_CONTACTS)   == BST_CHECKED);
            fTip        = (IsDlgButtonChecked(hDlg, IDC_TIPOFDAY)   == BST_CHECKED);

            fToolbar     = (IsDlgButtonChecked(hDlg, IDC_TOOLBAR)  == BST_CHECKED);
            fToolbarText = (IsDlgButtonChecked(hDlg, IDC_TBARTEXT) == BST_CHECKED);

            fPreview     = (IsDlgButtonChecked(hDlg, IDC_PREVIEW)    == BST_CHECKED);
            fPreviewSide = (IsDlgButtonChecked(hDlg, IDC_SPLITVERT)  == BST_CHECKED);
            fPreviewHdr  = (IsDlgButtonChecked(hDlg, IDC_PREVIEWHDR) == BST_CHECKED);

            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_OUTLKEXP, IK_FOLDERBAR,   fFolderBar  ? c_sz1 : c_sz0,  g_szCustIns);
            WritePrivateProfileString(IS_OUTLKEXP, IK_FOLDERLIST,  fFolderList ? c_sz1 : c_sz0,  g_szCustIns);
            WritePrivateProfileString(IS_OUTLKEXP, IK_OUTLOOKBAR,  fOutlook    ? c_sz1 : c_sz0,  g_szCustIns);
            WritePrivateProfileString(IS_OUTLKEXP, IK_STATUSBAR,   fStatus     ? c_sz1 : c_sz0,  g_szCustIns);
            WritePrivateProfileString(IS_OUTLKEXP, IK_CONTACTS,    fContacts   ? c_sz1 : c_sz0,  g_szCustIns);
            WritePrivateProfileString(IS_OUTLKEXP, IK_TIPOFTHEDAY, fTip        ? c_sz1 : c_sz0,  g_szCustIns);

            WritePrivateProfileString(IS_OUTLKEXP, IK_TOOLBAR, fToolbar ? c_sz1 : c_sz0,  g_szCustIns);
            if (fToolbar)
                psz = fToolbarText ? c_sz1 : c_sz0;
            else
                psz = NULL;
            WritePrivateProfileString(IS_OUTLKEXP, IK_TOOLBARTEXT, psz,  g_szCustIns);

            WritePrivateProfileString(IS_OUTLKEXP, IK_PREVIEWPANE, fPreview ? c_sz1 : c_sz0,  g_szCustIns);
            if (fPreview)
                psz = fPreviewHdr ? c_sz1 : c_sz0;
            else
                psz = NULL;
            WritePrivateProfileString(IS_OUTLKEXP, IK_PREVIEWHDR, psz,  g_szCustIns);
            if (fPreview)
                psz = fPreviewSide ? c_sz1 : c_sz0;
            else
                psz = NULL;
            WritePrivateProfileString(IS_OUTLKEXP, IK_PREVIEWSIDE, psz,  g_szCustIns);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_OEVIEW;
            EnablePages();

            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\custmsgr.cpp ===
#include "precomp.h"

#define MSGR_MAX_URL MAX_PATH
#define MSGR_MAX_BRAND 65
#define MSGR_MAX_SHORTBRAND 33

extern PROPSHEETPAGE g_psp[NUM_PAGES];
extern TCHAR g_szBuildRoot[MAX_PATH];
extern TCHAR g_szLanguage[];
extern TCHAR g_szCustIns[MAX_PATH];
extern TCHAR g_szTempSign[];
extern int   g_iCurPage;

TCHAR g_szMsgrIns[MAX_PATH] = TEXT("");
static TCHAR g_szMsgrPath[MAX_PATH] = TEXT("");

static const TCHAR c_szEmpty[] = TEXT("");

const TCHAR szHttpPrefix[] = TEXT("http://");

const TCHAR g_szMSNBrand[] = TEXT("MSN Messenger Service");
const TCHAR g_szHotmailDomain[] = TEXT("hotmail.com");
const TCHAR g_szPassportDomain[] = TEXT("passport.com");

BOOL RewriteMsgrInfWithBrand(LPTSTR lpszINF);

INT_PTR CALLBACK MessengerDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBrand[MSGR_MAX_SHORTBRAND];
    TCHAR szDownload[MSGR_MAX_URL];
    TCHAR szProvider[MSGR_MAX_SHORTBRAND];

    UNREFERENCED_PARAMETER(wParam);

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_MSGRBRAND);
        EnableDBCSChars(hDlg, IDE_MSGRDOWNLOAD);

        Edit_LimitText(GetDlgItem(hDlg, IDE_MSGRBRAND), MSGR_MAX_SHORTBRAND - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_MSGRBRAND2), MSGR_MAX_SHORTBRAND - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_MSGRDOWNLOAD),  countof(szDownload)-1);

        // Simulate click on first radio button to gray out appropriate controls
        SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_BRAND1, BN_CLICKED), NULL);
        CheckRadioButton(hDlg, IDC_BRAND1, IDC_BRAND2, IDC_BRAND1);

        if (TEXT('\0') == g_szMsgrIns[0])
        {
            // Set up MSGR path and IN_ file
            StrCpy(g_szMsgrPath, g_szCustIns);
            PathRemoveFileSpec(g_szMsgrPath);
            PathCreatePath(g_szMsgrPath);

            PathCombine(g_szMsgrIns, g_szMsgrPath, TEXT("MSMSGS.IN_"));
            
            // First 7 chars of customization key written to this IN_ later.
        }

        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields -----

            SHGetIniString(IS_MESSENGER, IK_PROVIDERNAME, szProvider, countof(szProvider), g_szMsgrIns);
            SHGetIniString(IS_MESSENGER, IK_SHORTNAME, szBrand, countof(szBrand), g_szMsgrIns);

            StrRemoveWhitespace(szBrand);
            StrRemoveWhitespace(szProvider);

            if (*szProvider)
            {
                // Use Option 1--set the provider name
                SetDlgItemText(hDlg, IDE_MSGRBRAND, szProvider);
            }
            else if (*szBrand)
            {
                // Use Option 2--set the brand name
                SetDlgItemText(hDlg, IDE_MSGRBRAND2, szBrand);

                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_BRAND2, BN_CLICKED), NULL);
                CheckRadioButton(hDlg, IDC_BRAND1, IDC_BRAND2, IDC_BRAND2);
            }

            GetPrivateProfileString(IS_MESSENGER, IK_DOWNLOAD, c_szEmpty, szDownload, countof(szDownload), g_szMsgrIns);

            StrRemoveWhitespace(szDownload);

            SetDlgItemText(hDlg, IDE_MSGRDOWNLOAD, szDownload);
            
            CheckBatchAdvance(hDlg);            // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            if (!CheckField(hDlg, IDE_MSGRDOWNLOAD, FC_URL))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                break;
            }

            //----- Read data from controls into internal variables -----

            // The brand name is written via SHSetIniString to UTF7 encode Unicode. This is the only
            // parameter for which Unicode characters can be used.

            if (IsDlgButtonChecked(hDlg, IDC_BRAND1))
            {
                TCHAR szProvider[MSGR_MAX_SHORTBRAND];
                // In this case, short name is just "MSN Messenger Service"
                SHSetIniString(IS_MESSENGER, IK_SHORTNAME, g_szMSNBrand, g_szMsgrIns);
            
                GetDlgItemText(hDlg, IDE_MSGRBRAND, szProvider, countof(szProvider));
                StrRemoveWhitespace(szProvider);
                SHSetIniString(IS_MESSENGER, IK_PROVIDERNAME, szProvider, g_szMsgrIns);
                SHSetIniString(IS_MESSENGER, IK_SHORTNAME, c_szEmpty, g_szMsgrIns);
            }
            else
            {
                GetDlgItemText(hDlg, IDE_MSGRBRAND2, szBrand, countof(szBrand));
                StrRemoveWhitespace(szBrand);
                SHSetIniString(IS_MESSENGER, IK_SHORTNAME, szBrand, g_szMsgrIns);
                SHSetIniString(IS_MESSENGER, IK_PROVIDERNAME, c_szEmpty, g_szMsgrIns);
            }
          
            GetDlgItemText(hDlg, IDE_MSGRDOWNLOAD, szDownload, countof(szDownload));

            StrRemoveWhitespace(szDownload);


            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_MESSENGER, IK_DOWNLOAD, szDownload, g_szMsgrIns);


            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_MESSENGER;
            EnablePages();

            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
           break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_BRAND1:
            DisableDlgItem(hDlg, IDE_MSGRBRAND2);
            DisableDlgItem(hDlg, IDC_NAME2_STATIC);
            DisableDlgItem(hDlg, IDC_BRAND2_STATIC);
            EnableDlgItem(hDlg, IDC_NAME1_STATIC);
            EnableDlgItem(hDlg, IDE_MSGRBRAND);
            EnableDlgItem(hDlg, IDC_BRAND1_STATIC);
            break;
        case IDC_BRAND2:
            DisableDlgItem(hDlg, IDC_NAME1_STATIC);
            DisableDlgItem(hDlg, IDE_MSGRBRAND);
            DisableDlgItem(hDlg, IDC_BRAND1_STATIC);
            EnableDlgItem(hDlg, IDE_MSGRBRAND2);
            EnableDlgItem(hDlg, IDC_NAME2_STATIC);
            EnableDlgItem(hDlg, IDC_BRAND2_STATIC);
            break;
        }

        break;

    default:
        return FALSE;
    }

    return TRUE;
        
}

INT_PTR CALLBACK MessengerLogoSoundDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szLogo[MAX_PATH];
    TCHAR szLogoLink[MSGR_MAX_URL];
    TCHAR szContactOnlineSound[MAX_PATH];
    TCHAR szNewEmailSound[MAX_PATH];
    TCHAR szNewMessageSound[MAX_PATH];
    TCHAR szXML[MSGR_MAX_URL];

    UNREFERENCED_PARAMETER(wParam);

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        EnableDBCSChars(hDlg, IDE_LOGO);
        EnableDBCSChars(hDlg, IDE_MSGRWEBLINK);
        EnableDBCSChars(hDlg, IDE_CONTACTONLINE);
        EnableDBCSChars(hDlg, IDE_NEWEMAIL);
        EnableDBCSChars(hDlg, IDE_NEWMESSAGE );
        EnableDBCSChars(hDlg, IDE_XMLURL );

        //----- Set up dialog controls -----
        Edit_LimitText(GetDlgItem(hDlg, IDE_LOGO), countof(szLogo)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_MSGRWEBLINK), countof(szLogoLink)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CONTACTONLINE),  countof(szContactOnlineSound)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_NEWEMAIL),  countof(szNewEmailSound)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_NEWMESSAGE),  countof(szNewMessageSound)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_XMLURL),  countof(szXML)-1);

        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields -----

            // BUGBUG: sounds path storage?

            GetPrivateProfileString(IS_MESSENGER, IK_PRODUCTLINK, c_szEmpty, szLogoLink, countof(szLogoLink), g_szMsgrIns);
            GetPrivateProfileString(IS_MESSENGER, IK_PARTNERLOGO, c_szEmpty, szLogo, countof(szLogo), g_szMsgrIns);
            GetPrivateProfileString(IS_MESSENGER, IK_CONTACTONLINE, c_szEmpty, szContactOnlineSound, countof(szContactOnlineSound), g_szMsgrIns);
            GetPrivateProfileString(IS_MESSENGER, IK_NEWEMAIL, c_szEmpty, szNewEmailSound, countof(szNewEmailSound), g_szMsgrIns);
            GetPrivateProfileString(IS_MESSENGER, IK_INCOMINGIM, c_szEmpty, szNewMessageSound, countof(szNewMessageSound), g_szMsgrIns);
            GetPrivateProfileString(IS_MESSENGER, IK_XMLLINK, c_szEmpty, szXML, countof(szXML), g_szMsgrIns);

            StrRemoveWhitespace(szLogoLink);
            StrRemoveWhitespace(szLogo);
            StrRemoveWhitespace(szContactOnlineSound);
            StrRemoveWhitespace(szNewEmailSound);
            StrRemoveWhitespace(szNewMessageSound);
            StrRemoveWhitespace(szXML);

            SetDlgItemText(hDlg, IDE_MSGRWEBLINK, szLogoLink);
            SetDlgItemText(hDlg, IDE_LOGO, szLogo);
            SetDlgItemText(hDlg, IDE_CONTACTONLINE, szContactOnlineSound);
            SetDlgItemText(hDlg, IDE_NEWEMAIL, szNewEmailSound);
            SetDlgItemText(hDlg, IDE_NEWMESSAGE, szNewMessageSound);
            SetDlgItemText(hDlg, IDE_XMLURL, szXML);

            CheckBatchAdvance(hDlg);            // standard line
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            if (!CheckField(hDlg, IDE_MSGRWEBLINK, FC_URL) ||
                !CheckField(hDlg, IDE_LOGO, FC_FILE | FC_EXISTS) ||
                !CheckField(hDlg, IDE_CONTACTONLINE, FC_FILE | FC_EXISTS) ||
                !CheckField(hDlg, IDE_NEWEMAIL, FC_FILE | FC_EXISTS) ||
                !CheckField(hDlg, IDE_NEWMESSAGE, FC_FILE | FC_EXISTS) ||
                !CheckField(hDlg, IDE_XMLURL, FC_URL))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                break;
            }

            //----- Read data from controls into internal variables -----

            GetDlgItemText(hDlg, IDE_LOGO, szLogo, countof(szLogo));
            GetDlgItemText(hDlg, IDE_MSGRWEBLINK, szLogoLink, countof(szLogoLink));
            GetDlgItemText(hDlg, IDE_CONTACTONLINE, szContactOnlineSound, countof(szContactOnlineSound));
            GetDlgItemText(hDlg, IDE_NEWEMAIL, szNewEmailSound, countof(szNewEmailSound));
            GetDlgItemText(hDlg, IDE_NEWMESSAGE, szNewMessageSound, countof(szNewMessageSound));
            GetDlgItemText(hDlg, IDE_XMLURL, szXML, countof(szXML));

            StrRemoveWhitespace(szLogo);
            StrRemoveWhitespace(szLogoLink);
            StrRemoveWhitespace(szContactOnlineSound);
            StrRemoveWhitespace(szNewEmailSound);
            StrRemoveWhitespace(szNewMessageSound);
            StrRemoveWhitespace(szXML);

            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_MESSENGER, IK_PRODUCTLINK, szLogoLink, g_szMsgrIns);
            WritePrivateProfileString(IS_MESSENGER, IK_PARTNERLOGO, szLogo, g_szMsgrIns);
            WritePrivateProfileString(IS_MESSENGER, IK_CONTACTONLINE, szContactOnlineSound, g_szMsgrIns);
            WritePrivateProfileString(IS_MESSENGER, IK_NEWEMAIL, szNewEmailSound, g_szMsgrIns);
            WritePrivateProfileString(IS_MESSENGER, IK_INCOMINGIM, szNewMessageSound, g_szMsgrIns);
            WritePrivateProfileString(IS_MESSENGER, IK_XMLLINK, szXML, g_szMsgrIns);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_LOGOSOUND;
            EnablePages();

            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
           break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_BROWSELOGO:
            GetDlgItemText(hDlg, IDE_LOGO, szLogo, countof(szLogo));
            if (BrowseForFile(hDlg, szLogo, countof(szLogo), GFN_GIF))
                SetDlgItemText(hDlg, IDE_LOGO, szLogo);
            break;
        case IDC_BROWSEONLINE:
            GetDlgItemText(hDlg, IDE_CONTACTONLINE, szContactOnlineSound, countof(szContactOnlineSound));
            if (BrowseForFile(hDlg, szContactOnlineSound, countof(szContactOnlineSound), GFN_WAV))
                SetDlgItemText(hDlg, IDE_CONTACTONLINE, szContactOnlineSound);
            break;
        case IDC_BROWSENEWEMAIL:
            GetDlgItemText(hDlg, IDE_NEWEMAIL, szNewEmailSound, countof(szNewEmailSound));
            if (BrowseForFile(hDlg, szNewEmailSound, countof(szNewEmailSound), GFN_WAV))
                SetDlgItemText(hDlg, IDE_NEWEMAIL, szNewEmailSound);
            break;
        case IDC_BROWSENEWMESSAGE:
            GetDlgItemText(hDlg, IDE_NEWMESSAGE, szNewMessageSound, countof(szNewMessageSound));
            if (BrowseForFile(hDlg, szNewMessageSound, countof(szNewMessageSound), GFN_WAV))
                SetDlgItemText(hDlg, IDE_NEWMESSAGE, szNewMessageSound);
            break;

        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
        
}

INT_PTR CALLBACK MessengerAccountsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szSignup[MSGR_MAX_URL];
    TCHAR szMailServer[MAX_PATH];
    TCHAR szDefaultDomain[MAX_PATH];

    UNREFERENCED_PARAMETER(wParam);

    switch (message)
    {
    case WM_INITDIALOG:
        //----- Set up the global goo -----
        g_hWizard  = hDlg;

        //----- Set up dialog controls -----
        EnableDBCSChars(hDlg, IDE_SIGNUP);
        EnableDBCSChars(hDlg, IDE_POPSERVER);
        EnableDBCSChars(hDlg, IDE_MAILURL);

        Edit_LimitText(GetDlgItem(hDlg, IDE_SIGNUP), countof(szSignup)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_POPSERVER),  countof(szMailServer)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_DOMAINCOMBO),  countof(szDefaultDomain)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_MAILURL),  countof(szMailServer)-1);

        SendDlgItemMessage(hDlg, IDC_DOMAINCOMBO, CB_ADDSTRING, 0, (LPARAM) g_szHotmailDomain);
        SendDlgItemMessage(hDlg, IDC_DOMAINCOMBO, CB_ADDSTRING, 0, (LPARAM) g_szPassportDomain);
        SendDlgItemMessage(hDlg, IDC_DOMAINCOMBO, CB_SETCURSEL, 0, 0);

        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
        {
            //----- Standard prolog -----
            // Note. Another case of the global goo.
            SetBannerText(hDlg);

            //----- Initialization of fields -----
            GetPrivateProfileString(IS_MESSENGER, IK_PPSIGNUP, c_szEmpty, szSignup, countof(szSignup), g_szMsgrIns);
            GetPrivateProfileString(IS_MESSENGER, IK_PPDOMAIN, c_szEmpty, szDefaultDomain, countof(szDefaultDomain), g_szMsgrIns);

            StrRemoveWhitespace(szSignup);
            StrRemoveWhitespace(szDefaultDomain);

            SetDlgItemText(hDlg, IDE_SIGNUP, szSignup);

            TCHAR szMailFunction[2];
            GetPrivateProfileString(IS_MESSENGER, IK_MAILFUNCTION, c_szEmpty, szMailFunction, countof(szMailFunction), g_szMsgrIns);

            if (TEXT('1') == *szMailFunction) // 1 == POP mail
            {
                GetPrivateProfileString(IS_MESSENGER, IK_MAILSERVER, c_szEmpty, szMailServer, countof(szMailServer), g_szMsgrIns);
                StrRemoveWhitespace(szMailServer);
                SetDlgItemText(hDlg, IDE_POPSERVER, szMailServer);

                TCHAR szSPA[2];
                GetPrivateProfileString(IS_MESSENGER, IK_MAILSPA, c_szEmpty, szSPA, countof(szSPA), g_szMsgrIns);
                if (TEXT('1') == *szSPA)
                {
                    CheckDlgButton(hDlg, IDC_MSGRSPA, BST_CHECKED);
                }
                else
                {
                    CheckDlgButton(hDlg, IDC_MSGRSPA, BST_UNCHECKED);
                }

                // Simulate click on radio button to gray out appropriate controls
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_RADIO_MAILSERVER, BN_CLICKED), NULL);
                CheckRadioButton(hDlg, IDC_RADIO_HOTMAIL, IDC_RADIO_MAILSERVER, IDC_RADIO_MAILSERVER);
            }
            else if (TEXT('2') == *szMailFunction) // 2 = URL mail
            {
                GetPrivateProfileString(IS_MESSENGER, IK_MAILURL, c_szEmpty, szMailServer, countof(szMailServer), g_szMsgrIns);
                StrRemoveWhitespace(szMailServer);
                SetDlgItemText(hDlg, IDE_MAILURL, szMailServer);

                // Simulate click on radio button to gray out appropriate controls
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_RADIO_URL, BN_CLICKED), NULL);
                CheckRadioButton(hDlg, IDC_RADIO_HOTMAIL, IDC_RADIO_MAILSERVER, IDC_RADIO_URL);
            }
            else
            {
                // Simulate click on first radio button to gray out appropriate controls
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_RADIO_HOTMAIL, BN_CLICKED), NULL);
                CheckRadioButton(hDlg, IDC_RADIO_HOTMAIL, IDC_RADIO_MAILSERVER, IDC_RADIO_HOTMAIL);
            }

            if (*szDefaultDomain)
            {
                SetDlgItemText(hDlg, IDC_DOMAINCOMBO, szDefaultDomain);
            }

            CheckBatchAdvance(hDlg);            // standard line
            break;
        }
        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            if (!CheckField(hDlg, IDE_SIGNUP, FC_URL) ||
                !CheckField(hDlg, IDC_DOMAINCOMBO, FC_NOSPACE))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                break;
            }

            //----- Read data from controls into internal variables -----

            if (IsDlgButtonChecked(hDlg, IDC_RADIO_URL))
            {
                if (!CheckField(hDlg, IDE_MAILURL, FC_URL | FC_NONNULL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                GetDlgItemText(hDlg, IDE_MAILURL, szMailServer, countof(szMailServer));
                StrRemoveWhitespace(szMailServer);
                WritePrivateProfileString(IS_MESSENGER, IK_MAILURL, szMailServer, g_szMsgrIns);
                WritePrivateProfileString(IS_MESSENGER, IK_MAILSERVER, c_szEmpty, g_szMsgrIns);
                // 2 signifies URL Mail integration
                WritePrivateProfileString(IS_MESSENGER, IK_MAILFUNCTION, TEXT("2"), g_szMsgrIns);
                WritePrivateProfileString(IS_MESSENGER, IK_MAILSPA, TEXT("0"), g_szMsgrIns);
            }
            else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MAILSERVER))
            {
                if (!CheckField(hDlg, IDE_POPSERVER, FC_NOSPACE))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                GetDlgItemText(hDlg, IDE_POPSERVER, szMailServer, countof(szMailServer));
                StrRemoveWhitespace(szMailServer);
                WritePrivateProfileString(IS_MESSENGER, IK_MAILSERVER, szMailServer, g_szMsgrIns);
                WritePrivateProfileString(IS_MESSENGER, IK_MAILURL, c_szEmpty, g_szMsgrIns);
                // 1 signifies POP Mail integration
                WritePrivateProfileString(IS_MESSENGER, IK_MAILFUNCTION, TEXT("1"), g_szMsgrIns);

                WritePrivateProfileString(  IS_MESSENGER, 
                                            IK_MAILSPA, 
                                            IsDlgButtonChecked(hDlg, IDC_MSGRSPA) ? TEXT("1") : TEXT("0"),
                                            g_szMsgrIns);
            }
            else
            {
                WritePrivateProfileString(IS_MESSENGER, IK_MAILSERVER, c_szEmpty, g_szMsgrIns);
                WritePrivateProfileString(IS_MESSENGER, IK_MAILURL, c_szEmpty, g_szMsgrIns);
                // 0 signifies Hotmail Mail integration
                WritePrivateProfileString(IS_MESSENGER, IK_MAILFUNCTION, TEXT("0"), g_szMsgrIns);
                WritePrivateProfileString(IS_MESSENGER, IK_MAILSPA, TEXT("0"), g_szMsgrIns);
            }

            GetDlgItemText(hDlg, IDE_SIGNUP, szSignup, countof(szSignup));
            GetDlgItemText(hDlg, IDC_DOMAINCOMBO, szDefaultDomain, countof(szDefaultDomain));

            StrRemoveWhitespace(szSignup);
            StrRemoveWhitespace(szDefaultDomain);

            //----- Serialize data to the *.ins file -----
            WritePrivateProfileString(IS_MESSENGER, IK_PPSIGNUP, szSignup, g_szMsgrIns);
            WritePrivateProfileString(IS_MESSENGER, IK_PPDOMAIN, szDefaultDomain, g_szMsgrIns);
            WritePrivateProfileString(IS_MESSENGER, IK_PPSUFFIX, szDefaultDomain, g_szMsgrIns);

            //----- Standard epilog -----
            // Note. Last and classical at that example of the global goo.
            g_iCurPage = PPAGE_MSGRACCOUNTS;
            EnablePages();

            if (((LPNMHDR)lParam)->code == PSN_WIZNEXT)
                PageNext(hDlg);
            else if (((LPNMHDR)lParam)->code == PSN_WIZBACK)
                PagePrev(hDlg);
           break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            return !QueryCancel(hDlg);

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_RADIO_HOTMAIL:
            DisableDlgItem(hDlg, IDC_MAILURL_STATIC);
            DisableDlgItem(hDlg, IDE_MAILURL);
            DisableDlgItem(hDlg, IDE_POPSERVER);
            DisableDlgItem(hDlg, IDC_MAILSERVER_STATIC);
            DisableDlgItem(hDlg, IDC_MSGRSPA);
            break;
        case IDC_RADIO_MAILSERVER:
            DisableDlgItem(hDlg, IDC_MAILURL_STATIC);
            DisableDlgItem(hDlg, IDE_MAILURL);
            EnableDlgItem(hDlg, IDE_POPSERVER);
            EnableDlgItem(hDlg, IDC_MAILSERVER_STATIC);
            EnableDlgItem(hDlg, IDC_MSGRSPA);
            break;
        case IDC_RADIO_URL:
            EnableDlgItem(hDlg, IDC_MAILURL_STATIC);
            EnableDlgItem(hDlg, IDE_MAILURL);
            DisableDlgItem(hDlg, IDE_POPSERVER);
            DisableDlgItem(hDlg, IDC_MAILSERVER_STATIC);
            DisableDlgItem(hDlg, IDC_MSGRSPA);
            break;
        }

        break;

    default:
        return FALSE;
    }

    return TRUE;
        
}

const CHAR g_szEmbeddedStrings[] = "[Strings.Embedded]";

BOOL RewriteMsgrInfWithBrand(LPTSTR lpszINF)
{
    BOOL bRet = FALSE;

    TCHAR szBrand[MSGR_MAX_SHORTBRAND];
    GetPrivateProfileString(IS_MESSENGER, IK_SHORTNAME, c_szEmpty, szBrand, countof(szBrand), g_szMsgrIns);

    CHAR szaBrand[MSGR_MAX_SHORTBRAND];
    T2Abux(szBrand, szaBrand);

    // Replace the brand in the INF, as specified by the PGMITEM_MSMSGS field
    TCHAR szOldBrand[MSGR_MAX_SHORTBRAND];
    GetPrivateProfileString(TEXT("Strings"), TEXT("PGMITEM_MSMSGS"), c_szEmpty, szOldBrand, countof(szOldBrand), lpszINF);
    
    // because we're mixing ini string functions with binary file operations
    WritePrivateProfileString(NULL, NULL, NULL, lpszINF);

    CHAR szaOldBrand[MSGR_MAX_SHORTBRAND];
    T2Abux(szOldBrand, szaOldBrand);

    ASSERT(*szaOldBrand && *szaBrand && "Both of these parameters should be valid when RewriteMsgrInfWithBrand is called");

    if (*szaOldBrand && *szaBrand)
    {
        CHAR szaINFBrand[MSGR_MAX_SHORTBRAND*4];
        StrCpyA(szaINFBrand, szaBrand);
        HANDLE hFile = ::CreateFile(lpszINF, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            DWORD dwSize = ::GetFileSize(hFile, NULL);
            if (dwSize)
            {
                LPSTR lpszData = new CHAR[dwSize + 1];
                if (lpszData)
                {
                    ULONG nRead;
                    if (ReadFile(hFile, lpszData, dwSize, &nRead, NULL))
                    {
                        // Null terminate the data
                        lpszData[nRead] = '\0';

                        // Reset the file pointer so we can write the branded INF data
                        // over the old data.
                        SetFilePointer(hFile, 0, 0, FILE_BEGIN);

                        LPSTR pszEmbeddedStrings = StrStrA(lpszData, g_szEmbeddedStrings);

                        // Write data up until an occurrence of the old brand name, replace the old brand name with the new
                        // brand name, and loop.

                        LPSTR lpszDataStart = lpszData, lpszDataEnd;
                        DWORD dwBytesWritten;
                        BOOL fPassedEmbedded = FALSE;
                        while (NULL != (lpszDataEnd = StrStrA(lpszDataStart, szaOldBrand)))
                        {
                            // If we pass the [Strings.Embedded] section header,
                            // that means all occurrences of the brand from here on are 
                            // embedded, so we need to quadruple the quotes.
                            if (!fPassedEmbedded && pszEmbeddedStrings &&
                                lpszDataEnd > pszEmbeddedStrings)
                            {
                                LPSTR pszTemp = szaINFBrand, pszSrc = szaBrand;

                                fPassedEmbedded = TRUE;
                                // Need to write FOUR of either kind of quote to make it show up correctly in the INF
                                // in the embedded strings
                                while (*pszSrc)
                                {
                                    if ('\'' == *pszSrc || '\"' == *pszSrc)
                                    {
                                        *pszTemp++ = *pszSrc;            
                                        *pszTemp++ = *pszSrc;            
                                        *pszTemp++ = *pszSrc;            
                                    }
                                    *pszTemp++ = *pszSrc++;
                                }
                                *pszTemp = '\0';
                            }

                            WriteFile(hFile, lpszDataStart, (DWORD)(lpszDataEnd - lpszDataStart), &dwBytesWritten, NULL);
                            WriteFile(hFile, szaINFBrand, lstrlenA(szaINFBrand), &dwBytesWritten, NULL);
                            lpszDataStart = lpszDataEnd + lstrlenA(szaOldBrand);
                        }
    
                        // Write the rest of the data after the last occurrence of the old brand name.

                        WriteFile(hFile, lpszDataStart, dwSize - (DWORD)(lpszDataStart - lpszData), &dwBytesWritten, NULL);
                        bRet = SetEndOfFile(hFile);
                    }
                }
            }

            // because we're mixing ini string functions with binary file operations
            FlushFileBuffers(hFile);
            CloseHandle(hFile);
        }
    }
    return bRet;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\ie4desk.cpp ===
#include "precomp.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szBuildTemp[];
extern TCHAR g_szTempSign[];
extern TCHAR g_szWizRoot[];
extern TCHAR g_szDestCif[];
extern TCHAR g_szDefInf[];
extern TCHAR g_szCustInf[];
extern TCHAR g_szAllModes[];
extern TCHAR g_szLanguage[];

extern BOOL g_fIntranet;
extern BOOL g_fServerICW, g_fServerKiosk, g_fServerless;

extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

extern void SetCompSize(LPTSTR szCab, LPTSTR szSect, DWORD dwInstallSize);
extern void WriteModesToCif(CCifRWComponent_t * pCifRWComponent_t, LPCTSTR pcszModes);

// global variables
TCHAR g_szJobVersion[32];
TCHAR g_szDeskTemp[MAX_PATH] = TEXT("");
TCHAR g_szUnsignedFiles[MAX_BUF] = TEXT("");

// static variables
static DWORD s_dwDDF = 0;
static TCHAR s_szInfAdd1[] = TEXT("\r\n[ProgramFilesDir]\r\nHKLM,Software\\Microsoft\\Windows\\CurrentVersion,ProgramFilesDir,,%24%\r\n");
static TCHAR s_szInfAdd2[] = TEXT("\r\n[IeFilesDir]\r\nHKLM,\"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE\"")
                    TEXT(",\"Path\",,\"%24%\\Program Files\\%IEDIR%\"\r\n");
static TCHAR s_szDDFTpl[] = TEXT(".Set SourceDir=%s\r\nsetup.inf /INF=NO\r\ninstall.inf /INF=NO");

void CreatePostCmdSection(LPCTSTR szDestDir, LPCTSTR szInf)
{
    TCHAR   szLDID[MAX_PATH],
            szDir[MAX_PATH],
            szBuildDir[MAX_PATH];
    LPTSTR  pPtr,
            pPostCmdSect;
    int     nSizeSectBuffer = 0;

    if (szDestDir == NULL || *szDestDir == TEXT('\0') || szInf == NULL || *szInf == TEXT('\0'))
        return;

    *szLDID = TEXT('\0');
    *szDir  = TEXT('\0');
    pPtr = StrChr(szDestDir, TEXT(','));
    if (pPtr != NULL)
    {
        StrCpyN(szLDID, szDestDir, (int) ((pPtr - szDestDir) + 1));
        StrCpy(szDir, pPtr + 1);
    }

    if (*szLDID == TEXT('\0') || *szDir == TEXT('\0'))
        return;

    wnsprintf(szBuildDir, countof(szBuildDir), TEXT("%%%s%%\\%s"), szLDID, szDir);
    nSizeSectBuffer = MAX_PATH * 5;
    pPostCmdSect = (LPTSTR)LocalAlloc(LPTR, nSizeSectBuffer * sizeof(TCHAR));
    if (pPostCmdSect)
    {
        TCHAR szFile[MAX_PATH],
              szSectLine[MAX_PATH];
        int   nCopyIndex = 0;
        WIN32_FIND_DATA findFileData;

        // add .adm inf line (if any) to the section string
        PathCombine(szFile, g_szTempSign, TEXT("*.inf"));

        HANDLE hFind = FindFirstFile(szFile, &findFileData);
        if(hFind != INVALID_HANDLE_VALUE)
        {
            TCHAR  szADMFile[MAX_PATH],
                   szADMPath[MAX_PATH];
            LPTSTR pTemp;

            PathCombine(szADMPath, g_szWizRoot, TEXT("Policies"));
            PathAppend(szADMPath, g_szLanguage);

            do
            {
                StrCpy(szFile, findFileData.cFileName);
                PathRenameExtension(szFile, TEXT(".adm"));
                PathCombine(szADMFile, szADMPath, szFile);
                if (PathFileExists(szADMFile))
                {
                    wnsprintf(szSectLine, countof(szSectLine), TEXT("rundll32.exe advpack.dll,LaunchINFSection %s\\%s,DefaultInstall.HKLM, 1"), szBuildDir, findFileData.cFileName);
                    if (nCopyIndex + StrLen(szSectLine) + 1 > (nSizeSectBuffer - 1))
                    {
                        nSizeSectBuffer += MAX_PATH;
                        pTemp = (LPTSTR)LocalReAlloc(pPostCmdSect, nSizeSectBuffer, LMEM_ZEROINIT);
                        if (pTemp != NULL)
                            pPostCmdSect = pTemp;
                        else
                            break;
                    }

                    StrCpy(pPostCmdSect + nCopyIndex, szSectLine);
                    nCopyIndex += StrLen(szSectLine);
                    nCopyIndex++; // section lines must be spaced with a NULL character
                }
            }while(FindNextFile(hFind, &findFileData));
            FindClose(hFind);
        }
    }
    if (pPostCmdSect != NULL)
    {
        if (*pPostCmdSect != TEXT('\0'))
        {
            WritePrivateProfileSection(TEXT("PostCmdSect"), pPostCmdSect, szInf);
            WritePrivateProfileString(NULL, NULL, NULL, szInf);
        }
        LocalFree(pPostCmdSect);
    }
}

HRESULT CabUpFolder(HWND hWnd, LPTSTR szFolderPath, LPTSTR szDestDir, LPTSTR szCabname,
                    LPTSTR szDisplayName, LPTSTR szGuid, LPTSTR szAddReg)
{
    WIN32_FIND_DATA fd;
    HANDLE hFind;
    TCHAR szFrom[MAX_PATH];
    TCHAR szCabPath[MAX_PATH];
    TCHAR szDDF[MAX_PATH];
    TCHAR szDiamondParams[MAX_PATH];
    TCHAR szInf[MAX_PATH];
    TCHAR szSetInf[MAX_PATH];
    TCHAR szTempDir[MAX_PATH];
    TCHAR szIEDir[MAX_PATH];
    TCHAR szMakeCabLoc[MAX_PATH];
    TCHAR szDefaultInstallSect[64];
    DWORD dwsHi, nWritten;
    HANDLE hDDF, hInf, hRegInf, hMakeCab;
    SHELLEXECUTEINFO shInfo;
    TCHAR szDDFAdd[3 * MAX_PATH];
    DWORD dwInstallSize;
    TCHAR szSourceDisk[80];

    PathCombine(szFrom, szFolderPath, TEXT("*.*"));
    PathCombine(szCabPath, g_szBuildTemp, szCabname);
    PathCombine(szDDF, g_szBuildTemp, TEXT("Folder.ddf"));
    wnsprintf(szDiamondParams, countof(szDiamondParams), TEXT("/D CabinetName1=..\\%s /D SourceDir=\"%s\" /F %s"),
            szCabname, szFolderPath, szDDF);
    StrCpy(szInf, szCabPath);
    PathRemoveFileSpec(szInf);
    PathAppend(szInf, TEXT("install.inf"));
    if (ISNULL(szGuid))
    {
        GUID guid;
        if (CoCreateGuid(&guid) == NOERROR)
            CoStringFromGUID(guid, szGuid, 64);
    }
    DeleteFile(szInf);
    WritePrivateProfileString(VERSION, TEXT("Signature"), TEXT("$Chicago$"), szInf);
    WritePrivateProfileString(VERSION, TEXT("AdvancedInf"), TEXT("2.5"), szInf);
    WritePrivateProfileString(VERSION, TEXT("LayoutFile"), TEXT("Setup.inf"), szInf);
    WritePrivateProfileString( TEXT("CustInstDestSection"), TEXT("49000,49001,49002,49003"),
        TEXT("ProgramFilesDir,5"), szInf );
    WritePrivateProfileString( TEXT("CustInstDestSection"), TEXT("49100,49101,49102,49103"),
        TEXT("IEFilesDir,5"), szInf );
    LoadString( g_rvInfo.hInst, IDS_IE, szIEDir, MAX_PATH );
    WritePrivateProfileString( IS_STRINGS, TEXT("IEDIR"), szIEDir, szInf);
    
    StrCpy(szDefaultInstallSect, DEFAULT_INSTALL);

    WritePrivateProfileString(szDefaultInstallSect,  TEXT("CopyFiles"), TEXT("CopyFileSect"), szInf);
    WritePrivateProfileString(szDefaultInstallSect,  TEXT("CustomDestination"),
        TEXT("CustInstDestSection"), szInf);
    WritePrivateProfileString(szDefaultInstallSect, REQUIRED_ENGINE, SETUPAPI_FATAL, szInf);
    WritePrivateProfileString(TEXT("DestinationDirs"), TEXT("CopyFileSect"), szDestDir, szInf);
    WritePrivateProfileString(NULL, NULL, NULL, szInf);
    hInf = CreateFile(szInf, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
         FILE_ATTRIBUTE_NORMAL, NULL);
    SetFilePointer(hInf, 0, NULL, FILE_END);
    WriteStringToFile( hInf, s_szInfAdd1, StrLen(s_szInfAdd1));
    WriteStringToFile( hInf, s_szInfAdd2, StrLen(s_szInfAdd2) );
    WriteStringToFile( hInf, TEXT("\r\n[CopyFileSect]\r\n"), 18);

    hDDF = CreateFile(szDDF, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
         FILE_ATTRIBUTE_NORMAL, NULL);

    if (hDDF == INVALID_HANDLE_VALUE)
    {
        CloseHandle(hInf);
        return E_FAIL;
    }
    if (s_dwDDF == 0) s_dwDDF = GetFileSize( hDDF, &dwsHi );
    SetFilePointer(hDDF, s_dwDDF, NULL, FILE_BEGIN);
    SetEndOfFile( hDDF );
    if ((hFind = FindFirstFile( szFrom, &fd)) != INVALID_HANDLE_VALUE)
        while (1)
        {
            LPTSTR pFn = fd.cFileName;
            if ((ISNONNULL(pFn)) && StrCmp(pFn, TEXT(".")) && StrCmp(pFn, TEXT(".."))
                && ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
            {
                WriteStringToFile( hDDF, TEXT("\""), 1);
                WriteStringToFile( hDDF, pFn, StrLen(pFn) );
                WriteStringToFile( hDDF, TEXT("\"\r\n"), 3 );
                WriteStringToFile( hInf, TEXT("\""), 1 );
                WriteStringToFile( hInf, pFn, StrLen(pFn) );
                WriteStringToFile( hInf, TEXT("\"\r\n"), 3 );
            }
            if (!FindNextFile( hFind, &fd ))
                if (GetLastError() == ERROR_NO_MORE_FILES)
                {
                    FindClose( hFind );
                    break;
                }
        }

    if (szAddReg)
    {
        if (ISNONNULL(szAddReg))
        {
            TCHAR szRegInf[MAX_PATH];
            CHAR szRegInfBuf[2048];
            TCHAR szQuotedVer[80];
            TCHAR szClearStubCmd[MAX_PATH];
            DWORD nRead;
            PathCombine(szRegInf, g_szBuildTemp, TEXT("ADDREG.INF"));
            ZeroMemory(szRegInfBuf, sizeof(szRegInfBuf));
            hRegInf = CreateFile(szRegInf, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);
            ReadFile( hRegInf, szRegInfBuf, sizeof(szRegInfBuf), &nRead, NULL );
            WriteFile( hInf, szRegInfBuf, nRead, &nWritten, NULL );
            CloseHandle(hInf);
            CloseHandle(hRegInf);
            if ((szGuid[0] == TEXT('>')) || (szGuid[0] == TEXT('<')))
            {
                WritePrivateProfileString(szDefaultInstallSect, TEXT("DelReg"),
                    TEXT("DelRegSect"), szInf);
                WritePrivateProfileString( IS_STRINGS, TEXT("OLDGUID"), &szGuid[1], szInf);
            }
            else
                WritePrivateProfileString(TEXT("DelRegSect"), NULL, NULL, szInf);
            wnsprintf(szQuotedVer, countof(szQuotedVer), TEXT("\"%s\""), g_szJobVersion);
            wnsprintf(szClearStubCmd, countof(szClearStubCmd), TEXT("\"RUNDLL32 IEDKCS32.DLL,BrandCleanInstallStubs %s\""), szGuid);
            WritePrivateProfileString( IS_STRINGS, TEXT("Description"), szDisplayName, szInf);
            WritePrivateProfileString( IS_STRINGS, TEXT("StubPath"), szAddReg, szInf);
            WritePrivateProfileString( IS_STRINGS, TEXT("Revision"), szQuotedVer, szInf);
            WritePrivateProfileString( IS_STRINGS, TEXT("GUID"), szGuid, szInf);
            WritePrivateProfileString( IS_STRINGS, TEXT("ClearStubsCmd"), szClearStubCmd, szInf);
            WritePrivateProfileString( szDefaultInstallSect, TEXT("AddReg"), TEXT("AddRegSect"), szInf);

            // create a postcmdsect to dump the HKLM data of the rating.inf and the
            // .adm inf's.
            WritePrivateProfileString(szDefaultInstallSect, TEXT("RunPostSetupCommands"), TEXT("PostCmdSect"), szInf);
            CreatePostCmdSection(szDestDir, szInf);
        }
        else CloseHandle(hInf);
    }
    else CloseHandle(hInf);

    wnsprintf(szDDFAdd, countof(szDDFAdd), s_szDDFTpl, g_szBuildTemp);
    WriteStringToFile( hDDF, szDDFAdd, StrLen(szDDFAdd));
    CloseHandle(hDDF);

    WritePrivateProfileString(NULL, NULL, NULL, szInf);

    wnsprintf(szSourceDisk, countof(szSourceDisk), TEXT("\"Custom Folder\",%s,0"), szCabname);
    PathCombine(szSetInf, g_szBuildTemp, TEXT("SETUP.INF") );
    DeleteFile(szSetInf);
    WritePrivateProfileString( TEXT("SourceDisksNames"), TEXT("1"), szSourceDisk, szSetInf );
    WritePrivateProfileString(NULL, NULL, NULL, szSetInf);

    dwInstallSize = FolderSize(szFolderPath) >> 10;
    memset(&shInfo, 0, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.hwnd = hWnd;
    shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    shInfo.lpVerb = TEXT("open");
    
    // If MAKECAB.EXE is in the current directory, use the full path.
    // otherwise when we build in the scratch dir we won't find it.
    PathCombine(szMakeCabLoc, g_szBuildTemp, TEXT("MAKECAB.EXE"));
    hMakeCab = CreateFile(szMakeCabLoc, GENERIC_READ, 0, NULL, OPEN_EXISTING,
         FILE_ATTRIBUTE_NORMAL, NULL);
    if(hMakeCab == INVALID_HANDLE_VALUE)
        shInfo.lpFile = TEXT("MAKECAB.EXE");
    else 
    {
        CloseHandle(hMakeCab);
        shInfo.lpFile = szMakeCabLoc;
    }
    shInfo.lpParameters = szDiamondParams;
    PathCombine(szTempDir, g_szBuildTemp, TEXT("SCRATCH") );  // SETUP.INF is destroyed by ShellExecAndWait!! Use scratch dir
    CreateDirectory(szTempDir, NULL);
    shInfo.lpDirectory = szTempDir;
    shInfo.nShow = SW_MINIMIZE;
    SetCurrentDirectory(szTempDir);
    ShellExecAndWait(shInfo);
    SetCurrentDirectory(g_szBuildTemp);

    {
        ICifRWComponent * pCifRWComponent;
        CCifRWComponent_t * pCifRWComponent_t;
        ICifComponent * pCifBaseComp;

        g_lpCifRWFileDest->DeleteComponent(szCabname);
        g_lpCifRWFileDest->CreateComponent(szCabname, &pCifRWComponent);
        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
        pCifRWComponent_t->SetGUID(szGuid);
        pCifRWComponent_t->SetDescription(szDisplayName);
        pCifRWComponent_t->SetUrl(0, szCabname, 3);
        pCifRWComponent_t->SetVersion(g_szJobVersion);
        pCifRWComponent_t->SetCommand(0, TEXT("INSTALL.INF"), TEXT(""), 0);
        pCifRWComponent_t->SetReboot(TRUE);
        WriteModesToCif(pCifRWComponent_t, g_szAllModes);
        pCifRWComponent_t->SetGroup(TEXT("BASEIE4"));
        pCifRWComponent_t->SetPriority(835);
        pCifRWComponent_t->SetUIVisible(FALSE);

        if (SUCCEEDED(g_lpCifRWFileDest->FindComponent(TEXT("BASEIE40_Win"), &pCifBaseComp)))
        {
            // passing in the slash because we can't change inseng interface signature
            // this translates to writing a line of BASEIE40:N:5.0.0.0"
            pCifRWComponent_t->AddDependency(TEXT("BASEIE40_Win"), TEXT('\\'));
            delete pCifRWComponent_t;
            g_lpCifRWFileDest->CreateComponent(TEXT("BASEIE40_Win"), &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->AddToTreatAsOne(szCabname);
            delete pCifRWComponent_t;
            g_lpCifRWFileDest->CreateComponent(TEXT("BASEIE40_NTx86"), &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->AddToTreatAsOne(szCabname);
            delete pCifRWComponent_t;
        }
        else
        {
            // passing in the slash because we can't change inseng interface signature
            // this translates to writing a line of BASEIE40:N:5.0.0.0"
            pCifRWComponent_t->AddDependency(TEXT("BASEIE40_NTAlpha"), TEXT('\\'));
            delete pCifRWComponent_t;
            g_lpCifRWFileDest->CreateComponent(TEXT("BASEIE40_NTAlpha"), &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->AddToTreatAsOne(szCabname);
            delete pCifRWComponent_t;
        }
    }
    SetCompSize(szCabPath, szCabname, dwInstallSize);
    return(S_OK);
}

void BuildIE4Folders(HWND hWnd)
{
    // build desktop.cab if g_szDeskTemp exists and is non-empty
    if (PathIsDirectory(g_szDeskTemp)  &&  !RemoveDirectory(g_szDeskTemp))
    {
        TCHAR szGuid[128];
        TCHAR szCustDesk[128];

        GetPrivateProfileString(IS_STRINGS, TEXT("DesktopName"), TEXT(""), szCustDesk, countof(szCustDesk), g_szDefInf);
        if (ISNULL(szCustDesk))
            LoadString(g_rvInfo.hInst, IDS_CUSTDESK, szCustDesk, countof(szCustDesk));
        GetPrivateProfileString(IS_BRANDING, TEXT("DesktopGuid"), TEXT(""), szGuid, countof(szGuid), g_szCustIns);
        CabUpFolder(hWnd, g_szDeskTemp, TEXT("25,WEB"), TEXT("DESKTOP.CAB"), szCustDesk, szGuid, NULL);
        SignFile(TEXT("DESKTOP.CAB"), g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);
        PathRemovePath(g_szDeskTemp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\ie4comp.cpp ===
#include "precomp.h"
#include <webcheck.h>
#include <intshcut.h>
#include <mlang.h>
#include "ie4comp.h"
#include "updates.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szTitle[];
extern TCHAR g_szBuildTemp[];
extern TCHAR g_szJobVersion[];
extern HANDLE g_hLogFile;
extern TCHAR g_aszLang[][16];
extern int g_nLangs, g_iDownloadState;

TCHAR g_szCustInf[MAX_PATH];
HANDLE g_hDownloadEvent = 0;


TCHAR g_szCifVer[MAX_PATH];
TCHAR g_szDestCif[MAX_PATH];
TCHAR g_szCif[MAX_PATH];
TCHAR g_szCustCif[MAX_PATH];
TCHAR g_szCustItems[MAX_PATH];
TCHAR g_szMyCptrPath[MAX_PATH];
TCHAR g_szCtlPanelPath[MAX_PATH];
TCHAR g_szCustIcmPro[MAX_PATH];
static TCHAR s_aszLangDesc[NUMLANG][64];

UINT g_uiNumCabs = 0;
COMPONENT g_aCustComponents[MAXCUST+1];
int g_nCustComp;
int g_iSelOpt;
int g_nModes;
SITEDATA g_aCustSites[NUMSITES];
int g_iSelSite;
int g_nDownloadUrls;

TCHAR g_szAllModes[16];
TCHAR g_szMastInf[MAX_PATH];
TCHAR g_szDefInf[MAX_PATH];

static DWORD s_dwTotalSize = 0;

extern BOOL g_fCancelled;
extern BOOL g_fDone;
extern BOOL g_fLangInit;

extern RECT g_dtRect;
extern BOOL g_fMailNews95;

extern int g_iCurPage;
extern HWND g_hDlg;

extern PROPSHEETPAGE g_psp[];
extern TCHAR g_szBuildRoot[];
extern TCHAR g_szSrcRoot[];
extern TCHAR g_szWizRoot[];
extern TCHAR g_szLanguage[];
extern BOOL g_fIntranet;
extern TCHAR szHtmlHelp[];

#define NUM_BITMAPS 2
#define CX_BITMAP 16
#define CY_BITMAP 16

PCOMPONENT g_paComp = NULL;
PCOMPONENT g_pMNComp = NULL;
PCOMP_VERSION g_rgCompVer = NULL;
HANDLE g_hAVSThread = NULL;

BOOL g_fOptCompInit = FALSE;
static BOOL s_fCustCompInit = FALSE;
TCHAR g_szActLang[4];
static TCHAR s_szCifNew[MAX_PATH];
static TCHAR s_szCifCabURL[MAX_PATH];
TCHAR g_szIEAKProg[MAX_PATH] = TEXT("");
TCHAR g_szBaseURL[MAX_URL];
TCHAR g_szUpdateData[MAX_URL] = TEXT("");
TCHAR g_szUpdateURL[MAX_URL] = TEXT("");
TCHAR g_szFailedCompsMsg[MAX_PATH];
TCHAR g_szFailedComps[MAX_BUF];
TCHAR g_szFailedCompsBox[MAX_PATH + MAX_BUF];
BOOL g_fFailedComp = FALSE;
HIMAGELIST s_hImgList = 0;
static int s_iSelComp = 0;
static PCOMPONENT s_pSelComp;
static int s_nNewCust = 1;
static TCHAR s_szNewTpl[80];

static WORD s_aCustStaticTextFieldID[] =
{
    IDC_LOC1, IDC_PARAM1, IDC_LOC3, IDC_LOC4, IDC_PARAM2, IDC_SIZE2, IDC_TITLE1, IDC_COMPDESC
};
#define NCUSTSTATICTEXTFIELDS sizeof(s_aCustStaticTextFieldID)/sizeof(WORD)

static WORD s_aCustTextFieldID[] =
{
    IDE_COMPFILENAME, IDE_COMPPARAM, /* IDE_COMPSIZE,*/ IDE_COMPGUID,
    IDE_COMPCOMMAND, IDE_UNINSTALLKEY, IDE_COMPVERSION, IDC_COMPTITLE, IDE_COMPDESC
};
#define NCUSTTEXTFIELDS sizeof(s_aCustTextFieldID)/sizeof(WORD)

static WORD s_aCustFieldID[] =
{
    IDE_COMPFILENAME, IDE_COMPPARAM, /* IDE_COMPSIZE,*/ IDE_COMPGUID,
    IDE_COMPCOMMAND, IDE_UNINSTALLKEY, IDE_COMPVERSION, IDC_COMPTITLE,
    IDC_VERIFY, IDC_REMOVECOMP, IDC_BROWSEFILE, IDE_COMPDESC, IDC_PREINSTALL, IDC_POSTINSTALL,
    IDC_REBOOTINSTALL, IDC_INSTALLSUCCESS
};

void updateCifVersions32(PCOMPONENT pComp, BOOL fIgnore, BOOL fUpdate = FALSE);
#define NCUSTFIELDS sizeof(s_aCustFieldID)/sizeof(WORD)

void UpdateInf(LPTSTR szMasterInf, LPTSTR szUserInf);

static BOOL s_fNoCore;
TCHAR g_szTempSign[MAX_PATH] = TEXT("");
static TCHAR s_szSiteData[MAX_URL];
extern BOOL g_fBatch;
extern BOOL g_fBatch2;
BOOL g_fInteg = FALSE;
extern void CheckBatchAdvance(HWND hDlg);
extern void DoBatchAdvance(HWND hDlg);
extern DWORD GetRootFree(LPCTSTR pcszPath);
extern BOOL g_fSilent, g_fStealth;

extern void UpdateIEAK(HWND hDlg);

// trust key defines, this are bit fields to determine which one to add/delete

struct TrustKey
{
    TCHAR szCompanyName[MAX_PATH];
    TCHAR szTrustString[MAX_PATH];
    BOOL fSet;
};

static TrustKey s_tkTrustArray[] =
{{TEXT("Microsoft Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap jpjmcfmhckkdfknkfemjikfiodeelkbd"), TRUE},
{TEXT("Microsoft Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap immbkmbpjfdkajbkncahcedfmndgehba"), TRUE},
{TEXT("Microsoft Corporation (Europe)"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap doamnolbnlpmdlpnkcnpckgfimpaaicl"), TRUE},
{TEXT("Microsoft Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap hbgflemajngobcablgnalaidgojggghj"), TRUE},
{TEXT("Microsoft Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap debgjcefniaahdamnhbggedppfiianff"), TRUE},   // new MS cert effective from 4/16/99
{TEXT("Microsoft Corporation (Europe)"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap kefdggbdmbmgbogjdcnmkoodcknmmghc"), TRUE},  // new MS Europe cert effective from 4/16/99
{TEXT("VDOnet Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap moambfklemnlbmhfoomjdignnbkjfkek"), TRUE},
{TEXT("Progressive Networks, Inc."), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap cdikdekkiddcimdmcgedabijgpeobdhd"), TRUE},
{TEXT("Macromedia, Inc."), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap akhlecfpbbjjngidddpgifggcplpcego"), TRUE}
};

extern BOOL g_fSrcDirChanged;
extern HINSTANCE hBrand;
extern BOOL g_fCD, g_fLAN, g_fDownload, g_fBrandingOnly;

BOOL g_fLocalMode = FALSE;

DWORD BuildCDandMflop(LPVOID);

HANDLE g_hProcessInfEvent = 0;
HANDLE g_hCifEvent = 0;

extern BOOL g_fOCW;

// core section component names for base

#define BASEWIN32 TEXT("BASEIE40_WIN")


// returns the component structure for base IE4 component, if for some
// weird reason its not there just return the first component structure
// in the list

PCOMPONENT FindComp(LPCTSTR szID, BOOL fCore)
{
    PCOMPONENT pComp;
    UINT       i;

    for (pComp = g_paComp, i=0; ((i < g_uiNumCabs) && (*pComp->szSection)); pComp++)
    {
        if (fCore)
        {
            // Note: we are depending on the section name of core IE4 here

            if (StrCmpI(pComp->szSection, BASEWIN32) == 0)
                return pComp;
        }
        else
        {
            if (StrCmpI(pComp->szSection, szID) == 0)
                return pComp;
        }
    }

    if (fCore)
        return g_paComp;
    else
        return NULL;
}

PCOMPONENT FindVisibleComponentName(LPCTSTR pcszCompName)
{
    PCOMPONENT pComp;
    for (pComp = g_paComp; *pComp->szSection; pComp++ )
    {
        if ((StrCmpI(pComp->szDisplayName, pcszCompName) == 0) && pComp->fVisible && 
            !pComp->fAddOnOnly)
            return(pComp);
    }
    return(NULL);

}

PCOMPONENT FindCustComp(LPCTSTR szID)
{
    PCOMPONENT pComp;

    for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
    {
        if (StrCmpI(pComp->szSection, szID) == 0)
            return pComp;
    }

    return NULL;
}

PCOMPONENT FindCustComponentName(LPTSTR szCompName)
{
    int i;
    PCOMPONENT pComp;
    for (i = 0, pComp = g_aCustComponents; i < g_nCustComp; i++, pComp++ )
    {
        if (StrCmp(pComp->szDisplayName, szCompName) == 0) return(pComp);
    }
    return(NULL);

}

PCOMPONENT FindCustComponentIndex(int iList)
{
    int i;
    PCOMPONENT pComp;
    for (i = 0, pComp = g_aCustComponents; i < g_nCustComp; i++, pComp++ )
    {
        if (pComp->iList == iList) return(pComp);
    }
    return(NULL);

}

int GetActiveSetupURL( LPTSTR pSection, LPTSTR szUrl, int /*iSize*/, LPTSTR szCif)
{
    TCHAR szUrlWrk[MAX_URL];

    GetPrivateProfileString( pSection, TEXT("URL1"), TEXT(""), szUrlWrk, MAX_URL, szCif );

    if (*szUrlWrk != TEXT('"')) StrCpy(szUrl, szUrlWrk);
    else
        StrCpy(szUrl, szUrlWrk + 1);
    StrTok(szUrl + 1, TEXT("\" ,"));
    return(lstrlen(szUrl));

}

void WriteActiveSetupURL(PCOMPONENT pComp, LPTSTR szCif)
{
    TCHAR szUrlWrk[MAX_URL] = TEXT("\"");
    StrCat(szUrlWrk, pComp->szUrl);
    StrCat(szUrlWrk, (pComp->iType != INST_CAB) ? TEXT("\",2") : TEXT("\",3"));
    WritePrivateProfileString(pComp->szSection, TEXT("URL1"), szUrlWrk, szCif);
}



//
//  FUNCTION: GetCustComponent(HWND, int)
//
//  PURPOSE:  Gets custom component data entered in the dialog boxes,
//              and saves it in memory
//
void GetCustComponent(HWND hDlg, int iList)
{
    PCOMPONENT pComp = FindCustComponentIndex(iList);
    if (pComp == NULL) return;
    GetDlgItemText( hDlg, IDE_COMPFILENAME, pComp->szPath, countof(pComp->szPath) );
    GetDlgItemText( hDlg, IDE_COMPCOMMAND, pComp->szCommand, countof(pComp->szCommand) );
    GetDlgItemText( hDlg, IDE_COMPPARAM, pComp->szSwitches, countof(pComp->szSwitches) );
    GetDlgItemText( hDlg, IDE_COMPGUID, pComp->szGUID, countof(pComp->szGUID) );
    GetDlgItemText( hDlg, IDE_UNINSTALLKEY, pComp->szUninstall, countof(pComp->szUninstall) );
    GetDlgItemText( hDlg, IDE_COMPVERSION, pComp->szVersion, countof(pComp->szVersion) );
    SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_GETLBTEXT, pComp->iList,(LPARAM) pComp->szDisplayName );
    GetDlgItemText( hDlg, IDE_COMPDESC, pComp->szDesc, countof(pComp->szDesc) );

    if (IsDlgButtonChecked(hDlg, IDC_POSTINSTALL) == BST_CHECKED)
        pComp->iInstallType = 0;
    else
    {
        if (IsDlgButtonChecked(hDlg, IDC_PREINSTALL) == BST_CHECKED)
            pComp->iInstallType = 1;
        else
            pComp->iInstallType = 2;
    }
    pComp->fIEDependency = (IsDlgButtonChecked(hDlg, IDC_INSTALLSUCCESS) == BST_CHECKED);
}

void CheckCompType(HWND hDlg, PCOMPONENT pComp )
{
    HANDLE hFile;
    DWORD dwSize = 0;
    LPTSTR pDot, pBack;
    if (!pComp) return;
    GetDlgItemText( hDlg, IDE_COMPFILENAME, pComp->szPath, countof(pComp->szPath) );

    pComp->dwSize = 0;
    if ((hFile = CreateFile(pComp->szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
    {
        pComp->dwSize = ((dwSize = GetFileSize(hFile, NULL)) != 0xffffffff) ? (dwSize >> 10) : 0;
        CloseHandle(hFile);
    }
    //SetDlgItemInt( hDlg, IDE_COMPSIZE, dwSize, FALSE);

    pDot = StrRChr(pComp->szPath, NULL, TEXT('.'));
    pBack = StrRChr(pComp->szPath, NULL, TEXT('\\'));
    if ((pDot != NULL) && (StrCmpI(pDot, TEXT(".cab")) == 0))
    {
        EnableDlgItem(hDlg, IDE_COMPCOMMAND);
        pComp->iType = INST_CAB;
        if (pBack != NULL)
        {
            StrCpy(pComp->szUrl, pBack + 1);
        }
        return;
    }
    DisableDlgItem(hDlg, IDE_COMPCOMMAND);

    if ((pDot != NULL) && (StrCmpI(pDot, TEXT(".exe")) == 0))
    {
        pComp->iType = INST_EXE;
        if (pBack != NULL)
        {
            StrCpy(pComp->szCommand, pBack + 1);
            StrCpy(pComp->szUrl, pBack + 1);
            SetDlgItemText( hDlg, IDE_COMPCOMMAND, pComp->szCommand );
        }
    }
}

//
//  FUNCTION: SetCustComponent(HWND, int)
//
//  PURPOSE:  Gets custom component data from memory,
//              and displays it on the screen
//
void SetCustComponent(HWND hDlg, int iList)
{
    PCOMPONENT pComp = FindCustComponentIndex(iList);
    if (!pComp)
    {
        int i;
        SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_SETCURSEL, 0, 0L );
        for (i = 0; i < NCUSTFIELDS ; i++ )
        {
            EnsureDialogFocus(hDlg, s_aCustFieldID[i], IDC_ADDNEWCOMP);
            DisableDlgItem(hDlg, s_aCustFieldID[i]);
        }
        for (i = 0; i < NCUSTTEXTFIELDS ; i++ )
        {
            SetDlgItemText( hDlg, s_aCustTextFieldID[i] , TEXT("") );
        }
        
        for (i = 0; i < NCUSTSTATICTEXTFIELDS ; i++ )
            DisableDlgItem(hDlg, s_aCustStaticTextFieldID[i]);

        CheckDlgButton(hDlg, IDC_PREINSTALL, BST_UNCHECKED);
        return;
    }
    SetDlgItemText( hDlg, IDE_COMPFILENAME, pComp->szPath );
    CheckCompType(hDlg, pComp);
    SetDlgItemText( hDlg, IDE_COMPCOMMAND, pComp->szCommand );
    if (ISNULL(pComp->szGUID))
    {
        GUID guid;

        if (CoCreateGuid(&guid) == NOERROR)
            CoStringFromGUID(guid, pComp->szGUID, countof(pComp->szGUID));
        else
            wnsprintf(pComp->szGUID, countof(pComp->szGUID), TEXT("CUSTOM%i"),iList);
    }
    SetDlgItemText( hDlg, IDE_COMPGUID, pComp->szGUID );
    SetDlgItemText( hDlg, IDE_COMPPARAM, pComp->szSwitches );
    SetDlgItemText( hDlg, IDE_UNINSTALLKEY, pComp->szUninstall );
    SetDlgItemText( hDlg, IDE_COMPVERSION, pComp->szVersion);
    SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_SETCURSEL, pComp->iList, 0L );
    SetDlgItemText( hDlg, IDC_COMPTITLE, pComp->szDisplayName);
    SetDlgItemText(hDlg, IDE_COMPDESC, pComp->szDesc);
    CheckRadioButton(hDlg, IDC_POSTINSTALL, IDC_REBOOTINSTALL, IDC_POSTINSTALL + pComp->iInstallType);
    CheckDlgButton( hDlg, IDC_INSTALLSUCCESS, pComp->fIEDependency ? BST_CHECKED : BST_UNCHECKED);
    EnableDlgItem2(hDlg, IDC_INSTALLSUCCESS, (pComp->iInstallType != 1));

    if (g_nCustComp < MAXCUST)
        EnableDlgItem(hDlg, IDC_ADDNEWCOMP);
    else
    {
        EnsureDialogFocus(hDlg, IDC_ADDNEWCOMP, IDC_REMOVECOMP);
        DisableDlgItem(hDlg, IDC_ADDNEWCOMP);
    }
    SetFocus(GetDlgItem( hDlg, IDC_COMPTITLE ));
}


void InitCustComponents(HWND hDlg)
{
    TCHAR szSectBuf[2048];
    LPTSTR pSection = szSectBuf;
    HWND hCompList;
    PCOMPONENT pComp;
    TCHAR szCustCifName[32];

    if (hDlg) hCompList = GetDlgItem(hDlg, IDC_COMPTITLE);

    StrCpy(szCustCifName, TEXT("CUSTOM.CIF"));
    PathCombine(g_szCustCif, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCustCif, GetOutputPlatformDir());
    PathAppend(g_szCustCif, g_szLanguage);
    PathAppend(g_szCustCif, szCustCifName);
    LoadString( g_rvInfo.hInst, IDS_NEWCUST, s_szNewTpl, countof(s_szNewTpl) );

    ZeroMemory(szSectBuf, sizeof(szSectBuf));
    GetPrivateProfileString( NULL, NULL, TEXT(""), szSectBuf, countof(szSectBuf), g_szCustCif );
    pComp = g_aCustComponents;

    g_nCustComp = 0;
    s_nNewCust = 1;
    while (*pSection)
    {
        int i;
        if (StrCmp(pSection, CUSTCMSECT) == 0)
        {
            pSection += lstrlen(pSection) + 1;
            continue;
        }
        StrCpy(pComp->szSection, pSection);
        GetPrivateProfileString( pSection, TEXT("Switches1"), TEXT(""), pComp->szSwitches, countof(pComp->szSwitches), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("DisplayName"), TEXT(""), pComp->szDisplayName, countof(pComp->szDisplayName), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("GUID"), TEXT(""), pComp->szGUID, countof(pComp->szGUID), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("UninstallKey"), TEXT(""), pComp->szUninstall, countof(pComp->szUninstall), g_szCustCif );
        GetActiveSetupURL( pSection, pComp->szUrl, countof(pComp->szUrl), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("Version"), TEXT(""), pComp->szVersion, countof(pComp->szVersion), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("Command1"), TEXT(""), pComp->szCommand, countof(pComp->szVersion), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("Path"), TEXT(""), pComp->szPath, countof(pComp->szPath), g_szCustCif );
        pComp->dwSize = GetPrivateProfileInt( pSection, TEXT("Size"), 0, g_szCustCif );
        pComp->iType = GetPrivateProfileInt( pSection, TEXT("Type1"), 0, g_szCustCif );
        pComp->iInstallType = GetPrivateProfileInt( pSection, TEXT("PreInstall"), 0, g_szCustCif);

        if (hDlg != NULL)
            pComp->iList = (int) SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName );
        
        GetPrivateProfileString( pSection, TEXT("Details"), TEXT(""), pComp->szDesc, countof(pComp->szDesc), g_szCustCif );
        pComp->fVisible = TRUE;
        pComp->fIEDependency = InsGetBool(pSection, TEXT("Dependency"), 0, g_szCustCif);
        
        if (StrCmpN(pComp->szDisplayName, s_szNewTpl, lstrlen(s_szNewTpl)) == 0)
        {
            i = StrToInt(pComp->szDisplayName + lstrlen(s_szNewTpl));
            if (i >= s_nNewCust) s_nNewCust = i  + 1;
        }
        i = StrToInt(pSection + countof("CUSTOM")-1);
        if (i >= s_nNewCust) s_nNewCust = i  + 1;
        pSection += StrLen(pSection) + 1;
        pComp++;
        g_nCustComp++;
    }

    s_iSelComp = 0;
    s_pSelComp = g_aCustComponents;
    if (hDlg != NULL)
        s_fCustCompInit = TRUE;

    if (g_nCustComp == 0)
    {
        if (hDlg != NULL)
        {
            int i;
            
            for (i = 0; i < NCUSTFIELDS ; i++ )
            {
                EnsureDialogFocus(hDlg, s_aCustFieldID[i], IDC_ADDNEWCOMP);
                DisableDlgItem(hDlg, s_aCustFieldID[i]);
            }
            for (i = 0; i < NCUSTSTATICTEXTFIELDS ; i++ )
                DisableDlgItem(hDlg, s_aCustStaticTextFieldID[i]);
        }
    }
    else
    {
        int i, iComp;

        if (hDlg != NULL)
            SetCustComponent(hDlg, 0);

        for (pComp = g_aCustComponents, iComp = 0; iComp < g_nCustComp ; pComp++, iComp++ )
        {
            TCHAR szModesParam[80] = TEXT("Cust0Modes");
            TCHAR szModes[16] = TEXT("\"");
            if (ISNULL(pComp->szSection)) break;
            szModesParam[4] = (TCHAR)(iComp + TEXT('0'));
            ZeroMemory(pComp->afInstall, sizeof(pComp->afInstall));
            GetPrivateProfileString(IS_STRINGS, szModesParam, TEXT(""), szModes, countof(szModes), g_szCustInf);
            StrCpy(pComp->szModes, szModes);
            if (StrCmpI(szModes, UNUSED) != 0)
            {
                for (i = 0; i < lstrlen(szModes) ; i++ )
                {
                    int j = szModes[i] - TEXT('0');
                    pComp->afInstall[j] = TRUE;
                }
            }

        }
    }
}

void SaveCustComponents()
{
    PCOMPONENT pComp;
    int i;
    TCHAR szSize[8];
    TCHAR szType[8];
    TCHAR szModesParam[80] = TEXT("Cust0Modes");
    TCHAR szTemp[80];

    for (pComp = g_aCustComponents, i = 0; i < g_nCustComp ; pComp++, i++)
    {
        LPTSTR pSection = pComp->szSection;
        wnsprintf(pSection, countof(pComp->szSection), TEXT("CUSTOM%i"), i);
        wnsprintf(szTemp, 80, TEXT("\"%s\""), pComp->szSwitches);
        StrCpy(pComp->szSwitches, szTemp);
        WritePrivateProfileString( pSection, TEXT("Switches1"),  pComp->szSwitches, g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("DisplayName"), pComp->szDisplayName, g_szCustCif );
        pComp->fVisible = TRUE;
        if (ISNULL(pComp->szGUID))
        {
            GUID guid;

            if (CoCreateGuid(&guid) == NOERROR)
                CoStringFromGUID(guid, pComp->szGUID, countof(pComp->szGUID));
            else
                wnsprintf(pComp->szGUID, countof(pComp->szGUID), TEXT("CUSTOM%i"),i);
        }
        WritePrivateProfileString( pSection, TEXT("GUID"),  pComp->szGUID,  g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("UninstallKey"),  pComp->szUninstall,  g_szCustCif );
        WriteActiveSetupURL(pComp,  g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Version"),  pComp->szVersion, g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Command1"), pComp->szCommand,  g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Path"), pComp->szPath, g_szCustCif );
        wnsprintf(szSize, countof(szSize), TEXT("%i"), (int) pComp->dwSize);
        wnsprintf(szType, countof(szType), TEXT("%i"), pComp->iType);
        WritePrivateProfileString( pSection, TEXT("Size"), szSize, g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Type1"), szType, g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Details"), pComp->szDesc, g_szCustCif );
        InsWriteInt( pSection, TEXT("PreInstall"), pComp->iInstallType, g_szCustCif );
        InsWriteBool( pSection, TEXT("Dependency"), pComp->fIEDependency, g_szCustCif );
        
        szModesParam[4] = (TCHAR)(i + TEXT('0'));
        WritePrivateProfileString(IS_STRINGS, szModesParam, pComp->szModes, g_szCustInf);
    }
    for (; i <= MAXCUST ; i++ )
    {
        TCHAR szSection[16];
        wnsprintf(szSection, countof(szSection), TEXT("CUSTOM%i"), i);
        WritePrivateProfileString( szSection, NULL, NULL, g_szCustCif );
        szModesParam[4] = (TCHAR)(i + TEXT('0'));
        WritePrivateProfileString(IS_STRINGS, szModesParam, NULL, g_szCustInf);
    }

    WritePrivateProfileString(NULL, NULL, NULL, g_szCustCif);
    WritePrivateProfileString(NULL, NULL, NULL, g_szCustInf);
}

// validate version info so that it can either contain a '.' char or numbers 0 - 9.
BOOL IsValidVersion(HWND hDlg, UINT nVersionCtrlID)
{
    TCHAR szVersion[MAX_PATH];
    int   nInvalidCharPos = -1;
    int   nLen            = 0;
    int   nNumLen         = 0;
    int   nComma          = 0;

    ZeroMemory(szVersion, sizeof(szVersion));
    GetDlgItemText(hDlg, nVersionCtrlID, szVersion, countof(szVersion));

    if (*szVersion == TEXT('\0'))
        return TRUE;

    nLen = StrLen(szVersion);
    for(int i = 0; (i < nLen && nInvalidCharPos == -1); i++)
    {
        if (szVersion[i] != TEXT(',') && !(szVersion[i] >= TEXT('0') && szVersion[i] <= TEXT('9')))
            nInvalidCharPos = i;
        else if (szVersion[i] == TEXT(','))
        {
            nComma++;
            if (i == 0 || szVersion[i - 1] == TEXT(',') || nComma > 3)
                nInvalidCharPos = i;
            nNumLen = 0;
        }
        else
        {
            nNumLen++;
            if (nNumLen > 4)
                nInvalidCharPos = i;
        }
    }
    if (nInvalidCharPos == -1 && (nNumLen == 0 || nComma < 3))
        nInvalidCharPos = nLen;

    if (nInvalidCharPos >= 0)
    {
        ErrorMessageBox(hDlg, IDS_INVALID_VERSION);
        SetFocus(GetDlgItem(hDlg, nVersionCtrlID));
        SendMessage(GetDlgItem(hDlg, nVersionCtrlID), EM_SETSEL, (WPARAM)nInvalidCharPos, (LPARAM)nLen);
        return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: CustomComponents(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "CustomComponents" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
INT_PTR CALLBACK CustomComponents(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    int     iComp, iNewSel, i;
    HRESULT res;
    HWND    hComplist;
    DWORD   dwFlags;

    switch (message)
    {
        case WM_INITDIALOG:
            EnableDBCSChars( hDlg, IDE_COMPFILENAME);
            EnableDBCSChars( hDlg, IDC_COMPTITLE);
            EnableDBCSChars( hDlg, IDE_COMPCOMMAND);
            EnableDBCSChars( hDlg, IDE_UNINSTALLKEY);
            EnableDBCSChars( hDlg, IDE_COMPPARAM);
            EnableDBCSChars( hDlg, IDE_COMPDESC);
            DisableDBCSChars(hDlg, IDE_COMPGUID);
            DisableDBCSChars(hDlg, IDE_COMPVERSION);

            // format for version field is XXXX,XXXX,XXXX,XXXX
            Edit_LimitText(GetDlgItem(hDlg, IDE_COMPVERSION), 19);
            Edit_LimitText(GetDlgItem(hDlg, IDC_COMPTITLE), countof(g_paComp->szDisplayName)-1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_COMPDESC), countof(g_paComp->szDesc)-1);

            g_hWizard = hDlg;
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                TCHAR szBuf[MAX_PATH];

                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_ADDNEWCOMP:
                            iComp = g_nCustComp;
                            if (iComp != 0)
                            {
                                GetCustComponent(hDlg, s_iSelComp);
                                if (ISNULL(g_aCustComponents[s_iSelComp].szDisplayName))
                                {
                                    ErrorMessageBox(hDlg, IDS_NOCUSTCOMPNAME);
                                    return TRUE;
                                }

                                dwFlags = FC_NONNULL | FC_FILE | FC_EXISTS;

                                if (!CheckField(hDlg, IDE_COMPFILENAME, dwFlags)
                                    || !IsValidVersion(hDlg, IDE_COMPVERSION))
                                    return TRUE;
                            }
                            else
                            {
                                for (i = 0; i < NCUSTFIELDS ; i++ )
                                {
                                    EnableDlgItem(hDlg, s_aCustFieldID[i]);
                                }

                                for (i = 0; i < NCUSTSTATICTEXTFIELDS ; i++ )
                                    EnableDlgItem(hDlg, s_aCustStaticTextFieldID[i]);
                            }

                            g_nCustComp++;
                            s_pSelComp = &g_aCustComponents[iComp];
                            ZeroMemory(s_pSelComp, sizeof(COMPONENT));
                            wnsprintf(s_pSelComp->szSection, countof(s_pSelComp->szSection), TEXT("CUSTOM%i"), s_nNewCust);
                            wnsprintf(s_pSelComp->szDisplayName, countof(s_pSelComp->szDisplayName), TEXT("%s%i"), s_szNewTpl, s_nNewCust++);
                            StrCpy(s_pSelComp->szModes, g_szAllModes);
                            s_pSelComp->iList = (int) SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_ADDSTRING, 0, (LPARAM) s_pSelComp->szDisplayName );
                            SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_SETCURSEL, s_pSelComp->iList, 0L);
                            s_iSelComp = s_pSelComp->iList;
                            SetCustComponent(hDlg, s_pSelComp->iList);
                            SendMessage(GetDlgItem( hDlg, IDC_COMPTITLE ), CB_SETEDITSEL,
                                0, MAKELPARAM(0, -1));
                            break;
                        case IDC_VERIFY:
                            dwFlags = FC_NONNULL | FC_FILE | FC_EXISTS;

                            if (!CheckField(hDlg, IDE_COMPFILENAME, dwFlags))
                                break;
                            s_pSelComp = &g_aCustComponents[s_iSelComp];
                            res = CheckTrustExWrap(NULL, s_pSelComp->szPath, hDlg, FALSE, NULL);
                            switch (res)
                            {
                                case NOERROR:
// note that the following means that the idiot hit 'no':
                                case TRUST_E_SUBJECT_NOT_TRUSTED:
                                case E_ABORT:
                                    ErrorMessageBox(hDlg, IDS_SIGNEDMSG, MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION);
                                    break;
                                case TRUST_E_NOSIGNATURE:
                                    ErrorMessageBox(hDlg, IDS_PLEASESIGNMSG);
                                    break;
                                case CERT_E_EXPIRED:
                                    ErrorMessageBox(hDlg, IDS_CERTEXPIREDMSG);
                                    break;
                                case TRUST_E_PROVIDER_UNKNOWN:
                                case CERT_E_UNTRUSTEDROOT:
                                    ErrorMessageBox(hDlg, IDS_BADPROVIDERMSG);
                                    break;
                                case CERT_E_MALFORMED:
                                case CERT_E_ISSUERCHAINING:
                                case CERT_E_CHAINING:
                                case CERT_E_CRITICAL:
                                case CERT_E_PATHLENCONST:
                                case CERT_E_ROLE:
                                case DIGSIG_E_DECODE:
                                case DIGSIG_E_ENCODE:
                                case DIGSIG_E_CRYPTO:
                                case DIGSIG_E_EXTENSIBILITY:
                                default:
                                    ErrorMessageBox(hDlg, IDS_CERTERRORMSG);
                                    break;
                            }
                            break;
                        case IDC_REMOVECOMP:
                            s_iSelComp = (int) SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_GETCURSEL, 0, 0L);
                            SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_DELETESTRING, s_iSelComp, 0L );
                            WritePrivateProfileString( g_aCustComponents[s_iSelComp].szSection, NULL, NULL, g_szCustCif );
                            for (i = s_iSelComp; i < g_nCustComp ; i++ )
                            {
                                g_aCustComponents[i] = g_aCustComponents[i + 1];
                                g_aCustComponents[i].iList--;
                            }
                            ZeroMemory(&g_aCustComponents[g_nCustComp--], sizeof(COMPONENT));
                            if (s_iSelComp >= g_nCustComp) s_iSelComp = g_nCustComp - 1;
                            SetCustComponent(hDlg, s_iSelComp);
                            break;
                        case IDC_BROWSEFILE:
                            GetDlgItemText(hDlg, IDE_COMPFILENAME, szBuf, countof(szBuf));
                            if (BrowseForFile(hDlg, szBuf, countof(szBuf), GFN_EXE | GFN_CAB))
                                SetDlgItemText(hDlg, IDE_COMPFILENAME, szBuf);
                            break;

                        case IDC_POSTINSTALL:
                        case IDC_REBOOTINSTALL:
                            if (HIWORD(wParam) == BN_CLICKED)
                            {
                                EnableDlgItem(hDlg, IDC_INSTALLSUCCESS);
                                break;
                            }
                            return FALSE;

                        case IDC_PREINSTALL:
                            if (HIWORD(wParam) == BN_CLICKED)
                            {
                                CheckDlgButton(hDlg, IDC_INSTALLSUCCESS, BST_UNCHECKED);
                                DisableDlgItem(hDlg, IDC_INSTALLSUCCESS);
                                break;
                            }
                            return FALSE;

                        default:
                            return FALSE;
                    }
                    break;

                case CBN_SELENDOK:
                    hComplist = GetDlgItem(hDlg, IDC_COMPTITLE);
                    iNewSel = (int) SendMessage( hComplist, CB_GETCURSEL, 0, 0L);
                    if (iNewSel != s_iSelComp)
                    {
                        if (ISNULL(g_aCustComponents[s_iSelComp].szDisplayName))
                        {
                            ErrorMessageBox(hDlg, IDS_NOCUSTCOMPNAME);
                            return TRUE;
                        }

                        dwFlags = FC_NONNULL | FC_FILE | FC_EXISTS;

                        if (!CheckField(hDlg, IDE_COMPFILENAME, dwFlags))
                        {
                            return TRUE;
                        }

                        if (!IsValidVersion(hDlg, IDE_COMPVERSION))
                            return TRUE;
                    }

                    GetWindowText( hComplist, s_pSelComp->szDisplayName, 80 );
                    SendMessage( hComplist, CB_DELETESTRING, s_iSelComp, 0L );
                    SendMessage( hComplist, CB_INSERTSTRING, s_iSelComp,
                        (LPARAM) s_pSelComp->szDisplayName);
                    if ((iNewSel != CB_ERR) && (iNewSel != s_iSelComp))
                    {
                        GetCustComponent(hDlg, s_iSelComp);
                        s_iSelComp = iNewSel;
                        s_pSelComp = &g_aCustComponents[s_iSelComp];
                        SetCustComponent(hDlg, s_iSelComp);
                    }
                    if (iNewSel < 0) iNewSel = 0;
                    SendMessage( hComplist, CB_SETCURSEL, iNewSel, 0L );
                    break;

                case CBN_EDITCHANGE:
                    GetWindowText( (HWND) lParam, s_pSelComp->szDisplayName, 80 );
                    break;

                case CBN_CLOSEUP:
                case CBN_SELENDCANCEL:
                case CBN_DROPDOWN:
                case CBN_KILLFOCUS:
                    if (s_iSelComp >= 0)
                    {
                        hComplist = GetDlgItem(hDlg, IDC_COMPTITLE);
                        GetWindowText( hComplist, s_pSelComp->szDisplayName, countof(s_pSelComp->szDisplayName) );
                        SendMessage( hComplist, CB_DELETESTRING, s_iSelComp, 0L );
                        SendMessage( hComplist, CB_INSERTSTRING, s_iSelComp,
                            (LPARAM) s_pSelComp->szDisplayName);
                        SendMessage( hComplist, CB_SETCURSEL, s_iSelComp, 0L );
                    }
                    break;

                case EN_CHANGE:
                    switch (LOWORD(wParam))
                    {
                        case IDE_COMPFILENAME:
                            if (s_pSelComp) CheckCompType(hDlg, s_pSelComp);
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!s_fCustCompInit)
                        InitCustComponents(hDlg);
                    else
                        SetCustComponent(hDlg, s_iSelComp);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    CheckBatchAdvance(hDlg);
                    break;


                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    GetCustComponent(hDlg, s_iSelComp);

                    if (g_nCustComp > 0)
                    {
                        if (ISNULL(g_aCustComponents[s_iSelComp].szDisplayName))
                        {
                            ErrorMessageBox(hDlg, IDS_NOCUSTCOMPNAME);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        dwFlags = FC_NONNULL | FC_FILE | FC_EXISTS;

                        if (!CheckField(hDlg, IDE_COMPFILENAME, dwFlags))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        if (!IsValidVersion(hDlg, IDE_COMPVERSION))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                    }

                    SaveCustComponents();

                    g_iCurPage = PPAGE_CUSTCOMP;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;

        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

int s_aiIcon[7];
HWND s_hStat,s_hStatus;

extern HWND g_hProgress;
static BOOL s_fComponent = FALSE;

static BOOL s_fNoNet = FALSE;
HWND g_hWait = NULL;

INT_PTR CALLBACK DownloadStatusDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM)
{
    RECT dlgRect;
    DWORD width, height, left, top;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            if (s_fComponent)
            {
                Animate_Open( GetDlgItem( hDlg, IDC_ANIM ), IDA_DOWNLOAD );
                Animate_Play( GetDlgItem( hDlg, IDC_ANIM ), 0, -1, -1 );
                InitSysFont(hDlg, IDC_DOWNCOMPNAMD);
                InitSysFont(hDlg, IDC_DOWNSTATUS);

                g_hProgress = GetDlgItem( hDlg, IDC_PROGRESS );
                s_hStatus = GetDlgItem( hDlg, IDC_DOWNSTATUS );
                SendMessage(g_hProgress, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
                SendMessage(g_hProgress, PBM_SETPOS, 0, 0L);
            }
            else
            {
                Animate_Open( GetDlgItem( hDlg, IDC_ANIM ), IDA_GEARS );
                Animate_Play( GetDlgItem( hDlg, IDC_ANIM ), 0, -1, -1 );
            }
            GetWindowRect(hDlg, &dlgRect);
            width = dlgRect.right - dlgRect.left;
            height = dlgRect.bottom - dlgRect.top;
            left = (g_dtRect.right - width)/2;
            top = (g_dtRect.bottom - height)/2;
            MoveWindow(hDlg, left, top, width, height, TRUE);
            break;

        case WM_COMMAND:
            if ((LOWORD(wParam) == IDCANCEL) && (HIWORD(wParam) == BN_CLICKED)) g_fCancelled = TRUE;
            break;

        case WM_CLOSE:
            g_hProgress = NULL;
            s_hStatus = NULL;
            EndDialog(hDlg, 0);
            break;

        default:
            return(FALSE);
    }
    return(TRUE);

}


static HINTERNET s_hInet = NULL;
DWORD g_nTotDown = 0;

HRESULT InetDownloadFile(LPTSTR szTempfile, LPTSTR szUrl, HWND hProgress, int sDownload, LPTSTR szFilename)
{
    HRESULT res = NOERROR;
    HINTERNET hInetFile = 0;
    DWORD dwTotDown = 0;
    if (s_hInet == NULL)
        s_hInet = InternetOpen(TEXT("Mozilla/4.0 (compatible; MSIE 4.01; Windows NT);IEAKWIZ"),
        INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);

    hInetFile = InternetOpenUrl(s_hInet, szUrl, TEXT("Accept: */*\r\n"), (DWORD)-1,
        INTERNET_FLAG_DONT_CACHE, 0);

    if (hInetFile  != NULL)
    {
        CHAR szBuf[4096];
        DWORD nRead, nWritten;
        MSG msg;
        DeleteFile(szTempfile);
        HANDLE hFile = CreateFile(szTempfile, GENERIC_WRITE, 0, NULL, CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE) while (1)
        {
            if (g_fCancelled)
            {
                res = -1;
                break;
            }
            while (PeekMessage( &msg, s_hStat, 0, 0, PM_REMOVE ))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            if (InternetReadFile(hInetFile, szBuf, sizeof(szBuf), &nRead))
            {
                if (nRead == 0) break;
                WriteFile( hFile, szBuf, nRead, &nWritten, NULL );
                dwTotDown += nWritten;
                g_nTotDown += nWritten;
                if (hProgress != NULL)
                {
                    int iPercent = g_nTotDown / (sDownload * 10);
                    SendMessage(hProgress, PBM_SETPOS, iPercent, 0L);
                    SetWindowTextSmart( s_hStatus, szFilename );
                }
            }
            else
            {
                res = -1;
                break;
            }
        }
//Code Path never called under NT build environment
//causes build error under MSDev: pFilename not defined
/*
#ifdef _DEBUG
        if (g_nTotDown)
        {
            TCHAR szMsg[MAX_PATH];
            wnsprintf(szMsg, countof(szMsg), "BRANDME: Wrote %i bytes to %s\r\n", g_nTotDown, pFilename);
            OutputDebugString(szMsg);
        }
#endif
*/
        CloseHandle(hFile);
        InternetCloseHandle(hInetFile);
    }
    else  res = -1;
    if (dwTotDown < 512)
        res = -1;

    return(res);
}

INT_PTR CALLBACK DupeSynchDlgProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    int nResult;
    switch (iMsg)
    {
    case WM_INITDIALOG:
        SetWindowText(hDlg, (TCHAR *)lParam);
        SetTimer(hDlg, 0, 300000, NULL);
        return TRUE;
    case WM_TIMER:
        EndDialog(hDlg, IDIGNORE);
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD (wParam))
        {
        case IDC_NOTOALL:
            nResult = IDIGNORE;
            break;
        case IDC_YESSYNCH:
            nResult = IDYES;
            break;
        case IDC_NOSYNCH:
        default:
            nResult = IDNO;
            break;
        }
        EndDialog(hDlg, nResult);
        return TRUE;
    }
    return FALSE;
}

INT_PTR CALLBACK ErrDlgProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    int nResult;
    switch (iMsg)
    {
    case WM_INITDIALOG:
        if (GetDlgItem(hDlg, IDC_BADCOMP))
            SetDlgItemText(hDlg, IDC_BADCOMP, (TCHAR *)lParam);
        else
        {
            if (GetDlgItem(hDlg, IDC_BADCOMPSEC))
                SetDlgItemText(hDlg, IDC_BADCOMPSEC, (TCHAR *)lParam);
        }
        SetTimer(hDlg, 0, 300000, NULL);
        return TRUE;
    case WM_TIMER:
        EndDialog(hDlg, IDIGNORE);
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD (wParam))
        {
        case IDC_ERRDLABORT:
            nResult = IDABORT;
            break;
        case IDC_ERRDLRETRY:
        case IDC_SECERRYES:
            nResult = IDRETRY;
            break;
        case IDC_SECERRNO:
        case IDC_ERRDLIGNORE:
        default:
            nResult = IDIGNORE;
            break;
        }
        EndDialog(hDlg, nResult);
        return TRUE;
    }
    return FALSE;
}

int DownloadErrMsg(HWND hWnd, LPTSTR szFilename, LPCTSTR lpTemplateName)
{
    return (int) DialogBoxParam(g_rvInfo.hInst, lpTemplateName, hWnd, ErrDlgProc, LPARAM(szFilename));
}

HRESULT DownloadCab(HWND hDlg, LPTSTR szUrl, LPTSTR szFilename, LPCTSTR pcszDisplayname, int sComponent, BOOL &fIgnore)
{
    HRESULT res = NOERROR;
    TCHAR szTempfile[MAX_PATH];
    LPTSTR pBack, pDot, pFile, pSlash;
    int i, iMsgRes;

    StrCpy( szTempfile, szFilename );
    pBack = StrRChr(szTempfile, NULL, TEXT('\\'));
    pDot = StrRChr(szUrl, NULL, TEXT('.'));
    pSlash = StrRChr(szUrl, NULL, TEXT('/'));
    StrCpy(pBack, TEXT("\\TEMPFILE"));
    if (pDot > pSlash)
        StrCat(szTempfile, pDot);
    DeleteFile( szTempfile );

    if (pcszDisplayname)
    {
        s_fComponent = TRUE;
        SetDlgItemText( s_hStat, IDC_DOWNCOMPNAMD, pcszDisplayname );
    }

    pFile = StrRChr(szUrl, NULL, TEXT('/'));
    if (pFile)
        pFile++;
    else
        pFile = szUrl;

    for (i=0; i < 3; i++)
    {
        res = InetDownloadFile(szTempfile, szUrl, g_hProgress, sComponent, szFilename);

        if ((res == NOERROR)||(g_fCancelled))
        {
            break;
        }
    }

    if ((res != NOERROR)&&(!g_fCancelled))
    {
        while( (iMsgRes = DownloadErrMsg(hDlg, pFile, MAKEINTRESOURCE(IDD_DOWNLOADERR))) == IDRETRY)
        {
            res = InetDownloadFile(szTempfile, szUrl, g_hProgress, sComponent, szFilename);

            if (res == NOERROR)
            {
                break;
            }
        }

        if (res != NOERROR)
        {
            if (iMsgRes == IDABORT)
                return res;
            else
            {
                res = NOERROR;
                fIgnore = TRUE;
                StrCat(g_szFailedComps, pFile);
                StrCat(g_szFailedComps, TEXT("\r\n"));
                g_fFailedComp = TRUE;
            }
        }
    }

    if ((!fIgnore)&&(!g_fCancelled))
    {
        DeleteFile(szFilename);
        res = CheckTrustExWrap(szUrl, szTempfile, hDlg, FALSE, NULL);

        if (res != NOERROR)
        {
            iMsgRes = DownloadErrMsg(hDlg, pFile, MAKEINTRESOURCE(IDD_DOWNLOADSEC));
            if (iMsgRes == IDRETRY)
                res = NOERROR;
            else
            {
                StrCat(g_szFailedComps, pFile);
                StrCat(g_szFailedComps, TEXT("\r\n"));
                g_fFailedComp = TRUE;
                res = DONT_SHOW_UPDATES;
            }
        }

        if (res == NOERROR)
        {
            if (!MoveFile( szTempfile, szFilename ))
            {
                res = 0xffffffff;
            }
        }
    }
    DeleteFile(szTempfile);
    return(res);

}

void NeedToSetMSTrustKey()
{
    static BOOL s_fFirst = TRUE;
    HKEY  hKey;
    DWORD dwTmp;

    if (!s_fFirst)
        return;

    s_fFirst = FALSE;

    // Check MS Vendor trust key and set
    if (RegOpenKeyEx(HKEY_CURRENT_USER, RK_TRUSTKEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        for (int i=0; i < countof(s_tkTrustArray); i++)
        {
            if (RegQueryValueEx( hKey, s_tkTrustArray[i].szTrustString, 0, NULL, NULL, &dwTmp ) == ERROR_SUCCESS)
                s_tkTrustArray[i].fSet = FALSE;
        }
        RegCloseKey(hKey);
    }
}

void WriteMSTrustKey(BOOL bSet)
{
    HKEY  hKey;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, RK_TRUSTKEY, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (bSet)
        {
            for (int i=0; i < countof(s_tkTrustArray); i++)
            {
                if (s_tkTrustArray[i].fSet)
                    RegSetValueEx( hKey, s_tkTrustArray[i].szTrustString, 0, REG_SZ,
                    (LPBYTE)s_tkTrustArray[i].szCompanyName, sizeof(s_tkTrustArray[i].szCompanyName) );
            }
        }
        else
        {
            for (int i=0; i < countof(s_tkTrustArray); i++)
            {
                if (s_tkTrustArray[i].fSet)
                    RegDeleteValue( hKey, s_tkTrustArray[i].szTrustString );
            }
        }
        RegCloseKey(hKey);
    }
}


void AnyCompSelected(HWND hDlg, BOOL &fSel, BOOL &fSizeChange)  //---- Blue and Brown components change size, and
{                                                               //     need to know to grey out synchronize button
    HWND hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    fSel           = FALSE;
    fSizeChange    = FALSE;

    PCOMPONENT pComp;

    for (pComp = g_paComp; ; pComp++ )
    {
        if (!pComp || (!(*pComp->szSection))) break;
        if (ListView_GetItemState(hCompList, pComp->iList, LVIS_SELECTED) & LVIS_SELECTED)
            if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage))
                fSizeChange = TRUE;
            else
                fSel = TRUE;
    }
}

BOOL AnyCompSelected(HWND hDlg)
{

    HWND hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    
    PCOMPONENT pComp;

    for (pComp = g_paComp; ; pComp++ )
    {
        if (!pComp || (!(*pComp->szSection))) break;
        if ((BLUE2 != pComp->iImage) && (BROWN2 != pComp->iImage))
            if (ListView_GetItemState(hCompList, pComp->iList, LVIS_SELECTED) & LVIS_SELECTED)
                return TRUE;
    }
    return FALSE;
}

void WriteModesToCif(CCifRWComponent_t * pCifRWComponent_t, LPCTSTR pcszModes)
{
    int i;
    TCHAR szCommaModes[32];

    if (pcszModes == NULL || ISNULL(pcszModes))
        szCommaModes[0] = TEXT('\0');
    else
    {
        for (i = 0; pcszModes[i]; i++)
        {
            szCommaModes[i*2] = pcszModes[i];
            szCommaModes[(i*2)+1] = TEXT(',');
        }
        szCommaModes[(i*2)-1] = TEXT('\0');
    }

    pCifRWComponent_t->SetModes(szCommaModes);
}

void writeToCifFile(PCOMPONENT pComp, LPTSTR szCifNew)
{
    ICifRWComponent*   pCifRWComponent;
    CCifRWComponent_t* pCifRWComponent_t;
    LPTSTR             pszSection;
    DWORD              dwVer, dwBuild;

    g_lpCifRWFile->CreateComponent(pComp->szSection, &pCifRWComponent);
    pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
    pCifRWComponent_t->CopyComponent(szCifNew);
    WriteModesToCif(pCifRWComponent_t, pComp->szModes);
    delete pCifRWComponent_t;
    g_lpCifRWFileVer->CreateComponent(pComp->szSection, &pCifRWComponent);
    pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
    pCifRWComponent_t->CopyComponent(szCifNew);
    pCifRWComponent_t->GetVersion(&dwVer, &dwBuild);
    delete pCifRWComponent_t;
    ConvertDwordsToVersionStr(pComp->szVersion, dwVer, dwBuild);

    pszSection = pComp->pszAVSDupeSections;

    while (pszSection != NULL)
    {
        if ((pComp = FindComp(pszSection, FALSE)) != NULL)
        {
            g_lpCifRWFile->CreateComponent(pComp->szSection, &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->CopyComponent(szCifNew);
            WriteModesToCif(pCifRWComponent_t, pComp->szModes);
            delete pCifRWComponent_t;
            g_lpCifRWFileVer->CreateComponent(pComp->szSection, &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->CopyComponent(szCifNew);
            pCifRWComponent_t->GetVersion(&dwVer, &dwBuild);
            delete pCifRWComponent_t;
            ConvertDwordsToVersionStr(pComp->szVersion, dwVer, dwBuild);
        }

        pszSection = StrChr(pszSection, TEXT(','));
        if (pszSection != NULL)
            pszSection++;
    }
}

void updateCifVersions32(PCOMPONENT pComp, BOOL fIgnore, BOOL fUpdate)
{
    TCHAR szCifPath[MAX_PATH];
    
    if ((!fUpdate) && (BLUE2 != pComp->iImage) && (BROWN2 != pComp->iImage))
        if (fIgnore)
            pComp->iImage = YELLOW;
        else
            pComp->iImage = GREEN;

        //---- use other ieupdate.cif for updates
    if ((fUpdate) || (BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage)) {
        PathCombine(szCifPath, g_szIEAKProg, TEXT("update\\ieupdate.cif"));
        writeToCifFile(pComp, szCifPath);
    }
    else
        writeToCifFile(pComp, s_szCifNew);
}

static s_fNoToAllSynch;

void DownloadComponent32(HWND hDlg, PCOMPONENT pComp, HWND hCompList, BOOL &g_fCancelled,
                         BOOL &fOk, BOOL &fDownloaded, BOOL &fIgnore, BOOL fAll)
{
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szCompUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szLocalPath[MAX_PATH];
    TCHAR szUpdateCif[MAX_PATH];
    LPTSTR pCab;
    LV_ITEM lvItem;
    CCifFile_t*     pCifFile = NULL;
    ICifComponent * pCifComponent = NULL;
    CCifComponent_t * pCifComponent_t;
    UINT uiIndex = 0;
    DWORD dwFlags;
    TCHAR tchType = '\0';
    int iRet = IDYES;
    UNREFERENCED_PARAMETER(tchType);

    if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage)) {
        StrCpy(szUpdateCif, g_szIEAKProg);
        PathAppend(szUpdateCif, TEXT("\\update\\ieupdate.cif"));
        if (!PathFileExists(szUpdateCif))
            return;
        GetICifFileFromFile_t(&pCifFile, szUpdateCif);
        if (g_fCancelled || (FAILED(pCifFile->FindComponent(pComp->szSection, &pCifComponent))))
            return;
    }
    else  
        if (g_fCancelled || (FAILED(g_lpCifFileNew->FindComponent(pComp->szSection, &pCifComponent))))
            return;

    pCifComponent_t = new CCifComponent_t((ICifRWComponent *)pCifComponent);

    // pComp->fIEDependency is used as a guard against circular dependencies here
    if (!pComp->fIEDependency && !pComp->fAVSDupe)
    {
        pComp->fIEDependency = TRUE;
                           //--- now BLUE2 and BROWN2 also mean that the component has already been downloaded
        if (((pComp->iImage != GREEN) && (pComp->iImage != BLUE2) && (pComp->iImage != BROWN2)) || 
            (!fAll && !s_fNoToAllSynch && (( iRet = (int) DialogBoxParam(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_DUPESYNCH),
            s_hStat, DupeSynchDlgProc, (LPARAM)pComp->szDisplayName)) == IDYES)))
        {
            while (SUCCEEDED(pCifComponent_t->GetUrl(uiIndex, szUrl, countof(szUrl), &dwFlags)))
            {
                if (dwFlags & URLF_RELATIVEURL)
                {
                    StrCpy(szCompUrl, g_szBaseURL);
                    StrCat(szCompUrl, TEXT("/"));
                    StrCat(szCompUrl, szUrl);
                    pCab = szUrl;
                }
                else
                {
                    StrCpy(szCompUrl, szUrl);
                    pCab = StrRChr(szUrl, NULL, TEXT('/'));
                    if (pCab)
                        pCab++;
                    else
                        pCab = szUrl;
                }
                PathCombine(szLocalPath, g_szIEAKProg, pCab);
                if (pComp->dwSize)
                {
                    if(StrCmpI(pCab, TEXT("oem.cab"))) //special case out the OEMInstall cab
                    {
                        if (DownloadCab(s_hStat, szCompUrl, szLocalPath, pComp->szDisplayName, pComp->dwSize, fIgnore)
                            != NOERROR)
                        {
                            fOk = FALSE;
                            g_fCancelled = TRUE;
                        }
                        else
                            if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage)) {
                                pComp->iImage = GREEN;
                                updateCifVersions32(pComp, fIgnore);
                            }
                        fDownloaded = TRUE;
                    }
                }
                if (g_fCancelled) break;
                uiIndex++;
            }
        }
        else  //we are not downloading this cab because it's already downloaded
        {
            //process window messages, so we pick up messages like cancel for download status popup
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (iRet == IDIGNORE)
            s_fNoToAllSynch = TRUE;

        if (!g_fCancelled)
        {
            if (fIgnore)
                    pComp->iImage = YELLOW;
            else
                if ((BLUE2 != pComp->iImage) && (BROWN2 != pComp->iImage))
                    pComp->iImage = GREEN;

            uiIndex = 0;

            while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szLocalPath, countof(szLocalPath), &tchType, NULL, NULL)))
            {
                PCOMPONENT pDepComp;

                pDepComp = FindComp(szLocalPath, FALSE);

                if (pDepComp && (pDepComp->iCompType == COMP_OPTIONAL))
                {
                    DownloadComponent32(hDlg, pDepComp, hCompList, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);
                    if (g_fCancelled)
                        break;
                }
                uiIndex++;
            }
        }

        if (g_fCancelled)
        {
            pComp->iImage = RED;

            if ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iPlatform <= PLAT_W98)
                && pComp->fVisible)
            {
                ZeroMemory(&lvItem, sizeof(lvItem));
                lvItem.mask = LVIF_IMAGE;
                lvItem.iItem = pComp->iList;
                ListView_GetItem(hCompList, &lvItem);

                lvItem.iImage = RED;
                lvItem.mask = LVIF_IMAGE;
                lvItem.iItem = pComp->iList;
                ListView_SetItem(hCompList, &lvItem);
                ListView_SetItemText(hCompList, pComp->iList, 1, TEXT(""));
            }

            if (SUCCEEDED(pCifComponent_t->GetUrl(0, szUrl, countof(szUrl), &dwFlags)))
            {
                if (dwFlags & URLF_RELATIVEURL)
                {
                    pCab = szUrl;
                }
                else
                {
                    pCab = StrRChr(szUrl, NULL, TEXT('/'));
                    if (pCab)
                        pCab++;
                    else
                        pCab = szUrl;
                }
                PathCombine(szLocalPath, g_szIEAKProg, pCab);
                DeleteFile(szLocalPath);
            }
            return;
        }

        updateCifVersions32(pComp, fIgnore);

        if (pComp->fVisible && ((pComp->iCompType != COMP_OPTIONAL) || (pComp->iPlatform <= PLAT_W98)))
        {
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_IMAGE;
            lvItem.iItem = pComp->iList;
            ListView_GetItem(hCompList, &lvItem);

            if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage))
                lvItem.iImage = pComp->iImage;
            else
                if (fIgnore)
                    lvItem.iImage = YELLOW;
                else
                    lvItem.iImage = GREEN;
            lvItem.mask = LVIF_IMAGE;
            lvItem.iItem = pComp->iList;
            ListView_SetItem(hCompList, &lvItem);
            ListView_SetItemText(hCompList, pComp->iList, 1, pComp->szVersion);
        }
    }

    delete pCifComponent_t;
}

void DownloadComponent(HWND hDlg, PCOMPONENT pComp, HWND hCompList, BOOL &g_fCancelled,
                       BOOL &fOk, BOOL &fDownloaded, BOOL &fIgnore, BOOL fAll)
{
    PCOMPONENT pCompTemp;
    for (pCompTemp = g_paComp; *pCompTemp->szSection; pCompTemp++)
        pCompTemp->fIEDependency = FALSE;
    DownloadComponent32(hDlg, pComp, hCompList, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);
}

BOOL IsCheyenneSoftwareRunning(HWND hDlg)
{
    if (FindWindow(NULL, TEXT("Inoculan Realtime Manager")) ||
        FindWindow(NULL, TEXT("Cheyenne ANtiVirus Realtime Monitor")))
    {
        TCHAR szMsgBoxText[MAX_PATH];

        LoadString( g_rvInfo.hInst, IDS_VIRUSPROGRAMRUNNING, szMsgBoxText, countof(szMsgBoxText) );
        MessageBox(hDlg, szMsgBoxText, g_szTitle, MB_OK);
        return TRUE;
    }

    return FALSE;
}

void ProcessDownload(HWND hDlg, BOOL fAll)
{
    HWND hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    TCHAR szWrk[MAX_PATH];
    PCOMPONENT pComp;
    BOOL fDownloaded;
    BOOL fIgnore = FALSE;

    if (IsCheyenneSoftwareRunning(hDlg))
        return;

    g_fCancelled = FALSE;
    s_fComponent = TRUE;
    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    s_hStat = CreateDialog( g_rvInfo.hInst,  MAKEINTRESOURCE(IDD_DOWNLOAD), NULL,
        DownloadStatusDlgProc );
    ShowWindow( s_hStat, SW_SHOWNORMAL );
    g_fFailedComp = FALSE;
    LoadString( g_rvInfo.hInst, IDS_DOWNLOADLIST_ERROR, g_szFailedCompsMsg, countof(g_szFailedCompsMsg) );
    for (pComp = g_paComp; ; pComp++ )
        if ((BROWN2 != pComp->iImage) && (BLUE2 != pComp->iImage))
        {
            LV_ITEM lvItem;
            BOOL fOk = TRUE;
            DWORD dwDestFree;
            PCOMPONENT pSearchComp;
            fDownloaded = FALSE;
            ZeroMemory(&lvItem,sizeof(lvItem));
            if (ISNULL(pComp->szSection)) break;
            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
            lvItem.stateMask = LVIS_SELECTED;
            lvItem.iItem = pComp->iList;
            ListView_GetItem(hCompList, &lvItem);
            if (!fAll)
            {
                if ((pComp->iList == 0) && (pComp->iCompType == COMP_OPTIONAL)) continue;
                if ((lvItem.state & LVIS_SELECTED) == 0)  continue;
            }
    // BUGBUG fix once we do Alpha version
            if (pComp->iPlatform == PLAT_ALPHA) continue;
            SetDlgItemText( s_hStat, IDC_DOWNCOMPNAMD, pComp->szDisplayName );
            g_nTotDown = 0;
            StrCpy(szWrk, g_szIEAKProg);
            dwDestFree = GetRootFree(szWrk);
            if (dwDestFree < pComp->dwSize)
            {
                TCHAR szTitle[MAX_PATH];
                TCHAR szTemplate[MAX_PATH];
                TCHAR szMsg[MAX_PATH];
                LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
                LoadString( g_rvInfo.hInst, IDS_TEMPDISKMSG, szTemplate, MAX_PATH );
                wnsprintf(szMsg, countof(szMsg), szTemplate, dwDestFree, (pComp->dwSize));
                MessageBox(NULL, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
                DestroyWindow(s_hStat);
                return;
            }

            fIgnore = FALSE;
            DownloadComponent(hDlg, pComp, hCompList, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);
    /*
            if (*(pComp->piPatchInfo.szSection))   // download patch files
            {
                DownloadComponent(pComp->piPatchInfo.szSection, pComp->szDisplayName, pComp->piPatchInfo.dwSize, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);

                if (fOk)
                {
                    TCHAR szSectBuf[1024];

                    GetPrivateProfileSection( pComp->piPatchInfo.szSection, szSectBuf, countof(szSectBuf), s_szCifNew );
                    WritePrivateProfileSection( pComp->piPatchInfo.szSection, szSectBuf, g_szCif );
                }
            }
    */
            if (!fAll && fDownloaded && !g_fCancelled && (pComp->iCompType == COMP_OPTIONAL))
            {
                // search to download comp on other platforms
                for (pSearchComp = g_paComp; ; pSearchComp++)
                {
                    if (ISNULL(pSearchComp->szSection)) break;
                    if ((StrCmpI(pSearchComp->szDisplayName, pComp->szDisplayName) == 0)
                        && (pSearchComp != pComp))
                    {
                        SetDlgItemText( s_hStat, IDC_DOWNCOMPNAMD, pSearchComp->szDisplayName );
                        g_nTotDown = 0;
                        StrCpy(szWrk, g_szIEAKProg);
                        dwDestFree = GetRootFree(szWrk);
                        if (dwDestFree < pSearchComp->dwSize)
                        {
                            TCHAR szTitle[MAX_PATH];
                            TCHAR szTemplate[MAX_PATH];
                            TCHAR szMsg[MAX_PATH];
                            LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
                            LoadString( g_rvInfo.hInst, IDS_TEMPDISKMSG, szTemplate, MAX_PATH );
                            wnsprintf(szMsg, countof(szMsg), szTemplate, dwDestFree, (pSearchComp->dwSize));
                            MessageBox(NULL, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
                            DestroyWindow(s_hStat);
                            return;
                        }
                        DownloadComponent(hDlg, pSearchComp, hCompList, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);

                        if (g_fCancelled) break;
                  /*      if (*(pSearchComp->piPatchInfo.szSection))   // download patch files
                        {
                            DownloadComponent(pSearchComp->piPatchInfo.szSection, pSearchComp->szDisplayName,
                                pSearchComp->piPatchInfo.dwSize, g_fCancelled, fOk, fDownloaded, fIgnore);

                            if (fOk)
                            {
                                TCHAR szSectBuf[1024];

                                GetPrivateProfileSection( pSearchComp->piPatchInfo.szSection, szSectBuf, countof(szSectBuf), s_szCifNew );
                                WritePrivateProfileSection( pSearchComp->piPatchInfo.szSection, szSectBuf, g_szCif );
                            }
                        }*/

                        if (g_fCancelled) break;

                        if (fOk)
                            updateCifVersions32(pSearchComp, fIgnore);
                    }
                }
            }

            if (fOk && !g_fCancelled)
            {
                PCOMPONENT pListComp = pComp;

                if (pComp->iCompType != COMP_OPTIONAL)
                {
                    s_fNoCore = FALSE;
                    pListComp = FindComp(NULL, TRUE);
                }
                if (fIgnore)
                    lvItem.iImage = pComp->iImage = YELLOW;
                else
                    if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage))
                        lvItem.iImage = pComp->iImage;
                    else
                        lvItem.iImage = pComp->iImage = GREEN;
                lvItem.mask = LVIF_IMAGE;
                lvItem.iItem = pListComp->iList;
                ListView_SetItem(hCompList, &lvItem);

                updateCifVersions32(pComp, fIgnore);

                // Do not try to set the version field for NT optional components or invisible
                // components for win32 since their iList fields will be zeroed

                if (((pComp->fVisible || (StrCmpI(pComp->szSection, BASEWIN32) == 0)) &&
                    ((pComp->iCompType != COMP_OPTIONAL) || (pComp->iPlatform <= PLAT_W98))))
                    ListView_SetItemText(hCompList, pListComp->iList, 1, pListComp->szVersion);
            }
            else
            {
                TCHAR szUrl[MAX_PATH];
                LPTSTR pUrl = szUrl;
                TCHAR szLocalPath[MAX_PATH];
                ICifComponent * pCifComponent;
                CCifComponent_t * pCifComponent_t;
                HRESULT hr;
                DWORD dwFlags;

                if (pComp->iCompType != COMP_OPTIONAL)
                {
                    s_fNoCore = TRUE;
                    pComp = FindComp(NULL, TRUE);
                }
                if ((pComp->iImage != BROWN2) && (pComp->iImage != BLUE2)) {
                    lvItem.iImage = pComp->iImage = RED;
                    lvItem.mask = LVIF_IMAGE;
                    lvItem.iItem = pComp->iList;
                    ListView_SetItem(hCompList, &lvItem);
                    ListView_SetItemText(hCompList, pComp->iList, 1, TEXT(""));
                }

                if (!(SUCCEEDED(g_lpCifFileNew->FindComponent(pComp->szSection, &pCifComponent))))
                    break;

                pCifComponent_t = new CCifComponent_t((ICifRWComponent *)pCifComponent);
                hr = pCifComponent_t->GetUrl(0, szUrl, countof(szUrl), &dwFlags);
                delete pCifComponent_t;

                if (!(SUCCEEDED(hr)))
                    break;

                if (!(dwFlags & URLF_RELATIVEURL))
                {
                    pUrl = StrRChr(szUrl, NULL, TEXT('/'));
                    if (pUrl)
                        pUrl++;
                    else
                        pUrl = szUrl;
                }
            
                PathCombine(szLocalPath, g_szIEAKProg, pUrl);
                DeleteFile(szLocalPath);
                break;
            }

        }
    DestroyWindow(s_hStat);
}

void SetCompRevDependList(PCOMPONENT pComp, CCifComponent_t * pCifComponent_t)
{
    UINT uiIndex = 0;
    PCOMPONENT pCompTemp;
    ICifComponent * pCifCompNew;
    TCHAR szID[128];
    TCHAR tchType;

    while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szID, countof(szID), &tchType, NULL, NULL)))
    {
        if ((pComp->iCompType != COMP_OPTIONAL) ||
            (StrCmpNI(szID, TEXT("BASEIE40"), 8) == 0))
        {
            uiIndex++;
            continue;
        }

        pCompTemp = FindComp(szID, FALSE);

        if (pCompTemp)
        {
            int i;
            BOOL fSet = FALSE;

            if (pCompTemp->fIEDependency)
            {
                uiIndex++;
                continue;
            }

            pCompTemp->fIEDependency = TRUE;

            for (i=0; (i < 10) && pCompTemp->paCompRevDeps[i]; i++)
            {
                if (pCompTemp->paCompRevDeps[i] == pComp)
                    fSet = TRUE;
            }

            if (!fSet && i < 10)
                pCompTemp->paCompRevDeps[i] = pComp;

        }
        if (SUCCEEDED(g_lpCifFileNew->FindComponent(szID, &pCifCompNew)))
        {
            CCifComponent_t * pCifCompNew_t =
                new CCifComponent_t((ICifRWComponent *)pCifCompNew);

            SetCompRevDependList(pComp, pCifCompNew_t);
            delete pCifCompNew_t;
        }
        uiIndex++;
    }
}

void BuildReverseDependencyList(IEnumCifComponents * pEnumCifComponents)
{
    PCOMPONENT pComp;
    ICifComponent * pCifComponent;
    TCHAR szID[128];

    while (pEnumCifComponents->Next(&pCifComponent) == S_OK)
    {
        CCifComponent_t * pCifComponent_t =
            new CCifComponent_t((ICifRWComponent *)pCifComponent);

        pCifComponent_t->GetID(szID, countof(szID));
        pComp = FindComp(szID, FALSE);
        if (pComp)
        {
            PCOMPONENT pCompTemp;

            for (pCompTemp = g_paComp; *pCompTemp->szSection; pCompTemp++)
                pCompTemp->fIEDependency = FALSE;
            pComp->fIEDependency = TRUE;
            SetCompRevDependList(pComp, pCifComponent_t);
        }
        delete pCifComponent_t;
    }
}

void GetUpdateSite() {
    TCHAR             szLang[8], szURL[MAX_URL], szMsg[MAX_PATH];
    CHAR              szSiteDataA[MAX_PATH];
    int               i, j;
    DWORD             dwErr;
    IDownloadSiteMgr* pSiteMgr = NULL;
    IDownloadSite*    pISite   = NULL;
    DOWNLOADSITE*     pSite;

    LoadString(g_rvInfo.hInst, IDS_AVSUPDATEINITFAIL, szMsg, countof(szMsg));
          
    for (j=0; s_szSiteData[j]; j++);
    for (i=j; (i>0) && ('/' != s_szSiteData[i]); i--);
    StrNCpy(g_szUpdateData, (LPCWSTR) s_szSiteData, i+1); 
          
    StrCat(g_szUpdateData, TEXT("/IEUPDATE.DAT"));    

    dwErr = CoCreateInstance(CLSID_DownloadSiteMgr, NULL, CLSCTX_INPROC_SERVER,
                      IID_IDownloadSiteMgr, (void **) &pSiteMgr);

    do {
        dwErr = pSiteMgr->Initialize(T2Abux(g_szUpdateData, szSiteDataA),  NULL);
    }
    while ((dwErr != NOERROR) && (MessageBox(g_hDlg, szMsg, g_szTitle, MB_RETRYCANCEL) == IDRETRY));

    for (i=0; i<NUMSITES; i++) {
        pSiteMgr->EnumSites(i, &pISite);
        if (!pISite) break;
        pISite->GetData(&pSite);
        A2Tbux(pSite->pszLang, szLang);
        if (0 == StrCmpI(szLang, g_szActLang)) {
            A2Tbux(pSite->pszUrl, szURL);
            StrCpy(g_szUpdateURL, szURL);
            break;
        }
    }
    if (pSiteMgr)
        pSiteMgr->Release();
    if (pISite)
        pISite->Release();
}

DWORD InitOptComponents32(LPVOID)
{
    HWND hDlg = g_hWizard;
    int iItem = 0;
    HWND hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    LV_ITEM lvItemMessage;
    TCHAR szBuf[8];
    DWORD dwType;
    HRESULT hr;
    PCOMPONENT pComp;
    PCOMP_VERSION pCompVer;
    BOOL fNeedCore = TRUE;
    TCHAR szCifName[32];
    TCHAR * lpszProgressMsg;

    CoInitialize(NULL);
    lpszProgressMsg=(TCHAR *) LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));

    ResetEvent(g_hCifEvent);
    NeedToSetMSTrustKey();
    WriteMSTrustKey(TRUE);      // Mark MS as a trusted provider

	if(!g_fOCW)
    {
        CreateDirectory( g_szIEAKProg, NULL );
    }
    StrCpy(szCifName, TEXT("IESetup.CIF"));
    PathCombine(g_szCif, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCif, GetOutputPlatformDir());
    PathAppend(g_szCif, g_szLanguage);
    PathAppend(g_szCif, szCifName);

    s_dwTotalSize = 0;
    ListView_DeleteAllItems(hCompList);
    ListView_DeleteColumn(hCompList, 1);
    ListView_DeleteColumn(hCompList, 0);
    s_fNoCore = FALSE;

    InitAVSListView(hCompList);      //----- assign image list and create columns
 
    LoadString(g_rvInfo.hInst,IDS_COMPINITDOWNLOAD,lpszProgressMsg,MAX_PATH);

    ZeroMemory(&lvItemMessage, sizeof(lvItemMessage));
    lvItemMessage.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItemMessage.iItem = iItem;
    lvItemMessage.pszText = lpszProgressMsg;
    lvItemMessage.iImage = YELLOW;
    ListView_InsertItem(hCompList, &lvItemMessage);

    StrCpy(szBuf, g_szLanguage + 1);
    szBuf[lstrlen(szBuf) - 1] = 0;
    StrCpy(s_szCifCabURL, g_szBaseURL);
    StrCat(s_szCifCabURL, TEXT("/IECIF.CAB"));
    StrCpy(g_szCifVer, g_szIEAKProg);
    PathAppend(g_szCifVer, TEXT("IEsetup.cif"));
    StrCpy(s_szCifNew, g_szIEAKProg);
    PathAppend(s_szCifNew, TEXT("new"));
    CreateDirectory( s_szCifNew, NULL );
    PathAppend(s_szCifNew, TEXT("IEsetup.cif"));

    if ((!s_fNoNet)&&(!g_fLocalMode))
    {
        BOOL fIgnore = FALSE;
        TCHAR szCifCabDest[MAX_PATH * 4];  //part of fix for bug 13454--trap on long file path.  Rest of fix is not to allow ridiculous paths.  

        if (g_fBatch2)
        {
            //batch2 mode we don't download the cab, we copy the cif.
            PathCombine(s_szCifCabURL, g_szBaseURL, TEXT("INS"));
            PathAppend(s_szCifCabURL, GetOutputPlatformDir());
            PathAppend(s_szCifCabURL, g_szLanguage);
            PathAppend(s_szCifCabURL, szCifName);
            PathCombine(szCifCabDest, g_szIEAKProg, TEXT("new\\IEsetup.cif"));
            if (CopyFile(s_szCifCabURL, szCifCabDest, FALSE))
                hr = NOERROR;
            else
                hr = -1;
        }
        else
        {
            if (!PathCombine(szCifCabDest, g_szIEAKProg, TEXT("new\\IECIF.CAB")))
            {
                //error in path combine, probably due to overly long path on win98
                //user can't continue

                ErrorMessageBox(hDlg, IDS_ERR_PATH);
                ListView_DeleteItem(hCompList, iItem);
                LocalFree(lpszProgressMsg);
                SetEvent(g_hCifEvent);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
                g_fOptCompInit = TRUE;
                s_fNoCore = TRUE;
                CoUninitialize();
                return(0);
            }
            hr = DownloadCab(hDlg, s_szCifCabURL, szCifCabDest, NULL, 0, fIgnore);
            if (hr == NOERROR)
            {
                TCHAR szCifCabFilesDest[MAX_PATH * 4];

                PathCombine(szCifCabFilesDest, g_szIEAKProg, TEXT("new"));
                hr = ExtractFilesWrap(szCifCabDest, szCifCabFilesDest, 0, NULL, NULL, 0);
            }
        }

        if (hr != NOERROR)
        {
            if (!PathFileExists(g_szCifVer))
            {
                ListView_DeleteItem(hCompList, iItem);
                LocalFree(lpszProgressMsg);
                SetEvent(g_hCifEvent);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
                g_fOptCompInit = TRUE;
                s_fNoCore = TRUE;
                CoUninitialize();
                return(0);
            }
            s_fNoNet = TRUE;
            g_fLocalMode = TRUE;
        }
    }
    if (!PathFileExists(g_szCifVer))
    {
        TCHAR szVerCifCab[MAX_PATH* 4];

        PathCombine(szVerCifCab, g_szIEAKProg, TEXT("IECIF.CAB"));

        // if there is an iecif.cab in the source dir then extract the cif and assume it's valid

        if (!PathFileExists(szVerCifCab) ||
            (ExtractFilesWrap(szVerCifCab, g_szIEAKProg, 0, NULL, NULL, 0) != NOERROR))
        {
            TCHAR szTemp[MAX_PATH* 4];
            WIN32_FIND_DATA fd;
            HANDLE hFind;

            PathCombine(szTemp, g_szIEAKProg, TEXT("*.cab"));

            if ((hFind = FindFirstFile(szTemp, &fd)) != INVALID_HANDLE_VALUE)
            {
                // delete all files in download directory if no versioning cif found, this is for
                // overinstalls

                LoadString(g_rvInfo.hInst, IDS_OLD_CABS, szTemp, countof(szTemp));

                FindClose(hFind);

                if (MessageBox(hDlg, szTemp, g_szTitle, MB_YESNO) == IDYES)
                {
                    PathRemovePath(g_szIEAKProg, ADN_DONT_DEL_SUBDIRS);
                }
                else
                {
                    ListView_DeleteItem(hCompList, iItem);
                    LocalFree(lpszProgressMsg);
                    SetEvent(g_hCifEvent);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                    PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
                    g_fOptCompInit = g_fLocalMode = TRUE;
                    s_fNoCore = TRUE;
                    CoUninitialize();
                    return(0);
                }
            }
            CopyFile(s_szCifNew, g_szCifVer, FALSE);
        }
    }
    if (!PathFileExists(g_szCif))
        CopyFile(g_szCifVer, g_szCif, FALSE);

    if (s_fNoNet||g_fLocalMode)
        StrCpy(s_szCifNew, g_szCifVer);

    ListView_DeleteItem(hCompList, iItem);

    LoadString(g_rvInfo.hInst,IDS_COMPINITPROCESSING,lpszProgressMsg,MAX_PATH);
    lvItemMessage.pszText = lpszProgressMsg;
    ListView_InsertItem(hCompList, &lvItemMessage);

    // create our cif objects

    if (g_lpCifFileNew)
    {
        delete g_lpCifFileNew;
        g_lpCifFileNew = NULL;
    }
    hr = GetICifFileFromFile_t(&g_lpCifFileNew, s_szCifNew);

    if (SUCCEEDED(hr))
    {
        if (g_lpCifRWFile)
        {
            delete g_lpCifRWFile;
            g_lpCifRWFile = NULL;
        }
        hr = GetICifRWFileFromFile_t(&g_lpCifRWFile, g_szCif);
        if (SUCCEEDED(hr))
        {
            if (g_lpCifRWFileVer)
            {
                delete g_lpCifRWFileVer;
                g_lpCifRWFileVer = NULL;
            }
            hr = GetICifRWFileFromFile_t(&g_lpCifRWFileVer, g_szCifVer);
        }
    }

    SetEvent(g_hCifEvent);

    // wait for the opt cab download attempt so we can block if there were problems

    while (MsgWaitForMultipleObjects(1, &g_hProcessInfEvent, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        MSG msg;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if (!PathFileExists(g_szMastInf)) // if iesetup.inf doesn't exist in the opt dir, then it
    {                                 // means the opt cab was not downloaded/extracted successfully
        // we should not let the user continue
        ErrorMessageBox(hDlg, IDS_OPTCAB_ERROR);
        ListView_DeleteItem(hCompList, iItem);
        LocalFree(lpszProgressMsg);
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
        PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
        g_fOptCompInit = g_fLocalMode = TRUE;
        s_fNoCore = TRUE;
        CoUninitialize();
        return(0);
    }

    ListView_DeleteItem(hCompList, iItem);

    if (SUCCEEDED(hr))
    {
        IEnumCifComponents *pEnumCifComponents = NULL;
        ICifRWComponent * pCifRWComponent;
        ICifComponent *pCifComponent = NULL;

        if (SUCCEEDED(hr))
        {
            // currently not showing alpha comps

            hr = g_lpCifFileNew->EnumComponents(&pEnumCifComponents,
                PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL);

            if (0 != g_uiNumCabs)
                g_uiNumCabs = 0;
            
            while (pEnumCifComponents->Next(&pCifComponent) == S_OK)
                g_uiNumCabs++;

            //bug 17727: we need to allocate enough memory to hold the updated components as well, which is
            //why there is so much extra

            pComp=g_paComp=(PCOMPONENT) LocalAlloc(LPTR, ((g_uiNumCabs*3) + 100) * sizeof(COMPONENT));  
            pCompVer=g_rgCompVer=(PCOMP_VERSION) LocalAlloc(LPTR, ((g_uiNumCabs*3) + 100) * sizeof(COMP_VERSION));

            iItem=0; //reset iItem for filling in the list box

            pEnumCifComponents->Reset();

            while(pEnumCifComponents->Next(&pCifComponent) == S_OK)
            {
                ICifComponent * pCifComponentTemp;
                TCHAR szVerNew[32];
                TCHAR szPatchVerNew[32];
                TCHAR szIEAKVer[32] = TEXT("");
                TCHAR szIEAKVerNew[32];
                TCHAR szCustData[MAX_PATH];
                TCHAR szID[128];
                TCHAR szMode[MAX_PATH];
                UINT uiIndex;
                DWORD dwVer, dwBuild, dwPlatform;
                CCifComponent_t * pCifComponent_t =
                    new CCifComponent_t((ICifRWComponent *)pCifComponent);

                // ignore components that aren't in a group

                if (FAILED(pCifComponent_t->GetGroup(szID, countof(szID))))
                {
                    delete pCifComponent_t;
                    g_uiNumCabs--;
                    continue;
                }

                pComp->fVisible = (pCifComponent_t->IsUIVisible() == S_FALSE) ? FALSE : TRUE;

                dwPlatform = pCifComponent_t->GetPlatform();

                if (dwPlatform & PLATFORM_WIN98)
                {
                    if (dwPlatform & PLATFORM_NT4)
                        pComp->iPlatform = PLAT_I386;
                    else
                        pComp->iPlatform = PLAT_W98;
                }
                else
                    pComp->iPlatform = PLAT_NTx86;

                pCifComponent_t->GetID(szID, countof(szID));

                StrCpy(pCompVer->szID, szID);

                // do not read in the branding.cab entry for microsoft.com

                if (StrCmpI(szID, TEXT("BRANDING.CAB")) == 0)
                {
                    ZeroMemory(pComp, sizeof(COMPONENT));
                    delete pCifComponent_t;
                    g_uiNumCabs--;
                    continue;
                }


                // do not read in exluded components in all modes(128Update) or
                // ISP excluded components(IE4SHELL) or corp excluded comps

                if (((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKExclude"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1'))) ||
                    (!g_fIntranet && (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKISPExclude"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1'))) ||
                    (g_fIntranet && (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKCorpExclude"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1'))))
                {
                    ZeroMemory(pComp, sizeof(COMPONENT));
                    delete pCifComponent_t;
                    continue;
                }

                // add on only components or IEAK show only components

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("AddOnOnly"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                {
                    pComp->fAddOnOnly = TRUE;
                    pComp->fVisible = TRUE;
                }

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKVisible"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                    pComp->fVisible = TRUE;


                pCifComponent_t->GetCustomData(TEXT("IEAKVersion"), szIEAKVerNew, countof(szIEAKVerNew));

                if (SUCCEEDED(g_lpCifRWFileVer->FindComponent(szID, &pCifComponentTemp)))
                {
                    CCifComponent_t * pCifComponentTemp_t =
                        new CCifComponent_t((ICifRWComponent *)pCifComponentTemp);

                    pCifComponentTemp_t->GetVersion(&dwVer, &dwBuild);
                    ConvertDwordsToVersionStr(pComp->szVersion, dwVer, dwBuild);
                    pCifComponentTemp_t->GetCustomData(TEXT("IEAKVersion"), szIEAKVer, countof(szIEAKVer));
                }
                pCifComponent_t->GetVersion(&dwVer, &dwBuild);
                ConvertDwordsToVersionStr(szVerNew, dwVer, dwBuild);

                StrCpy(pCompVer->szVersion, szVerNew);
               
                uiIndex = 0;

                szMode[0] = TEXT('\0');
                if (SUCCEEDED(g_lpCifRWFile->FindComponent(szID, &pCifComponentTemp)))
                {
                    CCifComponent_t * pCifComponentTemp_t =
                        new CCifComponent_t((ICifRWComponent *)pCifComponentTemp);
                    while (SUCCEEDED(pCifComponentTemp_t->GetMode(uiIndex, szMode, countof(szMode))))
                    {
                        pComp->szModes[uiIndex] = szMode[0];
                        pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
                        uiIndex++;
                    }
                    delete pCifComponentTemp_t;
                }
                else
                {
                    while (SUCCEEDED(pCifComponent_t->GetMode(uiIndex, szMode, countof(szMode))))
                    {
                        pComp->szModes[uiIndex] = szMode[0];
                        pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
                        uiIndex++;
                    }
                }

                pComp->szModes[uiIndex] = TEXT('\0');

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKCore"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                {
                    pComp->iCompType = COMP_CORE;
                    pComp->fVisible = FALSE;
                }

                // pick up special core comps for OCW

                if (g_fOCW && (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKOCWCore"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                {
                    pComp->iCompType = COMP_CORE;
                    pComp->fVisible = FALSE;
                }

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKServer"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                    pComp->iCompType = COMP_SERVER;

                // IEAK should ignore these components since they point to the same cabs as
                // another section

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKAVSIgnore"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                {
                    pComp->fAVSDupe = TRUE;
                    pComp->fVisible = FALSE;
                }

                // pick up components which point to the same cabs as this section

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKAVSLinks"), szCustData, countof(szCustData))))
                    && ISNONNULL(szCustData))
                {
                    StrRemoveWhitespace(szCustData);
                    if ((pComp->pszAVSDupeSections =
                        (LPTSTR)CoTaskMemAlloc((StrLen(szCustData)+1) * sizeof(TCHAR))) != NULL)
                        StrCpy(pComp->pszAVSDupeSections, szCustData);
                }
                else
                    pComp->pszAVSDupeSections = NULL;

                StrCpy(pComp->szSection, szID);

                if (StrCmpI(szID, TEXT("MAILNEWS")) == 0)
                    g_pMNComp = pComp;

                pCifComponent_t->GetGUID(pComp->szGUID, countof(pComp->szGUID));
                pCifComponent_t->GetDescription(pComp->szDisplayName, countof(pComp->szDisplayName));
                pCifComponent_t->GetUrl(0, pComp->szUrl, countof(pComp->szUrl), &dwType);
                if (!(dwType & URLF_RELATIVEURL))
                {
                    LPTSTR pUrl;
                    TCHAR szTempUrl[MAX_PATH];

                    pUrl = StrRChr(pComp->szUrl, NULL, TEXT('/'));
                    if (pUrl)
                        pUrl++;
                    else
                        pUrl = pComp->szUrl;

                    StrCpy(szTempUrl, pUrl);
                    StrCpy(pComp->szUrl, szTempUrl);
                }

                pComp->dwSize = pCifComponent_t->GetDownloadSize();

                if (!pComp->fAVSDupe)
                    s_dwTotalSize += pComp->dwSize;
                // take out patch processing for now

                /*
                // look for a patch entry, special case out patches from 4.0 to 4.01

                if (SUCCEEDED(pCifComponent_t->GetPatchID(pComp->piPatchInfo.szSection, countof(pComp->piPatchInfo.szSection))))
                {
                    CHAR szPatchSect[2048];
                    BOOL fBadPatch = FALSE;

                    if (GetPrivateProfileSection("Patches", szPatchSect, countof(szPatchSect), g_szDefInf))
                    {
                        LPSTR pSectID;

                        for (pSectID = szPatchSect; *pSectID; pSectID += (lstrlen(pSectID)+1))
                        {
                            if (StrCmpI(pSectID, pComp->piPatchInfo.szSection) == 0)
                            {
                                fBadPatch = TRUE;
                                break;
                            }
                        }
                    }

                    if (fBadPatch)
                    {
                        WritePrivateProfileString(pComp->piPatchInfo.szSection, NULL, NULL, g_szCif);
                        WritePrivateProfileString(pComp->piPatchInfo.szSection, NULL, NULL, s_szCifNew);
                        WritePrivateProfileString(szID, "PatchID", NULL, g_szCif);
                        WritePrivateProfileString(szID, "PatchID", NULL, s_szCifNew);
                        *pComp->piPatchInfo.szSection = '\0';
                    }
                    else
                    {
                        if (SUCCEEDED(g_lpCifFile->FindComponent(pComp->piPatchInfo.szSection, &pCifComponentTemp)))
                        {
                            pCifComponentTemp->GetVersion(&dwVer, &dwBuild);
                            ConvertDwordsToVersionStr(pComp->piPatchInfo.szVersion, dwVer, dwBuild);
                        }

                        g_lpCifFileNew->FindComponent(pComp->piPatchInfo.szSection, &pCifComponentTemp);
                        pCifComponentTemp->GetVersion(&dwVer, &dwBuild);
                        ConvertDwordsToVersionStr(szPatchVerNew, dwVer, dwBuild);
                        pComp->piPatchInfo.dwSize = pCifComponentTemp->GetDownloadSize();
                    }
                }
               */

                // Note: we are depending on the section name of core IE4 here.
                if ((fNeedCore && (StrCmpI(szID, BASEWIN32) == 0))
                    || ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iPlatform <= PLAT_W98)
                    && pComp->fVisible))
                {
                    LV_ITEM lvItem;
                    LVFINDINFO lvFind;
                    TCHAR szLocalPath[MAX_PATH];
                    if (StrCmpI(szID, BASEWIN32) == 0)
                    {
                        fNeedCore = FALSE;
                        StrCpy(g_szJobVersion, pComp->szVersion);
                    }
                    ZeroMemory(&lvItem, sizeof(lvItem));
                    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;

                    // BUGBUG: <oliverl> we should adjust iItem here to make sure core browser
                    // is always on top

                    lvItem.iItem = pComp->iList = iItem++;
                    lvItem.pszText = pComp->szDisplayName;
                    StrCpy(szLocalPath, g_szIEAKProg);
                    StrCat(szLocalPath, pComp->szUrl);

                    if (!PathFileExists(szLocalPath))
                    {
                        g_lpCifRWFile->CreateComponent(szID, &pCifRWComponent);
                        pCifRWComponent->SetGroup(NULL);
                        lvItem.iImage = pComp->iImage = RED;
                    }
                    else
                    {
                        CCifRWComponent_t * pCifRWComponent_t;

                        g_lpCifFileNew->FindComponent(szID, &pCifComponent);
                        pCifComponent_t->GetGroup(szLocalPath, countof(szLocalPath));
                        g_lpCifRWFile->CreateComponent(szID, &pCifRWComponent);
                        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
                        pCifRWComponent_t->SetGroup(szLocalPath);
                        delete pCifRWComponent_t;
                        if (s_fNoNet || g_fLocalMode || (CheckVer(pComp->szVersion, szVerNew) < 0)
                            || (CheckVer(szIEAKVer, szIEAKVerNew) < 0)
                            || ((ISNONNULL(pComp->piPatchInfo.szSection))
                            && (CheckVer(pComp->piPatchInfo.szVersion, szPatchVerNew) < 0)))
                            lvItem.iImage = pComp->iImage = YELLOW;
                        else lvItem.iImage = pComp->iImage = GREEN;
                    }

                    ZeroMemory(&lvFind, sizeof(lvFind));
                    lvFind.flags = LVFI_STRING;
                    lvFind.psz = pComp->szDisplayName;

                    if (ListView_FindItem(hCompList, -1, &lvFind) == -1)
                    {
                        ListView_InsertItem(hCompList, &lvItem);
                        if ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iImage != RED))
                            ListView_SetItemText(hCompList, pComp->iList, 1, pComp->szVersion);
                    }
                }
                else
                {
                    TCHAR szLocalPath[MAX_PATH];

                    PathCombine(szLocalPath, g_szIEAKProg, pComp->szUrl);
                    if (GetFileAttributes(szLocalPath) == 0xFFFFFFFF)
                    {
                        g_lpCifRWFile->CreateComponent(szID, &pCifRWComponent);
                        pCifRWComponent->SetGroup(NULL);
                        pComp->iImage = RED;
                    }
                    else
                    {
                        CCifRWComponent_t * pCifRWComponent_t;

                        g_lpCifFileNew->FindComponent(szID, &pCifComponent);
                        pCifComponent_t->GetGroup(szLocalPath, countof(szLocalPath));
                        g_lpCifRWFile->CreateComponent(szID, &pCifRWComponent);
                        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
                        pCifRWComponent_t->SetGroup(szLocalPath);
                        delete pCifRWComponent_t;
                        if (s_fNoNet || g_fLocalMode || (CheckVer(pComp->szVersion, szVerNew) < 0)
                            || (CheckVer(szIEAKVer, szIEAKVerNew) < 0)
                            || ((ISNONNULL(pComp->piPatchInfo.szSection))
                            && (CheckVer(pComp->piPatchInfo.szVersion, szPatchVerNew) < 0)))
                            pComp->iImage = YELLOW;
                        else pComp->iImage = GREEN;
                    }
                }

                pComp++;
                pCompVer++;
                delete pCifComponent_t;
            }

            pEnumCifComponents->Reset();
            BuildReverseDependencyList(pEnumCifComponents);
            pEnumCifComponents->Release();

            for (pComp = g_paComp; (pComp && ISNONNULL(pComp->szSection)); pComp++)
            {
                if ((pComp->iCompType != COMP_OPTIONAL) &&
                    (pComp->iImage == RED))
                    s_fNoCore = TRUE;
            }

            if (s_fNoCore)
            {
                LV_ITEM lvItem;

                lvItem.mask = LVIF_IMAGE;
                lvItem.iItem = 0;
                lvItem.iImage = RED;
                ListView_SetItem(hCompList, &lvItem);

                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            }
            else
            {
                pComp = FindComp(NULL, TRUE);

                if (pComp)
                    ListView_SetItemText(hCompList, pComp->iList, 1, pComp->szVersion);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
        }
    }
    
    ProcessUpdateIcons(hDlg);

    if (FAILED(hr))
    {
        s_fNoCore = TRUE;
        g_fLocalMode = TRUE;
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    }
    else
    {
        IEnumCifModes * pEnumCifModes;
        int i, j;

        // initialize modes

        // currently not getting alpha modes

        if (SUCCEEDED(g_lpCifRWFile->EnumModes(&pEnumCifModes,
            PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL)))
        {
            ICifMode * pCifMode;
            TCHAR szModeID[64];

            i = 0;
            while (SUCCEEDED(pEnumCifModes->Next(&pCifMode)))
            {
                CCifMode_t * pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);

                pCifMode_t->GetID(szModeID, countof(szModeID));
                delete pCifMode_t;
                g_szAllModes[i] = szModeID[0];
                i++;
            }
            pEnumCifModes->Release();
        }

        g_nModes = lstrlen(g_szAllModes);

        for (pComp = g_paComp; ; pComp++ )
        {
            if (*pComp->szSection == '\0') break;

            if (pComp->iCompType == COMP_CORE)
            {
                for (i = 0; i < g_nModes ; i++ )
                {
                    pComp->afInstall[i] = TRUE;
                }
            }
            else
            {
                for (i = 0; i < g_nModes; i++)
                {
                    for (j=0; j < lstrlen(pComp->szModes); j++)
                    {
                        if (pComp->szModes[j] == g_szAllModes[i])
                            pComp->afInstall[i] = TRUE;
                    }
                }

                // for invisible comps, set them to the same modes as the visible components
                // that depend on them

                if (!pComp->fVisible)
                {
                    for (i = 0; pComp->paCompRevDeps[i] && (i < 10); i++)
                    {
                        for (j=0; j < MAX_INSTALL_OPTS; j++)
                        {
                            if (pComp->paCompRevDeps[i]->afInstall[j])
                                pComp->afInstall[j] = TRUE;
                        }
                    }
                }
            }
        }

        InitCustComponents(NULL);
    }

    g_fOptCompInit = TRUE;

    if (!g_fLocalMode)
    {
        EnableDlgItem2(hDlg, IDC_DOWNLOAD, AnyCompSelected(hDlg));
        EnableDlgItem(hDlg, IDC_DOWNLOADALL);
        EnableDlgItem(hDlg, IDC_UPDATE);
    }

    LocalFree(lpszProgressMsg);
    PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
    CoUninitialize();
    return(0);
}

BOOL AnySelection(PCOMPONENT pComp)
{
    int i;

    if (!pComp)
        return FALSE;

    for (i = 0; i < 10 ; i++ )
    {
        if (pComp->afInstall[i]) return(TRUE);

    }
    return(FALSE);

}

DWORD GetCompDownloadSize(PCOMPONENT pComp)
{
    PCOMPONENT pCompDep;
    DWORD dwSize = 0;
    ICifComponent * pCifComponent;
    TCHAR szID[128];
    TCHAR tchType;
    UINT uiIndex;

    if (pComp->fIEDependency || pComp->fAVSDupe)
        return 0;

    pComp->fIEDependency = TRUE;

    if (SUCCEEDED(g_lpCifFileNew->FindComponent(pComp->szSection, &pCifComponent)))
    {
        CCifComponent_t * pCifComponent_t =
            new CCifComponent_t((ICifRWComponent *)pCifComponent);

        uiIndex = 0;
        while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szID, countof(szID), &tchType, NULL, NULL)))
        {
            if (StrCmpNI(szID, TEXT("BASEIE40"), 8) != 0)
            {
                if ((pCompDep = FindComp(szID, FALSE)) != NULL)
                    dwSize += GetCompDownloadSize(pCompDep);
            }
            uiIndex++;
        }
        delete pCifComponent_t;
    }

    dwSize += pComp->dwSize;
    return dwSize;
}

void GetDownloadSize(HWND hCompList, HWND hStatusField)
{
    PCOMPONENT pComp, pSearchComp;
    LV_ITEM lvItem;
    DWORD dwSizeNeeded = 0;
    TCHAR szSizeNeeded[32];
    BOOL fCore = FALSE;

    for (pComp = g_paComp; *pComp->szSection; pComp++)
    {
        ZeroMemory(&lvItem,sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
        lvItem.stateMask = LVIS_SELECTED;
        lvItem.iItem = pComp->iList;
        ListView_GetItem(hCompList, &lvItem);
        if (((lvItem.state & LVIS_SELECTED) == 0) || (pComp->fIEDependency))
            continue;

        if (!pComp->fVisible || pComp->fAVSDupe)
            continue;

        if (pComp->iCompType != COMP_OPTIONAL)
        {
            fCore = TRUE;
            continue;
        }

        // REVIEW: <oliverl> we need this check so we don't count NT comps twice
        if (pComp->iList == 0)
            continue;


        dwSizeNeeded += GetCompDownloadSize(pComp);

        // check other platforms

        for (pSearchComp = g_paComp; *pSearchComp->szSection; pSearchComp++)
        {
            if ((pComp != pSearchComp) &&
                (StrCmpI(pComp->szDisplayName, pSearchComp->szDisplayName) == 0))
                dwSizeNeeded += GetCompDownloadSize(pSearchComp);
        }
    }

    if (fCore)
    {
        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (!pComp->fIEDependency && !pComp->fAVSDupe && (pComp->iCompType != COMP_OPTIONAL))
                dwSizeNeeded += pComp->dwSize;
        }

        // REVIEW: <oliverl> fudge factor for rounding

        dwSizeNeeded += 15;
    }

    for (pComp = g_paComp; *pComp->szSection; pComp++)
        pComp->fIEDependency = FALSE;

    wnsprintf(szSizeNeeded, countof(szSizeNeeded), TEXT("%lu KB"), dwSizeNeeded);
    InsertCommas(szSizeNeeded);
    SetWindowText(hStatusField, szSizeNeeded);
}

//
//  FUNCTION: OptionalDownload(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "OptionalDownload" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//

INT_PTR CALLBACK OptionalDownload(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    static      TCHAR s_szTotalSize[32];
    TCHAR       szWrk[MAX_PATH];
    TCHAR       szFreeSpace[64];
    DWORD       dwFreeSpace;
    BOOL        fSel, fSizeChange = FALSE;
    static      HCURSOR hOldCur = NULL;
    static      s_fInit = FALSE;
    PCOMPONENT* ppCompUpdateList = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
            InitSysFont( hDlg, IDC_COMPLIST);
            g_hWizard = hDlg;
            break;

        case WM_SETCURSOR:
            if (hOldCur == NULL)
                hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
            else
            {
                if (!s_fInit)
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
            }
            break;

        case IDM_INITIALIZE:
            s_fInit = TRUE;
            // REVIEW: <oliverl> fudge factor for rounding

            s_dwTotalSize += 15;

            wnsprintf(s_szTotalSize, countof(s_szTotalSize), TEXT("%lu KB"), s_dwTotalSize);
            InsertCommas(s_szTotalSize);
            SetDlgItemText(hDlg, IDC_DISKSPACENEEDED, s_szTotalSize);
            StrCpy(szWrk, g_szIEAKProg);
            dwFreeSpace = GetRootFree(szWrk);
            wnsprintf(szFreeSpace, countof(szFreeSpace), TEXT("%lu KB"), dwFreeSpace);
            InsertCommas(szFreeSpace);
            SetDlgItemText(hDlg, IDC_DISKSPACE, szFreeSpace);
            SetCursor(hOldCur);
            while (MsgWaitForMultipleObjects(1, &g_hAVSThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
            {
                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            if (!g_fLocalMode)
            {
                s_fComponent = FALSE;
                UpdateIEAK(hDlg);
                if (g_fLocalMode)
                {
                    DisableDlgItem(hDlg, IDC_DOWNLOAD);
                    DisableDlgItem(hDlg, IDC_DOWNLOADALL);
                }
            }
            break;
            

        case IDM_BATCHADVANCE:
            EnableDlgItem2(hDlg, IDC_DOWNLOAD, AnyCompSelected(hDlg));
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    TCHAR szTitle[MAX_PATH];

                    case IDC_DOWNLOAD:
                        s_fNoToAllSynch = FALSE;
                        ProcessDownload(hDlg, FALSE);
                        if (g_fFailedComp)
                        {
                            LoadString( g_rvInfo.hInst, IDS_DOWNLOADERR, szTitle, MAX_PATH );
                            wnsprintf(g_szFailedCompsBox, countof(g_szFailedCompsBox), g_szFailedCompsMsg, g_szFailedComps);
                            MessageBox(hDlg, g_szFailedCompsBox, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
                            g_szFailedComps[0] = TEXT('\0');
                        }
                        break;
                    case IDC_DOWNLOADALL:
                        ProcessDownload(hDlg, TRUE);
                        if (g_fFailedComp)
                        {
                            LoadString( g_rvInfo.hInst, IDS_DOWNLOADERR, szTitle, MAX_PATH );
                            wnsprintf(g_szFailedCompsBox, countof(g_szFailedCompsBox), g_szFailedCompsMsg, g_szFailedComps);
                            MessageBox(hDlg, g_szFailedCompsBox, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
                            g_szFailedComps[0] = TEXT('\0');
                        }
                        break;
                    case IDC_UPDATE:
                        DisableDlgItem(hDlg, IDC_UPDATE);
                        g_hProgress = NULL;
                                                
                        PCOMPONENT *pCompList,
                                   *pCompEnum;
                        HRESULT    hr;
                        INT_PTR    iResult;

                        pCompList = NULL;
                        iResult   = DialogBoxParam(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_OPTUPDATE), hDlg,
                                                   UpdateDlgProc, (LPARAM)&pCompList);
                        if (IDOK == iResult) {
                            ASSERT(NULL != pCompList);
                            if (IsCheyenneSoftwareRunning(hDlg))
                                ErrDlgProc(hDlg, IDC_ERRDLABORT, NULL, 
                                           LPARAM(TEXT("Please turn of all Cheyenne Software")));
                            
                            s_hStat = CreateDialog( g_rvInfo.hInst,  MAKEINTRESOURCE(IDD_DOWNLOAD), NULL,
                                                   DownloadStatusDlgProc );
                            ShowWindow( s_hStat, SW_SHOWNORMAL );

                            HWND   hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
                            LVITEM lvi;

                            for (pCompEnum = pCompList; NULL != pCompEnum && NULL != (*pCompEnum); pCompEnum++) {
                                hr = DownloadUpdate(*pCompEnum);
                                ZeroMemory(&lvi, sizeof(lvi));                                    
                                
                                if (DONT_SHOW_UPDATES != hr)
                                    if (BLUE == (*pCompEnum)->iImage)
                                        UpdateBlueIcon(hCompList, *pCompEnum);
                                    else 
                                        UpdateBrownIcon(hCompList, *pCompEnum);
                                
                                LocalFree(*pCompEnum);
                            }
                            DestroyWindow(s_hStat);
                        }
                         
                        EnableDlgItem(hDlg, IDC_UPDATE);
                        break;
                }

                ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT2), SW_HIDE);
                SetDlgItemText(hDlg, IDC_DISKSPACENEEDED, s_szTotalSize);
                StrCpy(szWrk, g_szIEAKProg);
                dwFreeSpace = GetRootFree(szWrk);
                wnsprintf(szFreeSpace, countof(szFreeSpace), TEXT("%lu KB"), dwFreeSpace);
                InsertCommas(szFreeSpace);
                SetDlgItemText(hDlg, IDC_DISKSPACE, szFreeSpace);

                if (!g_fLocalMode)  EnableDlgItem2(hDlg, IDC_DOWNLOAD, AnyCompSelected(hDlg));
                if (!s_fNoCore)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    //processing that was formerly in the downloads page has to go here
                    g_iDownloadState = DOWN_STATE_SAVE_URL;
                    SetEvent(g_hDownloadEvent);

                    if (!g_fBatch && !g_fBatch2 && (!g_fOptCompInit || g_fSrcDirChanged))
                    {
                        DWORD dwTid;

                        g_hWizard = hDlg;

                        g_hDlg = hDlg;

                        g_fSrcDirChanged = FALSE;

                        DisableDlgItem(hDlg, IDC_DOWNLOAD);
                        DisableDlgItem(hDlg, IDC_DOWNLOADALL);
                        DisableDlgItem(hDlg, IDC_UPDATE);
						g_hAVSThread = CreateThread(NULL, 4096, InitOptComponents32, &g_hWizard, 0, &dwTid);
                        PropSheet_SetWizButtons(GetParent(hDlg), 0);
                    }
                    else
                    {
                        if (s_fNoCore)
                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                        else PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                        if (!g_fLocalMode)
                            EnableDlgItem2(hDlg, IDC_DOWNLOAD, AnyCompSelected(hDlg));
                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case LVN_ITEMCHANGED:
                    if (hOldCur == NULL)
                        hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    else
                    {
                        if (!s_fInit)
                            SetCursor(LoadCursor(NULL, IDC_WAIT));
                    }
                    AnyCompSelected(hDlg, fSel, fSizeChange);
                    if (!g_fLocalMode && g_fOptCompInit) EnableDlgItem2(hDlg, IDC_DOWNLOAD, fSel);
                    if (g_fOptCompInit)
                    {
                        if (fSizeChange || fSel)
                        {
                            ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT), SW_HIDE);
                            GetDownloadSize(GetDlgItem(hDlg, IDC_COMPLIST), GetDlgItem(hDlg, IDC_DISKSPACENEEDED));
                            ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT2), SW_SHOW);
                        }
                        else
                        {
                            ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT), SW_SHOW);
                            ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT2), SW_HIDE);
                            SetDlgItemText(hDlg, IDC_DISKSPACENEEDED, s_szTotalSize);
                        }
                    }
                    break;


                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    
                    if (!g_fOptCompInit && !g_fBatch && !g_fBatch2)
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        g_fCancelled = FALSE;
                        return(TRUE);
                    }

                    // show OE pages if OE is synchronized for win32

                    if (g_pMNComp)
                        g_fMailNews95 = (g_pMNComp->iImage != RED);

                    g_iCurPage = PPAGE_OPTDOWNLOAD;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;

        }
        break;

        case WM_LV_GETITEMS:
            LVGetItems(GetDlgItem(hDlg, IDC_COMPLIST));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

void InstallComp(PCOMPONENT pComp, INT iOpt, BOOL fInstall)
{
    PCOMPONENT pSearchComp;

    for (pSearchComp = g_paComp; *pSearchComp->szSection; pSearchComp++)
    {
        if (!pSearchComp->fAddOnOnly &&
            (StrCmpI(pSearchComp->szDisplayName, pComp->szDisplayName) == 0))
            pSearchComp->afInstall[iOpt] = fInstall;
    }

    for (pSearchComp = g_aCustComponents; *pSearchComp->szSection; pSearchComp++)
    {
        if (StrCmpI(pSearchComp->szDisplayName, pComp->szDisplayName) == 0)
            pSearchComp->afInstall[iOpt] = fInstall;
    }
}

void SetInstallOption(HWND hDlg, int iOpt)
{
    TCHAR szOptName[80];
    TCHAR szOptDesc[MAX_PATH];
    TCHAR szOptDescParam[16] = TEXT("0_DESC");
    TCHAR szOpt[2];
    int iComp;
    PCOMPONENT pComp, pCoreComp;
    ICifMode * pCifMode;
    CCifMode_t * pCifMode_t;

    szOpt[1] = 0;
    SendDlgItemMessage( hDlg, IDC_LISTAVAIL, LB_RESETCONTENT, 0, 0 );
    SendDlgItemMessage( hDlg, IDC_LISTINSTALL, LB_RESETCONTENT, 0, 0 );
    SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_SETCURSEL, iOpt, 0 );
    SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_GETLBTEXT, iOpt, (LPARAM) szOptName );
    szOptDescParam[0] = szOpt[0]= (TCHAR)(iOpt + TEXT('0'));
    WritePrivateProfileString( STRINGS, INSTALLMODE, szOpt, g_szCustInf );

    g_lpCifRWFile->FindMode(szOpt, &pCifMode);
    pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);
    pCifMode_t->GetDetails(szOptDesc, countof(szOptDesc));
    delete pCifMode_t;
    
    SetDlgItemText( hDlg, IDC_OPTDESC, szOptDesc );
    pCoreComp = FindComp(NULL, TRUE);
    for (pComp = g_paComp; ; pComp++ )
    {
        if (ISNULL(pComp->szSection)) break;
        if (pComp->fAddOnOnly) continue;
        if (pComp->iImage == RED)
        {
            int i;
            for (i = 0; i < MAX_INSTALL_OPTS ; i++ )
            {
                pComp->afInstall[i] = FALSE;
            }
            continue;
        }
        if (pComp == pCoreComp)
        {
            InstallComp(pComp, iOpt, TRUE);
            SendDlgItemMessage( hDlg, IDC_LISTINSTALL, LB_INSERTSTRING, 0, (LPARAM) pComp->szDisplayName );
        }
        else if ((pComp->iCompType != COMP_CORE) && (pComp->iPlatform <= PLAT_W98))
        {
            if (pComp->fVisible)
            {
                SendDlgItemMessage( hDlg, pComp->afInstall[iOpt] ? IDC_LISTINSTALL : IDC_LISTAVAIL,
                    LB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName );
            }

        }
    }

    for (pComp = g_aCustComponents, iComp = 0; iComp < g_nCustComp ; pComp++, iComp++ )
    {
        if ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iPlatform <= PLAT_W98))
        {
            SendDlgItemMessage( hDlg, pComp->afInstall[iOpt] ? IDC_LISTINSTALL : IDC_LISTAVAIL,
                LB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName );

        }
    }

    if (!g_fOCW)
    {
        // if not silent or stealth and we are under the max number of install options then
        // enable new button

        if (!(g_fIntranet && (g_fSilent || g_fStealth)) && (g_nModes < 10))
            EnableDlgItem(hDlg, IDC_NEWOPT);
        else
        {
            EnsureDialogFocus(hDlg, IDC_NEWOPT, IDC_DELOPT);
            DisableDlgItem(hDlg, IDC_NEWOPT);
        }

        if (g_nModes > 1)
            EnableDlgItem(hDlg, IDC_DELOPT);
        else
        {
            EnsureDialogFocus(hDlg, IDC_DELOPT,
                (g_fIntranet && (g_fSilent || g_fStealth)) ? IDC_OPTLIST : IDC_NEWOPT);
            DisableDlgItem(hDlg, IDC_DELOPT);
        }
    }
    EnableWindow(GetDlgItem(hDlg, IDC_ADDCOMP), 0 < SendMessage( GetDlgItem(hDlg, IDC_LISTAVAIL), LB_GETCOUNT, 0, 0 ));
    EnableWindow(GetDlgItem(hDlg, IDC_ADDALLCOMP), 0 < SendMessage( GetDlgItem(hDlg, IDC_LISTAVAIL), LB_GETCOUNT, 0, 0 ));
    EnableWindow(GetDlgItem(hDlg, IDC_REMCOMP), 1 < SendMessage( GetDlgItem(hDlg, IDC_LISTINSTALL), LB_GETCOUNT, 0, 0 ));
    EnableWindow(GetDlgItem(hDlg, IDC_REMALLCOMP), 1 < SendMessage( GetDlgItem(hDlg, IDC_LISTINSTALL), LB_GETCOUNT, 0, 0 ));

    SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
    SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));
}

void InitSelection32(HWND hDlg)
{
    int i, j, iComp;
    PCOMPONENT pComp;
    IEnumCifModes * pEnumCifModes;

    if (g_fBatch) return;
    SendDlgItemMessage(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_RESETCONTENT, 0, 0 );

    // currently not getting alpha modes

    if (SUCCEEDED(g_lpCifRWFile->EnumModes(&pEnumCifModes,
        PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL)))
    {
        ICifMode * pCifMode;
        TCHAR szModeID[64];
        TCHAR szOptName[96];

        i = 0;
        while (SUCCEEDED(pEnumCifModes->Next(&pCifMode)))
        {
            CCifMode_t * pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);

            pCifMode_t->GetID(szModeID, countof(szModeID));
            g_szAllModes[i] = szModeID[0];
            pCifMode_t->GetDescription(szOptName, countof(szOptName));
            SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_ADDSTRING, 0, (LPARAM) szOptName );
            i++;
            delete pCifMode_t;
        }
        pEnumCifModes->Release();
        g_szAllModes[i] = TEXT('\0');
    }

    g_nModes = lstrlen(g_szAllModes);

    for (pComp = g_paComp; ; pComp++ )
    {
        if (ISNULL(pComp->szSection)) break;
        ZeroMemory(pComp->afInstall, sizeof(pComp->afInstall));
        if (pComp->iCompType == COMP_CORE)
        {
            for (i = 0; i < g_nModes ; i++ )
            {
                pComp->afInstall[i] = TRUE;
            }
        }
        else
        {
            for (i = 0; i < g_nModes; i++)
            {
                for (j=0; j < lstrlen(pComp->szModes); j++)
                {
                    if (pComp->szModes[j] == g_szAllModes[i])
                        pComp->afInstall[i] = TRUE;
                }
            }

            // for invisible comps, set them to the same modes as the visible components
            // that depend on them

            if (!pComp->fVisible)
            {
                for (i = 0; pComp->paCompRevDeps[i] && (i < 10); i++)
                {
                    for (j=0; j < MAX_INSTALL_OPTS; j++)
                    {
                        if (pComp->paCompRevDeps[i]->afInstall[j])
                            pComp->afInstall[j] = TRUE;
                    }
                }
            }
        }
    }

    for (pComp = g_aCustComponents, iComp = 0; iComp < g_nCustComp ; pComp++, iComp++ )
    {
        TCHAR szModesParam[80] = TEXT("Cust0Modes");
        TCHAR szModes[16] = TEXT("\"");
        if (ISNULL(pComp->szSection)) break;

        szModesParam[4] = (TCHAR)(iComp + TEXT('0'));
        ZeroMemory(pComp->afInstall, sizeof(pComp->afInstall));
        GetPrivateProfileString(IS_STRINGS, szModesParam, TEXT(""), szModes, countof(szModes), g_szCustInf);
        if (StrCmpI(szModes, UNUSED) != 0)
        {
            for (i = 0; i < lstrlen(szModes) ; i++ )
            {
                int j = szModes[i] - TEXT('0');
                pComp->afInstall[j] = TRUE;
            }
        }

    }

    if (g_iSelOpt > g_nModes - 1) g_iSelOpt = g_nModes ? g_nModes - 1 : 0;
    SetInstallOption(hDlg, g_iSelOpt);
}

void SaveSelection()
{
    int i, iComp;
    PCOMPONENT pComp;
    TCHAR szQuotedModes[16] = TEXT("\"");
    ICifRWComponent * pCifRWComponent;
    CCifRWComponent_t * pCifRWComponent_t;

    StrCat(szQuotedModes, g_szAllModes);
    StrCat(szQuotedModes, TEXT("\""));

    for (pComp = g_aCustComponents, iComp = 0; iComp < MAXCUST ; pComp++, iComp++ )
    {
        TCHAR szModesParam[80] = TEXT("Cust0Modes");
        TCHAR szModesNameParam[80] = TEXT("Cust0Name");
        TCHAR szModes[16] = TEXT("");
        TCHAR szQuotedSection[32] = TEXT("\"");

        StrCat(szQuotedSection, pComp->szSection);
        StrCat(szQuotedSection, TEXT("\""));
        szModesParam[4] = szModesNameParam[4] = (TCHAR)(iComp + TEXT('0'));
        if (ISNULL(pComp->szSection))
        {
            InsWriteQuotedString(IS_STRINGS, szModesNameParam, UNUSED, g_szCustInf);
            InsWriteQuotedString(IS_STRINGS, szModesParam, TEXT("\"\""), g_szCustInf);
            continue;
        }
        for (i = 0; i < g_nModes ; i++ )
        {
            TCHAR szAddMode[2] = TEXT("0");
            szAddMode[0] = (TCHAR)(i + TEXT('0'));
            if (pComp->afInstall[i]) StrCat(szModes, szAddMode);
        }

        StrCpy(pComp->szModes, szModes);
        InsWriteQuotedString(IS_STRINGS, szModesNameParam, szQuotedSection, g_szCustInf);
        InsWriteQuotedString(IS_STRINGS, szModesParam, szModes, g_szCustInf);
    }

    for (pComp = g_paComp; ; pComp++ )
    {
        TCHAR szModesParam[80];
        TCHAR szModes[16] = TEXT("");

        if (ISNULL(pComp->szSection)) break;
    //BUGBUG fix for alpha release
        if (pComp->iPlatform == PLAT_ALPHA) continue;
        for (i = 0; i < g_nModes ; i++ )
        {
            TCHAR szAddMode[2] = TEXT("0");
            szAddMode[0] = (TCHAR)(i + TEXT('0'));
            if (pComp->afInstall[i]) StrCat(szModes, szAddMode);
        }
        
        StrCpy(szModesParam, pComp->szModes);

        g_lpCifRWFile->CreateComponent(pComp->szSection, &pCifRWComponent);
        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);

        if (pComp->iCompType == COMP_CORE)
        {
            int j;

            if ((StrCmpNI(pComp->szSection, TEXT("IE4SHELL"), 8) == 0) ||
                (StrCmpNI(pComp->szSection, TEXT("MFC"), 3) == 0))
                continue;

            WriteModesToCif(pCifRWComponent_t, g_szAllModes);
            StrCpy(pComp->szModes, g_szAllModes);
            for (j = 0; g_szAllModes[j]; j++)
                pComp->afInstall[j] = TRUE;
        }
        else
        {
            if (pComp->fVisible)
                WriteModesToCif(pCifRWComponent_t, szModes);

            // BUGBUG: <oliverl> take out this assert for now because we'd have to totally
            //         change the way we handle adding and removing comps from modes to
            //         prevent this from asserting
    /*        else
                ASSERT(ISNULL(pComp->szModes));  */

            StrCpy(pComp->szModes, szModes);
        }

        delete pCifRWComponent_t;
        pCifRWComponent_t = NULL;
    }

    WritePrivateProfileString(NULL, NULL, NULL, g_szCustInf);
    g_lpCifRWFile->Flush();
}

BOOL AddDependencies32(HWND hDlg, LPCTSTR pcszSectName, INT &nComp)
{
    HWND hSource = GetDlgItem(hDlg, IDC_LISTAVAIL);
    HWND hDest = GetDlgItem(hDlg, IDC_LISTINSTALL);
    int iComp;
    PCOMPONENT pComp;
    ICifComponent * pCifComponent;
    BOOL fCust = FALSE;

    if (StrCmpNI(pcszSectName, TEXT("BASEIE40"), 8) == 0)
        return TRUE;

    pComp = FindComp(pcszSectName, FALSE);

    if (pComp == NULL)
    {
        fCust = TRUE;
        pComp = FindCustComp(pcszSectName);

        if (pComp == NULL)
            return FALSE;
    }

    InstallComp(pComp, g_iSelOpt, TRUE);

    if (pComp->fVisible)
    {
        if ((iComp = (int) SendMessage( hSource, LB_FINDSTRINGEXACT, 0, (LPARAM)pComp->szDisplayName )) == -1 )
            return FALSE;


        SendMessage( hSource, LB_DELETESTRING, iComp, 0 );
        SendMessage( hDest, LB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName);
        nComp--;

        SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
        SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));
    }

    if (!fCust)
    {
        if (SUCCEEDED(g_lpCifRWFile->FindComponent(pComp->szSection, &pCifComponent)))
        {
            TCHAR tchType;
            TCHAR szDepID[96];
            UINT uiIndex = 0;
            PCOMPONENT pDepComp;
            CCifComponent_t * pCifComponent_t =
                new CCifComponent_t((ICifRWComponent *)pCifComponent);

            while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szDepID, countof(szDepID), &tchType, NULL, NULL)))
            {
                pDepComp = FindComp(szDepID, FALSE);

                // check to see if we've already seen this dependency

                if (pDepComp && !pDepComp->afInstall[g_iSelOpt])
                {
                    if (!AddDependencies32(hDlg, szDepID, nComp))
                        return FALSE;
                }
                uiIndex++;
            }

            delete pCifComponent_t;
        }
    }

    return TRUE;
}

void RemoveSilentDeps32(PCOMPONENT pComp, INT iSelOpt)
{
    ICifComponent * pCifComponent;
    PCOMPONENT pDepComp;
    UINT uiIndex = 0;
    TCHAR szDepID[32];
    TCHAR tchType;

    if (SUCCEEDED(g_lpCifRWFile->FindComponent(pComp->szSection, &pCifComponent)))
    {
        CCifComponent_t * pCifComponent_t =
            new CCifComponent_t((ICifRWComponent *)pCifComponent);

        while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szDepID, countof(szDepID), &tchType, NULL, NULL)))
        {
            pDepComp = FindComp(szDepID, FALSE);

            if (pDepComp && !pDepComp->fVisible && pDepComp->afInstall[iSelOpt])
            {
                InstallComp(pDepComp, iSelOpt, FALSE);
                RemoveSilentDeps32(pDepComp, iSelOpt);
            }
            uiIndex++;
        }
        delete pCifComponent_t;
    }
}

BOOL RemoveDependencies32(HWND hDlg, PCOMPONENT pComp, INT &nComp, BOOL fCust)
{
    int i, k, j = 0;
    BOOL fAdd;
    TCHAR szCompList[MAX_BUF];
    TCHAR szHeader[MAX_PATH];
    TCHAR szMsgBoxText[MAX_BUF];
    HWND hSource = GetDlgItem(hDlg, IDC_LISTINSTALL);
    HWND hDest = GetDlgItem(hDlg, IDC_LISTAVAIL);

    if (!fCust)
    {
        ZeroMemory(szCompList, sizeof(szCompList));

        StrCat(szCompList, TEXT("\r\n"));
        for (i = 0, j = 0; pComp->paCompRevDeps[i] && (i < 10); i++)
        {
            if (((pComp->paCompRevDeps[i])->fVisible) &&
                ((pComp->paCompRevDeps[i])->afInstall[g_iSelOpt]))
            {
                fAdd = TRUE;
                for (k = 0;  pComp->paCompRevDeps[k] && (k < i); k++)
                {
                    if (0 == (strcmp((const char*)(pComp->paCompRevDeps[k])->szDisplayName,
                                     (const char*)(pComp->paCompRevDeps[i])->szDisplayName)))
                        fAdd = FALSE;
                }
                if (fAdd)
                {
                    StrCat(szCompList, (pComp->paCompRevDeps[i])->szDisplayName);
                    StrCat(szCompList, TEXT("\r\n"));
                }
                j++;
            }
        }

        if (j != 0)
        {
            LoadString(g_rvInfo.hInst, IDS_DEPEND_WARNING , szHeader, countof(szHeader));
            wnsprintf(szMsgBoxText, countof(szMsgBoxText), szHeader, pComp->szDisplayName, szCompList);
        }
    }

    if (fCust || (j == 0) || (MessageBox(hDlg, szMsgBoxText, TEXT(""), MB_OKCANCEL) == IDOK))
    {

        InstallComp(pComp, g_iSelOpt, FALSE);
        if (!fCust)
        {
            for (i = 0; pComp->paCompRevDeps[i] && (i < 10); i++)
            {
                InstallComp(pComp->paCompRevDeps[i], g_iSelOpt, FALSE);

                if ((pComp->paCompRevDeps[i])->fVisible)
                {
                    if ((j = (int) SendMessage( hSource, LB_FINDSTRINGEXACT, 1, (LPARAM)(pComp->paCompRevDeps[i])->szDisplayName )) != -1 )
                    {
                        SendMessage( hSource, LB_DELETESTRING, j, 0 );
                        SendMessage( hDest, LB_ADDSTRING, 0, (LPARAM) (pComp->paCompRevDeps[i])->szDisplayName );
                        nComp--;

                        SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
                        SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));
                    }
                }
            }
            RemoveSilentDeps32(pComp, g_iSelOpt);
        }

        if ((i = (int) SendMessage( hSource, LB_FINDSTRINGEXACT, 1, (LPARAM)pComp->szDisplayName )) != -1 )
        {
            SendMessage( hSource, LB_DELETESTRING, i, 0 );
            SendMessage( hDest, LB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName );
            nComp--;

            SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
            SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));
        }

    }
    else
        return FALSE;

    return TRUE;
}



void AddRemoveComponents(HWND hDlg, BOOL fAll, BOOL fAdd)
{
    HWND hSource = GetDlgItem(hDlg, fAdd ? IDC_LISTAVAIL : IDC_LISTINSTALL);
    HWND hDest = GetDlgItem(hDlg, fAdd ? IDC_LISTINSTALL : IDC_LISTAVAIL);
    TCHAR szCompName[MAX_PATH];
    PCOMPONENT pComp;
    int iComp,iStart;
    int nComp = (int) SendMessage(hSource, LB_GETCOUNT, 0, 0);
    BOOL fCust;
    BOOL fSomeSel = FALSE;

    if(!fAdd)
    {
        iStart=1; //We don't want to remove the browser itself;
    }
    else
    {
        iStart=0;
    }

    if (fAll)
    {
        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            pComp->afInstall[g_iSelOpt] = fAdd && (!pComp->fAddOnOnly);
        }

        for (pComp = g_aCustComponents; *pComp->szSection; pComp++ )
        {
            pComp->afInstall[g_iSelOpt] = fAdd;
        }
    }

    for (iComp = iStart; iComp < nComp; iComp++ )
    {
        BOOL fSel = (SendMessage( hSource, LB_GETSEL, iComp, 0 ) > 0) ? TRUE : FALSE;
        if (!fSel && !fAll) continue;

        fSomeSel = TRUE;
        SendMessage( hSource, LB_GETTEXT, iComp, (LPARAM) szCompName );

        if (!fAll)
        {
            pComp = FindVisibleComponentName(szCompName);
            if (!pComp)
            {
                pComp = FindCustComponentName(szCompName);
                fCust = TRUE;
            }
            else
                fCust = FALSE;

            if (pComp)
            {
                if (fAdd)
                {
                    AddDependencies32(hDlg, pComp->szSection, nComp);
                    iComp = iStart-1;
                }
                else
                {
                    if (RemoveDependencies32(hDlg, pComp, nComp, fCust))
                        iComp = iStart-1;
                }
            }
            continue;
        }
        SendMessage( hSource, LB_DELETESTRING, iComp, 0 );
        SendMessage( hDest, LB_ADDSTRING, 0, (LPARAM) szCompName );
        iComp--;
        nComp--;
    }
    if (fSomeSel)
    {
        BOOL fEnableAdd = (0 < SendMessage( fAdd ? hSource : hDest, LB_GETCOUNT, 0, 0 ));
        BOOL fEnableRem = (iStart < SendMessage( fAdd ? hDest : hSource, LB_GETCOUNT, 0, 0 ));
                           
        EnableWindow(GetDlgItem(hDlg, IDC_ADDCOMP), fEnableAdd);
        EnableWindow(GetDlgItem(hDlg, IDC_ADDALLCOMP), fEnableAdd);
        EnableWindow(GetDlgItem(hDlg, IDC_REMCOMP), fEnableRem);
        EnableWindow(GetDlgItem(hDlg, IDC_REMALLCOMP), fEnableRem);

        if (fEnableAdd)
            SetFocus(GetDlgItem(hDlg,IDC_LISTINSTALL));
        else
            SetFocus(GetDlgItem(hDlg,IDC_LISTAVAIL));
    }

    SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
    SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));

}


DWORD GotRoom(HWND hDlg)
{
    PCOMPONENT pComp;
    TCHAR szDestRoot[MAX_PATH];
    TCHAR szTempRoot[MAX_PATH];
    int iComp;
    DWORD dwDestMul = 1, dwTempMul = 0;
    DWORD dwDestFree, dwTempFree, dwDestNeed, dwTempNeed;

    if (g_fCD) dwDestMul++;
    if (g_fLAN) dwDestMul++;
    if (g_fBrandingOnly) dwDestMul++;
    StrCpy(szDestRoot, g_szBuildRoot);
    StrCpy(szTempRoot, g_szBuildTemp);
    CharUpper(szDestRoot);
    CharUpper(szTempRoot);
    dwDestFree = GetRootFree(szDestRoot);
    dwTempFree = GetRootFree(szTempRoot);
    dwDestNeed = dwTempNeed = 4096;

    for (pComp = g_paComp;  ; pComp++ )
    {
        if (ISNULL(pComp->szSection)) break;
        dwDestNeed += pComp->dwSize * dwDestMul;
        dwTempNeed += pComp->dwSize * dwTempMul;
    }

    for (pComp = g_aCustComponents, iComp = 0; iComp < g_nCustComp ; pComp++, iComp++ )
    {
        DWORD dwSize = FolderSize(pComp->szPath) >> 10;
        dwDestNeed += dwSize * dwDestMul;
        dwTempNeed += dwSize * dwTempMul;
    }

    if (*szDestRoot == *szTempRoot)
    {
        dwDestNeed += dwTempNeed;
    }
    else if (dwTempFree < dwTempNeed)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szTemplate[MAX_PATH];
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
        LoadString( g_rvInfo.hInst, IDS_TEMPDISKMSG2, szTemplate, MAX_PATH );
        wnsprintf(szMsg, countof(szMsg), szTemplate, dwTempFree, dwTempNeed);
        if (MessageBox(hDlg, szMsg, szTitle, MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
        {
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
            DoCancel();
            return (DWORD)-1;
        }
        else
        {
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
            return (DWORD)-1;
        }
    }
    if (dwDestFree < dwDestNeed)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szTemplate[MAX_PATH];
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
        LoadString( g_rvInfo.hInst, IDS_DESTDISKMSG2, szTemplate, MAX_PATH );
        wnsprintf(szMsg, countof(szMsg), szTemplate, dwDestFree, dwDestNeed);
        if (MessageBox(hDlg, szMsg, szTitle, MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
        {
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
            DoCancel();
            return (DWORD)-1;
        }
        else
        {
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
            return (DWORD)-1;
        }
    }
    return(0);

}

BOOL SaveOption(HWND hDlg, HWND hOptlist)
{
    TCHAR szOptName[80] = TEXT("");
    TCHAR szOptNameParam[8] = TEXT("0_Name");
    TCHAR szOptDesc[MAX_PATH] = TEXT("");
    TCHAR szOptDescParam[8] = TEXT("0_DESC");
    TCHAR szOptNum[2] = TEXT("0");
    ICifRWMode * pCifRWMode;
    CCifRWMode_t * pCifRWMode_t;

    GetWindowText( hOptlist, szOptName, 80 );
    GetDlgItemText( hDlg, IDC_OPTDESC, szOptDesc, countof(szOptDesc));

    if (ISNULL(szOptName) || ISNULL(szOptDesc))
    {
        ErrorMessageBox(hDlg, IDS_BLANKOPTION);
        return FALSE;
    }
    SendMessage( hOptlist, CB_DELETESTRING, g_iSelOpt, 0L );
    SendMessage( hOptlist, CB_INSERTSTRING, g_iSelOpt, (LPARAM) szOptName);
    SendMessage( hOptlist, CB_SETCURSEL, g_iSelOpt, 0L );

    szOptNum[0] = (TCHAR)(g_iSelOpt + TEXT('0'));
    g_lpCifRWFile->CreateMode(szOptNum, &pCifRWMode);
    pCifRWMode_t = new CCifRWMode_t(pCifRWMode);
    pCifRWMode_t->SetDescription(szOptName);
    pCifRWMode_t->SetDetails(szOptDesc);
    delete pCifRWMode_t;

    return TRUE;
}

void ReinitModes(HWND hDlg)
{
    PCOMPONENT pComp;
    IEnumCifModes * pEnumCifModes;
    INT iComp;

    // delete the cif structure before copying over the versioning cif to the target dir

    if (g_lpCifRWFile)
    {
        delete g_lpCifRWFile;
        g_lpCifRWFile = NULL;
    }
    CopyFile(g_szCifVer, g_szCif, FALSE);
    GetICifRWFileFromFile_t(&g_lpCifRWFile, g_szCif);

    if (g_fOCW)
    {
        g_lpCifRWFile->DeleteMode(TEXT("2"));
        g_lpCifRWFile->Flush();
    }

    // reread the modes for the components from the cif

    for (pComp = g_paComp; *pComp->szSection; pComp++)
    {
        ICifComponent * pCifComponent;

        ZeroMemory(pComp->szModes, sizeof(pComp->szModes));
        ZeroMemory(pComp->afInstall, sizeof(pComp->afInstall));

        if (SUCCEEDED(g_lpCifRWFile->FindComponent(pComp->szSection, &pCifComponent)))
        {
            UINT uiIndex = 0;
            TCHAR szMode[MAX_PATH];
            CCifComponent_t * pCifComponent_t =
                new CCifComponent_t((ICifRWComponent *)pCifComponent);

            while (SUCCEEDED(pCifComponent_t->GetMode(uiIndex, szMode, countof(szMode))))
            {
                pComp->szModes[uiIndex] = szMode[0];
                pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
                uiIndex++;
            }
            delete pCifComponent_t;
        }
    }

    if (SUCCEEDED(g_lpCifRWFile->EnumModes(&pEnumCifModes,
        PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL)))
    {
        ICifMode * pCifMode;
        TCHAR szModeID[64];
        int i = 0;

        while (SUCCEEDED(pEnumCifModes->Next(&pCifMode)))
        {
            CCifMode_t * pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);

            pCifMode_t->GetID(szModeID, countof(szModeID));
            g_szAllModes[i] = szModeID[0];
            i++;
            delete pCifMode_t;
        }
        pEnumCifModes->Release();
        g_szAllModes[i] = TEXT('\0');
    }

    g_nModes = lstrlen(g_szAllModes);
    // reset custom components to be in all modes

    for (iComp = 0, pComp = g_aCustComponents; iComp < g_nCustComp; iComp++, pComp++ )
    {
        if (ISNULL(pComp->szSection)) break;
        StrCpy(pComp->szModes, g_szAllModes);
    }

    InitSelection32(hDlg);
}

//
//  FUNCTION: ComponentSelect(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "ComponentSelect" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
//
INT_PTR CALLBACK ComponentSelect(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szOptName[80];
    TCHAR szOptTpl[80];
    TCHAR szOptNameParam[8] = TEXT("0_Name");
    TCHAR szOptDesc[160];    // weird limit imposed by size of window control in ie6setup
    TCHAR szOptDescParam[8] = TEXT("0_DESC");
    TCHAR szOptNum[2] = TEXT("0");
    TCHAR szNextNameParam[8] = TEXT("0_Name");
    TCHAR szNextDescParam[8] = TEXT("0_Desc");
    TCHAR szModeNameParm[10] = TEXT("%0_Name%");
    TCHAR szModeDescParm[10] = TEXT("%0_Desc%");
    TCHAR szModeSect[8] = TEXT("0.Win");
    int iComp, iOpt, iNewSel;
    PCOMPONENT pComp;
    TCHAR szModeChar[4] = TEXT("0");
    BOOL s_fFirst = TRUE;
    HWND hOptlist;
    static BOOL s_fEditChange = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            EnableDBCSChars( hDlg, IDC_LISTAVAIL);
            EnableDBCSChars( hDlg, IDC_LISTINSTALL);
            EnableDBCSChars( hDlg, IDC_OPTLIST);
            EnableDBCSChars( hDlg, IDC_OPTLISTOCW);
            EnableDBCSChars( hDlg, IDC_OPTDESC);
            Edit_LimitText(GetDlgItem(hDlg, IDC_OPTDESC), countof(szOptDesc)-1);
            Edit_LimitText(GetDlgItem(hDlg, IDC_OPTLIST), countof(szOptName)-1);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_OPTLIST:
                case IDC_OPTLISTOCW:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                            s_fEditChange = TRUE;
                            break;

                        case CBN_SELENDOK:
                            hOptlist = GetDlgItem(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST);
                            iNewSel = ComboBox_GetCurSel(hOptlist);
                            if (s_fEditChange)
                            {
                                GetWindowText(hOptlist, szOptName, countof(szOptName));
                                ComboBox_DeleteString(hOptlist, g_iSelOpt);
                                ComboBox_InsertString(hOptlist, g_iSelOpt, szOptName);
                                
                                if (!SaveOption(hDlg, hOptlist))
                                {
                                    ComboBox_SetCurSel(hOptlist, g_iSelOpt);
                                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                    break;
                                }
                                s_fEditChange = FALSE;
                            }
                            if ((iNewSel != CB_ERR) && (iNewSel != g_iSelOpt))
                            {
                                g_iSelOpt = iNewSel;
                                SetInstallOption(hDlg, g_iSelOpt);
                            }
                            if (iNewSel < 0) iNewSel = 0;
                            ComboBox_SetCurSel(hOptlist, iNewSel);
                            break;

                        case CBN_DROPDOWN:
                            hOptlist = GetDlgItem(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST);
                            GetWindowText(hOptlist, szOptName, countof(szOptName));
                            ComboBox_DeleteString(hOptlist, g_iSelOpt);
                            ComboBox_InsertString(hOptlist, g_iSelOpt, szOptName);
                            ComboBox_SetCurSel(hOptlist, g_iSelOpt);
                            break;
                        default:
                            return FALSE;
                    }
                    break;
                case IDC_OPTDESC:
                    s_fEditChange = TRUE;
                    break;
                case IDC_NEWOPT:
                    if (s_fEditChange)
                    {
                        if (!SaveOption(hDlg, GetDlgItem(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST)))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                    }
                    g_iSelOpt = g_nModes++;
                    LoadString( g_rvInfo.hInst, IDS_NEWINSTALLOPT, szOptTpl, countof(szOptTpl) );
                    *szOptNum = *szOptNameParam = *szModeChar = *szModeSect =
                        szModeNameParm[1] = szModeDescParm[1] = (TCHAR)(g_iSelOpt + TEXT('0'));
                    wnsprintf(szOptName, countof(szOptName), TEXT("%s %s"), szOptTpl, szOptNum);

                    {
                        ICifRWMode * pCifRWMode;
                        CCifRWMode_t * pCifRWMode_t;

                        szOptNum[0] = (TCHAR)(g_iSelOpt + TEXT('0'));
                        g_lpCifRWFile->CreateMode(szOptNum, &pCifRWMode);
                        pCifRWMode_t = new CCifRWMode_t(pCifRWMode);
                        pCifRWMode_t->SetDescription(szOptName);
                        delete pCifRWMode_t;
                    }
                    
                    SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_ADDSTRING, 0, (LPARAM) szOptName );
                    StrCat(g_szAllModes, szModeChar);

                    // add custom components to mode by default
                    for (iComp = 0, pComp = g_aCustComponents; iComp < g_nCustComp  ; iComp++, pComp++ )
                    {
                        if (ISNULL(pComp->szSection)) break;
                        pComp->afInstall[g_nModes-1] = TRUE;
                        StrCat(pComp->szModes, szOptNum);
                    }

                    SetInstallOption(hDlg, g_iSelOpt);
                    s_fEditChange = TRUE;
                    break;
                case IDC_DELOPT:
                    SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_DELETESTRING, g_iSelOpt, 0 );
                    if (g_iSelOpt != (g_nModes - 1))
                    {
                        ICifRWMode * pCifRWMode;
                        CCifRWMode_t * pCifRWMode_t;
                        ICifMode * pCifMode;
                        CCifMode_t * pCifMode_t;
                        TCHAR szOptCurrent[2];
                        TCHAR szOptNext[2];
                        
                        for (iOpt = g_iSelOpt; iOpt < (g_nModes-1) ; iOpt++ )
                        {
                            *szNextNameParam = *szNextDescParam = (TCHAR)(iOpt + TEXT('1'));
                            *szOptDescParam = *szOptNameParam = (TCHAR)(iOpt + TEXT('0'));

                            StrCpy(szOptCurrent, TEXT("0"));
                            StrCpy(szOptNext, TEXT("0"));

                            szOptCurrent[0] = (TCHAR)(iOpt + TEXT('0'));
                            szOptNext[0] = (TCHAR)(iOpt + TEXT('1'));
                            g_lpCifRWFile->DeleteMode(szOptCurrent);
                            g_lpCifRWFile->CreateMode(szOptCurrent, &pCifRWMode);
                            pCifRWMode_t = new CCifRWMode_t(pCifRWMode);
                            g_lpCifRWFile->FindMode(szOptNext, &pCifMode);
                            pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);
                            pCifMode_t->GetDescription(szOptName, countof(szOptName));
                            pCifRWMode_t->SetDescription(szOptName);
                            pCifMode_t->GetDetails(szOptDesc, countof(szOptDesc));
                            pCifRWMode_t->SetDetails(szOptDesc);
                            delete pCifRWMode_t;
                            delete pCifMode_t;
                            pCifRWMode_t = NULL;
                            pCifMode_t = NULL;
                             
                            for (pComp = g_paComp; ; pComp++ )
                            {
                                if (ISNULL(pComp->szSection)) break;
                                pComp->afInstall[iOpt] = pComp->afInstall[iOpt + 1];
                            }
                            for (iComp = 0, pComp = g_aCustComponents; iComp < g_nCustComp  ; iComp++, pComp++ )
                            {
                                if (ISNULL(pComp->szSection)) break;
                                pComp->afInstall[iOpt] =  pComp->afInstall[iOpt + 1];
                            }
                        }
                    }

                    *szOptDescParam = *szOptNameParam = szOptNum[0] = (TCHAR)((g_nModes-1) + TEXT('0'));
                    szOptNum[1] = TEXT('\0');

                    g_lpCifRWFile->DeleteMode(szOptNum);

                    for (pComp = g_paComp; ; pComp++ )
                    {
                        if (ISNULL(pComp->szSection)) break;
                        pComp->afInstall[g_nModes-1] = FALSE;
                    }
                    for (iComp = 0, pComp = g_aCustComponents; iComp < g_nCustComp  ; iComp++, pComp++ )
                    {
                        if (ISNULL(pComp->szSection)) break;
                        pComp->afInstall[g_nModes-1] = FALSE;
                    }
                    g_nModes--;
                    g_szAllModes[g_nModes] = TEXT('\0');
                    
                    if (g_iSelOpt >= g_nModes) g_iSelOpt--;
                    SetInstallOption(hDlg, g_iSelOpt);
                    break;
                case IDC_ADDCOMP:
                    AddRemoveComponents(hDlg, FALSE, TRUE);
                    break;
                case IDC_REMCOMP:
                    AddRemoveComponents(hDlg, FALSE, FALSE);
                    break;
                case IDC_ADDALLCOMP:
                    AddRemoveComponents(hDlg, TRUE, TRUE);
                    break;
                case IDC_REMALLCOMP:
                    AddRemoveComponents(hDlg, TRUE, FALSE);
                    break;
                case IDC_RESETCOMPS:
                    ReinitModes(hDlg);
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    g_iSelOpt = GetPrivateProfileInt( STRINGS, INSTALLMODE, 0, g_szCustInf );

                    if (g_fOCW)
                    {
                        PCOMPONENT pComp;

                        DisableDlgItem(hDlg, IDC_NEWOPT);
                        DisableDlgItem(hDlg, IDC_DELOPT);
                        ShowWindow(GetDlgItem(hDlg, IDC_OPTLIST), SW_HIDE);
                        LoadString(g_rvInfo.hInst, IDS_OCWOPTDESC, szOptDesc, countof(szOptDesc));
                        SetWindowText(GetDlgItem(hDlg, IDC_OPTIONTEXT3), szOptDesc);

                        // do not offer full mode for OCW
                        g_lpCifRWFile->DeleteMode(TEXT("2"));
                        g_lpCifRWFile->Flush();

                        for (pComp = g_paComp; ; pComp++ )
                        {
                            if (ISNULL(pComp->szSection)) break;
                            pComp->afInstall[2] = FALSE;
                        }
                    }
                    else
                        ShowWindow(GetDlgItem(hDlg, IDC_OPTLISTOCW), SW_HIDE);

                    if (s_fFirst)
                    {
                        InitSelection32(hDlg);
                        s_fFirst = FALSE;
                    }
                    
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                    if (GotRoom(hDlg) != 0) return(TRUE);
                case PSN_WIZBACK:
                    if (!g_fBatch)
                    {
                        CNewCursor cur(IDC_WAIT);

                        if (s_fEditChange)
                        {
                            if (!SaveOption(hDlg, GetDlgItem(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST)))
                            {
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                break;
                            }
                            s_fEditChange = FALSE;
                        }
                        SaveSelection();
                        for (iOpt = 0; iOpt < g_nModes ; iOpt++ )
                        {
                            *szModeChar = *szModeSect = szModeNameParm[1] = szModeDescParm[1] =
                                *szOptNameParam = *szOptDescParam = *szOptNum = (TCHAR)(iOpt + TEXT('0'));

                            {
                                ICifMode * pCifMode;
                                CCifMode_t * pCifMode_t;

                                g_lpCifRWFile->FindMode(szOptNum, &pCifMode);
                                pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);
                                if (FAILED(pCifMode_t->GetDescription(szOptName, countof(szOptName))) ||
                                    FAILED(pCifMode_t->GetDetails(szOptDesc, countof(szOptDesc))))
                                {
                                    delete pCifMode_t;
                                    ErrorMessageBox(hDlg, IDS_BLANKOPTION);
                                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                    break;
                                }
                                delete pCifMode_t;
                            }
                        }

                        InsFlushChanges(g_szCustInf);
                    }
                    else
                    {
                        g_fMailNews95 = FALSE;
                    }

                    g_iCurPage = PPAGE_COMPSEL;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL InitList(HWND hwnd, UINT id)
{
    HIMAGELIST  himl;     // handle of image list
    HBITMAP     hbmp;     // handle of bitmap
    HWND        hwndList;
    LVCOLUMN    lvCol;

    hwndList = GetDlgItem(hwnd, id);
    // Create the image list.
    if ((himl = ImageList_Create(CX_BITMAP, CY_BITMAP, 0, NUM_BITMAPS, 0)) == NULL)
        return FALSE;

    hbmp = LoadBitmap(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_UNSELECT));
    ImageList_Add(himl, hbmp, (HBITMAP) NULL);
    DeleteObject(hbmp);

    hbmp = LoadBitmap(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_SELECT));
    ImageList_Add(himl, hbmp, (HBITMAP) NULL);
    DeleteObject(hbmp);

    if (ImageList_GetImageCount(himl) < NUM_BITMAPS)
        return FALSE;

    // Associate the image list with the  control.
    ListView_SetImageList(hwndList, himl, LVSIL_SMALL);

    ZeroMemory(&lvCol, sizeof(lvCol));
    lvCol.mask = LVCF_FMT;
    lvCol.fmt = LVCFMT_LEFT;
    lvCol.cx = 280;
    ListView_InsertColumn(hwndList, 0, &lvCol);

    return TRUE;
}

void InitHiddenItems(UINT uListId)
{
    TCHAR szBuf[8];
    PCOMPONENT pComp;

    if (uListId == IDC_COPYCOMP)
    {
        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
        {
            if (GetPrivateProfileString(IS_NOCOPYCUST, pComp->szGUID, TEXT(""), szBuf, countof(szBuf), g_szCustIns))
                pComp->fNoCopy = TRUE;
        }

        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (GetPrivateProfileString(IS_NOCOPYCUST, pComp->szGUID, TEXT(""), szBuf, countof(szBuf), g_szCustIns))
                pComp->fNoCopy = TRUE;
        }
    }
    else
    {
        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
        {
            if ((GetPrivateProfileString(IS_HIDECUST, pComp->szGUID, TEXT(""), szBuf, countof(szBuf), g_szCustIns)
                && (*szBuf == TEXT('1'))) || (ISNULL(szBuf) && !AnySelection(pComp)))
                pComp->fCustomHide = TRUE;
        }

        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (pComp->fAddOnOnly ||
                (GetPrivateProfileString(IS_HIDECUST, pComp->szGUID, TEXT(""), szBuf, countof(szBuf), g_szCustIns)
                && (*szBuf == TEXT('1'))) || (ISNULL(szBuf) && !AnySelection(pComp)))
                pComp->fCustomHide = TRUE;
        }
    }
}

// BUGBUG: <oliverl> should probably persist this server side only info in a server side file for IEAK6

void SaveHiddenItems(UINT uListId)
{
    PCOMPONENT pComp;

    if (uListId == IDC_COPYCOMP)
    {
        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
            WritePrivateProfileString(IS_NOCOPYCUST, pComp->szGUID, pComp->fNoCopy ? TEXT("1") : NULL, g_szCustIns);

        for (pComp = g_paComp; *pComp->szSection; pComp++)
            WritePrivateProfileString(IS_NOCOPYCUST, pComp->szGUID, pComp->fNoCopy ? TEXT("1") : NULL, g_szCustIns);
    }
    else
    {
        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
            WritePrivateProfileString(IS_HIDECUST, pComp->szGUID, pComp->fCustomHide ? TEXT("1") : TEXT("0"), g_szCustIns);

        for (pComp = g_paComp; *pComp->szSection; pComp++)
            WritePrivateProfileString(IS_HIDECUST, pComp->szGUID, (pComp->fCustomHide && !pComp->fAddOnOnly) ? TEXT("1") : TEXT("0"), g_szCustIns);
    }
}

BOOL AddItemToList(PCOMPONENT pComp, HWND hDlg, UINT uListID, int& iItem)
{
    LVITEM lvItem;
    LVFINDINFO lvFind;
    TCHAR szStatus[64];
    HWND hwndList = GetDlgItem(hDlg, uListID);

    if ((uListID == IDC_COPYCOMP) &&
        (AnySelection(pComp) || (!pComp->fCustomHide)))
        return FALSE;

    ZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItem.iItem = iItem;
    lvItem.pszText = pComp->szDisplayName;
    if (uListID == IDC_COPYCOMP)
        lvItem.iImage = pComp->fNoCopy ? 0 : 1;
    else
        lvItem.iImage = pComp->fCustomHide ? 0 : 1;
    ZeroMemory(&lvFind, sizeof(lvFind));
    lvFind.flags = LVFI_STRING;
    lvFind.psz = pComp->szDisplayName;

    if (ListView_FindItem(hwndList, -1, &lvFind) == -1)
    {
        ListView_InsertItem(hwndList, &lvItem);
        if (uListID == IDC_HIDECOMP)
        {
            if (pComp->fCustomHide)
            {
                if (AnySelection(pComp))
                    LoadString(g_rvInfo.hInst, IDS_STATUSFORCE, szStatus, countof(szStatus));
                else
                    LoadString(g_rvInfo.hInst, IDS_STATUSNOSHOW, szStatus, countof(szStatus));
            }
            else
                LoadString(g_rvInfo.hInst, IDS_STATUSSHOW, szStatus, countof(szStatus));

            ListView_SetItemText(hwndList, iItem, 1, szStatus);
        }
        iItem++;
    }

    return TRUE;
}

BOOL InitListControl(HWND hDlg, UINT uListID, BOOL fInit)
{
    HWND hwndList = GetDlgItem(hDlg, uListID);
    PCOMPONENT  pComp;
    LV_COLUMN lvCol;
    TCHAR szHeader[MAX_PATH];
    int iItem = 0;
    BOOL bRet = FALSE;

    ListView_DeleteAllItems(hwndList);
    if (uListID == IDC_HIDECOMP)
    {
        ListView_DeleteColumn(hwndList, 1);
        ListView_DeleteColumn(hwndList, 0);
    }

    if (!fInit)
        return TRUE;

    if (uListID == IDC_HIDECOMP)
    {
        ZeroMemory(&lvCol, sizeof(lvCol));
        lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvCol.fmt = LVCFMT_LEFT;
        lvCol.cx = 280;
        LoadString(g_rvInfo.hInst, IDS_COMPNAME, szHeader, countof(szHeader));
        lvCol.pszText = szHeader;
        ListView_InsertColumn(hwndList, 0, &lvCol);

        ZeroMemory(&lvCol, sizeof(lvCol));
        lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvCol.fmt = LVCFMT_LEFT;
        lvCol.cx = 140;
        LoadString(g_rvInfo.hInst, IDS_STATUS, szHeader, countof(szHeader));
        lvCol.pszText = szHeader;
        ListView_InsertColumn(hwndList, 1, &lvCol);
    }

    for (pComp = g_paComp; *pComp->szSection; pComp++)
    {
        if ((pComp->iImage != RED) && pComp->fVisible && !pComp->fAddOnOnly &&
            ((pComp->iCompType != COMP_OPTIONAL) ||
            ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iPlatform <= PLAT_W98))) &&
            (StrCmpI(pComp->szSection, TEXT("DCOM95")) != 0))    // dcom should always be hidden in custom mode
            bRet |= AddItemToList(pComp, hDlg, uListID, iItem);

    }

    for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
        bRet |= AddItemToList(pComp, hDlg, uListID, iItem);

    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

    return bRet;
}

void CheckItem(HWND hDlg, UINT uListID, LVITEM * plvItem, int iCheck)
{
    HWND hwndList = GetDlgItem(hDlg, uListID);
    PCOMPONENT pComp;
    BOOL fFound = FALSE;
    BOOL fCustomHide = FALSE;
    BOOL fForce = FALSE;

    for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
    {
        if (StrCmpI(plvItem->pszText, pComp->szDisplayName) == 0)
        {
            fForce = AnySelection(pComp);
            if (uListID == IDC_COPYCOMP)
                fCustomHide = (pComp->fNoCopy = ((iCheck == -1) ? !pComp->fNoCopy : (iCheck == 0)));
            else
                fCustomHide = (pComp->fCustomHide = ((iCheck == -1) ? !pComp->fCustomHide : (iCheck == 0)));
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (StrCmpI(plvItem->pszText, pComp->szDisplayName) == 0)
            {
                fForce = AnySelection(pComp);
                if (uListID == IDC_COPYCOMP)
                    fCustomHide = (pComp->fNoCopy = ((iCheck == -1) ? !pComp->fNoCopy : (iCheck == 0)));
                else
                    fCustomHide = (pComp->fCustomHide = ((iCheck == -1) ? !pComp->fCustomHide : (iCheck == 0)));
            }
        }
    }

    plvItem->mask = LVIF_IMAGE;
    plvItem->iImage = fCustomHide ? 0 : 1;

    ListView_SetItem(hwndList, plvItem);
    if (uListID == IDC_HIDECOMP)
    {
        TCHAR szStatus[64];

        if (fCustomHide)
        {
            if (fForce)
                LoadString(g_rvInfo.hInst, IDS_STATUSFORCE, szStatus, countof(szStatus));
            else
                LoadString(g_rvInfo.hInst, IDS_STATUSNOSHOW, szStatus, countof(szStatus));
        }
        else
            LoadString(g_rvInfo.hInst, IDS_STATUSSHOW, szStatus, countof(szStatus));

        ListView_SetItemText(hwndList, plvItem->iItem, 1, szStatus);
    }
}

void MaintToggleCheckItem(HWND hDlg, UINT uListID, int iItem)
{
    LVITEM lvItem;
    TCHAR szDisplayName[MAX_PATH];

    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.iItem = iItem;
    lvItem.pszText = szDisplayName;
    lvItem.cchTextMax = countof(szDisplayName);
    lvItem.mask = LVIF_TEXT;

    if (ListView_GetItem(GetDlgItem(hDlg, uListID), &lvItem))
    {
        CheckItem(hDlg, uListID, &lvItem, -1);
    }
}

void ListViewSelectAll(HWND hDlg, UINT uListID, BOOL fSet)
{
    HWND hwndList = GetDlgItem(hDlg, uListID);
    LVITEM lvItem;
    TCHAR szDisplayName[MAX_PATH];
    DWORD dwNumItems, dwIndex;

    dwNumItems = ListView_GetItemCount(hwndList);

    for (dwIndex=0; dwIndex < dwNumItems; dwIndex++)
    {
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = (int) dwIndex;
        lvItem.iSubItem = 0;
        ZeroMemory(szDisplayName, sizeof(szDisplayName));
        lvItem.pszText = szDisplayName;
        lvItem.cchTextMax = countof(szDisplayName);
        ListView_GetItem(hwndList, &lvItem);

        CheckItem(hDlg, uListID, &lvItem, fSet ? 1 : 0);
    }
}
//
//  FUNCTION: CustomizeCustom(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "Customize Custom" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
INT_PTR CALLBACK CustomizeCustom(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_HIDECOMP);
    int iItem;

    switch (message)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_HIDECOMP);
            InitList(hDlg, IDC_HIDECOMP);
            break;


        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                case IDC_HIDECHECKALL:
                    ListViewSelectAll(hDlg, IDC_HIDECOMP, TRUE);
                    break;
                case IDC_HIDEUNCHECKALL:
                    ListViewSelectAll(hDlg, IDC_HIDECOMP, FALSE);
                    break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case LVN_KEYDOWN:
                    {
                        NMLVKEYDOWN *pnm = (NMLVKEYDOWN*) lParam;
                        if ( pnm->wVKey == VK_SPACE )
                        {
                            iItem = ListView_GetSelectionMark(hwndList);
                            MaintToggleCheckItem(hDlg, IDC_HIDECOMP, iItem);
                        }
                        break;
                    }

                case NM_CLICK:
                    {
                        POINT pointScreen, pointLVClient;
                        DWORD dwPos;
                        LVHITTESTINFO HitTest;

                        dwPos = GetMessagePos();

                        pointScreen.x = LOWORD (dwPos);
                        pointScreen.y = HIWORD (dwPos);

                        pointLVClient = pointScreen;

                        // Convert the point from screen to client coordinates,
                        // relative to the Listview
                        ScreenToClient (hwndList, &pointLVClient);

                        HitTest.pt = pointLVClient;
                        ListView_HitTest(hwndList, &HitTest);

                        // Only if the user clicked on the checkbox icon/bitmap, change
                        if (HitTest.flags == LVHT_ONITEMICON)
                            MaintToggleCheckItem(hDlg, IDC_HIDECOMP, HitTest.iItem);
                    }
                    break;

                case NM_DBLCLK:
                    if ( ((LPNMHDR)lParam)->idFrom == IDC_HIDECOMP)
                    {
                        iItem = ListView_GetSelectionMark(hwndList);
                        MaintToggleCheckItem(hDlg, IDC_HIDECOMP, iItem);
                    }
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!g_fBatch)
                    {
                        BOOL fEnable = (!g_fSilent && !g_fStealth && !GetPrivateProfileInt(IS_BRANDING, TEXT("HideCustom"), 0, g_szCustIns));

                        EnableDlgItem2(hDlg, IDC_HIDECOMP, fEnable);
                        EnableDlgItem2(hDlg, IDC_HIDECHECKALL, fEnable);
                        EnableDlgItem2(hDlg, IDC_HIDEUNCHECKALL, fEnable);

                        InitHiddenItems(IDC_HIDECOMP);
                        InitListControl(hDlg, IDC_HIDECOMP, fEnable);

                        EnableDlgItem2(hDlg, IDC_WEBDLOPT, g_fDownload);
                        if (g_fDownload)
                        {
                            CheckDlgButton(hDlg, IDC_WEBDLOPT,
                                GetPrivateProfileInt(BRANDING, TEXT("NoIELite"), 1, g_szCustIns) ? BST_UNCHECKED : BST_CHECKED);
                        }
                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    if (!g_fBatch)
                    {
                        BOOL fNoIELite;

                        SaveHiddenItems(IDC_HIDECOMP);
                        if (g_fDownload)
                        {
                            fNoIELite = (IsDlgButtonChecked(hDlg, IDC_WEBDLOPT) == BST_CHECKED) ? FALSE : TRUE;
                            WritePrivateProfileString(BRANDING, TEXT("NoIELite"),
                                fNoIELite ? TEXT("1") : TEXT("0"), g_szCustIns);
                        }
                    }
                    g_iCurPage = PPAGE_CUSTOMCUSTOM;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;


                default:
                    return FALSE;

        }
        break;

        case WM_LV_GETITEMS:
            LVGetItems(GetDlgItem(hDlg, IDC_HIDECOMP));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: CopyComp(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  Processes messages for "Copy Custom" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
INT_PTR CALLBACK CopyComp(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_COPYCOMP);
    static BOOL s_fNext = TRUE;
    int iItem;

    switch (message)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_COPYCOMP);
            InitList(hDlg, IDC_COPYCOMP);
            break;


        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                case IDC_COPYCHECKALL:
                    ListViewSelectAll(hDlg, IDC_COPYCOMP, TRUE);
                    break;
                case IDC_COPYUNCHECKALL:
                    ListViewSelectAll(hDlg, IDC_COPYCOMP, FALSE);
                    break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case LVN_KEYDOWN:
                    {
                        NMLVKEYDOWN *pnm = (NMLVKEYDOWN*) lParam;
                        if ( pnm->wVKey == VK_SPACE )
                        {
                            iItem = ListView_GetSelectionMark(hwndList);
                            MaintToggleCheckItem(hDlg, IDC_COPYCOMP, iItem);
                        }
                        break;
                    }

                case NM_CLICK:
                    {
                        POINT pointScreen, pointLVClient;
                        DWORD dwPos;
                        LVHITTESTINFO HitTest;

                        dwPos = GetMessagePos();

                        pointScreen.x = LOWORD (dwPos);
                        pointScreen.y = HIWORD (dwPos);

                        pointLVClient = pointScreen;

                        // Convert the point from screen to client coordinates,
                        // relative to the Listview
                        ScreenToClient (hwndList, &pointLVClient);

                        HitTest.pt = pointLVClient;
                        ListView_HitTest(hwndList, &HitTest);

                        // Only if the user clicked on the checkbox icon/bitmap, change
                        if (HitTest.flags == LVHT_ONITEMICON)
                            MaintToggleCheckItem(hDlg, IDC_COPYCOMP, HitTest.iItem);
                    }
                    break;

                case NM_DBLCLK:
                    if ( ((LPNMHDR)lParam)->idFrom == IDC_COPYCOMP)
                    {
                        iItem = ListView_GetSelectionMark(hwndList);
                        MaintToggleCheckItem(hDlg, IDC_COPYCOMP, iItem);
                    }
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!g_fBatch)
                    {
                        InitHiddenItems(IDC_COPYCOMP);
                        if (!g_fDownload && (g_fSilent || g_fStealth || InsGetBool(IS_BRANDING, TEXT("HideCustom"), FALSE, g_szCustIns)))
                            InitHiddenItems(IDC_HIDECOMP);

                        if (!InitListControl(hDlg, IDC_COPYCOMP, TRUE))
                        {
                            if (s_fNext)
                                PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, PSBTN_NEXT, 0);
                            else
                                PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, PSBTN_BACK, 0);
                        }
                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    if (!g_fBatch)
                        SaveHiddenItems(IDC_COPYCOMP);

                    g_iCurPage = PPAGE_COPYCOMP;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    {
                        s_fNext = FALSE;
                        PageNext(hDlg);
                    }
                    else
                    {
                        s_fNext = TRUE;
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;


                default:
                    return FALSE;

        }
        break;

        case WM_LV_GETITEMS:
            LVGetItems(GetDlgItem(hDlg, IDC_COPYCOMP));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL g_fUrlsInit = FALSE;

static IDownloadSiteMgr * s_pSiteMgr = NULL;

static int s_aiSites[NUMSITES];

static BOOL s_fInChange = FALSE;

void SetCustSite(HWND hDlg, int iSite)
{
    PSITEDATA psd = &g_aCustSites[iSite];
    HWND hBaseUList = GetDlgItem(hDlg, IDC_BASEURLLIST);
    LV_ITEM lvItem;

    s_fInChange = TRUE;
    ZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iSite;
    lvItem.pszText = psd->szName;
    ListView_SetItem(hBaseUList, &lvItem);
    lvItem.iSubItem = 1;
    lvItem.pszText = psd->szUrl;
    ListView_SetItem(hBaseUList, &lvItem);
    lvItem.pszText = psd->szRegion;
    lvItem.iSubItem = 2;
    ListView_SetItem(hBaseUList, &lvItem);
    s_fInChange = FALSE;
}

void CopyAdmFiles()
{
    TCHAR szAdmSrcPath[MAX_PATH];
    TCHAR szAdmSrcFile[MAX_PATH];
    TCHAR szAdmDestFile[MAX_PATH];
    HANDLE hFind = NULL;
    WIN32_FIND_DATA wfdFind;
    BOOL bDirCreated = FALSE;

    PathCombine(szAdmSrcPath, g_szWizRoot, TEXT("iebin"));
    PathAppend(szAdmSrcPath, g_szLanguage);
    PathAppend(szAdmSrcPath, TEXT("optional"));
    PathAppend(szAdmSrcPath, TEXT("*.adm"));

    hFind = FindFirstFile( szAdmSrcPath, &wfdFind );
    if( hFind == INVALID_HANDLE_VALUE )
        return;

    do
    {
        StrCpy(szAdmSrcFile, szAdmSrcPath);
        PathRemoveFileSpec(szAdmSrcFile);
        PathAppend(szAdmSrcFile, wfdFind.cFileName);
        PathCombine(szAdmDestFile, g_szWizRoot, TEXT("policies"));
        PathAppend(szAdmDestFile, g_szLanguage);
        if(!bDirCreated)
        {
            PathCreatePath(szAdmDestFile);
            bDirCreated = TRUE;
        }
        PathAppend(szAdmDestFile, wfdFind.cFileName);
        CopyFile(szAdmSrcFile, szAdmDestFile, FALSE);
        DeleteFile(szAdmSrcFile);
    }while( FindNextFile( hFind, &wfdFind ));

    FindClose(hFind);
}

void SaveDownloadUrls()
{
    int iBase = s_aiSites[0];
    TCHAR szIEAKCabUrl[MAX_URL];
    TCHAR szCabPath[MAX_PATH];
    BOOL fDownloadOpt = TRUE;
    BOOL fIgnore = FALSE;
    static BOOL s_fFirst = TRUE;
    TCHAR szVersionNew[32];
    TCHAR szOptIniFile[MAX_PATH];
    s_fNoNet = FALSE;
    ICifComponent * pCifComponent;

    ResetEvent(g_hProcessInfEvent);

    if (!g_fBatch2)
    {
        if (s_pSiteMgr)
        {
            DOWNLOADSITE *pSite;
            IDownloadSite *pISite;
            TCHAR   szLang[8];

            for (int i=0; i<NUMSITES; i++) 
            {
                s_pSiteMgr->EnumSites(i, &pISite);
                if (!pISite) break;
                pISite->GetData(&pSite);
                A2Tbux(pSite->pszLang, szLang);
                if (0 == StrCmpI(szLang, g_szActLang)) {
                    A2Tbux(pSite->pszUrl, g_szBaseURL);
                    break;
                }
                pISite->Release();
            }
        }
        PathCombine(g_szMastInf, g_szWizRoot, TEXT("iebin"));
        PathAppend(g_szMastInf, g_szLanguage);
        PathAppend(g_szMastInf, TEXT("Optional"));
        PathCreatePath(g_szMastInf);
        PathRemoveBackslash(g_szMastInf);
    }

    // wait for cif to be downloaded so we can check version

    while (MsgWaitForMultipleObjects(1, &g_hCifEvent, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        MSG msg;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if (g_lpCifFileNew != NULL)
    {
        if (!g_fLocalMode)
        {
            // check version before downloading opt cab

            if (SUCCEEDED(g_lpCifFileNew->FindComponent(TEXT("IEAK6OPT"), &pCifComponent)))
            {
                DWORD dwVer, dwBuild;
                TCHAR szVersion[32];

                PathCombine(szOptIniFile, g_szMastInf, TEXT("ieak6opt.ini"));
                pCifComponent->GetVersion(&dwVer, &dwBuild);
                ConvertDwordsToVersionStr(szVersionNew, dwVer, dwBuild);
                GetPrivateProfileString(TEXT("ieak6OPT"), VERSION, TEXT("-1"), szVersion, countof(szVersion), szOptIniFile);

                if ((StrCmp(szVersion, TEXT("-1")) != 0) &&
                    (StrCmpI(szVersion, szVersionNew) == 0))  // is opt cab up to date ?
                    fDownloadOpt = FALSE;
            }
        }
    }

    if (!g_fLocalMode && s_fFirst)
    {
        s_fFirst = FALSE;
        wnsprintf(szIEAKCabUrl, countof(szIEAKCabUrl), TEXT("%s/ieak6opt.cab"), g_szBaseURL);
        PathCombine(szCabPath, g_szBuildTemp, TEXT("ieak6opt.cab"));
        if (fDownloadOpt)
        {
            // if we are attempting to download the opt cab, delete iesetup.inf in the opt dir
            // first and we'll use this as a flag to determine whether or not download &
            // extraction succeeded
            // Also delete ieak6opt.ini. In case the download fails, this will force a download 
            // next time ieak runs. Otherwise iesetup.inf never get created.
            // See bug 13467-IEv60  
            DeleteFileInDir(TEXT("iesetup.inf"), g_szMastInf);
            DeleteFileInDir(TEXT("ieak6opt.ini"), g_szMastInf);
            if (DownloadCab(g_hWizard, szIEAKCabUrl, szCabPath, NULL, 0, fIgnore) == NOERROR)
            {
                if (ExtractFilesWrap(szCabPath, g_szMastInf, 0, NULL, NULL, 0) != NOERROR)
                    DeleteFileInDir(TEXT("iesetup.inf"), g_szMastInf);
                else
                {
                    SetCurrentDirectory( g_szMastInf);
                    SetAttribAllEx(g_szMastInf, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);
                    CopyAdmFiles();
                    WritePrivateProfileString(TEXT("ieak6OPT"), VERSION, szVersionNew, szOptIniFile);
                }

                // delete the downloaded ieak6opt.cab from the temp dir so we don't copy
                // it to the target folder during the build process later

                DeleteFile(szCabPath);
            }
        }
    }
    PathCombine(g_szDefInf, g_szMastInf, TEXT("DefFav.inf"));
    PathAppend(g_szMastInf, TEXT("IeSetup.Inf"));
    PathCombine(g_szCustInf, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCustInf, GetOutputPlatformDir());
    PathAppend(g_szCustInf, g_szLanguage);
    PathAppend(g_szCustInf, TEXT("IESetup.inf"));

    if (GetFileAttributes(g_szCustInf) == 0xFFFFFFFF)
    {
        CopyFile(g_szMastInf, g_szCustInf, FALSE);
    }
    else
    {
        UpdateInf(g_szMastInf, g_szCustInf);
    }
    SetEvent(g_hProcessInfEvent);
}

void GetSiteDataPath(void)
{
    TCHAR szIEAKIni[MAX_PATH];

    PathCombine(szIEAKIni, g_szWizRoot, TEXT("ieak.ini"));

    switch (g_dwPlatformId)
    {
    case PLATFORM_WIN32:
    default:
        GetPrivateProfileString(TEXT("IEAK"), TEXT("Win32"), TEXT(""), s_szSiteData, countof(s_szSiteData), szIEAKIni);
        break;
    }
}


void IE4BatchSetup()
{
    TCHAR szSectBuf[1024];
    TCHAR szSrcCustInf[MAX_PATH];
    DWORD sWrk, sCif;
    PCOMPONENT pComp;
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    LPTSTR pBack;
    int nComp;

    PathCombine(g_szCustInf, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCustInf, GetOutputPlatformDir());
    PathAppend(g_szCustInf, g_szLanguage);
    PathCreatePath(g_szCustInf);

    PathCombine(szSrcCustInf, g_szSrcRoot, TEXT("INS"));
    PathAppend(szSrcCustInf, GetOutputPlatformDir());
    PathAppend(szSrcCustInf, g_szLanguage);

    if (g_fBatch2)
    {
        StrCpy(g_szBaseURL,g_szSrcRoot);
        StrCpy(g_szMastInf,g_szCustInf);

        s_fNoNet = FALSE;
    }

    if (g_fBatch2 && PathFileExists(szSrcCustInf) && PathFileExists(g_szCustInf))
    {
        CopyFilesSrcToDest(szSrcCustInf, TEXT("*.inf"), g_szCustInf);
        CopyFilesSrcToDest(szSrcCustInf, TEXT("*.ins"), g_szCustInf);
        CopyFilesSrcToDest(szSrcCustInf, TEXT("*.cif"), g_szCustInf);
        CopyFilesSrcToDest(szSrcCustInf, TEXT("*.in_"), g_szCustInf);
    }

    PathAppend(g_szCustInf, TEXT("IESetup.inf"));

    // initialize deffav.inf path
    PathCombine(g_szDefInf, g_szWizRoot, TEXT("IEBIN"));
    PathAppend(g_szDefInf, g_szLanguage);
    PathAppend(g_szDefInf, TEXT("OPTIONAL\\DEFFAV.INF"));
    PathCombine(g_szMastInf, g_szWizRoot, TEXT("IESetup.inf"));
    if ((hFind = FindFirstFile( g_szCustInf, &fd )) == INVALID_HANDLE_VALUE)
    {
        CopyFile(g_szMastInf, g_szCustInf, FALSE);
    }
    else
        FindClose(hFind);
    GetSiteDataPath();

    InitCustComponents(NULL);
    sWrk = MAX_PATH;

    GetModuleFileName( NULL, g_szIEAKProg, MAX_PATH );
    pBack = StrRChr(g_szIEAKProg, NULL, TEXT('\\'));
    if (pBack)
        *pBack = TEXT('\0');
    PathAppend(g_szIEAKProg, TEXT("Download"));
    PathAppend(g_szIEAKProg, g_szLanguage);
    PathCreatePath(g_szIEAKProg);
    PathCombine(g_szCif, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCif, GetOutputPlatformDir());
    PathAppend(g_szCif, g_szLanguage);
    PathAppend(g_szCif, TEXT("IESetup.cif"));
    if (!PathFileExists(g_szCif))
    {
        TCHAR szCifFile[MAX_PATH];

        PathCombine(szCifFile, g_szIEAKProg, TEXT("IESetup.cif"));
        CopyFile(szCifFile, g_szCif, FALSE);
    }

    StrCpy(s_szCifCabURL, g_szBaseURL);
    StrCat(s_szCifCabURL, TEXT("/IECIF.CAB"));
    StrCpy(s_szCifNew, g_szIEAKProg);
    PathAppend(s_szCifNew, TEXT("new"));
    PathCreatePath(s_szCifNew);
    PathAppend(s_szCifNew, TEXT("IEsetup.cif"));

    {
        IEnumCifModes * pEnumCifModes;
        ICifComponent * pCifComponent;

        GetICifFileFromFile_t(&g_lpCifFileNew, s_szCifNew);
        GetICifRWFileFromFile_t(&g_lpCifRWFile, g_szCif);

        if (!g_lpCifRWFile)
        {
            if (g_hLogFile)
            {
                TCHAR szError[MAX_PATH];
                DWORD dwNumWritten;
                LoadString(g_rvInfo.hInst,IDS_ERROR_CIFRWFILE,szError,MAX_PATH);
                WriteFile(g_hLogFile,szError,StrLen(szError),&dwNumWritten,NULL);
            }    
            return;
        }


        // initialie set of modes

        if (SUCCEEDED(g_lpCifRWFile->EnumModes(&pEnumCifModes,
            PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL)))
        {
            TCHAR szModeID[64];
            ICifMode * pCifMode;
            int i=0;

            while (SUCCEEDED(pEnumCifModes->Next(&pCifMode)))
            {
                CCifMode_t * pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);

                pCifMode_t->GetID(szModeID, countof(szModeID));
                g_szAllModes[i] = szModeID[0];
                i++;
                delete pCifMode_t;
            }
            pEnumCifModes->Release();
        }

        // initialize version number
        if (SUCCEEDED(g_lpCifRWFile->FindComponent(BASEWIN32, &pCifComponent)) ||
            SUCCEEDED(g_lpCifRWFile->FindComponent(TEXT("BASEIE40_NTAlpha"), &pCifComponent)))
        {
            DWORD dwVer, dwBuild;

            pCifComponent->GetVersion(&dwVer, &dwBuild);
            ConvertDwordsToVersionStr(g_szJobVersion, dwVer, dwBuild);
        }
    }
    
    sCif = GetPrivateProfileString( NULL, NULL, NULL, szSectBuf, countof(szSectBuf), s_szCifNew );
    nComp = 20 + sCif/4;
    pComp = g_paComp = (PCOMPONENT) LocalAlloc(LPTR, nComp * sizeof(COMPONENT) );
    ZeroMemory(g_paComp, nComp * sizeof(COMPONENT));
}


void UpdateInf(LPTSTR szMasterInf, LPTSTR szUserInf)
{
    TCHAR szInfBack[MAX_PATH];
    LPTSTR pDot, pBuf, pParm;
    SetFileAttributes(szUserInf, FILE_ATTRIBUTE_NORMAL);
    StrCpy(szInfBack, szUserInf);
    pDot = StrRChr(szInfBack, NULL, TEXT('.'));
    if (!pDot) return;
    StrCpy(pDot, TEXT(".bak"));
    DeleteFile( szInfBack );
    MoveFile( szUserInf, szInfBack );
    CopyFile(szMasterInf, szUserInf, FALSE);
    SetFileAttributes(szUserInf, FILE_ATTRIBUTE_NORMAL);
    pBuf = (LPTSTR) LocalAlloc(LPTR, INF_BUF_SIZE);
    if (pBuf)
    {
        GetPrivateProfileString( STRINGS, NULL, TEXT(""), pBuf, ARRAYSIZE(pBuf), szInfBack );
        pParm = pBuf;
        while (*pParm)
        {
            TCHAR szValBuf[MAX_PATH];
            GetPrivateProfileString( STRINGS, pParm, TEXT(""), szValBuf, countof(szValBuf), szInfBack );
            InsWriteQuotedString( STRINGS, pParm, szValBuf, szUserInf );
            pParm += lstrlen(pParm) + 1;
        }
        LocalFree(pBuf);
    }
}

BOOL GotLang(LPTSTR szLang)
{
    int i;

    for (i = 0; i < g_nLangs ; i++ )
    {
        if (StrCmpI(szLang, g_aszLang[i]) == 0) return(TRUE);

    }
    return(FALSE);

}

extern DWORD g_aLangId[];
extern DWORD g_wCurLang;

DWORD DownloadSiteThreadProc(LPVOID)
{
    int i;
    TCHAR szBuf[8];
    TCHAR szLang[8];
    TCHAR szLocaleIni[MAX_PATH];
    DWORD dwErr;
    HWND hBaseUList;
    WIN32_FIND_DATA fd;
    DWORD dwRet = WAIT_OBJECT_0;
    MSG msg;
    LPMULTILANGUAGE pMLang = NULL;
    int iEnglish = 0, iCurLang = 0;

    USES_CONVERSION;

    CoInitialize(NULL);
    g_fCancelled = FALSE;
    dwErr = CoCreateInstance(CLSID_DownloadSiteMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IDownloadSiteMgr, (void **) &s_pSiteMgr);
    if(!s_pSiteMgr)
    {
        dwErr = GetLastError();
        g_fLangInit = TRUE;
        SendMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
        PropSheet_SetWizButtons(GetParent(g_hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        CoUninitialize();
        return(dwErr);
    }
    g_hDownloadEvent = CreateEvent( NULL, FALSE, FALSE, TEXT("SiteMgrEvent") );
    g_hProcessInfEvent = CreateEvent( NULL, TRUE, FALSE, TEXT("ProcessInfEvent") );
    g_hCifEvent = CreateEvent( NULL, TRUE, FALSE, TEXT("CifEvent") );

    GetSiteDataPath();

    while (!(g_fDone || g_fCancelled))
    {
        if (dwRet == WAIT_OBJECT_0) switch (g_iDownloadState)
        {
            case DOWN_STATE_IDLE:
                break;
            case DOWN_STATE_ENUM_LANG:
                wnsprintf(szBuf, countof(szBuf), TEXT("%04lx"), g_wCurLang);
                PathCombine(szLocaleIni, g_szWizRoot, TEXT("Locale.INI"));
                if (GetPrivateProfileString( IS_ACTIVESETUP, szBuf, TEXT(""), g_szActLang,
                    countof(g_szActLang), szLocaleIni ) == 0)
                {
                    // check for sublocale defaults
                    GetPrivateProfileString( TEXT("SubLocales"), szBuf, TEXT("EN"), g_szActLang,
                    countof(g_szActLang), szLocaleIni );
                }

                iCurLang = -1;
                dwErr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER,
                    IID_IMultiLanguage, (void **) &pMLang);
                if (!g_fLocalMode)
                {
                    TCHAR szMsg[MAX_PATH];

                    LoadString(g_rvInfo.hInst, IDS_AVSINITFAIL, szMsg, countof(szMsg));
                    do
                    {
                        CHAR szSiteDataA[MAX_PATH];

                        dwErr = s_pSiteMgr->Initialize(T2Abux(s_szSiteData, szSiteDataA),  NULL);
                    }
                    while ((dwErr != NOERROR) && (MessageBox(g_hDlg, szMsg, g_szTitle, MB_RETRYCANCEL) == IDRETRY));
                }
                if (dwErr != NOERROR)
                {
                    s_pSiteMgr->Release();
                    s_pSiteMgr = NULL;
                    g_fLocalMode = TRUE;
                }
                if (!g_fLocalMode)
                {
                    for (i = 0, g_nLangs = 0;  ; i++ )
                    {
                        DOWNLOADSITE *pSite;
                        IDownloadSite *pISite;
                        if (!s_pSiteMgr) break;
                        s_pSiteMgr->EnumSites(i, &pISite);
                        if (!pISite) break;
                        pISite->GetData(&pSite);
                        A2Tbux(pSite->pszLang, szLang);
                        if (StrCmpI(szLang, TEXT("US")) == 0)
                            StrCpy(szLang, TEXT("EN"));

                        if (!GotLang(szLang))
                        {
                            if (StrCmpI(szLang, g_szActLang) == 0) iCurLang = g_nLangs;
                            if (StrCmpI(szLang, TEXT("EN")) == 0) iEnglish = g_nLangs;
                            StrCpy(g_aszLang[g_nLangs], szLang);
                            GetPrivateProfileString(IS_STRINGS, szLang, TEXT(""), s_aszLangDesc[g_nLangs], 64, szLocaleIni);
                            if (pMLang)
                            {
                                RFC1766INFO rInfo;
                                LCID lcid;

                                CharLower(szLang);
                                if ((dwErr = GetLcid(&lcid, szLang, szLocaleIni)) == NOERROR)
                                {
                                    g_aLangId[g_nLangs] = lcid;
                                    if (ISNULL(s_aszLangDesc[g_nLangs]))
                                    {
                                        dwErr = pMLang->GetRfc1766Info(lcid, &rInfo);
                                        W2Tbux(rInfo.wszLocaleName, s_aszLangDesc[g_nLangs]);
                                    }
                                }
                            }
                            if (dwErr == NOERROR)
                                SendDlgItemMessage(g_hDlg, IDC_LANGUAGE, CB_ADDSTRING, 0, (LPARAM)s_aszLangDesc[g_nLangs++] );
                            if (g_nLangs >= NUMLANG) break;
                        }
                    }
                    if (iCurLang == -1) iCurLang = iEnglish;
                    if (pMLang) pMLang->Release();
                }
                else
                {
                    TCHAR szDownloadDir[MAX_PATH];
                    BOOL fNoMore = FALSE;
                    HANDLE hFind = NULL;

                    for (i = 0, g_nLangs = 0;  ; i++ )
                    {
                        if (hFind == NULL)
                        {
                            PathCombine(szDownloadDir, g_szIEAKProg, TEXT("*.*"));
                            hFind = FindFirstFile(szDownloadDir, &fd);
                        }
                        else
                            fNoMore = FindNextFile(hFind, &fd) ? FALSE : TRUE;

                        while (!fNoMore && (hFind != INVALID_HANDLE_VALUE) && (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            || (StrCmp(fd.cFileName, TEXT(".")) == 0) || (StrCmp(fd.cFileName, TEXT("..")) == 0)))
                        {
                            if (!FindNextFile(hFind, &fd))
                            {
                                fNoMore = TRUE;
                                break;
                            }
                        }

                        if (fNoMore)
                        {
                            FindClose(hFind);
                            break;
                        }

                        if (hFind == INVALID_HANDLE_VALUE)
                            break;

                        if (StrCmpI(fd.cFileName, g_szActLang) == 0) iCurLang = g_nLangs;
                        if (StrCmpI(fd.cFileName, TEXT("EN")) == 0) iEnglish = g_nLangs;
                        StrCpy(g_aszLang[g_nLangs], fd.cFileName);
                        GetPrivateProfileString(IS_STRINGS, fd.cFileName, TEXT(""), s_aszLangDesc[g_nLangs], 64, szLocaleIni);
                        if (pMLang)
                        {
                            RFC1766INFO rInfo;
                            LCID lcid;

                            CharLower(fd.cFileName);
                            if ((dwErr = GetLcid(&lcid, fd.cFileName, szLocaleIni)) == NOERROR)
                            {
                                g_aLangId[g_nLangs] = lcid;
                                if (ISNULL(s_aszLangDesc[g_nLangs]))
                                {
                                    dwErr = pMLang->GetRfc1766Info(lcid, &rInfo);
                                    W2Tbux(rInfo.wszLocaleName, s_aszLangDesc[g_nLangs]);
                                }
                            }
                        }
                        if (dwErr == NOERROR)
                            SendDlgItemMessage(g_hDlg, IDC_LANGUAGE, CB_ADDSTRING, 0, (LPARAM)s_aszLangDesc[g_nLangs++] );
                        if (g_nLangs >= NUMLANG) break;
                    }
                    if (iCurLang == -1) iCurLang = iEnglish;
                }
                SendDlgItemMessage( g_hDlg, IDC_LANGUAGE, CB_SETCURSEL, iCurLang, 0 );
                g_fLangInit = TRUE;
                SendMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
                PropSheet_SetWizButtons(GetParent(g_hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                g_iDownloadState = DOWN_STATE_IDLE;
                break;
            case DOWN_STATE_ENUM_URL:
                hBaseUList = GetDlgItem(g_hDlg, IDC_BASEURLLIST);
                if (*g_szLanguage == TEXT('\\'))
                    StrCpy(szBuf, g_szLanguage + 1);
                else
                    StrCpy(szBuf, g_szLanguage);
                szBuf[2] = TEXT('\0');
                if (s_pSiteMgr)
                {
                    int iSite = 0;
                    SendDlgItemMessage(g_hDlg, IDC_DOWNLOADLIST, CB_RESETCONTENT, 0, 0);
                    for (i = 0; ; i++)
                    {
                        DOWNLOADSITE *pSite;
                        IDownloadSite *pISite;
                        if (!s_pSiteMgr)
                            break;
                        s_pSiteMgr->EnumSites(i, &pISite);
                        if (!pISite)
                            break;
                        pISite->GetData(&pSite);
                        A2Tbux(pSite->pszLang, szLang);

                        if (StrCmpI(szLang, szBuf) == 0)
                        {
                            TCHAR szFriendlyName[MAX_PATH];

                            s_aiSites[iSite++] = i;
                            A2Tbux(pSite->pszFriendlyName, szFriendlyName);
                            SendDlgItemMessage(g_hDlg, IDC_DOWNLOADLIST, CB_ADDSTRING,
                                0, (LPARAM) szFriendlyName );
                        }
                        pISite->Release();
                        if (iSite >= NUMSITES)
                            break;
                    }
                }
                g_fUrlsInit = TRUE;
                SendDlgItemMessage( g_hDlg, IDC_DOWNLOADLIST, CB_SETCURSEL, 0, 0L );
                SetFocus( hBaseUList );
                SendMessage(g_hDlg, IDM_INITIALIZE, 0, 0 );
                PropSheet_SetWizButtons(GetParent(g_hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                g_iDownloadState = DOWN_STATE_IDLE;
                break;
            case DOWN_STATE_SAVE_URL:
                SaveDownloadUrls();
                g_iDownloadState = DOWN_STATE_IDLE;
                break;
        }
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        dwRet = MsgWaitForMultipleObjects(1, &g_hDownloadEvent, FALSE, INFINITE, QS_ALLINPUT);
    }
    if (s_pSiteMgr) s_pSiteMgr->Release();
    s_pSiteMgr = 0;
    if (s_hInet)
    {
        InternetCloseHandle(s_hInet);
        s_hInet = NULL;
    }
    CloseHandle(g_hDownloadEvent);
    CloseHandle(g_hProcessInfEvent);
    CloseHandle(g_hCifEvent);
    g_hDownloadEvent = 0;
    g_hProcessInfEvent = 0;
    g_hCifEvent = 0;
    CoUninitialize();
    return(0);

}

void InitializeUserDownloadSites(HWND hDlg)
{
    int i;
    HWND hBaseUList = GetDlgItem(hDlg, IDC_BASEURLLIST);
    LV_COLUMN lvCol;
    TCHAR szColHead[80];
    PSITEDATA psd;

    if (hDlg != NULL)
    {
        ZeroMemory(&lvCol, sizeof(lvCol));
        lvCol.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        lvCol.fmt = LVCFMT_LEFT;
        lvCol.cx = 80;
        lvCol.pszText = szColHead;
        LoadString( g_rvInfo.hInst, IDS_DOWNSITEREGION, szColHead, countof(szColHead) );
        lvCol.iSubItem = 3;
        ListView_InsertColumn(hBaseUList, 0, &lvCol);
        lvCol.cx = 125;
        lvCol.iSubItem = 2;
        LoadString( g_rvInfo.hInst, IDS_DOWNSITEURL, szColHead, countof(szColHead) );
        ListView_InsertColumn(hBaseUList, 0, &lvCol);
        lvCol.cx = 125;
        lvCol.iSubItem = 1;
        LoadString( g_rvInfo.hInst, IDS_DOWNSITENAME, szColHead, countof(szColHead) );
        ListView_InsertColumn(hBaseUList, 0, &lvCol);
    }
    for (i = 0, psd = g_aCustSites; ; i++, psd++ )
    {
        TCHAR szBaseUrlParm[32];
        LV_ITEM lvItem;
        LPTSTR pSlash;

        ZeroMemory(psd, sizeof(SITEDATA));
        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteName%i"), i);
        GetPrivateProfileString(IS_ACTIVESETUP_SITES, szBaseUrlParm, TEXT(""), psd->szName, 80, g_szCustIns );
        if (ISNULL(psd->szName)) break;
        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteUrl%i"), i);
        GetPrivateProfileString(IS_ACTIVESETUP_SITES, szBaseUrlParm, TEXT(""), psd->szUrl, MAX_URL, g_szCustIns );
        pSlash = StrRChr(psd->szUrl, NULL, TEXT('/'));
        if (pSlash != NULL)
        {
            if (StrCmpI(pSlash, TEXT("/WIN32")) == 0)
            {
                LPTSTR pOld = pSlash;

                *pSlash = TEXT('\0');
                pSlash = StrRChr(psd->szUrl, NULL, TEXT('/'));
                if (pSlash != NULL)
                {
                    if (StrCmpI(pSlash, TEXT("/DOWNLOAD")) == 0)
                    {
                        *pSlash = TEXT('\0');
                    }
                    else
                        *pOld = TEXT('/');
                }
            }
        }
        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteRegion%i"), i);
        GetPrivateProfileString(IS_ACTIVESETUP_SITES, szBaseUrlParm, TEXT(""), psd->szRegion, 80, g_szCustIns );
        g_nDownloadUrls++;

        if (hDlg != NULL)
        {
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = i;
            lvItem.pszText = psd->szName;
            ListView_InsertItem(hBaseUList, &lvItem);
            lvItem.iSubItem = 1;
            lvItem.pszText = psd->szUrl;
            ListView_SetItem(hBaseUList, &lvItem);
            lvItem.pszText = psd->szRegion;
            lvItem.iSubItem = 2;
            ListView_SetItem(hBaseUList, &lvItem);
        }
    }

    if (hDlg != NULL)
    {
        if (g_nDownloadUrls)
        {
            SetDlgItemText( hDlg, IDE_DOWNSITENAME, g_aCustSites->szName );
            SetDlgItemText( hDlg, IDE_DOWNSITEURL, g_aCustSites->szUrl );
            SetDlgItemText( hDlg, IDE_DOWNSITEREGION, g_aCustSites->szRegion );
        }
        else
        {
            DisableDlgItem(hDlg, IDE_DOWNSITENAME);
            DisableDlgItem(hDlg, IDE_DOWNSITEURL);
            DisableDlgItem(hDlg, IDE_DOWNSITEREGION);
            DisableDlgItem(hDlg, IDC_DOWNSITENAME_TXT);
            DisableDlgItem(hDlg, IDC_DOWNSITEURL_TXT);
            DisableDlgItem(hDlg, IDC_DOWNSITEREGION_TXT);
        }
        ListView_SetItemState(hBaseUList, 0, LVIS_SELECTED | LVIS_FOCUSED,
            LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void SetDownloadSiteEditControls(HWND hDlg, int nSite)
{
    if (nSite >= 0)
    {
        PSITEDATA psd = &g_aCustSites[nSite];

        SetDlgItemText( hDlg, IDE_DOWNSITENAME, psd->szName );
        SetDlgItemText( hDlg, IDE_DOWNSITEURL, psd->szUrl );
        SetDlgItemText( hDlg, IDE_DOWNSITEREGION, psd->szRegion );
    }
    else
    {
        SetDlgItemText( hDlg, IDE_DOWNSITENAME, TEXT("") );
        SetDlgItemText( hDlg, IDE_DOWNSITEURL, TEXT("") );
        SetDlgItemText( hDlg, IDE_DOWNSITEREGION, TEXT("") );
    }
}

//
//  FUNCTION: ComponentSelect(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "ComponentSelect" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
//
INT_PTR CALLBACK ComponentUrls(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szDownTpl[MAX_PATH];
    LV_ITEM lvItem;
    HWND hUrlList = GetDlgItem( hDlg, IDC_BASEURLLIST);
    PSITEDATA psd = &g_aCustSites[g_iSelSite];
    static BOOL s_fNext = TRUE;
    static BOOL s_fUserSitesInit = FALSE;
    static BOOL s_fErrMessageShown = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            EnableDBCSChars( hDlg, IDC_BASEURLLIST);
            EnableDBCSChars( hDlg, IDE_DOWNSITENAME);
            EnableDBCSChars( hDlg, IDE_DOWNSITEREGION);
            EnableDBCSChars( hDlg, IDE_DOWNSITEURL );
            break;

        case IDM_INITIALIZE:
            if ((g_hWait != NULL) && g_fUrlsInit)
            {
                SendMessage(g_hWait, WM_CLOSE, 0, 0);
                g_hWait = NULL;
            }
            break;

        case WM_DESTROY:
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                int i;
                switch (LOWORD(wParam))
                {
                    case IDC_ADDBASEURL:
                        if (g_nDownloadUrls && 
                            IsWindowEnabled(GetDlgItem(hDlg, IDE_DOWNSITENAME)) &&
                            (!CheckField(hDlg, IDE_DOWNSITENAME, FC_NONNULL) ||
                            !CheckField(hDlg, IDE_DOWNSITEURL, FC_NONNULL | FC_URL) ||
                            !CheckField(hDlg, IDE_DOWNSITEREGION, FC_NONNULL)))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }

                        ZeroMemory(&lvItem, sizeof(lvItem));
                        lvItem.mask = LVIF_TEXT;
                        ListView_SetItemState(hUrlList, g_iSelSite, LVIS_SELECTED | LVIS_FOCUSED, 0);
                        lvItem.iItem = g_iSelSite = g_nDownloadUrls;
                        psd = &g_aCustSites[g_nDownloadUrls];
                        lvItem.pszText = psd->szName;
                        LoadString( g_rvInfo.hInst, IDS_DOWNLOADURL, szDownTpl, 80 );
                        wnsprintf(psd->szUrl, countof(psd->szUrl), TEXT("http://%s%i"), szDownTpl, g_nDownloadUrls);
                        LoadString( g_rvInfo.hInst, IDS_DOWNLOADSITE, szDownTpl, 80 );
                        wnsprintf(psd->szName, countof(psd->szName), TEXT("%s%i"), szDownTpl, g_nDownloadUrls++);
                        LoadString( g_rvInfo.hInst, IDS_NORTHAMERICA, psd->szRegion, 80 );
                        ListView_InsertItem(hUrlList, &lvItem);
                        SetCustSite(hDlg, g_iSelSite);
                        ListView_SetItemState(hUrlList, g_iSelSite,
                            LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        if (!IsWindowEnabled(GetDlgItem(GetParent(hDlg), IDC_NEXT)))
                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                        EnableDlgItem(hDlg, IDE_DOWNSITENAME);
                        EnableDlgItem(hDlg, IDE_DOWNSITEURL);
                        EnableDlgItem(hDlg, IDE_DOWNSITEREGION);
                        EnableDlgItem(hDlg, IDC_REMOVEBASEURL);
                        EnableDlgItem(hDlg, IDC_DOWNSITENAME_TXT);
                        EnableDlgItem(hDlg, IDC_DOWNSITEURL_TXT);
                        EnableDlgItem(hDlg, IDC_DOWNSITEREGION_TXT);

                        SetFocus(GetDlgItem( hDlg, IDE_DOWNSITENAME));
                        EnableDlgItem2(hDlg, IDC_ADDBASEURL, (g_nDownloadUrls < ((g_fIntranet && (g_fSilent || g_fStealth)) ? 1 : 10)));
                        SendMessage(GetDlgItem( hDlg, IDE_DOWNSITENAME), EM_SETSEL, 0, -1);
                        break;

                    case IDC_REMOVEBASEURL:
                        s_fInChange = TRUE;
                        if(ListView_DeleteItem(hUrlList, g_iSelSite))
                        {
                            for (i = g_iSelSite; i <= g_nDownloadUrls ; i++)
                            {
                                g_aCustSites[i] = g_aCustSites[i + 1];
                            }
                            g_nDownloadUrls--;
                        }
                        s_fInChange = FALSE;

                        EnableDlgItem2(hDlg, IDC_ADDBASEURL, (g_nDownloadUrls < ((g_fIntranet && (g_fSilent || g_fStealth)) ? 1 : 10)));
                        if (g_nDownloadUrls == 0) {
                            int rgids[] = { IDE_DOWNSITENAME, IDE_DOWNSITEURL, IDE_DOWNSITEREGION, IDC_REMOVEBASEURL };
                            int rgtxtids[] = { IDC_DOWNSITENAME_TXT, IDC_DOWNSITEURL_TXT, IDC_DOWNSITEREGION_TXT };

                            ZeroMemory(g_aCustSites, sizeof(COMPONENT));

                            EnsureDialogFocus(hDlg, rgids, countof(rgids), IDC_ADDBASEURL);
                            DisableDlgItems  (hDlg, rgids, countof(rgids));
                            DisableDlgItems  (hDlg, rgtxtids, countof(rgtxtids));

                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                        }
                        if (g_iSelSite >= g_nDownloadUrls) g_iSelSite--;
                        SetDownloadSiteEditControls(hDlg, g_iSelSite);
                        ListView_SetItemState(hUrlList, g_iSelSite,
                            LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        break;
                }
            }
            else if (HIWORD(wParam) == EN_CHANGE)
            {
                switch (LOWORD(wParam))
                {
                    case IDE_DOWNSITENAME:
                        GetDlgItemText( hDlg, IDE_DOWNSITENAME, psd->szName, countof(psd->szName) );
                        break;
                    case IDE_DOWNSITEURL:
                        GetDlgItemText( hDlg, IDE_DOWNSITEURL, psd->szUrl, countof(psd->szUrl) );
                        break;
                    case IDE_DOWNSITEREGION:
                        GetDlgItemText( hDlg, IDE_DOWNSITEREGION, psd->szRegion, countof(psd->szRegion) );
                        break;
                }
                SetCustSite(hDlg, g_iSelSite);

            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                int i;

                case LVN_ITEMCHANGED:
                case LVN_ITEMCHANGING:
                    if (s_fInChange) break;

                    // BUGBUG: <oliverl> crazy hack to eat up the second LVN_ITEMCHANGING
                    //          msg we get in the error case.  I can't figure out any way
                    //          to distinguish the two.

                    if ((g_nDownloadUrls > 1) && s_fErrMessageShown && 
                        (!GetDlgItemText(hDlg, IDE_DOWNSITENAME, szDownTpl, countof(szDownTpl)) ||
                        !GetDlgItemText(hDlg, IDE_DOWNSITEURL, szDownTpl, countof(szDownTpl)) ||
                        !PathIsURL(szDownTpl) || 
                        !GetDlgItemText(hDlg, IDE_DOWNSITEREGION, szDownTpl, countof(szDownTpl))))
                    {
                        s_fErrMessageShown = FALSE;
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    if ((g_nDownloadUrls > 1) &&
                        (!CheckField(hDlg, IDE_DOWNSITENAME, FC_NONNULL) ||
                         !CheckField(hDlg, IDE_DOWNSITENAME, FC_NONNULL) ||
                         !CheckField(hDlg, IDE_DOWNSITENAME, FC_NONNULL)))
                    {
                        s_fErrMessageShown = TRUE;
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    for (i = 0; i < g_nDownloadUrls ; i++ )
                    {
                        DWORD dwState = ListView_GetItemState(hUrlList, i, LVIS_SELECTED | LVIS_FOCUSED);
                        if (dwState == (LVIS_FOCUSED | LVIS_SELECTED))
                        {
                            g_iSelSite = i;
                            SetDownloadSiteEditControls(hDlg, g_iSelSite);
                        }

                    }
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    if (!s_fUserSitesInit)
                    {
                        InitializeUserDownloadSites(hDlg);
                        s_fUserSitesInit = TRUE;
                    }

                    if (!PageEnabled(PPAGE_COMPURLS))
                        PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, s_fNext ? PSBTN_NEXT : PSBTN_BACK, 0);
                    else
                    {
                        SetBannerText(hDlg);
                        EnableDlgItem2(hDlg, IDC_ADDBASEURL, (g_nDownloadUrls < ((g_fIntranet && (g_fSilent || g_fStealth)) ? 1 : 10)));
                        EnableDlgItem2(hDlg, IDC_REMOVEBASEURL, (g_nDownloadUrls != 0));
                        PropSheet_SetWizButtons(GetParent(hDlg), (g_nDownloadUrls == 0) ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
                        CheckBatchAdvance(hDlg);
                    }
                    break;


                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    WritePrivateProfileString( IS_ACTIVESETUP_SITES, NULL, NULL, g_szCustIns );
                    for (i = 0, psd = g_aCustSites; i < 10 ; i++, psd++ )
                    {
                        TCHAR szBaseUrlParm[32];
                        LPTSTR pSlash;

                        if (ISNONNULL(psd->szUrl) && !PathIsURL(psd->szUrl))
                        {
                            ErrorMessageBox(hDlg, IDS_INVALID_URL);
                            SetCustSite(hDlg, i);
                            SetFocus(hUrlList);
                            ListView_SetItemState(hUrlList, i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }

                        pSlash = StrRChr(psd->szUrl, NULL, TEXT('/'));
                        if (pSlash != NULL)
                        {
                            if (StrCmpI(pSlash, TEXT("/WIN32")) == 0)
                            {
                                LPTSTR pOld = pSlash;

                                *pSlash = TEXT('\0');
                                pSlash = StrRChr(psd->szUrl, NULL, TEXT('/'));
                                if (pSlash != NULL)
                                {
                                    if (StrCmpI(pSlash, TEXT("/DOWNLOAD")) == 0)
                                    {
                                        *pSlash = TEXT('\0');
                                    }
                                    else
                                        *pOld = TEXT('/');
                                }
                            }
                        }

                        if (!g_fBatch && (i < g_nDownloadUrls) && (ISNULL(psd->szUrl)
                             || ISNULL(psd->szName) || ISNULL(psd->szRegion)))
                        {
                            ErrorMessageBox(hDlg, IDS_BLANKSITE);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                        if ((StrChr(psd->szName, TEXT(',')) != NULL) ||
                            (StrChr(psd->szRegion, TEXT(',')) != NULL))
                        {
                            ErrorMessageBox(hDlg, IDS_ERROR_COMMA);
                            SetCustSite(hDlg, i);
                            SetFocus(hUrlList);
                            ListView_SetItemState(hUrlList, i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                        if (psd->szUrl[lstrlen(psd->szUrl)-1] == TEXT('/'))
                            psd->szUrl[lstrlen(psd->szUrl)-1] = TEXT('\0');
                        if(!g_fOCW && ISNONNULL(psd->szUrl))
                        {
                            StrCat(psd->szUrl, TEXT("/DOWNLOAD/"));
                            StrCat(psd->szUrl, GetOutputPlatformDir());
                            psd->szUrl[lstrlen(psd->szUrl)-1] = TEXT('\0');
                        }
                        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteUrl%i"), i);
                        WritePrivateProfileString( IS_ACTIVESETUP_SITES, szBaseUrlParm, psd->szUrl, g_szCustIns );
                        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteName%i"), i);
                        WritePrivateProfileString( IS_ACTIVESETUP_SITES, szBaseUrlParm, psd->szName, g_szCustIns );
                        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteRegion%i"), i);
                        WritePrivateProfileString( IS_ACTIVESETUP_SITES, szBaseUrlParm, psd->szRegion, g_szCustIns );
                    }

                    g_iCurPage = PPAGE_COMPURLS;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    {
                        s_fNext = FALSE;
                        PageNext(hDlg);
                    }
                    else
                    {
                        s_fNext = TRUE;
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}


INT_PTR CALLBACK AddOnDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fNoAddon,
         fDefAddon,
         fCustAddon,
         fUseMSSite;
    TCHAR szAddOnUrl[INTERNET_MAX_URL_LENGTH],
          szMenuText[128];
    INT id;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDE_ADDONURL);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ADDONURL), countof(szAddOnUrl) - 1);

            EnableDBCSChars(hDlg, IDE_MENUTEXT);
            Edit_LimitText(GetDlgItem(hDlg, IDE_MENUTEXT), countof(szMenuText) - 1);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    // no addon menu is available only in the corp mode
                    if (g_fIntranet)
                    {
                        fNoAddon = InsGetBool(IS_BRANDING, IK_NO_ADDON, FALSE, g_szCustIns);
                        ShowWindow(GetDlgItem(hDlg, IDC_NO_ADDON), SW_SHOW);
                    }
                    else
                    {
                        fNoAddon = FALSE;
                        ShowWindow(GetDlgItem(hDlg, IDC_NO_ADDON), SW_HIDE);
                    }
                    fDefAddon  = InsGetBool(IS_BRANDING, IK_DEF_ADDON,  FALSE, g_szCustIns);
                    fCustAddon = InsGetBool(IS_BRANDING, IK_CUST_ADDON, FALSE, g_szCustIns);

                    if (fNoAddon)
                        id = IDC_NO_ADDON;
                    else if (fDefAddon)
                        id = IDC_DEF_ADDON;
                    else if (fCustAddon)
                        id = IDC_CUST_ADDON;
                    else
                        id = IDC_DEF_ADDON;                                     // default radio button
                    CheckRadioButton(hDlg, IDC_NO_ADDON, IDC_CUST_ADDON, id);

                    GetPrivateProfileString(IS_BRANDING, IK_HELP_MENU_TEXT, TEXT(""), szMenuText, countof(szMenuText), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_MENUTEXT, szMenuText);

                    GetPrivateProfileString(IS_BRANDING, IK_ADDONURL, TEXT(""), szAddOnUrl, countof(szAddOnUrl), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_ADDONURL, szAddOnUrl);

                    EnableDlgItem2(hDlg, IDC_MENUTEXT, fCustAddon);
                    EnableDlgItem2(hDlg, IDE_MENUTEXT, fCustAddon);

                    EnableDlgItem2(hDlg, IDC_ADDONURL, fCustAddon);
                    EnableDlgItem2(hDlg, IDE_ADDONURL, fCustAddon);

                    fUseMSSite = InsGetBool(IS_BRANDING, IK_ALT_SITES_URL, FALSE, g_szCustIns);
                    CheckDlgButton(hDlg, IDC_MSDL, fUseMSSite ? BST_CHECKED : BST_UNCHECKED);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked(hDlg, IDC_CUST_ADDON) == BST_CHECKED)
                        if (!CheckField(hDlg, IDE_MENUTEXT, FC_NONNULL)  ||
                            !CheckField(hDlg, IDE_ADDONURL, FC_NONNULL | FC_URL))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                    if (g_fIntranet)
                        fNoAddon = (IsDlgButtonChecked(hDlg, IDC_NO_ADDON) == BST_CHECKED);
                    else
                        fNoAddon = FALSE;
                    fDefAddon  = (IsDlgButtonChecked(hDlg, IDC_DEF_ADDON)  == BST_CHECKED);
                    fCustAddon = (IsDlgButtonChecked(hDlg, IDC_CUST_ADDON) == BST_CHECKED);

                    if ((!g_fBatch) && (!g_fBatch2))
                    {
                        InsWriteBool(IS_BRANDING, IK_NO_ADDON,   fNoAddon,   g_szCustIns);
                        InsWriteBool(IS_BRANDING, IK_DEF_ADDON,  fDefAddon,  g_szCustIns);
                        InsWriteBool(IS_BRANDING, IK_CUST_ADDON, fCustAddon, g_szCustIns);
                    }

                    GetDlgItemText(hDlg, IDE_MENUTEXT, szMenuText, countof(szMenuText));
                    InsWriteString(IS_BRANDING, IK_HELP_MENU_TEXT, szMenuText, g_szCustIns);

                    GetDlgItemText(hDlg, IDE_ADDONURL, szAddOnUrl, countof(szAddOnUrl));
                    InsWriteString(IS_BRANDING, IK_ADDONURL, szAddOnUrl, g_szCustIns);

                    fUseMSSite = (IsDlgButtonChecked(hDlg, IDC_MSDL) == BST_CHECKED);
                    InsWriteBool(IS_BRANDING, IK_ALT_SITES_URL, fUseMSSite, g_szCustIns);

                    g_iCurPage = PPAGE_ADDON;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_NO_ADDON:
                        case IDC_DEF_ADDON:
                        case IDC_CUST_ADDON:
                            fCustAddon = (IsDlgButtonChecked(hDlg, IDC_CUST_ADDON) == BST_CHECKED);

                            EnableDlgItem2(hDlg, IDC_MENUTEXT, fCustAddon);
                            EnableDlgItem2(hDlg, IDE_MENUTEXT, fCustAddon);

                            EnableDlgItem2(hDlg, IDC_ADDONURL, fCustAddon);
                            EnableDlgItem2(hDlg, IDE_ADDONURL, fCustAddon);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
//  FUNCTION: UserAgentString(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "UserAgentString" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
//
INT_PTR CALLBACK UserAgentString( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    BOOL fChecked = FALSE;

    switch( msg )
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_UASTRING);
        Edit_LimitText(GetDlgItem(hDlg, IDC_UASTRING), MAX_PATH - 1);
        g_hWizard = hDlg;
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_UASTRINGCHECK:
                fChecked = (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDC_UASTRING, fChecked);
                EnableDlgItem2(hDlg, IDC_UASTRING_TXT, fChecked);
                break;

            default:
                return FALSE;
        }
        break;
    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {

            case PSN_HELP:
                IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                break;

            case PSN_SETACTIVE:
                SetBannerText(hDlg);
                SetDlgItemTextFromIns(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, IS_BRANDING,
                    USER_AGENT, g_szCustIns, NULL, INSIO_TRISTATE);
                EnableDlgItem2(hDlg, IDC_UASTRING_TXT, (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED));
                CheckBatchAdvance(hDlg);
                break;

            case PSN_WIZBACK:
            case PSN_WIZNEXT:
                g_iCurPage = PPAGE_UASTRDLG;
                WriteDlgItemTextToIns(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, IS_BRANDING,
                    USER_AGENT, g_szCustIns, NULL, INSIO_TRISTATE);
                EnablePages();
                (((LPNMHDR)lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                break;

            case PSN_QUERYCANCEL:
                QueryCancel(hDlg);
                break;

            default:
                return FALSE;
    }
    break;

    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK ActiveSetupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szActSetupTitle[50];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDE_TITLE);
            EnableDBCSChars(hDlg, IDE_WIZBITMAPPATH);
            EnableDBCSChars(hDlg, IDE_WIZBITMAPPATH2);
            EnableDBCSChars(hDlg, IDC_CCTITLE);

            Edit_LimitText(GetDlgItem(hDlg, IDE_TITLE),          countof(szActSetupTitle) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_WIZBITMAPPATH),  MAX_PATH - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_WIZBITMAPPATH2), MAX_PATH - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDC_CCTITLE),        countof(g_szCustItems) - 1);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    TCHAR szActSetupBitmap[MAX_PATH];

                    SetBannerText(hDlg);

                    // IEAKLite mode clean-up: delete the bmp files from the temp dir
                    DeleteFileInDir(TEXT("actsetup.bmp"), g_szBuildTemp);
                    DeleteFileInDir(TEXT("topsetup.bmp"), g_szBuildTemp);

                    // read title
                    GetPrivateProfileString(IS_ACTIVESETUP, IK_WIZTITLE, TEXT(""), szActSetupTitle, countof(szActSetupTitle), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_TITLE, szActSetupTitle);

                    // read left bitmap path
                    GetPrivateProfileString(IS_ACTIVESETUP, IK_WIZBMP, TEXT(""), szActSetupBitmap, countof(szActSetupBitmap), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_WIZBITMAPPATH, szActSetupBitmap);

                    // read top banner bitmap path
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_WIZBITMAPPATH2)))
                    {
                        GetPrivateProfileString(IS_ACTIVESETUP, IK_WIZBMP2, TEXT(""), szActSetupBitmap, countof(szActSetupBitmap), g_szCustIns);
                        SetDlgItemText(hDlg, IDE_WIZBITMAPPATH2, szActSetupBitmap);
                    }

                    // read cutom components title
                    if (g_nCustComp)
                    {
                        GetPrivateProfileString(STRINGS, CUSTITEMS, TEXT(""), g_szCustItems, countof(g_szCustItems), g_szCustInf);
                        if (*g_szCustItems == TEXT('\0'))
                            LoadString(g_rvInfo.hInst, IDS_CUSTOMCOMPTITLE, g_szCustItems, countof(g_szCustItems));
                    }
                    else
                        *g_szCustItems = TEXT('\0');
                    SetDlgItemText(hDlg, IDC_CCTITLE, g_szCustItems);
                    EnableDlgItem2(hDlg, IDC_CCTITLE, *g_szCustItems ? TRUE : FALSE);
                    EnableDlgItem2(hDlg, IDC_CCTITLE_TXT, *g_szCustItems ? TRUE : FALSE);

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                {
                    TCHAR szActSetupBitmap[MAX_PATH] = TEXT(""),
                          szActSetupBitmap2[MAX_PATH] = TEXT("");
                    LPCTSTR pszTmp;

                    if (!IsBitmapFileValid(hDlg, IDE_WIZBITMAPPATH, szActSetupBitmap, NULL, 164, 312, IDS_TOOBIG164x312, IDS_TOOSMALL164x312))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    // error checking for top bitmap
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_WIZBITMAPPATH2)))
                    {
                        if (!IsBitmapFileValid(hDlg, IDE_WIZBITMAPPATH2, szActSetupBitmap2, NULL, 496, 56, IDS_TOOBIG496x56, IDS_TOOSMALL496x56))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                    }
                    else
                        *szActSetupBitmap2 = TEXT('\0');

                    // error checking for custom components title
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CCTITLE)))
                    {
                        GetDlgItemText(hDlg, IDC_CCTITLE, g_szCustItems, countof(g_szCustItems));

                        if (*g_szCustItems == TEXT('\0'))
                        {
                            ErrorMessageBox(hDlg, IDS_CUSTOMCOMPTITLE_ERROR);
                            SetFocus(GetDlgItem(hDlg, IDC_CCTITLE));

                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                    }
                    else
                        *g_szCustItems = TEXT('\0');

                    // write title
                    GetDlgItemText(hDlg, IDE_TITLE, szActSetupTitle, countof(szActSetupTitle));

                    pszTmp = (*szActSetupTitle ? szActSetupTitle : NULL);

                    WritePrivateProfileString(IS_ACTIVESETUP, IK_WIZTITLE, pszTmp, g_szCustIns);
                    InsWriteQuotedString(BRANDING, IK_WIZTITLE, pszTmp, g_szCustInf);

                    // write left bitmap path
                    if (*szActSetupBitmap)
                    {
                        TCHAR szDest[MAX_PATH];

                        pszTmp = szActSetupBitmap;

                        PathCombine(szDest, g_szBuildTemp, TEXT("actsetup.bmp"));
                        CopyFile(szActSetupBitmap, szDest, FALSE);
                    }
                    else
                        pszTmp = NULL;

                    InsWriteQuotedString(IS_ACTIVESETUP, IK_WIZBMP, pszTmp, g_szCustIns);
                    InsWriteQuotedString(BRANDING, IK_WIZBMP, pszTmp != NULL ? TEXT("actsetup.bmp") : NULL, g_szCustInf);

                    // write top bitmap path
                    if (*szActSetupBitmap2)
                    {
                        TCHAR szDest[MAX_PATH];

                        pszTmp = szActSetupBitmap2;

                        PathCombine(szDest, g_szBuildTemp, TEXT("topsetup.bmp"));
                        CopyFile(szActSetupBitmap2, szDest, FALSE);
                    }
                    else
                        pszTmp = NULL;

                    InsWriteQuotedString(IS_ACTIVESETUP, IK_WIZBMP2, pszTmp, g_szCustIns);
                    InsWriteQuotedString(BRANDING, IK_WIZBMP2, pszTmp != NULL ? TEXT("topsetup.bmp") : NULL, g_szCustInf);

                    // write custom components title
                    pszTmp = (*g_szCustItems ? g_szCustItems : NULL);
                    InsWriteQuotedString(STRINGS, CUSTITEMS, pszTmp, g_szCustInf);

                    g_iCurPage = PPAGE_SETUPWIZARD;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;
                }

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        TCHAR szActSetupBitmap[MAX_PATH];

                        case IDC_BROWSEWIZPATH:
                            GetDlgItemText(hDlg, IDE_WIZBITMAPPATH, szActSetupBitmap, countof(szActSetupBitmap));
                            if (BrowseForFile(hDlg, szActSetupBitmap, countof(szActSetupBitmap), GFN_BMP))
                                SetDlgItemText(hDlg, IDE_WIZBITMAPPATH, szActSetupBitmap);
                            break;

                        case IDC_BROWSEWIZPATH2:
                            GetDlgItemText(hDlg, IDE_WIZBITMAPPATH2, szActSetupBitmap, countof(szActSetupBitmap));
                            if (BrowseForFile(hDlg, szActSetupBitmap, countof(szActSetupBitmap), GFN_BMP))
                                SetDlgItemText(hDlg, IDE_WIZBITMAPPATH2, szActSetupBitmap);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

#define MINCMAKVER  TEXT("4.71.0819.0")

BOOL g_fCustomICMPro = FALSE;

INT_PTR CALLBACK InternetConnMgr(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szCmd[MAX_PATH+8];
    LPTSTR pName;
    DWORD dwSize;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            InitSysFont( hDlg, IDE_ICMPRO);

            //BUGBUG: (a-saship) for now disable CMAK and once its confirmed remove all references to CMAK
            DisableDlgItem(hDlg, IDC_STARTCMAK);
            HideDlgItem(hDlg, IDC_STARTCMAK);
            HideDlgItem(hDlg, IDC_CMAKICON);

            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
                switch(LOWORD(wParam))
                {
                    case IDC_BROWSEICMPRO:
                        GetDlgItemText(hDlg, IDE_ICMPRO, g_szCustIcmPro, countof(g_szCustIcmPro));
                        if (BrowseForFile(hDlg, g_szCustIcmPro, countof(g_szCustIcmPro), GFN_EXE))
                            SetDlgItemText(hDlg, IDE_ICMPRO, g_szCustIcmPro);
                        break;

                    case IDC_ICMPROCHECK:
                        g_fCustomICMPro = (IsDlgButtonChecked( hDlg, IDC_ICMPROCHECK ) == BST_CHECKED);
                        EnableDlgItem2(hDlg, IDE_ICMPRO, g_fCustomICMPro);
                        EnableDlgItem2(hDlg, IDC_BROWSEICMPRO, g_fCustomICMPro);
                        EnableDlgItem2(hDlg, IDC_ICMPRO_TXT, g_fCustomICMPro);

                        break;
                    case IDC_STARTCMAK:
                        dwSize = sizeof(szCmd);
                        if (SHGetValue(HKEY_LOCAL_MACHINE, CURRENTVERSIONKEY TEXT("\\App Paths\\cmak.exe"), NULL,  NULL,
                            (LPVOID)szCmd, &dwSize) == ERROR_SUCCESS)
                        {
                            DWORD dwExitCode;
                            StrCat(szCmd, TEXT(" /i"));
                            if (RunAndWait(szCmd, g_szWizRoot, SW_SHOW, &dwExitCode) && (dwExitCode == IDOK))
                            {
                                dwSize = sizeof(g_szCustIcmPro);

                                if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Connection Manager Administration Kit"),
                                    TEXT("Output"), NULL, (LPVOID)g_szCustIcmPro, &dwSize) == ERROR_SUCCESS)
                                {
                                    g_fCustomICMPro = TRUE;
                                    EnableDlgItem2(hDlg, IDE_ICMPRO, g_fCustomICMPro);
                                    EnableDlgItem2(hDlg, IDC_BROWSEICMPRO, g_fCustomICMPro);
                                    EnableDlgItem2(hDlg, IDC_ICMPRO_TXT, g_fCustomICMPro);
                                    SetDlgItemText(hDlg, IDE_ICMPRO, g_szCustIcmPro);
                                    CheckDlgButton(hDlg, IDC_ICMPROCHECK, BST_CHECKED);
                                }
                            }
                        }
                        else
                            ErrorMessageBox(hDlg, IDS_NOCMAK);
                        break;
                }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    g_fCustomICMPro = GetPrivateProfileInt( BRANDING, CMUSECUSTOM, 0, g_szCustIns );
                    CheckDlgButton( hDlg, IDC_ICMPROCHECK, g_fCustomICMPro );
                    GetPrivateProfileString( BRANDING, CMPROFILEPATH, TEXT(""),
                        g_szCustIcmPro, countof(g_szCustIcmPro), g_szCustIns );
                    SetDlgItemText( hDlg, IDE_ICMPRO, g_szCustIcmPro );
                    EnableDlgItem2(hDlg, IDE_ICMPRO, g_fCustomICMPro);
                    EnableDlgItem2(hDlg, IDC_BROWSEICMPRO, g_fCustomICMPro);
                    EnableDlgItem2(hDlg, IDC_ICMPRO_TXT, g_fCustomICMPro);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    GetDlgItemText( hDlg, IDE_ICMPRO, g_szCustIcmPro, countof(g_szCustIcmPro) );
                    if(IsDlgButtonChecked(hDlg, IDC_ICMPROCHECK) == BST_CHECKED && !CheckField(hDlg, IDE_ICMPRO, FC_NONNULL | FC_FILE | FC_EXISTS))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }
                    WritePrivateProfileString( BRANDING, CMPROFILEPATH, g_szCustIcmPro, g_szCustIns );
                    pName = StrRChr(g_szCustIcmPro, NULL, TEXT('\\'));
                    if (pName) pName++;
                    else pName = g_szCustIcmPro;
                    WritePrivateProfileString( BRANDING, CMPROFILENAME, pName, g_szCustIns );
                    WritePrivateProfileString( BRANDING, CMUSECUSTOM, (g_fCustomICMPro ? TEXT("1") : TEXT("0")), g_szCustIns);
                    if (g_fCustomICMPro)
                    {
                        TCHAR szDisplayName[MAX_PATH];
                        TCHAR szGUID[MAX_PATH];
                        TCHAR szUrl[80];
                        TCHAR szVersion[64];
                        LPTSTR pFile, pDot;
                        DWORD dwVer, dwBuild;
                        GUID guid;

                        GetVersionFromFileWrap(g_szCustIcmPro, &dwVer, &dwBuild, TRUE);
                        ConvertDwordsToVersionStr(szVersion, dwVer, dwBuild);

                        if (CheckVer(szVersion, MINCMAKVER) <= 0)
                        {
                            ErrorMessageBox(hDlg, IDS_ERROR_CMAKVER);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        GetPrivateProfileString( CUSTCMSECT, TEXT("GUID"), TEXT(""), szGUID, countof(szGUID), g_szCustCif );
                        if (ISNULL(szGUID))
                        {
                            if (CoCreateGuid(&guid) == NOERROR)
                                CoStringFromGUID(guid, szGUID, countof(szGUID));
                        }
                        LoadString( g_rvInfo.hInst, IDS_CUSTICMPRO, szDisplayName, countof(szDisplayName) );
                        InsWriteQuotedString( CUSTCMSECT, TEXT("DisplayName"), szDisplayName, g_szCustCif );
                        InsWriteQuotedString( CUSTCMSECT, TEXT("GUID"),  szGUID,  g_szCustCif );
                        InsWriteQuotedString( CUSTCMSECT, TEXT("Command1"), pName,  g_szCustCif );

                        wnsprintf(szUrl, countof(szUrl), TEXT("%s"), pName);
                        WritePrivateProfileString( CUSTCMSECT, TEXT("URL1"), szUrl, g_szCustCif );
                        pFile = PathFindFileName(g_szCustIcmPro);
                        pDot = StrChr(pFile, TEXT('.'));
                        if (pDot)
                            *pDot = TEXT('\0');
                        wnsprintf(szDisplayName, countof(szDisplayName), TEXT("/q:a /r:n /c:\"cmstp.exe /i %s.inf\""), pFile);
                        if (pDot)
                            *pDot = TEXT('.');
                        InsWriteQuotedString( CUSTCMSECT, TEXT("Switches1"), szDisplayName, g_szCustCif );
                        WritePrivateProfileString( CUSTCMSECT, TEXT("Type1"), TEXT("2"), g_szCustCif );
                        // bump up the version number if it already exists, otherwise use the defined version in
                        // iedkbrnd.h

                        if (GetPrivateProfileString( CUSTCMSECT, VERSION, g_szJobVersion, szVersion, countof(szVersion), g_szCustCif ))
                        {
                            LPTSTR pComma;
                            INT iVer;

                            pComma = StrRChr(szVersion, NULL, TEXT(','));
                            if (pComma == NULL)
                                pComma = szVersion;
                            iVer = StrToInt( pComma + 1 );
                            iVer++;

                            wnsprintf(pComma, MAX_PATH, TEXT(",%i"), iVer);
                            WritePrivateProfileString(CUSTCMSECT, VERSION, szVersion, g_szCustCif);
                        }
                    }
                    else
                    {
                        WritePrivateProfileString( CUSTCMSECT, NULL, NULL, g_szCustCif );
                    }
                    g_iCurPage = PPAGE_ICM;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;


                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\intrawiz.cpp ===
#include "precomp.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szTempSign[];
extern TCHAR g_szMastInf[];

extern BOOL g_fOCW;
extern BOOL g_fIntranet;
extern BOOL g_fInteg;
extern BOOL g_fCD, g_fLAN, g_fDownload, g_fBrandingOnly;

extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

// global variables
TCHAR g_szInstallFolder[MAX_PATH] = TEXT("");
BOOL g_fSilent = FALSE;
BOOL g_fStealth = FALSE;
BOOL g_fImportConnect = FALSE;
int g_iInstallOpt;

// static variables
static TCHAR s_szInstallDir[MAX_PATH] = TEXT("");

INT_PTR CALLBACK QueryAutoConfigDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szAutoConfigURL[MAX_URL],
          szAutoProxyURL[MAX_URL],
          szAutoConfigTime[7];
    BOOL  fDetectConfig,
          fUseAutoConfig;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            DisableDBCSChars(hDlg, IDE_AUTOCONFIGTIME);

            EnableDBCSChars(hDlg, IDE_AUTOCONFIGURL);
            EnableDBCSChars(hDlg, IDE_AUTOPROXYURL);

            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOCONFIGTIME), countof(szAutoConfigTime) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOCONFIGURL),  countof(szAutoConfigURL) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOPROXYURL),   countof(szAutoProxyURL) - 1);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    fDetectConfig = FALSE;
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_AUTODETECT))) {
                        fDetectConfig = InsGetBool(IS_URL, IK_DETECTCONFIG, TRUE, g_szCustIns);
                        CheckDlgButton(hDlg, IDC_AUTODETECT, fDetectConfig  ? BST_CHECKED : BST_UNCHECKED);
                    }

                    fUseAutoConfig = InsGetBool(IS_URL, IK_USEAUTOCONF,  FALSE, g_szCustIns);
                    CheckDlgButton(hDlg, IDC_YESAUTOCON, fUseAutoConfig ? BST_CHECKED : BST_UNCHECKED);
                    
                    GetPrivateProfileString(IS_URL, IK_AUTOCONFTIME, TEXT(""), szAutoConfigTime, countof(szAutoConfigTime), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szAutoConfigTime);
                    EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME, fUseAutoConfig);
                    EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT2, fUseAutoConfig);
                    EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT3, fUseAutoConfig);

                    GetPrivateProfileString(IS_URL, IK_AUTOCONFURL, TEXT(""), szAutoConfigURL, countof(szAutoConfigURL), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_AUTOCONFIGURL, szAutoConfigURL);
                    EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL, fUseAutoConfig);
                    EnableDlgItem2(hDlg, IDC_AUTOCONFIGURL_TXT, fUseAutoConfig);

                    GetPrivateProfileString(IS_URL, IK_AUTOCONFURLJS, TEXT(""), szAutoProxyURL, countof(szAutoProxyURL), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_AUTOPROXYURL, szAutoProxyURL);
                    EnableDlgItem2(hDlg, IDE_AUTOPROXYURL, fUseAutoConfig);
                    EnableDlgItem2(hDlg, IDC_AUTOPROXYURL_TXT, fUseAutoConfig);

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    fDetectConfig  = (IsDlgButtonChecked(hDlg, IDC_AUTODETECT) == BST_CHECKED);
                    fUseAutoConfig = (IsDlgButtonChecked(hDlg, IDC_YESAUTOCON) == BST_CHECKED);

                    GetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szAutoConfigTime, countof(szAutoConfigTime));
                    GetDlgItemText(hDlg, IDE_AUTOCONFIGURL,  szAutoConfigURL,  countof(szAutoConfigURL));
                    GetDlgItemText(hDlg, IDE_AUTOPROXYURL,   szAutoProxyURL,   countof(szAutoProxyURL));

                    // do error checking
                    if (fUseAutoConfig) {
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDE_AUTOCONFIGTIME)) &&
                            !CheckField(hDlg, IDE_AUTOCONFIGTIME, FC_NUMBER)) {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        if (*szAutoConfigURL == TEXT('\0') && *szAutoProxyURL == TEXT('\0')) {
                            ErrorMessageBox(hDlg, IDS_AUTOCONFIG_NULL);

                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        if (!CheckField(hDlg, IDE_AUTOCONFIGURL, FC_URL) ||
                            !CheckField(hDlg, IDE_AUTOPROXYURL,  FC_URL)) {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                    }

                    // write the values to the INS file
                    InsWriteBoolEx(IS_URL, IK_DETECTCONFIG,  fDetectConfig,    g_szCustIns);
                    InsWriteBoolEx(IS_URL, IK_USEAUTOCONF,   fUseAutoConfig,   g_szCustIns);
                    InsWriteString(IS_URL, IK_AUTOCONFTIME,  szAutoConfigTime, g_szCustIns);
                    InsWriteString(IS_URL, IK_AUTOCONFURL,   szAutoConfigURL,  g_szCustIns);
                    InsWriteString(IS_URL, IK_AUTOCONFURLJS, szAutoProxyURL,   g_szCustIns);

                    g_iCurPage = PPAGE_QUERYAUTOCONFIG;
                    EnablePages();
                    (((NMHDR FAR *)lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_YESAUTOCON:
                            fUseAutoConfig = (IsDlgButtonChecked(hDlg, IDC_YESAUTOCON) == BST_CHECKED);
                            
                            EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME, fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT2, fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT3, fUseAutoConfig);    
                            EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL, fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDC_AUTOCONFIGURL_TXT, fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDE_AUTOPROXYURL,  fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDC_AUTOPROXYURL_TXT, fUseAutoConfig);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

void EnableProxyControls(HWND hDlg, BOOL fSame, BOOL fUseProxy)
{
    EnableDlgItem2(hDlg, IDE_FTPPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_FTPPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_FTPPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SECPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SECPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_SECPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_GOPHERPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_GOPHERPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_GOPHERPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SOCKSPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SOCKSPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_SOCKSPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_HTTPPROXY, fUseProxy);
    EnableDlgItem2(hDlg, IDE_HTTPPORT, fUseProxy);
    EnableDlgItem2(hDlg, IDC_HTTPPROXY1, fUseProxy);
    EnableDlgItem2(hDlg, IDC_SAMEFORALL, fUseProxy);
    EnableDlgItem2(hDlg, IDE_DISPROXYADR, fUseProxy);
    EnableDlgItem2(hDlg, IDC_DISPROXYADR1, fUseProxy);
    EnableDlgItem2(hDlg, IDC_DISPROXYLOCAL, fUseProxy);
}

void InitializeProxy(HWND hDlg, LPCTSTR szInsFile)
{
    BOOL fUseProxy;
    BOOL fSameProxy;
    BOOL fLocal;
    LPTSTR pLocal;
    TCHAR szProxy[MAX_PATH];
    TCHAR szProxyOverride[MAX_STRING];

    fUseProxy = InsGetBool(IS_PROXY, IK_PROXYENABLE, FALSE, szInsFile);
    CheckDlgButton( hDlg, IDC_YESPROXY, fUseProxy );

    fSameProxy = InsGetBool(IS_PROXY, IK_SAMEPROXY, TRUE, szInsFile);
    CheckDlgButton( hDlg, IDC_SAMEFORALL, fSameProxy );

    GetPrivateProfileString( IS_PROXY, IK_HTTPPROXY, TEXT(""), szProxy,
        countof(szProxy), szInsFile );
    if( fSameProxy )
    {
        SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
    }
    else
    {
        SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
        GetPrivateProfileString( IS_PROXY, IK_FTPPROXY, TEXT(""), szProxy, countof(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
        GetPrivateProfileString( IS_PROXY, IK_GOPHERPROXY, TEXT(""), szProxy, countof(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
        GetPrivateProfileString( IS_PROXY, IK_SECPROXY, TEXT(""), szProxy, countof(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
        GetPrivateProfileString( IS_PROXY, IK_SOCKSPROXY, TEXT(""), szProxy, countof(szProxy), szInsFile );
        if( lstrlen( szProxy ))
            SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
    }

    GetPrivateProfileString( IS_PROXY, IK_PROXYOVERRIDE, LOCALPROXY, szProxyOverride,
        countof( szProxyOverride ), szInsFile );

    pLocal = StrStr(szProxyOverride, LOCALPROXY);

    if(pLocal != NULL)
    {
        if (pLocal == (LPTSTR) szProxyOverride)         // at the beginning
        {
            LPTSTR pSemi = pLocal + 7;
            if( *pSemi == TEXT(';') ) pSemi++;
            MoveMemory( pLocal, pSemi, (StrLen(pSemi) + 1) * sizeof(TCHAR));
        }
        else if (*(pLocal + 7) == TEXT('\0'))   // at the end
            *(pLocal - 1) = TEXT('\0');
        fLocal = TRUE;
    }
    else
        fLocal = FALSE;
    CheckDlgButton( hDlg, IDC_DISPROXYLOCAL, fLocal );
    SetDlgItemText( hDlg, IDE_DISPROXYADR, szProxyOverride );
    EnableProxyControls( hDlg, fSameProxy, fUseProxy );
}

BOOL SaveProxy(HWND hDlg, LPCTSTR szInsFile)
{
    BOOL fUseProxy;
    BOOL fSameProxy;
    BOOL fLocal;
    TCHAR szProxy[MAX_PATH];
    TCHAR szProxyOverride[MAX_STRING];

    if (!CheckField(hDlg, IDE_HTTPPORT, FC_NUMBER)   ||
        !CheckField(hDlg, IDE_FTPPORT, FC_NUMBER)    ||
        !CheckField(hDlg, IDE_GOPHERPORT, FC_NUMBER) ||
        !CheckField(hDlg, IDE_SECPORT, FC_NUMBER)    ||
        !CheckField(hDlg, IDE_SOCKSPORT, FC_NUMBER))
        return FALSE;

    fSameProxy = IsDlgButtonChecked( hDlg, IDC_SAMEFORALL );
    fUseProxy = IsDlgButtonChecked( hDlg, IDC_YESPROXY );
    fLocal = IsDlgButtonChecked( hDlg, IDC_DISPROXYLOCAL );
    GetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT );
    WritePrivateProfileString( IS_PROXY, IK_HTTPPROXY, szProxy, szInsFile );
    GetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT );
    WritePrivateProfileString( IS_PROXY, IK_FTPPROXY, szProxy, szInsFile );
    GetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT );
    WritePrivateProfileString( IS_PROXY, IK_GOPHERPROXY, szProxy, szInsFile );
    GetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT );
    WritePrivateProfileString( IS_PROXY, IK_SECPROXY, szProxy, szInsFile );
    GetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT );
    WritePrivateProfileString( IS_PROXY, IK_SOCKSPROXY, szProxy, szInsFile );
    WritePrivateProfileString( IS_PROXY, IK_SAMEPROXY, fSameProxy ? TEXT("1") : TEXT("0"), szInsFile );
    WritePrivateProfileString( IS_PROXY, IK_PROXYENABLE, fUseProxy ? TEXT("1") : TEXT("0"), szInsFile );
    GetDlgItemText( hDlg, IDE_DISPROXYADR, szProxyOverride, countof(szProxyOverride) - 10 ); // 8 for ;<local> + 2 for ""
    if( fLocal )
    {
        if( *szProxyOverride )
        {
            TCHAR szPort[MAX_STRING];

            StrRemoveAllWhiteSpace(szProxyOverride);
            wnsprintf(szPort, countof(szPort), TEXT("%s;%s"), szProxyOverride, LOCALPROXY );
            InsWriteQuotedString( IS_PROXY, IK_PROXYOVERRIDE, szPort, szInsFile );
        }
        else
            WritePrivateProfileString( IS_PROXY, IK_PROXYOVERRIDE, LOCALPROXY, szInsFile );
    }
    else
        WritePrivateProfileString( IS_PROXY, IK_PROXYOVERRIDE, szProxyOverride, szInsFile );

    return TRUE;
}

INT_PTR CALLBACK ProxySettings( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    BOOL fSameProxy;
    BOOL fUseProxy;
    BOOL fLocal;
    TCHAR szProxy[MAX_PATH];

    switch( msg )
    {
    case WM_INITDIALOG:
        InitSysFont(hDlg, IDE_HTTPPROXY);
        InitSysFont(hDlg, IDE_SECPROXY);
        InitSysFont(hDlg, IDE_FTPPROXY);
        InitSysFont(hDlg, IDE_GOPHERPROXY);
        InitSysFont(hDlg, IDE_SOCKSPROXY);
        InitSysFont(hDlg, IDE_DISPROXYADR);

        Edit_LimitText(GetDlgItem(hDlg, IDE_HTTPPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_FTPPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_GOPHERPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SECPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SOCKSPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_DISPROXYADR), MAX_STRING - 11); // 8 for ;<local> + 2 for the double quotes

        g_hWizard = hDlg;
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_COMMAND:
        fSameProxy = IsDlgButtonChecked( hDlg, IDC_SAMEFORALL );
        fUseProxy = IsDlgButtonChecked( hDlg, IDC_YESPROXY );
        fLocal = IsDlgButtonChecked( hDlg, IDC_DISPROXYLOCAL );

        if( HIWORD(wParam) == BN_CLICKED )
        {
            switch( LOWORD(wParam))
            {
            case IDC_SAMEFORALL:
                GetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT);
                if( fSameProxy )
                {
                    SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
                }
                // fallthrough

            case IDC_YESPROXY:
                EnableProxyControls( hDlg, fSameProxy, fUseProxy );
                break;
            }
        }
        else if( (HIWORD(wParam) == EN_UPDATE) && fSameProxy && ((LOWORD(wParam) == IDE_HTTPPROXY) || (LOWORD(wParam) == IDE_HTTPPORT)))
        {
            GetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT);
            SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
            case PSN_HELP:
                IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                break;

            case PSN_SETACTIVE:
                SetBannerText(hDlg);
                InitializeProxy(hDlg, g_szCustIns);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                CheckBatchAdvance(hDlg);
                break;

            case PSN_WIZNEXT:
            case PSN_WIZBACK:
                if (!SaveProxy(hDlg, g_szCustIns))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }
                g_iCurPage = PPAGE_PROXY;
                EnablePages();
                if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    PageNext(hDlg);
                else
                    PagePrev(hDlg);
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_QUERYCANCEL:
                QueryCancel(hDlg);
                break;

            default:
                return FALSE;
    }
    break;

    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK ConnectSetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_CSNOIMPORT:
                            DisableDlgItem(hDlg, IDC_MODIFYCONNECT);
                            break;

                        case IDC_CSIMPORT:
                            EnableDlgItem(hDlg, IDC_MODIFYCONNECT);
                            break;

                        case IDC_MODIFYCONNECT:
                            ShowInetcpl(hDlg, INET_PAGE_CONNECTION, g_fIntranet ? IEM_CORP : IEM_NEUTRAL);
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                {
                    BOOL fImport;

                    SetBannerText(hDlg);
                    fImport = GetPrivateProfileInt(IS_CONNECTSET, OPTION, 0, g_szCustIns);
                    EnableDlgItem2(hDlg, IDC_MODIFYCONNECT, fImport);
                    CheckRadioButton(hDlg, IDC_CSNOIMPORT, IDC_CSIMPORT, fImport ? IDC_CSIMPORT : IDC_CSNOIMPORT);
                    CheckDlgButton(hDlg, IDC_DELCONNECT,
                        GetPrivateProfileInt(IS_CONNECTSET, IK_DELETECONN, 0, g_szCustIns) ? BST_CHECKED : BST_UNCHECKED);

                    ShowWindow(GetDlgItem(hDlg, IDC_DELCONNECT), g_fIntranet ? SW_SHOWNORMAL : SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_DELCONNECT_TXT), g_fIntranet ? SW_SHOWNORMAL : SW_HIDE);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                {
                    CNewCursor cur(IDC_WAIT);
                    TCHAR szWorkDir[MAX_PATH];

                    g_cmCabMappings.GetFeatureDir(FEATURE_CONNECT, szWorkDir);
                    g_fImportConnect = (IsDlgButtonChecked(hDlg, IDC_CSIMPORT) == BST_CHECKED);

                    ImportConnectSet(g_szCustIns, szWorkDir, g_szTempSign, g_fImportConnect, g_fIntranet ? IEM_CORP : IEM_NEUTRAL);
                    InsWriteBool(IS_CONNECTSET, IK_DELETECONN,
                        g_fIntranet && (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DELCONNECT)), g_szCustIns);

                    g_iCurPage = PPAGE_CONNECTSET;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;
                }

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK InstallDirectory(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szWrk[MAX_PATH];
    BOOL fAllow;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            InitSysFont( hDlg, IDE_INSTALLDIR);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
                switch (LOWORD(wParam))
                {
                    case IDC_BROWSEDIR:
                        {
                            TCHAR szInstructions[MAX_PATH];
                            LoadString(g_rvInfo.hInst,IDS_INSTALLDIR,szInstructions,countof(szInstructions));

                            if (BrowseForFolder(hDlg, s_szInstallDir, szInstructions))
                                SetDlgItemText( hDlg, IDE_INSTALLDIR, s_szInstallDir );
                            break;
                        }

                    case IDC_PROGFILES32:
                    case IDC_FULLPATH32:
                        CheckRadioButton( hDlg, IDC_PROGFILES32, IDC_FULLPATH32, LOWORD(wParam) );
                        GetDlgItemText( hDlg, IDE_INSTALLDIR, s_szInstallDir, MAX_PATH );
                        if (LOWORD(wParam) != IDC_FULLPATH32)
                        {
                            DisableDlgItem(hDlg, IDC_BROWSEDIR);
                            if (StrChr(s_szInstallDir, TEXT('\\')) || lstrlen(s_szInstallDir) == 0)
                            {
                                LoadString( g_rvInfo.hInst, IDS_IE, s_szInstallDir, MAX_PATH );
                                SetDlgItemText( hDlg, IDE_INSTALLDIR, s_szInstallDir );
                            }
                        }
                        else
                        {
                            if (s_szInstallDir[1] != TEXT(':'))
                                SetDlgItemText( hDlg, IDE_INSTALLDIR, TEXT("") );
                            EnableDlgItem(hDlg, IDC_BROWSEDIR);
                        }
                        break;
                }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    GetPrivateProfileString( IS_BRANDING, TEXT("InstallDir"), TEXT(""), szWrk, MAX_PATH, g_szCustIns );
                    if (*szWrk != TEXT('%'))
                    {
                        g_iInstallOpt = INSTALL_OPT_FULL;
                        if (ISNONNULL(szWrk))
                        {
                            StrCpy(s_szInstallDir, szWrk);
                            CheckRadioButton( hDlg, IDC_PROGFILES32, IDC_FULLPATH32, IDC_FULLPATH32 );
                        }
                        else
                        {
                            LoadString( g_rvInfo.hInst, IDS_IE, s_szInstallDir, MAX_PATH );
                            g_iInstallOpt = INSTALL_OPT_PROG;
                            CheckRadioButton( hDlg, IDC_PROGFILES32, IDC_FULLPATH32, IDC_PROGFILES32 );
                            DisableDlgItem(hDlg, IDC_BROWSEDIR);
                        }
                    }
                    else
                    {
                        switch (szWrk[1])
                        {
                            case TEXT('p'):
                            case TEXT('P'):
                            default:
                                g_iInstallOpt = INSTALL_OPT_PROG;
                                CheckRadioButton( hDlg, IDC_PROGFILES32, IDC_FULLPATH32, IDC_PROGFILES32 );
                                break;
                        }
                        DisableDlgItem(hDlg, IDC_BROWSEDIR);
                        StrCpy(s_szInstallDir, &szWrk[3]);
                    }

                    SetDlgItemText( hDlg, IDE_INSTALLDIR, s_szInstallDir );
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    if (g_fSilent || g_fStealth)
                        DisableDlgItem(hDlg, IDC_ALLOWINSTALLDIR);
                    else
                    {
                        EnableDlgItem(hDlg, IDC_ALLOWINSTALLDIR);
                        fAllow =  GetPrivateProfileInt(IS_BRANDING, TEXT("AllowInstallDir"), 1, g_szCustIns);

                        CheckDlgButton(hDlg, IDC_ALLOWINSTALLDIR,
                            fAllow ? BST_CHECKED : BST_UNCHECKED);

                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    GetDlgItemText( hDlg, IDE_INSTALLDIR, g_szInstallFolder, MAX_PATH );
                    if ((IsDlgButtonChecked( hDlg, IDC_FULLPATH32 ) == BST_CHECKED))
                    {
                        if (PathIsRelative(g_szInstallFolder))
                        {
                            ErrorMessageBox(hDlg, IDS_BADDEST);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        StrCpy(s_szInstallDir, g_szInstallFolder);
                        g_iInstallOpt = INSTALL_OPT_FULL;
                    }
                    else
                    {
                        if (!PathIsRelative(g_szInstallFolder))
                        {
                            ErrorMessageBox(hDlg, IDS_RELATIVE_ONLY);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                        if ((IsDlgButtonChecked( hDlg, IDC_PROGFILES32 )  == BST_CHECKED))
                        {
                            g_iInstallOpt = INSTALL_OPT_PROG;
                            wnsprintf(s_szInstallDir, countof(s_szInstallDir), TEXT("%%p\\%s"), g_szInstallFolder);
                        }
                    }

                    //----- Validate input -----
                    if (!PathIsValidPath(g_szInstallFolder)) {
                        HWND hEdit;
                        UINT nID;

                        ErrorMessageBox(hDlg, IDS_BADDEST);

                        switch (g_iInstallOpt) {
                        case INSTALL_OPT_FULL: nID = IDC_FULLPATH32;
                        case INSTALL_OPT_PROG: nID = IDC_PROGFILES32;
                        default:               nID = (UINT)-1; ASSERT(FALSE);
                        };

                        hEdit = GetDlgItem(hDlg, nID);
                        Edit_SetSel(hEdit, 0, -1);
                        SetFocus(hEdit);

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    }

                    WritePrivateProfileString( IS_BRANDING, TEXT("InstallDir"), s_szInstallDir, g_szCustIns );

                    fAllow = (IsDlgButtonChecked(hDlg, IDC_ALLOWINSTALLDIR) == BST_CHECKED) && !g_fSilent && !g_fStealth;
                    WritePrivateProfileString(IS_BRANDING, TEXT("AllowInstallDir"),
                        fAllow ? TEXT("1") : TEXT("0"), g_szCustIns);
                    
                    g_iCurPage = PPAGE_INSTALLDIR;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_WIZFINISH:
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: CorpCustomizeCustom(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "Corp Customize Custom" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
INT_PTR CALLBACK CorpCustomizeCustom(
    HWND hDlg,
    UINT message,
    WPARAM,
    LPARAM lParam)
{
    BOOL fCompatDisabled;
    BOOL fCustDisabled;
    BOOL fBackupDisabled;
    int iDefaultBrowserCheck;

    switch (message)
    {
        case WM_INITDIALOG:
            break;


        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    //from the former shellinteg dlg

                    g_fInteg = GetPrivateProfileInt( BRANDING, WEB_INTEGRATED, 0, g_szCustIns );

                    CheckDlgButton(hDlg, IDC_DESKTOPUPDATE, g_fInteg ? BST_CHECKED : BST_UNCHECKED);
                    
                    // BUGBUG: <oliverl> should probably move this stuff into server side file for IEAK6

                    EnableDlgItem2(hDlg, IDC_IECOMPAT, !(g_fSilent || g_fStealth));
                    EnableDlgItem2(hDlg, IDC_CUSTCUST, !(g_fSilent || g_fStealth));
                    EnableDlgItem2(hDlg, IDC_NOXFLAG, !(g_fSilent || g_fStealth));

                    iDefaultBrowserCheck = GetPrivateProfileInt(IS_BRANDING, TEXT("BrowserDefault"), 2, g_szCustIns);
                    if (!(g_fSilent || g_fStealth))
                    {
                        fCompatDisabled = GetPrivateProfileInt(IS_BRANDING, TEXT("HideCompat"), 0, g_szCustIns);
                        CheckDlgButton(hDlg, IDC_IECOMPAT, fCompatDisabled ? BST_CHECKED : BST_UNCHECKED);
                        fCustDisabled = GetPrivateProfileInt(IS_BRANDING, TEXT("HideCustom"), 0, g_szCustIns);
                        CheckDlgButton(hDlg, IDC_CUSTCUST, fCustDisabled ? BST_CHECKED : BST_UNCHECKED);
                    }
                    else
                    {
                        if (iDefaultBrowserCheck == 2)
                            iDefaultBrowserCheck = 0;
                    }

                    CheckRadioButton(hDlg, IDC_XFLAGFALSE, IDC_NOXFLAG, IDC_XFLAGFALSE + iDefaultBrowserCheck);

                    fBackupDisabled = GetPrivateProfileInt(IS_BRANDING, TEXT("NoBackup"), 0, g_szCustIns);
                    CheckDlgButton(hDlg, IDC_NOBACKUPDATA, fBackupDisabled ? BST_CHECKED : BST_UNCHECKED);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    //from the former shellinteg dlg
                    TCHAR szBrandingDir[MAX_PATH];

                    g_fInteg = IsDlgButtonChecked(hDlg, IDC_DESKTOPUPDATE);

                    if (g_fOCW)
                    {
                        HKEY hkIEAK;

                        if(RegOpenKeyEx(HKEY_CURRENT_USER, RK_IEAK_SERVER, 0, KEY_READ, &hkIEAK) == ERROR_SUCCESS)
                        {
                            DWORD dwData;

                            dwData = g_fInteg ? 1 : 0;
                            RegSetValueEx(hkIEAK, TEXT("InstallShell"), 0, REG_DWORD, (LPBYTE) &dwData, sizeof(dwData));
                            RegCloseKey(hkIEAK);
                        }
                    }

                    WritePrivateProfileString( BRANDING, WEB_INTEGRATED,
                        g_fInteg ? TEXT("1") : TEXT("0"), g_szCustIns );

                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);

                    if (g_fInteg)
                    {
                        TCHAR szFixIEIcoInf[MAX_PATH];

                        WritePrivateProfileString(EXTREGINF, TEXT("FixIEIco"), TEXT("*,fixieico.inf,DefaultInstall"), g_szCustIns);

                        // fixieico.inf is under iebin\<lang>\optional
                        StrCpy(szFixIEIcoInf, g_szMastInf);
                        PathRemoveFileSpec(szFixIEIcoInf);
                        PathAppend(szFixIEIcoInf, TEXT("fixieico.inf"));

                        // copy fixieico.inf from iebin\<lang>\optional to the branding dir
                        PathAppend(szBrandingDir, TEXT("fixieico.inf"));
                        CopyFile(szFixIEIcoInf, szBrandingDir, FALSE);
                    }
                    else
                    {
                        // delete the FixIEIco line
                        WritePrivateProfileString(EXTREGINF, TEXT("FixIEIco"), NULL, g_szCustIns);

                        // delete fixieico.inf from the branding dir
                        PathAppend(szBrandingDir, TEXT("fixieico.inf"));
                        DeleteFile(szBrandingDir);
                    }


                    //

                    if (!(g_fSilent || g_fStealth))
                    {
                        fCompatDisabled = (IsDlgButtonChecked(hDlg, IDC_IECOMPAT) == BST_CHECKED);
                        WritePrivateProfileString(IS_BRANDING, TEXT("HideCompat"),
                            fCompatDisabled ? TEXT("1") : TEXT("0"), g_szCustIns);
                        fCustDisabled = (IsDlgButtonChecked(hDlg, IDC_CUSTCUST) == BST_CHECKED);
                        WritePrivateProfileString(IS_BRANDING, TEXT("HideCustom"),
                            fCustDisabled ? TEXT("1") : TEXT("0"), g_szCustIns);
                    }
                    fBackupDisabled = (IsDlgButtonChecked(hDlg, IDC_NOBACKUPDATA) == BST_CHECKED);
                    WritePrivateProfileString(IS_BRANDING, TEXT("NoBackup"),
                        fBackupDisabled ? TEXT("1") : TEXT("0"), g_szCustIns);

                    if (IsDlgButtonChecked(hDlg, IDC_XFLAGFALSE) == BST_CHECKED)
                        WritePrivateProfileString(IS_BRANDING, TEXT("BrowserDefault"), TEXT("0"), g_szCustIns);
                    else
                    {
                        if (IsDlgButtonChecked(hDlg, IDC_XFLAGTRUE) == BST_CHECKED)
                            WritePrivateProfileString(IS_BRANDING, TEXT("BrowserDefault"), TEXT("1"), g_szCustIns);
                        else
                            WritePrivateProfileString(IS_BRANDING, TEXT("BrowserDefault"), TEXT("2"), g_szCustIns);
                    }
                    g_iCurPage = PPAGE_CORPCUSTOM;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;


                default:
                    return FALSE;

        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK SilentInstall(HWND hDlg, UINT message, WPARAM, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            break;


        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;


        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    if (!g_fDownload && !g_fLAN && !g_fCD)
                    {
                        g_fStealth = FALSE;
                        DisableDlgItem(hDlg, IDC_SILENTALL);
                    }

                    g_fSilent = GetPrivateProfileInt( BRANDING, SILENT_INSTALL, 0, g_szCustIns );
                    g_fStealth = GetPrivateProfileInt( BRANDING, TEXT("StealthInstall"), 0, g_szCustIns );

                    CheckRadioButton(hDlg, IDC_SILENTNOT, IDC_SILENTSOME,
                        g_fStealth ? IDC_SILENTALL : (g_fSilent ? IDC_SILENTSOME : IDC_SILENTNOT));

                    if (g_fLAN && !g_fDownload && !g_fCD && !g_fBrandingOnly)
                    {
                        ShowDlgItem(hDlg, IDC_URD);
                        ShowDlgItem(hDlg, IDC_URD_GROUP);
                        ShowDlgItem(hDlg, IDC_URD_TEXT1);
                        ShowDlgItem(hDlg, IDC_URD_TEXT2);
                        ShowDlgItem(hDlg, IDC_URD_TEXT3);
                        ReadBoolAndCheckButton(IS_HIDECUST, IK_URD_STR, FALSE, g_szCustIns, hDlg, IDC_URD);
                    }
                    else
                    {
                        CheckDlgButton(hDlg, IDC_URD, BST_UNCHECKED);
                        HideDlgItem(hDlg, IDC_URD);
                        HideDlgItem(hDlg, IDC_URD_GROUP);
                        HideDlgItem(hDlg, IDC_URD_TEXT1);
                        HideDlgItem(hDlg, IDC_URD_TEXT2);
                        HideDlgItem(hDlg, IDC_URD_TEXT3);
                    }

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    g_fSilent = IsDlgButtonChecked(hDlg, IDC_SILENTSOME);
                    WritePrivateProfileString( BRANDING, SILENT_INSTALL, g_fSilent ? TEXT("1") : TEXT("0"), g_szCustIns );

                    g_fStealth = IsDlgButtonChecked(hDlg, IDC_SILENTALL);
                    WritePrivateProfileString( BRANDING, TEXT("StealthInstall"), g_fStealth ? TEXT("1") : TEXT("0"), g_szCustIns );

                    CheckButtonAndWriteBool(hDlg, IDC_URD, IS_HIDECUST, IK_URD_STR, g_szCustIns);

                    g_iCurPage = PPAGE_SILENTINSTALL;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_WIZFINISH:
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK SecurityZonesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // ieaklite clean-up
            DeleteFileInDir(TEXT("seczones.inf"), g_szTempSign);
            DeleteFileInDir(TEXT("ratings.inf"),  g_szTempSign);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    BOOL fImport;

                    SetBannerText(hDlg);

                    fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportSecZones"), FALSE, g_szCustIns);
                    CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES, fImport ? IDC_IMPORTZONES : IDC_NOZONES);
                    EnableDlgItem2(hDlg, IDC_MODIFYZONES, fImport);

                    fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportRatings"), FALSE, g_szCustIns);
                    CheckRadioButton(hDlg, IDC_NORAT, IDC_IMPORTRAT, fImport ? IDC_IMPORTRAT : IDC_NORAT);
                    EnableDlgItem2(hDlg, IDC_MODIFYRAT, fImport);

                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                {
                    TCHAR szBrandingDir[MAX_PATH];
                    TCHAR szSecZonesInf[MAX_PATH];
                    TCHAR szRatingsInf[MAX_PATH];
                    HCURSOR hOldCur;

                    hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    // seczones.inf goes into the branding.cab
                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                    PathCombine(szSecZonesInf, szBrandingDir, TEXT("seczones.inf"));

                    ImportZones(g_szCustIns, NULL, szSecZonesInf, IsDlgButtonChecked(hDlg, IDC_IMPORTZONES) == BST_CHECKED);
                    
                    // ratings.inf goes into the branding.cab
                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                    PathCombine(szRatingsInf, szBrandingDir, TEXT("ratings.inf"));

                    ImportRatings(g_szCustIns, NULL, szRatingsInf, IsDlgButtonChecked(hDlg, IDC_IMPORTRAT) == BST_CHECKED);

                    SetCursor(hOldCur);

                    g_iCurPage = PPAGE_SECURITY;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;
                }

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_NOZONES:
                            DisableDlgItem(hDlg, IDC_MODIFYZONES);
                            break;

                        case IDC_IMPORTZONES:
                            EnableDlgItem(hDlg, IDC_MODIFYZONES);
                            break;

                        case IDC_MODIFYZONES:
                            ModifyZones(hDlg);
                            break;

                        case IDC_NORAT:
                            DisableDlgItem(hDlg, IDC_MODIFYRAT);
                            break;

                        case IDC_IMPORTRAT:
                            EnableDlgItem(hDlg, IDC_MODIFYRAT);
                            break;

                        case IDC_MODIFYRAT:
                            ModifyRatings(hDlg);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


INT_PTR CALLBACK SecurityCertsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // ieaklite clean-up
            DeleteFileInDir(TEXT("sitecert.inf"), g_szTempSign);
            DeleteFileInDir(TEXT("root.str"),     g_szTempSign);
            DeleteFileInDir(TEXT("ca.str"),       g_szTempSign);
            DeleteFileInDir(TEXT("authcode.inf"), g_szTempSign);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    BOOL fImport;

                    SetBannerText(hDlg);

                    fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportSiteCert"), FALSE, g_szCustIns);
                        
                    CheckRadioButton(hDlg, IDC_NOSC, IDC_IMPORTSC, fImport ? IDC_IMPORTSC : IDC_NOSC);
                    EnableDlgItem2(hDlg, IDC_MODIFYSC, fImport);

                    fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportAuthCode"), FALSE, g_szCustIns);
                    CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH, fImport ? IDC_IMPORTAUTH : IDC_NOAUTH);
                    EnableDlgItem2(hDlg, IDC_MODIFYAUTH, fImport);

                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                {
                    TCHAR szBrandingDir[MAX_PATH];
                    TCHAR szSiteCertInf[MAX_PATH];
                    TCHAR szRootStr[MAX_PATH];
                    TCHAR szCaStr[MAX_PATH];
                    TCHAR szAuthCodeInf[MAX_PATH];
                    HCURSOR hOldCur;

                    hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    // sitecert.inf, root.str and ca.str goes into the branding.cab
                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                    PathCombine(szSiteCertInf, szBrandingDir, TEXT("sitecert.inf"));
                    PathCombine(szRootStr, szBrandingDir, TEXT("root.str"));
                    PathCombine(szCaStr, szBrandingDir, TEXT("ca.str"));

                    ImportSiteCert(g_szCustIns, NULL, szSiteCertInf, IsDlgButtonChecked(hDlg, IDC_IMPORTSC) == BST_CHECKED);

                    // authcode.inf goes into the branding.cab
                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                    PathCombine(szAuthCodeInf, szBrandingDir, TEXT("authcode.inf"));

                    ImportAuthCode(g_szCustIns, NULL, szAuthCodeInf, IsDlgButtonChecked(hDlg, IDC_IMPORTAUTH) == BST_CHECKED);

                    SetCursor(hOldCur);

                    g_iCurPage = PPAGE_SECURITYCERT;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;
                }

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_NOSC:
                            DisableDlgItem(hDlg, IDC_MODIFYSC);
                            break;

                        case IDC_IMPORTSC:
                            EnableDlgItem(hDlg, IDC_MODIFYSC);
                            break;

                        case IDC_MODIFYSC:
                            ModifySiteCert(hDlg);
                            break;

                        case IDC_NOAUTH:
                            DisableDlgItem(hDlg, IDC_MODIFYAUTH);
                            break;

                        case IDC_IMPORTAUTH:
                            EnableDlgItem(hDlg, IDC_MODIFYAUTH);
                            break;

                        case IDC_MODIFYAUTH:
                            ModifyAuthCode(hDlg);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

/////////////////////////////////////////////////////////////////////////
//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  ShellExecuteExWrapW when you expected to see
//  ShellExecuteExW.
//
#include <w95wraps.h>

#include <windows.h>
#include <windowsx.h>

#include <commctrl.h>
#include <commdlg.h>
#include <prsht.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>
#include <inseng.h>
#include <advpub.h>
#include <ras.h>
#include <inetcpl.h>

#include <iedkbrnd.h>
#include "..\ieakutil\ieakutil.h"
#include "..\ieakeng\exports.h"

#include "..\ieakui\common.h"
#include "..\ieakui\resource.h"
#include "..\ieakui\wizard.h"
#include "..\ieakui\legacy.h"

#include "insengt.h"
#include "wizard.h"
#include "cabclass.h"
#include "utils.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\ieaklite.h ===
#include "precomp.h"

typedef enum tagIEAKLITEGROUP
{
    IL_ACTIVESETUP = 0,
    IL_CORPINSTALL,
    IL_CABSIGN,
    IL_ICM,
    IL_BROWSER,
    IL_URL,
    IL_FAV,
    IL_UASTR,
    IL_CONNECT,
    IL_SIGNUP,
    IL_CERT,
    IL_ZONES,
    IL_PROGRAMS,
    IL_MAILNEWS,
    IL_ADM,
    IL_END
};

typedef struct tagIEAKLITEINFO
{
    WORD idGroupName;
    WORD idCorpDesc;
    WORD idICPDesc;
    WORD idISPDesc;
    int  iListBox;
    BOOL fICP;
    BOOL fISP;
    BOOL fCorp;
    BOOL fEnabled;
} IEAKLITEINFO;

#define NUM_GROUPS IL_END

extern IEAKLITEINFO g_IEAKLiteArray[NUM_GROUPS];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\insengt.h ===
#ifndef _CIFTCHAR_H_
#define _CIFTCHAR_H_

// inseng tchar wrappers

// wrapper for ICifComponent

class CCifComponent_t
{
private:
    ICifRWComponent * pCifRWComponent;

public:
    CCifComponent_t(ICifRWComponent *);
    ~CCifComponent_t()   {};

    STDMETHOD(GetID)(LPTSTR pszID, DWORD cchSize);
    STDMETHOD(GetGUID)(LPTSTR pszGUID, DWORD cchSize);
    STDMETHOD(GetDescription)(LPTSTR pszDesc, DWORD cchSize);
    STDMETHOD(GetDetails)(LPTSTR pszDetails, DWORD cchSize);
    STDMETHOD(GetUrl)(UINT uUrlNum, LPTSTR pszUrl, DWORD cchSize, LPDWORD pdwUrlFlags);
    STDMETHOD(GetCommand)(UINT uCmdNum, LPTSTR pszCmd, DWORD cchCmdSize, LPTSTR pszSwitches,
        DWORD cchSwitchSize, LPDWORD pdwType);
    STDMETHOD(GetVersion)(LPDWORD pdwVersion, LPDWORD pdwBuild);
    STDMETHOD_(DWORD, GetDownloadSize)();
    STDMETHOD(GetDependency)(UINT uDepNum, LPTSTR pszID, DWORD cchSize, TCHAR *pchType, LPDWORD pdwVer, LPDWORD pdwBuild);
    STDMETHOD_(DWORD, GetPlatform)();
    STDMETHOD(GetMode)(UINT uModeNum, LPTSTR pszModes, DWORD cchSize);
    STDMETHOD(GetGroup)(LPTSTR pszID, DWORD cchSize);
    STDMETHOD(IsUIVisible)();
    STDMETHOD(GetCustomData)(LPTSTR pszKey, LPTSTR pszData, DWORD cchSize);
};

// wrapper for ICifRWComponent
class CCifRWComponent_t : public CCifComponent_t
{
private:
    ICifRWComponent * pCifRWComponent;

public:
    CCifRWComponent_t(ICifRWComponent *);
    ~CCifRWComponent_t()  {};

    STDMETHOD(SetGUID)(LPCTSTR pszGUID);
    STDMETHOD(SetDescription)(LPCTSTR pszDesc);
    STDMETHOD(SetCommand)(UINT uCmdNum, LPCTSTR pszCmd, LPCTSTR pszSwitches, DWORD dwType);
    STDMETHOD(SetVersion)(LPCTSTR pszVersion);
    STDMETHOD(SetUninstallKey)(LPCTSTR pszKey);
    STDMETHOD(SetInstalledSize)(DWORD dwWin, DWORD dwApp);
    STDMETHOD(SetDownloadSize)(DWORD);
    STDMETHOD(SetExtractSize)(DWORD);
    STDMETHOD(DeleteDependency)(LPCTSTR pszID, TCHAR chType);
    STDMETHOD(AddDependency)(LPCTSTR pszID, TCHAR chType);
    STDMETHOD(SetUIVisible)(BOOL);
    STDMETHOD(SetGroup)(LPCTSTR pszID);
    STDMETHOD(SetPlatform)(DWORD);
    STDMETHOD(SetPriority)(DWORD);
    STDMETHOD(SetReboot)(BOOL);
    STDMETHOD(SetUrl)(UINT uUrlNum, LPCTSTR pszUrl, DWORD dwUrlFlags);

    STDMETHOD(DeleteFromModes)(LPCTSTR pszMode);
    STDMETHOD(AddToMode)(LPCTSTR pszMode);
    STDMETHOD(SetModes)(LPCTSTR pszMode);
    STDMETHOD(CopyComponent)(LPCTSTR pszCifFile);
    STDMETHOD(AddToTreatAsOne)(LPCTSTR pszCompID);
    STDMETHOD(SetDetails)(LPCTSTR pszDesc);
};

// wrapper for ICifRWGroup

class CCifRWGroup_t
{
private:
    ICifRWGroup * pCifRWGroup;

public:
    CCifRWGroup_t(ICifRWGroup *);
    ~CCifRWGroup_t()  {};

    STDMETHOD(GetDescription)(LPTSTR pszDesc, DWORD cchSize);
    STDMETHOD_(DWORD, GetPriority)();

    STDMETHOD(SetDescription)(LPCTSTR pszDesc);
    STDMETHOD(SetPriority)(DWORD);
};

// wrapper for ICifMode

class CCifMode_t
{
private:
    ICifRWMode * pCifRWMode;

public:
    CCifMode_t(ICifRWMode *);
    ~CCifMode_t() {};

    STDMETHOD(GetID)(LPTSTR pszID, DWORD cchSize);
    STDMETHOD(GetDescription)(LPTSTR pszDesc, DWORD cchSize);
    STDMETHOD(GetDetails)(LPTSTR pszDetails, DWORD cchSize);
};

// wrapper for ICifRWMode
class CCifRWMode_t : public CCifMode_t
{
private:
    ICifRWMode * pCifRWMode;

public:
    CCifRWMode_t(ICifRWMode *);
    ~CCifRWMode_t()  {};

    STDMETHOD(SetDescription)(LPCTSTR pszDesc);
    STDMETHOD(SetDetails)(LPCTSTR pszDetails);
};

// wrapper for ICifFile
class CCifFile_t
{
private:
    ICifRWFile * pCifRWFile;

public:
    CCifFile_t(ICifRWFile *);
    ~CCifFile_t();

    STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
    STDMETHOD(FindComponent)(LPCTSTR pszID, ICifComponent **p);

    STDMETHOD(EnumModes)(IEnumCifModes **, DWORD dwFilter, LPVOID pv);
    STDMETHOD(FindMode)(LPCTSTR pszID, ICifMode **p);

    STDMETHOD(GetDescription)(LPTSTR pszDesc, DWORD cchSize);
};

// wrapper for ICifRWFile

class CCifRWFile_t : public CCifFile_t
{
private:
    ICifRWFile * pCifRWFile;

public:
    CCifRWFile_t(ICifRWFile *);
    ~CCifRWFile_t() {};     // release will be taken care of by CCifFile_t destructor

    // ICifRWFile methods
    STDMETHOD(SetDescription)(LPCTSTR pszDesc);
    STDMETHOD(CreateComponent)(LPCTSTR pszID, ICifRWComponent **p);
    STDMETHOD(CreateGroup)(LPCTSTR pszID, ICifRWGroup **p);
    STDMETHOD(CreateMode)(LPCTSTR pszID, ICifRWMode **p);
    STDMETHOD(DeleteComponent)(LPCTSTR pszID);
    STDMETHOD(DeleteGroup)(LPCTSTR pszID);
    STDMETHOD(DeleteMode)(LPCTSTR pszID);
    STDMETHOD(Flush)();
};

HRESULT GetICifFileFromFile_t(CCifFile_t **, LPCTSTR pszCifFile);
HRESULT GetICifRWFileFromFile_t(CCifRWFile_t **, LPCTSTR pszCifFile);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\keymake.cpp ===
#include "precomp.h"

extern BOOL g_fDemo, g_fKeyGood;
extern BOOL g_fBranded, g_fIntranet;
extern BOOL g_fSilent;
extern int g_iKeyType;

// Note: this function is also in ..\keymaker\keymake.c so make changes in both places

void MakeKey(LPTSTR pszSeed, BOOL fCorp)
{
    int i;
    DWORD dwKey;
    CHAR szKeyA[5];
    CHAR szSeedA[16];

    // always do the keycode create in ANSI

    T2Abux(pszSeed, szSeedA);
    i = lstrlenA(szSeedA);

    if (i < 6)
    {
        // extend the input seed to 6 characters
        for (; i < 6; i++)
            szSeedA[i] = (char)('0' + i);
    }

    // let's calculate the DWORD key used for the last 4 chars of keycode

    // multiply by my first name

    dwKey = szSeedA[0] * 'O' + szSeedA[1] * 'L' + szSeedA[2] * 'I' +
        szSeedA[3] * 'V' + szSeedA[4] * 'E' + szSeedA[5] * 'R';

    // multiply the result by JONCE

    dwKey *= ('J' + 'O' + 'N' + 'C' + 'E');

    dwKey %= 10000;

    if (fCorp)
    {
        // give a separate keycode based on corp flag or not
        // 9 is chosen because is is a multiplier such that for any x,
        // (x+214) * 9 != x + 10000y
        // we have 8x = 10000y - 1926 which when y=1 gives us 8x = 8074
        // since 8074 is not divisible by 8 where guaranteed to be OK since
        // the number on the right can only increase by 10000 increments which
        // are always divisible by 8

        dwKey += ('L' + 'E' + 'E');
        dwKey *= 9;
        dwKey %= 10000;
    }

    wsprintfA(szKeyA, "%04lu", dwKey);
    StrCpyA(&szSeedA[6], szKeyA);
    A2Tbux(szSeedA, pszSeed);
}

BOOL CheckKey(LPTSTR pszKey)
{
    TCHAR szBaseKey[16];

    CharUpper(pszKey);
    StrCpy(szBaseKey, pszKey);
    g_fDemo = g_fKeyGood = FALSE;
    g_iKeyType = KEY_TYPE_STANDARD;

    // check for MS key code

    if (StrCmpI(pszKey, TEXT("MICROSO800")) == 0)
    {
        g_fKeyGood = TRUE;
        return TRUE;
    }

    // check for ISP key code

    MakeKey(szBaseKey, FALSE);

    if (StrCmpI(szBaseKey, pszKey) == 0)
    {
        g_iKeyType = KEY_TYPE_SUPER;
        g_fKeyGood = TRUE;
        g_fBranded = TRUE;
        g_fIntranet = g_fSilent = FALSE;
        return TRUE;
    }

    // check for a corp key code

    MakeKey(szBaseKey, TRUE);

    if (StrCmpI(szBaseKey, pszKey) == 0)
    {
        g_iKeyType = KEY_TYPE_SUPERCORP;
        g_fKeyGood = TRUE;
        g_fBranded = TRUE;
        g_fIntranet = TRUE;
        return TRUE;
    }

    // check for demo key code

    if (StrCmpNI(pszKey, TEXT("DEMO"), 4) == 0  &&  lstrlen(pszKey) > 9)
    {
        g_fDemo = TRUE;
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\programs.cpp ===
#include "precomp.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szTempSign[];
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fImport;

    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            // import INS clean-up -- delete old content
            DeleteFileInDir(TEXT("programs.inf"), g_szTempSign);

            SetBannerText(hDlg);

            fImport = !InsIsKeyEmpty(IS_EXTREGINF, IK_PROGRAMS, g_szCustIns);

            CheckRadioButton(hDlg, IDC_PROGNOIMPORT, IDC_PROGIMPORT, fImport ? IDC_PROGIMPORT : IDC_PROGNOIMPORT);
            EnableDlgItem2(hDlg, IDC_MODIFYPROG, fImport);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            fImport = (IsDlgButtonChecked(hDlg, IDC_PROGIMPORT) == BST_CHECKED);

            {
                TCHAR szBrandingDir[MAX_PATH];

                CNewCursor cur(IDC_WAIT);

                g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                ImportPrograms(g_szCustIns, szBrandingDir, fImport);
            }

            g_iCurPage = PPAGE_PROGRAMS;
            EnablePages();
            (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_PROGNOIMPORT:
            DisableDlgItem(hDlg, IDC_MODIFYPROG);
            break;

        case IDC_PROGIMPORT:
            EnableDlgItem(hDlg, IDC_MODIFYPROG);
            break;

        case IDC_MODIFYPROG:
            ShowInetcpl(hDlg, INET_PAGE_PROGRAMS);
            break;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\insengt.cpp ===
#include "precomp.h"

// CCifComponent_t

CCifComponent_t::CCifComponent_t(ICifRWComponent * pCifRWComponentIn)
{
    pCifRWComponent = pCifRWComponentIn;
}

STDMETHODIMP CCifComponent_t::GetID(LPTSTR pszID, DWORD cchSize)
{
    CHAR szID[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetID(szID, countof(szID));
    A2Tbuf(szID, pszID, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetGUID(LPTSTR pszGUID, DWORD cchSize)
{
    CHAR szGUID[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetGUID(szGUID, countof(szGUID));
    A2Tbuf(szGUID, pszGUID, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetDescription(LPTSTR pszDesc, DWORD cchSize)
{
    CHAR szDesc[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetDescription(szDesc, countof(szDesc));
    A2Tbuf(szDesc, pszDesc, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetDetails(LPTSTR pszDetails, DWORD cchSize)
{
    CHAR szDetails[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetDetails(szDetails, countof(szDetails));
    A2Tbuf(szDetails, pszDetails, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetUrl(UINT uUrlNum, LPTSTR pszUrl, DWORD cchSize, LPDWORD pdwUrlFlags)
{
    CHAR szUrl[INTERNET_MAX_URL_LENGTH];
    HRESULT hr;

    hr = pCifRWComponent->GetUrl(uUrlNum, szUrl, countof(szUrl), pdwUrlFlags);
    A2Tbuf(szUrl, pszUrl, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetCommand(UINT uCmdNum, LPTSTR pszCmd, DWORD cchCmdSize, LPTSTR pszSwitches,
                                              DWORD cchSwitchSize, LPDWORD pdwType)
{
    CHAR szCmd[MAX_PATH];
    CHAR szSwitches[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetCommand(uCmdNum, szCmd, countof(szCmd),
        szSwitches, countof(szSwitches), pdwType);
    A2Tbuf(szCmd, pszCmd, cchCmdSize);
    A2Tbuf(szSwitches, pszSwitches, cchSwitchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetVersion(LPDWORD pdwVersion, LPDWORD pdwBuild)
{
    return pCifRWComponent->GetVersion(pdwVersion, pdwBuild);
}

STDMETHODIMP_(DWORD) CCifComponent_t::GetDownloadSize()
{
    return pCifRWComponent->GetDownloadSize();
}

STDMETHODIMP CCifComponent_t::GetDependency(UINT uDepNum, LPTSTR pszID, DWORD cchSize, TCHAR *pchType,
                                            LPDWORD pdwVer, LPDWORD pdwBuild)
{
    CHAR szID[MAX_PATH];
    CHAR chType;
    HRESULT hr;

    hr = pCifRWComponent->GetDependency(uDepNum, szID, countof(szID), &chType, pdwVer, pdwBuild);
    A2Tbuf(szID, pszID, cchSize);
    *pchType = (TCHAR)chType;

    return hr;
}

STDMETHODIMP_(DWORD) CCifComponent_t::GetPlatform()
{
    return pCifRWComponent->GetPlatform();
}

STDMETHODIMP CCifComponent_t::GetMode(UINT uModeNum, LPTSTR pszModes, DWORD cchSize)
{
    CHAR szModes[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetMode(uModeNum, szModes, countof(szModes));
    A2Tbuf(szModes, pszModes, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetGroup(LPTSTR pszID, DWORD cchSize)
{
    CHAR szID[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetGroup(szID, countof(szID));
    A2Tbuf(szID, pszID, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::IsUIVisible()
{
    return pCifRWComponent->IsUIVisible();
}

STDMETHODIMP CCifComponent_t::GetCustomData(LPTSTR pszKey, LPTSTR pszData, DWORD cchSize)
{
    CHAR szData[MAX_PATH];
    HRESULT hr;

    USES_CONVERSION;

    hr = pCifRWComponent->GetCustomData(T2A(pszKey), szData, countof(szData));
    A2Tbuf(szData, pszData, cchSize);

    return hr;
}

// CCifRWComponent_t

CCifRWComponent_t::CCifRWComponent_t(ICifRWComponent * pCifRWComponentIn) : CCifComponent_t(pCifRWComponentIn)
{
    pCifRWComponent = pCifRWComponentIn;
}

STDMETHODIMP CCifRWComponent_t::SetGUID(LPCTSTR pszGUID)
{
    USES_CONVERSION;

    return pCifRWComponent->SetGUID(T2CA(pszGUID));
}

STDMETHODIMP CCifRWComponent_t::SetDescription(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWComponent->SetDescription(T2CA(pszDesc));
}

STDMETHODIMP CCifRWComponent_t::SetCommand(UINT uCmdNum, LPCTSTR pszCmd, LPCTSTR pszSwitches, DWORD dwType)
{
    USES_CONVERSION;

    return pCifRWComponent->SetCommand(uCmdNum, T2CA(pszCmd), T2CA(pszSwitches), dwType);
}

STDMETHODIMP CCifRWComponent_t::SetVersion(LPCTSTR pszVersion)
{
    USES_CONVERSION;

    return pCifRWComponent->SetVersion(T2CA(pszVersion));
}

STDMETHODIMP CCifRWComponent_t::SetUninstallKey(LPCTSTR pszKey)
{
    USES_CONVERSION;

    return pCifRWComponent->SetUninstallKey(T2CA(pszKey));
}

STDMETHODIMP CCifRWComponent_t::SetInstalledSize(DWORD dwWin, DWORD dwApp)
{
    return pCifRWComponent->SetInstalledSize(dwWin, dwApp);
}

STDMETHODIMP CCifRWComponent_t::SetDownloadSize(DWORD dwSize)
{
    return pCifRWComponent->SetDownloadSize(dwSize);
}

STDMETHODIMP CCifRWComponent_t::SetExtractSize(DWORD dwSize)
{
    return pCifRWComponent->SetExtractSize(dwSize);
}

STDMETHODIMP CCifRWComponent_t::DeleteDependency(LPCTSTR pszID, TCHAR tchType)
{
    USES_CONVERSION;

    return pCifRWComponent->DeleteDependency(T2CA(pszID), (CHAR)tchType);
}

STDMETHODIMP CCifRWComponent_t::AddDependency(LPCTSTR pszID, TCHAR tchType)
{
    USES_CONVERSION;

    return pCifRWComponent->AddDependency(T2CA(pszID), (CHAR)tchType);
}

STDMETHODIMP CCifRWComponent_t::SetUIVisible(BOOL fVisible)
{
    return pCifRWComponent->SetUIVisible(fVisible);
}

STDMETHODIMP CCifRWComponent_t::SetGroup(LPCTSTR pszID)
{
    USES_CONVERSION;

    return pCifRWComponent->SetGroup(T2CA(pszID));
}

STDMETHODIMP CCifRWComponent_t::SetPlatform(DWORD dwPlatform)
{
    return pCifRWComponent->SetPlatform(dwPlatform);
}

STDMETHODIMP CCifRWComponent_t::SetPriority(DWORD dwPriority)
{
    return pCifRWComponent->SetPriority(dwPriority);
}

STDMETHODIMP CCifRWComponent_t::SetReboot(BOOL fReboot)
{
    return pCifRWComponent->SetReboot(fReboot);
}

STDMETHODIMP CCifRWComponent_t::SetUrl(UINT uUrlNum, LPCTSTR pszUrl, DWORD dwUrlFlags)
{
    USES_CONVERSION;

    return pCifRWComponent->SetUrl(uUrlNum, T2CA(pszUrl), dwUrlFlags);
}

STDMETHODIMP CCifRWComponent_t::DeleteFromModes(LPCTSTR pszMode)
{
    USES_CONVERSION;

    return pCifRWComponent->DeleteFromModes(T2CA(pszMode));
}

STDMETHODIMP CCifRWComponent_t::AddToMode(LPCTSTR pszMode)
{
    USES_CONVERSION;

    return pCifRWComponent->AddToMode(T2CA(pszMode));
}

STDMETHODIMP CCifRWComponent_t::SetModes(LPCTSTR pszMode)
{
    USES_CONVERSION;

    return pCifRWComponent->SetModes(T2CA(pszMode));
}

STDMETHODIMP CCifRWComponent_t::CopyComponent(LPCTSTR pszCifFile)
{
    USES_CONVERSION;

    return pCifRWComponent->CopyComponent(T2CA(pszCifFile));
}

STDMETHODIMP CCifRWComponent_t::AddToTreatAsOne(LPCTSTR pszCompID)
{
    USES_CONVERSION;

    return pCifRWComponent->AddToTreatAsOne(T2CA(pszCompID));
}

STDMETHODIMP CCifRWComponent_t::SetDetails(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWComponent->SetDetails(T2CA(pszDesc));
}

// CCifRWGroup_t

CCifRWGroup_t::CCifRWGroup_t(ICifRWGroup * pCifRWGroupIn)
{
    pCifRWGroup = pCifRWGroupIn;
}

STDMETHODIMP CCifRWGroup_t::GetDescription(LPTSTR pszDesc, DWORD cchSize)
{
    CHAR szDesc[MAX_PATH];
    HRESULT hr;

    USES_CONVERSION;

    hr = pCifRWGroup->GetDescription(szDesc, countof(szDesc));
    A2Tbuf(szDesc, pszDesc, cchSize);

    return hr;
}

STDMETHODIMP_(DWORD) CCifRWGroup_t::GetPriority()
{
    return pCifRWGroup->GetPriority();
}

STDMETHODIMP CCifRWGroup_t::SetDescription(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWGroup->SetDescription(T2CA(pszDesc));
}

STDMETHODIMP CCifRWGroup_t::SetPriority(DWORD dwPriority)
{
    return pCifRWGroup->SetPriority(dwPriority);
}

// CCifMode_t

CCifMode_t::CCifMode_t(ICifRWMode * pCifRWModeIn)
{
    pCifRWMode = pCifRWModeIn;
}

STDMETHODIMP CCifMode_t::GetID(LPTSTR pszID, DWORD cchSize)
{
    CHAR szID[MAX_PATH];
    HRESULT hr;

    hr = pCifRWMode->GetID(szID, countof(szID));
    A2Tbuf(szID, pszID, cchSize);

    return hr;
}

STDMETHODIMP CCifMode_t::GetDescription(LPTSTR pszDesc, DWORD cchSize)
{
    CHAR szDesc[MAX_PATH];
    HRESULT hr;

    hr = pCifRWMode->GetDescription(szDesc, countof(szDesc));
    A2Tbuf(szDesc, pszDesc, cchSize);

    return hr;
}

STDMETHODIMP CCifMode_t::GetDetails(LPTSTR pszDetails, DWORD cchSize)
{
    CHAR szDetails[MAX_PATH];
    HRESULT hr;

    hr = pCifRWMode->GetDetails(szDetails, countof(szDetails));
    A2Tbuf(szDetails, pszDetails, cchSize);

    return hr;
}

// CCifRWMode_t

CCifRWMode_t::CCifRWMode_t(ICifRWMode * pCifRWModeIn) : CCifMode_t(pCifRWModeIn)
{
    pCifRWMode = pCifRWModeIn;
}

STDMETHODIMP CCifRWMode_t::SetDescription(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWMode->SetDescription(T2CA(pszDesc));
}

STDMETHODIMP CCifRWMode_t::SetDetails(LPCTSTR pszDetails)
{
    USES_CONVERSION;

    return pCifRWMode->SetDetails(T2CA(pszDetails));
}

// CCifFile_t

CCifFile_t::CCifFile_t(ICifRWFile * pCifRWFileIn)
{
    pCifRWFile = pCifRWFileIn;
}

CCifFile_t::~CCifFile_t()
{
    if (pCifRWFile != NULL)
    {
        pCifRWFile->Release();
        pCifRWFile = NULL;
    }
}

STDMETHODIMP CCifFile_t::EnumComponents(IEnumCifComponents ** ppEnumCifComponents,
                                            DWORD dwFilter, LPVOID pv)
{
    return pCifRWFile->EnumComponents(ppEnumCifComponents, dwFilter, pv);
}

STDMETHODIMP CCifFile_t::FindComponent(LPCTSTR pszID, ICifComponent **p)
{
    USES_CONVERSION;

    return pCifRWFile->FindComponent(T2CA(pszID), p);
}

STDMETHODIMP CCifFile_t::EnumModes(IEnumCifModes ** ppEnumCifModes, DWORD dwFilter, LPVOID pv)
{
    return pCifRWFile->EnumModes(ppEnumCifModes, dwFilter, pv);
}

STDMETHODIMP CCifFile_t::FindMode(LPCTSTR pszID, ICifMode **p)
{
    USES_CONVERSION;

    return pCifRWFile->FindMode(T2CA(pszID), p);
}

STDMETHODIMP CCifFile_t::GetDescription(LPTSTR pszDesc, DWORD cchSize)
{
    CHAR szDesc[MAX_PATH];
    HRESULT hr;

    hr = pCifRWFile->GetDescription(szDesc, countof(szDesc));
    A2Tbuf(szDesc, pszDesc, cchSize);

    return hr;
}

// CCifRWFile_t

CCifRWFile_t::CCifRWFile_t(ICifRWFile * pCifRWFileIn) : CCifFile_t(pCifRWFileIn)
{
    pCifRWFile = pCifRWFileIn;
}

STDMETHODIMP CCifRWFile_t::SetDescription(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWFile->SetDescription(T2CA(pszDesc));
}

STDMETHODIMP CCifRWFile_t::CreateComponent(LPCTSTR pszID, ICifRWComponent **p)
{
    USES_CONVERSION;

    return pCifRWFile->CreateComponent(T2CA(pszID), p);
}

STDMETHODIMP CCifRWFile_t::CreateGroup(LPCTSTR pszID, ICifRWGroup **p)
{
    USES_CONVERSION;

    return pCifRWFile->CreateGroup(T2CA(pszID), p);
}

STDMETHODIMP CCifRWFile_t::CreateMode(LPCTSTR pszID, ICifRWMode **p)
{
    USES_CONVERSION;

    return pCifRWFile->CreateMode(T2CA(pszID), p);
}

STDMETHODIMP CCifRWFile_t::DeleteComponent(LPCTSTR pszID)
{
    USES_CONVERSION;

    return pCifRWFile->DeleteComponent(T2CA(pszID));
}

STDMETHODIMP CCifRWFile_t::DeleteGroup(LPCTSTR pszID)
{
    USES_CONVERSION;

    return pCifRWFile->DeleteGroup(T2CA(pszID));
}

STDMETHODIMP CCifRWFile_t::DeleteMode(LPCTSTR pszID)
{
    USES_CONVERSION;

    return pCifRWFile->DeleteMode(T2CA(pszID));
}

STDMETHODIMP CCifRWFile_t::Flush()
{
    return pCifRWFile->Flush();
}


// cif functions

HRESULT GetICifFileFromFile_t(CCifFile_t ** ppCifFile_t, LPCTSTR pszCifFile)
{
    ICifFile * lpCifFile;
    HRESULT hr;

    USES_CONVERSION;

    if (SUCCEEDED(hr = GetICifFileFromFile(&lpCifFile, T2CA(pszCifFile))))
        *ppCifFile_t = new CCifFile_t((ICifRWFile *)lpCifFile);

    return hr;
}

HRESULT GetICifRWFileFromFile_t(CCifRWFile_t ** ppCifFile_t, LPCTSTR pszCifFile)
{
    ICifRWFile * lpCifRWFile;
    HRESULT hr;

    USES_CONVERSION;

    if (SUCCEEDED(hr = GetICifRWFileFromFile(&lpCifRWFile, T2CA(pszCifFile))))
        *ppCifFile_t = new CCifRWFile_t(lpCifRWFile);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizard.rc
//
#define IDI_WIZARD                      101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1001
#define _APS_NEXT_COMMAND_VALUE         20001
#define _APS_NEXT_CONTROL_VALUE         10001
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\updates.h ===
#define DONT_SHOW_UPDATES       0xdeadbeef 
#define SHOW_UPDATES            0xabaddeed

typedef HRESULT (* FCLV_PREADDLISTITEM)(HWND hListView, int * count, CCifComponent_t *);

extern PCOMPONENT g_paComp;
extern PCOMPONENT g_pMNComp;
extern TCHAR g_szIEAKProg[MAX_PATH];
extern TCHAR g_szCifVer[MAX_PATH];
extern TCHAR g_szCif[MAX_PATH];
extern TCHAR g_szUpdateURL[MAX_URL];
extern TCHAR g_szUpdateData[MAX_URL];
extern UINT g_uiNumCabs;
extern BOOL g_fOCW;

extern HIMAGELIST s_hImgList;
extern HWND s_hStat;
extern int s_aiIcon[7];
extern DWORD GetRootFree(LPCTSTR pcszPath);
extern void updateCifVersions32(PCOMPONENT pComp, BOOL fIgnore, BOOL fUpdate);
extern PCOMPONENT FindComp(LPCTSTR szID, BOOL fCore);
extern INT_PTR CALLBACK ErrDlgProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
extern int DownloadErrMsg(HWND hWnd, LPTSTR szFilename, LPCTSTR lpTemplateName);
extern HRESULT DownloadCab(HWND hDlg, LPTSTR szUrl, LPTSTR szFilename, LPCTSTR pcszDisplayname, int sComponent, BOOL &fIgnore);

void InsertCommas(LPTSTR szIn);

ATOM CreateIEAKUrl();

void UpdateBlueIcon(HWND hCompList, PCOMPONENT pComp);

void UpdateBrownIcon(HWND hCompList, PCOMPONENT pNewComp);

HRESULT ProcessUpdateIcons(HWND hDlg);

HRESULT CifComponentToPComponent(PCOMPONENT pComp, CCifComponent_t * pCifComponent_t);

HRESULT DownloadUpdate(PCOMPONENT pComp);

void InitAVSListView(HWND hCompList);

HRESULT AssignComponentIcon(LPTSTR szInID, int pageNumber);

HRESULT PreAddListItem(HWND hCompList, int * count, CCifComponent_t * pCifComp);

int FillComponentsListView(HWND hCompList, LPCTSTR szCifPath, FCLV_PREADDLISTITEM pfnPreAddListItem);

DWORD InitUpdateThreadProc(LPVOID lParam);

DWORD UpdateDlg_InitDialog(HWND hDlg, LPTSTR ps_szFreeSpace, LPTSTR ps_szTotalSize);

PCOMPONENT* UpdateDlg_GetDownloadList(HWND hDlg);

void UpdateDlg_GetDownloadSize(HWND hCompList, HWND hStatusField, BOOL fAll);

LRESULT CALLBACK HyperLinkWndProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK UpdateDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\status.cpp ===
#include "precomp.h"

extern BOOL g_fBatch;
extern BOOL g_fBatch2;
extern RECT g_dtRect;

HWND g_hProgress;
HWND g_hStatusDlg;

static void setBoldFace(HWND hDlg, int idControl, BOOL fBold);

void UpdateProgress(int iProgress)
{
    static s_iProgress = 0;

    if (iProgress == -1)
        s_iProgress = 100;
    else
        s_iProgress += iProgress;

    if (s_iProgress > 100)
    {
        s_iProgress = 100;
        ASSERT(FALSE);
    }

    SendMessage(g_hProgress, PBM_SETPOS, s_iProgress, 0L);
}

void StatusDialog (UINT nStep)
{
    if (g_fBatch || g_fBatch2)
        return;

    switch (nStep)
    {
    case SD_STEP1:
        setBoldFace(g_hStatusDlg, IDC_STEP1, TRUE);
        break;

    case SD_STEP2:
        setBoldFace(g_hStatusDlg, IDC_STEP1, FALSE);
        setBoldFace(g_hStatusDlg, IDC_STEP3, TRUE);
        break;
    }
}

static void setBoldFace(HWND hDlg, int idControl, BOOL fBold)
{
    HFONT hFont;
    LOGFONT lfFont;

    hFont = (HFONT) SendDlgItemMessage(hDlg, idControl, WM_GETFONT, 0, 0);

    GetObject(hFont, sizeof(lfFont), &lfFont);
    lfFont.lfWeight = fBold ? FW_BOLD : FW_NORMAL;

    hFont = CreateFontIndirect(&lfFont);

    SendDlgItemMessage(hDlg, idControl, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\signup.cpp ===
#include "precomp.h"


// external variable declarations
extern TCHAR g_szCustIns[];
extern TCHAR g_szBuildRoot[];
extern TCHAR g_szLanguage[];
extern TCHAR g_szTempSign[];
extern BOOL g_fBrandingOnly;
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;


// macro definitions
#define MAX_SIGNUP_FILES 50


// type definitions
typedef struct tagSIGNUPFILE
{
    TCHAR szEntryName[RAS_MaxEntryName + 1];

    TCHAR szEntryPath[MAX_PATH];

    TCHAR szAreaCode[RAS_MaxAreaCode + 1];
    TCHAR szPhoneNumber[RAS_MaxPhoneNumber + 1];
    TCHAR szCountryCode[8];
    TCHAR szCountryId[8];

    TCHAR szName[64];
    TCHAR szPassword[64];

    TCHAR szSupportNum[RAS_MaxPhoneNumber + 1];

    TCHAR szSignupURL[MAX_URL];

    struct
    {
        BOOL  fStaticDNS;
        TCHAR szDNSAddress[32];
        TCHAR szAltDNSAddress[32];

        BOOL  fRequiresLogon:1;
        BOOL  fNegTCPIP:1;
        BOOL  fDisableLCP:1;
        BOOL  fDialAsIs:1;

        BOOL  fPWEncrypt:1;
        BOOL  fSWCompress:1;
        BOOL  fIPHdrComp:1;
        BOOL  fDefGate:1;

        BOOL  fDontApplyIns:1;
        BOOL  fDontModify:1;
        BOOL  fApplyIns:1;
        TCHAR szBrandingCabName[64];
        TCHAR szBrandingCabURL[MAX_URL];
    } Advanced;
} SIGNUPFILE,*PSIGNUPFILE;


// prototype declaration of functions defined in this file
static INT_PTR CALLBACK SignupDlgProcHelper(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam,
                                            HWND hwndCombo, PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems,
                                            DWORD &nSignupFiles, INT &iSelIndex, BOOL fIsp);

static INT_PTR CALLBACK IspPopupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static INT_PTR CALLBACK InsPopupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static INT_PTR CALLBACK SignupPopupDlgProcHelper(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM,
                                                 PSIGNUPFILE pSignupFile, BOOL fIsp);

static VOID UpdateSignupFilesStatus(HWND hDlg, LPCTSTR pcszSignupPath);

static DWORD InitSignupFileArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems,
                                 HWND hwndCombo, BOOL fIsp);
static VOID SaveSignupFileArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, BOOL fIsp);

static VOID ReadSignupFile(PSIGNUPFILE pSignupFile, LPCTSTR pcszSignupFile, BOOL fIsp);
static VOID WriteSignupFile(PSIGNUPFILE pSignupFile, LPCTSTR pcszSignupFile, BOOL fIsp);

static INT NewSignupFileEntry(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, HWND hwndCombo,
                              BOOL fIsp);
static VOID SetSignupFileEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp);
static BOOL SaveSignupFileEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp);

static VOID SetSignupFileAdvancedEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp);
static BOOL SaveSignupFileAdvancedEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp);

static VOID SetDlgIPAddress(HWND hDlg, LPCTSTR pcszIPAddress, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD);
static VOID GetDlgIPAddress(HWND hDlg, LPTSTR  pszIPAddress,  INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD);
static BOOL VerifyDlgIPAddress(HWND hDlg, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD);

static PSIGNUPFILE IsEntryPathInSignupArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, LPCTSTR pcszEntryPath);

static VOID CleanupSignupFiles(LPCTSTR pcszTempDir, LPCTSTR pcszIns);


// global variables
BOOL g_fServerICW = FALSE;
BOOL g_fServerKiosk = FALSE;
BOOL g_fServerless = FALSE;
BOOL g_fNoSignup = FALSE;

BOOL g_fSkipServerIsps = FALSE;
BOOL g_fSkipIspIns = FALSE;

TCHAR g_szSignup[MAX_PATH];

static TCHAR s_szIsp[MAX_PATH];
static SIGNUPFILE s_SignupFileArray[MAX_SIGNUP_FILES];


INT_PTR CALLBACK QuerySignupDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    INT id;

                    SetBannerText(hDlg);

                    // do IEAKLite mode clean-up here
                    CleanupSignupFiles(g_szTempSign, g_szCustIns);

                    // initialize signup mode
                    g_fServerICW = InsGetBool(IS_BRANDING, IK_USEICW, 0, g_szCustIns);
                    g_fServerKiosk = InsGetBool(IS_BRANDING, IK_SERVERKIOSK, 0, g_szCustIns);
                    g_fServerless = InsGetBool(IS_BRANDING, IK_SERVERLESS, 0, g_szCustIns);
                    g_fNoSignup = InsGetBool(IS_BRANDING, IK_NODIAL, 0, g_szCustIns);

                    if (!IsWindowEnabled(GetDlgItem(hDlg, IDC_ISS2)))
                        g_fServerICW = FALSE;

                    if (g_fServerICW)
                        id = IDC_ISS2;
                    else if (g_fServerKiosk)
                        id = IDC_ISS;
                    else if (g_fServerless)
                        id = IDC_SERVLESS;
                    else if (g_fNoSignup)
                        id = IDC_NOSIGNUP;
                    else 
                        id = IDC_ISS2;

                    CheckRadioButton(hDlg, IDC_ISS2, IDC_NOSIGNUP, id);

                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_ISS2)))
                        g_fServerICW = (IsDlgButtonChecked(hDlg, IDC_ISS2) == BST_CHECKED);
                    else
                        g_fServerICW = FALSE;
                    g_fServerKiosk = (IsDlgButtonChecked(hDlg, IDC_ISS) == BST_CHECKED);
                    g_fServerless = (IsDlgButtonChecked(hDlg, IDC_SERVLESS) == BST_CHECKED);
                    g_fNoSignup = (IsDlgButtonChecked(hDlg, IDC_NOSIGNUP) == BST_CHECKED);

                    InsWriteBool(IS_BRANDING, IK_USEICW, g_fServerICW, g_szCustIns);
                    InsWriteBool(IS_BRANDING, IK_SERVERKIOSK, g_fServerKiosk, g_szCustIns);
                    InsWriteBool(IS_BRANDING, IK_SERVERLESS, g_fServerless, g_szCustIns);
                    InsWriteBool(IS_BRANDING, IK_NODIAL, g_fNoSignup, g_szCustIns);

                    // CopyIE4Files() relies on g_szSignup to be non-empty to copy files from the signup folder
                    // to the temp location so that they will be cabbed up in the branding cab.
                    // We should clear the path here so that if the user chooses a signup mode and then
                    // selects NoSignup, CopyIE4Files() won't copy any files around unnecessarily.
                    *g_szSignup = TEXT('\0');

                    g_iCurPage = PPAGE_QUERYSIGNUP;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


INT_PTR CALLBACK SignupFilesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_SFLOC);
            EnableDBCSChars(hDlg, IDE_SFCOPY);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    // clear the status bitmaps
                    SendMessage(GetDlgItem(hDlg, IDC_SFBMP1), STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, NULL);
                    SendMessage(GetDlgItem(hDlg, IDC_SFBMP2), STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, NULL);
                    SendMessage(GetDlgItem(hDlg, IDC_SFBMP3), STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, NULL);
                    SendMessage(GetDlgItem(hDlg, IDC_SFBMP4), STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, NULL);

                    // disable the copy files button; it will be enabled with the user enters a path or file(s) to copy
                    EnableDlgItem2(hDlg, IDC_COPYSF, GetDlgItemTextLength(hDlg, IDE_SFCOPY) ? TRUE : FALSE);

                    // if the new ICW method is not chosen, disable the status
                    // line that requires icwsign.htm; otherwise, enable it
                    EnableDlgItem2(hDlg, IDC_SFSTATUS1, g_fServerICW);

                    // for the new ICW method, if single disk branding media is chosen,
                    // we require that signup.htm is also supplied to work on downlevel clients
                    if (g_fServerICW)
                        EnableDlgItem2(hDlg, IDC_SFSTATUS2, g_fBrandingOnly);
                    else
                        EnableDlgItem(hDlg, IDC_SFSTATUS2);

                    // for serverless signup, no .ISP files are required
                    // so disable the status line and the check box for .ISP
                    EnableDlgItem2(hDlg, IDC_SFSTATUS3, !g_fServerless);
                    EnableDlgItem2(hDlg, IDC_CHECK3, !g_fServerless);

                    // construct the signup folder path; the signup folder is under the output dir
                    // for e.g.: <output dir>\ins\win32\en\signup\kiosk
                    PathCombine(g_szSignup, g_szBuildRoot, TEXT("ins"));
                    PathAppend(g_szSignup, GetOutputPlatformDir());
                    PathAppend(g_szSignup, g_szLanguage);
                    PathAppend(g_szSignup, TEXT("signup"));

                    // create a different subdir depending on the signup mode chosen
                    PathAppend(g_szSignup, g_fServerICW ? TEXT("icw") : (g_fServerKiosk ? TEXT("kiosk") : TEXT("servless")));

                    SetDlgItemText(hDlg, IDC_SFLOC, g_szSignup);

                    // set the attribs of all the files in the signup folder to NORMAL;
                    // good thing to do because if some of the ISP/INS files have READONLY attrib set,
                    // GetPrivateProfile calls would fail on Win9x
                    SetAttribAllEx(g_szSignup, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, FALSE);

                    // initialize the path to signup.isp (used in subsequent dlg procs)
                    PathCombine(s_szIsp, g_szSignup, TEXT("signup.isp"));

                    UpdateSignupFilesStatus(hDlg, g_szSignup);

                    // initialize modify .ISP files checkbox
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK3)))
                        ReadBoolAndCheckButton(IS_ICW, IK_MODIFY_ISP, 1, g_szCustIns, hDlg, IDC_CHECK3);

                    // initialize modify .INS files checkbox
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK4)))
                        ReadBoolAndCheckButton(IS_ICW, IK_MODIFY_INS, 1, g_szCustIns, hDlg, IDC_CHECK4);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    // do error checking only if the user clicked the Next button
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    {
                        // for ICW mode, make sure that icwsign.htm is present in the signup folder
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS1)))
                        {
                            if (!PathFileExistsInDir(TEXT("icwsign.htm"), g_szSignup))
                            {
                                ErrorMessageBox(hDlg, IDS_ICWHTM_MISSING);

                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                return TRUE;
                            }
                        }

                        // for all other modes including ICW mode with single-disk branding,
                        // make sure that signup.htm is present in the signup folder
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS2)))
                        {
                            if (!PathFileExistsInDir(TEXT("signup.htm"), g_szSignup))
                            {
                                ErrorMessageBox(hDlg, IDS_SIGNUPHTM_MISSING);

                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                return TRUE;
                            }
                        }

                        // if the modify .ISP files button is unchecked, make sure
                        // that signup.isp is present in the signup folder
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK3)))
                            if (IsDlgButtonChecked(hDlg, IDC_CHECK3) == BST_UNCHECKED)
                            {
                                if (!PathFileExistsInDir(TEXT("signup.isp"), g_szSignup))
                                {
                                    ErrorMessageBox(hDlg, IDS_SIGNUPISP_MISSING);

                                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                    return TRUE;
                                }

                                // write the magic number to signup.isp so that ICW doesn't complain
                                WritePrivateProfileString(IS_BRANDING, FLAGS, TEXT("16319"), s_szIsp);
                                InsFlushChanges(s_szIsp);
                            }

                        // if the modify .INS files button is unchecked, make sure
                        // that a file called install.ins is not present in the signup folder
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK4)))
                            if (IsDlgButtonChecked(hDlg, IDC_CHECK4) == BST_UNCHECKED)
                            {
                                if (PathFileExistsInDir(TEXT("install.ins"), g_szSignup))
                                {
                                    ErrorMessageBox(hDlg, IDS_INSTALLINS_FOUND);

                                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                    return TRUE;
                                }
                            }
                    }

                    // persist the modify .ISP files checkbox state
                    g_fSkipServerIsps = FALSE;
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK3)))
                    {
                        g_fSkipServerIsps = (IsDlgButtonChecked(hDlg,IDC_CHECK3) == BST_UNCHECKED);
                        InsWriteBoolEx(IS_ICW, IK_MODIFY_ISP, !g_fSkipServerIsps, g_szCustIns);
                    }
                    else
                        WritePrivateProfileString(IS_ICW, IK_MODIFY_ISP, NULL, g_szCustIns);

                    // persist the modify .INS files checkbox state
                    g_fSkipIspIns = FALSE;
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK4)))
                    {
                        g_fSkipIspIns = (IsDlgButtonChecked(hDlg,IDC_CHECK4) == BST_UNCHECKED);
                        InsWriteBoolEx(IS_ICW, IK_MODIFY_INS, !g_fSkipIspIns, g_szCustIns);
                    }
                    else
                        WritePrivateProfileString(IS_ICW, IK_MODIFY_INS, NULL, g_szCustIns);

                    g_iCurPage = PPAGE_SIGNUPFILES;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                TCHAR szCopySignupFiles[MAX_PATH];

                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_SFBROWSE:
                            {
                                TCHAR szInstructions[MAX_PATH];
                                LoadString(g_rvInfo.hInst,IDS_SFDIR,szInstructions,countof(szInstructions));

                                if (BrowseForFolder(hDlg, szCopySignupFiles,szInstructions))
                                    SetDlgItemText(hDlg, IDE_SFCOPY, szCopySignupFiles);
                                break;
                            }

                        case IDC_COPYSF:
                        {
                            HANDLE hFind;
                            WIN32_FIND_DATA fd;

                            GetDlgItemText(hDlg, IDE_SFCOPY, szCopySignupFiles, countof(szCopySignupFiles));

                            // NOTE: szCopySignupFiles can be either a dir or a file.
                            //       if a file, it can contain wildcard chars

                            // FindFirstFile would fail if you specify "\" or "c:\" (root paths); so append *.*
                            if (PathIsRoot(szCopySignupFiles))
                                PathAppend(szCopySignupFiles, TEXT("*.*"));

                            // verify if the path exists
                            if ((hFind = FindFirstFile(szCopySignupFiles, &fd)) != INVALID_HANDLE_VALUE)
                                FindClose(hFind);
                            else
                            {
                                HWND hCtrl = GetDlgItem(hDlg, IDE_SFCOPY);

                                ErrorMessageBox(hDlg, IDS_PATH_DOESNT_EXIST);
                                Edit_SetSel(hCtrl, 0, -1);
                                SetFocus(hCtrl);

                                break;
                            }

                            CNewCursor cur(IDC_WAIT);

                            if (PathIsDirectory(szCopySignupFiles))
                                CopyFilesSrcToDest(szCopySignupFiles, TEXT("*.*"), g_szSignup);
                            else
                            {
                                LPTSTR pszFile;

                                pszFile = PathFindFileName(szCopySignupFiles);
                                PathRemoveFileSpec(szCopySignupFiles);

                                CopyFilesSrcToDest(szCopySignupFiles, pszFile, g_szSignup);
                            }

                            // set the attribs of all the files in the signup folder to NORMAL;
                            // good thing to do because if some of the ISP/INS files have READONLY attrib set,
                            // GetPrivateProfile calls would fail on Win9x
                            SetAttribAllEx(g_szSignup, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, FALSE);

                            // clear out the path in the edit control
                            SetDlgItemText(hDlg, IDE_SFCOPY, TEXT(""));

                            UpdateSignupFilesStatus(hDlg, g_szSignup);
                            break;
                        }
                    }
                    break;

                case EN_CHANGE:
                    switch (LOWORD(wParam))
                    {
                        case IDE_SFCOPY:
                            GetDlgItemText(hDlg, IDE_SFCOPY, szCopySignupFiles, countof(szCopySignupFiles));

                            // enable the copy files button if the path is non-empty
                            if (*szCopySignupFiles == TEXT('\0'))
                                EnsureDialogFocus(hDlg, IDC_COPYSF, IDE_SFCOPY);
                            EnableDlgItem2(hDlg, IDC_COPYSF, *szCopySignupFiles ? TRUE : FALSE);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


INT_PTR CALLBACK ServerIspsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND s_hwndCombo = NULL;
    static DWORD s_nISPFiles = 0;
    static INT s_iSelIndex = 0;

    if (uMsg == WM_INITDIALOG)
        s_hwndCombo = GetDlgItem(hDlg, IDC_CONNECTION);         // used in lots of places in the dlg proc

    // NOTE: s_nISPFiles and s_iSelIndex are passed by reference.
    return SignupDlgProcHelper(hDlg, uMsg, wParam, lParam,
                    s_hwndCombo, s_SignupFileArray, countof(s_SignupFileArray),
                    s_nISPFiles, s_iSelIndex, TRUE);
}


INT_PTR CALLBACK SignupInsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND s_hwndCombo = NULL;
    static DWORD s_nINSFiles = 0;
    static INT s_iSelIndex = 0;

    if (uMsg == WM_INITDIALOG)
        s_hwndCombo = GetDlgItem(hDlg, IDC_CONNECTION);         // used in lots of places in the dlg proc

    // NOTE: s_nINSFiles and s_iSelIndex are passed by reference.
    return SignupDlgProcHelper(hDlg, uMsg, wParam, lParam,
                    s_hwndCombo, s_SignupFileArray, countof(s_SignupFileArray), s_nINSFiles,
                    s_iSelIndex, FALSE);
}

static INT_PTR CALLBACK SignupDlgProcHelper(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam,
                                         HWND hwndCombo, PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems,
                                         DWORD &nSignupFiles, INT &iSelIndex, BOOL fIsp)
{
    PSIGNUPFILE pSignupFileCurrent;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_CONNECTION);
            ComboBox_LimitText(hwndCombo, countof(pSignupArray[0].szEntryName) - 1);

            EnableDBCSChars(hDlg, IDE_CONNECTION);
            Edit_LimitText(GetDlgItem(hDlg, IDE_CONNECTION), countof(pSignupArray[0].szEntryPath) - 1);

            DisableDBCSChars(hDlg, IDE_AREACODE);
            DisableDBCSChars(hDlg, IDE_PHONENUMBER);
            DisableDBCSChars(hDlg, IDE_COUNTRYCODE);
            DisableDBCSChars(hDlg, IDE_COUNTRYID);
            Edit_LimitText(GetDlgItem(hDlg, IDE_AREACODE), countof(pSignupArray[0].szAreaCode) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_PHONENUMBER), countof(pSignupArray[0].szPhoneNumber) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_COUNTRYCODE), countof(pSignupArray[0].szCountryCode) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_COUNTRYID), countof(pSignupArray[0].szCountryId) - 1);

            EnableDBCSChars(hDlg, IDE_USERNAME);
            DisableDBCSChars(hDlg, IDE_PASSWORD);
            Edit_LimitText(GetDlgItem(hDlg, IDE_USERNAME), countof(pSignupArray[0].szName) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_PASSWORD), countof(pSignupArray[0].szPassword) - 1);

            if (fIsp)
            {
                DisableDBCSChars(hDlg, IDE_SUPPORTNUM);
                Edit_LimitText(GetDlgItem(hDlg, IDE_SUPPORTNUM), countof(pSignupArray[0].szSupportNum) - 1);
            }
            else
            {
                // support number is not applicable on the INS page
                ShowWindow(GetDlgItem(hDlg, IDC_SUPPORTNUM), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDE_SUPPORTNUM), SW_HIDE);
            }

            if (fIsp)
            {
                EnableDBCSChars(hDlg, IDE_SIGNUPURL);
                Edit_LimitText(GetDlgItem(hDlg, IDE_SIGNUPURL), countof(pSignupArray[0].szSignupURL) - 1);
            }
            else
            {
                ShowWindow(GetDlgItem(hDlg, IDC_SIGNUPURLTXT), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDE_SIGNUPURL), SW_HIDE);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    // set the window caption
                    {
                        TCHAR szTemp[MAX_PATH];

                        LoadString(g_rvInfo.hInst, fIsp ? IDS_ISPINS1_TITLE : IDS_ISPINS2_TITLE, szTemp, countof(szTemp));
                        SetWindowText(hDlg, szTemp);

                        LoadString(g_rvInfo.hInst, fIsp ? IDS_ISPINS1_TEXT : IDS_ISPINS2_TEXT, szTemp, countof(szTemp));
                        SetWindowText(GetDlgItem(hDlg, IDC_ENTER), szTemp);
                    }

                    // NOTE: SetBannerText should be called *after* the window caption is set because
                    //       it uses the current window caption string to create the banner text.
                    SetBannerText(hDlg);

                    if (fIsp)
                    {
                        // support number should be shown only for the ICW signup mode
                        ShowWindow(GetDlgItem(hDlg, IDC_SUPPORTNUM), g_fServerICW ? SW_SHOW : SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDE_SUPPORTNUM), g_fServerICW ? SW_SHOW : SW_HIDE);
                    }

                    ZeroMemory(pSignupArray, nSignupArrayElems * sizeof(pSignupArray[0]));

                    nSignupFiles = InitSignupFileArray(pSignupArray, nSignupArrayElems, hwndCombo, fIsp);
                    if (nSignupFiles == 0)
                    {
                        NewSignupFileEntry(pSignupArray, nSignupArrayElems, hwndCombo, fIsp);
                        nSignupFiles++;
                    }

                    iSelIndex = 0;

                    pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                    SetSignupFileEntry(hDlg, pSignupFileCurrent, fIsp);

                    ComboBox_SetCurSel(hwndCombo, iSelIndex);

                    EnableDlgItem2(hDlg, IDC_ADDCONNECTION, nSignupFiles < nSignupArrayElems);
                    EnableDlgItem2(hDlg, IDC_RMCONNECTION,  nSignupFiles > 1);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                    if (!SaveSignupFileEntry(hDlg, pSignupFileCurrent, fIsp))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    // for ISP case, make sure that signup.isp is specified (fIsp && pSignupFileCurrent == NULL).
                    // for INS case, make sure that install.ins is NOT specified (!fIsp && pSignupFileCurrent != NULL).
                    pSignupFileCurrent = IsEntryPathInSignupArray(pSignupArray, nSignupArrayElems, fIsp ? TEXT("signup.isp") : TEXT("install.ins"));
                    if (( fIsp && pSignupFileCurrent == NULL)  ||
                        (!fIsp && pSignupFileCurrent != NULL))
                    {
                        ErrorMessageBox(hDlg, fIsp ? IDS_NEEDSIGNUPISP : IDS_INSTALLINS_SPECIFIED);

                        // BUGBUG: for install.ins case, try sending a CBN_SELENDOK message to display the install.ins entry

                        Edit_SetSel(GetDlgItem(hDlg, IDE_CONNECTION), 0, -1);
                        SetFocus(GetDlgItem(hDlg, IDE_CONNECTION));

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    SaveSignupFileArray(pSignupArray, nSignupArrayElems, fIsp);

                    if (fIsp)
                    {
                        // write the magic number to signup.isp so that ICW doesn't complain
                        WritePrivateProfileString(IS_BRANDING, FLAGS, TEXT("16319"), s_szIsp);
                        InsFlushChanges(s_szIsp);
                    }

                    g_iCurPage = (fIsp ? PPAGE_SERVERISPS : PPAGE_ISPINS);
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_ADDCONNECTION:
                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            if (!SaveSignupFileEntry(hDlg, pSignupFileCurrent, fIsp))
                                break;

                            iSelIndex = NewSignupFileEntry(pSignupArray, nSignupArrayElems, hwndCombo, fIsp);
                            nSignupFiles++;

                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            SetSignupFileEntry(hDlg, pSignupFileCurrent, fIsp);

                            if (nSignupFiles >= nSignupArrayElems)
                                EnsureDialogFocus(hDlg, IDC_ADDCONNECTION, IDC_RMCONNECTION);
                            EnableDlgItem2(hDlg, IDC_ADDCONNECTION, nSignupFiles < nSignupArrayElems);
                            EnableDlgItem(hDlg, IDC_RMCONNECTION);
                            break;

                        case IDC_RMCONNECTION:
                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);

                            DeleteFile(pSignupFileCurrent->szEntryPath);
                            if (!fIsp  &&  !g_fServerless)
                                DeleteFileInDir(pSignupFileCurrent->Advanced.szBrandingCabName, g_szSignup);
                            nSignupFiles--;

                            // clear the entry
                            ZeroMemory(pSignupFileCurrent, sizeof(*pSignupFileCurrent));

                            ComboBox_DeleteString(hwndCombo, iSelIndex);

                            if ((DWORD) iSelIndex >= nSignupFiles)
                                iSelIndex = nSignupFiles - 1;

                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            SetSignupFileEntry(hDlg, pSignupFileCurrent, fIsp);

                            EnableDlgItem(hDlg, IDC_ADDCONNECTION);
                            if (nSignupFiles <= 1)
                                EnsureDialogFocus(hDlg, IDC_RMCONNECTION, IDC_ADDCONNECTION);
                            EnableDlgItem2(hDlg, IDC_RMCONNECTION,  nSignupFiles > 1);
                            break;

                        case IDC_SFADVANCED:
                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            DialogBoxParam(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_SIGNUPPOPUP), hDlg,
                                (fIsp ? IspPopupDlgProc : InsPopupDlgProc),
                                (LPARAM) pSignupFileCurrent);
                            break;
                    }
                    break;

                case CBN_SELENDOK:
                {
                    INT iCurSelIndex;

                    if ((iCurSelIndex = ComboBox_GetCurSel(hwndCombo)) != CB_ERR  &&  iCurSelIndex != iSelIndex)
                    {
                        pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                        if (SaveSignupFileEntry(hDlg, pSignupFileCurrent, fIsp))
                        {
                            iSelIndex = iCurSelIndex;

                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            SetSignupFileEntry(hDlg, pSignupFileCurrent, fIsp);
                        }
                    }
                    ComboBox_SetCurSel(hwndCombo, iSelIndex);
                    break;
                }

                case CBN_CLOSEUP:
                case CBN_SELENDCANCEL:
                case CBN_DROPDOWN:
                case CBN_KILLFOCUS:
                    if ((pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex)) != (PSIGNUPFILE) CB_ERR)
                    {
                        TCHAR szEntryName[RAS_MaxEntryName + 1];

                        GetDlgItemText(hDlg, IDC_CONNECTION, szEntryName, countof(szEntryName));

                        if (StrCmpI(pSignupFileCurrent->szEntryName, szEntryName))
                        {
                            ComboBox_DeleteString(hwndCombo, iSelIndex);

                            StrCpy(pSignupFileCurrent->szEntryName, szEntryName);
                            ComboBox_InsertString(hwndCombo, iSelIndex, (LPARAM) pSignupFileCurrent->szEntryName);
                            ComboBox_SetItemData(hwndCombo, iSelIndex, (LPARAM) pSignupFileCurrent);
                        }
                        ComboBox_SetCurSel(hwndCombo, iSelIndex);
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


INT_PTR CALLBACK NewICWDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL  fCustICWTitle;
    TCHAR szICWTitle[MAX_PATH],
          szTopBmpFile[MAX_PATH] = TEXT(""),
          szLeftBmpFile[MAX_PATH] = TEXT(""),
          szPrevBmpFile[MAX_PATH];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDE_ICWTITLE);
            EnableDBCSChars(hDlg, IDE_ICWHEADERBMP);
            EnableDBCSChars(hDlg, IDE_ICWWATERBMP);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    // read the checkbox state for customizing the title bar
                    fCustICWTitle = InsGetBool(IS_ICW, IK_CUSTICWTITLE, 0, g_szCustIns);
                    CheckDlgButton(hDlg, IDC_ICWTITLE, fCustICWTitle ? BST_CHECKED : BST_UNCHECKED);

                    // read the custom title
                    GetPrivateProfileString(IS_ICW, IK_ICWDISPNAME, TEXT(""), szICWTitle, countof(szICWTitle), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_ICWTITLE, szICWTitle);

                    // read top bitmap file
                    GetPrivateProfileString(IS_ICW, IK_HEADERBMP, TEXT(""), szTopBmpFile, countof(szTopBmpFile), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_ICWHEADERBMP, szTopBmpFile);

                    // read left bitmap file
                    GetPrivateProfileString(IS_ICW, IK_WATERBMP, TEXT(""), szLeftBmpFile, countof(szLeftBmpFile), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_ICWWATERBMP, szLeftBmpFile);

                    EnableDlgItem2(hDlg, IDE_ICWTITLE, fCustICWTitle);
                    EnableDlgItem2(hDlg, IDC_ICWTITLE_TXT, fCustICWTitle);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    // make sure that if customize title bar is checked, the title bar text is non-empty
                    fCustICWTitle = (IsDlgButtonChecked(hDlg, IDC_ICWTITLE) == BST_CHECKED);
                    if (fCustICWTitle)
                        if (!CheckField(hDlg, IDE_ICWTITLE, FC_NONNULL))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                    // check if the bitmaps have the correct sizes
                    if (!IsBitmapFileValid(hDlg, IDE_ICWHEADERBMP, szTopBmpFile, NULL, 49, 49, IDS_TOOBIG49x49, IDS_TOOSMALL49x49)  ||
                        !IsBitmapFileValid(hDlg, IDE_ICWWATERBMP, szLeftBmpFile, NULL, 164, 458, IDS_TOOBIG164x458, IDS_TOOSMALL164x458))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    // persist the checkbox state
                    InsWriteBool(IS_ICW, IK_CUSTICWTITLE, fCustICWTitle, g_szCustIns);

                    // write the custom title
                    GetDlgItemText(hDlg, IDE_ICWTITLE, szICWTitle, countof(szICWTitle));
                    WritePrivateProfileString(IS_ICW, IK_ICWDISPNAME, fCustICWTitle ? szICWTitle : NULL, s_szIsp);

                    // write the custom title to the INS also so that if you import this INS file, all the values
                    // on this page are persisted
                    InsWriteString(IS_ICW, IK_ICWDISPNAME, szICWTitle, g_szCustIns);

                    // delete the old top bitmap file from the signup folder
                    GetPrivateProfileString(IS_ICW, IK_HEADERBMP, TEXT(""), szPrevBmpFile, countof(szPrevBmpFile), s_szIsp);
                    if (ISNONNULL(szPrevBmpFile))
                        DeleteFileInDir(szPrevBmpFile, g_szSignup);

                    // write top bitmap file path and copy the file to the signup folder
                    InsWriteString(IS_ICW, IK_HEADERBMP, PathFindFileName(szTopBmpFile), s_szIsp);
                    InsWriteString(IS_ICW, IK_HEADERBMP, szTopBmpFile, g_szCustIns);
                    if (ISNONNULL(szTopBmpFile))
                        CopyFileToDir(szTopBmpFile, g_szSignup);

                    // delete the old left bitmap file from the signup folder
                    GetPrivateProfileString(IS_ICW, IK_WATERBMP, TEXT(""), szPrevBmpFile, countof(szPrevBmpFile), s_szIsp);
                    if (ISNONNULL(szPrevBmpFile))
                        DeleteFileInDir(szPrevBmpFile, g_szSignup);

                    // write left bitmap file path and copy the file to the signup folder
                    InsWriteString(IS_ICW, IK_WATERBMP, PathFindFileName(szLeftBmpFile), s_szIsp);
                    InsWriteString(IS_ICW, IK_WATERBMP, szLeftBmpFile, g_szCustIns);
                    if (ISNONNULL(szLeftBmpFile))
                        CopyFileToDir(szLeftBmpFile, g_szSignup);

                    // write flags to let ICW know that ICW-based signup process should be used
                    WritePrivateProfileString(IS_ICW, IK_USEICW, TEXT("1"), s_szIsp);
                    WritePrivateProfileString(IS_ICW, IK_ICWHTM, TEXT("icwsign.htm"), s_szIsp);

                    g_iCurPage = PPAGE_ICW;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_ICWTITLE:
                            fCustICWTitle = (IsDlgButtonChecked(hDlg, IDC_ICWTITLE) == BST_CHECKED);
                            EnableDlgItem2(hDlg, IDE_ICWTITLE, fCustICWTitle);
                            EnableDlgItem2(hDlg, IDC_ICWTITLE_TXT, fCustICWTitle);
                            break;

                        case IDC_BROWSEICWHEADERBMP:
                            GetDlgItemText(hDlg, IDE_ICWHEADERBMP, szTopBmpFile, countof(szTopBmpFile));
                            if (BrowseForFile(hDlg, szTopBmpFile, countof(szTopBmpFile), GFN_PICTURE | GFN_BMP))
                                SetDlgItemText(hDlg, IDE_ICWHEADERBMP, szTopBmpFile);
                            break;

                        case IDC_BROWSEICWWATERBMP:
                            GetDlgItemText(hDlg, IDE_ICWWATERBMP, szLeftBmpFile, countof(szLeftBmpFile));
                            if (BrowseForFile(hDlg, szLeftBmpFile, countof(szLeftBmpFile), GFN_PICTURE | GFN_BMP))
                                SetDlgItemText(hDlg, IDE_ICWWATERBMP, szLeftBmpFile);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


static INT_PTR CALLBACK IspPopupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PSIGNUPFILE s_pISPFileCurrent = NULL;

    if (uMsg == WM_INITDIALOG)
        s_pISPFileCurrent = (PSIGNUPFILE) lParam;

    return SignupPopupDlgProcHelper(hDlg, uMsg, wParam, lParam, s_pISPFileCurrent, TRUE);
}


static INT_PTR CALLBACK InsPopupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PSIGNUPFILE s_pINSFileCurrent = NULL;

    if (uMsg == WM_INITDIALOG)
        s_pINSFileCurrent = (PSIGNUPFILE) lParam;

    return SignupPopupDlgProcHelper(hDlg, uMsg, wParam, lParam, s_pINSFileCurrent, FALSE);
}


static INT_PTR CALLBACK SignupPopupDlgProcHelper(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM,
                                              PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            DisableDBCSChars(hDlg, IDE_DNSA);
            DisableDBCSChars(hDlg, IDE_DNSB);
            DisableDBCSChars(hDlg, IDE_DNSC);
            DisableDBCSChars(hDlg, IDE_DNSD);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DNSA), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DNSB), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DNSC), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DNSD), 3);

            DisableDBCSChars(hDlg, IDE_ALTDNSA);
            DisableDBCSChars(hDlg, IDE_ALTDNSB);
            DisableDBCSChars(hDlg, IDE_ALTDNSC);
            DisableDBCSChars(hDlg, IDE_ALTDNSD);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ALTDNSA), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ALTDNSB), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ALTDNSC), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ALTDNSD), 3);

            // for serverless, only Applyins is applicable
            if (fIsp  ||  g_fServerless)
            {
                if (fIsp)
                {
                    ShowWindow(GetDlgItem(hDlg, IDC_DONTAPPLYINS), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_DONTMODIFY), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_APPLYINS), SW_HIDE);
                }

                ShowWindow(GetDlgItem(hDlg, IDC_BRANDNAME), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDE_BRANDINGCABNAME), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_BRANDURL), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDE_BRANDINGCABURL), SW_HIDE);
            }

            SetSignupFileAdvancedEntry(hDlg, pSignupFile, fIsp);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_CHECKSTATICDNS:
                {
                    BOOL fStaticDNS;

                    fStaticDNS = (IsDlgButtonChecked(hDlg, IDC_CHECKSTATICDNS) == BST_CHECKED);

                    EnableDlgItem2(hDlg, IDC_PRIMARY, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_DNSA, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_DNSB, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_DNSC, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_DNSD, fStaticDNS);

                    EnableDlgItem2(hDlg, IDC_ALT, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_ALTDNSA, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_ALTDNSB, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_ALTDNSC, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_ALTDNSD, fStaticDNS);

                    return TRUE;
                }

                case IDC_DONTAPPLYINS:
                case IDC_DONTMODIFY:
                case IDC_APPLYINS:
                    if (!g_fServerless)
                    {
                        BOOL fApplyIns;

                        fApplyIns = (IsDlgButtonChecked(hDlg, IDC_APPLYINS) == BST_CHECKED);

                        EnableDlgItem2(hDlg, IDC_BRANDNAME, fApplyIns);
                        EnableDlgItem2(hDlg, IDE_BRANDINGCABNAME, fApplyIns);

                        EnableDlgItem2(hDlg, IDC_BRANDURL, fApplyIns);
                        EnableDlgItem2(hDlg, IDE_BRANDINGCABURL, fApplyIns);
                    }
                    return TRUE;

                case IDOK:
                    if (!SaveSignupFileAdvancedEntry(hDlg, pSignupFile, fIsp))
                        break;
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
            break;
    }

    return FALSE;
}


static VOID UpdateSignupFilesStatus(HWND hDlg, LPCTSTR pcszSignupPath)
{
    static HBITMAP s_hCheckBmp = NULL;
    static HBITMAP s_hXBmp = NULL;

    HWND hwndBitmap;
    TCHAR szBuf[MAX_PATH];
    DWORD nFiles;

    // NOTE: s_hCheckBmp and s_hXBmp don't get freed up until the wizard is closed.

    if (s_hCheckBmp == NULL)
        s_hCheckBmp = (HBITMAP) LoadImage(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);

    if (s_hXBmp == NULL)
        s_hXBmp = (HBITMAP) LoadImage(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_X), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);

    // check if icwsign.htm exists in the signup folder
    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS1)))
    {
        hwndBitmap = GetDlgItem(hDlg, IDC_SFBMP1);

        if (PathFileExistsInDir(TEXT("icwsign.htm"), pcszSignupPath))
        {
            LoadString(g_rvInfo.hInst, IDS_SF_ICWHTM_FOUND, szBuf, countof(szBuf));

            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hCheckBmp);
        }
        else
        {
            LoadString(g_rvInfo.hInst, IDS_SF_ICWHTM_NOTFOUND, szBuf, countof(szBuf));

            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hXBmp);
        }

        SetDlgItemText(hDlg, IDC_SFSTATUS1, szBuf);
    }

    // check if signup.htm exists in the signup folder
    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS2)))
    {
        hwndBitmap = GetDlgItem(hDlg, IDC_SFBMP2);

        if (PathFileExistsInDir(TEXT("signup.htm"), pcszSignupPath))
        {
            LoadString(g_rvInfo.hInst, IDS_SF_SIGNUPHTM_FOUND, szBuf, countof(szBuf));

            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hCheckBmp);
        }
        else
        {
            LoadString(g_rvInfo.hInst, IDS_SF_SIGNUPHTM_NOTFOUND, szBuf, countof(szBuf));

            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hXBmp);
        }

        SetDlgItemText(hDlg, IDC_SFSTATUS2, szBuf);
    }

    // check how many .ISP files are there in the signup folder
    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS3)))
    {
        TCHAR szBuf2[64];

        hwndBitmap = GetDlgItem(hDlg, IDC_SFBMP3);

        nFiles = GetNumberOfFiles(TEXT("*.isp"), pcszSignupPath);

        if (nFiles > 0)
        {
            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hCheckBmp);

            EnableDlgItem(hDlg, IDC_CHECK3);
        }
        else
        {
            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hXBmp);

            // if no files found, user shouldn't be able to unselect the Verify/modify checkbox;
            // so select it and disable it
            CheckDlgButton(hDlg, IDC_CHECK3, BST_CHECKED);
            DisableDlgItem(hDlg, IDC_CHECK3);
        }

        LoadString(g_rvInfo.hInst, IDS_SF_ISPFILES, szBuf2, countof(szBuf2));
        wnsprintf(szBuf, countof(szBuf), szBuf2, nFiles);
        SetDlgItemText(hDlg, IDC_SFSTATUS3, szBuf);
    }

    // check how many .INS files are there in the signup folder
    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS4)))
    {
        TCHAR szBuf2[64];

        hwndBitmap = GetDlgItem(hDlg, IDC_SFBMP4);

        nFiles = GetNumberOfINSFiles(pcszSignupPath);
        if (nFiles > 0)
        {
            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hCheckBmp);

            EnableDlgItem(hDlg, IDC_CHECK4);
        }
        else
        {
            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hXBmp);

            if (g_fServerless)
            {
                // if no files found, user shouldn't be able to unselect the Verify/modify checkbox;
                // so select it and disable it
                CheckDlgButton(hDlg, IDC_CHECK4, BST_CHECKED);
                DisableDlgItem(hDlg, IDC_CHECK4);
            }
            else
            {
                // for server-based, creating INS files is optional;
                // so don't force the Verify/modify checkbox to be selected
                CheckDlgButton(hDlg, IDC_CHECK4, BST_UNCHECKED);        // unchecked by default
                EnableDlgItem(hDlg, IDC_CHECK4);

                // have to change this here because in PSN_SETACTIVE, the default is to turn it on;
                // should probably move that logic in this function.
                if (!InsGetBool(IS_ICW, IK_MODIFY_INS, 0, g_szCustIns))
                    WritePrivateProfileString(IS_ICW, IK_MODIFY_INS, TEXT("0"), g_szCustIns);
            }
        }

        LoadString(g_rvInfo.hInst, IDS_SF_INSFILES, szBuf2, countof(szBuf2));
        wnsprintf(szBuf, countof(szBuf), szBuf2, nFiles);
        SetDlgItemText(hDlg, IDC_SFSTATUS4, szBuf);
    }
}


static DWORD InitSignupFileArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems,
                                 HWND hwndCombo, BOOL fIsp)
{
    DWORD nSignupFiles = 0;
    TCHAR szFile[MAX_PATH];
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    ComboBox_ResetContent(hwndCombo);

    PathCombine(szFile, g_szSignup, fIsp ? TEXT("*.isp") : TEXT("*.ins"));

    if ((hFind = FindFirstFile(szFile, &fd)) != INVALID_HANDLE_VALUE)
    {
        BOOL fSignupIspFound = FALSE;

        do
        {
            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                continue;

            // don't enumerate .ins files that have Cancel=Yes in the [Entry] section
            if (!fIsp)
            {
                PathCombine(szFile, g_szSignup, fd.cFileName);
                if (InsGetYesNo(TEXT("Entry"), TEXT("Cancel"), 0, szFile))
                    continue;
            }

            PathCombine(pSignupArray[nSignupFiles].szEntryPath, g_szSignup, fd.cFileName);
            ReadSignupFile(&pSignupArray[nSignupFiles], pSignupArray[nSignupFiles].szEntryPath, fIsp);

            INT iIndex = ComboBox_AddString(hwndCombo, pSignupArray[nSignupFiles].szEntryName);
            ComboBox_SetItemData(hwndCombo, iIndex, (LPARAM) &pSignupArray[nSignupFiles]);

            nSignupFiles++;
        } while (nSignupFiles < nSignupArrayElems  &&  FindNextFile(hFind, &fd));

        FindClose(hFind);
    }

    return nSignupFiles;
}


static VOID SaveSignupFileArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, BOOL fIsp)
{
    for ( ;  nSignupArrayElems-- > 0;  pSignupArray++)
        if (*pSignupArray->szEntryPath)
            WriteSignupFile(pSignupArray, pSignupArray->szEntryPath, fIsp);
}


static VOID ReadSignupFile(PSIGNUPFILE pSignupFile, LPCTSTR pcszSignupFile, BOOL fIsp)
{
    GetPrivateProfileString(TEXT("Entry"), TEXT("Entry_Name"), TEXT(""),
                            pSignupFile->szEntryName, countof(pSignupFile->szEntryName), pcszSignupFile);

    GetPrivateProfileString(TEXT("Phone"), TEXT("Area_Code"), TEXT(""),
                            pSignupFile->szAreaCode, countof(pSignupFile->szAreaCode), pcszSignupFile);
    GetPrivateProfileString(TEXT("Phone"), TEXT("Phone_Number"), TEXT(""),
                            pSignupFile->szPhoneNumber, countof(pSignupFile->szPhoneNumber), pcszSignupFile);
    GetPrivateProfileString(TEXT("Phone"), TEXT("Country_Code"), TEXT(""),
                            pSignupFile->szCountryCode, countof(pSignupFile->szCountryCode), pcszSignupFile);
    GetPrivateProfileString(TEXT("Phone"), TEXT("Country_ID"), TEXT(""),
                            pSignupFile->szCountryId, countof(pSignupFile->szCountryId), pcszSignupFile);

    GetPrivateProfileString(TEXT("User"), TEXT("Name"), TEXT(""),
                            pSignupFile->szName, countof(pSignupFile->szName), pcszSignupFile);
    GetPrivateProfileString(TEXT("User"), TEXT("Password"), TEXT(""),
                            pSignupFile->szPassword, countof(pSignupFile->szPassword), pcszSignupFile);

    // support number is applicable only for an ISP file and if ICW mode is chosen
    if (fIsp  &&  g_fServerICW)
        GetPrivateProfileString(TEXT("Support"), TEXT("SupportPhoneNumber"), TEXT(""),
                            pSignupFile->szSupportNum, countof(pSignupFile->szSupportNum), pcszSignupFile);

    pSignupFile->Advanced.fStaticDNS = InsGetYesNo(TEXT("TCP/IP"), TEXT("Specify_Server_Address"), 0, pcszSignupFile);
    GetPrivateProfileString(TEXT("TCP/IP"), TEXT("DNS_Address"), TEXT(""),
                            pSignupFile->Advanced.szDNSAddress, countof(pSignupFile->Advanced.szDNSAddress), pcszSignupFile);
    GetPrivateProfileString(TEXT("TCP/IP"), TEXT("DNS_Alt_Address"), TEXT(""),
                            pSignupFile->Advanced.szAltDNSAddress, countof(pSignupFile->Advanced.szAltDNSAddress), pcszSignupFile);

    // signup url is not applicable for .ins files
    if (fIsp)
    {
        GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""),
                            pSignupFile->szSignupURL, countof(pSignupFile->szSignupURL), pcszSignupFile);

        if (*pSignupFile->szSignupURL == TEXT('\0'))
        {
            // for backward compatibility, check if SignupURL is defined in signup.isp or install.ins
            if (GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""), pSignupFile->szSignupURL, countof(pSignupFile->szSignupURL), s_szIsp) == 0)
                GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""), pSignupFile->szSignupURL, countof(pSignupFile->szSignupURL), g_szCustIns);
        }
    }

    pSignupFile->Advanced.fRequiresLogon = InsGetYesNo(TEXT("User"), TEXT("Requires_Logon"), 0, pcszSignupFile);
    pSignupFile->Advanced.fNegTCPIP = InsGetYesNo(TEXT("Server"), TEXT("Negotiate_TCP/IP"), 1, pcszSignupFile);
    pSignupFile->Advanced.fDisableLCP = InsGetYesNo(TEXT("Server"), TEXT("Disable_LCP"), 0, pcszSignupFile);
    pSignupFile->Advanced.fDialAsIs = InsGetYesNo(TEXT("Phone"), TEXT("Dial_As_Is"), 0, pcszSignupFile);

    pSignupFile->Advanced.fPWEncrypt = InsGetYesNo(TEXT("Server"), TEXT("PW_Encrypt"), 0, pcszSignupFile);
    pSignupFile->Advanced.fSWCompress = InsGetYesNo(TEXT("Server"), TEXT("SW_Compress"), 0, pcszSignupFile);
    pSignupFile->Advanced.fIPHdrComp = InsGetYesNo(TEXT("TCP/IP"), TEXT("IP_Header_Compress"), 1, pcszSignupFile);
    pSignupFile->Advanced.fDefGate = InsGetYesNo(TEXT("TCP/IP"), TEXT("Gateway_On_Remote"), 1, pcszSignupFile);

    if (!fIsp)
    {
        pSignupFile->Advanced.fDontApplyIns =
        pSignupFile->Advanced.fDontModify =
        pSignupFile->Advanced.fApplyIns = FALSE;

        // make sure that only one of the above BOOLs is set to TRUE
        pSignupFile->Advanced.fApplyIns = InsGetBool(IS_APPLYINS, IK_APPLYINS, 0, pcszSignupFile);
        if (!pSignupFile->Advanced.fApplyIns)
        {
            pSignupFile->Advanced.fDontModify = InsGetBool(IS_APPLYINS, IK_DONTMODIFY, 0, pcszSignupFile);
            if (!pSignupFile->Advanced.fDontModify)
            {
                // default to TRUE for DontApplyIns
                pSignupFile->Advanced.fDontApplyIns = InsGetBool(IS_APPLYINS, IK_DONTAPPLYINS, 1, pcszSignupFile);
            }
        }

        if (!g_fServerless)
        {
            GetPrivateProfileString(IS_APPLYINS, IK_BRAND_NAME, TEXT(""),
                                pSignupFile->Advanced.szBrandingCabName, countof(pSignupFile->Advanced.szBrandingCabName), pcszSignupFile);
            GetPrivateProfileString(IS_APPLYINS, IK_BRAND_URL, TEXT(""),
                                pSignupFile->Advanced.szBrandingCabURL, countof(pSignupFile->Advanced.szBrandingCabURL), pcszSignupFile);
        }
    }
}


static VOID WriteSignupFile(PSIGNUPFILE pSignupFile, LPCTSTR pcszSignupFile, BOOL fIsp)
{
    // IMPORTANT: (pritobla): On Win9x, if we don't flush the content before DeleteFile and WritePrivateProfile
    // calls, the file would get deleted but for some weird reason, the WritePrivateProfile calls would fail to
    // create a new one.
    WritePrivateProfileString(NULL, NULL, NULL, pcszSignupFile);

    // for .INS, delete the file if DontApplyIns or ApplyIns is TRUE;
    // we want to primarily do this to clean-up the ApplyIns customizations
    if (!fIsp  &&  !pSignupFile->Advanced.fDontModify)
    {
        SetFileAttributes(pcszSignupFile, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(pcszSignupFile);
    }

    InsWriteString(TEXT("Entry"), TEXT("Entry_Name"), pSignupFile->szEntryName, pcszSignupFile);

    InsWriteString(TEXT("Phone"), TEXT("Area_Code"), pSignupFile->szAreaCode, pcszSignupFile);
    InsWriteString(TEXT("Phone"), TEXT("Phone_Number"), pSignupFile->szPhoneNumber, pcszSignupFile);
    InsWriteString(TEXT("Phone"), TEXT("Country_Code"), pSignupFile->szCountryCode, pcszSignupFile);
    InsWriteString(TEXT("Phone"), TEXT("Country_ID"), pSignupFile->szCountryId, pcszSignupFile);

    InsWriteString(TEXT("User"), TEXT("Name"), pSignupFile->szName, pcszSignupFile);
    InsWriteString(TEXT("User"), TEXT("Password"), pSignupFile->szPassword, pcszSignupFile);

    // support number is applicable only for an ISP file and if ICW mode is chosen
    if (fIsp  &&  g_fServerICW)
        InsWriteString(TEXT("Support"), TEXT("SupportPhoneNumber"), pSignupFile->szSupportNum, pcszSignupFile);

    if (fIsp)
        InsWriteString(IS_URL, TEXT("Signup"), pSignupFile->szSignupURL, pcszSignupFile);

    InsWriteYesNo(TEXT("TCP/IP"), TEXT("Specify_Server_Address"), pSignupFile->Advanced.fStaticDNS, pcszSignupFile);
    InsWriteString(TEXT("TCP/IP"), TEXT("DNS_Address"), pSignupFile->Advanced.szDNSAddress, pcszSignupFile);
    InsWriteString(TEXT("TCP/IP"), TEXT("DNS_Alt_Address"), pSignupFile->Advanced.szAltDNSAddress, pcszSignupFile);

    InsWriteYesNo(TEXT("User"), TEXT("Requires_Logon"), pSignupFile->Advanced.fRequiresLogon, pcszSignupFile);
    InsWriteYesNo(TEXT("Server"), TEXT("Negotiate_TCP/IP"), pSignupFile->Advanced.fNegTCPIP, pcszSignupFile);
    InsWriteYesNo(TEXT("Server"), TEXT("Disable_LCP"), pSignupFile->Advanced.fDisableLCP, pcszSignupFile);
    InsWriteYesNo(TEXT("Phone"), TEXT("Dial_As_Is"), pSignupFile->Advanced.fDialAsIs, pcszSignupFile);

    InsWriteYesNo(TEXT("Server"), TEXT("PW_Encrypt"), pSignupFile->Advanced.fPWEncrypt, pcszSignupFile);
    InsWriteYesNo(TEXT("Server"), TEXT("SW_Compress"), pSignupFile->Advanced.fSWCompress, pcszSignupFile);
    InsWriteYesNo(TEXT("TCP/IP"), TEXT("IP_Header_Compress"), pSignupFile->Advanced.fIPHdrComp, pcszSignupFile);
    InsWriteYesNo(TEXT("TCP/IP"), TEXT("Gateway_On_Remote"), pSignupFile->Advanced.fDefGate, pcszSignupFile);

    if (!fIsp)
    {
        InsWriteBool(IS_APPLYINS, IK_APPLYINS, pSignupFile->Advanced.fApplyIns, pcszSignupFile);
        InsWriteBool(IS_APPLYINS, IK_DONTMODIFY, pSignupFile->Advanced.fDontModify, pcszSignupFile);
        InsWriteBool(IS_APPLYINS, IK_DONTAPPLYINS, pSignupFile->Advanced.fDontApplyIns, pcszSignupFile);

        if (!g_fServerless)
        {
            InsWriteString(IS_APPLYINS, IK_BRAND_NAME, pSignupFile->Advanced.szBrandingCabName, pcszSignupFile);
            InsWriteString(IS_APPLYINS, IK_BRAND_URL, pSignupFile->Advanced.szBrandingCabURL, pcszSignupFile);
        }
    }

    // NOTE: we need to write the default server type
    WritePrivateProfileString(TEXT("Server"), TEXT("Type"), TEXT("PPP"), pcszSignupFile);

    // flush the buffer
    WritePrivateProfileString(NULL, NULL, NULL, pcszSignupFile);
}


static INT NewSignupFileEntry(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, HWND hwndCombo,
                              BOOL fIsp)
{
    DWORD nIndex;
    PSIGNUPFILE pSignupFileNew;
    TCHAR szNameBuf[64];
    INT iSelIndex;

    for (nIndex = 0, pSignupFileNew = pSignupArray;  nIndex < nSignupArrayElems;  nIndex++, pSignupFileNew++)
        if (*pSignupFileNew->szEntryName == TEXT('\0'))
            break;

    ASSERT(nIndex < nSignupArrayElems);

    ZeroMemory(pSignupFileNew, sizeof(*pSignupFileNew));

    // give a default name for the connection
    LoadString(g_rvInfo.hInst, IDS_CONNECTNAME, szNameBuf, countof(szNameBuf));

    // start with an index of 1 and find a name that's not in the combo box list
    for (nIndex = 1;  nIndex <= nSignupArrayElems;  nIndex++)
    {
        wnsprintf(pSignupFileNew->szEntryName, countof(pSignupFileNew->szEntryName), szNameBuf, nIndex);
        if (ComboBox_FindStringExact(hwndCombo, -1, (LPARAM) pSignupFileNew->szEntryName) == CB_ERR)
            break;
    }

    ASSERT(nIndex <= nSignupArrayElems);

    // give a default name for the file name
    LoadString(g_rvInfo.hInst, fIsp ? IDS_CONNECTFILE_ISP : IDS_CONNECTFILE_INS, szNameBuf, countof(szNameBuf));
    wnsprintf(pSignupFileNew->szEntryPath, countof(pSignupFileNew->szEntryPath), szNameBuf, nIndex);

    // read in SignupURL if defined in signup.isp or install.ins as the default for Signup URL
    if (fIsp)
        if (GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""), pSignupFileNew->szSignupURL, countof(pSignupFileNew->szSignupURL), s_szIsp) == 0)
            GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""), pSignupFileNew->szSignupURL, countof(pSignupFileNew->szSignupURL), g_szCustIns);

    // the following settings are on by default
    pSignupFileNew->Advanced.fNegTCPIP = TRUE;
    pSignupFileNew->Advanced.fIPHdrComp = TRUE;
    pSignupFileNew->Advanced.fDefGate = TRUE;

    if (!fIsp)
        pSignupFileNew->Advanced.fDontApplyIns = TRUE;

    iSelIndex = ComboBox_AddString(hwndCombo, pSignupFileNew->szEntryName);
    ComboBox_SetItemData(hwndCombo, iSelIndex, (LPARAM) pSignupFileNew);

    return iSelIndex;
}


static VOID SetSignupFileEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    SetDlgItemText(hDlg, IDC_CONNECTION, pSignupFile->szEntryName);

    SetDlgItemText(hDlg, IDE_CONNECTION, PathFindFileName(pSignupFile->szEntryPath));

    SetDlgItemText(hDlg, IDE_AREACODE, pSignupFile->szAreaCode);
    SetDlgItemText(hDlg, IDE_PHONENUMBER, pSignupFile->szPhoneNumber);
    SetDlgItemText(hDlg, IDE_COUNTRYCODE, pSignupFile->szCountryCode);
    SetDlgItemText(hDlg, IDE_COUNTRYID, pSignupFile->szCountryId);

    SetDlgItemText(hDlg, IDE_USERNAME, pSignupFile->szName);
    SetDlgItemText(hDlg, IDE_PASSWORD, pSignupFile->szPassword);

    // support number is applicable only for an ISP file and if ICW mode is chosen
    if (fIsp  &&  g_fServerICW)
        SetDlgItemText(hDlg, IDE_SUPPORTNUM, pSignupFile->szSupportNum);

    if (fIsp)
        SetDlgItemText(hDlg, IDE_SIGNUPURL, pSignupFile->szSignupURL);
}


static BOOL SaveSignupFileEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    // NOTE: passing PIVP_FILENAME_ONLY for IDE_CONNECTION makes sure that only
    //       filenames are specified (no path components should be there)
    if (!CheckField(hDlg, IDC_CONNECTION,  FC_NONNULL)  ||
        !CheckField(hDlg, IDE_CONNECTION,  FC_NONNULL | FC_FILE, PIVP_FILENAME_ONLY)  ||
        !CheckField(hDlg, IDE_PHONENUMBER, FC_NONNULL)  ||
        !CheckField(hDlg, IDE_COUNTRYCODE, FC_NONNULL)  ||
        !CheckField(hDlg, IDE_COUNTRYID,   FC_NONNULL))
        return FALSE;

    if (fIsp)
        if (!CheckField(hDlg, IDE_SIGNUPURL, FC_NONNULL | FC_URL))
            return FALSE;

    // check if file extension is .isp or .ins if the field is enabled
    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CONNECTION)))
    {
        TCHAR szFile[MAX_PATH];
        LPTSTR pszExt;

        GetDlgItemText(hDlg, IDE_CONNECTION, szFile, countof(szFile));
        pszExt = PathFindExtension(szFile);
        if (StrCmpI(pszExt, fIsp ? TEXT(".isp") : TEXT(".ins")))
        {
            ErrorMessageBox(hDlg, fIsp ? IDS_NON_ISP_EXTN : IDS_NON_INS_EXTN);

            Edit_SetSel(GetDlgItem(hDlg, IDE_CONNECTION), pszExt - szFile, -1);
            SetFocus(GetDlgItem(hDlg, IDE_CONNECTION));

            return FALSE;
        }

        // if the current file name is different from the previous one, delete the previous file
        if (StrCmpI(szFile, PathFindFileName(pSignupFile->szEntryPath)))
            DeleteFile(pSignupFile->szEntryPath);

        PathCombine(pSignupFile->szEntryPath, g_szSignup, szFile);
    }

    GetDlgItemText(hDlg, IDC_CONNECTION, pSignupFile->szEntryName, countof(pSignupFile->szEntryName));

    GetDlgItemText(hDlg, IDE_AREACODE, pSignupFile->szAreaCode, countof(pSignupFile->szAreaCode));
    GetDlgItemText(hDlg, IDE_PHONENUMBER, pSignupFile->szPhoneNumber, countof(pSignupFile->szPhoneNumber));
    GetDlgItemText(hDlg, IDE_COUNTRYCODE, pSignupFile->szCountryCode, countof(pSignupFile->szCountryCode));
    GetDlgItemText(hDlg, IDE_COUNTRYID, pSignupFile->szCountryId, countof(pSignupFile->szCountryId));

    GetDlgItemText(hDlg, IDE_USERNAME, pSignupFile->szName, countof(pSignupFile->szName));
    GetDlgItemText(hDlg, IDE_PASSWORD, pSignupFile->szPassword, countof(pSignupFile->szPassword));

    // support number is applicable only for an ISP file and if ICW mode is chosen
    if (fIsp  && g_fServerICW)
        GetDlgItemText(hDlg, IDE_SUPPORTNUM, pSignupFile->szSupportNum, countof(pSignupFile->szSupportNum));

    if (fIsp)
        GetDlgItemText(hDlg, IDE_SIGNUPURL, pSignupFile->szSignupURL, countof(pSignupFile->szSignupURL));

    return TRUE;
}


static VOID SetSignupFileAdvancedEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    CheckDlgButton(hDlg, IDC_CHECKSTATICDNS, pSignupFile->Advanced.fStaticDNS ? BST_CHECKED : BST_UNCHECKED);
    SetDlgIPAddress(hDlg, pSignupFile->Advanced.szDNSAddress, IDE_DNSA, IDE_DNSB, IDE_DNSC, IDE_DNSD);
    SetDlgIPAddress(hDlg, pSignupFile->Advanced.szAltDNSAddress, IDE_ALTDNSA, IDE_ALTDNSB, IDE_ALTDNSC, IDE_ALTDNSD);

    CheckDlgButton(hDlg, IDC_REQLOGON, pSignupFile->Advanced.fRequiresLogon ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_NEGOTIATETCP, pSignupFile->Advanced.fNegTCPIP ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_DISABLELCP, pSignupFile->Advanced.fDisableLCP ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_DIALASIS, pSignupFile->Advanced.fDialAsIs ? BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(hDlg, IDC_CHECKPWENCRYPT, pSignupFile->Advanced.fPWEncrypt ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_CHECKSWCOMP, pSignupFile->Advanced.fSWCompress ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_CHECKIPHDRCOMP, pSignupFile->Advanced.fIPHdrComp ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_CHECKDEFGW, pSignupFile->Advanced.fDefGate ? BST_CHECKED : BST_UNCHECKED);

    if (!fIsp)
    {
        INT id;

        if (pSignupFile->Advanced.fApplyIns)
            id = IDC_APPLYINS;
        else if (pSignupFile->Advanced.fDontModify)
            id = IDC_DONTMODIFY;
        else
            id = IDC_DONTAPPLYINS;

        CheckRadioButton(hDlg, IDC_DONTAPPLYINS, IDC_APPLYINS, id);

        if (!g_fServerless)
        {
            if (ISNULL(pSignupFile->Advanced.szBrandingCabName))
            {
                // pre-populate the name for the branding cab with <name of the ins file>.cab
                StrCpy(pSignupFile->Advanced.szBrandingCabName, PathFindFileName(pSignupFile->szEntryPath));
                PathRenameExtension(pSignupFile->Advanced.szBrandingCabName, TEXT(".cab"));
            }

            if (ISNULL(pSignupFile->Advanced.szBrandingCabURL))
            {
                // pre-populate the URL for the branding cab with the signup URL from signup.isp or install.ins
                if (GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""),
                            pSignupFile->Advanced.szBrandingCabURL, countof(pSignupFile->Advanced.szBrandingCabURL), s_szIsp) == 0)
                    GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""),
                            pSignupFile->Advanced.szBrandingCabURL, countof(pSignupFile->Advanced.szBrandingCabURL), g_szCustIns);
            }

            SetDlgItemText(hDlg, IDE_BRANDINGCABNAME, pSignupFile->Advanced.szBrandingCabName);
            SetDlgItemText(hDlg, IDE_BRANDINGCABURL, pSignupFile->Advanced.szBrandingCabURL);
        }
    }

    EnableDlgItem2(hDlg, IDC_PRIMARY, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_DNSA, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_DNSB, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_DNSC, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_DNSD, pSignupFile->Advanced.fStaticDNS);

    EnableDlgItem2(hDlg, IDC_ALT, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_ALTDNSA, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_ALTDNSB, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_ALTDNSC, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_ALTDNSD, pSignupFile->Advanced.fStaticDNS);

    if (!fIsp  &&  !g_fServerless)
    {
        EnableDlgItem2(hDlg, IDC_BRANDNAME, pSignupFile->Advanced.fApplyIns);
        EnableDlgItem2(hDlg, IDE_BRANDINGCABNAME, pSignupFile->Advanced.fApplyIns);

        EnableDlgItem2(hDlg, IDC_BRANDURL, pSignupFile->Advanced.fApplyIns);
        EnableDlgItem2(hDlg, IDE_BRANDINGCABURL, pSignupFile->Advanced.fApplyIns);
    }
}


static BOOL SaveSignupFileAdvancedEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    if (IsDlgButtonChecked(hDlg, IDC_CHECKSTATICDNS) == BST_CHECKED)
        if (!VerifyDlgIPAddress(hDlg, IDE_DNSA, IDE_DNSB, IDE_DNSC, IDE_DNSD)  ||
            !VerifyDlgIPAddress(hDlg, IDE_ALTDNSA, IDE_ALTDNSB, IDE_ALTDNSC, IDE_ALTDNSD))
            return FALSE;

    // NOTE: passing PIVP_FILENAME_ONLY for IDE_BRANDINGCABNAME makes sure that only
    //       filenames are specified (no path components should be there)
    if (!fIsp  &&  !g_fServerless)
        if (IsDlgButtonChecked(hDlg, IDC_APPLYINS) == BST_CHECKED)
            if (!CheckField(hDlg, IDE_BRANDINGCABNAME, FC_NONNULL | FC_FILE, PIVP_FILENAME_ONLY)  ||
                !CheckField(hDlg, IDE_BRANDINGCABURL,  FC_NONNULL | FC_URL))
                return FALSE;

    pSignupFile->Advanced.fStaticDNS = (IsDlgButtonChecked(hDlg, IDC_CHECKSTATICDNS) == BST_CHECKED);
    GetDlgIPAddress(hDlg, pSignupFile->Advanced.szDNSAddress, IDE_DNSA, IDE_DNSB, IDE_DNSC, IDE_DNSD);
    GetDlgIPAddress(hDlg, pSignupFile->Advanced.szAltDNSAddress, IDE_ALTDNSA, IDE_ALTDNSB, IDE_ALTDNSC, IDE_ALTDNSD);

    pSignupFile->Advanced.fRequiresLogon = (IsDlgButtonChecked(hDlg, IDC_REQLOGON) == BST_CHECKED);
    pSignupFile->Advanced.fNegTCPIP = (IsDlgButtonChecked(hDlg, IDC_NEGOTIATETCP) == BST_CHECKED);
    pSignupFile->Advanced.fDisableLCP = (IsDlgButtonChecked(hDlg, IDC_DISABLELCP) == BST_CHECKED);
    pSignupFile->Advanced.fDialAsIs = (IsDlgButtonChecked(hDlg, IDC_DIALASIS) == BST_CHECKED);

    pSignupFile->Advanced.fPWEncrypt = (IsDlgButtonChecked(hDlg, IDC_CHECKPWENCRYPT) == BST_CHECKED);
    pSignupFile->Advanced.fSWCompress = (IsDlgButtonChecked(hDlg, IDC_CHECKSWCOMP) == BST_CHECKED);
    pSignupFile->Advanced.fIPHdrComp = (IsDlgButtonChecked(hDlg, IDC_CHECKIPHDRCOMP) == BST_CHECKED);
    pSignupFile->Advanced.fDefGate = (IsDlgButtonChecked(hDlg, IDC_CHECKDEFGW) == BST_CHECKED);

    if (!fIsp)
    {
        pSignupFile->Advanced.fApplyIns     = (IsDlgButtonChecked(hDlg, IDC_APPLYINS)     == BST_CHECKED);
        pSignupFile->Advanced.fDontModify   = (IsDlgButtonChecked(hDlg, IDC_DONTMODIFY)   == BST_CHECKED);
        pSignupFile->Advanced.fDontApplyIns = (IsDlgButtonChecked(hDlg, IDC_DONTAPPLYINS) == BST_CHECKED);

        if (!g_fServerless)
        {
            TCHAR szCabName[MAX_PATH];

            GetDlgItemText(hDlg, IDE_BRANDINGCABNAME, szCabName, countof(szCabName));

            // if DontApplyIns is TRUE  OR
            // if ApplyIns is TRUE and the current cabname is different from the previous one,
            // delete the previous branding cab
            if ( pSignupFile->Advanced.fDontApplyIns  ||
                (pSignupFile->Advanced.fApplyIns && StrCmpI(szCabName, pSignupFile->Advanced.szBrandingCabName)))
                DeleteFileInDir(pSignupFile->Advanced.szBrandingCabName, g_szSignup);

            StrCpy(pSignupFile->Advanced.szBrandingCabName, szCabName);
            GetDlgItemText(hDlg, IDE_BRANDINGCABURL, pSignupFile->Advanced.szBrandingCabURL,
                                countof(pSignupFile->Advanced.szBrandingCabURL));
        }
    }

    return TRUE;
}


static VOID SetDlgIPAddress(HWND hDlg, LPCTSTR pcszIPAddress, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD)
{
    INT aIDs[4];
    TCHAR szWrkIPAddress[32];
    LPTSTR pszWrkIPAddress;

    aIDs[0] = iCtlA;
    aIDs[1] = iCtlB;
    aIDs[2] = iCtlC;
    aIDs[3] = iCtlD;

    if (pcszIPAddress != NULL)
    {
        StrCpy(szWrkIPAddress, pcszIPAddress);
        pszWrkIPAddress = szWrkIPAddress;
    }
    else
        pszWrkIPAddress = NULL;

    for (INT i = 0;  i < countof(aIDs);  i++)
    {
        LPTSTR pszIPAdr = TEXT("0");                    // display "0" by default

        if (pszWrkIPAddress != NULL)
        {
            LPTSTR pszDot;
            INT iLen;

            if ((pszDot = StrChr(pszWrkIPAddress, TEXT('.'))) != NULL)
                *pszDot++ = TEXT('\0');

            iLen = lstrlen(pszWrkIPAddress);
            if (iLen > 0)                               // if iLen == 0, display "0"
            {
                if (iLen > 3)                           // max 3 characters are allowed
                    pszWrkIPAddress[3] = TEXT('\0');
                pszIPAdr = pszWrkIPAddress;
            }

            pszWrkIPAddress = pszDot;
        }

        SetDlgItemText(hDlg, aIDs[i], pszIPAdr);
    }
}


static VOID GetDlgIPAddress(HWND hDlg, LPTSTR pszIPAddress, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD)
{
    INT aIDs[4];

    if (pszIPAddress == NULL)
        return;

    aIDs[0] = iCtlA;
    aIDs[1] = iCtlB;
    aIDs[2] = iCtlC;
    aIDs[3] = iCtlD;

    for (INT i = 0;  i < countof(aIDs);  i++)
    {
        // max 3 characters are allowed
        GetDlgItemText(hDlg, aIDs[i], pszIPAddress, 4);
        if (*pszIPAddress == TEXT('\0'))
            StrCpy(pszIPAddress, TEXT("0"));            // copy "0" as default

        pszIPAddress += lstrlen(pszIPAddress);
        *pszIPAddress++ = TEXT('.');                    // place a dot between two addresses
    }

    *--pszIPAddress = TEXT('\0');                       // replace the final dot with a nul character
}


static BOOL VerifyDlgIPAddress(HWND hDlg, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD)
{
    INT aIDs[4];

    aIDs[0] = iCtlA;
    aIDs[1] = iCtlB;
    aIDs[2] = iCtlC;
    aIDs[3] = iCtlD;

    for (INT i = 0;  i < countof(aIDs);  i++)
    {
        TCHAR szIPAddress[4];                           // max 3 characters are allowed

        if (!CheckField(hDlg, aIDs[i], FC_NUMBER))
            return FALSE;

        // verify that the value is in the range 0-255
        GetDlgItemText(hDlg, aIDs[i], szIPAddress, countof(szIPAddress));
        if (StrToInt(szIPAddress) > 255)
        {
            ErrorMessageBox(hDlg, IDS_BADIPADDR);

            Edit_SetSel(GetDlgItem(hDlg, aIDs[i]), 0, -1);
            SetFocus(GetDlgItem(hDlg, aIDs[i]));

            return FALSE;
        }
    }

    return TRUE;
}


static PSIGNUPFILE IsEntryPathInSignupArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, LPCTSTR pcszEntryPath)
{
    for ( ;  nSignupArrayElems-- > 0;  pSignupArray++)
        if (ISNONNULL(pSignupArray->szEntryPath)  &&  StrCmpI(PathFindFileName(pSignupArray->szEntryPath), pcszEntryPath) == 0)
            return pSignupArray;

    return NULL;
}


static VOID CleanupSignupFiles(LPCTSTR pcszTempDir, LPCTSTR pcszIns)
{
    for (INT i = 0;  TRUE;  i++)
    {
        TCHAR szKey[8],
              szFile[MAX_PATH];

        wnsprintf(szKey, countof(szKey), FILE_TEXT, i);
        if (GetPrivateProfileString(IS_SIGNUP, szKey, TEXT(""), szFile, countof(szFile), pcszIns) == 0)
            break;

        DeleteFileInDir(szFile, pcszTempDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\security.cpp ===
#include "precomp.h"
#include <wincrypt.h>

extern TCHAR g_szCustIns[];
extern TCHAR g_szTempSign[];
extern TCHAR g_szWizRoot[];
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

static void initCerts(HWND hwndCtl);
static void addCompanyCertToReg(HWND hDlg);

INT_PTR CALLBACK ISPAddRootCertDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szCertFile[MAX_PATH];
    TCHAR szWorkDir[MAX_PATH];
    TCHAR szTemp[MAX_PATH];

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_ISPROOTCERT);
        Edit_LimitText(GetDlgItem(hDlg, IDE_ISPROOTCERT), countof(szCertFile) - 1);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            // import INS clean-up -- delete cert file from the temp location
            if (InsGetString(IS_ISPSECURITY, IK_ROOTCERT, szCertFile, countof(szCertFile), g_szCustIns))
                DeleteFileInDir(szCertFile, g_szTempSign);

            SetBannerText(hDlg);

            SetDlgItemText(hDlg, IDE_ISPROOTCERT, szCertFile);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            if (!CheckField(hDlg, IDE_ISPROOTCERT, FC_FILE | FC_EXISTS))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                return TRUE;
            }

            g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szWorkDir);

            // delete the old cert file
            if (InsGetString(IS_ISPSECURITY, IK_ROOTCERT, szTemp, countof(szTemp), g_szCustIns))
                DeleteFileInDir(szTemp, szWorkDir);

            // copy the new cert file
            GetDlgItemText(hDlg, IDE_ISPROOTCERT, szCertFile, countof(szCertFile));
            if (*szCertFile)
                CopyFileToDir(szCertFile, szWorkDir);

            InsWriteString(IS_ISPSECURITY, IK_ROOTCERT, szCertFile, g_szCustIns);

            g_iCurPage = PPAGE_ADDROOT;
            EnablePages();
            (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_BROWSEROOTCERT:
            GetDlgItemText(hDlg, IDE_ISPROOTCERT, szCertFile, countof(szCertFile));
            if (BrowseForFile(hDlg, szCertFile, countof(szCertFile), GFN_CERTIFICATE))
                SetDlgItemText(hDlg, IDE_ISPROOTCERT, szCertFile);
            break;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK CabSignDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szSPCPath[MAX_PATH];
    TCHAR szPVKPath[MAX_PATH];
    TCHAR szDesc[MAX_PATH];
    TCHAR szInfoUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szTimeUrl[INTERNET_MAX_URL_LENGTH];

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_CSCOMP);
        initCerts(GetDlgItem(hDlg, IDC_CSCOMP));

        EnableDBCSChars(hDlg, IDE_CSSPC);
        EnableDBCSChars(hDlg, IDE_CSPVK);
        EnableDBCSChars(hDlg, IDE_CSDESC);
        EnableDBCSChars(hDlg, IDE_CSURL);
        EnableDBCSChars(hDlg, IDE_CSTIME);
 
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSSPC),  countof(szSPCPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSPVK),  countof(szPVKPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSDESC), countof(szDesc)    - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSURL),  countof(szInfoUrl) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSTIME),  countof(szTimeUrl) - 1);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

            InsGetString(IS_CABSIGN, IK_SPC,   szSPCPath, countof(szSPCPath), g_szCustIns);
            InsGetString(IS_CABSIGN, IK_PVK,   szPVKPath, countof(szPVKPath), g_szCustIns);
            InsGetString(IS_CABSIGN, IK_NAME,  szDesc,    countof(szDesc),    g_szCustIns);
            InsGetString(IS_CABSIGN, IK_CSURL, szInfoUrl, countof(szInfoUrl), g_szCustIns);
            InsGetString(IS_CABSIGN, IK_CSTIME, szTimeUrl, countof(szTimeUrl), g_szCustIns);

            SetDlgItemText(hDlg, IDE_CSSPC,  szSPCPath);
            SetDlgItemText(hDlg, IDE_CSPVK,  szPVKPath);
            SetDlgItemText(hDlg, IDE_CSDESC, szDesc);
            SetDlgItemText(hDlg, IDE_CSURL,  szInfoUrl);
            SetDlgItemText(hDlg, IDE_CSTIME,  szTimeUrl);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            GetDlgItemText(hDlg, IDE_CSSPC,  szSPCPath, countof(szSPCPath));
            GetDlgItemText(hDlg, IDE_CSPVK,  szPVKPath, countof(szPVKPath));
            GetDlgItemText(hDlg, IDE_CSDESC, szDesc,    countof(szDesc));
            GetDlgItemText(hDlg, IDE_CSURL,  szInfoUrl, countof(szInfoUrl));
            GetDlgItemText(hDlg, IDE_CSTIME,  szTimeUrl, countof(szTimeUrl));

            if (*szSPCPath  ||  *szPVKPath  ||  *szDesc  ||  *szInfoUrl ||  *szTimeUrl)
            {
                TCHAR szCompanyName[MAX_PATH];
                HWND hwndCtl;
                int iSel;

                if (!CheckField(hDlg, IDE_CSSPC,  FC_NONNULL | FC_FILE | FC_EXISTS)  ||
                    !CheckField(hDlg, IDE_CSPVK,  FC_NONNULL | FC_FILE | FC_EXISTS)  ||
                    !CheckField(hDlg, IDE_CSDESC, FC_NONNULL)                        ||
                    !CheckField(hDlg, IDE_CSURL,  FC_URL)                            ||
                    !CheckField(hDlg, IDE_CSTIME, FC_URL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }

                *szCompanyName = TEXT('\0');
                hwndCtl = GetDlgItem(hDlg, IDC_CSCOMP);

                iSel = ComboBox_GetCurSel(hwndCtl);
                if (iSel != CB_ERR)
                    ComboBox_GetLBText(hwndCtl, iSel, szCompanyName);

                InsWriteString(IS_CABSIGN, IK_COMPANYNAME, szCompanyName, g_szCustIns);
            }

            InsWriteString(IS_CABSIGN, IK_SPC,   szSPCPath, g_szCustIns);
            InsWriteString(IS_CABSIGN, IK_PVK,   szPVKPath, g_szCustIns);
            InsWriteString(IS_CABSIGN, IK_NAME,  szDesc,    g_szCustIns);
            InsWriteString(IS_CABSIGN, IK_CSURL, szInfoUrl, g_szCustIns);
            InsWriteString(IS_CABSIGN, IK_CSTIME, szTimeUrl, g_szCustIns);

            g_iCurPage = PPAGE_CABSIGN;
            EnablePages();
            (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_CSADD:
            addCompanyCertToReg(hDlg);       
            break;
        case IDC_BROWSECSSPC:
            GetDlgItemText(hDlg, IDE_CSSPC, szSPCPath, countof(szSPCPath));
            if (BrowseForFile(hDlg, szSPCPath, countof(szSPCPath), GFN_SPC))
                SetDlgItemText(hDlg, IDE_CSSPC, szSPCPath);
            break;

        case IDC_BROWSECSPVK:
            GetDlgItemText(hDlg, IDE_CSPVK, szPVKPath, countof(szPVKPath));
            if (BrowseForFile(hDlg, szPVKPath, countof(szPVKPath), GFN_PVK))
                SetDlgItemText(hDlg, IDE_CSPVK, szPVKPath);
            break;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

static void initCerts(HWND hwndCtl)
{
    HKEY hKey;
    TCHAR szCompanyName[MAX_PATH];

    if (SHOpenKeyHKCU(RK_TRUSTKEY, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        TCHAR szKey[MAX_PATH];
        TCHAR szValue[MAX_PATH];
        DWORD dwEntry;
        DWORD cchKey;
        DWORD cbValue;

        dwEntry = 0;
        cchKey  = countof(szKey);
        cbValue = sizeof(szValue);

        while (RegEnumValue(hKey, dwEntry, szKey, &cchKey, NULL, NULL, (LPBYTE) szValue, &cbValue) == ERROR_SUCCESS)
        {
            if (ComboBox_FindStringExact(hwndCtl, -1, szValue) == CB_ERR)   // string not present
                ComboBox_AddString(hwndCtl, szValue);                       // so, add it

            dwEntry++;
            cchKey  = countof(szKey);
            cbValue = sizeof(szValue);
        }

        RegCloseKey(hKey);
    }

    InsGetString(IS_CABSIGN, IK_COMPANYNAME, szCompanyName, countof(szCompanyName), g_szCustIns);
    if (*szCompanyName == TEXT('\0'))
        StrCpy(szCompanyName, TEXT("MICROSOFT"));

    ComboBox_SelectString(hwndCtl, -1, szCompanyName);
}

static void addCompanyCertToReg(HWND hDlg)
{
    if (CheckField(hDlg, IDE_CSSPC,  FC_NONNULL | FC_FILE | FC_EXISTS)  &&
        CheckField(hDlg, IDE_CSPVK,  FC_NONNULL | FC_FILE | FC_EXISTS))
    {
        TCHAR szTempDir[MAX_PATH];
        TCHAR szTempFile[MAX_PATH];
        TCHAR szCabFile[MAX_PATH];
        TCHAR szResult[MAX_PATH + 16] = TEXT("");
        BOOL fSuccess = FALSE;
    
        
        PathCombine(szTempDir, g_szTempSign, TEXT("SIGN"));
        PathCreatePath(szTempDir);
        
        // copy signing files to temp dir
        
        PathCombine(szTempFile, g_szWizRoot, TEXT("tools\\signcode.exe"));
        CopyFileToDir(szTempFile, szTempDir);
        PathRemoveFileSpec(szTempFile);
        PathAppend(szTempFile, TEXT("signer.dll"));
        CopyFileToDir(szTempFile, szTempDir);
        
        GetDlgItemText(hDlg, IDE_CSSPC, szTempFile, countof(szTempFile));
        InsWriteString(IS_CABSIGN, IK_SPC, szTempFile, g_szCustIns);
        GetDlgItemText(hDlg, IDE_CSPVK, szTempFile, countof(szTempFile));
        InsWriteString(IS_CABSIGN, IK_PVK, szTempFile, g_szCustIns);
        
        InsFlushChanges(g_szCustIns);
        
        PathCombine(szTempFile, szTempDir, TEXT("temp.exe"));

        // copy cabarc.exe from tools dir to  sign

        PathCombine(szCabFile, g_szWizRoot, TEXT("tools\\cabarc.exe"));

        CopyFile(szCabFile, szTempFile, FALSE);
        
        SignFile(szTempFile, NULL, g_szCustIns, szResult, NULL, TRUE);
        
        if (ISNULL(szResult) &&
            (CheckTrustExWrap(NULL, szTempFile, hDlg, FALSE, NULL) == NOERROR))
            fSuccess = TRUE;
            
        if (fSuccess)
        {
            initCerts(GetDlgItem(hDlg, IDC_CSCOMP));
            ErrorMessageBox(hDlg, IDS_SUCCESS_CSADDCERT);
        }
        else
            ErrorMessageBox(hDlg, IDS_ERROR_CSADDCERT);
        
        PathRemovePath(szTempDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\update.cpp ===
#include "precomp.h"

extern TCHAR g_szTitle[];
extern TCHAR g_szBuildTemp[];
extern TCHAR g_szBaseURL[];
extern TCHAR g_szWizRoot[];
extern HWND g_hWait;
extern BOOL g_fLocalMode, g_fOCW;
extern int s_iType;

extern DWORD GetRootFree(LPCTSTR pcszPath);
extern HRESULT DownloadCab(HWND hDlg, LPTSTR szUrl, LPTSTR szFilename,
                           LPCTSTR pcszDisplayname, int sComponent, BOOL &fIgnore);

void UpdateIni(LPCTSTR pcszCurrentIni, CCifComponent_t * pCifComponent_t)
{
    TCHAR szNew[INTERNET_MAX_URL_LENGTH];

    if (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("Win32"), szNew, countof(szNew))))
        WritePrivateProfileString(TEXT("IEAK"), TEXT("Win32"), szNew, pcszCurrentIni);
    if (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("Ini"), szNew, countof(szNew))))
        WritePrivateProfileString(VERSION, IK_INI, szNew, pcszCurrentIni);

}

BOOL CheckIniVersion(LPTSTR pszId, LPCTSTR pcszCurrentIni, CCifComponent_t * pCifComponent_t)
{
    TCHAR szCurrentVer[64];
    TCHAR szNewVer[64];
    BOOL fRet = TRUE;

    GetPrivateProfileString(VERSION, pszId, TEXT(""), szCurrentVer, countof(szCurrentVer), pcszCurrentIni);

    fRet = SUCCEEDED(pCifComponent_t->GetCustomData(pszId, szNewVer, countof(szNewVer)));

    return (fRet && (CheckVer(szCurrentVer, szNewVer) < 0));
}

DWORD DownloadUpdateThreadProc(LPVOID lpvUrl)
{
    TCHAR szDest[MAX_PATH];
    TCHAR szMsg[MAX_PATH];
    LPTSTR pFile;
    DWORD dwRet = 0;

    GetTempPath(countof(szDest), szDest);

    pFile = StrRChr((LPTSTR)lpvUrl, NULL, TEXT('/'));

    if (pFile != NULL)
        pFile++;

    if (StrCmpI(StrRChr((LPTSTR)lpvUrl, NULL, TEXT('.')), TEXT(".EXE")) == 0)
    {
        BOOL fIgnore = FALSE;

        PathAppend(szDest, pFile);

        if (DownloadCab(g_hWait, (LPTSTR)lpvUrl, szDest, NULL, 0, fIgnore) != NOERROR)
        {
            LoadString(g_rvInfo.hInst, IDS_UPDATEERROR, szMsg, countof(szMsg));
            MessageBox(g_hWizard, szMsg, g_szTitle, MB_OK);
            return (DWORD)-1;
        }
    }
    else
    {
        BOOL fSuccess = TRUE;
        BOOL fIgnore = FALSE;

        PathCombine(szDest, g_szBuildTemp, pFile);

        if (DownloadCab(g_hWait, (LPTSTR)lpvUrl, szDest, NULL, 0, fIgnore) == NOERROR)
        {
            TCHAR szTempDir[MAX_PATH];

            PathCombine(szTempDir, g_szBuildTemp, TEXT("update"));
            PathCreatePath(szTempDir);

            if (ExtractFilesWrap(szDest, szTempDir, 0, NULL, NULL, 0) == ERROR_SUCCESS)
            {
                TCHAR szInf[MAX_PATH];

                PathCombine(szInf, szTempDir, TEXT("ieak6.inf"));
                dwRet = RunSetupCommandWrap(g_hWizard, szInf, NULL, szTempDir, NULL,
                    NULL, RSC_FLAG_INF | RSC_FLAG_QUIET, NULL);

                PathRemovePath(szTempDir);
                DeleteFile(szDest);
            }
            else
                fSuccess = FALSE;
        }
        else
            fSuccess = FALSE;

        SendMessage(g_hWait, WM_CLOSE, 0, 0);

        if (!fSuccess)
        {
            LoadString(g_rvInfo.hInst, IDS_UPDATEERROR, szMsg, countof(szMsg));
            MessageBox(g_hWizard, szMsg, g_szTitle, MB_OK);
            return (DWORD)-1;
        }
    }

    return dwRet;
}

void UpdateIEAK(HWND hDlg)
{
    TCHAR szCurrentIni[MAX_PATH];
    TCHAR szMsg[MAX_PATH];
    TCHAR szUpdateUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szCifLang[8];
    TCHAR szWizLang[8];
    ICifComponent * pCifComponent;
    CCifComponent_t * pCifComponent_t;
    DWORD dwTid;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL fNo = FALSE;
    HWND hWait;

    if (!g_lpCifFileNew || !(SUCCEEDED(g_lpCifFileNew->FindComponent(TEXT("ieak6OPT"), &pCifComponent))))
        return;

    pCifComponent_t = new CCifComponent_t((ICifRWComponent *)pCifComponent);

    pCifComponent_t->GetCustomData(TEXT("Lang"), szCifLang, countof(szCifLang));

    StrCpy(szUpdateUrl, g_szBaseURL);
    if (*(CharPrev(szUpdateUrl, szUpdateUrl + StrLen(szUpdateUrl))) != TEXT('/'))
        StrCat(szUpdateUrl, TEXT("/"));

    PathCombine(szCurrentIni, g_szWizRoot, TEXT("ieak.ini"));

    GetPrivateProfileString(VERSION, TEXT("Lang"), TEXT(""), szWizLang, countof(szWizLang), szCurrentIni);

    // only allow self-update for same language as the current wizard

    if (StrCmpI(szCifLang, szWizLang) != 0)
        goto exit;

    if (CheckIniVersion(IK_FULL, szCurrentIni, pCifComponent_t))
    {
        pCifComponent_t->GetCustomData(TEXT("FullText"), szMsg, countof(szMsg));

        if (MessageBox(g_hWizard, szMsg, g_szTitle, MB_YESNO | MB_DEFBUTTON2) == IDYES)
        {
            HANDLE hThread;
            TCHAR szExeName[MAX_PATH];
            DWORD dwFlags;
            ICifComponent * pCifExeComponent;
            CCifComponent_t * pCifExeComponent_t;

            if (SUCCEEDED(g_lpCifFileNew->FindComponent(TEXT("ieak6EXE"), &pCifExeComponent)))
            {
                pCifExeComponent_t = new CCifComponent_t((ICifRWComponent *)pCifExeComponent);

                if (SUCCEEDED(pCifExeComponent_t->GetUrl(0, szExeName, countof(szExeName), &dwFlags)))
                {
                    // do not allow self-update to continue if not enough size (size of Exe +
                    // extract size approximated by twice the size of the exe)

                    if (((dwFlags = pCifExeComponent_t->GetDownloadSize() * 3) > GetRootFree(g_szBuildTemp)) &&
                        dwFlags)
                    {
                        TCHAR szMsg[MAX_PATH];
                        TCHAR szMsgTemplate[MAX_PATH];

                        LoadString(g_rvInfo.hInst, IDS_ERROR_UPDATESPACE, szMsgTemplate, countof(szMsgTemplate));
                        wnsprintf(szMsg, countof(szMsg), szMsgTemplate, pCifExeComponent_t->GetDownloadSize() * 3);
                        dwRet = (DWORD)-1;
                        MessageBox(hDlg, szMsg, g_szTitle, MB_OK | MB_ICONEXCLAMATION);
                    }
                    else
                    {
                        StrCat(szUpdateUrl, szExeName);

                        hWait = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_UPDATE), hDlg,
                            DownloadStatusDlgProc);
                        ShowWindow( hWait, SW_SHOWNORMAL );

                        hThread = CreateThread(NULL, 4096, DownloadUpdateThreadProc, (LPVOID)szUpdateUrl, 0, &dwTid);

                        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                        {
                            MSG msg;

                            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                        GetExitCodeThread(hThread, &dwRet);
                        CloseHandle(hThread);
                        SendMessage(hWait, WM_CLOSE, 0, 0);
                    }
                }
                else
                    dwRet = (DWORD)-1;

                delete pCifExeComponent_t;
            }
            else
                dwRet = (DWORD)-1;

            if (dwRet == -1)
            {
                g_fLocalMode = TRUE;
                goto exit;
            }
            else
            {
                SHELLEXECUTEINFO shInfo;
                DWORD dwPID;
                TCHAR szTempBuf[MAX_PATH + 32];
                TCHAR szTempPath[MAX_PATH];

                PathCombine(szTempBuf, g_szWizRoot, TEXT("update.exe"));
                GetTempPath(countof(szTempPath), szTempPath);
                CopyFileToDir(szTempBuf, szTempPath);

                ZeroMemory(&shInfo, sizeof(shInfo));
                shInfo.cbSize = sizeof(shInfo);
                shInfo.hwnd = GetDesktopWindow();
                shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
                shInfo.lpVerb = TEXT("open");
                shInfo.lpFile = TEXT("update.exe");
                dwPID = GetCurrentProcessId();
                WCHAR wcType;
                switch (s_iType)
                {
                    case BRANDED:
                        wcType = TEXT('B');
                    break;
                    
                    case REDIST:
                        wcType = TEXT('R');
                    break;

                    case INTRANET:
                    default:
                        wcType = TEXT('I');
                    break;
                }
                if (g_fOCW)
                    wnsprintf(szTempBuf, countof(szTempBuf), TEXT("/o /p:%lu /m:%c"), dwPID,wcType);
                else
                    wnsprintf(szTempBuf, countof(szTempBuf), TEXT("/p:%lu /m:%c"), dwPID,wcType);

                shInfo.lpParameters = szTempBuf;
                shInfo.lpDirectory = szTempPath;
                shInfo.nShow = SW_SHOWNORMAL;

                ShellExecuteEx(&shInfo);
                CloseHandle(shInfo.hProcess);
                DoCancel();
                goto exit;
            }
        }
        else
            fNo = TRUE;
    }

    if (!fNo && (CheckIniVersion(IK_CAB, szCurrentIni, pCifComponent_t)))
    {
        pCifComponent_t->GetCustomData(TEXT("CabText"), szMsg, countof(szMsg));

        if (MessageBox(g_hWizard, szMsg, g_szTitle, MB_YESNO | MB_DEFBUTTON2) == IDYES)
        {
            TCHAR szNewVer[MAX_PATH];
            TCHAR  szCabName[32];
            DWORD dwFlags;
            HANDLE hThread;
            ICifComponent * pCifCabComponent;
            CCifComponent_t * pCifCabComponent_t;

            if (SUCCEEDED(g_lpCifFileNew->FindComponent(TEXT("ieak6CAB"), &pCifCabComponent)))
            {
                pCifCabComponent_t = new CCifComponent_t((ICifRWComponent *)pCifCabComponent);

                if (SUCCEEDED(pCifCabComponent_t->GetUrl(0, szCabName, countof(szCabName), &dwFlags)))
                {
                    // do not allow self-update to continue if not enough size (size of Cab +
                    // extract size approximated by twice the size of the cab)

                    if (((dwFlags = pCifCabComponent_t->GetDownloadSize() * 3) > GetRootFree(g_szBuildTemp)) &&
                        dwFlags)
                    {
                        TCHAR szMsg[MAX_PATH];
                        TCHAR szMsgTemplate[MAX_PATH];

                        LoadString(g_rvInfo.hInst, IDS_ERROR_UPDATESPACE, szMsgTemplate, countof(szMsgTemplate));
                        wnsprintf(szMsg, countof(szMsg), szMsgTemplate, pCifCabComponent_t->GetDownloadSize() * 3);
                        dwRet = (DWORD)-1;
                        MessageBox(hDlg, szMsg, g_szTitle, MB_OK | MB_ICONEXCLAMATION);
                    }
                    else
                    {
                        StrCat(szUpdateUrl, szCabName);

                        hWait = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_UPDATE), hDlg,
                            DownloadStatusDlgProc);
                        ShowWindow( hWait, SW_SHOWNORMAL );

                        hThread = CreateThread(NULL, 4096, DownloadUpdateThreadProc, (LPVOID)szUpdateUrl, 0, &dwTid);

                        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                        {
                            MSG msg;

                            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                        GetExitCodeThread(hThread, &dwRet);
                        CloseHandle(hThread);
                        SendMessage(hWait, WM_CLOSE, 0, 0);
                    }
                }
                else
                    dwRet = (DWORD)-1;

                delete pCifCabComponent_t;
            }
            else
                dwRet = (DWORD)-1;

            if (dwRet == (DWORD)-1)
            {
                g_fLocalMode = TRUE;
                goto exit;
            }

            if (CheckIniVersion(IK_INI, szCurrentIni, pCifComponent_t))
                UpdateIni(szCurrentIni, pCifComponent_t);

            if (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("Cab"), szNewVer, countof(szNewVer))))
                WritePrivateProfileString(VERSION, IK_CAB, szNewVer, szCurrentIni);
        }
        else
            fNo = TRUE;
    }

    if (!fNo && (CheckIniVersion(IK_INI, szCurrentIni, pCifComponent_t)))
    {
        pCifComponent_t->GetCustomData(TEXT("IniText"), szMsg, countof(szMsg));

        if (MessageBox(g_hWizard, szMsg, g_szTitle, MB_YESNO | MB_DEFBUTTON2) == IDYES)
        {
            UpdateIni(szCurrentIni, pCifComponent_t);
        }
        else
            fNo = TRUE;
    }

    if (dwRet == ERROR_SUCCESS_REBOOT_REQUIRED)
        DoReboot(g_hWizard);

    if (fNo)
        g_fLocalMode = TRUE;

exit:
    delete pCifComponent_t;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\updates.cpp ===
#include "precomp.h"
#include "ie4comp.h"
#include "updates.h"

extern PCOMP_VERSION g_rgCompVer;

void InsertCommas(LPTSTR pszIn)
{                                     //---- Puts commas into numbered strings ending in " KB" ----
    TCHAR szTemp[30], szTemp2[30];
    int   i, j, z;

    for (j=0; pszIn[j+3]; j++);
    for (i=j-1; i>=0; i--)
        szTemp[j-i-1]=pszIn[i];
    szTemp[j]='\0';
    z=0;
    for (i=0; szTemp[i]; i++, z++) {
        szTemp2[z] = szTemp[i];
        if (i % 3 == 2) {
            z++;
            szTemp2[z] = ',';
        }
    }
    if (',' == szTemp2[z-1])
        z--;
    szTemp2[z]='\0';
    for (i=z-1; i>=0; i--)
        pszIn[z-i-1] = szTemp2[i];
    pszIn[z]='\0';
    StrCat(pszIn, TEXT(" KB"));
}

ATOM CreateIEAKUrl()
{
    WNDCLASS wc;
    wc.style         = 0;
    wc.lpfnWndProc   = HyperLinkWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_rvInfo.hInst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(g_rvInfo.hInst, MAKEINTRESOURCE(IDC_LINK));
    wc.hbrBackground = (HBRUSH) GetStockObject(GetSysColor(COLOR_MENU));
    wc.lpszMenuName  = TEXT("Link Window");
    wc.lpszClassName = TEXT("Link Window");
    return RegisterClass(&wc);
}

HRESULT CifComponentToPComponent(PCOMPONENT pComp, CCifComponent_t * pCifComponent_t)
{
    TCHAR          szCustData[MAX_PATH], szID[128], szMode[MAX_PATH];
    DWORD          dwPlatform, dwType, dwVer, dwBuild;
    UINT           uiIndex = 0;
    ICifComponent* pCifComponentTemp;
    
    pComp->fVisible = (pCifComponent_t->IsUIVisible() == S_FALSE) ? FALSE : TRUE;

    dwPlatform = pCifComponent_t->GetPlatform();

    if (dwPlatform & PLATFORM_WIN98)
    {
        if (dwPlatform & PLATFORM_NT4)
            pComp->iPlatform = PLAT_I386;
        else
            pComp->iPlatform = PLAT_W98;
    }
    else
        pComp->iPlatform = PLAT_NTx86;

    pCifComponent_t->GetID(szID, countof(szID));

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("AddOnOnly"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
    {
        pComp->fAddOnOnly = TRUE;
        pComp->fVisible = TRUE;
    }

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKVisible"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
        pComp->fVisible = TRUE;

    szMode[0] = TEXT('\0');
    if (SUCCEEDED(g_lpCifRWFile->FindComponent(szID, &pCifComponentTemp)))
    {
        CCifComponent_t * pCifComponentTemp_t =
            new CCifComponent_t((ICifRWComponent *)pCifComponentTemp);
        while (SUCCEEDED(pCifComponentTemp_t->GetMode(uiIndex, szMode, countof(szMode))))
        {
            pComp->szModes[uiIndex] = szMode[0];
            pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
            uiIndex++;
        }
        delete pCifComponentTemp_t;
    }
    else
    {
        while (SUCCEEDED(pCifComponent_t->GetMode(uiIndex, szMode, countof(szMode))))
        {
            pComp->szModes[uiIndex] = szMode[0];
            pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
            uiIndex++;
        }
    } 

    pComp->szModes[uiIndex] = TEXT('\0');

    ZeroMemory(pComp->szVersion, sizeof(pComp->szVersion));
    pCifComponent_t->GetVersion(&dwVer, &dwBuild);
    ConvertDwordsToVersionStr(pComp->szVersion, dwVer, dwBuild);
    
    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKCore"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
    {
        pComp->iCompType = COMP_CORE;
        pComp->fVisible = FALSE;
    }

    // pick up special core comps for OCW

    if (g_fOCW && (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKOCWCore"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
    {
        pComp->iCompType = COMP_CORE;
        pComp->fVisible = FALSE;
    }

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKServer"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
        pComp->iCompType = COMP_SERVER;

    // IEAK should ignore these components since they point to the same cabs as
    // another section

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKAVSIgnore"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
    {
        pComp->fAVSDupe = TRUE;
        pComp->fVisible = FALSE;
    }

    // pick up components which point to the same cabs as this section

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKAVSLinks"), szCustData, countof(szCustData))))
        && ISNONNULL(szCustData))
    {
        StrRemoveWhitespace(szCustData);
        if ((pComp->pszAVSDupeSections =
            (LPTSTR)CoTaskMemAlloc((StrLen(szCustData)+1) * sizeof(TCHAR))) != NULL)
            StrCpy(pComp->pszAVSDupeSections, szCustData);
    }
    else
        pComp->pszAVSDupeSections = NULL;

    StrCpy(pComp->szSection, szID);

    /*bug 14679 - don't change these pointers in updates.cpp or this will get clobbered when updates.cpp frees
    all this memory!!

    if (StrCmpI(szID, TEXT("MAILNEWS")) == 0)
        g_pMNComp = pComp;

*/

    pCifComponent_t->GetGUID(pComp->szGUID, countof(pComp->szGUID));
    pCifComponent_t->GetDescription(pComp->szDisplayName, countof(pComp->szDisplayName));
    pCifComponent_t->GetUrl(0, pComp->szUrl, countof(pComp->szUrl), &dwType);
    if (!(dwType & URLF_RELATIVEURL))
    {
        LPTSTR pUrl;
        TCHAR szTempUrl[MAX_PATH];

        pUrl = StrRChr(pComp->szUrl, NULL, TEXT('/'));
        if (pUrl)
            pUrl++;
        else
            pUrl = pComp->szUrl;

        StrCpy(szTempUrl, pUrl);
        StrCpy(pComp->szUrl, szTempUrl);
    }

    pComp->dwSize = pCifComponent_t->GetDownloadSize();
    return TRUE;
}

void UpdateBlueIcon(HWND hCompList, PCOMPONENT pComp)
{
    PCOMPONENT pCompTemp = FindComp(pComp->szSection, FALSE);
    LVITEM     lvi;
                                
    StrCpy(pCompTemp->szVersion, pComp->szVersion);
    pCompTemp->dwSize = pComp->dwSize;
    pCompTemp->iImage = BLUE2;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask  = LVIF_IMAGE;
    lvi.iItem = pCompTemp->iList;
    ListView_GetItem(hCompList, &lvi);

    lvi.iImage = BLUE2;
    lvi.mask   = LVIF_IMAGE;
    lvi.iItem  = pCompTemp->iList;

    ListView_SetItem(hCompList, &lvi);
    ListView_SetItemText(hCompList, lvi.iItem, 1, pComp->szVersion);
}

void UpdateBrownIcon(HWND hCompList, PCOMPONENT pNewComp)
{
    PCOMPONENT pComp = NULL;
    PCOMP_VERSION pCompVer = NULL;
    LVITEM     lvi;
    int        nList = ListView_GetItemCount(hCompList);
    UINT        uiSize;
    
    ZeroMemory(&lvi, sizeof(lvi));

    uiSize = (UINT)LocalSize(g_paComp);
    
    if (uiSize < (g_uiNumCabs * sizeof(COMPONENT)))
    {
        ASSERT(TRUE);  //not enough memory for all these components
        return;
    }

    pComp = g_paComp + g_uiNumCabs;
    *pComp = *pNewComp;

    //we also need to set g_rgCompVer
    pCompVer = g_rgCompVer + g_uiNumCabs;
    StrCpy(pCompVer->szID,pComp->szCommand);
    StrCpy(pCompVer->szVersion,pComp->szVersion);
  
    pComp->iList  = nList;
    pComp->iImage = BROWN2;
    
    lvi.mask       = LVIF_TEXT | LVIF_IMAGE;
    lvi.iItem      = nList;
    lvi.iSubItem   = 0;
    lvi.iImage     = BROWN2;
    lvi.pszText    = pComp->szDisplayName;
    lvi.cchTextMax = countof(pComp->szDisplayName);
    ListView_InsertItem(hCompList, &lvi);

    //handle our special case globals--per bug 14679, we have to be very careful what these point
    //to, that it's something that won't be freed until we are really done.  g_paComp will hold
    //onto this memory until the end, though having these global pointers is still risky design

    if (StrCmpI(pComp->szDisplayName, TEXT("MAILNEWS")) == 0)
        g_pMNComp = pComp;

    ListView_SetItemText(hCompList, nList, 1, pComp->szVersion);
    g_uiNumCabs++;
}

HRESULT ProcessUpdateIcons(HWND hDlg)
{                                  //---- fixes  updated component for the main page list view
    HWND                hCompList          = GetDlgItem(hDlg, IDC_COMPLIST);
    HRESULT             hr                 = NULL;
    TCHAR               szUpdateCif[MAX_PATH];
    PCOMP_VERSION       pCompVer           = NULL;
    CCifFile_t*         pCifFile           = NULL;
    IEnumCifComponents* pEnumCifComponents = NULL;

    PathCombine(szUpdateCif, g_szIEAKProg, TEXT("update\\ieupdate.cif"));

    if (!PathFileExists(szUpdateCif))
        return DONT_SHOW_UPDATES;

    if ((0 == StrCmp(TEXT(""), g_szUpdateData)) || (0 == StrCmp(TEXT(""), g_szUpdateURL)))
        GetUpdateSite();
    
    GetICifFileFromFile_t(&pCifFile, szUpdateCif);
    hr = pCifFile->EnumComponents(&pEnumCifComponents, PLATFORM_WIN98 | PLATFORM_NT4 | 
                                                       PLATFORM_NT5 | PLATFORM_MILLEN, NULL);
    if (FAILED(hr)) {
        delete pCifFile;
        return hr;
    }
    
    ICifComponent* pCifComponent = NULL;
    PCOMPONENT     pComp         = NULL;
    
    pComp = (PCOMPONENT) LocalAlloc(LPTR, sizeof(COMPONENT) );
          
    while (S_OK == pEnumCifComponents->Next(&pCifComponent))
    {
        CCifComponent_t* pCifComp;

        pCifComp = new CCifComponent_t((ICifRWComponent*)pCifComponent);
        if (NULL == pCifComp) {
            delete pCifComp;
            continue;
        }
        
        ZeroMemory(pComp, sizeof(COMPONENT));
        CifComponentToPComponent(pComp, pCifComp);
        if ((FALSE == pComp->fVisible) || (TRUE == pComp->fAVSDupe)) {
            delete pCifComp;
            continue;
        }

        pComp->iImage = AssignComponentIcon(pComp->szSection, 3);

        if (DONT_SHOW_UPDATES != pComp->iImage) {
            if (BLUE2 == pComp->iImage) 
                UpdateBlueIcon(hCompList, pComp);

            if (BROWN2 == pComp->iImage)
                UpdateBrownIcon(hCompList, pComp);
        }

        delete pCifComp;
    }

    pEnumCifComponents->Release();
    delete pCifFile;
    LocalFree(pComp);
    return TRUE;
}

HRESULT DownloadUpdate(PCOMPONENT pComp)
{
    TCHAR        szLocalPath[MAX_PATH], szUrl[INTERNET_MAX_URL_LENGTH];
    LPTSTR       pCab = NULL;
    DWORD        dwFreeSpace;
    HRESULT      hr;
    BOOL         fIgnore = FALSE;
    
    if (pComp->szDisplayName)
        SetDlgItemText( s_hStat, IDC_DOWNCOMPNAMD, pComp->szDisplayName );
    
    PathCombine(szLocalPath, g_szIEAKProg, pComp->szUrl);

    StrCpy(szUrl, g_szUpdateURL);
    StrCat(szUrl, TEXT("/"));
    StrCat(szUrl, pComp->szUrl);

    dwFreeSpace = GetRootFree(g_szIEAKProg);
    if (dwFreeSpace < pComp->dwSize)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szTemplate[MAX_PATH];
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
        LoadString( g_rvInfo.hInst, IDS_TEMPDISKMSG, szTemplate, MAX_PATH );
        wnsprintf(szMsg, countof(szMsg), szTemplate, dwFreeSpace, (pComp->dwSize));
        MessageBox(NULL, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
        return FALSE;
    }

    hr = DownloadCab(s_hStat, szUrl, szLocalPath, pComp->szDisplayName, pComp->dwSize, fIgnore);
    if (!PathFileExists(szLocalPath) || (DONT_SHOW_UPDATES == hr))
        return DONT_SHOW_UPDATES;

    updateCifVersions32(pComp, fIgnore, TRUE);
 
    return S_OK;
}

void InitAVSListView(HWND hCompList)
{
    LVCOLUMN lvc;
    TCHAR    szAux[MAX_PATH];
    HICON    hBrown, hBrown2, hBlue, hBlue2, hRed, hYellow, hGreen;
        
    //----- Create the image list if it has not already been created -----
    if (s_hImgList == 0) 
    {
        s_hImgList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON), 1, 7, 1);

        hBrown  = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_BROWN));
        hBrown2 = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_BROWN2));
        hBlue   = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_BLUE));
        hBlue2  = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_BLUE2));
        hRed    = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_RED));
        hYellow = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_YELLOW));
        hGreen  = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_GREEN));

        s_aiIcon[0] = ImageList_AddIcon(s_hImgList, hBrown);
        s_aiIcon[1] = ImageList_AddIcon(s_hImgList, hBrown2);
        s_aiIcon[2] = ImageList_AddIcon(s_hImgList, hBlue);
        s_aiIcon[3] = ImageList_AddIcon(s_hImgList, hBlue2);
        s_aiIcon[4] = ImageList_AddIcon(s_hImgList, hRed);
        s_aiIcon[5] = ImageList_AddIcon(s_hImgList, hYellow);
        s_aiIcon[6] = ImageList_AddIcon(s_hImgList, hGreen);
    
        DestroyIcon(hBrown);
        DestroyIcon(hBrown2);
        DestroyIcon(hBlue);
        DestroyIcon(hBlue2);
        DestroyIcon(hRed);
        DestroyIcon(hYellow);
        DestroyIcon(hGreen);
    }

    // Assign the image lists to the list view control.
    ListView_SetImageList(hCompList, s_hImgList, LVSIL_SMALL);

    //----- Initialize columns in a list view -----
    LoadString(g_rvInfo.hInst, IDS_COMPNAME, szAux, countof(szAux));

    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvc.fmt     = LVCFMT_LEFT;
    lvc.cx      = 273;
    lvc.pszText = szAux;
    ListView_InsertColumn(hCompList, 0, &lvc);

    LoadString(g_rvInfo.hInst, IDS_VERSION, szAux, countof(szAux));

    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvc.fmt     = LVCFMT_LEFT;
    lvc.cx      = 105;
    lvc.pszText = szAux;
    ListView_InsertColumn(hCompList, 1, &lvc);   
}

HRESULT AssignComponentIcon(LPTSTR szInID, int ipageNumber)
{
    //---- returns the icon color, Unless the component update is not shown => returns DONT_SHOW_UPDATE
    TCHAR             szDiskVer[MAX_PATH], szSetupVer[MAX_PATH], szUpdateVer[MAX_PATH], 
                      szIECifPath[MAX_PATH], szUpdatePath[MAX_PATH];
    HRESULT           hr = NULL;
    DWORD             dwVer, dwBuild;
    UINT              i;
    BOOL              fOnDisk = TRUE, fInSetupFile = TRUE, fInUpdateFile = TRUE, fInDownload = TRUE;
    PCOMP_VERSION     pCompVer = NULL;
    CCifFile_t      * lpDiskFile     = NULL, * lpSetupFile     = NULL, * lpUpdateFile     = NULL;
    ICifComponent   * pDiskComponent = NULL, * pSetupComponent = NULL, * pUpdateComponent = NULL;
    CCifComponent_t * pDiskComp      = NULL, * pSetupComp      = NULL, * pUpdateComp      = NULL;
    int               iDiskSetup;
    
    PathCombine(szIECifPath, g_szIEAKProg, TEXT("new\\iesetup.cif"));
    PathCombine(szUpdatePath, g_szIEAKProg, TEXT("update\\ieupdate.cif"));
    
    if (PathFileExists(g_szCif))
        hr = GetICifFileFromFile_t(&lpDiskFile, g_szCif);
    else
        fOnDisk = FALSE;

    pCompVer = g_rgCompVer;
    for (i=0; i < g_uiNumCabs; i++, pCompVer++) 
        if ((NULL != pCompVer->szID) && (0 == StrCmp(pCompVer->szID, szInID))) {
            StrCpy(szSetupVer, pCompVer->szVersion);
            fInSetupFile = TRUE;
            break;
        }
    if (((NULL == pCompVer->szID) || (i == g_uiNumCabs)) && (0 != StrCmp(pCompVer->szID, szInID)))
        fInSetupFile = FALSE;

    if (PathFileExists(szUpdatePath))                                          
        hr = GetICifFileFromFile_t(&lpUpdateFile, szUpdatePath);
    else
        fInUpdateFile = FALSE;

    if (fOnDisk)
        fOnDisk = SUCCEEDED(lpDiskFile->FindComponent(szInID, &pDiskComponent));
        if (fOnDisk)                                                                //--- Search ID in Builds\...\IEsetup.cif
        {
            TCHAR szPath[MAX_PATH], szUrl[MAX_PATH];
            DWORD dwType;

            pDiskComp = new CCifComponent_t((ICifRWComponent *) pDiskComponent);   
            StrCpy(szPath, g_szIEAKProg);

            pDiskComp->GetUrl(0, szUrl, countof(szUrl), &dwType);       //--- Check to see if it the cab is downloaded
            if (!(dwType & URLF_RELATIVEURL))
            {
                LPTSTR pUrl;
                TCHAR szTempUrl[MAX_PATH];

                pUrl = StrRChr(szUrl, NULL, TEXT('/'));
                if (pUrl)
                    pUrl++;
                else
                    pUrl = szUrl;

                StrCpy(szTempUrl, pUrl);
                StrCpy(szUrl, szTempUrl);
            }

            PathAppend(szPath, szUrl);

            if (!PathFileExists(szPath))
                fInDownload = FALSE;
            pDiskComp->GetVersion(&dwVer, &dwBuild);
            ConvertDwordsToVersionStr(szDiskVer, dwVer, dwBuild);
        }
        else
            fInDownload = FALSE;
    if (fInUpdateFile)
        fInUpdateFile = SUCCEEDED(lpUpdateFile->FindComponent(szInID, &pUpdateComponent));
        if (fInUpdateFile)                                                          //--- Search ID in update\IEsetup.cif
        {
            pUpdateComp = new CCifComponent_t((ICifRWComponent *) pUpdateComponent);   
            pUpdateComp->GetVersion(&dwVer, &dwBuild);
            ConvertDwordsToVersionStr(szUpdateVer, dwVer, dwBuild);
        }

    delete pSetupComp;
    delete pDiskComp;
    delete pUpdateComp;
    delete lpDiskFile;
    delete lpSetupFile;
    delete lpUpdateFile;

    if ((ipageNumber == 1) || (ipageNumber == 3))
        if ((!fOnDisk) || (!fInDownload))
            return RED;
        else 
        {
            iDiskSetup = CheckVer(szDiskVer, szSetupVer);
            if ((fInSetupFile) && (0 > iDiskSetup))
                return YELLOW;
            else
                if ((fInSetupFile) && (0 == iDiskSetup))
                    return GREEN;
        }

    if (fOnDisk)
    {
        if ((2 == ipageNumber) && (((CheckVer(szDiskVer, szUpdateVer) == 0) && (fInDownload)) ||
                                   (0 == CheckVer(szUpdateVer, szSetupVer))))
            return DONT_SHOW_UPDATES;
        if (2 == ipageNumber)
            if (fInSetupFile)
                return BLUE;
            else
                return BROWN;
        if (fInSetupFile)
            return BLUE2;
        else
            return BROWN2;
    }
    else
        if (!fInSetupFile)
            return BROWN;
        else
            return BLUE;
}

HRESULT PreAddListItem(HWND hCompList, int * count, CCifComponent_t * pCifComp)
{
    LVITEM       lvi;
    PCOMPONENT   pComp = NULL;
    
    ZeroMemory(&lvi, sizeof(lvi));

    pComp = (PCOMPONENT) LocalAlloc(LPTR, sizeof(COMPONENT) );
    if (!pComp) 
        return FALSE;
    ZeroMemory(pComp, sizeof(COMPONENT));
    
    CifComponentToPComponent(pComp, pCifComp);

    if ((TRUE == pComp->fAVSDupe) || (FALSE == pComp->fVisible))
        return FALSE;
    else
        pComp->iImage = lvi.iImage = AssignComponentIcon(pComp->szSection, 2);
    if (DONT_SHOW_UPDATES == lvi.iImage)
        return FALSE;

    lvi.lParam     = (LPARAM) pComp;

    lvi.mask       = LVIF_STATE | LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.iItem      = *count;
    lvi.pszText    = pComp->szDisplayName;
    lvi.cchTextMax = countof(pComp->szDisplayName);

    ListView_InsertItem(hCompList, &lvi);
    ListView_SetItemText(hCompList, *count, 1, pComp->szVersion);
    return TRUE;
}

int FillComponentsListView(HWND hCompList, LPCTSTR szCifPath, FCLV_PREADDLISTITEM pfnPreAddListItem)
{
    HRESULT  hr;
    LPLVITEM plvi   = NULL;
    int      icount = 0;
    CCifFile_t* pCifFile = NULL;

    InitAVSListView(hCompList);                 //---- assigns image list and creates columns

    if (NULL == pfnPreAddListItem)
        return S_FALSE;

    hr = GetICifFileFromFile_t(&pCifFile, szCifPath);
    if (FAILED(hr))
        return hr;

    IEnumCifComponents* pEnumCifComponents = NULL;
    ICifComponent*      pCifComponent      = NULL;

    hr = pCifFile->EnumComponents(&pEnumCifComponents,
                                  PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL);
    if (FAILED(hr))
        return hr;

    while (S_OK == pEnumCifComponents->Next(&pCifComponent))
    {
        CCifComponent_t* pCifComponent_t;

        pCifComponent_t = new CCifComponent_t((ICifRWComponent*)pCifComponent);
        if (NULL == pCifComponent_t)
            continue;

        if (!(*pfnPreAddListItem)(hCompList, &icount, pCifComponent_t))
            delete pCifComponent_t;
        else
            icount++;                            //----- Don't delete the component if it's in the list view
    }
    pEnumCifComponents->Release();

    delete pCifFile;
    return icount;
}

DWORD InitUpdateThreadProc(LPVOID lParam)    //----- Downloads cab file, extracts new cif, and sends status -----
{
    TCHAR   szLocalCab[MAX_PATH], szCabURL[MAX_PATH], szLocalDir[MAX_PATH];
    HWND    hDlg      = (HWND) lParam,
            hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    HRESULT hrCom;
    int     count     = 0;
    BOOL    fIgnore   = FALSE;

    CCifFile_t * lpUpdateFile = NULL;

    hrCom = CoInitialize(NULL);

    PathCombine(szLocalDir, g_szIEAKProg, TEXT("update\\"));
  
    TCHAR szMsg[MAX_PATH], szTitle[MAX_PATH];
    LoadString(g_rvInfo.hInst, IDS_NOUPDATETITLE, szTitle, countof(szTitle));
    LoadString(g_rvInfo.hInst, IDS_ERROR_UPDATEFOLDER, szMsg, countof(szMsg));

    if (!PathIsDirectory(szLocalDir))
        while ((!CreateDirectory(szLocalDir, NULL)) && (IDRETRY == MessageBox(hDlg, szMsg, szTitle, MB_ICONERROR | MB_RETRYCANCEL)));

    if ((0 == StrCmp(TEXT(""), g_szUpdateData)) || (0 == StrCmp(TEXT(""), g_szUpdateURL)))
        GetUpdateSite();
    
    ZeroMemory(szCabURL, sizeof(szCabURL));
    StrCpy(szCabURL, g_szUpdateURL);
    StrCat(szCabURL, TEXT("/IEUPDATE.CAB"));
    PathCombine(szLocalCab, szLocalDir, TEXT("IEUPDATE.CAB"));

    if (SUCCEEDED(DownloadCab(hDlg, szCabURL, szLocalCab, TEXT("IEUPDATE.CAB"), 0, fIgnore))) 
    {
        if (SUCCEEDED(ExtractFilesWrap(szLocalCab, szLocalDir, 0, NULL, NULL, 0)))
        {
            TCHAR szLocalCif[MAX_PATH];
            FCLV_PREADDLISTITEM pfnPreAddListItem = PreAddListItem;
    
            PathCombine(szLocalCif, szLocalDir, TEXT("ieupdate.cif"));

            count = FillComponentsListView(hCompList, szLocalCif, pfnPreAddListItem);
            if ((0 < count) && (9 > count))
                ListView_SetColumnWidth(hCompList, 1, 128);
            else
                ListView_SetColumnWidth(hCompList, 1, 113);
        }
        else
        {
            LoadString(g_rvInfo.hInst, IDS_ERROR_IEUPDATECIF, szMsg, countof(szMsg));
            MessageBox(hDlg, szMsg, szTitle, MB_ICONERROR);
        }
    }
    else
        DownloadErrMsg(hDlg, TEXT("IEUPDATE.CAB"), MAKEINTRESOURCE(IDD_DOWNLOADERR));
    
    if (SUCCEEDED(hrCom))
        CoUninitialize();
    return (0 < count) ? SHOW_UPDATES : DONT_SHOW_UPDATES;
}

INT_PTR CALLBACK FindUpdateDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(wParam);

    HWND* phDlg;

    switch (iMsg)
    {
        case WM_INITDIALOG:
            phDlg = (HWND*)lParam;
            if (NULL != phDlg) {
                ASSERT(NULL == *phDlg);
                *phDlg = hDlg;
            }
            break;

        default:
            return FALSE; 
    }

    return TRUE;
}

DWORD UpdateDlg_InitDialog(HWND hDlg, LPTSTR ps_szFreeSpace, LPTSTR ps_szTotalSize)
{
    HWND   hFindUpdateDlg;
    HANDLE hAVSThread;
    DWORD  dwResult, dwThread;
  
    hAVSThread = CreateThread(NULL, 4096, InitUpdateThreadProc, hDlg, 0, &dwThread);
    if (NULL == hAVSThread) {
        return 0;
    } 

    hFindUpdateDlg = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_FINDUPDATE), hDlg, FindUpdateDlgProc);
    ShowWindow(hFindUpdateDlg, SW_SHOWNORMAL);

    while (WAIT_OBJECT_0 != MsgWaitForMultipleObjects(1, &hAVSThread, FALSE, INFINITE, QS_ALLINPUT))
    {
        MSG msg;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    DestroyWindow(hFindUpdateDlg);

    GetExitCodeThread(hAVSThread, &dwResult);
    if (DONT_SHOW_UPDATES == dwResult) {
        TCHAR szMsg[MAX_PATH], szTitle[MAX_PATH];

        LoadString(g_rvInfo.hInst, IDS_AVSNOUPDATES, szMsg, countof(szMsg));
        LoadString(g_rvInfo.hInst, IDS_NOUPDATETITLE, szTitle, countof(szTitle));
        MessageBox(hDlg, szMsg, szTitle, MB_OK);

        EndDialog(hDlg, IDCANCEL);
    }
                           //--- Set initial Disk space displays -----
    InsertCommas(ps_szFreeSpace);
    SetDlgItemText(hDlg, IDC_DISKSPACE, ps_szFreeSpace);
    ShowDlgItem(hDlg, IDC_DISKSPACE);
    UpdateDlg_GetDownloadSize(GetDlgItem(hDlg, IDC_COMPLIST), GetDlgItem(hDlg, IDC_DISKSPACENEEDED), TRUE);
    GetDlgItemText(hDlg, IDC_DISKSPACENEEDED, ps_szTotalSize, MAX_PATH);
    ShowDlgItem(hDlg, IDC_DISKSPACENEEDED);
    ShowDlgItem(hDlg, IDC_DISKSPACETEXT);
    
    DisableDlgItem(hDlg, IDOK);            //---- Can't synchronize with nothing selected.

    return 0;
}

PCOMPONENT* UpdateDlg_GetDownloadList(HWND hDlg)
{
    HWND        hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    PCOMPONENT* rgpComp,
                pComp;
    UINT        cSelected,
                i, j;

    cSelected = ListView_GetSelectedCount(hCompList);
    if (0 == cSelected)
        return NULL;

    rgpComp = (PCOMPONENT*)LocalAlloc(LPTR, (1 + cSelected) * sizeof(PCOMPONENT));
    if (NULL == rgpComp)
        return NULL;
    ZeroMemory(rgpComp, (1 + cSelected) * sizeof(PCOMPONENT));

    for (i = j = 0; i < (UINT) ListView_GetItemCount(hCompList); i++)
    {
        LVITEM lvi;

        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask      = LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = LVIS_SELECTED;
        lvi.iItem     = i;
        ListView_GetItem(hCompList, &lvi);

        pComp = (PCOMPONENT)lvi.lParam;
        if (0 != (LVIS_SELECTED & lvi.state))
            rgpComp[j++] = pComp;

        else
            LocalFree(pComp);
    }
    ASSERT(j == cSelected);
    rgpComp[j] = NULL;

    return rgpComp;
}

void UpdateDlg_GetDownloadSize(HWND hCompList, HWND hStatusField, BOOL fAll)
{
    int        i;
    DWORD      dwSize = 0;
    TCHAR      szSize[32];
    PCOMPONENT pComp;

    for (i=0; i < ListView_GetItemCount(hCompList); i++)
    {
        LVITEM lvi;

        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask      = LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = LVIS_SELECTED;
        lvi.iItem     = i;
        ListView_GetItem(hCompList, &lvi);
        
        if ((!fAll) && ((lvi.state & LVIS_SELECTED) == 0))
            continue;

        pComp = (PCOMPONENT) lvi.lParam;
        dwSize += pComp->dwSize;
    }
    wnsprintf(szSize, countof(szSize), TEXT("%lu KB"), dwSize);
    InsertCommas(szSize);
    SetWindowText(hStatusField, szSize);
}

LRESULT CALLBACK HyperLinkWndProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR       szText[30];
    PAINTSTRUCT ps;
    HDC         hdc;
    LOGFONT     lfNew, lf;
    HFONT       hfCurrent, hfLink;
    int         len;

    switch (iMsg)
    {
        case WM_PAINT:
            ZeroMemory(szText, sizeof(szText));
            GetWindowText(hDlg, szText, sizeof(szText));
            hdc = BeginPaint(hDlg, &ps);
 
            hfCurrent = (HFONT) GetCurrentObject(hdc, OBJ_FONT);    
            ASSERT(hfCurrent != NULL);    
    
            len = GetObject(hfCurrent, sizeof(lf), &lf);    
            ASSERT(len == sizeof(lf));        
        
            ZeroMemory(&lfNew, sizeof(lfNew));        
            lfNew.lfHeight    = (LONG) 13;
            lfNew.lfUnderline = TRUE;    
            lfNew.lfWeight    = FW_NORMAL;
            StrCpy(lfNew.lfFaceName, TEXT("Tahoma"));
            hfLink = CreateFontIndirect(&lfNew);

            SelectObject(hdc, hfLink);
            SetBkColor(hdc, GetSysColor(COLOR_MENU));
            SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHT));

            TextOut(hdc, 0, 0, szText, StrLen(szText));
            
            DeleteObject(SelectObject(hdc, GetStockObject(OBJ_FONT)));
            DeleteDC(hdc);
            EndPaint(hDlg, &ps); 
            return 0;
        case WM_KEYUP:
            if (wParam != VK_SPACE)
                break;
        case WM_LBUTTONUP:
            SendMessage(GetParent(hDlg), WM_COMMAND, GetWindowLong(hDlg, GWL_ID), (LPARAM) hDlg);
            return 0;
    }
    return DefWindowProc(hDlg, iMsg, wParam, lParam);
}

INT_PTR CALLBACK UpdateDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static   PCOMPONENT** s_ppCompList; /*= NULL*/
    HWND     hCompList;
    static   TCHAR s_szFreeSpace[MAX_PATH];
    static   TCHAR s_szTotalSize[MAX_PATH];
    static   HFONT hfLink;
    
    switch (iMsg)
    {
        case WM_INITDIALOG:
            wnsprintf(s_szFreeSpace, countof(s_szFreeSpace), TEXT("%lu KB"), GetRootFree(g_szIEAKProg));
            UpdateDlg_InitDialog(hDlg, s_szFreeSpace, s_szTotalSize);
            s_ppCompList = (PCOMPONENT**)lParam;                    //--- Keep pointer to download list
            ASSERT(NULL != s_ppCompList);
            break;

        case IDM_INITIALIZE:
            break;

        case WM_COMMAND:
            if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
                return FALSE;

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    *s_ppCompList = UpdateDlg_GetDownloadList(hDlg); //--- Set download list
                case IDCANCEL:
                    EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;
                case IDHELP:
                    ListView_SetItemState(GetDlgItem(hDlg, IDC_COMPLIST), -1, 0, LVIS_SELECTED);
                    IeakPageHelp(hDlg, MAKEINTRESOURCE(IDD_OPTUPDATE));
                    break;
                case IDC_DOWNLOADALL:
                    hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
                    SetFocus(hCompList);
                    ListView_SetItemState(hCompList, -1, LVIS_SELECTED, LVIS_SELECTED);
                    break;
 //-----------------     IEAK Site here Take out link for now since it doesn't work with build lab------------
 //-----------------     also need to uncomment CreateIEAKUrl in ie4comp.cpp and the comments     ------------
 //-----------------     for the control in ieakui\wizard.rc (IDD_OPTUPDATE) to activate          ------------
 //               case IDC_DIALOGLINK:
 //                   ShellExecute(hDlg, TEXT("open"), TEXT("http://www.microsoft.com/isapi/Redir.dll?prd=ieak&ar=ieak"), 
 //                       NULL, NULL, SW_SHOWNORMAL); 
                    break;
                default:
                    return FALSE;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {
              case LVN_ITEMCHANGED:
                hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
                if (0 < ListView_GetSelectedCount(hCompList))
                {
                    HideDlgItem(hDlg, IDC_DISKSPACETEXT);
                    UpdateDlg_GetDownloadSize(hCompList, GetDlgItem(hDlg, IDC_DISKSPACENEEDED), FALSE);
                    ShowDlgItem(hDlg, IDC_DISKSPACETEXT2);
                    EnableDlgItem(hDlg, IDOK);
                }
                else
                {
                    ShowDlgItem(hDlg, IDC_DISKSPACETEXT);
                    HideDlgItem(hDlg, IDC_DISKSPACETEXT2);
                    SetDlgItemText(hDlg, IDC_DISKSPACENEEDED, s_szTotalSize);
                    DisableDlgItem(hDlg, IDOK);
                }
                break;
           
            default:
                return FALSE;
            }
            break; 

        case WM_HELP:
            ListView_SetItemState(GetDlgItem(hDlg, IDC_COMPLIST), -1, 0, LVIS_SELECTED);
            IeakPageHelp(hDlg, MAKEINTRESOURCE(IDD_OPTUPDATE));
            break;

        default:
            return FALSE; 
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

#ifndef ISNULL
#define ISNULL(psz)    (*(psz) == TEXT('\0'))
#endif

#ifndef ISNONNULL
#define ISNONNULL(psz) (*(psz) != TEXT('\0'))
#endif

DWORD   FolderSize(LPCTSTR pszFolderName);
HRESULT CopyFilesSrcToDest(LPCTSTR pszSrcPath, LPCTSTR pszSrcFilter, LPCTSTR pszDestPath,
                           DWORD dwTicks = 0);

void  TooBig(HWND hWnd, WORD id);
void SetWindowTextSmart(HWND hwnd, LPCTSTR pcszText);

DWORD ShellExecAndWait(SHELLEXECUTEINFO shInfo);

LPTSTR StrTok(LPTSTR pcszToken, LPCTSTR pcszDelimit);

void LVGetItems(HWND hwndLV);

LPTSTR GetOutputPlatformDir();

int GetRole(BOOL g_fBranded, BOOL g_fIntranet);

BOOL IsIconsInFavs(LPCTSTR pcszSection, LPCTSTR pcszCustIns);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\wizard.h ===
#ifndef _WIZARD_H_
#define _WIZARD_H_

#pragma warning (disable:4189) // disable local var init'd but not ref'd warning since all
                               // occurences in the wizard have been removed.  Should be
                               // moved to warning.h in ..\inc when other modules have been
                               // fixed

// constants
#define MAX_BUF          5000
#define MAX_LINE          512
#define MAX_URL          2048
#define MAX_BUFFER_SIZE 32767
#define MAX_COPY_SIZE   32767

typedef enum tagPPAGE {
    PPAGE_WELCOME    = 0,
    PPAGE_OCWWELCOME = 0,

    PPAGE_STAGE1,
    PPAGE_TARGET,
    PPAGE_LANGUAGE,
    PPAGE_MEDIA,
    PPAGE_IEAKLITE,

    PPAGE_STAGE2,
    PPAGE_OPTDOWNLOAD,
    PPAGE_CUSTCOMP,

    PPAGE_STAGE3,
    PPAGE_ISKBACK,
    PPAGE_CDINFO,
    PPAGE_SETUPWIZARD,
    PPAGE_SILENTINSTALL,
    PPAGE_COMPSEL,
    PPAGE_COMPURLS,
    PPAGE_ADDON,
    PPAGE_INSTALLDIR,
    PPAGE_CORPCUSTOM,
    PPAGE_CUSTOMCUSTOM,
    PPAGE_COPYCOMP,
    PPAGE_ICM,
    PPAGE_CABSIGN,

    PPAGE_STAGE4,
    PPAGE_OCWSTAGE2,
    PPAGE_TITLE,
    PPAGE_BTOOLBARS,
    PPAGE_CUSTICON,
    PPAGE_STARTSEARCH,
    PPAGE_FAVORITES,
    PPAGE_WELCOMEMSGS,
    PPAGE_DESKTOP,
    PPAGE_DTOOLBARS,
    PPAGE_FOLDERMCCP,
    PPAGE_UASTRDLG,
    PPAGE_CONNECTSET,
    PPAGE_QUERYAUTOCONFIG,
    PPAGE_PROXY,
    PPAGE_ADDROOT,
    PPAGE_SECURITYCERT,
    PPAGE_SECURITY,

    PPAGE_QUERYSIGNUP,
    PPAGE_SIGNUPFILES,
    PPAGE_SERVERISPS,
    PPAGE_ISPINS,
    PPAGE_ICW,

    PPAGE_STAGE5,
    PPAGE_PROGRAMS,
    PPAGE_MAIL,
    PPAGE_IMAP,
    PPAGE_OE,
    PPAGE_PRECONFIG,
    PPAGE_OEVIEW,
    PPAGE_SIG,
    PPAGE_LDAP,
    PPAGE_ADMDESC,
    PPAGE_ADM,
    PPAGE_STATUS,
    PPAGE_FINISH
};

#define NUM_PAGES   PPAGE_FINISH + 1

// typedefs
typedef struct tagREVIEWINFO
{
    HINSTANCE hInst;                            // instance handel of the resource dll
    HINSTANCE hinstExe;                         // instance handle of this executable

    TCHAR pszName[MAX_PATH];
} REVIEWINFO;

// Function prototypes

// procs
LRESULT APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);

// Pages for Wizard
INT_PTR CALLBACK OptionalDownload(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DownloadStatusDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CustomComponents(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CertificatePick(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ComponentSelect(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CorpCustomizeCustom(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CustomizeCustom(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CopyComp(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ComponentUrls(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CabSignDlgProc(HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK CustIcon(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK Favorites(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK QueryAutoConfigDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ProxySettings(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ConnectSetDlgProc(HWND, UINT, WPARAM, LPARAM);

INT_PTR CALLBACK QuerySignupDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SignupFilesDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ServerIspsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SignupInsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK NewICWDlgProc(HWND, UINT, WPARAM, LPARAM);

INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK MailServer(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK IMAPSettings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LDAPServer(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CustomizeOE(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK Signature(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ViewSettings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PreConfigSettings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK WelcomeMessageDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK InstallDirectory(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CustUserSettings(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SecurityZonesDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SecurityCertsDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ISPAddRootCertDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ActiveSetupDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK BToolbarProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DesktopAddOneComp(HWND,UINT, WPARAM, LPARAM);
INT_PTR CALLBACK UserAgentString(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ADMDesc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ADMParse(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK InternetConnMgr(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CustomCompName(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AddOnDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SilentInstall(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AddEditChannel(HWND, UINT, WPARAM, LPARAM);
DWORD DownloadSiteThreadProc(LPVOID);
INT_PTR CALLBACK MediaDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK TargetProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK IEAKLiteProc(HWND, UINT, WPARAM, LPARAM);


//functions
BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE);
int  CreateWizard(HWND);
void FillInPropertyPage( int , int, LPTSTR, DLGPROC);
void GenerateReview(HWND);
void StatusDialog(UINT);

void DoBatchAdvance(HWND hDlg);
BOOL IeakPageHelp(HWND, LPCTSTR pszData);
void EnablePages();
BOOL PageEnabled(int iPage);
void PagePrev(HWND hDlg);
void PageNext(HWND hDlg);
void DoCancel();
BOOL QueryCancel(HWND hDlg);
void CheckBatchAdvance(HWND hDlg);

BOOL ADMEnablePage(); // admwizpg.cpp
void SetBannerText(HWND hDlg);
void ChangeBannerText(HWND hDlg);

// definitions for StatusDialog( )
#define SD_STEP1    1
#define SD_STEP2    2

typedef struct tagISKINFO
{
    TCHAR szISKBackBitmap[MAX_PATH];
    TCHAR szISKTitleBar[128];
    TCHAR szISKBtnBitmap[MAX_PATH];
    DWORD dwNormalColor;
    DWORD dwHighlightColor;
    DWORD dwNIndex;
    DWORD dwHIndex;
    BOOL fCoolButtons;
} ISKINFO;

INT_PTR CALLBACK ISKBackBitmap(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CDInfoProc(HWND, UINT, WPARAM, LPARAM);


#define SIGTYPE_TEXT 1
#define SIGTYPE_FILE 2


#define SIGFLAG_OUTGOING 0x10000
#define SIGFLAG_REPLY 0x20000


// Automation HookIn
#define WM_LV_GETITEMS  WM_USER+21

#define IDM_WIZARD         WM_USER + 3000
#define IDM_LAST           WM_USER + 3001
#define IDM_EXIT           WM_USER + 3002
#define IDM_INITIALIZE     WM_USER + 3003
#define IDM_BATCHADVANCE   WM_USER + 3004
#define IDM_SETDEFBUTTON   WM_USER + 3005
#define IDM_ERROR          WM_USER + 3006

#define NUMLANG 100

#define DOWN_STATE_IDLE 0
#define DOWN_STATE_ENUM_LANG 1
#define DOWN_STATE_ENUM_URL 2
#define DOWN_STATE_SAVE_URL 3

#define KEY_TYPE_STANDARD 0                // old MS mode still used for current MS builds
#define KEY_TYPE_ENHANCED 1                // old code now unused
#define KEY_TYPE_SUPER    2                // isp
#define KEY_TYPE_CORP     3                // old code now unused
#define KEY_TYPE_SUPERCORP 4               // corp

#define MAX_INSTALL_OPTS 10

typedef struct patch_info
{
    DWORD dwSize;
    TCHAR szVersion[32];
    TCHAR szSection[32];
} PATCHINFO, *PPATCHINFO;

typedef struct tag_component
{
    int iList;
    DWORD dwSize;
    int iType;
    int iImage;
    int iPlatform;
    int iCompType;
    int iInstallType;         // 0=after IE, 1=before IE, 2=after reboot
    BOOL fVisible;
    BOOL fAddOnOnly;
    BOOL fCustomHide;
    BOOL fNoCopy;
    BOOL fAVSDupe;
    BOOL fIEDependency;
    PATCHINFO piPatchInfo;
    BOOL afInstall[MAX_INSTALL_OPTS];
    TCHAR szDisplayName[80];
    TCHAR szSection[32];
    LPTSTR pszAVSDupeSections;
    TCHAR szCommand[32];
    TCHAR szUrl[80];
    TCHAR szGUID[64];
    TCHAR szSwitches[80];
    TCHAR szUninstall[80];
    TCHAR szVersion[32];
    TCHAR szModes[80];
    TCHAR szPath[MAX_PATH];
    TCHAR szDesc[512];
    tag_component * paCompRevDeps[10];
} COMPONENT, *PCOMPONENT;

extern REVIEWINFO g_rvInfo;
extern DWORD      g_dwPlatformId;
extern BOOL       g_fUseShortFileName;
extern HWND       g_hWizard;

extern CCifRWFile_t *g_lpCifRWFile;
extern CCifFile_t   *g_lpCifFileNew;
extern CCifRWFile_t *g_lpCifRWFileDest;
extern CCifRWFile_t *g_lpCifRWFileVer;

// ProcessINSFiles flags
#define PINSF_DEFAULT   0x00
#define PINSF_DELETE    0x01
#define PINSF_COPY      0x02
#define PINSF_APPLY     0x04
#define PINSF_COPYCAB   0x08
#define PINSF_FIXINS    0x10
#define PINSF_NOCLEAR   0x20

DWORD ProcessINSFiles(LPCTSTR pcszDir, DWORD dwFlags, LPCTSTR pcszOutDir);
#define GetNumberOfINSFiles(d)          (ProcessINSFiles((d), PINSF_DEFAULT, NULL))
#define DeleteINSFiles(d)               (ProcessINSFiles((d), PINSF_DELETE,  NULL))
#define CopyINSFiles(d, o)              (ProcessINSFiles((d), PINSF_COPY,    (o)))
#define ApplyINSFiles(d, i)             (ProcessINSFiles((d), PINSF_APPLY,   (i)))
#define CopyCabFiles(d, c)              (ProcessINSFiles((d), PINSF_COPYCAB, (c)))
#define FixINSFiles(d)                  (ProcessINSFiles((d), PINSF_FIXINS,  NULL))
#define WriteNoClearToINSFiles(d)       (ProcessINSFiles((d), PINSF_NOCLEAR, NULL))


// ADM constants
#define IS_ADM      TEXT("ADM")
#define IK_ADMIN    TEXT("Admin")

#define POSTCUSTITEMS   TEXT("PostCustItems")
#define URDCOMP         TEXT("URD")
#define IE55URD_EXE     TEXT("ie55urd.exe")
#define URD_GUID_STR    TEXT("{71F159B0-139A-4555-BE78-D728734BB5D4}")
#define IK_URD_STR      URD_GUID_STR

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\utils.cpp ===
#include "precomp.h"
#include "utils.h"

#define MAX_FILES 700

extern void UpdateProgress(int);

DWORD FolderSize(LPCTSTR pszFolderName)
{
    DWORD dwSize = 0;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;
    TCHAR szFile[MAX_PATH];

    if (pszFolderName == NULL  ||  ISNULL(pszFolderName))
        return dwSize;

    PathCombine(szFile, pszFolderName, TEXT("*"));

    if ((hFindFile = FindFirstFile(szFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                dwSize += fileData.nFileSizeLow;
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }

    return dwSize;
}

HRESULT MySHFileOperation(SHFILEOPSTRUCT &shfStruc, LPDWORD lpdwSizeArray,
                          DWORD dwTotalSize, DWORD dwTicks)
{
    LPCTSTR pFrom;
    LPTSTR pTo;
    TCHAR szTo[MAX_PATH];
    DWORD dwBytesCopied = 0;
    DWORD dwTickInterval = 0;
    DWORD dwIndex = 0;
    int i;

    // create the directory(we assume all files are being copied to the same dir here)

    PathCreatePath(shfStruc.pTo);

    if (dwTicks)
    {
        dwIndex = 1;

        // round up on the update interval

        dwTickInterval = dwTotalSize / dwTicks +
            ((dwTotalSize % dwTicks == 0) ? 0 : 1);
    }

    StrCpy(szTo, shfStruc.pTo);
    PathAddBackslash(szTo);
    pTo = szTo + StrLen(szTo);
    for (pFrom = shfStruc.pFrom, i = 0; *pFrom; pFrom += StrLen(pFrom) + 1, i++)
    {
        StrCpy(pTo, PathFindFileName(pFrom));
        // set the file_normal attribute so we can overwrite existing files
        SetFileAttributes(szTo, FILE_ATTRIBUTE_NORMAL);

        if (!CopyFile(pFrom, szTo, FALSE))
            return E_FAIL;
        if (dwTicks)
        {
            dwBytesCopied += lpdwSizeArray[i];
            if (dwBytesCopied > (dwTickInterval * dwIndex))
            {
                dwIndex++;
                UpdateProgress(1);
            }
        }
    }

    if (dwTicks)
        UpdateProgress(1);
    return S_OK;
}

HRESULT CopyFilesSrcToDest(LPCTSTR pszSrcPath, LPCTSTR pszSrcFilter, LPCTSTR pszDestPath,
                           DWORD dwTicks /* = 0 */)
{
    HANDLE hFind;
    WIN32_FIND_DATA wfdFind;
    TCHAR szSrcFile[MAX_PATH];
    DWORD dwTotalSize = 0;
    LPTSTR lpszFrom;
    LPDWORD lpdwSize = NULL;
    int nFrom = 0;
    int nFiles = 0;
    HRESULT res = S_OK;
    SHFILEOPSTRUCT shfStruc;

    if(ISNULL(pszSrcPath))
        return S_OK;

    lpszFrom = (LPTSTR) LocalAlloc(LPTR, MAX_BUFFER_SIZE*sizeof(TCHAR));
    if (!lpszFrom)
        return E_FAIL;

    if (dwTicks)
    {
        lpdwSize = (LPDWORD) LocalAlloc(LPTR, MAX_FILES * sizeof(DWORD));
        if (!lpdwSize)
        {
            LocalFree(lpszFrom);
            return E_FAIL;
        }
    }

    ZeroMemory(&shfStruc, sizeof(shfStruc));
    shfStruc.hwnd = g_hWizard;
    shfStruc.wFunc = FO_COPY;

    // remove the trailing backslash character
    TCHAR szBuffer[MAX_PATH];

    StrCpy(szBuffer, pszSrcPath);
    PathRemoveBackslash(szBuffer);
    pszSrcPath = szBuffer;

    PathCombine(szSrcFile, pszSrcPath, pszSrcFilter);
    hFind = FindFirstFile(szSrcFile, &wfdFind);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(wfdFind.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                && StrCmp(wfdFind.cFileName, TEXT("."))
                && StrCmp(wfdFind.cFileName, TEXT("..")))
            {
                PathCombine(szSrcFile, pszSrcPath, wfdFind.cFileName);
                if (((nFrom + lstrlen(szSrcFile) + 1) < MAX_BUFFER_SIZE) &&
                    ((!dwTicks) || (nFiles < MAX_FILES)))
                {
                    StrCpy(lpszFrom + nFrom, szSrcFile);
                    nFrom += lstrlen(szSrcFile) + 1;
                    if (dwTicks)
                    {
                        dwTotalSize += (lpdwSize[nFiles] = wfdFind.nFileSizeLow);
                        nFiles++;
                    }
                }
                else
                {
                    shfStruc.pFrom = lpszFrom;
                    shfStruc.pTo = pszDestPath;
                    shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

                    res |= MySHFileOperation(shfStruc, lpdwSize, dwTotalSize, dwTicks);

                    ZeroMemory(lpszFrom, MAX_BUFFER_SIZE);
                    nFrom = 0;
                    dwTicks = 0;

                    StrCpy(lpszFrom + nFrom, szSrcFile);
                    nFrom += lstrlen(szSrcFile) + 1;
                }
            }
        }while (FindNextFile( hFind, &wfdFind));
        FindClose(hFind);

        if(ISNONNULL(lpszFrom))
        {
            shfStruc.pFrom = lpszFrom;
            shfStruc.pTo = pszDestPath;
            shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            res |= MySHFileOperation(shfStruc, lpdwSize, dwTotalSize, dwTicks);
        }
    }
    LocalFree(lpszFrom);
    if (dwTicks) LocalFree(lpdwSize);
    return res;
}

void TooBig(HWND hWnd, WORD id)
{
    TCHAR szTitle[MAX_PATH], szMsg[MAX_PATH];

    LoadString(g_rvInfo.hInst, IDS_TITLE, szTitle, countof(szTitle));
    LoadString(g_rvInfo.hInst, id, szMsg, countof(szMsg));

    MessageBox(hWnd, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
    SetWindowLongPtr(hWnd, DWLP_MSGRESULT, -1);
}

void SetWindowTextSmart(HWND hwnd, LPCTSTR pcszText)
{
    TCHAR szCurrentText[INTERNET_MAX_URL_LENGTH];

    if (GetWindowText(hwnd, szCurrentText, countof(szCurrentText)))
    {
        if (StrCmpI(pcszText, szCurrentText) == 0)
            return;
    }

    SetWindowText(hwnd, pcszText);
}

DWORD ShellExecAndWait(SHELLEXECUTEINFO shInfo)
{
    MSG msg;
    DWORD dwRet;

    if (!ShellExecuteEx(&shInfo))
        return (DWORD)E_FAIL;

    while (MsgWaitForMultipleObjects(1, &shInfo.hProcess, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    GetExitCodeProcess(shInfo.hProcess, &dwRet);
    CloseHandle(shInfo.hProcess);
    return dwRet;
}

// equivalent of c run time strtok

LPTSTR StrTok(LPTSTR pcszToken, LPCTSTR pcszDelimit)
{
    LPTSTR pszRet, pszCur;
    int i;

    pszCur = pcszToken;

    while (*pszCur)
    {
        i = 0;
        while(pcszDelimit[i])
        {
            if (*pszCur == pcszDelimit[i])
                break;
            i++;
        }
        if (!pcszDelimit[i])
            break;
        pszCur++;
    }

    pszRet = ((*pszCur) ? pszCur : NULL);

    if (pszRet != NULL)
    {
        while (*pszCur)
        {
            i = 0;
            while(pcszDelimit[i])
            {
                if (*pszCur == pcszDelimit[i])
                    break;
                i++;
            }
            if (pcszDelimit[i])
                break;
            pszCur++;
        }

        if(*pszCur)
            *pszCur = TEXT('\0');
    }

    return pszRet;
}

//**********************************************************************
// Automation HookIn : This function copies displayed item names from the
// LV into the Registry key "HKEY_LOCAL_MACHINE\Soft\MS\AutoTemp".
// Taken from setupwbv.cpp
//
//**********************************************************************

void LVGetItems(HWND hwndLV)
{
    LV_ITEM     lvi;
    DWORD       dwNumItems, dwIndex;
    HKEY        hKey;
    DWORD       dwDisp;
    TCHAR       szValueName[5];
    TCHAR       szDisplayName[MAX_PATH];
    BOOL        bOK = TRUE;
    LONG        lRet;

    dwNumItems = ListView_GetItemCount(hwndLV);

    // Create the new key. NOTE: Its volatile.
    lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AutoTemp"), 0,
                          NULL, REG_OPTION_VOLATILE, KEY_READ|KEY_WRITE,
                          NULL, &hKey, &dwDisp);
    bOK = (lRet == ERROR_SUCCESS);
    if (bOK)
    {
        // If the key already existed, delete it so that old
        // data does not carry-over by mistake.
        if ( dwDisp == REG_OPENED_EXISTING_KEY )
        {
            RegCloseKey(hKey);
            RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AutoTemp"));
            lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AutoTemp"), 0,
                                  NULL, REG_OPTION_VOLATILE, KEY_READ|KEY_WRITE,
                                  NULL, &hKey, &dwDisp);
            bOK = (lRet == ERROR_SUCCESS);
        }

        if (bOK)
        {
            for (dwIndex=0; dwIndex < dwNumItems && bOK; dwIndex++)
            {
                lvi.mask = LVIF_TEXT;
                lvi.iItem = (int) dwIndex;
                lvi.iSubItem = 0;
                ZeroMemory(szDisplayName, sizeof(szDisplayName));
                lvi.pszText = szDisplayName;
                lvi.cchTextMax = countof(szDisplayName);
                ListView_GetItem(hwndLV, &lvi);

                // Write the Display name to the Registry.
                wnsprintf(szValueName, countof(szValueName), TEXT("%03d"), dwIndex);
                lRet = RegSetValueEx(hKey, szValueName, 0, REG_SZ,
                              (const BYTE *)szDisplayName, (lstrlen(szDisplayName)+1)*sizeof(TCHAR));

                bOK = (lRet == ERROR_SUCCESS);
            }

            // Write the number of values for the automation people to readout.
            RegSetValueEx(hKey, TEXT("Number"), 0, REG_DWORD,
                          (const BYTE *)&dwIndex, sizeof(dwIndex));

            // Close the Reg key.
            RegCloseKey(hKey);
        }
    }
}

LPTSTR GetOutputPlatformDir()
{
    static TCHAR s_szOutPlatform[MAX_PATH];

    if (ISNULL(s_szOutPlatform))
    {
        switch (g_dwPlatformId)
        {
        case PLATFORM_WIN32:
        default:
            StrCpy(s_szOutPlatform, TEXT("WIN32\\"));
            break;
        }
    }

    ASSERT(ISNONNULL(s_szOutPlatform));
    return s_szOutPlatform;
}

int GetRole(BOOL g_fBranded, BOOL g_fIntranet)
{
    int nRetVal = -1;

    if (g_fBranded == FALSE && g_fIntranet == FALSE)
        nRetVal = ROLE_ICP;
    else if (g_fBranded == TRUE && g_fIntranet == FALSE)
        nRetVal = ROLE_ISP;
    else if (g_fBranded == TRUE && g_fIntranet == TRUE)
        nRetVal = ROLE_CORP;
    else
        ASSERT(FALSE);

    return nRetVal;
}

// Loop thru Favorites/Links under the section FavoritesEx/URL and check if it has any associated icon file.
BOOL IsIconsInFavs(LPCTSTR pcszSection, LPCTSTR pcszCustIns)
{
    TCHAR szTemp[MAX_PATH];
    TCHAR szNameKey[MAX_PATH];
    TCHAR szIconKey[MAX_PATH];
    TCHAR szNameFormat[MAX_PATH];
    TCHAR szIconFormat[MAX_PATH];

    if (StrCmpI(pcszSection, IS_FAVORITESEX) == 0)
    {
        StrCpy(szNameFormat, IK_TITLE_FMT);
        StrCpy(szIconFormat, IK_ICON_FMT);
    }
    else // IS_URL
    {
        StrCpy(szNameFormat, IK_QUICKLINK_NAME);
        StrCpy(szIconFormat, IK_QUICKLINK_ICON);
    }

    for(int nCount = 1; ; nCount++)
    {
        wnsprintf(szNameKey, countof(szNameKey), szNameFormat, nCount);
        wnsprintf(szIconKey, countof(szIconKey), szIconFormat, nCount);
        
        if (GetPrivateProfileString(pcszSection, szNameKey, TEXT(""), szTemp, countof(szTemp), pcszCustIns) != 0)
        {
            if (GetPrivateProfileString(pcszSection, szIconKey, TEXT(""), szTemp, countof(szTemp), pcszCustIns) != 0)
                return TRUE;
        }
        else
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieak5\wizard\wizard.cpp ===
#include "precomp.h"
#include <htmlhelp.h>                           // for html help calls
#include <regstr.h>
#include "wizard.rcv"                           // for VER_PRODUCTVERSION_STR only
#include "adjustui.h"
#include "ieaklite.h"
#include "ie4comp.h"

CCabMappings g_cmCabMappings;
REVIEWINFO g_rvInfo;      // a structure containing the review information
HWND g_hWizard;
TCHAR g_szCustIns[MAX_PATH] = TEXT("");
TCHAR g_szSrcRoot[MAX_PATH] = TEXT(""); //Batch mode only: use settings in g_szSrcRoot to build package in g_szBuildRoot.
TCHAR g_szBuildRoot[MAX_PATH] = TEXT("");
TCHAR g_szBuildTemp[MAX_PATH] = TEXT("");
TCHAR g_szWizPath[MAX_PATH];
TCHAR g_szWizRoot[MAX_PATH];
TCHAR g_szTitle[MAX_PATH];
TCHAR g_szLogFile[MAX_PATH] = TEXT("");
HANDLE g_hLogFile = NULL;   //Logfile handle;

extern TCHAR g_szDefInf[];
extern TCHAR g_szTempSign[];
BOOL g_fDownload = TRUE;
BOOL g_fCD = FALSE;
BOOL g_fLAN = FALSE;
BOOL g_fBrandingOnly = FALSE;
BOOL g_fBranded = FALSE;
BOOL g_fIntranet = FALSE;
BOOL g_fMailNews95 = FALSE;
BOOL g_fLangInit = FALSE;
BOOL g_fSrcDirChanged = TRUE;
static BOOL s_fDestDirChanged = TRUE;
BOOL g_fDisableIMAPPage = FALSE;
extern TCHAR g_szDeskTemp[];
extern int g_iInstallOpt;
extern TCHAR g_szInstallFolder[];
extern TCHAR   s_szBannerText[MAX_PATH];

HANDLE g_hThread = NULL;   // handle to DownloadSiteThreadProc
extern HANDLE g_hAVSThread;
extern BOOL g_fOptCompInit;
BOOL g_fCancelled = FALSE;
BOOL g_fDone = FALSE;
BOOL g_fKeyGood = FALSE;

static BOOL s_fNT5;

int g_iKeyType = KEY_TYPE_STANDARD;
TCHAR g_szKey[16] ;

extern int MakeKey(TCHAR *, int);
PROPSHEETPAGE g_psp[NUM_PAGES];
static HPROPSHEETPAGE s_ahPsp[NUM_PAGES];
static BOOL s_fPageEnabled[NUM_PAGES] =
{
    TRUE, TRUE, TRUE, TRUE
};
int g_iCurPage;

RECT g_dtRect;

TCHAR g_szLanguage[16];
extern TCHAR g_szActLang[];

TCHAR g_aszLang[NUMLANG][16];
DWORD g_aLangId[NUMLANG];

BOOL g_fDemo = FALSE;

#define MAX_STDOPT 5
#define MIN_CUSTOPT 6
#define MAX_CUSTOPT 7
#define OPT_CUST1 6
#define OPT_CUST2 7

extern BOOL  CheckKey(LPTSTR szKey);
static HKEY s_hkIEAKUser;

BOOL g_fUseIEWelcomePage = FALSE;
static TCHAR s_szSourceDir[MAX_PATH] = TEXT("");
TCHAR g_szLoadedIns[MAX_PATH] = TEXT("");
static BOOL s_fLoadIns;

static BOOL s_fAppendLang;
BOOL g_fBatch = FALSE;
BOOL g_fBatch2 = FALSE; //The second batch mode
static TCHAR s_szType[16];
int s_iType;

extern BOOL g_fServerICW;
extern BOOL g_fServerKiosk;
extern BOOL g_fServerless;
extern BOOL g_fNoSignup;
extern BOOL g_fSkipServerIsps;
extern BOOL g_fSkipIspIns;

extern HANDLE g_hDownloadEvent;
int g_iDownloadState = 0, g_nLangs = 0;
HWND g_hDlg = 0;

extern void IE4BatchSetup(void);
extern BOOL InitList(HWND hwnd, UINT id);

extern BOOL g_fSilent, g_fStealth;
extern BOOL g_fUrlsInit;
extern BOOL g_fLocalMode;
extern BOOL g_fInteg, g_fImportConnect;
extern PCOMPONENT g_paComp;
extern UINT g_uiNumCabs;
extern PCOMP_VERSION g_rgCompVer;
extern HFONT g_hFont;

DWORD g_dwPlatformId = PLATFORM_WIN32;

// new cif format stuff

CCifFile_t   *g_lpCifFileNew = NULL;
CCifRWFile_t *g_lpCifRWFile = NULL;
CCifRWFile_t *g_lpCifRWFileDest = NULL;
CCifRWFile_t *g_lpCifRWFileVer = NULL;

// g_hBaseDllHandle is used by DelayLoadFailureHook() -- defined in ieakutil.lib
// for more info, read the Notes section in ieak5\ieakutil\dload.cpp
HANDLE  g_hBaseDllHandle;

//OCW specific
BOOL g_fOCW = FALSE;
BOOL g_fOCWCancel = FALSE;
TCHAR g_szParentWindowName[MAX_PATH];

BOOL ParseCmdLine(LPSTR lpCmdLine);
void PositionWindow(HWND hWnd);
//
extern TCHAR g_szIEAKProg[MAX_PATH];
void GetIEAKDir(LPTSTR szDir);

extern HBITMAP g_hBannerBmp;
extern HWND g_hWait;
extern LPTSTR GetOutputPlatformDir();
void GenerateCustomIns();

extern void WriteMSTrustKey(BOOL bSet);
DWORD g_wCurLang;

static HWND s_hWndHelp = NULL;

void CleanUp()
{
    if (g_hAVSThread != NULL)
    {
        while ((MsgWaitForMultipleObjects(1, &g_hAVSThread, FALSE, INFINITE, QS_ALLINPUT)) != WAIT_OBJECT_0)
        {
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(g_hAVSThread);
    }

    if (g_hThread != NULL)
    {
        while ((MsgWaitForMultipleObjects(1, &g_hThread, FALSE, INFINITE, QS_ALLINPUT)) != WAIT_OBJECT_0)
        {
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(g_hThread);
    }

    if (g_paComp != NULL)
    {
        for (PCOMPONENT pComp = g_paComp; ISNONNULL(pComp->szSection); pComp++)
        {
            if (pComp->pszAVSDupeSections != NULL)
                CoTaskMemFree(pComp->pszAVSDupeSections);
        }
        LocalFree(g_paComp);
    }

    if (g_rgCompVer)
    {
        LocalFree(g_rgCompVer);
    } 

    if (g_hFont != NULL) DeleteObject(g_hFont);

    if (g_lpCifRWFile != NULL)
    {
        delete g_lpCifRWFile;
        g_lpCifRWFile = NULL;
    }

    if (g_lpCifFileNew != NULL)
    {
        delete g_lpCifFileNew;
        g_lpCifFileNew = NULL;
    }

    if (g_lpCifRWFileDest != NULL)
    {
        delete g_lpCifRWFileDest;
        g_lpCifRWFileDest = NULL;
    }

    if (g_lpCifRWFileVer != NULL)
    {
        delete g_lpCifRWFileVer;
        g_lpCifRWFileVer = NULL;
    }

    if (g_hBannerBmp != NULL)
        DeleteObject(g_hBannerBmp);

    if (ISNONNULL(g_szDeskTemp))
        PathRemovePath(g_szDeskTemp);
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR lpCmdLine, int)
{
    MSG     msg;
    HANDLE  hMutex;
    HRESULT hrOle;
    int     iRetVal;
    
    // initialize g_hBaseDllHandle which is used by DelayLoadFailureHook()
    // in ieak5\ieakutil\dload.cpp
    g_hBaseDllHandle = hInstance;

    hMutex = NULL;
    // allow only one instance running at a time, except for build lab batch mode
    // also if ie6 is not installed, bail out

    if (lpCmdLine  == NULL                  ||
        *lpCmdLine == '\0'                  ||
        StrCmpNIA(lpCmdLine, "/o", 2) == 0  ||
        StrCmpNIA(lpCmdLine, "/p", 2) == 0)
    {
        DWORD dwIEVer;

        hMutex = CreateMutex(NULL, TRUE, TEXT("IEAK6Wizard.Mutex"));
        if (hMutex != NULL  &&  GetLastError() == ERROR_ALREADY_EXISTS)
        {
            CloseHandle(hMutex);
            ErrorMessageBox(NULL, IDS_ERROR_MULTWIZ);
            return ERROR_CANCELLED;
        }

        dwIEVer = GetIEVersion();
        if (HIWORD(dwIEVer) < 6)
        {
            ErrorMessageBox(NULL, IDS_NOIE);
            return ERROR_CANCELLED;
        }
    }

    ZeroMemory(&g_rvInfo, sizeof(g_rvInfo));
    g_rvInfo.hinstExe = hInstance;
    g_rvInfo.hInst    = LoadLibrary(TEXT("ieakui.dll"));

    if (g_rvInfo.hInst == NULL)
        return ERROR_CANCELLED;

    // if the class registration fails, return.
    if (!InitApplication(hInstance))
    {
        FreeLibrary(g_rvInfo.hInst);
        return ERROR_CANCELLED;
    }

    SHCreateKeyHKCU(RK_IEAK_SERVER_MAIN, KEY_ALL_ACCESS, &s_hkIEAKUser);

    g_wCurLang = GetUserDefaultLCID() & 0xFFFF;
    s_fNT5   = IsOS(OS_NT5);

    hrOle = CoInitialize(NULL);

    GetIEAKDir(g_szWizPath);

    StrCpy(g_szWizRoot, g_szWizPath);
    CharUpper(g_szWizRoot);

    LoadString(g_rvInfo.hInst, IDS_TITLE, g_szTitle, countof(g_szTitle));

    //get the mode  -- NOTE: THIS MUST COME BEFORE PARSECMDLINE SO THAT COMMANDLINE OPTIONS OVERRIDE THE REG ENTRY!!!
    DWORD dwSize = sizeof(DWORD);
    if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\IEAK"), TEXT("Mode"), NULL, &s_iType, &dwSize) != ERROR_SUCCESS)
        s_iType = INTRANET; //if there is no reg entry, default to corp mode
    switch (s_iType)
    {
        case REDIST://icp
            StrCpy(s_szType, TEXT("REDIST"));
            g_fBranded = FALSE;
            g_iKeyType = KEY_TYPE_SUPER;
            g_fIntranet = g_fSilent = FALSE;
            break;

        case BRANDED://isp
            StrCpy(s_szType, TEXT("BRANDED"));
            g_fBranded = TRUE;
            g_iKeyType = KEY_TYPE_SUPER;
            g_fIntranet = g_fSilent = FALSE;
            break;

        case INTRANET:
        default:
            StrCpy(s_szType, TEXT("INTRANET"));
            g_iKeyType = KEY_TYPE_SUPERCORP;
            g_fBranded = TRUE;
            g_fIntranet = TRUE;
            break;
    }

    *g_szKey = TEXT('\0');
    if (lpCmdLine != NULL  &&  *lpCmdLine)
        if (!ParseCmdLine(lpCmdLine))
        {
            FreeLibrary(g_rvInfo.hInst);
            return ERROR_CANCELLED;
        }

    if (*g_szLogFile != 0 && (g_hLogFile = CreateFile(g_szLogFile, GENERIC_WRITE, 
                                                    FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
                                                    FILE_ATTRIBUTE_NORMAL, NULL)) == NULL)
    {
        MessageBox(NULL, TEXT("Cannot open log file"), NULL, MB_OK);
        return ERROR_CANCELLED;
    }

    // Perform initializations that apply to a specific instance
    if (!InitInstance(hInstance))
    {
        FreeLibrary(g_rvInfo.hInst);
        return ERROR_CANCELLED;
    }

    // Acquire and dispatch messages until a WM_QUIT message is received.
    iRetVal = GetMessage(&msg, NULL, 0, 0);
    while (iRetVal != -1  &&  iRetVal != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);

        iRetVal = GetMessage(&msg, NULL, 0, 0);
    }

    CleanUp();
    if (S_OK == hrOle)
        CoUninitialize();

    if (g_hLogFile)
        CloseHandle(g_hLogFile);


#ifdef DBG
    if (g_fBatch || g_fBatch2 || MessageBox(NULL, TEXT("OK to Delete Temp Files"), TEXT("Wizard Complete"), MB_YESNO) == IDYES)
#endif
        if (lstrlen(g_szBuildTemp))
            PathRemovePath(g_szBuildTemp);

    RegCloseKey(s_hkIEAKUser);
    WriteMSTrustKey(FALSE);      // Mark MS as a trusted provider

    if (s_hWndHelp != NULL)
        SendMessage(s_hWndHelp, WM_CLOSE, 0, 0L);

    FreeLibrary(g_rvInfo.hInst);

    if (hMutex != NULL)
        CloseHandle(hMutex);

    if (g_fOCWCancel)
        return ERROR_CANCELLED;

    return (int) msg.wParam;
}

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS wcSample;

    wcSample.style         = 0;
    wcSample.lpfnWndProc   = MainWndProc;
    wcSample.cbClsExtra    = 0;
    wcSample.cbWndExtra    = 0;
    wcSample.hInstance     = hInstance;
    wcSample.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WIZARD));
    wcSample.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcSample.hbrBackground = (HBRUSH) GetStockObject(GRAY_BRUSH);
    wcSample.lpszMenuName  = NULL;
    wcSample.lpszClassName = TEXT("SampleWClass");

    return RegisterClass(&wcSample);
}

BOOL ParseCmdLine(LPSTR lpCmdLine)
{
    TCHAR szCmdLine[MAX_PATH];
    LPTSTR pParam;
    TCHAR szWrkLang[8] = TEXT("en");
    HKEY hKey;
    DWORD dwSize;
    TCHAR szType[16]; //Mode: CORP(INTRANET), ICP(RETAIL) or ISP(BRANDED)

    *szType = TEXT('\0');     

    A2Tbux(lpCmdLine, szCmdLine);
    CharUpper(szCmdLine);

    pParam = szCmdLine;
    while (pParam != NULL)
    {
        pParam = StrChr(pParam, TEXT('/'));
        if (pParam == NULL)
            break;

        switch (*++pParam)
        {
            case TEXT('S'): // srcpath
                if ( *(pParam+2) == '\"' ) 
                {
                    pParam++; //skip the first quote, we don't want the quotes
                    StrCpyN(g_szSrcRoot, pParam + 2, countof(g_szSrcRoot));
                    StrTok(g_szSrcRoot, TEXT("\"\n\r\t"));  //instead of stopping w/ a space, stop w/ "
                }
                else
                {
                    StrCpyN(g_szSrcRoot, pParam + 2, countof(g_szSrcRoot));
                    StrTok(g_szSrcRoot, TEXT(" \n\r\t"));
                }
                pParam += StrLen(g_szSrcRoot);
                break;
                
            case TEXT('I'):
            case TEXT('D'):
                if ( *(pParam+2) == '\"' ) 
                {
                    pParam++; //skip the first quote, we don't want the quotes
                    StrCpyN(g_szBuildRoot, pParam + 2, countof(g_szBuildRoot));
                    StrTok(g_szBuildRoot, TEXT("\"\n\r\t"));  //instead of stopping w/ a space, stop w/ "
                }
                else
                {
                    StrCpyN(g_szBuildRoot, pParam + 2, countof(g_szBuildRoot));
                    StrTok(g_szBuildRoot, TEXT(" \n\r\t"));
                }
                pParam += StrLen(g_szBuildRoot);
                break;

            case TEXT('K'):
                StrCpyN(g_szKey, pParam + 2, countof(g_szKey));
                StrTok(g_szKey, TEXT(" \n\r\t"));
                pParam += StrLen(g_szKey);
                break;

            case TEXT('M'): // Mode: corp, isp or icp
                StrCpyN(szType, pParam + 2, countof(szType));
                StrTok(szType, TEXT(" \n\r\t"));
                pParam += StrLen(szType);
                break;

            case TEXT('Q'): // logfile
                if ( *(pParam+2) == '\"' ) 
                {
                    pParam++; //skip the first quote, we don't want the quotes
                    StrCpyN(g_szLogFile, pParam + 2, countof(g_szLogFile));
                    StrTok(g_szLogFile, TEXT("\"\n\r\t"));  //instead of stopping w/ a space, stop w/ "
                }
                else
                {
                    StrCpyN(g_szLogFile, pParam + 2, countof(g_szLogFile));
                    StrTok(g_szLogFile, TEXT(" \n\r\t"));
                }
                pParam += StrLen(g_szLogFile);
                break;

            case TEXT('L'):
                StrCpyN(szWrkLang, pParam + 2, 3);
                pParam += 3;
                break;

            case TEXT('O'):
                g_fOCW = TRUE;
                g_dwPlatformId = PLATFORM_WIN32;

                // (a-saship) read all the data from the registry from HKCU\Software\Microsoft\IEAK since
                // office reads/writes data from/to this location. This is due to the fact that IEAK5_5
                // changed the registry location to HKCU\Software\Microsoft\IEAK5_5 and office is not aware
                // of it. These values is only used by Office and hence we are safe here.
                if (RegOpenKeyEx(HKEY_CURRENT_USER, RK_IEAK, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(g_szKey);
                    SHQueryValueEx(hKey, TEXT("KeyCode"), NULL, NULL, (LPVOID) g_szKey, &dwSize);

                    dwSize = sizeof(g_szIEAKProg);
                    SHQueryValueEx(hKey, TEXT("SourceDir"), NULL, NULL, (LPVOID) g_szIEAKProg, &dwSize);
                    if (*g_szIEAKProg)
                    {
                        PathAddBackslash(g_szIEAKProg);
                        StrCpy(s_szSourceDir, g_szIEAKProg);
                    }

                    dwSize = sizeof(g_szBuildRoot);
                    SHQueryValueEx(hKey, TEXT("TargetDir"), NULL, NULL, (LPVOID) g_szBuildRoot, &dwSize);
                    if (*g_szBuildRoot == TEXT('\0'))
                        StrCpy(g_szBuildRoot, g_szIEAKProg);
                    if (*g_szBuildRoot)
                        PathRemoveBackslash(g_szBuildRoot);

                    s_fAppendLang = TRUE;

                    dwSize = sizeof(g_szParentWindowName);
                    SHQueryValueEx(hKey, TEXT("ParentWindowName"), NULL, NULL, (LPVOID) g_szParentWindowName, &dwSize);

                    RegCloseKey(hKey);
                }
                break;
        }
    }

    *g_szLanguage = TEXT('\\');
    StrCpy(&g_szLanguage[1], szWrkLang);
    g_szLanguage[3] = TEXT('\\');
    g_szLanguage[4] = TEXT('\0');

    StrCpy(g_szActLang, szWrkLang);

    if ((*g_szKey != TEXT('\0')) && (!szType[0]))  //if they set a key, we should override the mode
    {
        CheckKey(g_szKey); 
        if (g_iKeyType == KEY_TYPE_SUPERCORP)
        {
            StrCpy(s_szType, TEXT("INTRANET"));
            StrCpy(szType, TEXT("CORP"));
        }
        else StrCpy(szType, TEXT("ICP"));
    }


/*  removed--this is really crappy validation code and also makes it impossible to have spaces in paths

    if (StrCmpN(g_szBuildRoot, TEXT("\\\\"), 2)  &&
        StrCmpN(&g_szBuildRoot[1], TEXT(":\\"), 2))
    {
        ErrorMessageBox(NULL, IDS_NEEDPATH);
        return FALSE;
    }
*/

    if (StrLen(g_szBuildRoot) <= 3)
    {
        ErrorMessageBox(NULL, IDS_ROOTILLEGAL);
        return FALSE;
    }

    if ((!PathIsDirectory(g_szBuildRoot)) && (!CreateDirectory(g_szBuildRoot,NULL)))
    {
        TCHAR szMsg[MAX_PATH];
        TCHAR szTemp[2 * MAX_PATH];

        LoadString(g_rvInfo.hInst, IDS_BADDIR, szMsg, countof(szMsg));
        wnsprintf(szTemp, countof(szTemp), szMsg, g_szBuildRoot);
        MessageBox(NULL, szTemp, g_szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
        return FALSE;
    }
    
    GetTempPath(MAX_PATH, g_szBuildTemp);
    PathAppend(g_szBuildTemp, TEXT("iedktemp"));

    PathRemovePath(g_szBuildTemp);
    PathCreatePath(g_szBuildTemp);

    GenerateCustomIns();

    if (g_szSrcRoot[0])
        g_fBatch2 = TRUE;
    else
        g_fBatch = TRUE;

    if (szType[0])
    {
        if ( 0 == StrCmpI(szType, TEXT("CORP")))
        {
            // if type CORP, set CorpMode=1; this allows the Profile Manager to run
            DWORD dwVal = 1;
            RegSetValueEx(s_hkIEAKUser, TEXT("CorpMode"), 0, REG_DWORD, (CONST BYTE *) &dwVal, sizeof(dwVal));
            s_iType = INTRANET;
        }
        else if ( 0 == StrCmpI(szType, TEXT("ISP")))
        {
            RegDeleteValue(s_hkIEAKUser, TEXT("CorpMode"));
            s_iType = BRANDED;
        }
        else if ( 0 == StrCmpI(szType, TEXT("ICP")))
        {
            RegDeleteValue(s_hkIEAKUser, TEXT("CorpMode"));
            s_iType = REDIST;
        }
        else
        {
            if(g_hLogFile)
            {
                TCHAR szError[MAX_PATH];
                DWORD dwNumWritten;
                LoadString(g_rvInfo.hInst,IDS_ERROR_INVALIDMODE,szError,MAX_PATH);
                FormatString(szError,szType);
                WriteFile(g_hLogFile,szError,StrLen(szError),&dwNumWritten,NULL);
            }
            return FALSE;
        }
    }
    else
        s_iType = GetPrivateProfileInt( IS_BRANDING, TEXT("Type"), REDIST, g_szCustIns );

    switch (s_iType)
    {
        case REDIST:
            g_fBranded = g_fIntranet = g_fSilent = FALSE;
            break;
        case BRANDED:
        case BRANDEDPROXY:
            g_fBranded = TRUE;
            g_fIntranet = g_fSilent = FALSE;
            break;
        case INTRANET:
            g_fIntranet = g_fBranded = TRUE;
            break;
    }
    
    if (g_fOCW)
    {
        // set to corp mode
        g_fIntranet = g_fBranded = TRUE;
        s_iType = INTRANET;

        // set to flat install
        g_fDownload = g_fCD = g_fBrandingOnly = FALSE;
        g_fLAN = TRUE;

        return TRUE;
    }

    IE4BatchSetup();

    return TRUE;
}


//
//
//   FUNCTION: InitInstance(HANDLE)
//
//   PURPOSE: Creates the main window.
//
//   COMMENTS: N/A
//
//
HWND g_hWndCent;

BOOL InitInstance(HINSTANCE hInstance)
{
    InitCommonControls();
    GetWindowRect(GetDesktopWindow(), &g_dtRect);
    g_hWndCent = CreateWindow(
                TEXT("SampleWClass"),
                TEXT("IEAK"),
        WS_POPUPWINDOW | WS_CAPTION,
        g_dtRect.right/2, g_dtRect.bottom/2, 0, 0,
        HWND_DESKTOP,
        NULL,
        hInstance,
        (HINSTANCE) NULL);

    ShowWindow(g_hWndCent, SW_SHOWNORMAL);
    UpdateWindow(g_hWndCent);
    PostMessage(g_hWndCent, WM_COMMAND, IDM_WIZARD, (LPARAM) 0);

    return (TRUE);

}

IEAKLITEINFO g_IEAKLiteArray[NUM_GROUPS] =  {
{IDS_IL_ACTIVESETUP, IDS_IL_ACTIVESETUPDESC, IDS_IL_ACTIVESETUPDESC, IDS_IL_ACTIVESETUPDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_CORPINSTALL, IDS_IL_CORPINSTALLDESC, IDS_IL_CORPINSTALLDESC, IDS_IL_CORPINSTALLDESC, -2, FALSE, FALSE, TRUE, TRUE},
{IDS_IL_CABSIGN, IDS_IL_CABSIGNDESC, IDS_IL_CABSIGNDESC, IDS_IL_CABSIGNDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_ICM, IDS_IL_ICMDESC, IDS_IL_ICMDESC, IDS_IL_ICMDESC, -2, FALSE, TRUE, TRUE, TRUE},
{IDS_IL_BROWSER, IDS_IL_BROWSERDESC, IDS_IL_BROWSERDESC, IDS_IL_BROWSERDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_URL, IDS_IL_URLDESC, IDS_IL_URLDESC, IDS_IL_URLDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_FAV, IDS_IL_FAVDESC, IDS_IL_FAVDESC, IDS_IL_FAVDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_UASTR, IDS_IL_UASTRDESC, IDS_IL_UASTRDESC, IDS_IL_UASTRDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_CONNECT, IDS_IL_CONNECTDESC, IDS_IL_CONNECTDESC, IDS_IL_CONNECTDESC, -2, FALSE, TRUE, TRUE, TRUE},
{IDS_IL_SIGNUP, IDS_IL_SIGNUPDESC, IDS_IL_SIGNUPDESC, IDS_IL_SIGNUPDESC, -2, FALSE, TRUE, FALSE, TRUE},
{IDS_IL_CERT, IDS_IL_CERTDESC, IDS_IL_CERTDESC, IDS_IL_CERTDESC, -2, FALSE, TRUE, TRUE, TRUE},
{IDS_IL_ZONES, IDS_IL_ZONESDESC, IDS_IL_ZONESDESC, IDS_IL_ZONESDESC, -2, FALSE, FALSE, TRUE, TRUE},
{IDS_IL_PROGRAMS, IDS_IL_PROGRAMSDESC, IDS_IL_PROGRAMSDESC, IDS_IL_PROGRAMSDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_MAILNEWS, IDS_IL_MAILNEWSDESC, IDS_IL_MAILNEWSDESC, IDS_IL_MAILNEWSDESC, -2, FALSE, TRUE, TRUE, TRUE},
{IDS_IL_ADM, IDS_IL_ADMDESC, IDS_IL_ADMDESC, IDS_IL_ADMDESC, -2, TRUE, TRUE, TRUE, TRUE}
};

void DisableIEAKLiteGroups()
{
    TCHAR szIspFile[MAX_PATH];

    if (!g_IEAKLiteArray[IL_ACTIVESETUP].fEnabled)
    {
        s_fPageEnabled[PPAGE_SETUPWIZARD] = s_fPageEnabled[PPAGE_COMPSEL] = s_fPageEnabled[PPAGE_ISKBACK] = s_fPageEnabled[PPAGE_CDINFO] =
        s_fPageEnabled[PPAGE_CUSTOMCUSTOM] = s_fPageEnabled[PPAGE_COPYCOMP] = s_fPageEnabled[PPAGE_COMPURLS] =
        s_fPageEnabled[PPAGE_CUSTCOMP] =  FALSE;
    }

    if (!g_IEAKLiteArray[IL_CORPINSTALL].fEnabled)
    {
        s_fPageEnabled[PPAGE_CORPCUSTOM] = s_fPageEnabled[PPAGE_INSTALLDIR] = s_fPageEnabled[PPAGE_SILENTINSTALL] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_CABSIGN].fEnabled)
    {
        s_fPageEnabled[PPAGE_CABSIGN] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_ICM].fEnabled)
    {
        s_fPageEnabled[PPAGE_ICM] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_BROWSER].fEnabled)
    {
        s_fPageEnabled[PPAGE_TITLE] = s_fPageEnabled[PPAGE_CUSTICON] =
        s_fPageEnabled[PPAGE_BTOOLBARS] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_URL].fEnabled)
    {
        s_fPageEnabled[PPAGE_STARTSEARCH] = s_fPageEnabled[PPAGE_WELCOMEMSGS] =
            s_fPageEnabled[PPAGE_ADDON] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_FAV].fEnabled)
    {
        s_fPageEnabled[PPAGE_FAVORITES] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_UASTR].fEnabled)
    {
        s_fPageEnabled[PPAGE_UASTRDLG] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_CONNECT].fEnabled)
    {
        s_fPageEnabled[PPAGE_PROXY] = s_fPageEnabled[PPAGE_CONNECTSET] = s_fPageEnabled[PPAGE_QUERYAUTOCONFIG] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_SIGNUP].fEnabled)
    {
        s_fPageEnabled[PPAGE_QUERYSIGNUP] =
        s_fPageEnabled[PPAGE_SIGNUPFILES] =
        s_fPageEnabled[PPAGE_SERVERISPS] =
        s_fPageEnabled[PPAGE_ICW] = s_fPageEnabled[PPAGE_ISPINS] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_CERT].fEnabled)
    {
        s_fPageEnabled[PPAGE_ADDROOT] = s_fPageEnabled[PPAGE_SECURITYCERT] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_ZONES].fEnabled)
    {
        s_fPageEnabled[PPAGE_SECURITY] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_PROGRAMS].fEnabled)
    {
        s_fPageEnabled[PPAGE_PROGRAMS] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_MAILNEWS].fEnabled)
    {
        s_fPageEnabled[PPAGE_MAIL] = s_fPageEnabled[PPAGE_IMAP] = s_fPageEnabled[PPAGE_LDAP] =
        s_fPageEnabled[PPAGE_OE]   = s_fPageEnabled[PPAGE_SIG]  = s_fPageEnabled[PPAGE_PRECONFIG] =
        s_fPageEnabled[PPAGE_OEVIEW] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_ADM].fEnabled)
    {
        s_fPageEnabled[PPAGE_ADMDESC] = FALSE;
        s_fPageEnabled[PPAGE_ADM] = FALSE;
    }

    // do not show stage 4 page if nothing has been left on in the stage

    if (!(g_IEAKLiteArray[IL_BROWSER].fEnabled || g_IEAKLiteArray[IL_URL].fEnabled 
        || g_IEAKLiteArray[IL_FAV].fEnabled || g_IEAKLiteArray[IL_UASTR].fEnabled ||
        (g_IEAKLiteArray[IL_CONNECT].fEnabled && g_fBranded) || (g_IEAKLiteArray[IL_SIGNUP].fEnabled && !g_fIntranet && g_fBranded) ||
        ((g_IEAKLiteArray[IL_CERT].fEnabled || g_IEAKLiteArray[IL_ZONES].fEnabled) && g_fIntranet)))
        s_fPageEnabled[PPAGE_STAGE4] = FALSE;

    if (!(g_IEAKLiteArray[IL_PROGRAMS].fEnabled || (g_IEAKLiteArray[IL_MAILNEWS].fEnabled && g_fBranded) || 
          g_IEAKLiteArray[IL_ADM].fEnabled))
        s_fPageEnabled[PPAGE_STAGE5] = FALSE;

    // szIspFile used as temp buf

    if (g_fDownload && !g_fOCW && ISNONNULL(g_szCustIns) && !GetPrivateProfileString(IS_ACTIVESETUP_SITES, TEXT("SiteUrl0"), TEXT(""), szIspFile, countof(szIspFile), g_szCustIns))
        s_fPageEnabled[PPAGE_COMPURLS] = TRUE;

    // do not show stage 3 page if nothing has been left on in the stage

    if (!(s_fPageEnabled[PPAGE_COMPURLS] || g_IEAKLiteArray[IL_ACTIVESETUP].fEnabled ||
          (g_IEAKLiteArray[IL_CORPINSTALL].fEnabled && g_fIntranet) || g_IEAKLiteArray[IL_CABSIGN].fEnabled || 
          (g_IEAKLiteArray[IL_ICM].fEnabled) && g_fBranded && !g_fBrandingOnly))
        s_fPageEnabled[PPAGE_STAGE3] = FALSE;

    // always enable download urls page for download packages
    // the page itself has logic to skip

    if (g_fDownload)
        s_fPageEnabled[PPAGE_COMPURLS] = TRUE;
}

void EnablePages()
{
    int i;
    static BOOL s_fRunningOnIntegShell = WhichPlatform() & PLATFORM_INTEGRATED;

    for (i = 0;  i < NUM_PAGES;  i++)
    {
        s_fPageEnabled[i] = TRUE;
    }

    // NOTE: pages should not explicitly be set to TRUE after this point

    // g_fIntranet and g_fBranded are set to the following values depending on the role
    // ICP:  (g_fIntranet == FALSE  &&  g_fBranded == FALSE)
    // ISP:  (g_fIntranet == FALSE  &&  g_fBranded == TRUE )
    // CORP: (g_fIntranet == TRUE   &&  g_fBranded == TRUE )
    //
    // So, check for
    // ICP  is (!g_fBranded)
    // ISP  is (!g_fIntranet  &&  g_fBranded)
    // CORP is (g_fIntranet)

    if (!g_fBranded)
    {   // ICP mode
        s_fPageEnabled[PPAGE_PROXY] =
        s_fPageEnabled[PPAGE_INSTALLDIR] =
        s_fPageEnabled[PPAGE_ICM] =
        s_fPageEnabled[PPAGE_ICW] =
        s_fPageEnabled[PPAGE_QUERYAUTOCONFIG] =
        s_fPageEnabled[PPAGE_MAIL] =
        s_fPageEnabled[PPAGE_IMAP] =
        s_fPageEnabled[PPAGE_LDAP] =
        s_fPageEnabled[PPAGE_PRECONFIG] =
        s_fPageEnabled[PPAGE_OEVIEW] =
        s_fPageEnabled[PPAGE_OE]   = s_fPageEnabled[PPAGE_CORPCUSTOM] = s_fPageEnabled[PPAGE_ADMDESC] =
        s_fPageEnabled[PPAGE_SIG]  = s_fPageEnabled[PPAGE_FOLDERMCCP] = s_fPageEnabled[PPAGE_ADDROOT] =
        s_fPageEnabled[PPAGE_SECURITY] = s_fPageEnabled[PPAGE_SECURITYCERT] = s_fPageEnabled[PPAGE_QUERYSIGNUP] =
        s_fPageEnabled[PPAGE_SILENTINSTALL] =
        s_fPageEnabled[PPAGE_DESKTOP] = s_fPageEnabled[PPAGE_DTOOLBARS] = s_fPageEnabled[PPAGE_CONNECTSET] =
        s_fPageEnabled[PPAGE_SIGNUPFILES] = s_fPageEnabled[PPAGE_SERVERISPS] = s_fPageEnabled[PPAGE_ISPINS] = FALSE;
    }
    else if (!g_fIntranet)
    {   // Either ISP or Super ISP
        s_fPageEnabled[PPAGE_QUERYAUTOCONFIG] =
        s_fPageEnabled[PPAGE_SIG] =
        s_fPageEnabled[PPAGE_INSTALLDIR] =
        s_fPageEnabled[PPAGE_SILENTINSTALL] =
        s_fPageEnabled[PPAGE_DESKTOP] = s_fPageEnabled[PPAGE_DTOOLBARS] = s_fPageEnabled[PPAGE_ADMDESC] =
        s_fPageEnabled[PPAGE_SECURITY] = s_fPageEnabled[PPAGE_SECURITYCERT] =
        s_fPageEnabled[PPAGE_FOLDERMCCP] = s_fPageEnabled[PPAGE_CORPCUSTOM] = FALSE;

        s_fPageEnabled[PPAGE_SERVERISPS] = (g_fServerICW || g_fServerKiosk)  &&  !g_fSkipServerIsps;
        s_fPageEnabled[PPAGE_ISPINS] = !g_fNoSignup  &&  !g_fSkipIspIns;

        s_fPageEnabled[PPAGE_ICW] = g_fServerICW;
        s_fPageEnabled[PPAGE_SIGNUPFILES] = !g_fNoSignup;
    }
    else
    {   // CorpAdmin mode
        s_fPageEnabled[PPAGE_ADDROOT] = s_fPageEnabled[PPAGE_ICW] =
        s_fPageEnabled[PPAGE_SERVERISPS] = s_fPageEnabled[PPAGE_ISPINS] =
        s_fPageEnabled[PPAGE_QUERYSIGNUP] = s_fPageEnabled[PPAGE_SIGNUPFILES] = FALSE;
        s_fPageEnabled[PPAGE_DTOOLBARS] = s_fPageEnabled[PPAGE_DESKTOP] = g_fInteg && s_fRunningOnIntegShell && !s_fNT5;
        s_fPageEnabled[PPAGE_FOLDERMCCP] = g_fInteg && !s_fNT5;

        s_fPageEnabled[PPAGE_ADMDESC] = ADMEnablePage();
    }

    if (!g_fCD)
        s_fPageEnabled[PPAGE_ISKBACK] = s_fPageEnabled[PPAGE_CDINFO] = FALSE;

    if (!g_fDownload)
        s_fPageEnabled[PPAGE_COMPURLS] = FALSE;

    if (!g_fMailNews95 && !g_fOCW)
    {
        s_fPageEnabled[PPAGE_MAIL] = s_fPageEnabled[PPAGE_IMAP] = s_fPageEnabled[PPAGE_PRECONFIG] =
        s_fPageEnabled[PPAGE_OEVIEW] = s_fPageEnabled[PPAGE_LDAP] = s_fPageEnabled[PPAGE_OE] =
        s_fPageEnabled[PPAGE_SIG]  = FALSE;
    }

    if (!g_fDownload && (g_fSilent || g_fStealth))
        s_fPageEnabled[PPAGE_CUSTOMCUSTOM] = FALSE;

    // pages to disable for single disk branding only builds

    if (g_fBrandingOnly && !(g_fDownload || g_fLAN || g_fCD))
    {
        s_fPageEnabled[PPAGE_CUSTCOMP] = s_fPageEnabled[PPAGE_COMPSEL] = s_fPageEnabled[PPAGE_COMPURLS] =
        s_fPageEnabled[PPAGE_INSTALLDIR] = s_fPageEnabled[PPAGE_CORPCUSTOM] = s_fPageEnabled[PPAGE_CUSTOMCUSTOM] =
        s_fPageEnabled[PPAGE_COPYCOMP] = s_fPageEnabled[PPAGE_ICM] =
        s_fPageEnabled[PPAGE_ADDON] = FALSE;

        g_fInteg = TRUE;  // set this flag to true so admins can still make desktop customizations
    }

    // disable advanced installation options page if no download media and custom mode
    // disabled

    if (!g_fDownload && InsGetBool(IS_BRANDING, TEXT("HideCustom"), FALSE, g_szCustIns))
        s_fPageEnabled[PPAGE_CUSTOMCUSTOM] = FALSE;

    if (g_fImportConnect)
        s_fPageEnabled[PPAGE_PROXY] = s_fPageEnabled[PPAGE_QUERYAUTOCONFIG] = FALSE;

    s_fPageEnabled[PPAGE_ADM] = ADMEnablePage();

    if(g_fOCW)
    {
        s_fPageEnabled[PPAGE_FINISH]       = 
        s_fPageEnabled[PPAGE_MEDIA]        = s_fPageEnabled[PPAGE_ISPINS] =
        s_fPageEnabled[PPAGE_ICM]          = s_fPageEnabled[PPAGE_QUERYSIGNUP]  = s_fPageEnabled[PPAGE_ICW] =
        s_fPageEnabled[PPAGE_SIGNUPFILES]  = s_fPageEnabled[PPAGE_SERVERISPS]   = s_fPageEnabled[PPAGE_SETUPWIZARD]  =
        s_fPageEnabled[PPAGE_STAGE1]       = s_fPageEnabled[PPAGE_STAGE2]       = s_fPageEnabled[PPAGE_STAGE3]        =
        s_fPageEnabled[PPAGE_STAGE4]       = s_fPageEnabled[PPAGE_STAGE5]       = s_fPageEnabled[PPAGE_SILENTINSTALL] =
        s_fPageEnabled[PPAGE_COMPURLS]     = s_fPageEnabled[PPAGE_INSTALLDIR]   = FALSE;
    }
    else
    {
        s_fPageEnabled[PPAGE_OCWSTAGE2]    = FALSE;
    }

    // Special case IMAP page
    if (g_fDisableIMAPPage)
        s_fPageEnabled[PPAGE_IMAP] = FALSE;

    DisableIEAKLiteGroups();
}

BOOL PageEnabled(int iPage)
{
    TCHAR szTemp[4];

    // this should eventually just index into s_fPageEnabled, but for now we need to do this
    // manually since we must still use the page array for PageNext and PageBack

    if (iPage == PPAGE_COMPURLS)
        return (g_IEAKLiteArray[IL_ACTIVESETUP].fEnabled
                || !GetPrivateProfileString(IS_ACTIVESETUP_SITES, TEXT("SiteUrl0"),
                TEXT(""), szTemp, countof(szTemp), g_szCustIns));

    return TRUE;    // default to show page
}

static TCHAR s_aSzTitle[NUM_PAGES][MAX_PATH];

void PageNext(HWND hDlg)
{
    if (s_fPageEnabled[++g_iCurPage]) return;
    while (1)
    {
        if (s_fPageEnabled[++g_iCurPage])
        {
            DWORD id = (DWORD) PtrToUlong(g_psp[g_iCurPage].pszTemplate);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, id);
            return;
        }
    }
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FINISH);
}

void PagePrev(HWND hDlg)
{
    if (s_fPageEnabled[--g_iCurPage]) return;
    while (1)
    {
        if (s_fPageEnabled[--g_iCurPage])
        {
            DWORD id = (DWORD) PtrToUlong(g_psp[g_iCurPage].pszTemplate);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, id);
            return;
        }
    }
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_KEYINS);
}

SHFILEOPSTRUCT g_shfStruc;

void DoCancel()
{
    g_fCancelled = TRUE;
    g_fOCWCancel = TRUE;
    if (g_hDownloadEvent) SetEvent(g_hDownloadEvent);
    PostQuitMessage(0);

}

BOOL QueryCancel(HWND hDlg)
{
    TCHAR szMsg[MAX_PATH];
    LoadString( g_rvInfo.hInst, IDS_CANCELOK, szMsg, countof(szMsg) );
    if (MessageBox(hDlg, szMsg, g_szTitle, MB_YESNO | MB_SETFOREGROUND) == IDNO)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        g_fCancelled = FALSE;
        return(FALSE);
    }
    DoCancel();
    return(TRUE);
}

BOOL IeakPageHelp(HWND hWnd, LPCTSTR pszData)
{
    static TCHAR szHelpPath[MAX_PATH] = TEXT("");

    UNREFERENCED_PARAMETER(hWnd);

    if (ISNULL(szHelpPath))
        PathCombine(szHelpPath, g_szWizRoot, TEXT("ieakhelp.chm"));

    // (pritobla): If we pass hWnd to HtmlHelp, the HTML help window
    // would stay on top of our window (parent->child relationship).
    // This is bad because the user can't switch between these windows
    // for cross referencing.  This is especially bad on a 640x480
    // resolution monitor.
    s_hWndHelp = HtmlHelp(NULL, szHelpPath, HH_HELP_CONTEXT, (ULONG_PTR) pszData);

    // (pritobla): On OSR2 machines, the HTML help window comes up behind
    // our window.  On a 640x480 resolution monitor, we pretty much occupy
    // the entire screen, so the user won't know that the HTML help window
    // is up.  Setting it to the foreground solves the problem.

    SetForegroundWindow(s_hWndHelp);
    return TRUE;
}

extern DWORD BuildIE4(LPVOID );

//
//   FUNCTION: MainWndProc(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for the main window procedure
//
//    MESSAGES:
//
//  WM_CREATE - creates the main MLE for the window
//  WM_COMMAND - processes the menu commands for the application
//  WM_SIZE - sizes the MLE to fill the client area of the window
//  WM_DESTROY - posts a quit message and returns
//
LRESULT APIENTRY MainWndProc(
    HWND hWnd,                // window handle
    UINT message,             // type of message
    WPARAM wParam,              // additional information
    LPARAM lParam)              // additional information
{
    int i;

    switch (message)
    {
        case WM_CREATE:
            return FALSE;

        case WM_INITDIALOG:
            return FALSE;

        case WM_SIZE:
            if (!IsIconic(hWnd) && (hWnd != g_hWndCent))
                ShowWindow(hWnd, SW_MINIMIZE);
            if (g_hWizard != NULL)
                SetFocus(g_hWizard);
            return (DefWindowProc(hWnd, message, wParam, lParam));

        case WM_HELP:
            IeakPageHelp(hWnd, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch( LOWORD( wParam ))
            {
                case IDM_WIZARD:
                    if (g_fCancelled)
                        break;

                    i = CreateWizard(g_hWndCent);
                    if (i < 0) {
                        PostQuitMessage(0);
                        break;
                    }
                    PostMessage(hWnd, WM_COMMAND, IDM_LAST, (LPARAM) 0);
                    break;

                case IDM_LAST:
                    PostQuitMessage(0);
                    break;

                case IDM_EXIT:
                    PostQuitMessage(0);
                    break;

                default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));

        }
        break;

        case WM_CLOSE:
            QueryCancel(hWnd);
            break;

        case WM_DESTROY:                  /* message: window being destroyed */
            PostQuitMessage(0);
            DestroyWindow(g_hWndCent);
            break;

        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}


DWORD GetRootFree(LPCTSTR pcszPath)
{
    DWORD dwSecPerClus, dwBytesPerSec, dwTotClusters, dwFreeClusters, dwClustK;
    CHAR szPathA[MAX_PATH];

    // thunk to ANSI since shlwapi doesn't have a wrapper fot GetDiskFreeSpace and
    // the W version is stubbed out on Win95

    T2Abux(pcszPath, szPathA);

    if (szPathA[1] == ':')
    {
        szPathA[3] = '\0';
    }
    else
    {
        if ((szPathA[0] == '\\') && (szPathA[1] == '\\'))
        {
            NETRESOURCEA netRes;
            DWORD erc = ERROR_ALREADY_ASSIGNED;
            CHAR szLocalPathA[4] = "D:";
            LPSTR pBack = StrChrA(&szPathA[2], '\\');
            if (!pBack) return(0);
            pBack = StrChrA(CharNextA(pBack), '\\');
            if (pBack) *pBack = '\0';
            ZeroMemory(&netRes, sizeof(netRes));
            netRes.dwType = RESOURCETYPE_DISK;
            netRes.lpRemoteName = szPathA;
            for (*szLocalPathA = 'D'; *szLocalPathA <= 'Z' ; (*szLocalPathA)++ )
            {
                netRes.lpLocalName = szLocalPathA;
                erc = WNetAddConnection2A(&netRes, NULL, NULL, 0);
                if (erc == ERROR_ALREADY_ASSIGNED) continue;
                if (erc == NO_ERROR) break;
            }
            if (erc == NO_ERROR)
            {
                if (!GetDiskFreeSpaceA( szLocalPathA, &dwSecPerClus, &dwBytesPerSec, &dwFreeClusters, &dwTotClusters ))
                    dwSecPerClus = dwBytesPerSec = 0;
                WNetCancelConnection2A(szLocalPathA, 0, FALSE);
                if (dwSecPerClus == 1) return(dwFreeClusters/2);
                dwClustK = dwSecPerClus * dwBytesPerSec / 1024;
                return(dwClustK * dwFreeClusters);
            }
        }
        else return(0);
    }
    if (!GetDiskFreeSpaceA( szPathA, &dwSecPerClus, &dwBytesPerSec, &dwFreeClusters, &dwTotClusters ))
        return(0);
    if (dwSecPerClus == 1) return(dwFreeClusters/2);
    dwClustK = dwSecPerClus * dwBytesPerSec / 1024;
    return(dwClustK * dwFreeClusters);
}

void CheckBatchAdvance(HWND hDlg)
{
    if (g_fBatch || g_fBatch2) PostMessage(hDlg, IDM_BATCHADVANCE, 0, 0);
}

void DoBatchAdvance(HWND hDlg)
{
    if (g_fBatch || g_fBatch2) PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, PSBTN_NEXT, 0);
}

INT_PTR CALLBACK MediaDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM lParam)
{
    static BOOL s_fNext = TRUE;

    switch (uMsg)
    {
        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    g_fDownload     = GetPrivateProfileInt(TEXT("Media"), TEXT("Build_Download"),     1, g_szCustIns);
                    g_fCD           = GetPrivateProfileInt(TEXT("Media"), TEXT("Build_CD"),           0, g_szCustIns);
                    g_fLAN          = GetPrivateProfileInt(TEXT("Media"), TEXT("Build_LAN"),          0, g_szCustIns);
                    g_fBrandingOnly = GetPrivateProfileInt(TEXT("Media"), TEXT("Build_BrandingOnly"), 0, g_szCustIns);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKDL)))
                        CheckDlgButton(hDlg, IDC_CHECKDL, g_fDownload ? BST_CHECKED : BST_UNCHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKCD)))
                        CheckDlgButton(hDlg, IDC_CHECKCD, g_fCD ? BST_CHECKED : BST_UNCHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKLAN)))
                        CheckDlgButton(hDlg, IDC_CHECKLAN, g_fLAN ? BST_CHECKED : BST_UNCHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKSDB)))
                        CheckDlgButton(hDlg, IDC_CHECKSDB, g_fBrandingOnly ? BST_CHECKED : BST_UNCHECKED);

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    g_fDownload = g_fCD = g_fLAN = g_fBrandingOnly = FALSE;

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKDL)))
                        g_fDownload = (IsDlgButtonChecked(hDlg, IDC_CHECKDL) == BST_CHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKCD)))
                        g_fCD = (IsDlgButtonChecked(hDlg, IDC_CHECKCD) == BST_CHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKLAN)))
                        g_fLAN = (IsDlgButtonChecked(hDlg, IDC_CHECKLAN) == BST_CHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKSDB)))
                        g_fBrandingOnly = (IsDlgButtonChecked(hDlg, IDC_CHECKSDB) == BST_CHECKED);

                    // if none of the media boxes are selected, display an error msg
                    if (!g_fDownload  &&  !g_fCD  &&  !g_fLAN  &&  !g_fBrandingOnly)
                    {
                        ErrorMessageBox(hDlg, IDS_NOMEDIA);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    WritePrivateProfileString(TEXT("Media"), TEXT("Build_Download"),     g_fDownload     ? TEXT("1") : TEXT("0"), g_szCustIns );
                    WritePrivateProfileString(TEXT("Media"), TEXT("Build_CD"),           g_fCD           ? TEXT("1") : TEXT("0"), g_szCustIns );
                    WritePrivateProfileString(TEXT("Media"), TEXT("Build_LAN"),          g_fLAN          ? TEXT("1") : TEXT("0"), g_szCustIns );
                    WritePrivateProfileString(TEXT("Media"), TEXT("Build_BrandingOnly"), g_fBrandingOnly ? TEXT("1") : TEXT("0"), g_szCustIns );

                    s_fNext = (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? FALSE : TRUE;

                    g_iCurPage = PPAGE_MEDIA;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

void DisplayBitmap(HWND hControl, LPCTSTR pcszFileName, int nBitmapId)
{
    HANDLE hBmp = (HANDLE) GetWindowLongPtr(hControl, GWLP_USERDATA);

    if(ISNONNULL(pcszFileName) && PathFileExists(pcszFileName))
        ShowBitmap(hControl, pcszFileName, 0, &hBmp);
    else
        ShowBitmap(hControl, TEXT(""), nBitmapId, &hBmp);

    SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR)hBmp);
}

void ReleaseBitmap(HWND hControl)
{
    HANDLE hBmp = (HANDLE) GetWindowLongPtr(hControl, GWLP_USERDATA);

    if (hBmp)
        DeleteObject(hBmp);
}

void InitializeAnimBmps(HWND hDlg, LPCTSTR szInsFile)
{
    TCHAR szBig[MAX_PATH];
    TCHAR szSmall[MAX_PATH];
    BOOL fBrandBmps;

    // load information from ins file
    fBrandBmps = InsGetString(IS_ANIMATION, TEXT("Big_Path"),
        szBig, countof(szBig), szInsFile);
    SetDlgItemTextTriState(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP, szBig, fBrandBmps);

    InsGetString(IS_ANIMATION, TEXT("Small_Path"),
        szSmall, countof(szSmall), szInsFile, NULL, &fBrandBmps);
    SetDlgItemTextTriState(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, szSmall, fBrandBmps);

    EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandBmps);
    EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandBmps);
}


//
//  FUNCTION: CustIcon(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "Work Habits" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
INT_PTR CALLBACK CustIcon( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    TCHAR szBig[MAX_PATH];
    TCHAR szSmall[MAX_PATH];
    TCHAR szLargeBmp[MAX_PATH];
    TCHAR szSmallBmp[MAX_PATH];

    LPDRAWITEMSTRUCT lpDrawItem = NULL;
    TCHAR szWorkDir[MAX_PATH];
    BOOL fBrandBmps,fBrandAnim;

    switch( msg )
    {
    case WM_INITDIALOG:
        //from anim
        EnableDBCSChars(hDlg, IDE_SMALLANIMBITMAP);
        EnableDBCSChars(hDlg, IDE_BIGANIMBITMAP);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP), countof(szSmallBmp) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BIGANIMBITMAP), countof(szLargeBmp) - 1);
        
        //custicon
        EnableDBCSChars(hDlg, IDC_BITMAP);
        EnableDBCSChars(hDlg, IDC_BITMAP2);
        Edit_LimitText(GetDlgItem(hDlg, IDC_BITMAP), countof(szBig) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_BITMAP2), countof(szSmall) - 1);
        g_hWizard = hDlg;
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_BROWSEBIG:
                GetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeBmp, countof(szLargeBmp));
                if(BrowseForFile(hDlg, szLargeBmp, countof(szLargeBmp), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeBmp);
                break;

            case IDC_BROWSESMALL:
                GetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp, countof(szSmallBmp));
                if(BrowseForFile(hDlg, szSmallBmp, countof(szSmallBmp), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp);
                break;

            case IDC_ANIMBITMAP:
                fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandAnim);
                EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandAnim);
                break;

            case IDC_BROWSEICON:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    GetDlgItemText(hDlg, IDC_BITMAP, szBig, countof(szBig));
                    if(BrowseForFile(hDlg, szBig, countof(szBig), GFN_BMP))
                        SetDlgItemText(hDlg, IDC_BITMAP, szBig);
                    break;
                }
                return FALSE;

            case IDC_BROWSEICON2:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    GetDlgItemText(hDlg, IDC_BITMAP2, szSmall, countof(szSmall));
                    if(BrowseForFile(hDlg, szSmall, countof(szSmall), GFN_BMP))
                        SetDlgItemText(hDlg, IDC_BITMAP2, szSmall);
                    break;
                }
                return FALSE;

            case IDC_BITMAPCHECK:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);
                    EnableDlgItem2(hDlg, IDC_BITMAP, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BROWSEICON, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_LARGEBITMAP_TXT, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BROWSEICON2, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BITMAP2, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_SMALLBITMAP_TXT, fBrandBmps);
                    break;
                }
                return FALSE;

            default:
                return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {

            case PSN_HELP:
                IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                break;

            case PSN_SETACTIVE:
                SetBannerText(hDlg);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

                // load information from ins file
                InitializeAnimBmps(hDlg, g_szCustIns);

                InsGetString(IS_SMALLLOGO, TEXT("Path"),
                    szSmall, countof(szSmall), g_szCustIns);
                InsGetString(IS_LARGELOGO, TEXT("Path"),
                    szBig, countof(szBig), g_szCustIns, NULL, &fBrandBmps);

                SetDlgItemTextTriState(hDlg, IDC_BITMAP2, IDC_BITMAPCHECK, szSmall, fBrandBmps);
                SetDlgItemTextTriState(hDlg, IDC_BITMAP, IDC_BITMAPCHECK, szBig, fBrandBmps);
                EnableDlgItem2(hDlg, IDC_BROWSEICON, fBrandBmps);
                EnableDlgItem2(hDlg, IDC_BROWSEICON2, fBrandBmps);
                EnableDlgItem2(hDlg, IDC_LARGEBITMAP_TXT, fBrandBmps);
                EnableDlgItem2(hDlg, IDC_SMALLBITMAP_TXT, fBrandBmps);
                {
                    TCHAR szTmp[MAX_PATH];

                    if (ISNONNULL(szSmall))
                    {
                        PathCombine(szTmp, g_szTempSign, PathFindFileName(szSmall));
                        DeleteFile(szTmp);
                    }
                    if (ISNONNULL(szBig))
                    {
                        PathCombine(szTmp, g_szTempSign, PathFindFileName(szBig));
                        DeleteFile(szTmp);
                    }
                }

                CheckBatchAdvance(hDlg);
                break;

            case PSN_WIZNEXT:
            case PSN_WIZBACK:
                //from animbmp
                g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szWorkDir);

                GetDlgItemTextTriState(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, szSmallBmp,
                    countof(szSmallBmp));

                fBrandAnim = GetDlgItemTextTriState(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP,
                    szLargeBmp, countof(szLargeBmp));

                if ((fBrandAnim && !IsAnimBitmapFileValid(hDlg, IDE_BIGANIMBITMAP, szLargeBmp, NULL, IDS_TOOBIG38, IDS_TOOSMALL38, 38, 38)) ||
                    !CopyAnimBmp(hDlg, szLargeBmp, szWorkDir, IK_LARGEBITMAP, TEXT("Big_Path"), g_szCustIns))
                {
                    SetFocus(GetDlgItem(hDlg, IDE_BIGANIMBITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                if ((fBrandAnim && !IsAnimBitmapFileValid(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp, NULL, IDS_TOOBIG22, IDS_TOOSMALL22, 22, 22)) ||
                    !CopyAnimBmp(hDlg, szSmallBmp, szWorkDir, IK_SMALLBITMAP, TEXT("Small_Path"), g_szCustIns))
                {
                    SetFocus(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                if ((fBrandAnim && ISNULL(szSmallBmp) && ISNONNULL(szLargeBmp)) || (fBrandAnim && ISNONNULL(szSmallBmp) && ISNULL(szLargeBmp)))
                {
                    ErrorMessageBox(hDlg, IDS_BOTHBMP_ERROR);
                    if (ISNULL(szSmallBmp))
                        SetFocus(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP));
                    else
                        SetFocus(GetDlgItem(hDlg, IDE_BIGANIMBITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                InsWriteBool(IS_ANIMATION, IK_DOANIMATION, fBrandAnim, g_szCustIns);

                //custicon
                fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);
                //----- Validate the bitmap -----
                GetDlgItemText(hDlg, IDC_BITMAP2, szSmall, countof(szSmall));
                if (fBrandBmps && !IsBitmapFileValid(hDlg, IDC_BITMAP2, szSmall, NULL, 22, 22, IDS_TOOBIG22, IDS_TOOSMALL22))
                {
                    SetFocus(GetDlgItem(hDlg, IDC_BITMAP2));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                CopyLogoBmp(hDlg, szSmall, IS_SMALLLOGO, szWorkDir, g_szCustIns);

                GetDlgItemText(hDlg, IDC_BITMAP, szBig, countof(szBig));
                if (fBrandBmps && !IsBitmapFileValid(hDlg, IDC_BITMAP, szBig, NULL, 38, 38, IDS_TOOBIG38, IDS_TOOSMALL38))
                {
                    SetFocus(GetDlgItem(hDlg, IDC_BITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                CopyLogoBmp(hDlg, szBig, IS_LARGELOGO, szWorkDir, g_szCustIns);

                if ((fBrandBmps && ISNULL(szSmall) && ISNONNULL(szBig)) || (fBrandBmps && ISNONNULL(szSmall) && ISNULL(szBig)))
                {
                    ErrorMessageBox(hDlg, IDS_BOTHBMP_ERROR);
                    if (ISNULL(szSmall))
                        SetFocus(GetDlgItem(hDlg, IDC_BITMAP2));
                    else
                        SetFocus(GetDlgItem(hDlg, IDC_BITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                g_iCurPage = PPAGE_CUSTICON;
                EnablePages();
                if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    PageNext(hDlg);
                else
                    PagePrev(hDlg);
                break;

            case PSN_QUERYCANCEL:
                QueryCancel(hDlg);
                break;

            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK Favorites(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR      szWorkDir[MAX_PATH],
               szValue[16],
               szUrl[INTERNET_MAX_URL_LENGTH];
    HWND       hTv = GetDlgItem(hDlg, IDC_TREE1);
    LPCTSTR    pszValue;
    BOOL       fQL,
               fFavoritesOnTop, fFavoritesDelete, fIEAKFavoritesDelete;
    DWORD      dwFavoritesDeleteFlags;

    switch(msg) {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_TREE1);

        MigrateFavorites(g_szCustIns);
#ifdef UNICODE
        TreeView_SetUnicodeFormat(hTv, TRUE);
#else
        TreeView_SetUnicodeFormat(hTv, FALSE);
#endif
        g_hWizard = hDlg;
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam)) {
        case BN_CLICKED:
            switch(LOWORD(wParam)) {
            case IDC_FAVONTOP:
                if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_FAVONTOP)) {
                    HTREEITEM hti;
                    TV_ITEM   tvi;

                    EnableDlgItem(hDlg, IDC_FAVONTOP);

                    hti = TreeView_GetSelection(hTv);
                    if (hti != NULL) {
                        ZeroMemory(&tvi, sizeof(tvi));
                        tvi.mask  = TVIF_STATE;
                        tvi.hItem = hti;
                        TreeView_GetItem(hTv, &tvi);

                        if (!HasFlag(tvi.state, TVIS_BOLD)) {
                            EnableDlgItem2(hDlg, IDC_FAVUP,   (NULL != TreeView_GetPrevSibling(hTv, hti)));
                            EnableDlgItem2(hDlg, IDC_FAVDOWN, (NULL != TreeView_GetNextSibling(hTv, hti)));
                        }
                    }
                }
                else {
                    DisableDlgItem(hDlg, IDC_FAVUP);
                    DisableDlgItem(hDlg, IDC_FAVDOWN);
                }
                break;

            case IDC_DELFAVORITES:
                fFavoritesDelete = (IsDlgButtonChecked(hDlg, IDC_DELFAVORITES) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDC_DELIEAKFAVORITES, fFavoritesDelete);
                break;

            case IDC_FAVUP:
                MoveUpFavorite(hTv, TreeView_GetSelection(hTv));
                break;

            case IDC_FAVDOWN:
                MoveDownFavorite(hTv, TreeView_GetSelection(hTv));
                break;

            case IDC_ADDURL:
                fQL = !IsFavoriteItem(hTv, TreeView_GetSelection(hTv));
                if (GetFavoritesNumber(hTv, fQL) >= GetFavoritesMaxNumber(fQL)) {
                    UINT nID;

                    nID = (!fQL ? IDS_ERROR_MAXFAVS : IDS_ERROR_MAXQLS);
                    ErrorMessageBox(hDlg, nID);
                    break;
                }

                g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
                NewUrl(hTv, szWorkDir, g_dwPlatformId, g_fIntranet ? IEM_CORP : IEM_NEUTRAL);
                break;

            case IDC_ADDFOLDER:
                ASSERT(IsFavoriteItem(hTv, TreeView_GetSelection(hTv)));
                if (GetFavoritesNumber(hTv) >= GetFavoritesMaxNumber()) {
                    ErrorMessageBox(hDlg, IDS_ERROR_MAXFAVS);
                    break;
                }

                NewFolder(hTv);
                break;

            case IDC_MODIFY:
                g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
                ModifyFavorite(hTv, TreeView_GetSelection(hTv), szWorkDir, g_szTempSign, g_dwPlatformId, g_fIntranet ? IEM_CORP : IEM_NEUTRAL);
                break;

            case IDC_REMOVE:
                g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
                DeleteFavorite(hTv, TreeView_GetSelection(hTv), szWorkDir);
                break;

            case IDC_TESTFAVURL:
                if (GetFavoriteUrl(hTv, TreeView_GetSelection(hTv), szUrl, countof(szUrl)))
                    TestURL(szUrl);
                break;

            case IDC_IMPORT: {
                CNewCursor cursor(IDC_WAIT);

                g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
                ImportFavoritesCmd(hTv, szWorkDir);
                break;
                }
            }
        }
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

            g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
            PathCreatePath(szWorkDir);

            ASSERT(GetFavoritesNumber(hTv, FALSE) == 0 && GetFavoritesNumber(hTv, TRUE) == 0);
            ImportFavorites (hTv, g_szDefInf, g_szCustIns, szWorkDir, g_szTempSign, !g_fIntranet);
            ImportQuickLinks(hTv, g_szDefInf, g_szCustIns, szWorkDir, g_szTempSign, !g_fIntranet);

            TreeView_SelectItem(hTv, TreeView_GetRoot(hTv));

            fFavoritesOnTop = GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_ONTOP, (int)FALSE, g_szCustIns);
            CheckDlgButton(hDlg, IDC_FAVONTOP, fFavoritesOnTop ? BST_CHECKED : BST_UNCHECKED);

            //delete channels checkbox
            if (g_fIntranet)
            {
                EnableDlgItem(hDlg, IDC_DELETECHANNELS);
                ShowDlgItem  (hDlg, IDC_DELETECHANNELS);
                ReadBoolAndCheckButton(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, g_szCustIns, hDlg, IDC_DELETECHANNELS);
            }
            else
            {
                DisableDlgItem(hDlg, IDC_DELETECHANNELS);
                HideDlgItem   (hDlg, IDC_DELETECHANNELS);
            }

            if (!fFavoritesOnTop) {
                DisableDlgItem(hDlg, IDC_FAVUP);
                DisableDlgItem(hDlg, IDC_FAVDOWN);
            }

            if (g_fIntranet) {
                ShowWindow(GetDlgItem(hDlg, IDC_DELFAVORITES),     SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_DELIEAKFAVORITES), SW_SHOW);

                dwFavoritesDeleteFlags = (DWORD) GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_DELETE, (int)FD_DEFAULT, g_szCustIns);

                fFavoritesDelete = HasFlag(dwFavoritesDeleteFlags, ~FD_REMOVE_IEAK_CREATED);
                CheckDlgButton(hDlg, IDC_DELFAVORITES, fFavoritesDelete ? BST_CHECKED : BST_UNCHECKED);

                fIEAKFavoritesDelete = HasFlag(dwFavoritesDeleteFlags, FD_REMOVE_IEAK_CREATED);
                CheckDlgButton(hDlg, IDC_DELIEAKFAVORITES, fIEAKFavoritesDelete ? BST_CHECKED : BST_UNCHECKED);

                // only if delete Favorites is TRUE should the delete IEAK Favorites checkbox be enabled
                EnableDlgItem2(hDlg, IDC_DELIEAKFAVORITES, fFavoritesDelete);
            }
            else {
                ShowWindow(GetDlgItem(hDlg, IDC_DELFAVORITES),     SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_DELIEAKFAVORITES), SW_HIDE);
            }
            
            CheckBatchAdvance(hDlg);
            break;

        case TVN_GETINFOTIP:
            ASSERT(wParam == IDC_TREE1);
            GetFavoritesInfoTip((LPNMTVGETINFOTIP)lParam);
            break;

        case NM_DBLCLK:
            ASSERT(wParam == IDC_TREE1);
            if (IsWindowEnabled(GetDlgItem(hDlg, IDC_MODIFY)))
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_MODIFY, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_MODIFY));
            break;

        case TVN_KEYDOWN:
            ASSERT(wParam == IDC_TREE1);
            if (((LPNMTVKEYDOWN)lParam)->wVKey == VK_DELETE && IsWindowEnabled(GetDlgItem(hDlg, IDC_REMOVE)))
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_REMOVE, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_REMOVE));
            break;

        case TVN_SELCHANGED:
            ASSERT(wParam == IDC_TREE1);
            ProcessFavSelChange(hDlg, hTv, (LPNMTREEVIEW)lParam);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            fFavoritesOnTop = (IsDlgButtonChecked(hDlg, IDC_FAVONTOP) == BST_CHECKED);

            dwFavoritesDeleteFlags = 0;
            szValue[0]             = TEXT('\0');
            pszValue               = NULL;
            fFavoritesDelete       = (IsDlgButtonChecked(hDlg, IDC_DELFAVORITES)     == BST_CHECKED);
            fIEAKFavoritesDelete   = (IsDlgButtonChecked(hDlg, IDC_DELIEAKFAVORITES) == BST_CHECKED);

            if (fFavoritesDelete) {
                // NOTE. (andrewgu) flags explanation:
                // 1. FD_FAVORITES        means "empty favorites";
                // 2. FD_CHANNELS         means "don't delete channels folder";
                // 3. FD_SOFTWAREUPDATES  means "don't delete sofware updates folder";
                // 4. FD_QUICKLINKS       means "don't delete quick links folder";
                // 5. FD_EMPTY_QUICKLINKS means "but make it empty";
                // 6. FD_REMOVE_HIDDEN    means "don't hesitate to party on HIDDEN folders and favorites";
                // 7. FD_REMOVE_SYSTEM    means "don't hesitate to party on SYSTEM folders and favorites";
                dwFavoritesDeleteFlags |= FD_FAVORITES      |
                    FD_CHANNELS        | FD_SOFTWAREUPDATES | FD_QUICKLINKS | FD_EMPTY_QUICKLINKS |
                    FD_REMOVE_HIDDEN   | FD_REMOVE_SYSTEM;
            }

            //delete channels
            if (g_fIntranet)
                CheckButtonAndWriteBool(hDlg, IDC_DELETECHANNELS, IS_DESKTOPOBJS, IK_DELETECHANNELS, g_szCustIns);
            
            if (fIEAKFavoritesDelete)
                // FD_REMOVE_IEAK_CREATED means "delete those items created by the IEAK";
                dwFavoritesDeleteFlags |= FD_REMOVE_IEAK_CREATED;

            if (dwFavoritesDeleteFlags) {
                wnsprintf(szValue, countof(szValue), TEXT("0x%X"), dwFavoritesDeleteFlags);
                pszValue = szValue;
            }

            WritePrivateProfileString(IS_BRANDING, IK_FAVORITES_DELETE, pszValue, g_szCustIns);
            WritePrivateProfileString(IS_BRANDING, IK_FAVORITES_ONTOP, fFavoritesOnTop ? TEXT("1") : TEXT("0"), g_szCustIns);

            g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
            ExportFavorites (hTv, g_szCustIns, szWorkDir, TRUE);
            ExportQuickLinks(hTv, g_szCustIns, szWorkDir, TRUE);

            if (!g_fBatch)
            {
                // (pritobla) if in batch mode, no need to export to the old IE4 format
                // because there is no scenario that the ms install.ins will be installed
                // without the IE6 branding dll.
                MigrateToOldFavorites(g_szCustIns);
            }

            DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);
            DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);

            g_iCurPage = PPAGE_FAVORITES;
            EnablePages();
            if (((LPNMHDR)lParam)->code != PSN_WIZBACK)
                PageNext(hDlg);
            else
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            if (QueryCancel(hDlg)) {
                DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);
                DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);
            }
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//
//  FUNCTION: Welcome(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for welcome page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
INT_PTR CALLBACK Welcome(
    HWND hDlg,
    UINT message,
    WPARAM,
    LPARAM lParam)
{
    static fInitWindowPos = FALSE;

    switch (message)
    {
        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_INITDIALOG:
            LoadString(g_rvInfo.hInst, IDS_TITLE, g_szTitle, countof(g_szTitle));
            SetWindowText(g_hWndCent, g_szTitle);
            g_hWizard = hDlg;
            return(TRUE);

            case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    TCHAR szWizardVer[MAX_PATH];
                    TCHAR szType[MAX_PATH];
                    TCHAR  szTemp1[MAX_PATH], szTemp2[MAX_PATH];

                    SetBannerText(hDlg);

                    LoadString(g_rvInfo.hInst,IDS_WIZARDTYPETEXT,szWizardVer,countof(szWizardVer));
                    switch (s_iType)
                    {
                        case BRANDED:
                            LoadString(g_rvInfo.hInst,IDS_ISPTYPE,szType,countof(szType));
                            break;
                        case REDIST:
                            LoadString(g_rvInfo.hInst,IDS_ICPTYPE,szType,countof(szType));
                            break;
                        case INTRANET:
                        default:
                            LoadString(g_rvInfo.hInst,IDS_CORPTYPE,szType,countof(szType));
                            break;
                    }   

                    wnsprintf(szTemp1,countof(szTemp1),szWizardVer,szType);
                    wnsprintf(szTemp2,countof(szTemp2),s_szBannerText,szTemp1);

                    StrCpy(s_szBannerText,szTemp2);
                    
                    ChangeBannerText(hDlg);
                    PropSheet_SetTitle(hDlg, 0, s_aSzTitle[g_iCurPage]);
                    if (g_fDone)
                    {
                        EndDialog(hDlg, 0);
                        return FALSE;
                    }
                    if(!fInitWindowPos)
                    {
                        PositionWindow(GetParent(hDlg));
                        ShowWindow(GetParent(hDlg), SW_SHOWNORMAL);
                        fInitWindowPos = TRUE;
                    }
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;
            }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: Stage(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for welcome page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
INT_PTR CALLBACK Stage(
    HWND hDlg,
    UINT message,
    WPARAM,
    LPARAM lParam)
{
    switch (message)
    {
        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_INITDIALOG:
            return(FALSE);

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    PropSheet_SetTitle(hDlg, 0, s_aSzTitle[g_iCurPage]);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                        PageNext(hDlg);
                    else
                        PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;
            }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

static UINT_PTR s_idTim;

INT_PTR CALLBACK BrandTitle(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szFullTitle[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    DWORD dwTitlePrefixLen;
    BOOL  fTitle;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_TITLE);

        LoadString(g_rvInfo.hInst, IDS_TITLE_PREFIX, szTitle, countof(szTitle));
        dwTitlePrefixLen = StrLen(szTitle);
        // browser will only display 74 chars before cutting off title
        Edit_LimitText(GetDlgItem(hDlg, IDE_TITLE), 74 - dwTitlePrefixLen);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

            // title
            InsGetString(IS_BRANDING, TEXT("Window_Title_CN"), szTitle, countof(szTitle), 
                g_szCustIns, NULL, &fTitle);
            if (!fTitle  &&  *szTitle == '\0')
                InsGetString(IS_BRANDING, TEXT("CompanyName"), szTitle, countof(szTitle), g_szCustIns);

            SetDlgItemTextTriState(hDlg, IDE_TITLE, IDC_TITLE, szTitle, fTitle);
            EnableDlgItem2(hDlg, IDC_TITLE_TXT, fTitle);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            // title
            if (g_fBatch)
            {
                InsGetString(TEXT("BatchMode"), IK_WINDOWTITLE, szFullTitle, countof(szFullTitle), g_szCustIns);
                InsWriteString(IS_BRANDING, IK_WINDOWTITLE, szFullTitle, g_szCustIns, TRUE, NULL, INSIO_TRISTATE);

                InsGetString(TEXT("BatchMode"), TEXT("Window_Title_OE"), szFullTitle, countof(szFullTitle), g_szCustIns);
                InsWriteString(IS_INTERNETMAIL, IK_WINDOWTITLE, szFullTitle, g_szCustIns, TRUE, NULL, INSIO_TRISTATE);
            }
            else
            {
                fTitle = GetDlgItemTextTriState(hDlg, IDE_TITLE, IDC_TITLE, szTitle, countof(szTitle));
                InsWriteString(IS_BRANDING, TEXT("Window_Title_CN"), szTitle, g_szCustIns, fTitle, NULL, INSIO_SERVERONLY | INSIO_TRISTATE);

                // browser title
                *szFullTitle = TEXT('\0');
                if (*szTitle)
                {
                    *szTemp = TEXT('\0');

                    InsGetString(IS_STRINGS, TEXT("IE_TITLE"), szTemp, countof(szTemp), g_szDefInf);

                    if (*szTemp)
                        wnsprintf(szFullTitle, countof(szFullTitle), szTemp, szTitle);
                }
                InsWriteString(IS_BRANDING, IK_WINDOWTITLE, szFullTitle, g_szCustIns, fTitle, NULL, INSIO_TRISTATE);

                // OE title
                *szFullTitle = TEXT('\0');
                if (*szTitle)
                {
                    *szTemp = TEXT('\0');

                    InsGetString(IS_STRINGS, TEXT("OE_TITLE"), szTemp, countof(szTemp), g_szDefInf);

                    if (*szTemp)
                        wnsprintf(szFullTitle, countof(szFullTitle), szTemp, szTitle);
                }
                InsWriteString(IS_INTERNETMAIL, IK_WINDOWTITLE, szFullTitle, g_szCustIns, fTitle, NULL, INSIO_TRISTATE);
            }

            g_iCurPage = PPAGE_TITLE;
            EnablePages();
            (((LPNMHDR) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_TITLE:
            fTitle = (IsDlgButtonChecked(hDlg, IDC_TITLE) == BST_CHECKED);
            EnableDlgItem2(hDlg, IDC_TITLE_TXT, fTitle);
            EnableDlgItem2(hDlg, IDE_TITLE,     fTitle);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK WelcomeMessageDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szInitHomePage[INTERNET_MAX_URL_LENGTH];
    INT   id;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_WELCOMEURL);
        Edit_LimitText(GetDlgItem(hDlg, IDE_WELCOMEURL), countof(szInitHomePage) - 1);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

            g_fUseIEWelcomePage = !InsGetBool(IS_URL, IK_NO_WELCOME_URL, FALSE, g_szCustIns);
            InsGetString(IS_URL, IK_FIRSTHOMEPAGE, szInitHomePage, countof(szInitHomePage), g_szCustIns);

            if (g_fUseIEWelcomePage)
                id = IDC_WELCOMEDEF;
            else
                id = (*szInitHomePage ? IDC_WELCOMECUST : IDC_WELCOMENO);

            CheckRadioButton(hDlg, IDC_WELCOMEDEF, IDC_WELCOMECUST, id);

            if (id == IDC_WELCOMECUST)
            {
                SetDlgItemText(hDlg, IDE_WELCOMEURL, szInitHomePage);
                EnableDlgItem (hDlg, IDE_WELCOMEURL);
            }
            else
                DisableDlgItem(hDlg, IDE_WELCOMEURL);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            // if custom home page radio button is checked, verify that a URL is specified
            if (IsDlgButtonChecked(hDlg, IDC_WELCOMECUST) == BST_CHECKED)
                if (!CheckField(hDlg, IDE_WELCOMEURL, FC_NONNULL | FC_URL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }

            g_fUseIEWelcomePage = (IsDlgButtonChecked(hDlg, IDC_WELCOMEDEF) == BST_CHECKED);
            InsWriteBool(IS_URL, IK_NO_WELCOME_URL, !g_fUseIEWelcomePage, g_szCustIns);

            GetDlgItemText(hDlg, IDE_WELCOMEURL, szInitHomePage, countof(szInitHomePage));
            InsWriteString(IS_URL, IK_FIRSTHOMEPAGE, szInitHomePage, g_szCustIns);

            g_iCurPage = PPAGE_WELCOMEMSGS;
            EnablePages();
            (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_WELCOMENO:
        case IDC_WELCOMEDEF:
            SetDlgItemText(hDlg, IDE_WELCOMEURL, TEXT(""));
            DisableDlgItem(hDlg, IDE_WELCOMEURL);
            break;

        case IDC_WELCOMECUST:
            EnableDlgItem(hDlg, IDE_WELCOMEURL);
            break;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void LoadInsFile(LPCTSTR pcszNewInsFile)
{
    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDestDir[MAX_PATH];
    TCHAR szPlatform[8];
    TCHAR szFilePath[MAX_PATH];
    TCHAR szData[8];

    CopyFile(pcszNewInsFile, g_szCustIns, FALSE);

    SetFileAttributes(g_szCustIns, FILE_ATTRIBUTE_NORMAL);
    StrCpy(szSrcPath, pcszNewInsFile);
    PathRemoveFileSpec(szSrcPath);
    StrCpy(szDestDir, g_szCustIns);
    PathRemoveFileSpec(szDestDir);

    // make sure platform info is correct

    wnsprintf(szPlatform, countof(szPlatform), TEXT("%lu"), g_dwPlatformId);
    WritePrivateProfileString(BRANDING, TEXT("Platform"), szPlatform, g_szCustIns);

    // the delete adms flag will be cleared out when we hit next on the adm page

    WritePrivateProfileString(IS_BRANDING, TEXT("DeleteAdms"), TEXT("1"), g_szCustIns);
    WritePrivateProfileString(IS_BRANDING, TEXT("ImportIns"), pcszNewInsFile, g_szCustIns);

    // branding.cab file is cross platform

    CopyFilesSrcToDest(szSrcPath, TEXT("BRANDING.CAB"), szDestDir);

    PathCombine(szFilePath, szSrcPath, TEXT("iesetup.inf"));

    // only copy over iesetup.inf if it's also a win32 inf
    if (GetPrivateProfileString(OPTIONS, TEXT("CifName"), TEXT(""), szData, countof(szData), szFilePath))
        CopyFilesSrcToDest(szSrcPath, TEXT("iesetup.inf"), szDestDir);


    CopyFilesSrcToDest(szSrcPath, TEXT("iak.ini"), szDestDir);
    CopyFilesSrcToDest(szSrcPath, TEXT("iesetup.cif"), szDestDir);
    CopyFilesSrcToDest(szSrcPath, TEXT("custom.cif"), szDestDir);
    CopyFilesSrcToDest(szSrcPath, TEXT("DESKTOP.CAB"), szDestDir);
    CopyFilesSrcToDest(szSrcPath, TEXT("CHNLS.CAB"), szDestDir);
    SetAttribAllEx(szDestDir, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, FALSE);

    // clear out CMAK guid when importing so we'll generate a new one for this package

    PathCombine(szFilePath, szDestDir, TEXT("custom.cif"));
    WritePrivateProfileString( CUSTCMSECT, TEXT("GUID"), NULL, szFilePath );
    WritePrivateProfileString( CUSTCMSECT, VERSION, NULL, szFilePath );

    // copy singup files
    // BUGBUG: pritobla- should implement a function in ieakutil to xcopy a folder (including its subdirs)
    //                   to another location and use that function here.
    PathAppend(szSrcPath, TEXT("signup"));
    PathAppend(szDestDir, TEXT("signup"));

    PathAppend(szSrcPath, TEXT("icw"));
    PathAppend(szDestDir, TEXT("icw"));
    CopyFilesSrcToDest(szSrcPath, TEXT("*.*"), szDestDir);

    PathRemoveFileSpec(szSrcPath);
    PathRemoveFileSpec(szDestDir);

    PathAppend(szSrcPath, TEXT("kiosk"));
    PathAppend(szDestDir, TEXT("kiosk"));
    CopyFilesSrcToDest(szSrcPath, TEXT("*.*"), szDestDir);

    PathRemoveFileSpec(szSrcPath);
    PathRemoveFileSpec(szDestDir);

    PathAppend(szSrcPath, TEXT("servless"));
    PathAppend(szDestDir, TEXT("servless"));
    CopyFilesSrcToDest(szSrcPath, TEXT("*.*"), szDestDir);
}

//
//  FUNCTION: Language(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "Language" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
INT_PTR CALLBACK Language(
    HWND hDlg,
    UINT message,
    WPARAM,
    LPARAM lParam)
{
    TCHAR szBuf[1024];
    int i;
    static BOOL s_fNext = TRUE;
    TCHAR szTemp[MAX_PATH];
    DWORD dwSelLangId;

    USES_CONVERSION;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            InitSysFont( hDlg, IDC_LANGUAGE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            //from the download pg
            if (!g_fUrlsInit && !g_fBatch && !g_fBatch2 && !g_hWait && g_hDownloadEvent && !g_fLocalMode)
            {
                g_hWizard = hDlg;
                g_hWait = CreateDialog( g_rvInfo.hInst, MAKEINTRESOURCE(IDD_WAITSITES), hDlg,
                     DownloadStatusDlgProc );
                ShowWindow( g_hWait, SW_SHOWNORMAL );
                PropSheet_SetWizButtons(GetParent(hDlg), 0 );
                g_iDownloadState = DOWN_STATE_ENUM_URL;
                g_hDlg = hDlg;
                SetEvent(g_hDownloadEvent);
            }

            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case IDM_INITIALIZE:
            if (g_hWait && g_fLangInit)
            {
                SendMessage(g_hWait, WM_CLOSE, 0, 0);
                g_hWait = NULL;
            }
            break;

        // this resets the focus away from cancel when we disable back/next

        case IDM_SETDEFBUTTON:
            SetFocus( GetDlgItem( GetParent(hDlg), IDC_STATIC ) );
            SendMessage(GetParent(hDlg), DM_SETDEFID, (WPARAM)IDC_STATIC, (LPARAM)0);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!g_fLangInit && !g_fBatch && !g_fBatch2)
                    {
                        DWORD dwTid;
                        g_iDownloadState = DOWN_STATE_ENUM_LANG;
                        g_hDlg = hDlg;
                        PropSheet_SetWizButtons(GetParent(hDlg), 0);
                        if (!g_fLocalMode)
                        {
                            g_hWait = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_WAITSITES), hDlg,
                                DownloadStatusDlgProc);
                            ShowWindow( g_hWait, SW_SHOWNORMAL );
                        }
                        g_hThread = CreateThread(NULL, 4096, DownloadSiteThreadProc, &g_hWizard, 0, &dwTid);
                        PostMessage(hDlg, IDM_SETDEFBUTTON, 0, 0);
                        break;
                    }

                    if (g_fOptCompInit)
                        DisableDlgItem(hDlg, IDC_LANGUAGE);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    if (!g_nLangs && !g_fBatch && !g_fBatch2)
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        g_fCancelled = FALSE;
                        return(TRUE);
                    }
                    
                    //original processing

                    dwSelLangId = 1033;
                    if (!g_fBatch && !g_fBatch2)
                    {
                        i = (int) SendDlgItemMessage( hDlg, IDC_LANGUAGE, CB_GETCURSEL, 0, 0 );

                        StrCpy(g_szLanguage + 1, g_aszLang[i]);
                        *g_szLanguage = g_szLanguage[3] = TEXT('\\');
                        g_szLanguage[4] = TEXT('\0');
                        dwSelLangId = g_aLangId[i];

                        if (StrCmpI(g_szActLang, g_aszLang[i]) != 0)
                        {
                            s_fAppendLang = TRUE;
                            g_fSrcDirChanged = TRUE;
                            StrCpy(g_szActLang, g_aszLang[i]);
                        }
                        if (s_fAppendLang)
                        {
                            PathCombine(g_szIEAKProg, s_szSourceDir, &g_szLanguage[1]);
                            if (!PathFileExists(g_szIEAKProg))
                                PathCreatePath(g_szIEAKProg);
                            s_fAppendLang = FALSE;
                        }
                    }
                    CharUpper(g_szLanguage);
                    CharUpper(g_szActLang);

                    StrCpy(szBuf, g_szLanguage + 1);
                    szBuf[lstrlen(szBuf) - 1] = TEXT('\0');

                    GenerateCustomIns();

                    if (ISNONNULL(g_szLoadedIns) && s_fLoadIns)
                    {
                        TCHAR szLoadLang[8];

                        s_fLoadIns = FALSE;
                        if (GetPrivateProfileString(IS_BRANDING, LANG_LOCALE, TEXT(""),
                            szLoadLang, countof(szLoadLang), g_szLoadedIns) && (StrCmpI(szLoadLang, g_szActLang) != 0))
                        {
                            TCHAR szMsgParam[MAX_PATH];
                            TCHAR szMsg[MAX_PATH*2];

                            LoadString(g_rvInfo.hInst, IDS_LANGDIFFERS, szMsgParam, countof(szMsgParam));
                            wnsprintf(szMsg, countof(szMsg), szMsgParam, g_szLoadedIns);

                            if (MessageBox(hDlg, szMsg, g_szTitle, MB_YESNO) == IDNO)
                            {
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                return TRUE;
                            }
                        }

                        LoadInsFile(g_szLoadedIns);
                    }

                    wnsprintf(s_szType, countof(s_szType), TEXT("%i"), s_iType);
                    WritePrivateProfileString(BRANDING, TEXT("Type"), s_szType, g_szCustIns);
                    WritePrivateProfileString( BRANDING, IK_WIZVERSION, A2CT(VER_PRODUCTVERSION_STR), g_szCustIns );
                    //clear others so we know this is wizard
                    WritePrivateProfileString(BRANDING, PMVERKEY, NULL, g_szCustIns);
                    WritePrivateProfileString(BRANDING, GPVERKEY, NULL, g_szCustIns);
                    StrCpy(szTemp, g_szKey);
                    szTemp[7] = TEXT('\0');
                    WritePrivateProfileString( BRANDING, TEXT("Custom_Key"), szTemp, g_szCustIns );
                    if (*(g_rvInfo.pszName) == 0)
                        GetPrivateProfileString(BRANDING, TEXT("CompanyName"), TEXT(""), g_rvInfo.pszName, countof(g_rvInfo.pszName), g_szCustIns);
                    WritePrivateProfileString(BRANDING, TEXT("CompanyName"), g_rvInfo.pszName, g_szCustIns);

                    if (g_iKeyType < KEY_TYPE_ENHANCED)
                    {
                        WritePrivateProfileString( TEXT("Animation"), NULL, NULL, g_szCustIns );
                        WritePrivateProfileString( TEXT("Big_Logo"), NULL, NULL, g_szCustIns );
                        WritePrivateProfileString( TEXT("Small_Logo"), NULL, NULL, g_szCustIns );
                    }
                    if (!g_fBatch)
                    {
                        TCHAR szLngID[16];

                        wnsprintf(szLngID, countof(szLngID), TEXT("%lu"), dwSelLangId);
                        WritePrivateProfileString(BRANDING, LANG_LOCALE, g_szActLang, g_szCustIns);
                        WritePrivateProfileString(BRANDING, LANG_ID, szLngID, g_szCustIns);
                    }

                    g_iCurPage = PPAGE_LANGUAGE;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    {
                        s_fNext = FALSE;
                        PageNext(hDlg);
                    }
                    else
                    {
                        s_fNext = TRUE;
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;

        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK StartSearch(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fStartPage, fSearchPage, fSupportPage;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_STARTPAGE);
        EnableDBCSChars(hDlg, IDE_SEARCHPAGE);
        EnableDBCSChars(hDlg, IDE_CUSTOMSUPPORT);

        Edit_LimitText(GetDlgItem(hDlg, IDE_STARTPAGE),     INTERNET_MAX_URL_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SEARCHPAGE),    INTERNET_MAX_URL_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CUSTOMSUPPORT), INTERNET_MAX_URL_LENGTH - 1);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
            case PSN_SETACTIVE:
                SetBannerText(hDlg);

                InitializeStartSearch(hDlg, g_szCustIns, NULL);

                CheckBatchAdvance(hDlg);
                break;

            case PSN_WIZBACK:
            case PSN_WIZNEXT:
                fStartPage   = (IsDlgButtonChecked(hDlg, IDC_STARTPAGE)     == BST_CHECKED);
                fSearchPage  = (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE)    == BST_CHECKED);
                fSupportPage = (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED);

                if ((fStartPage    &&  !CheckField(hDlg, IDE_STARTPAGE,     FC_URL))  ||
                    (fSearchPage   &&  !CheckField(hDlg, IDE_SEARCHPAGE,    FC_URL))  ||
                    (fSupportPage  &&  !CheckField(hDlg, IDE_CUSTOMSUPPORT, FC_URL)))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }

                SaveStartSearch(hDlg, g_szCustIns, NULL);

                g_iCurPage = PPAGE_STARTSEARCH;
                EnablePages();
                (((LPNMHDR) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                break;

            case PSN_HELP:
                IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                break;

            case PSN_QUERYCANCEL:
                QueryCancel(hDlg);
                break;

            default:
                return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_STARTPAGE:
                fStartPage = (IsDlgButtonChecked(hDlg, IDC_STARTPAGE) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_STARTPAGE, fStartPage);
                EnableDlgItem2(hDlg, IDC_STARTPAGE_TXT, fStartPage);
                break;

            case IDC_SEARCHPAGE:
                fSearchPage = (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_SEARCHPAGE, fSearchPage);
                EnableDlgItem2(hDlg, IDC_SEARCHPAGE_TXT, fSearchPage);
                break;

            case IDC_CUSTOMSUPPORT:
                fSupportPage = (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_CUSTOMSUPPORT, fSupportPage);
                EnableDlgItem2(hDlg, IDC_CUSTOMSUPPORT_TXT, fSupportPage);
                break;

            default:
                return FALSE;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK Finish(HWND hDlg, UINT message, WPARAM, LPARAM lParam)
{
    TCHAR szPlatform[8];
    TCHAR szWinDir[MAX_PATH];
    static s_fFinished = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            if (s_fFinished)
                EnableDBCSChars(hDlg, IDC_FINISHTXT3);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!s_fFinished)
                    {
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                        ShowWindow(GetDlgItem(hDlg, IDC_FINISHTXT1), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDC_STEP1), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDC_STEP3), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS), SW_HIDE);
                        CheckBatchAdvance(hDlg);
                    }
                    else
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_FINISHTXT3), g_szBuildRoot);
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

                        if (g_fBatch || g_fBatch2)
                            PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, PSBTN_FINISH, 0);
                    }
                    break;

                case PSN_WIZBACK:
                    PagePrev(hDlg);
                    break;

                case PSN_WIZNEXT:
                    if (!g_fCancelled && !g_fDemo)
                    {
                        CNewCursor cur(IDC_WAIT);
                        HANDLE hThread;
                        DWORD dwTid;

                        wnsprintf(szPlatform, countof(szPlatform), TEXT("%lu"), g_dwPlatformId);
                        WritePrivateProfileString(BRANDING, TEXT("Platform"), szPlatform, g_szCustIns);

                        ShowWindow(GetDlgItem(hDlg, IDC_FINISHTXT1), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDC_STEP1), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDC_STEP3), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS), SW_SHOW);
                        PropSheet_SetWizButtons(GetParent(hDlg), 0);
                        DisableDlgItem(GetParent(hDlg), IDHELP);
                        DisableDlgItem(GetParent(hDlg), IDCANCEL);

                        Animate_Open( GetDlgItem( hDlg, IDC_ANIM ), IDA_GEARS );
                        Animate_Play( GetDlgItem( hDlg, IDC_ANIM ), 0, -1, -1 );

                        SetAttribAllEx(g_szBuildRoot, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);
                        g_fCancelled = TRUE;
                        GetWindowsDirectory(szWinDir, MAX_PATH);
                        memset(&g_shfStruc, 0, sizeof(g_shfStruc));
                        g_shfStruc.hwnd = hDlg;
                        g_shfStruc.wFunc = FO_COPY;
                        SetAttribAllEx(g_szBuildTemp, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);

                        hThread = CreateThread(NULL, 4096, BuildIE4, hDlg, 0, &dwTid);

                        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                        {
                            MSG msg;
                            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }

                        CloseHandle(hThread);

                        // this sets the last 'platform/language' package built in this build directory.
                        // its used to get the settings used in the last .ins file.
                        {
                            TCHAR szPlatformLang[MAX_PATH];
                            TCHAR szRegKey[MAX_PATH];

                            wnsprintf(szRegKey, countof(szRegKey), TEXT("%s\\INS"), RK_IEAK_SERVER);
                            wnsprintf(szPlatformLang, countof(szPlatformLang), TEXT("%s%s"), GetOutputPlatformDir(), g_szActLang);
                            SHSetValue(HKEY_CURRENT_USER, szRegKey, g_szBuildRoot, REG_SZ, (LPBYTE)szPlatformLang,
                                (StrLen(szPlatformLang)+1)*sizeof(TCHAR));
                        }
                    }

                    if (g_fDemo)
                    {
                        TCHAR szMsg[MAX_PATH];
                        SetCurrentDirectory(g_szBuildRoot);
                        PathRemovePath(g_szBuildTemp);
                        LoadString( g_rvInfo.hInst, IDS_ENDEMO, szMsg, countof(szMsg) );
                        MessageBox(hDlg, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
                        g_fDone = TRUE;
                        SetEvent(g_hDownloadEvent);
                    }
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);
                    g_fCancelled = TRUE;
                    s_fFinished = TRUE;
                    break;

                case PSN_WIZFINISH:
                    break;

                case PSN_QUERYCANCEL:
                    if (IsWindowEnabled(GetDlgItem(GetParent(hDlg), IDCANCEL)))
                        QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

#define OLDPRSHTSIZE 0x28
#define OLDPPAGESIZE 0x28

#define SSF_ALL SSF_SHOWALLOBJECTS | SSF_SHOWEXTENSIONS | SSF_SHOWCOMPCOLOR | SSF_SHOWSYSFILES | SSF_DESKTOPHTML | SSF_WIN95CLASSIC

void FillInPropertyPage(int iPsp, WORD idDlg, DLGPROC pfnDlgProc)
{
    LPPROPSHEETPAGE pPsp;
    TCHAR           szPage[MAX_PATH];
    LPDLGTEMPLATE   pDlg;

    if (iPsp < 0 || iPsp > NUM_PAGES)
        return;

    if (idDlg == 0)
        return;

    if (pfnDlgProc == NULL)
        return;

    pDlg = NULL;

    LoadString(g_rvInfo.hInst, IDS_TITLE, szPage, countof(szPage));

    if (iPsp != PPAGE_WELCOME && iPsp != PPAGE_OCWWELCOME && iPsp != PPAGE_FINISH)
    {
        TCHAR szStage[MAX_PATH];

        if (iPsp < PPAGE_STAGE2)
            LoadString(g_rvInfo.hInst, IDS_STAGE1, szStage, countof(szStage));
        else
        {
            if (iPsp < PPAGE_STAGE3)
                LoadString(g_rvInfo.hInst, IDS_STAGE2, szStage, countof(szStage));
            else
            {
                if (iPsp < PPAGE_STAGE4)
                    LoadString(g_rvInfo.hInst, IDS_STAGE3, szStage, countof(szStage));
                else
                {
                    if (iPsp < PPAGE_STAGE5)
                        LoadString(g_rvInfo.hInst, IDS_STAGE4, szStage, countof(szStage));
                    else
                        LoadString(g_rvInfo.hInst, IDS_STAGE5, szStage, countof(szStage));
                }
            }
        }

        StrCpy(s_aSzTitle[iPsp], szStage);
    }
    else
        StrCpy(s_aSzTitle[iPsp], szPage);

    pPsp = &g_psp[iPsp];
    ZeroMemory(pPsp, sizeof(PROPSHEETPAGE));

    pPsp->dwSize      = sizeof(PROPSHEETPAGE);
    pPsp->dwFlags     = PSP_USETITLE | PSP_HASHELP;
    pPsp->hInstance   = g_rvInfo.hInst;
    pPsp->pfnDlgProc  = pfnDlgProc;
    pPsp->pszTitle    = s_aSzTitle[iPsp];
    pPsp->pszTemplate = MAKEINTRESOURCE(idDlg);

/*    if (!IsTahomaFontExist(g_hWndCent))
    {
        pPsp->dwFlags   |= PSP_DLGINDIRECT;
        pPsp->pResource  = pDlg;
    }*/

    s_ahPsp[iPsp] = CreatePropertySheetPage(pPsp);
}

int CreateWizard(HWND hwndOwner)
{
    PROPSHEETHEADER psh;
    LPTSTR pLastSlash;

    GetModuleFileName(GetModuleHandle(NULL), g_szWizPath, MAX_PATH);
    pLastSlash = StrRChr(g_szWizPath, NULL, TEXT('\\'));
    if (pLastSlash)
    {
        pLastSlash[1] = TEXT('\0');
    }
    StrCpy(g_szWizRoot, g_szWizPath);
    CharUpper(g_szWizRoot);
    pLastSlash = StrStr(g_szWizRoot, TEXT("IEBIN"));
    if (pLastSlash) *pLastSlash = TEXT('\0');

    LoadString( g_rvInfo.hInst, IDS_TITLE, g_szTitle, countof(g_szTitle) );

    ZeroMemory(&psh, sizeof(psh));
    if(!g_fOCW)
        FillInPropertyPage( PPAGE_WELCOME, IDD_WELCOME, Welcome);
    else
        FillInPropertyPage( PPAGE_OCWWELCOME, IDD_OCWWELCOME, Welcome);

    FillInPropertyPage( PPAGE_STAGE1, IDD_STAGE1, Stage);
    FillInPropertyPage( PPAGE_TARGET, IDD_TARGET, TargetProc);
    FillInPropertyPage( PPAGE_LANGUAGE, IDD_LANGUAGE, Language);
    FillInPropertyPage( PPAGE_MEDIA, IDD_MEDIA, MediaDlgProc);
    FillInPropertyPage( PPAGE_IEAKLITE, IDD_IEAKLITE, IEAKLiteProc);

    FillInPropertyPage( PPAGE_STAGE2, IDD_STAGE2, Stage);
    FillInPropertyPage( PPAGE_OPTDOWNLOAD, IDD_OPTDOWNLOAD, OptionalDownload);
    FillInPropertyPage( PPAGE_CUSTCOMP, IDD_CUSTCOMP4, CustomComponents);

    FillInPropertyPage( PPAGE_STAGE3, IDD_STAGE3, Stage);
    FillInPropertyPage( PPAGE_ISKBACK, IDD_ISKBACKBITMAP, ISKBackBitmap);
    FillInPropertyPage( PPAGE_CDINFO, IDD_CD, CDInfoProc);
    FillInPropertyPage( PPAGE_SETUPWIZARD, IDD_SETUPWIZARD, ActiveSetupDlgProc);
    FillInPropertyPage( PPAGE_ICM, IDD_ICM, InternetConnMgr);
    FillInPropertyPage( PPAGE_COMPSEL, IDD_COMPSEL4, ComponentSelect);
    FillInPropertyPage( PPAGE_COMPURLS, IDD_COMPURLS, ComponentUrls);
    FillInPropertyPage( PPAGE_ADDON, IDD_ADDON, AddOnDlgProc);
    FillInPropertyPage( PPAGE_CORPCUSTOM, IDD_CORPCUSTOM, CorpCustomizeCustom);
    FillInPropertyPage( PPAGE_CUSTOMCUSTOM, IDD_CUSTOMCUSTOM, CustomizeCustom);
    FillInPropertyPage( PPAGE_COPYCOMP, IDD_COPYCOMP, CopyComp);
    FillInPropertyPage( PPAGE_CABSIGN, IDD_CABSIGN, CabSignDlgProc);

    FillInPropertyPage( PPAGE_STAGE4, IDD_STAGE4, Stage);
    FillInPropertyPage( PPAGE_OCWSTAGE2, IDD_OCWSTAGE2, Stage);
    FillInPropertyPage( PPAGE_INSTALLDIR, IDD_INSTALLDIR, InstallDirectory);
    FillInPropertyPage( PPAGE_SILENTINSTALL, IDD_SILENTINSTALL, SilentInstall);
    FillInPropertyPage( PPAGE_TITLE, IDD_BTITLE, BrandTitle);
    FillInPropertyPage( PPAGE_BTOOLBARS, IDD_BTOOLBARS, BToolbarProc);
    FillInPropertyPage( PPAGE_CUSTICON, IDD_CUSTICON, CustIcon);
    FillInPropertyPage( PPAGE_STARTSEARCH, IDD_STARTSEARCH, StartSearch);
    FillInPropertyPage( PPAGE_FAVORITES, IDD_FAVORITES, Favorites);
    FillInPropertyPage( PPAGE_WELCOMEMSGS, IDD_WELCOMEMSGS, WelcomeMessageDlgProc);
    FillInPropertyPage( PPAGE_UASTRDLG, IDD_UASTRDLG, UserAgentString);
    FillInPropertyPage( PPAGE_QUERYAUTOCONFIG, IDD_QUERYAUTOCONFIG, QueryAutoConfigDlgProc);
    FillInPropertyPage( PPAGE_PROXY, IDD_PROXY, ProxySettings);
    FillInPropertyPage( PPAGE_CONNECTSET, IDD_CONNECTSET, ConnectSetDlgProc);

    FillInPropertyPage( PPAGE_QUERYSIGNUP, IDD_QUERYSIGNUP, QuerySignupDlgProc);
    FillInPropertyPage( PPAGE_SIGNUPFILES, IDD_SIGNUPFILES, SignupFilesDlgProc);
    FillInPropertyPage( PPAGE_SERVERISPS, IDD_SERVERISPS, ServerIspsDlgProc);
    FillInPropertyPage( PPAGE_ISPINS, IDD_SIGNUPINS, SignupInsDlgProc);
    FillInPropertyPage( PPAGE_ICW, IDD_ICW, NewICWDlgProc);

    FillInPropertyPage( PPAGE_ADDROOT, IDD_ADDROOT, ISPAddRootCertDlgProc);
    FillInPropertyPage( PPAGE_SECURITYCERT, IDD_SECURITYCERT, SecurityCertsDlgProc);
    FillInPropertyPage( PPAGE_SECURITY, IDD_SECURITY1, SecurityZonesDlgProc);

    FillInPropertyPage( PPAGE_STAGE5, IDD_STAGE5, Stage);
    FillInPropertyPage( PPAGE_PROGRAMS, IDD_PROGRAMS, ProgramsDlgProc);
    FillInPropertyPage( PPAGE_MAIL, IDD_MAIL, MailServer);
    FillInPropertyPage( PPAGE_IMAP, IDD_IMAP, IMAPSettings);
    FillInPropertyPage( PPAGE_PRECONFIG,IDD_PRECONFIG,PreConfigSettings);
    FillInPropertyPage( PPAGE_OEVIEW,IDD_OEVIEW,ViewSettings);
    FillInPropertyPage( PPAGE_LDAP, IDD_LDAP, LDAPServer);
    FillInPropertyPage( PPAGE_OE, IDD_OE, CustomizeOE);
    FillInPropertyPage( PPAGE_SIG, IDD_SIG, Signature);
    FillInPropertyPage( PPAGE_ADMDESC, IDD_ADMDESC, ADMDesc);
    FillInPropertyPage( PPAGE_ADM, IDD_ADM, ADMParse);
    FillInPropertyPage( PPAGE_STATUS, IDD_STATUS, Finish);
    FillInPropertyPage( PPAGE_FINISH, IDD_FINISH, Finish);

    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_WIZARD | PSH_NOAPPLYNOW | PSH_USEPAGELANG | PSH_USECALLBACK;
    psh.hInstance  = g_rvInfo.hInst;
    psh.hwndParent = hwndOwner;
    psh.pszCaption = TEXT("Review Wizard");
    psh.nPages     = NUM_PAGES;
    psh.nStartPage = 0;
    psh.phpage     = s_ahPsp;
    psh.pfnCallback= &PropSheetProc;

    INT_PTR iResult = PropertySheet(&psh);

/*    if (!IsTahomaFontExist(g_hWndCent))
    {
        for (int i = 0; i < NUM_PAGES; i++) {
            CoTaskMemFree((PVOID)g_psp[i].pResource);
            g_psp[i].pResource = NULL;
        }
    }*/

    return (iResult < 0) ? -1 : 1;
}


BOOL CheckAVS(LPCTSTR pcszDownloadDir)
{
    TCHAR szDownloadDir[MAX_PATH];
    TCHAR szCabFile[MAX_PATH];
    HANDLE hFind = NULL;
    WIN32_FIND_DATA fd;
    static TCHAR s_szLocaleIni[MAX_PATH];

    if (ISNULL(s_szLocaleIni))
        PathCombine(s_szLocaleIni, g_szWizRoot, TEXT("locale.ini"));

    PathCombine(szDownloadDir, pcszDownloadDir, TEXT("*.*"));
    hFind = FindFirstFile(szDownloadDir, &fd);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                || (StrCmp(fd.cFileName, TEXT(".")) == 0)
                || (StrCmp(fd.cFileName, TEXT("..")) == 0))
                continue;

            if (!InsIsKeyEmpty(IS_STRINGS, fd.cFileName, s_szLocaleIni))
            {
                PathCombine(szCabFile, pcszDownloadDir, fd.cFileName);
                PathAppend(szCabFile, TEXT("setupw95.cab"));
                if (PathFileExists(szCabFile))
                {
                    FindClose(hFind);
                    return TRUE;
                }
            }
        }
        while (FindNextFile(hFind, &fd));

        FindClose(hFind);
    }
    return FALSE;
}

INT_PTR CALLBACK AdvancedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM)
{
    TCHAR  szTemp[MAX_PATH];
    TCHAR  szTempFile[MAX_PATH];
    DWORD  dwVal;
    BOOL   fLocalMode = TRUE;
    HANDLE hTemp;
    DWORD  dwFlags;

    switch (message)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_LOADINS);
        EnableDBCSChars(hDlg, IDE_SOURCEDIR);
        SetDlgItemText(hDlg, IDE_SOURCEDIR, g_szIEAKProg);
        CheckDlgButton( hDlg, IDC_OFFLINE, g_fLocalMode ? BST_UNCHECKED : BST_CHECKED );

        if (g_fLangInit)
            DisableDlgItem(hDlg, IDC_OFFLINE);

        SetDlgItemText(hDlg, IDE_LOADINS, g_szLoadedIns);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_BROWSE:
                {
                    TCHAR szInstructions[MAX_PATH];
                    LoadString(g_rvInfo.hInst,IDS_COMPDLDIR,szInstructions,countof(szInstructions));

                    if (BrowseForFolder(hDlg, szTemp, szInstructions))
                        SetDlgItemText(hDlg, IDE_SOURCEDIR, szTemp);
                }
                break;
            case IDC_BROWSEINS:
                GetDlgItemText( hDlg, IDE_LOADINS, szTemp, countof(szTemp));
                if( BrowseForFile( hDlg, szTemp, countof(szTemp), GFN_INS ))
                    SetDlgItemText( hDlg, IDE_LOADINS, szTemp );
                break;
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL );
                break;
            case IDOK:
                dwFlags = FC_FILE | FC_EXISTS;
                if (!CheckField(hDlg, IDE_LOADINS, dwFlags))
                    break;
                GetDlgItemText(hDlg, IDE_SOURCEDIR, szTemp, countof(szTemp));

                if (!CheckField(hDlg, IDE_SOURCEDIR, FC_PATH | FC_DIR))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                if (!PathIsUNC(szTemp))
                {
                    if ((PathIsRoot(szTemp)) || (PathIsRelative(szTemp)))
                    {
                        ErrorMessageBox(hDlg, IDS_SRCNEEDPATH);
                        break;
                    }
                }

                if ((StrLen(szTemp) <= 3) || PathIsUNCServer(szTemp))
                {
                    ErrorMessageBox(hDlg, IDS_SRCROOTILLEGAL);
                    break;;
                }

                fLocalMode = !IsDlgButtonChecked( hDlg, IDC_OFFLINE );

                if (!g_fBatch && fLocalMode && !CheckAVS(szTemp))
                {
                    ErrorMessageBox(hDlg, IDS_NEEDAVS);
                    break;
                }

                PathCombine(szTempFile, szTemp, TEXT("~~!!foo.txt"));

                if (!PathCreatePath(szTemp) ||
                    ((hTemp = CreateFile(szTempFile, GENERIC_WRITE, 0, NULL,
                    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE))
                {
                    TCHAR szMsg[128];
                    TCHAR szMsgTemp[MAX_PATH+128];

                    LoadString(g_rvInfo.hInst, IDS_BADDIR, szMsg, countof(szMsg));
                    wnsprintf(szMsgTemp, countof(szMsgTemp), szMsg, szTemp);
                    MessageBox(hDlg, szMsgTemp, g_szTitle, MB_OK | MB_SETFOREGROUND);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }
                CloseHandle(hTemp);
                DeleteFile(szTempFile);
                PathAddBackslash(szTemp);

                StrCpy(g_szIEAKProg, szTemp);

                GetDlgItemText(hDlg, IDE_LOADINS, g_szLoadedIns, countof(g_szLoadedIns));

                if (ISNONNULL(g_szLoadedIns))
                {
                    int nPlatformId = 0;

                    InsGetString(IS_BRANDING, TEXT("Platform"), szTemp, countof(szTemp), g_szLoadedIns);
                    nPlatformId = StrToInt(szTemp);
                    if (nPlatformId != 0 && nPlatformId != PLATFORM_WIN32 && nPlatformId != PLATFORM_W2K)
                    {
                        TCHAR szMsgParam[128];
                        TCHAR szMsg[MAX_PATH+128];

                        LoadString(g_rvInfo.hInst, IDS_UNSUPPORTED_PLATFORM, szMsgParam, countof(szMsgParam));
                        wnsprintf(szMsg, countof(szMsg), szMsgParam, g_szLoadedIns);

                        MessageBox(hDlg, szMsg, g_szTitle, MB_ICONINFORMATION | MB_OK);
                        
                        *g_szLoadedIns = TEXT('\0');
                        SetFocus(GetDlgItem(hDlg, IDE_LOADINS));

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    else if (nPlatformId == 0)
                        nPlatformId = PLATFORM_WIN32;
                }

                s_fLoadIns = TRUE;
                g_fLocalMode = fLocalMode;
                dwVal = g_fLocalMode ? 0 : 1;
                switch (g_dwPlatformId)
                {
                case PLATFORM_WIN32:
                default:
                     SHSetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("WIN32_AVS"), REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal));
                     break;
                }

                EndDialog( hDlg, IDOK );
                break;
            }
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: TargetProc(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "OCW Source Target" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//
INT_PTR CALLBACK TargetProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR  szMsg[MAX_PATH];
    TCHAR  szTemp[MAX_PATH+128];
    TCHAR  szTempFile[MAX_PATH];
    TCHAR  szDeskDir[MAX_PATH];
    TCHAR  szRealRoot[MAX_PATH];
    TCHAR  szDestRoot[MAX_PATH];
    TCHAR  szTempRoot[MAX_PATH];
    DWORD  dwDestFree, dwDestNeed;
    DWORD  dwSRet, dwAttrib = 0xFFFFFFFF;
    BOOL   fNext = FALSE;
    HANDLE hTemp;
    static BOOL s_fFirst = TRUE;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            EnableDBCSChars(hDlg, IDE_TARGETDIR);

            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_COMMAND:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                switch (LOWORD(wParam))
                {
                case IDC_BROWSE2:
                    {
                        TCHAR szInstructions[MAX_PATH];
                        LoadString(g_rvInfo.hInst,IDS_TARGETDIR,szInstructions,countof(szInstructions));

                        if (BrowseForFolder(hDlg, szTemp,szInstructions))
                            SetDlgItemText(hDlg, IDE_TARGETDIR, szTemp);
                    }
                    break;
                case IDC_ADVANCED:
                    DialogBox( g_rvInfo.hInst, (LPTSTR) IDD_ADVANCEDPOPUP, hDlg, AdvancedDlgProc);
                    break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    //file locs
                    dwSRet = countof(g_szBuildRoot);
                    if(!g_fBatch && !g_fBatch2)
                    {
                        if (ISNULL(s_szSourceDir))
                        {
                            DWORD dwSize = sizeof(g_szIEAKProg);

                            SHGetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("SourceDir"), NULL, (LPBYTE)s_szSourceDir, &dwSize);

                            if (ISNULL(s_szSourceDir))
                            {
                                GetIEAKDir(s_szSourceDir);
                                PathAppend(s_szSourceDir, TEXT("Download"));
                            }
                        }
                        StrCpy(g_szIEAKProg, s_szSourceDir);
                        PathAddBackslash(s_szSourceDir);
                        s_fAppendLang = TRUE;
                    }

                    if (s_fFirst)
                    {
                        DWORD dwSize, dwVal;

                        s_fFirst = FALSE;
                        dwSize = sizeof(dwVal);
                        switch (g_dwPlatformId)
                        {
                        case PLATFORM_WIN32:
                        default:
                            if ((SHGetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("WIN32_AVS"), NULL, (LPBYTE)&dwVal, &dwSize) == ERROR_SUCCESS)
                                && !dwVal)
                                g_fLocalMode = TRUE;
                            break;
                        }
                    }

                    if (ISNONNULL(g_szIEAKProg))
                        PathRemoveBackslash(g_szIEAKProg);

                    if (!g_fOCW)
                    {
                        if (!g_fBatch && !g_fBatch2)
                        {
                            DWORD dwSize = sizeof(g_szBuildRoot);
                            SHGetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("DestPath"), NULL, (LPVOID)g_szBuildRoot, &dwSize);
                        }
                    }

                    if (ISNONNULL(g_szBuildRoot))
                        PathRemoveBackslash(g_szBuildRoot);

                    else
                    {
                        SYSTEMTIME SystemTime;
                        TCHAR szDate[MAX_PATH];
                        TCHAR szDefaultTarget[MAX_PATH];

                        GetLocalTime(&SystemTime);
                        wnsprintf(szDate, countof(szDate), TEXT("%02d%02d%d"), SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear);
                        LoadString(g_rvInfo.hInst, IDS_DEFAULT_TARGETDIR, szDefaultTarget, countof(szDefaultTarget));
                        wnsprintf(g_szBuildRoot, countof(g_szBuildRoot), szDefaultTarget, szDate);
                    }

                    SetDlgItemText(hDlg, IDE_TARGETDIR, g_szBuildRoot);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                    fNext = TRUE;
                case PSN_WIZBACK:
                    //file locs
                    if (!g_fBatch && g_fLocalMode && !CheckAVS(g_szIEAKProg))
                    {
                        ErrorMessageBox(hDlg, IDS_NEEDAVS2);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    StrCpy(szTemp, g_szBuildRoot);
                    GetDlgItemText(hDlg, IDE_TARGETDIR, g_szBuildRoot, countof(g_szBuildRoot));
                    StrTrim(g_szBuildRoot, TEXT(" \t"));
                    if (!PathIsUNC(g_szBuildRoot))
                    {
                        if ((PathIsRoot(g_szBuildRoot)) || (PathIsRelative(g_szBuildRoot)))
                        {
                            ErrorMessageBox(hDlg, IDS_NEEDPATH);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;

                        }
                    }

                    if ((StrLen(g_szBuildRoot) <= 3) || PathIsUNCServer(g_szBuildRoot))
                    {
                        ErrorMessageBox(hDlg, IDS_ROOTILLEGAL);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    if (!CheckField(hDlg, IDE_TARGETDIR, FC_PATH | FC_DIR))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    if (ISNONNULL(g_szBuildRoot))
                        PathRemoveBackslash(g_szBuildRoot);

                    PathRemoveBackslash(g_szIEAKProg);

                    if (StrCmpI(g_szBuildRoot, g_szIEAKProg) == 0)
                    {
                        LoadString(g_rvInfo.hInst, IDS_SAMEDIR, szMsg, countof(szMsg));
                        MessageBox(hDlg, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    StrCpy(szRealRoot, g_szBuildRoot);

                    hTemp = NULL;
                    PathCombine(szTempFile, g_szIEAKProg, TEXT("~~!!foo.txt"));
                    if (!PathCreatePath(g_szIEAKProg) ||
                        ((hTemp = CreateFile(szTempFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE))
                    {
                        LoadString(g_rvInfo.hInst, IDS_BADDIR2, szMsg, countof(szMsg));
                        wnsprintf(szTemp, countof(szTemp), szMsg, g_szIEAKProg);
                        MessageBox(hDlg, szTemp, g_szTitle, MB_OK | MB_SETFOREGROUND);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    if (hTemp != INVALID_HANDLE_VALUE)
                        CloseHandle(hTemp);
                    DeleteFile(szTempFile);
                    PathAddBackslash(g_szIEAKProg);

                    hTemp = NULL;
                    PathCombine(szTempFile, g_szBuildRoot, TEXT("~~!!foo.txt"));
                    if (!PathCreatePath(g_szBuildRoot) || (hTemp = CreateFile(szTempFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
                    {
                        LoadString(g_rvInfo.hInst, IDS_BADDIR, szMsg, countof(szMsg));
                        wnsprintf(szTemp, countof(szTemp), szMsg, g_szBuildRoot);
                        MessageBox(hDlg, szTemp, g_szTitle, MB_OK | MB_SETFOREGROUND);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    if (hTemp != INVALID_HANDLE_VALUE)
                        CloseHandle(hTemp);
                    DeleteFile(szTempFile);

                    PathCombine(szDeskDir, g_szBuildRoot, TEXT("Desktop"));
                    if ((dwAttrib = GetFileAttributes(szDeskDir)) != 0xFFFFFFFF)
                        SetFileAttributes(szDeskDir, dwAttrib & ~FILE_ATTRIBUTE_HIDDEN);
                    if (!g_fBatch)
                        SHSetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("DestPath"), REG_SZ, (LPBYTE)szRealRoot,
                                    (StrLen(szRealRoot)+1)*sizeof(TCHAR));

                    GetTempPath(MAX_PATH, g_szBuildTemp);
                    PathAppend(g_szBuildTemp, TEXT("IEDKTEMP"));
                    PathRemovePath(g_szBuildTemp);
                    PathCreatePath(g_szBuildTemp);
                    PathCombine(g_szTempSign, g_szBuildTemp, TEXT("CUSTSIGN"));
                    PathCreatePath(g_szTempSign);

                    // BUGBUG: (andrewgu) no man's land starts...
                    StrCpy(szDestRoot, g_szBuildRoot);
                    StrCpy(szTempRoot, g_szBuildTemp);
                    CharUpper(szDestRoot);
                    CharUpper(szTempRoot);
                    dwDestFree = GetRootFree(szDestRoot);
                    dwDestNeed = MIN_PACKAGE_SIZE;
                    if (fNext)
                    {
                        if (dwDestFree < dwDestNeed)
                        {
                            TCHAR szTitle[MAX_PATH];
                            TCHAR szTemplate[MAX_PATH];
                            TCHAR szMsg[MAX_PATH];
                            LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
                            LoadString( g_rvInfo.hInst, IDS_DESTDISKMSG, szTemplate, MAX_PATH );
                            wnsprintf(szMsg, countof(szMsg), szTemplate, dwDestFree, dwDestNeed);
                            if (MessageBox(hDlg, szMsg, szTitle, MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
                            {
                                LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
                                MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
                                DoCancel();
                            }

                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                    }

                    if(!g_fBatch && !g_fBatch2)
                    {
                        if (StrCmpI(s_szSourceDir, g_szIEAKProg) != 0)
                        {
                            SHSetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("SourceDir"), REG_SZ,
                                (LPBYTE)g_szIEAKProg, (lstrlen(g_szIEAKProg)+1)*sizeof(TCHAR));
                            g_fSrcDirChanged = TRUE;
                            s_fAppendLang = TRUE;
                            StrCpy(s_szSourceDir, g_szIEAKProg);
                        }

                        if (StrCmpI(szTemp, g_szBuildRoot))
                            s_fDestDirChanged = TRUE;
                    }

                    g_iCurPage = PPAGE_TARGET;
                    EnablePages();
                    if (fNext)
                        PageNext(hDlg);
                    else
                        PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

void InitIEAKLite(HWND hwndList)
{
    ListView_DeleteAllItems(hwndList);

    for (int i = 0, iItem = 0;  i < IL_END;  i++)
    {
        TCHAR  szGroupName[MAX_PATH];
        LVITEM lvItem;

        // do not show groups that are not relevant for the current role (ICP, ISP, or Corp)
        // recap:
        //  ICP  is (!g_fBranded)
        //  ISP  is (g_fBranded && !g_fIntranet)
        //  CORP is (g_fIntranet)
        if ((!g_fBranded                  &&  g_IEAKLiteArray[i].fICP  == FALSE)  ||
            ( g_fBranded && !g_fIntranet  &&  g_IEAKLiteArray[i].fISP  == FALSE)  ||
            (                g_fIntranet  &&  g_IEAKLiteArray[i].fCorp == FALSE))
        {
            g_IEAKLiteArray[i].iListBox = -2;
            g_IEAKLiteArray[i].fEnabled = TRUE;
            continue;
        }

        // do not show ICM group in IEAKLite if only doing single disk branding since it's
        // not available anyway
        if (i == IL_ICM)
        {
            if (g_fBrandingOnly  &&  !g_fDownload  &&  !g_fCD  &&  !g_fLAN)
            {
                g_IEAKLiteArray[i].iListBox = -2;
                g_IEAKLiteArray[i].fEnabled = TRUE;
                continue;
            }
        }

        // if adms haven't been deleted yet, show adm page
        // by not creating an entry in the IEAKLite box
        if (i == IL_ADM)
        {
            if (InsGetBool(IS_BRANDING, TEXT("DeleteAdms"), FALSE, g_szCustIns))
            {
                g_IEAKLiteArray[i].iListBox = -2;
                g_IEAKLiteArray[i].fEnabled = TRUE;
                continue;
            }
        }

        // BUGBUG: pritobla: should have separate flags similar to DeleteAdms for activesetup
        // and icm so that even if the user cancels out of wizard before reaching these
        // pages, we can force them again.
        // Should consider this while reworking ieaklite.

        // force active setup, CMAK and adms to show up if imported an ins
        // by not creating an entry in the IEAKLite box
        if (*g_szLoadedIns)
        {
            if (i == IL_ACTIVESETUP  ||  i == IL_ICM  ||  i == IL_ADM)
            {
                g_IEAKLiteArray[i].iListBox = -2;
                g_IEAKLiteArray[i].fEnabled = TRUE;
                continue;
            }
        }

        LoadString(g_rvInfo.hInst, g_IEAKLiteArray[i].idGroupName, szGroupName, countof(szGroupName));
        
        g_IEAKLiteArray[i].fEnabled = !InsGetBool(IS_IEAKLITE, szGroupName, FALSE, g_szCustIns);

        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
        lvItem.iItem = iItem++;
        lvItem.pszText = szGroupName;
        lvItem.iImage = g_IEAKLiteArray[i].fEnabled ? 1 : 0;

#ifdef _DEBUG
        {
            LVFINDINFO lvFind;

            ZeroMemory(&lvFind, sizeof(lvFind));
            lvFind.flags = LVFI_STRING;
            lvFind.psz = szGroupName;

            ASSERT(ListView_FindItem(hwndList, -1, &lvFind) == -1);
        }
#endif

        g_IEAKLiteArray[i].iListBox = ListView_InsertItem(hwndList, &lvItem);
    }

    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);
}

void IEAKLiteMaintToggleCheckItem(HWND hwndList, int iItem)
{
    int i;
    LVITEM lvItem;

    for (i = 0; i < IL_END; i++)
    {
        if (g_IEAKLiteArray[i].iListBox == iItem)
            break;
    }
    ZeroMemory(&lvItem, sizeof(lvItem));
    g_IEAKLiteArray[i].fEnabled = !(g_IEAKLiteArray[i].fEnabled);
    lvItem.iItem = iItem;
    lvItem.mask = LVIF_IMAGE;
    lvItem.iImage = g_IEAKLiteArray[i].fEnabled ? 1 : 0;

    ListView_SetItem(hwndList, &lvItem);
}

BOOL ExtractOldInfo(LPCTSTR pcszCabname, LPTSTR pcszDestDir, BOOL fExe)
{
    TCHAR szCabPath[MAX_PATH];
    TCHAR szCmd[MAX_PATH*3];

    StrCpy(szCabPath, g_szCustIns);
    PathRemoveFileSpec(szCabPath);
    PathAppend(szCabPath, pcszCabname);

    if (!PathFileExists(szCabPath))
        return TRUE;

    if (!fExe)
        return (ExtractFilesWrap(szCabPath, pcszDestDir, 0, NULL, NULL, 0) == ERROR_SUCCESS);

    wnsprintf(szCmd, countof(szCmd), TEXT("\"%s\" /c /t:\"%s\""), szCabPath, pcszDestDir);

    return (RunAndWait(szCmd, g_szBuildTemp, SW_HIDE) == S_OK);
}

// BUGBUG: <oliverl> should probably persist this server side only info in a server side file for IEAK6

DWORD SaveIEAKLiteThreadProc(LPVOID)
{
    static BOOL s_fDesk;
    static BOOL s_fBrand;
    static BOOL s_fExe;
    TCHAR szGroupName[128];
    TCHAR szTmp[MAX_PATH];

    if (s_fDestDirChanged)
        s_fDestDirChanged = s_fDesk = s_fBrand = s_fExe = FALSE;

    for (int i=0; i < IL_END; i++)
    {
        LoadString(g_rvInfo.hInst, g_IEAKLiteArray[i].idGroupName, szGroupName, countof(szGroupName));
        WritePrivateProfileString(IS_IEAKLITE, szGroupName, g_IEAKLiteArray[i].fEnabled ? NULL : TEXT("1"), g_szCustIns);
    }

    if (!s_fExe && !g_IEAKLiteArray[IL_ACTIVESETUP].fEnabled)
    {
        ExtractOldInfo(TEXT("IE6SETUP.EXE"), g_szBuildTemp, TRUE);
        s_fExe = TRUE;
    }

    if (!s_fBrand &&
        (!g_IEAKLiteArray[IL_BROWSER].fEnabled || !g_IEAKLiteArray[IL_SIGNUP].fEnabled || !g_IEAKLiteArray[IL_CONNECT].fEnabled ||
        !g_IEAKLiteArray[IL_ZONES].fEnabled || !g_IEAKLiteArray[IL_CERT].fEnabled || !g_IEAKLiteArray[IL_MAILNEWS].fEnabled ||
        !g_IEAKLiteArray[IL_ADM].fEnabled || IsIconsInFavs(IS_FAVORITESEX, g_szCustIns) ||
        IsIconsInFavs(IS_URL, g_szCustIns)))
    {
        ExtractOldInfo(TEXT("BRANDING.CAB"), g_szTempSign, FALSE);
        PathCombine(szTmp, g_szTempSign, TEXT("install.inf"));
        DeleteFile(szTmp);
        PathCombine(szTmp, g_szTempSign, TEXT("setup.inf"));
        DeleteFile(szTmp);

        s_fBrand = TRUE;
    }

    if (ISNULL(g_szDeskTemp) && g_fIntranet)
    {
        PathCombine(g_szDeskTemp, g_szBuildRoot, TEXT("DESKTOP"));
        PathCreatePath(g_szDeskTemp);
    }

    if (!s_fDesk)
    {
        ExtractOldInfo(TEXT("DESKTOP.CAB"), g_szDeskTemp, FALSE);
        PathCombine(szTmp, g_szDeskTemp, TEXT("install.inf"));
        DeleteFile(szTmp);
        PathCombine(szTmp, g_szDeskTemp, TEXT("setup.inf"));
        DeleteFile(szTmp);
        s_fDesk = TRUE;
    }

    if (!g_fIntranet && g_fBranded)
    {
        // ISP

        g_fServerICW = g_fServerKiosk = g_fServerless = g_fNoSignup = FALSE;

        // make sure that only one of the variables is set to TRUE
        g_fServerICW = InsGetBool(IS_BRANDING, IK_USEICW, 0, g_szCustIns);
        if (!g_fServerICW)
        {
            g_fServerKiosk = InsGetBool(IS_BRANDING, IK_SERVERKIOSK, 0, g_szCustIns);
            if (!g_fServerKiosk)
            {
                g_fServerless = InsGetBool(IS_BRANDING, IK_SERVERLESS, 0, g_szCustIns);
                if (!g_fServerless)
                {
                    // in lots of other functions like BuildIE4, BuildBrandingOnly, BuildCDandMflop, etc.,
                    // !g_fNoSignup is used to mean that some signup mode was chosen;
                    // therefore, default to TRUE for g_fNoSignup
                    g_fNoSignup = InsGetBool(IS_BRANDING, IK_NODIAL, 1, g_szCustIns);
                }
            }
        }
    }
    else
    {
        if (g_fIntranet)
        {
            // Corp
            g_fSilent = GetPrivateProfileInt( BRANDING, SILENT_INSTALL, 0, g_szCustIns );
            g_fStealth = GetPrivateProfileInt( BRANDING, TEXT("StealthInstall"), 0, g_szCustIns );
            g_fInteg = GetPrivateProfileInt( BRANDING, WEB_INTEGRATED, 0, g_szCustIns );
        }
    }

    g_fUseIEWelcomePage = !InsGetBool(IS_URL, IK_NO_WELCOME_URL, FALSE, g_szCustIns);

    // take care of install dir for corp case
    if (g_fIntranet)
    {
        TCHAR szWrk[MAX_PATH];

        GetPrivateProfileString( IS_BRANDING, TEXT("InstallDir"), TEXT(""), szWrk, countof(szWrk), g_szCustIns );
        if (*szWrk != TEXT('%'))
        {
            g_iInstallOpt = INSTALL_OPT_FULL;
            if (ISNONNULL(szWrk))
                StrCpy(g_szInstallFolder, szWrk);
            else
            {
                LoadString( g_rvInfo.hInst, IDS_IE, g_szInstallFolder, MAX_PATH );
                g_iInstallOpt = INSTALL_OPT_PROG;
            }
        }
        else
        {
            switch (szWrk[1])
            {
            case 'p':
            case 'P':
            default:
                g_iInstallOpt = INSTALL_OPT_PROG;
                break;
            }
            StrCpy(g_szInstallFolder, &szWrk[3]);
        }
    }
    return 0;
}

void SetIEAKLiteDesc(HWND hDlg, int iItem)
{
    WORD wId;
    int i;
    TCHAR szDesc[512];

    for (i = 0; i < IL_END; i++)
    {
        if (g_IEAKLiteArray[i].iListBox == iItem)
            break;
    }

    if (!g_fBranded)
        wId = g_IEAKLiteArray[i].idICPDesc;
    else
    {
        if (!g_fIntranet)
            wId = g_IEAKLiteArray[i].idISPDesc;
        else
            wId = g_IEAKLiteArray[i].idCorpDesc;
    }
    LoadString(g_rvInfo.hInst, wId, szDesc, countof(szDesc));
    SetDlgItemText(hDlg, IDC_IEAKLITEDESC, szDesc);
}

void IEAKLiteSelectAll(HWND hCompList, BOOL fSet)
{
    for (int i=0; i < IL_END; i++)
    {
        if (g_IEAKLiteArray[i].iListBox != -2)
        {
            LV_ITEM lvItem;

            g_IEAKLiteArray[i].fEnabled = fSet;
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.iImage = fSet ? 1 : 0;
            lvItem.mask = LVIF_IMAGE;
            lvItem.iItem = g_IEAKLiteArray[i].iListBox;
            ListView_SetItem(hCompList, &lvItem);
        }
    }
}
//
//  FUNCTION: IEAKLiteProc(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "IEAKLite" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//
INT_PTR CALLBACK IEAKLiteProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_IEAKLITE);
    HWND hWait;
    HANDLE hThread;
    int iItem;
    DWORD dwTid;

    switch (message)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_IEAKLITE);
            InitList(hDlg, IDC_IEAKLITE);
            g_hWizard = hDlg;
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_LITECHECKALL:
                        IEAKLiteSelectAll(hwndList, TRUE);
                        break;
                    case IDC_LITEUNCHECKALL:
                        IEAKLiteSelectAll(hwndList, FALSE);
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case LVN_KEYDOWN:
                    {
                        NMLVKEYDOWN *pnm = (NMLVKEYDOWN*) lParam;
                        if ( pnm->wVKey == VK_SPACE )
                        {
                            iItem = ListView_GetSelectionMark(hwndList);
                            IEAKLiteMaintToggleCheckItem(hwndList, iItem);
                        }
                        break;
                    }

                case NM_CLICK:
                    {
                        POINT pointScreen, pointLVClient;
                        DWORD dwPos;
                        LVHITTESTINFO HitTest;

                        dwPos = GetMessagePos();

                        pointScreen.x = LOWORD (dwPos);
                        pointScreen.y = HIWORD (dwPos);

                        pointLVClient = pointScreen;

                        // Convert the point from screen to client coordinates,
                        // relative to the Listview
                        ScreenToClient (hwndList, &pointLVClient);

                        HitTest.pt = pointLVClient;
                        ListView_HitTest(hwndList, &HitTest);

                        // Only if the user clicked on the checkbox icon/bitmap, change
                        if (HitTest.flags == LVHT_ONITEMICON)
                            IEAKLiteMaintToggleCheckItem(hwndList, HitTest.iItem);
                        SetIEAKLiteDesc(hDlg, HitTest.iItem);
                    }
                    break;

                case NM_DBLCLK:
                    if ( ((LPNMHDR)lParam)->idFrom == IDC_IEAKLITE)
                    {
                        iItem = ListView_GetSelectionMark(hwndList);
                        IEAKLiteMaintToggleCheckItem(hwndList, iItem);
                        SetIEAKLiteDesc(hDlg, iItem);
                    }
                    break;

                case LVN_ITEMCHANGED:
                    iItem = ListView_GetSelectionMark(hwndList);
                    SetIEAKLiteDesc(hDlg, iItem);
                    break;
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    InitIEAKLite(GetDlgItem(hDlg, IDC_IEAKLITE));
                    ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);
                    SetIEAKLiteDesc(hDlg, 0);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
                    hWait = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_WAITIEAKLITE), hDlg,
                        DownloadStatusDlgProc);
                    ShowWindow( hWait, SW_SHOWNORMAL );

                    hThread = CreateThread(NULL, 4096, SaveIEAKLiteThreadProc, NULL, 0, &dwTid);

                    while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                    {
                        MSG msg;

                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                    }

                    if (hThread) CloseHandle(hThread);

                    DestroyWindow(hWait);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    g_iCurPage = PPAGE_IEAKLITE;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        case WM_LV_GETITEMS:
            LVGetItems(GetDlgItem(hDlg, IDC_IEAKLITE));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

void PositionWindow(HWND hWnd)
{
    int nXPos, nYPos, nWidth, nHeight;
    RECT rectWnd, rectDesktop;

    if (hWnd == NULL && !IsWindow(hWnd))
        return;

    GetWindowRect(GetDesktopWindow(), &rectDesktop);
    GetWindowRect(hWnd, &rectWnd);

    nXPos = nYPos = -1;
    nWidth = rectWnd.right - rectWnd.left;
    nHeight = rectWnd.bottom - rectWnd.top;

    if (g_fOCW  &&  *g_szParentWindowName)
    {
        HWND hOCWWnd;
        RECT rect;

        hOCWWnd = FindWindow(NULL, g_szParentWindowName);
        if (hOCWWnd != NULL  &&  IsWindow(hOCWWnd)  &&  !IsIconic(hOCWWnd))
        {
            GetWindowRect(hOCWWnd, &rect);
            nXPos = rect.left;
            nYPos = rect.top;
        }
    }

    if (nXPos == -1 && nYPos == -1)
    {
        nXPos = (rectDesktop.right  - nWidth)  / 2;
        nYPos = (rectDesktop.bottom - nHeight) / 2;
    }

    MoveWindow(hWnd, nXPos, nYPos, nWidth, nHeight, TRUE);
}

void GetIEAKDir(LPTSTR szDir)
{
    TCHAR szIEAKDir[MAX_PATH];

    *szIEAKDir = TEXT('\0');
    if (GetModuleFileName(NULL, szIEAKDir, countof(szIEAKDir)))
        PathRemoveFileSpec(szIEAKDir);
    else
    {
        DWORD dwSize;

        dwSize = sizeof(szIEAKDir);
        if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\ieak6WIZ.EXE"),
                            TEXT("Path"), NULL, (LPVOID) szIEAKDir, &dwSize) != ERROR_SUCCESS)
        {
            dwSize = sizeof(szIEAKDir);
            if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, TEXT("ProgramFilesDir"),
                                NULL, (LPVOID) szIEAKDir, &dwSize) == ERROR_SUCCESS)
                PathAppend(szIEAKDir, TEXT("IEAK"));
        }
    }

    StrCpy(szDir, szIEAKDir);
}

// get the ins file from the selected "platform/language" directory if exists
// else copy the last ins file used for this build directory if one exists
// else start with a new ins file
void GenerateCustomIns()
{
    TCHAR szSrcCustIns[MAX_PATH];

    PathCombine(g_szCustIns, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCustIns, GetOutputPlatformDir());
    PathAppend(g_szCustIns, g_szLanguage);
    PathCreatePath(g_szCustIns);
    PathAppend(g_szCustIns, TEXT("INSTALL.INS"));

    if (g_szSrcRoot[0])
    {
        PathCombine(szSrcCustIns, g_szSrcRoot, TEXT("INS"));
        PathAppend(szSrcCustIns, GetOutputPlatformDir());
        PathAppend(szSrcCustIns, g_szLanguage);
        PathCreatePath(szSrcCustIns);
        PathAppend(szSrcCustIns, TEXT("INSTALL.INS"));
    }

    if (PathFileExists(szSrcCustIns))
        CopyFile(szSrcCustIns, g_szCustIns, FALSE); //Overwrite if already exists

    if (!PathFileExists(g_szCustIns))
    {
        TCHAR szInsFile[MAX_PATH];
        TCHAR szPlatformLang[MAX_PATH];
        DWORD dwSize = sizeof(szPlatformLang);
        TCHAR szRegKey[MAX_PATH];

        wnsprintf(szRegKey, countof(szRegKey), TEXT("%s\\INS"), RK_IEAK_SERVER);
        if (SHGetValue(HKEY_CURRENT_USER, szRegKey, g_szBuildRoot, NULL, (LPBYTE)szPlatformLang, &dwSize) == ERROR_SUCCESS)
        {
            TCHAR szTemp[MAX_PATH];

            StrCpy(szTemp, szPlatformLang);
            PathRemoveFileSpec(szTemp);
            if (StrCmpI(szTemp, TEXT("WIN32")) == 0)
            {
                PathCombine(szInsFile, g_szBuildRoot, TEXT("INS"));
                PathAppend(szInsFile, szPlatformLang);
                PathAppend(szInsFile, TEXT("INSTALL.INS"));
                CopyFile(szInsFile, g_szCustIns, TRUE);
                if (ISNULL(g_szLoadedIns) && (StrCmpI(g_szLoadedIns, szInsFile) != 0))
                {
                    StrCpy(g_szLoadedIns, szInsFile);
                    s_fLoadIns = TRUE;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\msie.h ===
#if !defined(AFX_MSIE_H__25959BF4_E700_11D2_A7AF_00C04F806200__INCLUDED_)
#define AFX_MSIE_H__25959BF4_E700_11D2_A7AF_00C04F806200__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Msie.h : main header file for MSIE.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#include "msiedata.h"
#include <ras.h>
#include <wincrypt.h>

/////////////////////////////////////////////////////////////////////////////
// CMsieApp : See Msie.cpp for implementation.

class CMsieApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();

	DWORD AppGetTemplate(void ** ppBuffer);
	void AppGetIEData(IEDataType enType, long *lCount, void ***pppIEData, long *pCancel = NULL);
	void AppDeleteIEData(IEDataType enType, long lCount, void **ppIEData);

private:
	void LoadTemplate();
	CString GetBooleanString(BOOL bValue, int nType = 0);
	CString ConvertIPAddressToString(RASIPADDR ipaddr);
	void GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, COleVariant &vtData);
	long GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, DWORD &dwData);
	long GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, CString &strData);
	CString GetLongPathName(LPCTSTR pszShortPath);
	DWORD GetDirSize(LPCTSTR pszFolder);
	CString GetFileVersion(LPCTSTR pszFileName);
	CString GetFileCompany(LPCTSTR pszFileName);
	DWORD GetCipherStrength();
	void GetCertificateInfo(PCCERT_CONTEXT pContext, int idsType, CPtrArray& ptrs);
	void GetPersonalCertificates(CPtrArray& ptrs);
	void GetOtherPeopleCertificates(CPtrArray& ptrs);

	bool m_bRunningOnNT;
	bool m_bRunningOnNT5OrHigher;

	BOOL m_fTemplateLoaded;
	unsigned char *m_pTemplateInfo;
	DWORD m_dwTemplateInfoLen;
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
extern CMsieApp theApp;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSIE_H__25959BF4_E700_11D2_A7AF_00C04F806200__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\filefind.h ===
#ifndef _FILEFIND_H_
#define _FILEFIND_H_

////////////////////////////////////////////////////////////////////////////
// Local file searches

class CFindFile : public CObject
{
public:
	CFindFile();
	virtual ~CFindFile();

// Attributes
public:
	DWORD GetLength() const;
#if defined(_X86_) || defined(_ALPHA_)
	__int64 GetLength64() const;
#endif
	virtual CString GetFileName() const;
	virtual CString GetFilePath() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFileURL() const;
	virtual CString GetRoot() const;

	virtual BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetCreationTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastWriteTime(CTime& refTime) const;
	virtual BOOL GetLastAccessTime(CTime& refTime) const;
	virtual BOOL GetCreationTime(CTime& refTime) const;

	virtual BOOL MatchesMask(DWORD dwMask) const;

	virtual BOOL IsDots() const;
	// these aren't virtual because they all use MatchesMask(), which is
	BOOL IsReadOnly() const;
	BOOL IsDirectory() const { return MatchesMask(FILE_ATTRIBUTE_DIRECTORY); };
	BOOL IsCompressed() const;
	BOOL IsSystem() const;
	BOOL IsHidden() const;
	BOOL IsTemporary() const;
	BOOL IsNormal() const;
	BOOL IsArchived() const;

// Operations
	void Close();
	virtual BOOL FindFile(LPCTSTR pstrName = NULL, DWORD dwUnused = 0);
	virtual BOOL FindNextFile();

protected:
	virtual void CloseContext();

// Implementation
protected:
	void* m_pFoundInfo;
	void* m_pNextInfo;
	HANDLE m_hContext;
	BOOL m_bGotLast;
	CString m_strRoot;
	TCHAR m_chDirSeparator;     // not '\\' for Internet classes

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
	void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFindFile)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\filefind.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifdef _MAC
#error CFindFile is not supported on the Macintosh
#endif

#include "stdafx.h"
#include "filefind.h"

////////////////////////////////////////////////////////////////////////////
// CFindFile implementation

CFindFile::CFindFile()
{
	m_pFoundInfo = NULL;
	m_pNextInfo = NULL;
	m_hContext = NULL;
	m_chDirSeparator = '\\';
}

CFindFile::~CFindFile()
{
	Close();
}

void CFindFile::Close()
{
	if (m_pFoundInfo != NULL)
	{
		delete m_pFoundInfo;
		m_pFoundInfo = NULL;
	}

	if (m_pNextInfo != NULL)
	{
		delete m_pNextInfo;
		m_pNextInfo = NULL;
	}

	if (m_hContext != NULL && m_hContext != INVALID_HANDLE_VALUE)
	{
		CloseContext();
		m_hContext = NULL;
	}
}

void CFindFile::CloseContext()
{
	::FindClose(m_hContext);
	return;
}

BOOL CFindFile::FindFile(LPCTSTR pstrName /* = NULL */,
	DWORD dwUnused /* = 0 */)
{
	UNUSED_ALWAYS(dwUnused);
	Close();
	m_pNextInfo = new WIN32_FIND_DATA;
	m_bGotLast = FALSE;

	if (pstrName == NULL)
		pstrName = _T("*.*");
	_tcsncpy(((WIN32_FIND_DATA*) m_pNextInfo)->cFileName, pstrName,_tcslen(((WIN32_FIND_DATA*) m_pNextInfo)->cFileName));

	m_hContext = ::FindFirstFile(pstrName, (WIN32_FIND_DATA*) m_pNextInfo);

	if (m_hContext == INVALID_HANDLE_VALUE)
	{
		DWORD dwTemp = ::GetLastError();
		Close();
		::SetLastError(dwTemp);
		return FALSE;
	}

	LPTSTR pstrRoot = m_strRoot.GetBufferSetLength(_MAX_PATH);
	LPCTSTR pstr = _tfullpath(pstrRoot, pstrName, _MAX_PATH);

	// passed name isn't a valid path but was found by the API
	ASSERT(pstr != NULL);
	if (pstr == NULL)
	{
		m_strRoot.ReleaseBuffer(-1);
		Close();
		::SetLastError(ERROR_INVALID_NAME);
		return FALSE;
	}
	else
	{
		// find the last forward or backward whack
		LPTSTR pstrBack  = _tcsrchr(pstrRoot, '\\');
		LPTSTR pstrFront = _tcsrchr(pstrRoot, '/');

		if (pstrFront != NULL || pstrBack != NULL)
		{
			if (pstrFront == NULL)
				pstrFront = pstrRoot;
			if (pstrBack == NULL)
				pstrBack = pstrRoot;

			// from the start to the last whack is the root

			if (pstrFront >= pstrBack)
				*pstrFront = '\0';
			else
				*pstrBack = '\0';
		}
		m_strRoot.ReleaseBuffer(-1);
	}

	return TRUE;
}

BOOL CFindFile::MatchesMask(DWORD dwMask) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
		return (!!(((LPWIN32_FIND_DATA) m_pFoundInfo)->dwFileAttributes & dwMask));
	else
		return FALSE;
}

BOOL CFindFile::GetLastAccessTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT(pTimeStamp != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastAccessTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetLastWriteTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT(pTimeStamp != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastWriteTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetCreationTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftCreationTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetLastAccessTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastAccessTime);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetLastWriteTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastWriteTime);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetCreationTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftCreationTime);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::IsDots() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	// return TRUE if the file name is "." or ".." and
	// the file is a directory

	BOOL bResult = FALSE;
	if (m_pFoundInfo != NULL && IsDirectory())
	{
		LPWIN32_FIND_DATA pFindData = (LPWIN32_FIND_DATA) m_pFoundInfo;
		if (pFindData->cFileName[0] == '.')
		{
			if (pFindData->cFileName[1] == '\0' ||
				(pFindData->cFileName[1] == '.' &&
				 pFindData->cFileName[2] == '\0'))
			{
				bResult = TRUE;
			}
		}
	}

	return bResult;
}

BOOL CFindFile::FindNextFile()
{
	ASSERT(m_hContext != NULL);

	if (m_hContext == NULL)
		return FALSE;
	if (m_pFoundInfo == NULL)
		m_pFoundInfo = new WIN32_FIND_DATA;

	ASSERT_VALID(this);

	void* pTemp = m_pFoundInfo;
	m_pFoundInfo = m_pNextInfo;
	m_pNextInfo = pTemp;

	return ::FindNextFile(m_hContext, (LPWIN32_FIND_DATA) m_pNextInfo);
}

CString CFindFile::GetFileURL() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strResult("file://");
	strResult += GetFilePath();
	return strResult;
}

CString CFindFile::GetRoot() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	return m_strRoot;
}

CString CFindFile::GetFilePath() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strResult = m_strRoot;
	if (strResult[strResult.GetLength()-1] != '\\' &&
		strResult[strResult.GetLength()-1] != '/')
		strResult += m_chDirSeparator;
	strResult += GetFileName();
	return strResult;
}

CString CFindFile::GetFileTitle() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strFullName = GetFileName();
	CString strResult;

	_tsplitpath(strFullName, NULL, NULL, strResult.GetBuffer(_MAX_PATH), NULL);
	strResult.ReleaseBuffer();
	return strResult;
}

CString CFindFile::GetFileName() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString ret;

	if (m_pFoundInfo != NULL)
		ret = ((LPWIN32_FIND_DATA) m_pFoundInfo)->cFileName;
	return ret;
}

DWORD CFindFile::GetLength() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
		return ((LPWIN32_FIND_DATA) m_pFoundInfo)->nFileSizeLow;
	else
		return 0;
}

#if defined(_X86_) || defined(_ALPHA_)
__int64 CFindFile::GetLength64() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
		return ((LPWIN32_FIND_DATA) m_pFoundInfo)->nFileSizeLow +
				(((LPWIN32_FIND_DATA) m_pFoundInfo)->nFileSizeHigh << 32);
	else
		return 0;
}
#endif

#ifdef _DEBUG
void CFindFile::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);
	dc << "\nm_hContext = " << (UINT) m_hContext;
}

void CFindFile::AssertValid() const
{
	// if you trip the ASSERT in the else side, you've called
	// a Get() function without having done at least one
	// FindNext() call

	if (m_hContext == NULL)
		ASSERT(m_pFoundInfo == NULL && m_pNextInfo == NULL);
	else
		ASSERT(m_pFoundInfo != NULL && m_pNextInfo != NULL);

}
#endif

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CFindFile, CObject)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\msiectl.cpp ===
// MsieCtl.cpp : Implementation of the CMsieCtrl ActiveX Control class.

#include "stdafx.h"
#include "Msie.h"
#include "MsieCtl.h"
#include "MsiePpg.h"
#include "MsieData.h"
#include "resdefs.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// WMI Interfaces used (defining here instead of linking to wbemuuid.lib)

const IID IID_IWbemProviderInit =
		{ 0x1be41572, 0x91dd, 0x11d1, { 0xae, 0xb2, 0x00, 0xc0, 0x4f, 0xb6, 0x88, 0x20 } };

//const IID IID_IWbemServices = 
//		{ 0x9556dc99, 0x828c, 0x11cf, { 0xa3, 0x7e, 0x00, 0xaa, 0x00, 0x32, 0x40, 0xc7 } };


// Macro for setting a WBEM property

#define SETPROPERTY(prop) \
	if (pData->prop.vt == VT_DATE) \
		ConvertDateToWbemString(pData->prop); \
	pInstance->Put(L#prop, 0, &pData->prop, 0);


IMPLEMENT_DYNCREATE(CMsieCtrl, COleControl)

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMsieCtrl, COleControl)
	//{{AFX_MSG_MAP(CMsieCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_CTLCOLOR()
	ON_BN_CLICKED(IDC_BTN_BASIC, OnBasicBtnClicked) 
	ON_BN_CLICKED(IDC_BTN_ADVANCED, OnAdvancedBtnClicked) 
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CMsieCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CMsieCtrl)
	DISP_PROPERTY_NOTIFY(CMsieCtrl, "MSInfoView", m_MSInfoView, OnMSInfoViewChanged, VT_I4)
	DISP_FUNCTION(CMsieCtrl, "MSInfoRefresh", MSInfoRefresh, VT_EMPTY, VTS_BOOL VTS_PI4)
	DISP_FUNCTION(CMsieCtrl, "MSInfoLoadFile", MSInfoLoadFile, VT_BOOL, VTS_BSTR)
	DISP_FUNCTION(CMsieCtrl, "MSInfoSelectAll", MSInfoSelectAll, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CMsieCtrl, "MSInfoCopy", MSInfoCopy, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CMsieCtrl, "MSInfoUpdateView", MSInfoUpdateView, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CMsieCtrl, "MSInfoGetData", MSInfoGetData, VT_I4, VTS_I4 VTS_PI4 VTS_I4)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Interface map

BEGIN_INTERFACE_MAP(CMsieCtrl, COleControl)
	INTERFACE_PART(CMsieCtrl, IID_IWbemProviderInit, WbemProviderInit)
	INTERFACE_PART(CMsieCtrl, IID_IWbemServices, WbemServices)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CMsieCtrl, COleControl)
	//{{AFX_EVENT_MAP(CMsieCtrl)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CMsieCtrl, 1)
	PROPPAGEID(CMsiePropPage::guid)
END_PROPPAGEIDS(CMsieCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMsieCtrl, "MSIE.MsieCtrl.1",
	0x25959bef, 0xe700, 0x11d2, 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CMsieCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DMsie =
		{ 0x25959bed, 0xe700, 0x11d2, { 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0 } };
const IID BASED_CODE IID_DMsieEvents =
		{ 0x25959bee, 0xe700, 0x11d2, { 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0 } };

/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwMsieOleMisc =
	OLEMISC_SIMPLEFRAME |
	OLEMISC_INVISIBLEATRUNTIME |
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CMsieCtrl, IDS_MSIE, _dwMsieOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::CMsieCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CMsieCtrl

BOOL CMsieCtrl::CMsieCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_MSIE,
			IDB_MSIE,
			afxRegApartmentThreading,
			_dwMsieOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::CMsieCtrl - Constructor

CMsieCtrl::CMsieCtrl()
{
	TRACE0("-- CMsieCtrl::CMsieCtrl()\n");

	InitializeIIDs(&IID_DMsie, &IID_DMsieEvents);

	EnableSimpleFrame();

	// set background brush to white (used with static and radio button controls)

	m_pCtlBkBrush = new CBrush(RGB(255,255,255));

	// You don't need to initialize your data members here. In fact, you
	// shouldn't do any time consuming updates here. MSInfoRefresh will
	// be called before you need to render or save information.
	//
	// You will want to initialize the member variable which indicates
	// that the control is showing current system info (not any loaded
	// information) as this is the default.

	m_bCurrent = true;
	m_cColumns = 0;
	m_MSInfoView = 0;
	m_pNamespace = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::~CMsieCtrl - Destructor

CMsieCtrl::~CMsieCtrl()
{
	TRACE0("-- CMsieCtrl::~CMsieCtrl()\n");

	// Delete all of the items in the pointer array.

	for (int i = 0; i < m_ptrarray.GetSize(); i++)
		DeleteArrayObject(m_ptrarray.GetAt(i));
	m_ptrarray.RemoveAll();

	delete m_pCtlBkBrush;

	if (m_pNamespace)
		m_pNamespace->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::OnDraw - Drawing function

void CMsieCtrl::OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	TRACE0("-- CMsieCtrl::OnDraw()\n");

	if (m_MSInfoView)
	{
		if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
		{
			DrawLine();
			m_edit.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		}
		else
			m_list.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME); 
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::DoPropExchange - Persistence support

void CMsieCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// Not using properties, so I'll just leave this one alone.
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::OnResetState - Reset control to default state

void CMsieCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange
}

//-----------------------------------------------------------------------------
// The OnCreate method is used to create the list control. Also, if we've
// already loaded information using Serialize, we can add the lines to
// the list control.
//-----------------------------------------------------------------------------

int CMsieCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	TRACE0("-- CMsieCtrl::OnCreate()\n");

	CRect rect;
	DWORD dwExStyles;
	CString strText;
	CHARFORMAT cf;
	NONCLIENTMETRICS ncm;

	// setup fonts for static and radio button controls

	memset(&ncm, 0, sizeof(ncm));
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	ncm.lfMessageFont.lfWeight = FW_BOLD;
	m_fontStatic.CreateFontIndirect(&ncm.lfMessageFont);

	ncm.lfMessageFont.lfWeight = FW_NORMAL;
	m_fontBtn.CreateFontIndirect(&ncm.lfMessageFont);

	if (COleControl::OnCreate(lpCreateStruct) == -1) return -1;
	
	// In this control, we want to process the WM_CREATE message so we
	// can create the list control which is used to display the print
	// information. Make the list control the same size as the 
	// client area.

	GetClientRect(&rect);

	if (!m_list.Create(WS_CHILD | WS_VSCROLL | WS_HSCROLL | LVS_REPORT, rect, this, IDC_LISTCTRL))
		return -1;

	// set to FullRowSelect (via extended style)

	dwExStyles = (DWORD) ::SendMessage(m_list.m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
	::SendMessage(m_list.m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dwExStyles | LVS_EX_FULLROWSELECT);

	// create static text for Connectivity node

	strText.LoadString(IDS_CONNECTIVITY);
	if (!m_static.Create(strText, WS_CHILD | WS_GROUP | WS_EX_TRANSPARENT | SS_LEFT, CRect(rect.left + 5, rect.top, rect.left + 100, rect.top + 20), this, IDC_STATIC))
		return -1;
	m_static.SetFont(&m_fontStatic);

	// create basic and advanced radio buttons for Connectivity node

	strText.LoadString(IDS_BASIC_INFO);
	if (!m_btnBasic.Create(strText, WS_CHILD | WS_TABSTOP | WS_GROUP | BS_AUTORADIOBUTTON, CRect(rect.left + 5, rect.top + 25, rect.left + 200, rect.top + 45), this, IDC_BTN_BASIC))
		return -1;
	m_btnBasic.SetFont(&m_fontBtn);
	m_btnBasic.SetCheck(1);

	strText.LoadString(IDS_ADVANCED_INFO);
	if (!m_btnAdvanced.Create(strText, WS_CHILD | BS_AUTORADIOBUTTON, CRect(rect.left + 200, rect.top + 25, rect.left + 400, rect.top + 45), this, IDC_BTN_ADVANCED))
		return -1;
	m_btnAdvanced.SetFont(&m_fontBtn);

	// create a rich edit control for display Connectivity node

	if (!m_edit.Create(WS_CHILD | WS_CLIPCHILDREN | WS_TABSTOP | WS_GROUP | WS_VSCROLL | WS_HSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | ES_SAVESEL | ES_READONLY, CRect(rect.left, rect.top + 63, rect.right, rect.bottom), this, IDC_EDITCTRL))
		return -1;

	// set default character formatting for rich edit control

	cf.cbSize = sizeof(cf);
	cf.dwMask = CFM_BOLD | CFM_COLOR | CFM_FACE | CFM_SIZE;
	cf.dwEffects = CFE_AUTOCOLOR; 
	cf.yHeight = 180;
	strcpy(cf.szFaceName, "MS Sans Serif");
	m_edit.SetDefaultCharFormat(cf);

	return 0;
}

void CMsieCtrl::DrawLine()
{
	CRect rect;
	CDC *dc = GetDC();
	CBrush brush;

	GetClientRect(&rect);
	brush.CreateSolidBrush(GetBkColor(*dc));
	dc->FillRect(rect, &brush);	
	dc->MoveTo(0, 61);
	dc->LineTo(rect.Width(), 61);
	dc->MoveTo(0, 62);
	dc->LineTo(rect.Width(), 62);

	ReleaseDC(dc);
}

//-----------------------------------------------------------------------------
// The FormatColumns method makes calls to the AddColumn method to create
// all of the necessary columns for this control.
//-----------------------------------------------------------------------------

BOOL CMsieCtrl::FormatColumns()
{
	TRACE1("-- CMsieCtrl::FormatColumns: %i\n", m_MSInfoView);

	int idsCol1, idsCol2;

	// remove current columns

	for (int iCol = m_cColumns - 1; iCol >= 0; iCol--)
		m_list.DeleteColumn(iCol);
	m_cColumns = 0;
	
	if (m_MSInfoView == MSIVIEW_FILE_VERSIONS)
	{
		// File, Version, Size, Date, Path, Company

		AddColumn(IDS_FILE, 0, 17);
		AddColumn(IDS_VERSION, 1, 17);
		AddColumn(IDS_SIZE, 2, 17, 0, LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM, LVCFMT_RIGHT);
		AddColumn(IDS_DATE, 3, 17);
		AddColumn(IDS_PATH, 4, 17);
		AddColumn(IDS_COMPANY, 5, -1);
	}
	else if (m_MSInfoView == MSIVIEW_OBJECT_LIST)
	{
		AddColumn(IDS_PROGRAM_FILE, 0, 40);
		AddColumn(IDS_STATUS, 1, 20);
		AddColumn(IDS_CODE_BASE, 5, -1);
	}
	else if ((m_MSInfoView == MSIVIEW_PERSONAL_CERTIFICATES) || (m_MSInfoView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES))
	{
		AddColumn(IDS_ISSUED_TO, 0, 30);
		AddColumn(IDS_ISSUED_BY, 1, 30);
		AddColumn(IDS_VALIDITY, 5, 20);
		AddColumn(IDS_SIGNATURE_ALGORITHM, 5, -1);
	}
	else if (m_MSInfoView == MSIVIEW_PUBLISHERS)
	{
		AddColumn(IDS_NAME, 0, -1);
	}
	else
	{
		if (m_MSInfoView == MSIVIEW_SECURITY)
		{
			idsCol1 = IDS_ZONE;
			idsCol2 = IDS_SECURITY_LEVEL;
		}
		else
		{
			idsCol1 = IDS_ITEM;
			idsCol2 = IDS_VALUE;
		}

		// Item, Value
		// The item lable gets 40% of the control width, the value label the rest.

		AddColumn(idsCol1, 0, 40);
		AddColumn(idsCol2, 1, -1);
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// The AddColumn method adds (you guessed it) a column to the list control. If
// size is zero, the column is sized large enough to hold the text. If size is
// positive, it is treated as a percentage of the window width. If size is -1,
// the column is sized to fill the remaining space in the window.
//-----------------------------------------------------------------------------

BOOL CMsieCtrl::AddColumn(int idsLabel, int nItem, int size, int nSubItem, int nMask, int nFmt)
{
	LV_COLUMN lvc, getlvc;
	CString strLabel;
	CRect rect;
	int nIndex, spaceUsed = 0, nCol = 0;

	strLabel.LoadString(idsLabel);

	// strip off W2K "[]" stuff

	if (-1 != (nIndex = strLabel.Find(_T('['))))
		strLabel = strLabel.Left(nIndex - 1);

	lvc.mask = nMask;
	lvc.fmt = nFmt;
	lvc.pszText = (LPTSTR)(LPCTSTR)strLabel;
	
	// Save the ratio for this column.

	ASSERT(nItem < 20);
	m_aiRequestedWidths[nItem] = size;
	if (m_cColumns < nItem + 1)
		m_cColumns = nItem + 1;

	// Determine the size of this new column.

	switch (size)
	{
	case 0:	// shouldn't use this, though.
		lvc.cx = m_list.GetStringWidth(lvc.pszText) + 15;
		break;
	case -1:
		getlvc.mask = LVCF_WIDTH;
		for (nCol = 0; m_list.GetColumn(nCol, &getlvc); nCol++)
			spaceUsed += getlvc.cx;
	
		m_list.GetClientRect(&rect);
		lvc.cx = rect.Width() - spaceUsed;
		break;
	default:
		m_list.GetClientRect(&rect);
		lvc.cx = (rect.Width() * size) / 100;
	}

	if (nMask & LVCF_SUBITEM)
	{
		if (nSubItem != -1)
			lvc.iSubItem = nSubItem;
		else
			lvc.iSubItem = nItem;
	}

	m_aiColumnWidths[nItem] = lvc.cx;
	m_aiMaxWidths[nItem] = lvc.cx;
	m_aiMinWidths[nItem] = lvc.cx;

	return m_list.InsertColumn(nItem, &lvc);
}

//-----------------------------------------------------------------------------
// The RefigureColumns method is called when the control is resized. It should
// use the information saved about the columns to change their widths. We
// assume that the last column should be sized to fit the remaining space, if
// possible. Here are our resizing rules:
//
//		1.	If the user has resized something, LEAVE THAT WIDTH ALONE.
//		2.	Otherwise, use the ratios originally set.
//		3.	If a column's wider than its widest item, use the widest item.
//		4.	If a column's smaller than its minimum width, use the min.
//		5.	Always size the last column to fit, unless it would be smaller
//			than its minimum.
//-----------------------------------------------------------------------------

void CMsieCtrl::RefigureColumns(CRect& rect)
{
	int iCol, iPercentageLeft, cxAvailable, cxTotal, cxWidth;
	BOOL bIgnoreColumn[20];

	if (rect == CRect(0,0,0,0))
		m_list.GetClientRect(&rect);

	// Initialize the running totals.

	iPercentageLeft = 100;
	cxAvailable = rect.Width();

	// The first pass will be used to find out what columns to leave alone.
	// Doing this allows us to use make a better estimate of the other
	// column's size using the ratios.

	for (iCol = 0; iCol < m_cColumns; iCol++)
	{
		if (m_list.GetColumnWidth(iCol) != m_aiColumnWidths[iCol])
		{
			cxAvailable -= m_list.GetColumnWidth(iCol);
			iPercentageLeft -= m_aiRequestedWidths[iCol];
			bIgnoreColumn[iCol] = TRUE;
		}
		else
			bIgnoreColumn[iCol] = FALSE;
	}
	cxTotal = cxAvailable;

	// Now, resize the rest of the columns.

	for (iCol = 0; iCol < m_cColumns; iCol++)
	{
		if (bIgnoreColumn[iCol])
			continue;

		// Compute how big this column should be, based on the space
		// remaining. Remember, cxTotal is the total remaining space
		// left after the fixed size columns have been accounted for.

		if (iCol + 1 < m_cColumns)
		{
			cxWidth = m_aiRequestedWidths[iCol] * cxAvailable / iPercentageLeft;
			iPercentageLeft -= m_aiRequestedWidths[iCol];

			if (cxWidth > m_aiMaxWidths[iCol]) cxWidth = m_aiMaxWidths[iCol];
			if (cxWidth < m_aiMinWidths[iCol]) cxWidth = m_aiMinWidths[iCol];
		}
		else
		{
			// This is the last column. Try out using the space available.

			cxWidth = cxAvailable;
			if (cxWidth < m_aiMinWidths[iCol]) cxWidth = m_aiMinWidths[iCol];
		}

		// if first column, add space for icon

		if (!iCol)
			cxWidth += 20;

		cxAvailable -= cxWidth;
		m_list.SetColumnWidth(iCol, cxWidth);
		m_aiColumnWidths[iCol] = m_list.GetColumnWidth(iCol);
	}
}

//-----------------------------------------------------------------------------
// The AddItem method is used to add a line to the list control.
//-----------------------------------------------------------------------------

BOOL CMsieCtrl::AddItem(int nItem, int nSubItem, LPCTSTR strItem, int nImageIndex)
{
	LV_ITEM lvItem;
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = nItem;
	lvItem.iSubItem = nSubItem;
	lvItem.pszText = (LPTSTR)strItem;
	if (nSubItem == 0)
	{
		if (nImageIndex != -1)
		{
			lvItem.mask |= LVIF_IMAGE;
			lvItem.iImage = nImageIndex;
		}
		return m_list.InsertItem(&lvItem);
	}
	return m_list.SetItem(&lvItem);
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// When the view property is changed, we should update whatever
// variables used to display the information so the new view will
// be reflected when the control is redrawn, or when data is returned
// by the MSInfoGetText method. This method should NOT refresh the
// information from the system (that's what MSInfoRefresh is for) or
// cause the control to redraw itself.
//-----------------------------------------------------------------------------

void CMsieCtrl::OnMSInfoViewChanged() 
{
	TRACE1("-- CMsieCtrl::OnMSInfoViewChanged() [changed to %ld]\n", m_MSInfoView);
}


void CMsieCtrl::DeleteArrayObject(void *ptrArray)
{
	LIST_ITEM *pListItem;
	LIST_FILE_VERSION *pFileVersion;
	LIST_OBJECT *pObject;
	LIST_CERT *pCert;
	LIST_NAME *pName;
	EDIT_ITEM *pEditItem;

	if (ptrArray)
	{
		switch (m_MSInfoView)
		{
		case MSIVIEW_FILE_VERSIONS:
			pFileVersion = (LIST_FILE_VERSION *)ptrArray;
			delete pFileVersion;
			break;
		case MSIVIEW_OBJECT_LIST:
			pObject = (LIST_OBJECT *)ptrArray;
			delete pObject;
			break;
		case MSIVIEW_CONNECTIVITY:
			pEditItem = (EDIT_ITEM *)ptrArray;
			delete pEditItem;
			break;
		case MSIVIEW_PERSONAL_CERTIFICATES:
		case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
			pCert = (LIST_CERT *)ptrArray;
			delete pCert;
			break;
		case MSIVIEW_PUBLISHERS:
			pName = (LIST_NAME *)ptrArray;
			delete pName;
			break;
		default:
			pListItem = (LIST_ITEM *)ptrArray;
			delete pListItem;
		}
	}
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// The MSInfoRefresh method is where the bulk of the work will be
// done for your control. You should requery the system for all of the
// information you display. If this query has the potential to be
// at all time consuming, monitor the long pointed to by pCancel.
// If it is ever non-zero, cancel the update. If the update is
// cancelled, the control is responsible for restoring itself to the
// original, pre-refresh state. 
//
// This method should never be called if the control is displaying 
// previously saved information.
// 
// If the fForSave parameter is TRUE, then the control is being
// updated prior to saving to a stream. In this case, ALL information
// should be gathered (not just info relevant to the current
// MSInfoView) and the control should not be redrawn. Otherwise, for
// efficiency, you can update information only shown by the current
// view.
//-----------------------------------------------------------------------------

void CMsieCtrl::MSInfoRefresh(BOOL fForSave, long FAR* pCancel) 
{
	TRACE1("-- CMsieCtrl::MSInfoRefresh(%s,...)\n", (fForSave) ? "TRUE" : "FALSE");

	CPtrArray ptrarrayNew;
	int i, iListItem;

	if (!m_bCurrent) return;

	// Remember, we need to check if the update was cancelled. It's a good idea
	// to check before we start the update, in case it was cancelled while the
	// control was being loaded.

	if (*pCancel != 0L) return;

	// Call a method to update the new pointer array with current info, based
	// on what view we should be showing.

	iListItem = 0;
	if (fForSave)
	{
		for (i = MSIVIEW_BEGIN; i <= MSIVIEW_END; i++)
			RefreshArray(i, iListItem, ptrarrayNew);
	}
	else
		RefreshArray(m_MSInfoView, iListItem, ptrarrayNew);

	// If this loop has been broken out of because of a cancel, then
	// deallocate all of the structures we've allocated for the list
	// and exit. If we're still OK, copy all of the new items over
	// to the real pointer array (deallocating what's already there).

	if (*pCancel == 0L)
	{
		i = 0;
		while (i < ptrarrayNew.GetSize())
		{
			// Delete what's already in the list (if there is anything
			// in the list).

			if (i < m_ptrarray.GetSize())
				DeleteArrayObject(m_ptrarray.GetAt(i));

			// Copy the element from the new array to the real array.

			m_ptrarray.SetAtGrow(i++, ptrarrayNew.GetAt(i));
		}

		// Finish emptying out the list (if necessary).

		while (i < m_ptrarray.GetSize())
		{
			DeleteArrayObject(m_ptrarray.GetAt(i));
			m_ptrarray.SetAt(i++, NULL);
		}
	}
	else
	{
		// Delete all of the items in the pointer array.

		for (int i = 0; i < ptrarrayNew.GetSize(); i++)
			DeleteArrayObject(ptrarrayNew.GetAt(i));

		ptrarrayNew.RemoveAll();
	}
}

void CMsieCtrl::RefreshArray(int iView, int &iListItem, CPtrArray &ptrarrayNew)
{
	TRACE0("-- CMsieCtrl::RefreshArray\n");

	long lCount, lIndex;

	m_uiView = iView;

	if (iView == MSIVIEW_SUMMARY)
	{
		IE_SUMMARY **ppData;
		CString strVersion;

		theApp.AppGetIEData(SummaryType, &lCount, (void***)&ppData);
		if (lCount == 1)
		{
			AddToArray(ptrarrayNew, iListItem++, IDS_VERSION, GetStringFromVariant((*ppData)->Version));
			AddToArray(ptrarrayNew, iListItem++, IDS_BUILD, GetStringFromVariant((*ppData)->Build));
			AddToArray(ptrarrayNew, iListItem++, IDS_PRODUCT_ID, GetStringFromVariant((*ppData)->ProductID));
			AddToArray(ptrarrayNew, iListItem++, IDS_APP_PATH, GetStringFromVariant((*ppData)->Path));
			AddToArray(ptrarrayNew, iListItem++, IDS_LAST_INSTALL_DATE, GetStringFromVariant((*ppData)->LastInstallDate));
			AddToArray(ptrarrayNew, iListItem++, IDS_LANGUAGE, GetStringFromVariant((*ppData)->Language));
			AddToArray(ptrarrayNew, iListItem++, IDS_ACTIVE_PRINTER, GetStringFromVariant((*ppData)->ActivePrinter));
			AddBlankLineToArray(ptrarrayNew, iListItem++);
			AddToArray(ptrarrayNew, iListItem++, IDS_CIPHER_STRENGTH, GetStringFromVariant((*ppData)->CipherStrength, IDS_FORMAT_BIT));
			AddToArray(ptrarrayNew, iListItem++, IDS_CONTENT_ADVISOR, GetStringFromVariant((*ppData)->ContentAdvisor));
			AddToArray(ptrarrayNew, iListItem++, IDS_IEAK_INSTALL, GetStringFromVariant((*ppData)->IEAKInstall));
		}
		theApp.AppDeleteIEData(SummaryType, lCount, (void**)ppData);
	}
	else if (iView == MSIVIEW_FILE_VERSIONS)
	{
		IE_FILE_VERSION **ppData;

		theApp.AppGetIEData(FileVersionType, &lCount, (void***)&ppData);
		for (lIndex = 0; lIndex < lCount; lIndex++)
		{
			AddFileVersionToArray(ptrarrayNew, iListItem++,
				GetStringFromVariant(ppData[lIndex]->File),
				GetStringFromVariant(ppData[lIndex]->Version),
				GetStringFromVariant(ppData[lIndex]->Size, IDS_FORMAT_KB),
				GetStringFromVariant(ppData[lIndex]->Date),
				GetStringFromVariant(ppData[lIndex]->Path),
				GetStringFromVariant(ppData[lIndex]->Company),
				ppData[lIndex]->Size.lVal,
				ppData[lIndex]->Date.date);
		}
		theApp.AppDeleteIEData(FileVersionType, lCount, (void**)ppData);
	}
	else if (iView == MSIVIEW_CONNECTIVITY)
	{
		IE_CONN_SUMMARY **ppData;
		IE_LAN_SETTINGS **ppLanData;
		IE_CONN_SETTINGS **ppConnData;
		CString strTemp;
		long lLanCount, lConnCount;

		theApp.AppGetIEData(ConnSummaryType, &lCount, (void***)&ppData);
		if (lCount == 1)
		{
			AddEditBlankLineToArray(ptrarrayNew, iListItem++);
			AddEditToArray(ptrarrayNew, iListItem++, IDS_CONN_PREF, GetStringFromVariant((*ppData)->ConnectionPreference));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_ENABLE_HTTP_1_1, GetStringFromVariant((*ppData)->EnableHttp11));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_HTTP_1_1, GetStringFromVariant((*ppData)->ProxyHttp11));
		}
		theApp.AppDeleteIEData(ConnSummaryType, lCount, (void**)ppData);

		theApp.AppGetIEData(LanSettingsType, &lLanCount, (void***)&ppLanData);
		if (lCount == 1)
		{
			AddEditBlankLineToArray(ptrarrayNew, iListItem++);
			AddEditToArray(ptrarrayNew, iListItem++, IDS_LAN_SETTINGS, _T(""), TRUE);
			AddEditBlankLineToArray(ptrarrayNew, iListItem++);
			AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_CONFIG_PROXY, GetStringFromVariant((*ppLanData)->AutoConfigProxy));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_PROXY_DETECT_MODE, GetStringFromVariant((*ppLanData)->AutoProxyDetectMode));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_CONFIG_URL, GetStringFromVariant((*ppLanData)->AutoConfigURL));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY, GetStringFromVariant((*ppLanData)->Proxy));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_SERVER, GetStringFromVariant((*ppLanData)->ProxyServer));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_OVERRIDE, GetStringFromVariant((*ppLanData)->ProxyOverride));
		}
		theApp.AppDeleteIEData(LanSettingsType, lLanCount, (void**)ppLanData);

		theApp.AppGetIEData(ConnSettingsType, &lConnCount, (void***)&ppConnData);
		if (lConnCount > 0)
		{
			for (lIndex = 0; lIndex < lConnCount; lIndex++)
			{
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, GetStringFromVariant(ppConnData[lIndex]->Name), _T(""), TRUE);
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_PROXY_DETECT_MODE, GetStringFromVariant(ppConnData[lIndex]->AutoProxyDetectMode));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_CONFIG_URL, GetStringFromVariant(ppConnData[lIndex]->AutoConfigURL));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY, GetStringFromVariant(ppConnData[lIndex]->Proxy));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_SERVER, GetStringFromVariant(ppConnData[lIndex]->ProxyServer));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_OVERRIDE, GetStringFromVariant(ppConnData[lIndex]->ProxyOverride));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_ALLOW_INTERNET_PROGRAMS, GetStringFromVariant(ppConnData[lIndex]->AllowInternetPrograms));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_MAX_ATTEMPTS, GetStringFromVariant(ppConnData[lIndex]->RedialAttempts));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_WAIT_BETWEEN_ATTEMPTS, GetStringFromVariant(ppConnData[lIndex]->RedialWait));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_DISCONNECT_IDLE_TIME, GetStringFromVariant(ppConnData[lIndex]->DisconnectIdleTime));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_DISCONNECT, GetStringFromVariant(ppConnData[lIndex]->AutoDisconnect));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_MODEM, GetStringFromVariant(ppConnData[lIndex]->Modem));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_DIAL_UP_SERVER, GetStringFromVariant(ppConnData[lIndex]->DialUpServer));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_LOG_ON_TO_NETWORK, GetStringFromVariant(ppConnData[lIndex]->NetworkLogon));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_ENABLE_SOFTWARE_COMPRESSION, GetStringFromVariant(ppConnData[lIndex]->SoftwareCompression));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_REQUIRE_ENCRYPTED_PASSWORD, GetStringFromVariant(ppConnData[lIndex]->EncryptedPassword));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_REQUIRE_DATA_ENCRYPTION, GetStringFromVariant(ppConnData[lIndex]->DataEncryption));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_RECORD_LOG_FILE, GetStringFromVariant(ppConnData[lIndex]->RecordLogFile));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_NETWORK_PROTOCOLS, GetStringFromVariant(ppConnData[lIndex]->NetworkProtocols));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_USE_SERVER_ASSIGNED_IP_ADDRESS, GetStringFromVariant(ppConnData[lIndex]->ServerAssignedIPAddress));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_IP_ADDRESS, GetStringFromVariant(ppConnData[lIndex]->IPAddress));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_USE_SERVER_ASSIGNED_NAME_SERVER, GetStringFromVariant(ppConnData[lIndex]->ServerAssignedNameServer));
				strTemp.Format(IDS_PRIMARY_DNS, GetStringFromVariant(ppConnData[lIndex]->PrimaryDNS));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_NAME_SERVER_ADDRESSES, strTemp);
				strTemp.Format(IDS_SECONDARY_DNS, GetStringFromVariant(ppConnData[lIndex]->SecondaryDNS));
				AddEditToArray(ptrarrayNew, iListItem++, _T(""), strTemp);
				strTemp.Format(IDS_PRIMARY_WINS, GetStringFromVariant(ppConnData[lIndex]->PrimaryWINS));
				AddEditToArray(ptrarrayNew, iListItem++, _T(""), strTemp);
				strTemp.Format(IDS_SECONDARY_WINS, GetStringFromVariant(ppConnData[lIndex]->SecondaryWINS));
				AddEditToArray(ptrarrayNew, iListItem++, _T(""), strTemp);
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_USE_IP_HEADER_COMPRESSION, GetStringFromVariant(ppConnData[lIndex]->IPHeaderCompression));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_USE_DEFAULT_GATEWAY, GetStringFromVariant(ppConnData[lIndex]->DefaultGateway));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_SCRIPT_FILE_NAME, GetStringFromVariant(ppConnData[lIndex]->ScriptFileName));
			}
			theApp.AppDeleteIEData(ConnSettingsType, lConnCount, (void**)ppConnData);
		}
		else
		{
			AddEditBlankLineToArray(ptrarrayNew, iListItem++);
			AddEditToArray(ptrarrayNew, iListItem++, IDS_NO_CONNECTIONS, _T(""));
		}
	}
	else if (iView == MSIVIEW_CACHE)
	{
		IE_CACHE **ppData;

		theApp.AppGetIEData(CacheType, &lCount, (void***)&ppData);
		if (lCount == 1)
		{
			AddToArray(ptrarrayNew, iListItem++, IDS_PAGE_REFRESH_TYPE, GetStringFromVariant((*ppData)->PageRefreshType));
			AddToArray(ptrarrayNew, iListItem++, IDS_TEMPORARY_INTERNET_FILES_FOLDER, GetStringFromVariant((*ppData)->TempInternetFilesFolder));
			AddToArray(ptrarrayNew, iListItem++, IDS_TOTAL_DISK_SPACE, GetStringFromVariant((*ppData)->TotalDiskSpace, IDS_FORMAT_MB));
			AddToArray(ptrarrayNew, iListItem++, IDS_AVAILABLE_DISK_SPACE, GetStringFromVariant((*ppData)->AvailableDiskSpace, IDS_FORMAT_MB));
			AddToArray(ptrarrayNew, iListItem++, IDS_MAX_CACHE_SIZE, GetStringFromVariant((*ppData)->MaxCacheSize, IDS_FORMAT_MB));
			AddToArray(ptrarrayNew, iListItem++, IDS_AVAILABLE_CACHE_SIZE, GetStringFromVariant((*ppData)->AvailableCacheSize, IDS_FORMAT_MB));
		}
		theApp.AppDeleteIEData(CacheType, lCount, (void**)ppData);
	}
	else if (iView == MSIVIEW_OBJECT_LIST)
	{
		IE_OBJECT **ppData;

		theApp.AppGetIEData(ObjectType, &lCount, (void***)&ppData);
		if (lCount > 0)
		{
			for (lIndex = 0; lIndex < lCount; lIndex++)
			{
				AddObjectToArray(ptrarrayNew, iListItem++,
					GetStringFromVariant(ppData[lIndex]->ProgramFile),
					GetStringFromVariant(ppData[lIndex]->Status),
					GetStringFromVariant(ppData[lIndex]->CodeBase));
			}
			theApp.AppDeleteIEData(ObjectType, lCount, (void**)ppData);
		}
	}
	else if (iView == MSIVIEW_CONTENT)
	{
		IE_CONTENT **ppData;

		theApp.AppGetIEData(ContentType, &lCount, (void***)&ppData);
		if (lCount == 1)
		{
			AddToArray(ptrarrayNew, iListItem++, IDS_CONTENT_ADVISOR, GetStringFromVariant((*ppData)->Advisor));
		}
		theApp.AppDeleteIEData(ContentType, lCount, (void**)ppData);
	}
	else if ((iView == MSIVIEW_PERSONAL_CERTIFICATES) || (iView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES))
	{
		IE_CERTIFICATE **ppData;
		CString strType;
		int idsType;

		theApp.AppGetIEData(CertificateType, &lCount, (void***)&ppData);
		if (lCount > 0)
		{
			idsType = (iView == MSIVIEW_PERSONAL_CERTIFICATES)? IDS_PERSONAL_TYPE : IDS_OTHER_PEOPLE_TYPE;
			strType.LoadString(idsType);

			for (lIndex = 0; lIndex < lCount; lIndex++)
			{
				if (strType == ppData[lIndex]->Type.bstrVal)
					AddCertificateToArray(ptrarrayNew, iListItem++,
						GetStringFromVariant(ppData[lIndex]->IssuedTo),
						GetStringFromVariant(ppData[lIndex]->IssuedBy),
						GetStringFromVariant(ppData[lIndex]->Validity),
						GetStringFromVariant(ppData[lIndex]->SignatureAlgorithm));
			}
			theApp.AppDeleteIEData(CertificateType, lCount, (void**)ppData);
		}
	}
	else if (iView == MSIVIEW_PUBLISHERS)
	{
		IE_PUBLISHER **ppData;

		theApp.AppGetIEData(PublisherType, &lCount, (void***)&ppData);
		if (lCount > 0)
		{
			for (lIndex = 0; lIndex < lCount; lIndex++)
			{
				AddNameToArray(ptrarrayNew, iListItem++, GetStringFromVariant(ppData[lIndex]->Name));
			}
			theApp.AppDeleteIEData(PublisherType, lCount, (void**)ppData);
		}
	}
	else if (iView == MSIVIEW_SECURITY)
	{
		IE_SECURITY **ppData;

		theApp.AppGetIEData(SecurityType, &lCount, (void***)&ppData);
		if (lCount > 0)
		{
			for (lIndex = 0; lIndex < lCount; lIndex++)
			{
				AddToArray(ptrarrayNew, iListItem++, GetStringFromVariant(ppData[lIndex]->Zone), GetStringFromVariant(ppData[lIndex]->Level));
			}
			theApp.AppDeleteIEData(SecurityType, lCount, (void**)ppData);
		}
	}
}

CString CMsieCtrl::GetStringFromVariant(COleVariant &var, int idsFormat)
{
	COleDateTime dateTime;
	CString strRet;

	switch (var.vt)
	{
	case VT_BSTR:
		strRet = var.bstrVal;
		break;

	case VT_I4:
		if (idsFormat)
			strRet.Format(idsFormat, var.lVal);
		else
			strRet.Format(_T("%d"), var.lVal);
		break;

	case VT_R4:
		if (idsFormat)
			strRet.Format(idsFormat, var.fltVal);
		else
			strRet.Format(_T("%0.1f"), var.fltVal);
		break;

	case VT_BOOL:
		strRet.LoadString(var.boolVal ? IDS_TRUE : IDS_FALSE);
		break;

	case VT_I2:	// boolean
		strRet.LoadString(var.iVal ? IDS_TRUE : IDS_FALSE);
		break;

	case VT_DATE:
		dateTime = var.date;
		strRet = dateTime.Format();
		break;

	case VT_EMPTY:
		strRet.LoadString(IDS_NOT_AVAILABLE);
		break;

	default:
		ASSERT(false);		// should be handling this type
		strRet.LoadString(IDS_NOT_AVAILABLE);
	}
	return strRet;
}

//-----------------------------------------------------------------------------
// This helper method is called to add a list item to an array.
//-----------------------------------------------------------------------------

void CMsieCtrl::AddToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszItem, LPCTSTR pszValue)
{
	LIST_ITEM *pListItem;

	if ((pListItem = new LIST_ITEM) == NULL) 
		return;
	lstrcpyn(pListItem->szItem, pszItem, ITEM_LEN);
	lstrcpyn(pListItem->szValue, pszValue, VALUE_LEN);
	pListItem->uiView = m_uiView;
	ptrarray.SetAtGrow(itemNum, pListItem);
}

void CMsieCtrl::AddToArray(CPtrArray &ptrarray, int itemNum, int idsItem, LPCTSTR pszValue)
{
	CString strItem;

	strItem.LoadString(idsItem);
	AddToArray(ptrarray, itemNum, strItem, pszValue);
}

void CMsieCtrl::AddFileVersionToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszFile, LPCTSTR pszVersion, LPCTSTR pszSize, LPCTSTR pszDate, LPCTSTR pszPath, LPCTSTR pszCompany, DWORD dwSize, DATE date)
{
	LIST_FILE_VERSION *pFileVersion;

	if ((pFileVersion = new LIST_FILE_VERSION) == NULL) 
		return;
	lstrcpyn(pFileVersion->szFile, pszFile, _MAX_FNAME);
	lstrcpyn(pFileVersion->szVersion, pszVersion, VERSION_LEN);
	lstrcpyn(pFileVersion->szSize, pszSize, SIZE_LEN);
	lstrcpyn(pFileVersion->szDate, pszDate, DATE_LEN);
	lstrcpyn(pFileVersion->szPath, pszPath, VALUE_LEN);
	lstrcpyn(pFileVersion->szCompany, pszCompany, VALUE_LEN);
	pFileVersion->uiView = m_uiView;
	pFileVersion->dwSize = dwSize;
	pFileVersion->date = date;
	ptrarray.SetAtGrow(itemNum, pFileVersion);
}

void CMsieCtrl::AddEditToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszItem, LPCTSTR pszValue, BOOL bBold)
{
	EDIT_ITEM *pEditItem;

	if ((pEditItem = new EDIT_ITEM) == NULL) 
		return;

	lstrcpyn(pEditItem->szItem, pszItem, ITEM_LEN);
	lstrcpyn(pEditItem->szValue, pszValue, VALUE_LEN);
	pEditItem->uiView = m_uiView;
	pEditItem->bBold = bBold;
	ptrarray.SetAtGrow(itemNum, pEditItem);
}

void CMsieCtrl::AddEditToArray(CPtrArray &ptrarray, int itemNum, int idsItem, LPCTSTR pszValue, BOOL bBold)
{
	CString strItem;

	strItem.LoadString(idsItem);
	AddEditToArray(ptrarray, itemNum, strItem, pszValue, bBold);
}

void CMsieCtrl::AddObjectToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszProgramFile, LPCTSTR pszStatus, LPCTSTR pszCodeBase)
{
	LIST_OBJECT *pObject;

	if ((pObject = new LIST_OBJECT) == NULL) 
		return;
	lstrcpyn(pObject->szProgramFile, pszProgramFile, _MAX_FNAME);
	lstrcpyn(pObject->szStatus, pszStatus, STATUS_LEN);
	lstrcpyn(pObject->szCodeBase, pszCodeBase, MAX_PATH);
	pObject->uiView = m_uiView;
	ptrarray.SetAtGrow(itemNum, pObject);
}

void CMsieCtrl::AddCertificateToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszIssuedTo, LPCTSTR pszIssuedBy, LPCTSTR pszValidity, LPCTSTR pszSignatureAlgorithm)
{
	LIST_CERT *pCert;

	if ((pCert = new LIST_CERT) == NULL) 
		return;
	lstrcpyn(pCert->szIssuedTo, pszIssuedTo, _MAX_FNAME);
	lstrcpyn(pCert->szIssuedBy, pszIssuedBy, _MAX_FNAME);
	lstrcpyn(pCert->szValidity, pszValidity, _MAX_FNAME);
	lstrcpyn(pCert->szSignatureAlgorithm, pszSignatureAlgorithm, _MAX_FNAME);
	pCert->uiView = m_uiView;
	ptrarray.SetAtGrow(itemNum, pCert);
}

void CMsieCtrl::AddNameToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszName)
{
	LIST_NAME *pName;

	if ((pName = new LIST_NAME) == NULL) 
		return;
	lstrcpyn(pName->szName, pszName, _MAX_FNAME);
	pName->uiView = m_uiView;
	ptrarray.SetAtGrow(itemNum, pName);
}

//-----------------------------------------------------------------------------
// This helper method is called to add a blank line list item to an array.
//-----------------------------------------------------------------------------

void CMsieCtrl::AddBlankLineToArray(CPtrArray &ptrarray, int itemNum)
{
	AddToArray(ptrarray, itemNum, _T(""), _T(""));
}

void CMsieCtrl::AddEditBlankLineToArray(CPtrArray &ptrarray, int itemNum)
{
	AddEditToArray(ptrarray, itemNum, _T(""), _T(""));
}

//-----------------------------------------------------------------------------
// This method is called to update the display with the current data.
//-----------------------------------------------------------------------------

void CMsieCtrl::MSInfoUpdateView() 
{
	TRACE0("-- CMsieCtrl::MSInfoUpdateView()\n");

	if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
	{
		if (!m_edit.IsWindowVisible())
		{
			m_list.ShowWindow(SW_HIDE);
			m_list.EnableWindow(FALSE);

			m_static.ShowWindow(SW_SHOW);
			m_btnBasic.ShowWindow(SW_SHOW);
			m_btnBasic.EnableWindow(TRUE);
			m_btnAdvanced.ShowWindow(SW_SHOW);
			m_btnAdvanced.EnableWindow(TRUE);
			m_edit.ShowWindow(SW_SHOW);
			m_edit.EnableWindow(TRUE);
		}
		RefreshEditControl(TRUE);
	}
	else
	{
		if (!m_list.IsWindowVisible())
		{
			m_static.ShowWindow(SW_HIDE);
			m_btnBasic.ShowWindow(SW_HIDE);
			m_btnBasic.EnableWindow(FALSE);
			m_btnAdvanced.ShowWindow(SW_HIDE);
			m_btnAdvanced.EnableWindow(FALSE);
			m_edit.ShowWindow(SW_HIDE);
			m_edit.EnableWindow(FALSE);

			m_list.ShowWindow(SW_SHOW);
			m_list.EnableWindow(TRUE);
		}
		RefreshListControl(TRUE);
	}
}

//-----------------------------------------------------------------------------
// This method updates the list control to contain the contents of the
// pointer array. This is also where we compute some of the values used in 
// sizing the columns (like minimum and maximum column widths). Remember, only
// put the item in the list view if the MSInfoView index and the flag for
// the item agree.
//
// For each line we add, we set the item data for that line to be the index
// to the element in the pointer array for that item. Since more than one
// line comes from each element in the array, we OR in a constant.
//-----------------------------------------------------------------------------

void CMsieCtrl::RefreshListControl(BOOL bRedraw)
{
	TRACE0("-- CMsieCtrl::RefreshListControl()\n");

	LIST_ITEM *pListItem;
	LIST_FILE_VERSION *pFileVersion;
	LIST_OBJECT *pObject;
	LIST_CERT *pCert;
	LIST_NAME *pName;
	CRect	rect;
	int listIndex = 0;

	m_list.SetRedraw(FALSE);
	m_list.DeleteAllItems();


	// Format columns adds the appropriate columns to the list control.

	FormatColumns();

	for (int itemNum = 0; itemNum < m_ptrarray.GetSize(); itemNum++)
	{
		pListItem = (LIST_ITEM *)m_ptrarray.GetAt(itemNum);
		if (pListItem)
		{
			if ((long)pListItem->uiView == m_MSInfoView)
			{
				if (pListItem->uiView == MSIVIEW_FILE_VERSIONS)
				{
					pFileVersion = (LIST_FILE_VERSION *)pListItem;

					AddItem(listIndex, 0, pFileVersion->szFile);
					AddItem(listIndex, 1, pFileVersion->szVersion);
					AddItem(listIndex, 2, pFileVersion->szSize);
					AddItem(listIndex, 3, pFileVersion->szDate);
					AddItem(listIndex, 4, pFileVersion->szPath);
					AddItem(listIndex, 5, pFileVersion->szCompany);
				}
				else if (pListItem->uiView == MSIVIEW_OBJECT_LIST)
				{
					pObject = (LIST_OBJECT *)pListItem;

					AddItem(listIndex, 0, pObject->szProgramFile);
					AddItem(listIndex, 1, pObject->szStatus);
					AddItem(listIndex, 2, pObject->szCodeBase);
				}
				else if ((pListItem->uiView == MSIVIEW_PERSONAL_CERTIFICATES) || (pListItem->uiView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES))
				{
					pCert = (LIST_CERT *)pListItem;

					AddItem(listIndex, 0, pCert->szIssuedTo);
					AddItem(listIndex, 1, pCert->szIssuedBy);
					AddItem(listIndex, 2, pCert->szValidity);
					AddItem(listIndex, 3, pCert->szSignatureAlgorithm);
				}
				else if (pListItem->uiView == MSIVIEW_PUBLISHERS)
				{
					pName = (LIST_NAME *)pListItem;

					AddItem(listIndex, 0, pName->szName);
				}
				else
				{
					AddItem(listIndex, 0, pListItem->szItem);
					AddItem(listIndex, 1, pListItem->szValue);
				}
				m_list.SetItemData(listIndex, itemNum);
				listIndex++;
			}
		}
	}

	// Now, figure some values for the column widths. But only if we actually added
	// items to the list.

	if (listIndex)
	{
		int cxMax, cxWidth, cxMin, cxAverage;
		for (int iCol = 0; iCol < m_cColumns; iCol++)
		{
			cxMax = 0; cxMin = 0; cxAverage = 0;
			for (int iRow = 0; iRow < m_list.GetItemCount(); iRow++)
			{
				cxWidth = m_list.GetStringWidth(m_list.GetItemText(iRow, iCol));
				if (cxWidth > cxMax) 
					cxMax = cxWidth;
				if ((cxWidth < cxMin || cxMin == 0) && cxWidth != 0) 
					cxMin = cxWidth;

				cxAverage += cxWidth;
			}

			cxAverage /= m_list.GetItemCount();
			m_aiMaxWidths[iCol] = cxMax + 12;
			m_aiMinWidths[iCol] = cxAverage + 12;
		}
	}

	GetClientRect(&rect);
	RefigureColumns(rect);
	m_list.SetRedraw(TRUE);

	if (bRedraw)
		InvalidateControl();
}

void CMsieCtrl::RefreshEditControl(BOOL bRedraw)
{
	TRACE0("-- CMsieCtrl::RefreshEditControl()\n");

	EDIT_ITEM *pEditItem;
	CString strLine;
	CHARFORMAT cf;
	SIZE sizeSpace, sizeStr;
	int itemNum, nLen, i, cLines = 0;
	BOOL bBasicView;

	DrawLine();

	m_edit.SetRedraw(FALSE);
	m_edit.SetWindowText(_T(""));

	bBasicView = m_btnBasic.GetCheck();

	cf.cbSize = sizeof(cf);
	cf.dwMask = CFM_BOLD;
	GetTextExtentPoint(m_edit.GetDC()->m_hDC, _T(" "), 1, &sizeSpace);
	for (itemNum = 0; itemNum < m_ptrarray.GetSize(); itemNum++)
	{
		pEditItem = (EDIT_ITEM *)m_ptrarray.GetAt(itemNum);
		if (pEditItem)
		{
			if ((long)pEditItem->uiView == m_MSInfoView)
			{
				strLine = _T("   ");
				if (!pEditItem->bBold)
					strLine += _T(' ');

				strLine += pEditItem->szItem;

				if (pEditItem->szValue[0] != _T('\0'))
				{
					GetTextExtentPoint(m_edit.GetDC()->m_hDC, pEditItem->szItem, _tcslen(pEditItem->szItem), &sizeStr);

					nLen = sizeStr.cx / sizeSpace.cx;
					if (nLen < 50)
					{
						for (i = nLen; i < 50; i++)
							strLine += _T(' ');
					}
					strLine += _T('\t');
					strLine += pEditItem->szValue;
				}
				strLine += _T('\n');

				m_edit.SetSel(-1, -1);

				cf.dwEffects = pEditItem->bBold ? CFE_BOLD : 0;
				m_edit.SetSelectionCharFormat(cf);

				m_edit.ReplaceSel(strLine);

				// only show default connection info if basic info button checked

				if (bBasicView)
					if (++cLines == CONNECTIVITY_BASIC_LINES)
						break;
			}
		}
	}

	m_edit.SetRedraw(TRUE);
	if (bRedraw)
		InvalidateControl();
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// When the control is resized, we want to also resize the list
// control. We'll also call a method to resize the columns in the
// list control, based on the new control size.
//-----------------------------------------------------------------------------

void CMsieCtrl::OnSize(UINT nType, int cx, int cy) 
{
	COleControl::OnSize(nType, cx, cy);

	CRect rect;
	GetClientRect(&rect);

	m_edit.MoveWindow(CRect(rect.left, rect.top + 63, rect.right, rect.bottom));
	m_list.MoveWindow(&rect);

	if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
	{
		m_edit.Invalidate();
	}
	else
	{
		RefigureColumns(rect);
		m_list.Invalidate();
	}
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// The Serialize method is used to save the state of your object to
// a stream, or to load it from a stream. This stream is part of the
// compound MSInfo file. Your control can also open a file directly
// by making an entry in the MSInfo registry key indicating what
// file types it can open. In that case, the file will be passed to
// MSInfoLoadFile.
//
// The InternetExplorer category will save the items in it's list view to the
// archive as a struct. The first item in the archive will be a DWORD
// indicating how many pairs will be saved. The view for each struct will be
// archived out just before the struct for easier loading (knowing which type
// of struct to new for loading).
//-----------------------------------------------------------------------------

void CMsieCtrl::Serialize(CArchive& ar) 
{
	TRACE1("-- CMsieCtrl::Serialize() [%s]\n", (ar.IsStoring()) ? "STORE" : "LOAD");

	LIST_ITEM *pListItem;
	LIST_FILE_VERSION *pFileVersion;
	LIST_OBJECT *pObject;
	LIST_CERT *pCert;
	LIST_NAME *pName;
	EDIT_ITEM *pEditItem;
	DWORD dwCount;
	UINT uiView;

	if (ar.IsStoring())
	{
		dwCount = (DWORD) m_ptrarray.GetSize();
		ar << dwCount;

		for (DWORD i = 0; i < dwCount; i++)
		{
			pListItem = (LIST_ITEM *)m_ptrarray.GetAt(i);
			if (pListItem)
			{
				ar << pListItem->uiView;
				switch (pListItem->uiView)
				{
				case MSIVIEW_FILE_VERSIONS:
					pFileVersion = (LIST_FILE_VERSION *)pListItem;
					ar.Write((void *)pFileVersion, sizeof(LIST_FILE_VERSION));
					break;
				case MSIVIEW_OBJECT_LIST:
					pObject = (LIST_OBJECT *)pListItem;
					ar.Write((void *)pObject, sizeof(LIST_OBJECT));
					break;
				case MSIVIEW_CONNECTIVITY:
					pEditItem = (EDIT_ITEM *)pListItem;
					ar.Write((void *)pEditItem, sizeof(EDIT_ITEM));
					break;
				case MSIVIEW_PERSONAL_CERTIFICATES:
				case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
					pCert = (LIST_CERT *)pListItem;
					ar.Write((void *)pCert, sizeof(LIST_CERT));
					break;
				case MSIVIEW_PUBLISHERS:
					pName = (LIST_NAME *)pListItem;
					ar.Write((void *)pName, sizeof(LIST_NAME));
					break;
				default:
					ar.Write((void *)pListItem, sizeof(LIST_ITEM));
				}
			}
		}
	}
	else
	{
		ar >> dwCount;
		for (DWORD i = 0; i < dwCount; i++)
		{
			ar >> uiView;
			switch (uiView)
			{
			case MSIVIEW_FILE_VERSIONS:
				pFileVersion = new LIST_FILE_VERSION;
				if (pFileVersion)
				{
					if (ar.Read((void *)pFileVersion, sizeof(LIST_FILE_VERSION)) != sizeof(LIST_FILE_VERSION))
						break;
					m_ptrarray.SetAtGrow(i, pFileVersion);
				}
				break;
			case MSIVIEW_OBJECT_LIST:
				pObject = new LIST_OBJECT;
				if (pObject)
				{
					if (ar.Read((void *)pObject, sizeof(LIST_OBJECT)) != sizeof(LIST_OBJECT))
						break;
					m_ptrarray.SetAtGrow(i, pObject);
				}
				break;
			case MSIVIEW_CONNECTIVITY:
				pEditItem = new EDIT_ITEM;
				if (pEditItem)
				{
					if (ar.Read((void *)pEditItem, sizeof(EDIT_ITEM)) != sizeof(EDIT_ITEM))
						break;
					m_ptrarray.SetAtGrow(i, pEditItem);
				}
				break;
			case MSIVIEW_PERSONAL_CERTIFICATES:
			case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
				pCert = new LIST_CERT;
				if (pCert)
				{
					if (ar.Read((void *)pCert, sizeof(LIST_CERT)) != sizeof(LIST_CERT))
						break;
					m_ptrarray.SetAtGrow(i, pCert);
				}
				break;
			case MSIVIEW_PUBLISHERS:
				pName = new LIST_NAME;
				if (pName)
				{
					if (ar.Read((void *)pName, sizeof(LIST_NAME)) != sizeof(LIST_NAME))
						break;
					m_ptrarray.SetAtGrow(i, pName);
				}
				break;
			default:
				pListItem = new LIST_ITEM;
				if (pListItem)
				{
					if (ar.Read((void *)pListItem, sizeof(LIST_ITEM)) != sizeof(LIST_ITEM))
						break;
					m_ptrarray.SetAtGrow(i, pListItem);
				}
			}
		}
		m_bCurrent = false;
	} 
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// A control used in MSInfo has the ability to register itself as
// recognizing a file type (by extension). This entry is made in the
// registry, and when MSInfo lets the user open a file, files of this
// type can be displayed. If a file is chosen, a different set of
// categories is loaded, presumably all using this control. When
// the control is created, a call will be made to MSInfoLoadFile with
// the file to load.
//
// There isn't a native file format for this control, so we do
// exactly nothing.
//-----------------------------------------------------------------------------

BOOL CMsieCtrl::MSInfoLoadFile(LPCTSTR szFileName) 
{
	TRACE1("-- CMsieCtrl::MSInfoLoadFile(%s)\n", szFileName);
	return TRUE;
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// This method should do a select all on the information the control
// shows. This only applies to controls which support selection.
// If the selection is changed, the control is responsible for
// redrawing itself
//
// For this control, we mark all of the items in the list view as selected.
//-----------------------------------------------------------------------------

void CMsieCtrl::MSInfoSelectAll() 
{
	TRACE0("-- CMsieCtrl::SelectAll()\n");

	if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
	{
		m_edit.SetFocus();
		m_edit.SetSel(0, -1);
	}
	else
	{
		m_list.SetFocus();
		for (int i = 0; i < m_list.GetItemCount(); i++)
			m_list.SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);
	}

	InvalidateControl();
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// Use this method to copy the currently selected information into
// the clipboard in an appropriate format. If your control does not
// support user selection, then all of the data displayed by your
// control should be put into the clipboard. If this is the case,
// only the information shown by the current MSInfoView should be
// copied (if you support multiple views).
//
// We'll scan through the list view, and generate a text string
// containing the text from each selected line.
//-----------------------------------------------------------------------------

void CMsieCtrl::MSInfoCopy() 
{
	TRACE0("-- CMsieCtrl::MSInfoCopy()\n");

	CString strReturnText;
	int i, nIndex;

	// Build a string of the text of selected items.

	if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
	{
		strReturnText = m_edit.GetSelText();
	}
	else
	{
		for (i = 0; i < m_list.GetItemCount(); i++)
		{
			if (m_list.GetItemState(i, LVIS_SELECTED) != 0)
			{
				strReturnText += m_list.GetItemText(i, 0);
				for (nIndex = 1; nIndex < m_cColumns; nIndex++)
				{
					strReturnText += '\t';
					strReturnText += m_list.GetItemText(i, nIndex);
				}
				strReturnText += CString("\r\n");
			}
		}
	}

	// Put that text in the clipboard.

	if (OpenClipboard())
	{
		if (EmptyClipboard())
		{
			DWORD	dwSize = strReturnText.GetLength() + 1;	// +1 for terminating NULL
			HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize);

			if (hMem)
			{
				LPVOID lpvoid = GlobalLock(hMem);
				if (lpvoid)
				{
					memcpy(lpvoid, (LPCTSTR) strReturnText, dwSize);
					GlobalUnlock(hMem);
					SetClipboardData(CF_TEXT, hMem);
				}
			}
		}
		CloseClipboard();
	}
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// The control should return its contents as text when this method
// is called. The parameters are a pointer to a buffer and a length
// of the buffer in bytes. Write the contents of the control to the
// buffer (including a null) up to dwLength. Return the number of
// bytes copied (not including the null). If the pointer parameter is
// null, then just return the length.
//
// For this example, we get the text from the list and concatenate
// the columns together.
//-----------------------------------------------------------------------------

static CString strGetDataReturnText;

long CMsieCtrl::MSInfoGetData(long dwMSInfoView, long FAR* pBuffer, long dwLength) 
{
	TRACE2("-- CMsieCtrl::MSInfoGetData(0x%08x, %ld)\n", (long) pBuffer, dwLength);

	LIST_ITEM *	pListItem;
	LIST_FILE_VERSION *pFileVersion;
	LIST_OBJECT *pObject;
	LIST_CERT *pCert;
	LIST_NAME *pName;
	CString strWorking, strTemp;

	if (pBuffer == NULL)
	{
		// We should get the data from the array of pointers, not the list
		// control. This is because this method might be called without
		// ever drawing the list. We need to use the current MSInfoView
		// in determining what to return.

		strGetDataReturnText.Empty();

		// write out column headers if view with columns

		switch (dwMSInfoView)
		{
		case MSIVIEW_FILE_VERSIONS:
			strTemp.LoadString(IDS_FILE);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_VERSION);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_SIZE);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_DATE);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_PATH);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_COMPANY);
			strGetDataReturnText += strTemp;
			break;

		case MSIVIEW_OBJECT_LIST:
			strTemp.LoadString(IDS_PROGRAM_FILE);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_STATUS);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_CODE_BASE);
			strGetDataReturnText += strTemp;
			break;

		case MSIVIEW_PERSONAL_CERTIFICATES:
		case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
			break;

//  BUGBUG: NEED TO FILL IN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

		case MSIVIEW_PUBLISHERS:
			break;

//  BUGBUG: NEED TO FILL IN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			break;
		}

		for (int i = 0; i < m_ptrarray.GetSize(); i++)
		{
			pListItem = (LIST_ITEM *) m_ptrarray.GetAt(i);
			if (pListItem != NULL)
			{
				if ((long)pListItem->uiView == dwMSInfoView)
				{
					strWorking.Empty();

					switch (dwMSInfoView)
					{
					case MSIVIEW_FILE_VERSIONS:
						pFileVersion = (LIST_FILE_VERSION *)pListItem;
						if (pFileVersion->szFile[0] != _T('\0'))
						{
							strWorking += pFileVersion->szFile;
							strWorking += '\t';
							strWorking += pFileVersion->szVersion;
							strWorking += '\t';
							strWorking += pFileVersion->szSize;
							strWorking += '\t';
							strWorking += pFileVersion->szDate;
							strWorking += '\t';
							strWorking += pFileVersion->szPath;
							strWorking += '\t';
							strWorking += pFileVersion->szCompany;
						}
						break;

					case MSIVIEW_OBJECT_LIST:
						pObject = (LIST_OBJECT *)pListItem;
						if (pObject->szProgramFile[0] != _T('\0'))
						{
							strWorking += pObject->szProgramFile;
							strWorking += '\t';
							strWorking += pObject->szStatus;
							strWorking += '\t';
							strWorking += pObject->szCodeBase;
						}
						break;

					case MSIVIEW_PERSONAL_CERTIFICATES:
					case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
						pCert = (LIST_CERT *)pListItem;
						if (pCert->szIssuedTo[0] != _T('\0'))
						{
							strWorking += pCert->szIssuedTo;
							strWorking += '\t';
							strWorking += pCert->szIssuedBy;
							strWorking += '\t';
							strWorking += pCert->szValidity;
							strWorking += '\t';
							strWorking += pCert->szSignatureAlgorithm;
						}
						break;

					case MSIVIEW_PUBLISHERS:
						pName = (LIST_NAME *)pListItem;
						if (pName->szName[0] != _T('\0'))
						{
							strWorking += pName->szName;
						}
						break;

					default:
						strWorking += pListItem->szItem;
						strWorking += '\t';
						strWorking += pListItem->szValue;
					}
					strWorking.TrimRight();
					if (!strGetDataReturnText.IsEmpty())
						strGetDataReturnText += _T("\r\n");
					strGetDataReturnText += strWorking;
				}
			}
		}

		return (long) strGetDataReturnText.GetLength();
	}
	else
	{
		DWORD	dwSize;

		// dwSize will be the number of characters to copy, and shouldn't
		// include the null terminator.

		dwSize = strGetDataReturnText.GetLength();
		if (dwLength <= (long)dwSize)
		{
			// There isn't enough room in the buffer to copy all of the
			// characters and the null, so we'll need to concatenate.

			dwSize = dwLength - 1;
		}

		memcpy(pBuffer, (LPCTSTR) strGetDataReturnText, dwSize);
		((char *)pBuffer)[dwSize] = '\0';
		return (long) dwSize;
	}
}

//-----------------------------------------------------------------------------
// We override the OnNotify member because we want to be able to take action
// when the user resizes a column (possibly by double clicking the divider)
// and when the user clicks on a column header (we want to sort by that
// column).
//-----------------------------------------------------------------------------

CPtrArray* pptrarray;
static bool bAscendingOrder = true;
static int nLastColumn = 0;
int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
BOOL CMsieCtrl::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	NMHDR *pnmhdr = (NMHDR *)lParam;
	NM_LISTVIEW *pnmlv;

	if (pnmhdr)
	{
		if (pnmhdr->code == HDN_ENDTRACK || pnmhdr->code == HDN_DIVIDERDBLCLICK)
			RefigureColumns(CRect(0,0,0,0));

		if (wParam == IDC_LISTCTRL)
		{
			switch (pnmhdr->code)
			{
			case LVN_COLUMNCLICK:

				if ((m_MSInfoView == MSIVIEW_FILE_VERSIONS) ||
					(m_MSInfoView == MSIVIEW_OBJECT_LIST) ||
					(m_MSInfoView == MSIVIEW_PERSONAL_CERTIFICATES) ||
					(m_MSInfoView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES) ||
					(m_MSInfoView == MSIVIEW_PUBLISHERS))
				{
					pnmlv = (NM_LISTVIEW*)lParam;
					pptrarray = &m_ptrarray;

					if (nLastColumn == pnmlv->iSubItem)
					{
						bAscendingOrder = !bAscendingOrder;
					}
					else
					{
						bAscendingOrder = true;
						nLastColumn = pnmlv->iSubItem;
					}

					m_list.SortItems(CompareFunc, (LPARAM)pnmlv->iSubItem);
				}
				break;
			}
		}
	}
	
	return COleControl::OnNotify(wParam, lParam, pResult);
}

//-----------------------------------------------------------------------------
// This compare function is called by the list control as a callback when we
// sort the list.
//-----------------------------------------------------------------------------

int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	int nRet = 0;
	double flDateDiff;

   // lParamSort contains a pointer to the list view control.
   // The lParam of an item is just its index.

	LIST_ITEM *pItem = (LIST_ITEM *)pptrarray->GetAt(lParam1);

	if (pItem->uiView == MSIVIEW_FILE_VERSIONS)
	{
		LIST_FILE_VERSION* pItem1 = (LIST_FILE_VERSION *)pptrarray->GetAt(lParam1);
		LIST_FILE_VERSION* pItem2 = (LIST_FILE_VERSION *)pptrarray->GetAt(lParam2);

		ASSERT(pItem1 != NULL && pItem2 != NULL);
		if (pItem1 == NULL || pItem2 == NULL)
			return 0;

		switch (lParamSort)
		{
			case 0:
				nRet = _tcsicmp(pItem1->szFile, pItem2->szFile);
				break;

			case 1:
				nRet = _tcsicmp(pItem2->szVersion, pItem1->szVersion);
				break;
			
			case 2:
				nRet = pItem1->dwSize - pItem2->dwSize;
				break;
			
			case 3:
				flDateDiff = pItem1->date - pItem2->date;
				if (flDateDiff > 0)
					nRet = -1;
				else if (flDateDiff < 0)
					nRet = 1;
				break;

			case 4:
				nRet = _tcsicmp(pItem1->szPath, pItem2->szPath);
				break;

			case 5:
				nRet = _tcsicmp(pItem1->szCompany, pItem2->szCompany);
				break;
		}
	}
	else if (pItem->uiView == MSIVIEW_OBJECT_LIST)
	{
		LIST_OBJECT* pItem1 = (LIST_OBJECT *)pptrarray->GetAt(lParam1);
		LIST_OBJECT* pItem2 = (LIST_OBJECT *)pptrarray->GetAt(lParam2);

		ASSERT(pItem1 != NULL && pItem2 != NULL);
		if (pItem1 == NULL || pItem2 == NULL)
			return 0;

		switch (lParamSort)
		{
			case 0:
				nRet = _tcsicmp(pItem1->szProgramFile, pItem2->szProgramFile);
				break;

			case 1:
				nRet = _tcsicmp(pItem1->szStatus, pItem2->szStatus);
				break;
			
			case 2:
				nRet = _tcsicmp(pItem1->szCodeBase, pItem2->szCodeBase);
				break;
		}
	}
	else if ((pItem->uiView == MSIVIEW_PERSONAL_CERTIFICATES) || (pItem->uiView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES))
	{
		LIST_CERT* pItem1 = (LIST_CERT *)pptrarray->GetAt(lParam1);
		LIST_CERT* pItem2 = (LIST_CERT *)pptrarray->GetAt(lParam2);

		ASSERT(pItem1 != NULL && pItem2 != NULL);
		if (pItem1 == NULL || pItem2 == NULL)
			return 0;

		switch (lParamSort)
		{
			case 0:
				nRet = _tcsicmp(pItem1->szIssuedTo, pItem2->szIssuedTo);
				break;

			case 1:
				nRet = _tcsicmp(pItem1->szIssuedBy, pItem2->szIssuedBy);
				break;
			
			case 2:
				nRet = _tcsicmp(pItem1->szValidity, pItem2->szValidity);
				break;

			case 3:
				nRet = _tcsicmp(pItem1->szSignatureAlgorithm, pItem2->szSignatureAlgorithm);
				break;
		}
	}
	else if (pItem->uiView == MSIVIEW_PUBLISHERS)
	{
		LIST_NAME* pItem1 = (LIST_NAME *)pptrarray->GetAt(lParam1);
		LIST_NAME* pItem2 = (LIST_NAME *)pptrarray->GetAt(lParam2);

		ASSERT(pItem1 != NULL && pItem2 != NULL);
		if (pItem1 == NULL || pItem2 == NULL)
			return 0;

		switch (lParamSort)
		{
			case 0:
				nRet = _tcsicmp(pItem1->szName, pItem2->szName);
				break;
		}
	}

	if (!bAscendingOrder)
		nRet = -nRet;

	return nRet;
}

HBRUSH CMsieCtrl::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	switch (nCtlColor)
	{
	case CTLCOLOR_STATIC:
	case CTLCOLOR_BTN:
		return (HBRUSH)(m_pCtlBkBrush->GetSafeHandle());

	default:
		return CWnd::OnCtlColor(pDC, pWnd, nCtlColor);
	}
}

void CMsieCtrl::OnBasicBtnClicked()
{
	MSInfoUpdateView();
}

void CMsieCtrl::OnAdvancedBtnClicked()
{
	MSInfoUpdateView();
}

/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::XWbemProviderInit

STDMETHODIMP_(ULONG) CMsieCtrl::XWbemProviderInit::AddRef()
{
	METHOD_PROLOGUE(CMsieCtrl, WbemProviderInit)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMsieCtrl::XWbemProviderInit::Release()
{
	METHOD_PROLOGUE(CMsieCtrl, WbemProviderInit)
	return pThis->ExternalRelease();
}

STDMETHODIMP CMsieCtrl::XWbemProviderInit::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE(CMsieCtrl, WbemProviderInit)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CMsieCtrl::XWbemProviderInit::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
	METHOD_PROLOGUE(CMsieCtrl, WbemProviderInit)

	if (pNamespace)
		pNamespace->AddRef();
	pThis->m_pNamespace = pNamespace;

	//Let CIMOM know you are initialized

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::XWbemServices

STDMETHODIMP_(ULONG) CMsieCtrl::XWbemServices::AddRef()
{
	METHOD_PROLOGUE(CMsieCtrl, WbemServices)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMsieCtrl::XWbemServices::Release()
{
	METHOD_PROLOGUE(CMsieCtrl, WbemServices)
	return pThis->ExternalRelease();
}

STDMETHODIMP CMsieCtrl::XWbemServices::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE(CMsieCtrl, WbemServices)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

SCODE CMsieCtrl::XWbemServices::CreateInstanceEnumAsync(const BSTR RefStr, long lFlags, IWbemContext *pCtx, IWbemObjectSink *pHandler)
{
	METHOD_PROLOGUE(CMsieCtrl, WbemServices)

	IWbemClassObject *pClass = NULL;
	IWbemClassObject **ppInstances = NULL;
	SCODE sc;
	void **ppData;
	IEDataType enType;
	long cInstances, lIndex;

	CoImpersonateClient();

	// Do a check of arguments and make sure we have pointer to Namespace

	if (pHandler == NULL || pThis->m_pNamespace == NULL)
		return WBEM_E_INVALID_PARAMETER;

	// Get a class object from CIMOM

	sc = pThis->m_pNamespace->GetObject(RefStr, 0, pCtx, &pClass, NULL);
	if (sc != S_OK)
		return WBEM_E_FAILED;

	if (pThis->GetIEType(RefStr, enType))
	{
		theApp.AppGetIEData(enType, &cInstances, (void***)&ppData);

		ppInstances = (IWbemClassObject**)new LPVOID[cInstances];

		for (lIndex = 0; lIndex < cInstances; lIndex++)
		{
			// Create an instance object and fill it will appropriate Office data

			sc = pClass->SpawnInstance(0, &ppInstances[lIndex]);
			if (SUCCEEDED(sc))
			{
				pThis->SetIEProperties(enType, ppData[lIndex], ppInstances[lIndex]);
			}
		}
		theApp.AppDeleteIEData(enType, cInstances, ppData);
	}
	else
	{
		sc = WBEM_E_NOT_FOUND;
	}

	pClass->Release();

	if (SUCCEEDED(sc))
	{
		// Send the instances to the caller

		pHandler->Indicate(cInstances, ppInstances);

		for (lIndex = 0; lIndex < cInstances; lIndex++)
			ppInstances[lIndex]->Release();
	}

	// Clean up

	if (ppInstances)
		delete []ppInstances;

	// Set status

	pHandler->SetStatus(0, sc, NULL, NULL);

	return sc;
}

bool CMsieCtrl::GetIEType(const BSTR classStr, IEDataType &enType)
{
	bool bRet = true;
	CString strClass(classStr);

	if (strClass == _T("MicrosoftIE_Summary"))  enType = SummaryType;
	else if (strClass == _T("MicrosoftIE_FileVersion"))  enType = FileVersionType;
	else if (strClass == _T("MicrosoftIE_ConnectionSummary"))  enType = ConnSummaryType;
	else if (strClass == _T("MicrosoftIE_LanSettings"))  enType = LanSettingsType;
	else if (strClass == _T("MicrosoftIE_ConnectionSettings"))  enType = ConnSettingsType;
	else if (strClass == _T("MicrosoftIE_Cache"))  enType = CacheType;
	else if (strClass == _T("MicrosoftIE_Object"))  enType = ObjectType;
	else if (strClass == _T("MicrosoftIE_Certificate"))  enType = CertificateType;
	else if (strClass == _T("MicrosoftIE_Publisher"))  enType = PublisherType;
	else if (strClass == _T("MicrosoftIE_Security"))  enType = SecurityType;
	else
	{
		bRet = false;
	}

	return bRet;
}

void CMsieCtrl::ConvertDateToWbemString(COleVariant &var)
{
	COleDateTime dateTime;
	CString strDateTime;

	dateTime = var.date;
	strDateTime = dateTime.Format(_T("%Y%m%d%H%M%S.******+***"));
	var = strDateTime.AllocSysString();
}

void CMsieCtrl::SetIEProperties(IEDataType enType, void *pIEData, IWbemClassObject *pInstance)
{
	if (enType == SummaryType)
	{
		IE_SUMMARY *pData = (IE_SUMMARY*)pIEData;

		SETPROPERTY(Name);
		SETPROPERTY(Version);
		SETPROPERTY(Build);
		SETPROPERTY(ProductID);
		SETPROPERTY(Path);
		SETPROPERTY(Language);
		SETPROPERTY(ActivePrinter);
		SETPROPERTY(CipherStrength);
		SETPROPERTY(ContentAdvisor);
		SETPROPERTY(IEAKInstall);
	}
	else if (enType == FileVersionType)
	{
		IE_FILE_VERSION *pData = (IE_FILE_VERSION*)pIEData;
		CString strVersion, strFileMissing;

		SETPROPERTY(File);
		SETPROPERTY(Version);

		// don't set rest of properties if file is missing

		strVersion = pData->Version.bstrVal;
		strFileMissing.LoadString(IDS_FILE_MISSING);
		if (strFileMissing != strVersion)
		{
			SETPROPERTY(Size);
			SETPROPERTY(Date);
			SETPROPERTY(Path);
			SETPROPERTY(Company);
		}
	}
	else if (enType == ConnSummaryType)
	{
		IE_CONN_SUMMARY *pData = (IE_CONN_SUMMARY*)pIEData;

		SETPROPERTY(ConnectionPreference);
		SETPROPERTY(EnableHttp11);
		SETPROPERTY(ProxyHttp11);
	}
	else if (enType == LanSettingsType)
	{
		IE_LAN_SETTINGS *pData = (IE_LAN_SETTINGS*)pIEData;

		SETPROPERTY(AutoConfigProxy);
		SETPROPERTY(AutoProxyDetectMode);
		SETPROPERTY(AutoConfigURL);
		SETPROPERTY(Proxy);
		SETPROPERTY(ProxyServer);
		SETPROPERTY(ProxyOverride);
	}
	else if (enType == ConnSettingsType)
	{
		IE_CONN_SETTINGS *pData = (IE_CONN_SETTINGS*)pIEData;

		SETPROPERTY(Name);
		SETPROPERTY(Default);
		SETPROPERTY(AutoProxyDetectMode);
		SETPROPERTY(AutoConfigURL);
		SETPROPERTY(Proxy);
		SETPROPERTY(ProxyServer);
		SETPROPERTY(ProxyOverride);
		SETPROPERTY(AllowInternetPrograms);
		SETPROPERTY(RedialAttempts);
		SETPROPERTY(RedialWait);
		SETPROPERTY(DisconnectIdleTime);
		SETPROPERTY(AutoDisconnect);
		SETPROPERTY(Modem);
		SETPROPERTY(DialUpServer);
		SETPROPERTY(NetworkLogon);
		SETPROPERTY(SoftwareCompression);
		SETPROPERTY(EncryptedPassword);
		SETPROPERTY(DataEncryption);
		SETPROPERTY(NetworkProtocols);
		SETPROPERTY(ServerAssignedIPAddress);
		SETPROPERTY(IPAddress);
		SETPROPERTY(ServerAssignedNameServer);
		SETPROPERTY(PrimaryDNS);
		SETPROPERTY(SecondaryDNS);
		SETPROPERTY(PrimaryWINS);
		SETPROPERTY(SecondaryWINS);
		SETPROPERTY(IPHeaderCompression);
		SETPROPERTY(DefaultGateway);
		SETPROPERTY(ScriptFileName);
	}
	else if (enType == CacheType)
	{
		IE_CACHE *pData = (IE_CACHE*)pIEData;

		SETPROPERTY(PageRefreshType);
		SETPROPERTY(TempInternetFilesFolder);
		SETPROPERTY(TotalDiskSpace);
		SETPROPERTY(AvailableDiskSpace);
		SETPROPERTY(MaxCacheSize);
		SETPROPERTY(AvailableCacheSize);
	}
	else if (enType == ObjectType)
	{
		IE_OBJECT *pData = (IE_OBJECT*)pIEData;

		SETPROPERTY(ProgramFile);
		SETPROPERTY(Status);
		SETPROPERTY(CodeBase);
	}
	else if (enType == CertificateType)
	{
		IE_CERTIFICATE *pData = (IE_CERTIFICATE*)pIEData;

		SETPROPERTY(Type);
		SETPROPERTY(IssuedTo);
		SETPROPERTY(IssuedBy);
		SETPROPERTY(Validity);
		SETPROPERTY(SignatureAlgorithm);
	}
	else if (enType == PublisherType)
	{
		IE_PUBLISHER *pData = (IE_PUBLISHER*)pIEData;

		SETPROPERTY(Name);
	}
	else if (enType == SecurityType)
	{
		IE_SECURITY *pData = (IE_SECURITY*)pIEData;

		SETPROPERTY(Zone);
		SETPROPERTY(Level);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\msie.cpp ===
// Msie.cpp : Implementation of CMsieApp and DLL registration.

#include "stdafx.h"
#include "Msie.h"
#include "regkeys.h"
#include "resdefs.h"
#include <wbemprov.h>
#include <AFXPRIV.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CMsieApp theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x25959bec, 0xe700, 0x11d2, { 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const LPCSTR CLSID_MSIE = "{25959BEF-E700-11D2-A7AF-00C04F806200}";
const LPCSTR IE_REPAIR_CMD = "rundll32 setupwbv.dll,IE6Maintenance \"%s\\Setup\\SETUP.EXE\" /g \"%s\\%s\"";

const LPCSTR OCX_FILE_IN_COMMON = "Microsoft Shared\\MSInfo\\ieinfo5.ocx";
const LPCSTR MOF_FILE_PATH = "%SystemRoot%\\System32\\WBEM\\MOF";
const LPCSTR MOF_FILE = "ieinfo5.mof";

const MAX_KEY_LENGTH = 256;



////////////////////////////////////////////////////////////////////////////
// CMsieApp::InitInstance - DLL initialization

BOOL CMsieApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		m_fTemplateLoaded		= FALSE;
		m_pTemplateInfo		= NULL;
		m_dwTemplateInfoLen	= 0;
	}

	return bInit;
}

////////////////////////////////////////////////////////////////////////////
// CMsieApp::ExitInstance - DLL termination

int CMsieApp::ExitInstance()
{
	if (m_pTemplateInfo != NULL)
	{
		delete m_pTemplateInfo;
		m_pTemplateInfo = NULL;
	}
	return COleControlModule::ExitInstance();
}

//-----------------------------------------------------------------------------
// AppGetTemplate is the entry point for the app object from outside the DLL.
// It's called by the exported function GetTemplate. The reconstructed template
// file should be returned to the caller as a pointer in the pBuffer parameter.
//
// If a NULL pointer is passed for pBuffer, we are free to delete the internal
// buffer storing the template file.
//-----------------------------------------------------------------------------

DWORD CMsieApp::AppGetTemplate(void ** ppBuffer)
{
	if (!m_fTemplateLoaded)
	{
		LoadTemplate();
		m_fTemplateLoaded = TRUE;
	}

	if (ppBuffer == NULL)
	{
		if (m_pTemplateInfo)
			delete m_pTemplateInfo;

		m_pTemplateInfo = NULL;
		m_dwTemplateInfoLen = 0;
		m_fTemplateLoaded = FALSE;
		return 0;
	}

	*ppBuffer = (void *)m_pTemplateInfo;
	return m_dwTemplateInfoLen;
}

//-----------------------------------------------------------------------------
// This table of keywords is used during the reconstruction process. It matches
// exactly the table used during the conversion from NFT to resources, and it
// MUST NOT be modified, or the reconstructed information will be bogus.
//-----------------------------------------------------------------------------

#define KEYWORD_COUNT 19
char * KEYWORD_STRING[KEYWORD_COUNT] = 
{
	"node", "columns", "line", "field", "enumlines", "(", ")", "{", "}", ",",
	"\"basic\"", "\"advanced\"", "\"BASIC\"", "\"ADVANCED\"", "\"static\"",
	"\"LEXICAL\"", "\"VALUE\"", "\"NONE\"", "\"\""
};

//-----------------------------------------------------------------------------
// The LoadTemplate function needs to load the template information out of
// our resources, and create a buffer which contains the restored template
// file to return to our caller (through AppGetTemplate).
//-----------------------------------------------------------------------------

void CMsieApp::LoadTemplate()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMapWordToPtr	mapNonLocalized;
	HRSRC				hrsrcNFN;
	HGLOBAL			hglbNFN;
	unsigned char	*pData;
	WORD				wID;
	CString			strToken, *pstrToken;

	// In debug mode, we'll reconstruct the original template file for comparison.

/*#ifdef DBG
	CFile fileRestore(_T("ie-restore.nft"), CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite);
#endif*/

	// Load the non-localized strings from the custom resource type and create
	// a map of ID to strings. Because these are non-localized strings, they
	// will not be stored as Unicode. Each item in the stream is a 2 byte word
	// ID followed by a null-terminated string. A zero ID indicates the end of
	// the stream.

	hrsrcNFN		= FindResource(AfxGetResourceHandle(), _T("#1"), _T("MSINonLocalizedTokens"));
	hglbNFN		= LoadResource(AfxGetResourceHandle(), hrsrcNFN);
	pData			= (unsigned char *)LockResource(hglbNFN);

	while (pData && *((WORD UNALIGNED *)pData))
	{
		wID  = (WORD)(((WORD)*pData++) << 8);	// deal with the byte order explicitly to avoid
		wID |= (WORD)*pData++;						// endian problems.

		pstrToken = new CString((char *)pData);
		pData += strlen((char *)pData) + 1;

		if (pstrToken)
			mapNonLocalized.SetAt(wID, (void *)pstrToken);
	}

	// Load the binary stream of token identifiers into memory.

	HRSRC				hrsrcNFB = FindResource(AfxGetResourceHandle(), _T("#1"), _T("MSITemplateStream"));
	HGLOBAL			hglbNFB = LoadResource(AfxGetResourceHandle(), hrsrcNFB);
	unsigned char *pStream = (unsigned char *) LockResource(hglbNFB);

	if (pStream)
	{
		// The first DWORD in the stream is the size of the original text file. We'll
		// use this to allocate our buffer to store the reconstituted file.

		DWORD dwSize;
		dwSize  = ((DWORD)*pStream++) << 24;
		dwSize |= ((DWORD)*pStream++) << 16;
		dwSize |= ((DWORD)*pStream++) << 8;
		dwSize |= ((DWORD)*pStream++);

		// The size stored is for an Ansi text file. We need to adjust for the
		// fact that our reconstituted file will be Unicode. We also want to add
		// a word to the front of the stream to hold the Unicode file marker (so
		// MSInfo can use the same functions to read a file or this stream).

		dwSize *= sizeof(WCHAR);	// adjust for Unicode
		dwSize += sizeof(WORD);		// add room for Unicode file marker
		m_pTemplateInfo = new unsigned char[dwSize];
		m_dwTemplateInfoLen = 0;
		if (m_pTemplateInfo == NULL)
			return;

		// Write the Unicode file marker.

		wID = 0xFEFF;
		memcpy(&m_pTemplateInfo[m_dwTemplateInfoLen], (void *)&wID, sizeof(WORD));
		m_dwTemplateInfoLen += sizeof(WORD);

		// Process the stream a token at a time. For each new item in the stream, we
		// process it as follows:
		//
		// 1. If ((byte & 0x80) == 0x00), use the byte to lookup a KEYWORD_STRING.
		// 2. If ((byte & 0xC0) == 0x80), use the byte and the next byte as a word
		//    ID to lookup a non-localized token from mapNonLocalized.
		// 3. Else ((byte & 0xC0) == 0xC0), use the byte and the next byte as a word
		//    ID to lookup a localized token from the resources of this DLL.

		while (pStream && *pStream)
		{
			if ((*pStream & 0x80) == 0x00)
			{
				// A byte with the high bit clear refers to a keyword. Look up the keyword
				// from the table, and add it to the restored file.

				wID = (WORD)(((WORD)*pStream++) - 1); ASSERT(wID <= KEYWORD_COUNT);
				if (wID <= KEYWORD_COUNT)
					strToken = KEYWORD_STRING[wID];
			}
			else
			{
				wID  = (WORD)(((WORD)*pStream++) << 8);	// deal with the byte order explicitly to avoid
				wID |= (WORD)*pStream++;						// endian problems.

				if ((wID & 0xC000) == 0x8000)
				{
					// A byte with the high bit set, but the next to high bit clear indicates
					// the ID is actually a word, and should be used to get a non-localized
					// string. Get the string out of the map we created and add it to the file.

					if (mapNonLocalized.Lookup(((WORD)(wID & 0x7FFF)), (void *&)pstrToken))
						strToken = *pstrToken;
					else
						ASSERT(FALSE);
				}
				else
				{
					// A byte with the two MSB set indicates that the ID is a word, and should
					// be used to reference a localized string out of the string table in this
					// module's resources. This string will be UNICODE.

					VERIFY(strToken.LoadString((wID & 0x3FFF) + IDS_MSITEMPLATEBASE));
					strToken = _T("\"") + strToken + _T("\"");
				}
			}

			// Store the token on the end of our buffer. The data in this buffer must
			// be Unicode, so we'll need to convert the string if necessary.

			//v-stlowe  if (m_dwTemplateInfoLen + strToken.GetLength() * sizeof(WCHAR) < dwSize)
			if (m_dwTemplateInfoLen + strToken.GetLength() < dwSize)
			{
				// Converting to strToken to Unicode

				
				WCHAR *pwchToken;
				pwchToken = new WCHAR[strToken.GetLength() + 1];
				//v-stlowe ::MultiByteToWideChar(CP_ACP, 0, strToken, -1, pwchToken, (strToken.GetLength() + 1) * sizeof(WCHAR));
				
				
				USES_CONVERSION;
				wcscpy(pwchToken,T2W((LPTSTR)(LPCTSTR)strToken));

				// Copying Unicode string to buffer

				memcpy(&m_pTemplateInfo[m_dwTemplateInfoLen], (void *)pwchToken, wcslen(pwchToken) * sizeof(WCHAR));
				m_dwTemplateInfoLen += wcslen(pwchToken) * sizeof(WCHAR);
				
				delete pwchToken;
				
				/*memcpy(&m_pTemplateInfo[m_dwTemplateInfoLen],(void *) strToken.GetBuffer(strToken.GetLength()),strToken.GetLength());
				strToken.ReleaseBuffer();*/
			}
			else
				ASSERT(FALSE);

/*#ifdef DBG
			if (strToken == CString(_T("}")) || strToken == CString(_T("{")) || strToken == CString(_T(")")))
				strToken += CString(_T("\r\n"));
			fileRestore.Write((void *)(LPCTSTR)strToken, strToken.GetLength() * sizeof(TCHAR));
#endif*/

		}
	}

	// Delete the contents of the lookup table.

	#ifdef DBG
		CFile fileRestore(_T("test.nft"), CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite);
		fileRestore.Write(m_pTemplateInfo,m_dwTemplateInfoLen);
	#endif

	for (POSITION pos = mapNonLocalized.GetStartPosition(); pos != NULL;)
	{
		mapNonLocalized.GetNextAssoc(pos, wID, (void *&)pstrToken);
		if (pstrToken)
			delete pstrToken;
	}
}

////////////////////////////////////////////////////////////////////////////
// WriteNode - Helper function for writing an MSInfo node to the registry

void WriteNode(HKEY hKey, LPCTSTR pszSubKey, int idsDefault, DWORD dwView, DWORD dwRank)
{
	HKEY hNewKey;
	DWORD dwDisposition;
	CString strDefault;

	if (ERROR_SUCCESS == RegCreateKeyEx(hKey, pszSubKey, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hNewKey, &dwDisposition))
	{
		strDefault.LoadString(idsDefault);
		RegSetValueEx(hNewKey, NULL, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strDefault, strDefault.GetLength() + sizeof(TCHAR));
		RegSetValueEx(hNewKey, REG_CLSID, 0, REG_SZ, (const LPBYTE)CLSID_MSIE, strlen(CLSID_MSIE) + 1);
		RegSetValueEx(hNewKey, REG_MSINFO_VIEW, 0, REG_BINARY, (const LPBYTE)&dwView, sizeof(DWORD));
		RegSetValueEx(hNewKey, REG_RANK, 0, REG_BINARY, (const LPBYTE)&dwRank, sizeof(DWORD));

		RegCloseKey(hNewKey);
	}
}

////////////////////////////////////////////////////////////////////////////
// RegDeleteKeyRecusive - Helper function for deleting reg keys

DWORD RegDeleteKeyRecusive(HKEY hStartKey, LPCTSTR pKeyName)
{
   DWORD   dwRtn, dwSubKeyLength;
   LPTSTR  pSubKey = NULL;
   TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
   HKEY    hKey;

   // Do not allow NULL or empty key name
   if ( pKeyName &&  lstrlen(pKeyName))
   {
      if( (dwRtn = RegOpenKeyEx(hStartKey, pKeyName, 0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
      {
         while (dwRtn == ERROR_SUCCESS)
         {
            dwSubKeyLength = MAX_KEY_LENGTH;
            dwRtn=RegEnumKeyEx(
                           hKey,
                           0,       // always index zero
                           szSubKey,
                           &dwSubKeyLength,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );

            if(dwRtn == ERROR_NO_MORE_ITEMS)
            {
               dwRtn = RegDeleteKey(hStartKey, pKeyName);
               break;
            }
            else if(dwRtn == ERROR_SUCCESS)
               dwRtn = RegDeleteKeyRecusive(hKey, szSubKey);
         }
         RegCloseKey(hKey);
         // Do not save return code because error
         // has already occurred
      }
   }
   else
      dwRtn = ERROR_BADKEY;

   return dwRtn;
}

////////////////////////////////////////////////////////////////////////////
// GetIERepairToolCmdLine - Helper function for creating command line for
//									 launching IE Repair Tool.

CString GetIERepairToolCmdLine()
{
	CString strRet, strIEPath, strIEPathExpanded, strWindowsPath, strRepairLog;
	HKEY hKey;
	DWORD cbData;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_IE_SETUP_KEY, 0, KEY_QUERY_VALUE, &hKey))
	{
		cbData = MAX_PATH;
		RegQueryValueEx(hKey, REG_PATH, NULL, NULL, (LPBYTE)strIEPath.GetBuffer(MAX_PATH), &cbData);
		strIEPath.ReleaseBuffer();

		ExpandEnvironmentStrings(strIEPath, strIEPathExpanded.GetBuffer(MAX_PATH), MAX_PATH);
		strIEPathExpanded.ReleaseBuffer();

		RegCloseKey(hKey);
	}
	GetWindowsDirectory(strWindowsPath.GetBuffer(MAX_PATH), MAX_PATH);
	strWindowsPath.ReleaseBuffer();
	strRepairLog.LoadString(IDS_REPAIR_LOG);
	strRet.Format((LPCTSTR) IE_REPAIR_CMD, strIEPathExpanded, strWindowsPath, strRepairLog);

	return strRet;
}
			
/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OSVERSIONINFO osver;
	HKEY hCatKey, hIE6Key, hCacheKey, hContentKey, hRepairKey, hMsinfoKey, hTemplatesKey, hIeinfo5Key;
	HKEY hMicrosoftKey, hSharedToolsKey, hCurrentVersionKey;
	CString strCatKey, strKey, strValue, strFullPath, strMofPathSrc, strMofPathDest;
	BYTE szBuffer[MAX_PATH];
	DWORD dwDisposition, dwType, dwSize;
	int nIndex;
    HRESULT hr = S_OK;

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	// check OS ver

	osver.dwOSVersionInfoSize = sizeof(osver);
	VERIFY(GetVersionEx(&osver));
	if ((osver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osver.dwMajorVersion >= 5))
	{
		//***** Windows 2000 *****

		// add template reg entry

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_MICROSOFT_KEY, 0, KEY_CREATE_SUB_KEY, &hMicrosoftKey))
		{
			if (ERROR_SUCCESS == RegCreateKeyEx(hMicrosoftKey, REG_SHARED_TOOLS, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY, NULL, &hSharedToolsKey, &dwDisposition))
			{
				if (ERROR_SUCCESS == RegCreateKeyEx(hSharedToolsKey, REG_MSINFO, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY, NULL, &hMsinfoKey, &dwDisposition))
				{
					if (ERROR_SUCCESS == RegCreateKeyEx(hMsinfoKey, REG_TEMPLATES, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY, NULL, &hTemplatesKey, &dwDisposition))
					{
						if (ERROR_SUCCESS == RegCreateKeyEx(hTemplatesKey, REG_IEINFO5, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hIeinfo5Key, &dwDisposition))
						{
							if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CURRENT_VERSION_KEY, 0, KEY_QUERY_VALUE, &hCurrentVersionKey))
							{
								dwType = REG_SZ;
								dwSize = MAX_PATH;
								if (ERROR_SUCCESS == RegQueryValueEx(hCurrentVersionKey, REG_COMMON_FILES_DIR, NULL, &dwType, (LPBYTE)strFullPath.GetBuffer(MAX_PATH), &dwSize))
								{
									strFullPath.ReleaseBuffer();

									strFullPath += _T('\\');
									strFullPath += OCX_FILE_IN_COMMON;
									if (strFullPath[0] == _T('"'))
										strFullPath = strFullPath.Right(strFullPath.GetLength() - 1);

									RegSetValueEx(hIeinfo5Key, NULL, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strFullPath, strFullPath.GetLength() * sizeof(TCHAR));
								}
								RegCloseKey(hCurrentVersionKey);
							}
							RegCloseKey(hIeinfo5Key);
						}
						RegCloseKey(hTemplatesKey);
					}
					RegCloseKey(hMsinfoKey);
				}
				RegCloseKey(hSharedToolsKey);
			}
			RegCloseKey(hMicrosoftKey);
		}

        // copy ieinfo5.mof to mof dir

        if (!strFullPath.IsEmpty() && false) //12/13/2000. a-sanka. do not compile mof. 
        {
            WCHAR strPathMof[MAX_PATH];

            strMofPathSrc = strFullPath;
            nIndex = strMofPathSrc.ReverseFind(_T('\\'));

            strMofPathSrc = strMofPathSrc.Left(nIndex + 1);
            strMofPathSrc += MOF_FILE;
            
            if (strMofPathSrc[0] == _T('"'))
                strMofPathSrc = strMofPathSrc.Right(strMofPathSrc.GetLength() - 1);

#ifdef UNICODE
            wsprintfW(strPathMof, L"%ls", strMofPathSrc);
#else
            wsprintfW(strPathMof, L"%hs", strMofPathSrc);
#endif
            HRESULT hrInit = CoInitialize(NULL);
            IMofCompiler * pMofComp;

            hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void**)&pMofComp);
            if (SUCCEEDED(hr))
            {
                WBEM_COMPILE_STATUS_INFO Info;
                hr = pMofComp->CompileFile(strPathMof,NULL,NULL,NULL,NULL,WBEM_FLAG_AUTORECOVER,0,0,&Info);

                pMofComp->Release();
            }

            if (SUCCEEDED(hrInit))
                CoUninitialize();
        }
    }
    else
    {
		//***** NT4, Win 9x *****

		// Set all MSInfo category reg values for this extension

		strCatKey = REG_MSINFO_KEY;
		strCatKey += '\\'; 
		strCatKey += REG_CATEGORIES;
		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, strCatKey, 0, KEY_WRITE, &hCatKey))
		{
			WriteNode(hCatKey, REG_INTERNET_EXPLORER_6, IDS_INTERNET_EXPLORER_6, 1, 0x35);

			if (ERROR_SUCCESS == RegOpenKeyEx(hCatKey, REG_INTERNET_EXPLORER_6, 0, KEY_WRITE, &hIE6Key))
			{
				WriteNode(hIE6Key, REG_FILE_VERSIONS, IDS_FILE_VERSIONS, 2, 0x10);
				WriteNode(hIE6Key, REG_CONNECTIVITY, IDS_CONNECTIVITY, 3, 0x20);
				WriteNode(hIE6Key, REG_CACHE, IDS_CACHE, 4, 0x30);
				if (ERROR_SUCCESS == RegOpenKeyEx(hIE6Key, REG_CACHE, 0, KEY_WRITE, &hCacheKey))
				{
					WriteNode(hCacheKey, REG_OBJECT_LIST, IDS_OBJECT_LIST, 5, 0x10);
					RegCloseKey(hCacheKey);
				}
				WriteNode(hIE6Key, REG_CONTENT, IDS_CONTENT, 6, 0x40);
				if (ERROR_SUCCESS == RegOpenKeyEx(hIE6Key, REG_CONTENT, 0, KEY_WRITE, &hContentKey))
				{
					WriteNode(hContentKey, REG_PERSONAL_CERTIFICATES, IDS_PERSONAL_CERTIFICATES, 7, 0x10);
					WriteNode(hContentKey, REG_OTHER_PEOPLE_CERTIFICATES, IDS_OTHER_PEOPLE_CERTIFICATES, 8, 0x20);
					WriteNode(hContentKey, REG_PUBLISHERS, IDS_PUBLISHERS, 9, 0x30);
					RegCloseKey(hContentKey);
				}
				WriteNode(hIE6Key, REG_SECURITY, IDS_SECURITY, 10, 0x50);

				RegCloseKey(hIE6Key);
			}
			RegCloseKey(hCatKey);
		}

		// Add MSInfo tool reg values for IE Repair Tool

		strKey = REG_MSINFO_KEY;
		strKey += '\\'; 
		strKey += REG_TOOLS;
		strKey += '\\'; 
		strKey += REG_IE_REPAIR;
		if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, strKey, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRepairKey, &dwDisposition))
		{
			strValue.LoadString(IDS_IE_REPAIR_TOOL);
			RegSetValueEx(hRepairKey, NULL, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strValue, strValue.GetLength() + sizeof(TCHAR));

			strValue = GetIERepairToolCmdLine();
			RegSetValueEx(hRepairKey, REG_COMMAND, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strValue, strValue.GetLength() + sizeof(TCHAR));

			strValue.LoadString(IDS_RUNS_IE_REPAIR_TOOL);
			RegSetValueEx(hRepairKey, REG_DESCRIPTION, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strValue, strValue.GetLength() + sizeof(TCHAR));

			RegCloseKey(hRepairKey);
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OSVERSIONINFO osver;
	CString strKey;

	if (!AfxOleUnregisterTypeLib(_tlid /*, _wVerMajor, _wVerMinor*/))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	osver.dwOSVersionInfoSize = sizeof(osver);
	VERIFY(GetVersionEx(&osver));
	if ((osver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osver.dwMajorVersion >= 5))
	{
		// Windows 2000

	}
	else
	{
		// NT4, Win 9x

		// Remove all MSInfo category reg values for this extension

		strKey = REG_MSINFO_KEY;
		strKey += '\\'; 
		strKey += REG_CATEGORIES;
		strKey += '\\'; 
		strKey += REG_INTERNET_EXPLORER_6;
		RegDeleteKeyRecusive(HKEY_LOCAL_MACHINE, strKey);

		// Remove MSInfo tool reg values for IE Repair Tool

		strKey = REG_MSINFO_KEY;
		strKey += '\\'; 
		strKey += REG_TOOLS;
		strKey += '\\'; 
		strKey += REG_IE_REPAIR;
		RegDeleteKey(HKEY_LOCAL_MACHINE, strKey);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// GetTemplate - exported function for NT5 template dll

DWORD __cdecl GetTemplate(void ** ppBuffer)
{
	DWORD dwReturn = 0;

	TRY
	{
		dwReturn = theApp.AppGetTemplate(ppBuffer);	
	}
	CATCH_ALL(e)
	{
#ifdef DBG
		e->ReportError();
#endif
		dwReturn = 0;
	}
	END_CATCH_ALL

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\msiedata.cpp ===
#include "stdafx.h"
#include "regkeys.h"
#include "filefind.h"
#include "resdefs.h"
#include <afxtempl.h>
#include <shlobj.h>
#include <comdef.h>
#include <setupapi.h>
#include <wininet.h>
#include <winineti.h>
#include <cleanoc.h>
#include <ras.h>
#include <raserror.h>
#include <wincrypt.h>

#define SECURITY_WIN32
#include <schnlsp.h> //for UNISP_NAME_A
#include <sspi.h> //for SCHANNEL.dll api -- to obtain encryption key size

#include "msie.h"
#include "msiedata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//*** DEFINES ***

#define CONSTANT_MEGABYTE		(1024*1024)
#define CONTROLNAME_MAXSIZE	200

#define CONTENT_IE5				"Content.IE5"

#define INF_FILE					"iefiles5.inf"
#define INF_FILES_SECTION		_T("Files")

#define SETUP_LOG					"Active Setup Log.txt"
#define IEXPLORE_EXE				"iexplore.exe"

#define MY_STORE					"MY"
#define ADDRESS_BOOK_STORE		"AddressBook"
#define CA_STORE					"CA"


//*** ENUMS ***

enum BoolStringType
{
	YES_NO,
	TRUE_FALSE,
	ENABLED_DISABLED
};

enum ExportLibType
{
	WININET,
	MSRATING,
	OCCACHE,
	RASAPI32,
	CRYPT32
};


//*** STRUCTS ***

struct TRANSLATION	// for retrieving Language
{
	WORD langID;   // language ID
	WORD charset; // code page
} translation;


// WININET Function Pointers

BOOL (WINAPI* pfnInternetQueryOption)(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufferLength);
BOOL (WINAPI* pfnGetDiskInfo)(LPTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, PDWORDLONG pdlTotal);

// MSRATING Function Pointers

HRESULT (WINAPI* pfnRatingEnabledQuery)();

// OCCACHE Function Pointers

LONG (WINAPI *pfnFindFirstControl)(HANDLE& hFindHandle, HANDLE& hControlHandle, LPCTSTR lpszCachePath /*= NULL*/);
LONG (WINAPI *pfnFindNextControl)(HANDLE& hFindHandle, HANDLE& hControlHandle);
BOOL (WINAPI *pfnGetControlInfo)(HANDLE hControlHandle, UINT nFlag, LPDWORD lpdwData, LPSTR lpszBuf, int nBufLen);
void (WINAPI *pfnFindControlClose)(HANDLE hFindHandle);
void (WINAPI *pfnReleaseControlHandle)(HANDLE hControlHandle);

// RASAPI32 Function Pointers

DWORD (WINAPI* pfnRasGetEntryProperties)(LPCTSTR, LPCTSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);
DWORD (WINAPI* pfnRasEnumEntries)(LPCTSTR, LPCTSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);

// CRYPT32 Function Pointers

HCERTSTORE (WINAPI* pfnCertOpenSystemStore)(HCRYPTPROV, LPCSTR);
BOOL (WINAPI* pfnCertCloseStore)(HCERTSTORE, DWORD);
PCCERT_CONTEXT (WINAPI* pfnCertEnumCertificatesInStore)(HCERTSTORE, PCCERT_CONTEXT);
DWORD (WINAPI* pfnCertGetNameString)(PCCERT_CONTEXT, DWORD, DWORD, void *, LPTSTR, DWORD);
PCCRYPT_OID_INFO (WINAPI* pfnCryptFindOIDInfo)(DWORD, void *, DWORD);
BOOL (WINAPI* pfnCertGetCertificateContextProperty)(PCCERT_CONTEXT, DWORD, void *, DWORD *);
BOOL (WINAPI* pfnCryptDecodeObject)(DWORD, LPCSTR, const BYTE *, DWORD, DWORD, void *, DWORD *);

HINSTANCE GetExports(int enExportLib)
{
	TCHAR szwindir[MAX_PATH + 1];
	GetSystemDirectory(szwindir,MAX_PATH);
	CString strPath;
	HINSTANCE hInst;

	switch (enExportLib)
	{
	case WININET:
		strPath = szwindir;
		strPath += _T("\\WININET.DLL");
		//hInst = LoadLibraryW(_T("WININET.DLL"));
		hInst = LoadLibraryW(strPath);
		
		if (hInst == NULL)
			goto error;

		pfnInternetQueryOption = (BOOL(WINAPI *)(HINTERNET, DWORD, LPVOID, LPDWORD))GetProcAddress(hInst, "InternetQueryOptionW");
		pfnGetDiskInfo = (BOOL(WINAPI *)(LPTSTR, PDWORD, PDWORDLONG, PDWORDLONG))GetProcAddress(hInst, (LPSTR)102);

		if ((pfnInternetQueryOption == NULL) || (pfnGetDiskInfo == NULL))
			goto error;
		break;

	case MSRATING:
		strPath = szwindir;
		strPath += _T("\\MSRATING.DLL");
		hInst = LoadLibraryW(strPath);
		//hInst = LoadLibraryW(_T("MSRATING.DLL"));
		if (hInst == NULL)
			goto error;

		pfnRatingEnabledQuery = (HRESULT(WINAPI *)(VOID))GetProcAddress(hInst, "RatingEnabledQuery");

		if (pfnRatingEnabledQuery == NULL)
			goto error;
		break;

	case OCCACHE:
		strPath = szwindir;
		strPath += _T("\\OCCACHE.DLL");
		hInst = LoadLibraryW(strPath);
		if (hInst == NULL)
			goto error;

		pfnFindFirstControl = (LONG(WINAPI *)(HANDLE&, HANDLE&, LPCTSTR))GetProcAddress(hInst, "FindFirstControl");
		pfnFindNextControl = (LONG(WINAPI *)(HANDLE&, HANDLE&))GetProcAddress(hInst, "FindNextControl");
		pfnGetControlInfo = (BOOL(WINAPI *)(HANDLE, UINT, LPDWORD, LPSTR, int))GetProcAddress(hInst, "GetControlInfo");
		pfnFindControlClose = (void(WINAPI *)(HANDLE))GetProcAddress(hInst, "FindControlClose");
		pfnReleaseControlHandle = (void(WINAPI *)(HANDLE))GetProcAddress(hInst, "ReleaseControlHandle");

		if ((pfnFindFirstControl == NULL) || (pfnFindNextControl == NULL) || (pfnGetControlInfo == NULL)
				|| (pfnFindControlClose == NULL) || (pfnReleaseControlHandle == NULL))
			goto error;
		break;

	case RASAPI32:

		hInst = LoadLibraryA("%windir%\\system32\\RASAPI32.DLL");
		if (hInst == NULL)
			goto error;

		pfnRasGetEntryProperties = (DWORD(WINAPI *)(LPCTSTR, LPCTSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD))GetProcAddress(hInst, "RasGetEntryPropertiesW");
		pfnRasEnumEntries = (DWORD(WINAPI *)(LPCTSTR, LPCTSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD))GetProcAddress(hInst, "RasEnumEntriesW");

		if ((pfnRasGetEntryProperties == NULL) || (pfnRasEnumEntries == NULL))
			goto error;
		break;
	
	case CRYPT32:
		strPath = szwindir;
		strPath += _T("%windir%\\system32\\CRYPT32.DLL");
		hInst = LoadLibraryW(strPath);
		if (hInst == NULL)
			goto error;

		pfnCertOpenSystemStore = (HCERTSTORE(WINAPI *)(HCRYPTPROV, LPCSTR))GetProcAddress(hInst, "CertOpenSystemStoreW");
		pfnCertCloseStore = (BOOL(WINAPI *)(HCERTSTORE, DWORD))GetProcAddress(hInst, "CertCloseStore");
		pfnCertEnumCertificatesInStore = (PCCERT_CONTEXT(WINAPI *)(HCERTSTORE, PCCERT_CONTEXT))GetProcAddress(hInst, "CertEnumCertificatesInStore");
		pfnCertGetNameString = (DWORD(WINAPI *)(PCCERT_CONTEXT, DWORD, DWORD, void *, LPTSTR, DWORD))GetProcAddress(hInst, "CertGetNameStringW");
		pfnCryptFindOIDInfo = (PCCRYPT_OID_INFO(WINAPI *)(DWORD, void *, DWORD))GetProcAddress(hInst, "CryptFindOIDInfo");
		pfnCertGetCertificateContextProperty = (BOOL(WINAPI *)(PCCERT_CONTEXT, DWORD, void *, DWORD *))GetProcAddress(hInst, "CertGetCertificateContextProperty");
		pfnCryptDecodeObject = (BOOL(WINAPI *)(DWORD, LPCSTR, const BYTE *, DWORD, DWORD, void *, DWORD *))GetProcAddress(hInst, "CryptDecodeObject");

		if ((pfnCertOpenSystemStore == NULL) ||
				(pfnCertCloseStore == NULL) ||
				(pfnCertEnumCertificatesInStore == NULL) ||
				(pfnCertGetNameString == NULL) ||
				(pfnCryptFindOIDInfo == NULL) ||
				(pfnCertGetCertificateContextProperty == NULL) ||
				(pfnCryptDecodeObject == NULL))
			goto error;
	}
	return hInst;

error:
	if (hInst)
		FreeLibrary(hInst);

	return NULL;
}

//-----------------------------------------------------------------------------
// GetBooleanString - Converts a boolean to a string, returns as a CString.
//-----------------------------------------------------------------------------

CString CMsieApp::GetBooleanString(BOOL bValue, int nType)
{
	CString strTemp;
	int idsTemp;

	switch (nType)
	{
	case TRUE_FALSE:
		idsTemp = bValue ? IDS_TRUE : IDS_FALSE;
		break;
	case ENABLED_DISABLED:
		idsTemp = bValue ? IDS_ENABLED : IDS_DISABLED;
		break;
	case YES_NO:
	default:
		idsTemp = bValue ? IDS_YES : IDS_NO;
		break;
	}

	strTemp.LoadString(idsTemp);
	return strTemp;
}

//-----------------------------------------------------------------------------
// ConvertIPAddressToString - Converts an IP address, returns as a CString.
//-----------------------------------------------------------------------------

CString CMsieApp::ConvertIPAddressToString(RASIPADDR ipaddr)
{
	CString strTemp;

	strTemp.Format(_T("%d.%d.%d.%d"), ipaddr.a, ipaddr.b, ipaddr.c, ipaddr.d);

	return strTemp;
}

//-----------------------------------------------------------------------------
// GetRegValue - Gets a Registry value, returns as variant.
//-----------------------------------------------------------------------------

void CMsieApp::GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, COleVariant &vtData)
{
	CoImpersonateClient();
	HKEY hOpenKey;
	BYTE byData[MAX_PATH];
	DWORD dwType, cbData;
	long lResult;

	if (ERROR_SUCCESS == RegOpenKeyEx(hKey, pszSubKey, 0, KEY_QUERY_VALUE, &hOpenKey))
	{
		cbData = sizeof(byData);
		dwType = REG_DWORD;
		lResult = RegQueryValueEx(hOpenKey, pszName, NULL, &dwType, byData, &cbData);
		if (lResult == ERROR_SUCCESS)
		{
			if ((dwType == REG_BINARY) || (dwType == REG_DWORD))
				vtData = (long)*byData;
			else
				vtData = (TCHAR*) byData;
		}
		RegCloseKey(hOpenKey);
	}
}

//-----------------------------------------------------------------------------
// GetRegValue - Gets a Registry value, returns as long.
//-----------------------------------------------------------------------------

long CMsieApp::GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, DWORD &dwData)
{
	HKEY hOpenKey;
	DWORD cbData;
	long lResult;

	lResult = RegOpenKeyEx(hKey, pszSubKey, 0, KEY_QUERY_VALUE, &hOpenKey);
	if (lResult == ERROR_SUCCESS)
	{
		cbData = sizeof(dwData);
		lResult = RegQueryValueEx(hOpenKey, pszName, NULL, NULL, (LPBYTE)&dwData, &cbData);

		RegCloseKey(hOpenKey);
	}
	return lResult;
}

//-----------------------------------------------------------------------------
// GetRegValue - Gets a Registry value, returns as string.
//-----------------------------------------------------------------------------

long CMsieApp::GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, CString &strData)
{
	HKEY hOpenKey;
	DWORD cbData;
	long lResult;

	lResult = RegOpenKeyEx(hKey, pszSubKey, 0, KEY_QUERY_VALUE, &hOpenKey);
	if (lResult == ERROR_SUCCESS)
	{
		cbData = MAX_PATH;
		lResult = RegQueryValueEx(hOpenKey, pszName, NULL, NULL, (LPBYTE)strData.GetBuffer(MAX_PATH), &cbData);
		strData.ReleaseBuffer();

		RegCloseKey(hOpenKey);
	}
	return lResult;
}

//-----------------------------------------------------------------------------
// GetLongPathName - Returns long path name of passed in short path name.
//-----------------------------------------------------------------------------

CString CMsieApp::GetLongPathName(LPCTSTR pszShortPath)
{
   LPSHELLFOLDER psfDesktop = NULL;
   ULONG chEaten = 0;
   LPITEMIDLIST pidlShellItem = NULL;
	CString strLongPath = pszShortPath;		// initializing return str in case of failure
	WCHAR wstrShortPath[MAX_PATH + 1];

   // Get the Desktop's shell folder interface

   HRESULT hr = SHGetDesktopFolder(&psfDesktop);

#ifdef _UNICODE
	wcsncpy(wstrShortPath, pszShortPath,MAX_PATH);
#else
	MultiByteToWideChar(CP_ACP, 0, pszShortPath, -1, wstrShortPath, MAX_PATH);
#endif

   // Request an ID list (relative to the desktop) for the short pathname

   hr = psfDesktop->ParseDisplayName(NULL, NULL, wstrShortPath, &chEaten, &pidlShellItem, NULL);
   psfDesktop->Release();  // Release the desktop's IShellFolder   
   if (SUCCEEDED(hr))
	{
      // We did get an ID list, convert it to a long pathname

      SHGetPathFromIDList(pidlShellItem, strLongPath.GetBuffer(MAX_PATH));
		strLongPath.ReleaseBuffer();

      // Free the ID list allocated by ParseDisplayName

      LPMALLOC pMalloc = NULL;
      SHGetMalloc(&pMalloc);
      pMalloc->Free(pidlShellItem);
      pMalloc->Release();
	}
	return strLongPath;
}

//-----------------------------------------------------------------------------
// GetDirSize - Returns size of a directory, including all files in subdirs.
//-----------------------------------------------------------------------------

DWORD CMsieApp::GetDirSize(LPCTSTR pszDir)
{
	CFindFile finder;
	CString strDir(pszDir);
	DWORD dwSize = 0;
	BOOL bWorking;

	if (strDir[strDir.GetLength() - 1] != _T('\\'))
		strDir += '\\';
	strDir += "*.*";
	bWorking = finder.FindFile(strDir);
	while (bWorking)
	{
		bWorking = finder.FindNextFile();
		if (!finder.IsDots())
		{
			if (finder.IsDirectory())
			{
				// recursively add subdir size

				dwSize += GetDirSize(finder.GetFilePath());
			}
			else
			{
				//TRACE(finder.GetFileName() + "\n");
				dwSize += finder.GetLength();
			}
		}
	}
	return dwSize;
}

//-----------------------------------------------------------------------------
// GetFileVersion - Retrieves FileVersion of passed in filename.
//-----------------------------------------------------------------------------

CString CMsieApp::GetFileVersion(LPCTSTR pszFileName)
{
	CString strVersion;
	HANDLE hMem;
	LPVOID lpvMem;
	VS_FIXEDFILEINFO *pVerInfo;
	UINT cchVerInfo;
	DWORD dwVerInfoSize, dwTemp;

	dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)pszFileName, &dwTemp); 
	if (dwVerInfoSize)
	{ 
		hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); 
		lpvMem = GlobalLock(hMem); 
		if (GetFileVersionInfo((LPTSTR)pszFileName, dwTemp, dwVerInfoSize, lpvMem))
		{
			if (VerQueryValue(lpvMem, _T("\\"), (LPVOID*)&pVerInfo, &cchVerInfo))
			{
				strVersion.Format(_T("%u.%u.%u.%u"), HIWORD(pVerInfo->dwFileVersionMS), LOWORD(pVerInfo->dwFileVersionMS),
										HIWORD(pVerInfo->dwFileVersionLS), LOWORD(pVerInfo->dwFileVersionLS));
			}
		}
		GlobalUnlock(hMem);
		GlobalFree(hMem);
	}

	if (strVersion.IsEmpty())
		strVersion.LoadString(IDS_NOT_AVAILABLE);

	return strVersion;
}

//-----------------------------------------------------------------------------
// GetFileCompany - Retrieves CompanyName declared in passed in file.
//-----------------------------------------------------------------------------

CString CMsieApp::GetFileCompany(LPCTSTR pszFileName)
{
	CString strCompany, strSubBlock, strLangID, strCharset;
	HANDLE hMem;
	LPVOID lpvMem, pBuffer;
	VS_FIXEDFILEINFO *pVerInfo;
	UINT cchVerInfo, cchBuffer;
	DWORD dwVerInfoSize, dwTemp;

	dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)pszFileName, &dwTemp); 
	if (dwVerInfoSize)
	{ 
		hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); 
		lpvMem = GlobalLock(hMem); 
		if (GetFileVersionInfo((LPTSTR)pszFileName, dwTemp, dwVerInfoSize, lpvMem))
		{
			if (VerQueryValue(lpvMem, _T("\\VarFileInfo\\Translation"), (LPVOID*)&pVerInfo, &cchVerInfo))
			{
				translation = *(TRANSLATION*)pVerInfo;

				strSubBlock.Format(_T("\\StringFileInfo\\%04X%04X\\CompanyName"), translation.langID, translation.charset);
				VerQueryValue(lpvMem, (LPTSTR)(LPCTSTR)strSubBlock, &pBuffer, &cchBuffer);
				strCompany = (LPCTSTR)pBuffer;
			}
		}
		GlobalUnlock(hMem);
		GlobalFree(hMem);
	}

	if (strCompany.IsEmpty())
		strCompany.LoadString(IDS_NOT_AVAILABLE);

	return strCompany;
}

//-----------------------------------------------------------------------------
// GetCipherStrength - Returns the maximum cipher strength (snagged from IE
//		About Box code (aboutinf.cpp).
//-----------------------------------------------------------------------------

DWORD CMsieApp::GetCipherStrength()
{
    PSecurityFunctionTable (WINAPI *pfnInitSecurityInterface)();
    PSecurityFunctionTable pSecFuncTable;
    HINSTANCE hSecurity;
    DWORD dwKeySize = 0;

	 // Can't go directly to schannel on NT5.  (Note that g_bRunningOnNT5OrHigher
    // may not be initialized when fUseSChannel is initialized!)
    //
	TCHAR szwindir[MAX_PATH + 1];
	GetSystemDirectory(szwindir,MAX_PATH);
    static BOOL fUseSChannel = TRUE;
    if (fUseSChannel && !m_bRunningOnNT5OrHigher)
    {
        //
        // This is better for performance. Rather than call through
        // SSPI, we go right to the DLL doing the work.
        //
		CString strPath = szwindir;
		strPath +=_T("\\SCHANNEL.DLL");
        hSecurity = LoadLibrary(strPath);
    }
    else
    {
        //
        // Use SSPI
        //
        if (m_bRunningOnNT)
        {
			CString strPath = szwindir;
			strPath +=_T("\\SECURITY.DLL");
            hSecurity = LoadLibrary(strPath);
        }
        else
        {
			CString strPath = szwindir;
			strPath +=_T("\\SECUR32.DLL");
            hSecurity = LoadLibrary(strPath );
        }
    }

    if (hSecurity == NULL)
    {
        return 0;
    }

    //
    // Get the SSPI dispatch table
    //
    pfnInitSecurityInterface =
        (PSecurityFunctionTable(WINAPI *)())GetProcAddress(hSecurity, "InitSecurityInterfaceW");

    if (pfnInitSecurityInterface == NULL)
    {
        goto exit;
    }

    pSecFuncTable = (PSecurityFunctionTable)((*pfnInitSecurityInterface)());
    if (pSecFuncTable == NULL)
    {
        goto exit;
    }

    if (pSecFuncTable->AcquireCredentialsHandleW && pSecFuncTable->QueryCredentialsAttributesW)
    {
        TimeStamp  tsExpiry;
        CredHandle chCred;
        SecPkgCred_CipherStrengths cs;

        if (S_OK == (*pSecFuncTable->AcquireCredentialsHandleW)(NULL,  
                          UNISP_NAME_W, // Package
                          SECPKG_CRED_OUTBOUND,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          &chCred,      // Handle
                          &tsExpiry ))
        {
            if (S_OK == (*pSecFuncTable->QueryCredentialsAttributesW)(&chCred, SECPKG_ATTR_CIPHER_STRENGTHS, &cs))
            {
                dwKeySize = cs.dwMaximumCipherStrength;
            }

            // Free the handle if we can
            if (pSecFuncTable->FreeCredentialsHandle)
            {
                (*pSecFuncTable->FreeCredentialsHandle)(&chCred);
            }
        }
    }

exit:
    FreeLibrary(hSecurity);

    if (dwKeySize == 0 && fUseSChannel)
    {
        // Failed, so retry using SSPI
        fUseSChannel = FALSE;
        dwKeySize = GetCipherStrength();
    }
    return dwKeySize;
}

//---------------------------------------------------------------------------------
// GetCertificateInfo - Retrieves specific certificate info from passed in context.
//---------------------------------------------------------------------------------

void CMsieApp::GetCertificateInfo(PCCERT_CONTEXT pContext, int idsType, CPtrArray& ptrs)
{
	IE_CERTIFICATE *pData;
	PCCRYPT_OID_INFO pOidInfo;
	CString strType, strIssuedTo, strIssuedBy, strValidity;
	COleDateTime dateNotBefore, dateNotAfter;
	DWORD dwResult;

	pData = new IE_CERTIFICATE;
	ptrs.Add(pData);

	strType.LoadString(idsType);
	pData->Type = strType;

	// get Issued To (Subject)

	dwResult = pfnCertGetNameString(pContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, strIssuedTo.GetBuffer(256), 256);
	strIssuedTo.ReleaseBuffer();
	if (dwResult)
		pData->IssuedTo = strIssuedTo;

	// get Issued From (Issuer)

	dwResult = pfnCertGetNameString(pContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL, strIssuedBy.GetBuffer(256), 256);
	strIssuedBy.ReleaseBuffer();
	if (dwResult)
		pData->IssuedBy = strIssuedBy;

	// get Validity dates

	dateNotBefore = pContext->pCertInfo->NotBefore;
	dateNotAfter = pContext->pCertInfo->NotAfter;
	strValidity.Format(IDS_VALIDITY_FORMAT, dateNotBefore.Format(VAR_DATEVALUEONLY), dateNotAfter.Format(VAR_DATEVALUEONLY));
	pData->Validity = strValidity;

	// get Signature Algorithm

	if (pOidInfo = pfnCryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pContext->pCertInfo->SignatureAlgorithm.pszObjId, 0))
		pData->SignatureAlgorithm = pOidInfo->pwszName;
}

//-----------------------------------------------------------------------------
// GetPersonalCertificates - Retrieves certificates from MY certificate store.
//-----------------------------------------------------------------------------

void CMsieApp::GetPersonalCertificates(CPtrArray& ptrs)
{
	HCERTSTORE hStore;
	PCCERT_CONTEXT pPrevContext, pContext;
	DWORD dwPrivateKey, dwSize;

	hStore = pfnCertOpenSystemStore(NULL, MY_STORE);
	if (hStore)
	{
		pPrevContext = NULL;
		while (pContext = pfnCertEnumCertificatesInStore(hStore, pPrevContext))
		{
			// make sure private key property exists

			dwSize = sizeof(DWORD);
			if (pfnCertGetCertificateContextProperty(pContext, CERT_KEY_SPEC_PROP_ID, &dwPrivateKey, &dwSize))
			{
				GetCertificateInfo(pContext, IDS_PERSONAL_TYPE, ptrs);
			}
			pPrevContext = pContext;
		}
		pfnCertCloseStore(hStore, 0);
	}
}

//-----------------------------------------------------------------------------
// GetOtherPeopleCertificates - Retrieves from AddressBook certificate store.
//-----------------------------------------------------------------------------

void CMsieApp::GetOtherPeopleCertificates(CPtrArray& ptrs)
{
	HCERTSTORE hStore;
	PCCERT_CONTEXT pPrevContext, pContext;
	CERT_BASIC_CONSTRAINTS2_INFO constraintInfo;
	DWORD dwSize, dwIndex;
	bool bIsEndEntity;

	hStore = pfnCertOpenSystemStore(NULL, ADDRESS_BOOK_STORE);
	if (hStore)
	{
		pPrevContext = NULL;
		while (pContext = pfnCertEnumCertificatesInStore(hStore, pPrevContext))
		{
			GetCertificateInfo(pContext, IDS_OTHER_PEOPLE_TYPE, ptrs);

			pPrevContext = pContext;
		}
		pfnCertCloseStore(hStore, 0);
	}

	// also obtain end-entity certificate from CA store

	hStore = pfnCertOpenSystemStore(NULL, CA_STORE);
	if (hStore)
	{
		pPrevContext = NULL;
		while (pContext = pfnCertEnumCertificatesInStore(hStore, pPrevContext))
		{
			bIsEndEntity = false;
			for (dwIndex = 0; dwIndex < pContext->pCertInfo->cExtension; dwIndex++)
			{
				if (!strcmp(pContext->pCertInfo->rgExtension[dwIndex].pszObjId, szOID_BASIC_CONSTRAINTS2))
				{
					dwSize = sizeof(constraintInfo);
					if (pfnCryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, szOID_BASIC_CONSTRAINTS2,
													pContext->pCertInfo->rgExtension[dwIndex].Value.pbData,
													pContext->pCertInfo->rgExtension[dwIndex].Value.cbData, 0, &constraintInfo, &dwSize))
					{
						bIsEndEntity = !constraintInfo.fCA;
						break;
					}
				}
			}
			if (bIsEndEntity)
			{
				GetCertificateInfo(pContext, IDS_OTHER_PEOPLE_TYPE, ptrs);
			}
			pPrevContext = pContext;
		}
		pfnCertCloseStore(hStore, 0);
	}
}

///////////////////////////////////////////////////////////////////////////////
// AppGetIEData - Retrieves IE data.
///////////////////////////////////////////////////////////////////////////////

void CMsieApp::AppGetIEData(IEDataType enType, long *plCount, void ***pppIEData, long *pCancel)
{
	*plCount = 0;
	*pppIEData = NULL;

	if (enType == SummaryType)
	{
		IE_SUMMARY *pData;
		HINSTANCE hInstRatingDll;
		OSVERSIONINFO osver;
		HANDLE hMem;
		LPVOID lpvMem;
		VS_FIXEDFILEINFO *pVerInfo;
		CStdioFile fileSetupLog;
		COleDateTime dateTime;
		CString strAppName, strKey, strPath, strActivePrinter, strVersion, strCustomizedVersion, strSetupLog, strLine, strFullPath, strLanguage;
		DWORD dwVerInfoSize, dwTemp;
		long lStrength;
		UINT cchVerInfo;
		int nIndex, nEndIndex;
		BOOL (WINAPI *pfnRatingEnabledQuery)();

		if (pCancel)
			if (*pCancel != 0L) return;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_SUMMARY;
		*pppIEData[0] = pData;
		*plCount = 1;

		// get name

		strAppName.LoadString(IDS_INTERNET_EXPLORER_6);
		pData->Name = strAppName;

		// get version and build

		GetRegValue(HKEY_LOCAL_MACHINE, REG_IE_KEY, REG_VERSION, pData->Version);
		GetRegValue(HKEY_LOCAL_MACHINE, REG_IE_KEY, REG_BUILD, pData->Build);

		// get product id

		strKey = REG_IE_KEY;
		strKey += "\\";
		strKey += REG_REGISTRATION;
		GetRegValue(HKEY_LOCAL_MACHINE, strKey, REG_PRODUCT_ID, pData->ProductID);

		// get app path

		GetRegValue(HKEY_LOCAL_MACHINE, REG_IEXPLORE_EXE_KEY, _T(""), pData->Path);
		strPath = pData->Path.bstrVal;
		if (!strPath.IsEmpty())
		{
			nIndex = strPath.ReverseFind(_T('\\'));
			if (nIndex != -1)
				strPath = strPath.Left(nIndex);

			// change to long file name

			pData->Path = GetLongPathName(strPath);
		}

		// get last install date from "active setup log.txt"
		// Ex: "Date:4/7/1999 (M/D/Y) Time:10:23:20"

		if (GetWindowsDirectory(strSetupLog.GetBuffer(MAX_PATH), MAX_PATH))
		{
			strSetupLog.ReleaseBuffer();
			strSetupLog += '\\';
			strSetupLog += SETUP_LOG;

			if (fileSetupLog.Open(strSetupLog, CFile::modeRead))
			{
				try
				{
					while (fileSetupLog.ReadString(strLine))
					{
						// find date line

						if (strLine.Left(5) == "Date:")
						{
							strLine = strLine.Right(strLine.GetLength() - 5);

							// remove "(M/D/Y)"

							if ((nIndex = strLine.Find('(')) != -1)
							{
								if ((nEndIndex = strLine.Find(')')) != -1)
									strLine = strLine.Left(nIndex) + strLine.Right(strLine.GetLength() - nEndIndex - 1);
							}

							// remove "Time:"

							if ((nIndex = strLine.Find(_T("Time:"))) != -1)
								strLine = strLine.Left(nIndex) + strLine.Right(strLine.GetLength() - nIndex - 5);

							dateTime.ParseDateTime(strLine);
							pData->LastInstallDate = dateTime;

							break;
						}
					}
				}
				catch (CFileException *e)
				{
					e->Delete();
				}
				fileSetupLog.Close();
			}
		}

		// get language (from iexplore.exe)

		GetRegValue(HKEY_LOCAL_MACHINE, REG_IEXPLORE_EXE_KEY, _T(""), strFullPath);
		dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)(LPCTSTR)strFullPath, &dwTemp); 
		if (dwVerInfoSize)
		{ 
			hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); 
			lpvMem = GlobalLock(hMem); 
			if (GetFileVersionInfo((LPTSTR)(LPCTSTR)strFullPath, dwTemp, dwVerInfoSize, lpvMem))
			{
				if (VerQueryValue(lpvMem, _T("\\VarFileInfo\\Translation"), (LPVOID*)&pVerInfo, &cchVerInfo))
				{
					translation = *(TRANSLATION*)pVerInfo;
					VerLanguageName(translation.langID, strLanguage.GetBuffer(MAX_PATH), MAX_PATH);
					strLanguage.ReleaseBuffer();

					pData->Language = strLanguage;
				}
			}
			GlobalUnlock(hMem);
			GlobalFree(hMem);
		}

		// get active printer

		::GetProfileString(_T("windows"), _T("device"), _T(",,,"), strActivePrinter.GetBuffer(MAX_PATH), MAX_PATH);
		strActivePrinter.ReleaseBuffer();
		if ((!strActivePrinter.IsEmpty()) && (strActivePrinter != ",,,"))
			pData->ActivePrinter = strActivePrinter;

		// get cipher strength
  		// first check OS

		osver.dwOSVersionInfoSize = sizeof(osver);
		VERIFY(GetVersionEx(&osver));
		m_bRunningOnNT = (osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
		m_bRunningOnNT5OrHigher = (m_bRunningOnNT && (osver.dwMajorVersion >= 5));
		lStrength = (long)GetCipherStrength();

		// handle weirdness of cipher strength
		/*
		if (m_bRunningOnNT5OrHigher)
			pData->CipherStrength = lStrength;
		else
			pData->CipherStrength = (lStrength >= 168) ? (long)128 : (long)40;
		
		a-sanka 02/15/2001
		QueryCredentialsAttributes returns 128 for 40-bit & 168 for 128-bit encryption.
		All other values are authentic, and can be reported unchanged.
		*/
		
		if(lStrength == 128)
			lStrength = 40;
		else if(lStrength == 168)
			lStrength = 128;
		pData->CipherStrength = lStrength;
		
		// get content advisor (via msrating.dll call)
		TCHAR szwindir[MAX_PATH + 1];
		GetSystemDirectory(szwindir,MAX_PATH);
		strPath = szwindir;
		strPath += _T("\\msrating.dll");
		if (hInstRatingDll = LoadLibrary(strPath))
		{
			if (pfnRatingEnabledQuery = (BOOL(WINAPI *)())GetProcAddress(hInstRatingDll, "RatingEnabledQuery"))
			{
				pData->ContentAdvisor = GetBooleanString(S_OK == pfnRatingEnabledQuery(), ENABLED_DISABLED);
			}
			FreeLibrary(hInstRatingDll);
		}

		// get ieak install

		GetRegValue(HKEY_LOCAL_MACHINE, REG_IE_KEY, REG_CUSTOMIZED_VERSION, strCustomizedVersion);
		pData->IEAKInstall = GetBooleanString(!strCustomizedVersion.IsEmpty());
		if (!strCustomizedVersion.IsEmpty())
		{
			// add IS, CO or IC to version string
			
			strVersion = pData->Version.bstrVal;
			strVersion += strCustomizedVersion;
			pData->Version = strVersion;
		}
	}

	else if (enType == FileVersionType)
	{
		IE_FILE_VERSION *pData;
		CTypedPtrArray<CPtrArray, IE_FILE_VERSION*> ptrs;
		CStringArray strSearchPaths;
		CString strInfPath, strFileName, strFileMissing, strPathEnvVar, strFullPath, strIExplorePath;
		CFileStatus status;
		COleDateTime dateTime;
		HINF hInf;
		INFCONTEXT context;
		DWORD dwFileIndex;
		long cFiles;
		int nIndex, nPathIndex;
		bool bFoundFile;

		// open msiefiles.inf file for list of files display info about

		GetRegValue(HKEY_LOCAL_MACHINE, REG_MSINFO_KEY, REG_PATH, strInfPath);
		ASSERT(!strInfPath.IsEmpty());

		// replace msinfo32.exe with inf filename

		nIndex = strInfPath.ReverseFind(_T('\\'));
		strInfPath = strInfPath.Left(nIndex + 1);
		strInfPath += INF_FILE;
		if (strInfPath[0] == _T('"'))
			strInfPath = strInfPath.Right(strInfPath.GetLength() - 1);

		hInf = SetupOpenInfFile(strInfPath, NULL, INF_STYLE_WIN4, NULL);
		ASSERT(hInf != INVALID_HANDLE_VALUE);
		if (hInf != INVALID_HANDLE_VALUE)
		{
			cFiles = SetupGetLineCount(hInf, INF_FILES_SECTION);
			if (cFiles > 0)
			{
				// get all dirs to look in from PATH environment variable

				GetEnvironmentVariable(_T("PATH"), strPathEnvVar.GetBuffer(1024), 1024);
				strPathEnvVar.ReleaseBuffer();

				while (-1 != (nIndex = strPathEnvVar.Find(_T(';'))))
				{
					strSearchPaths.Add(strPathEnvVar.Left(nIndex));
					strPathEnvVar = strPathEnvVar.Right(strPathEnvVar.GetLength() - (nIndex + 1));
				}
				if (!strPathEnvVar.IsEmpty())
					strSearchPaths.Add(strPathEnvVar);

				// also add iexplore dir to search paths

				GetRegValue(HKEY_LOCAL_MACHINE, REG_IEXPLORE_EXE_KEY, REG_PATH, strIExplorePath);
				if (!strIExplorePath.IsEmpty())
				{
					if (strIExplorePath[strIExplorePath.GetLength() - 1] == _T(';'))
						strIExplorePath = strIExplorePath.Left(strIExplorePath.GetLength() -1);
					strSearchPaths.Add(strIExplorePath);
				}

				// Look for files...

				strFileMissing.LoadString(IDS_FILE_MISSING);
				for (dwFileIndex = 0; dwFileIndex < (DWORD)cFiles; dwFileIndex++)
				{
					SetupGetLineByIndex(hInf, INF_FILES_SECTION, dwFileIndex, &context);
					SetupGetLineText(&context, hInf, NULL, NULL, strFileName.GetBuffer(_MAX_FNAME), _MAX_FNAME, NULL);
					strFileName.ReleaseBuffer();

					//...in each path (in environment)

					bFoundFile = false;
					for (nPathIndex = 0; nPathIndex < strSearchPaths.GetSize(); nPathIndex++)
					{
						strFullPath = strSearchPaths[nPathIndex];
						if (strFullPath[strFullPath.GetLength() - 1] != _T('\\'))
							strFullPath += '\\';
						strFullPath += strFileName;

						if (CFile::GetStatus(strFullPath, status))
						{
							if (!bFoundFile)
								bFoundFile = true;

							pData = new IE_FILE_VERSION;
							ptrs.Add(pData);

							// set name

							pData->File = strFileName;

							// get version

							pData->Version = GetFileVersion(strFullPath);

							// get size and modified date

							if (CFile::GetStatus(strFullPath, status))
							{
								pData->Size = (float)status.m_size / 1024;

								dateTime = status.m_mtime.GetTime();
								pData->Date = dateTime;
							}

							// get company

							pData->Company = GetFileCompany(strFullPath);

							// get path (chop off filename and make sure long filename)

							strFullPath = strFullPath.Left(strFullPath.GetLength() - (strFileName.GetLength() + 1));
							pData->Path = GetLongPathName(strFullPath);
						}
					}
					if (!bFoundFile)
					{
						pData = new IE_FILE_VERSION;
						ptrs.Add(pData);

						pData->File = strFileName;
						pData->Version = strFileMissing;
						pData->Size = _T("");
						pData->Date = _T("");
						pData->Path = _T("");
						pData->Company = _T("");
					}
				}
				SetupCloseInfFile(hInf);

				*plCount = (long) ptrs.GetSize();
				*pppIEData = (void**)new LPVOID[*plCount];

				for (int i = 0; i < *plCount; i++)
					(*pppIEData)[i] = ptrs[i];

			}
			else
			{
				*pppIEData = (void**)new LPVOID;
				pData = new IE_FILE_VERSION;
				*pppIEData[0] = pData;
				*plCount = 1;

				strFileName.LoadString(IDS_INF_FILE_MISSING);
				pData->File = strFileName;

				pData->Version = _T("");
				pData->Size = _T("");
				pData->Date = _T("");
				pData->Path = _T("");
				pData->Company = _T("");
			}
		}
	}

	else if (enType == ConnSummaryType)
	{
		IE_CONN_SUMMARY *pData;
		HKEY hOpenKey;
		BOOL bAutodial, bNoNetAutodial;
		DWORD cbData;
		long lResult;
		int ids;
		CString strTemp;

		if (pCancel)
			if (*pCancel != 0L) return;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_CONN_SUMMARY;
		*pppIEData[0] = pData;
		*plCount = 1;

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, 0, KEY_QUERY_VALUE, &hOpenKey))
		{
			cbData = sizeof(bAutodial);
			lResult = RegQueryValueEx(hOpenKey, REG_ENABLE_AUTODIAL, NULL, NULL, (BYTE*)&bAutodial, &cbData);
			if (lResult == ERROR_SUCCESS)
			{
				if (bAutodial)
				{
					cbData = sizeof(bNoNetAutodial);
					lResult = RegQueryValueEx(hOpenKey, REG_NO_NET_AUTODIAL, NULL, NULL, (BYTE*)&bNoNetAutodial, &cbData);
					if (lResult == ERROR_SUCCESS)
						ids = bNoNetAutodial ? IDS_DIAL_NO_NET : IDS_ALWAYS_DIAL;
					else
						ids = IDS_NOT_AVAILABLE;
				}
				else
					ids = IDS_NEVER_DIAL;
			}
			else
				ids = IDS_NEVER_DIAL;	// if reg entry not found, set to default

			strTemp.LoadString(ids);
			pData->ConnectionPreference = strTemp;

			RegCloseKey(hOpenKey);
		}
		GetRegValue(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, REG_ENABLE_HTTP_1_1, pData->EnableHttp11);
		if (VT_EMPTY == pData->EnableHttp11.vt)
			pData->EnableHttp11 = (long)1;	// if reg entry not found, set to default

		GetRegValue(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, REG_PROXY_HTTP_1_1, pData->ProxyHttp11);
		if (VT_EMPTY == pData->ProxyHttp11.vt)
			pData->ProxyHttp11 = (long)0;		// if reg entry not found, set to default
	}

	else if (enType == LanSettingsType)
	{
		IE_LAN_SETTINGS *pData;
		INTERNET_PER_CONN_OPTION_LIST list;
		HINSTANCE hInst;
		DWORD dwListSize;
		CString strTemp;

		if (pCancel)
			if (*pCancel != 0L) return;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_LAN_SETTINGS;
		*pppIEData[0] = pData;
		*plCount = 1;

		// get AutoConfigProxy

		GetRegValue(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, REG_AUTO_CONFIG_PROXY, pData->AutoConfigProxy);

		// get all InternetQueryOption info

		if (hInst = GetExports(WININET))
		{
			dwListSize = sizeof(list);
			list.pszConnection = NULL;
			list.dwSize = sizeof(list);
			list.dwOptionCount = 4;
			list.pOptions = new INTERNET_PER_CONN_OPTION[4];

			list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
			list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
			list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
			list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

			BOOL bResult = pfnInternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwListSize);
			if (bResult)
			{
				pData->AutoProxyDetectMode = GetBooleanString(list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT, ENABLED_DISABLED);

				strTemp = list.pOptions[3].Value.pszValue;
				pData->AutoConfigURL = strTemp;

				pData->Proxy = GetBooleanString(list.pOptions[0].Value.dwValue & PROXY_TYPE_PROXY, ENABLED_DISABLED);

				strTemp = list.pOptions[1].Value.pszValue;
				pData->ProxyServer = strTemp;

				strTemp = list.pOptions[2].Value.pszValue;
				pData->ProxyOverride = strTemp;
			}
			delete []list.pOptions;

			FreeLibrary(hInst);
		}
	}

	else if (enType == ConnSettingsType)
	{
		IE_CONN_SETTINGS *pData;
		CString strName, strDefaultName, strDefault, strKey, strProxyOverride, strTemp;
		INTERNET_PER_CONN_OPTION_LIST list;
		LPRASENTRYNAME pRasEntryName;
		LPRASENTRYNAME pRasEntryNamePreFail = NULL;
		LPRASENTRY pRasEntry;
		LPRASENTRY pRasEntryPreFail = NULL;
		HINSTANCE hInstRAS, hInst;
		DWORD dwTemp, dwIndex, dwListSize, dwEntrySize, dwResult, cEntries = 0;
		int ids, nIndex, nDefaultIndex = -1;
		BOOL bResult;
		bool bFoundDefault = false;

		strDefault.LoadString(IDS_DEFAULT);

		// get number of Connections

		if (hInstRAS = GetExports(RASAPI32))
		{
			dwEntrySize = sizeof(RASENTRYNAME);
			if ((pRasEntryName = (LPRASENTRYNAME)malloc((UINT)dwEntrySize)) != NULL) 
			{
				pRasEntryName->dwSize = sizeof(RASENTRYNAME);
				dwResult = pfnRasEnumEntries(NULL, NULL, pRasEntryName, &dwEntrySize, &cEntries);
				if (dwResult == ERROR_BUFFER_TOO_SMALL)
				{
                    pRasEntryNamePreFail = pRasEntryName;
#pragma prefast(suppress:308,"Pointer was saved")
					if ((pRasEntryName = (LPRASENTRYNAME)realloc(pRasEntryName, dwEntrySize)) != NULL)
						dwResult = pfnRasEnumEntries(NULL, NULL, pRasEntryName, &dwEntrySize, &cEntries);
                                        else
                                        {
                                            free(pRasEntryNamePreFail);
                                        }
				}
				if ((!dwResult) && (cEntries > 0) && pRasEntryName)
				{
					*plCount = cEntries;
					*pppIEData = (void**)new LPVOID[cEntries];

					// get default connection name (if one exists)

					GetRegValue(HKEY_CURRENT_USER, REG_REMOTE_ACCESS, REG_INTERNET_PROFILE, strDefaultName);

					for (dwIndex = 0; dwIndex < cEntries; dwIndex++)
					{
						pData = new IE_CONN_SETTINGS;
						(*pppIEData)[dwIndex] = pData;

						// set connection name

						strName = pRasEntryName[dwIndex].szEntryName;

						if (strName == strDefaultName)
						{
							// add " (Default)" to name

							strDefaultName += strDefault;
							pData->Name = strDefaultName;
							pData->Default = VARIANT_TRUE;
							nDefaultIndex = dwIndex;
						}
						else
						{
							pData->Name = strName;
							pData->Default = VARIANT_FALSE;
						}

						// get all InternetQueryOption info

						if (hInst = GetExports(WININET))
						{
							dwListSize = sizeof(list);
							list.pszConnection = strName.GetBuffer(strName.GetLength());
							list.dwSize = sizeof(list);
							list.dwOptionCount = 4;
							list.pOptions = new INTERNET_PER_CONN_OPTION[4];

							list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
							list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
							list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
							list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

							bResult = pfnInternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwListSize);
							if (bResult)
							{
								pData->AutoProxyDetectMode = GetBooleanString(list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT, ENABLED_DISABLED);

								strTemp = list.pOptions[3].Value.pszValue;
								pData->AutoConfigURL = strTemp;

								pData->Proxy = GetBooleanString(list.pOptions[0].Value.dwValue & PROXY_TYPE_PROXY, ENABLED_DISABLED);

								strTemp = list.pOptions[1].Value.pszValue;
								pData->ProxyServer = strTemp;
								
								strProxyOverride = list.pOptions[2].Value.pszValue;

								// removing all <enter>s from string

								while (-1 != (nIndex = strProxyOverride.Find(_T("\r\n"))))
									strProxyOverride = strProxyOverride.Left(nIndex) + strProxyOverride.Right(strProxyOverride.GetLength() - (nIndex + 2));

								pData->ProxyOverride = strProxyOverride;
							}
							delete []list.pOptions;
							strName.ReleaseBuffer();

							FreeLibrary(hInst);
						}

						// allow Internet programs to use connection

						strKey = REG_REMOTE_ACCESS_PROFILE;
						strKey += _T('\\');
						strKey += strName;
						if (ERROR_SUCCESS == GetRegValue(HKEY_CURRENT_USER, strKey, REG_COVER_EXCLUDE, dwTemp))
							pData->AllowInternetPrograms = GetBooleanString(!dwTemp);

						// get other reg data

						GetRegValue(HKEY_CURRENT_USER, strKey, REG_REDIAL_ATTEMPTS, pData->RedialAttempts);
						if (VT_EMPTY == pData->RedialAttempts.vt)
							pData->RedialAttempts = (long)10;		// if reg entry not found, set to default

						GetRegValue(HKEY_CURRENT_USER, strKey, REG_REDIAL_WAIT, pData->RedialWait);
						if (VT_EMPTY == pData->RedialWait.vt)
							pData->RedialWait = (long)5;		// if reg entry not found, set to default

						GetRegValue(HKEY_CURRENT_USER, strKey, REG_DISCONNECT_IDLE_TIME, pData->DisconnectIdleTime);
						if (VT_EMPTY == pData->DisconnectIdleTime.vt)
							pData->DisconnectIdleTime = (long)20;		// if reg entry not found, set to default

						dwTemp = 0;		// if reg entry not found, set to default
						GetRegValue(HKEY_CURRENT_USER, strKey, REG_ENABLE_AUTO_DISCONNECT, dwTemp);
						pData->AutoDisconnect = GetBooleanString(dwTemp, ENABLED_DISABLED);

						if (ERROR_SUCCESS == GetRegValue(HKEY_LOCAL_MACHINE, REG_PPP_KEY, REG_LOGGING, dwTemp))
							pData->RecordLogFile = GetBooleanString(dwTemp);

						// get all RasGetEntryProperties info

						dwEntrySize = sizeof(RASENTRY);
						if ((pRasEntry = (LPRASENTRY)malloc((UINT)dwEntrySize)) != NULL) 
						{
							pRasEntry->dwSize = sizeof(RASENTRY);
							dwResult = pfnRasGetEntryProperties(NULL,(LPCTSTR)strName, pRasEntry, &dwEntrySize, NULL, NULL);
							if (dwResult == ERROR_BUFFER_TOO_SMALL)
							{
                                pRasEntryPreFail = pRasEntry;
#pragma prefast(suppress:308,"Pointer was saved")
								if ((pRasEntry = (LPRASENTRY)realloc(pRasEntry, dwEntrySize)) != NULL)
									dwResult = pfnRasGetEntryProperties(NULL, (LPCTSTR)strName, pRasEntry, &dwEntrySize, NULL, NULL);
                                else
                                {
									free(pRasEntryPreFail);
                                }
							}
							if (!dwResult && pRasEntry)
							{
								// modem name

								pData->Modem = pRasEntry->szDeviceName;

								// dial-up server (framing protocol)

								switch (pRasEntry->dwFramingProtocol)
								{
								case RASFP_Ppp:
									ids = IDS_PROTOCOL_PPP;
									break;
								case RASFP_Slip:
									ids = IDS_PROTOCOL_SLIP;
									break;
								case RASFP_Ras:
									ids = IDS_PROTOCOL_RAS;
									break;
								default:
									ids = IDS_NOT_AVAILABLE;
								}
								strTemp.LoadString(ids);
								pData->DialUpServer = strTemp;

								// bools

								pData->NetworkLogon = GetBooleanString(pRasEntry->dwfOptions & RASEO_NetworkLogon);
								pData->SoftwareCompression = GetBooleanString(pRasEntry->dwfOptions & RASEO_SwCompression);
								pData->EncryptedPassword = GetBooleanString(pRasEntry->dwfOptions & RASEO_RequireEncryptedPw);
								pData->DataEncryption = GetBooleanString(pRasEntry->dwfOptions & RASEO_RequireDataEncryption);
								pData->IPHeaderCompression = GetBooleanString(pRasEntry->dwfOptions & RASEO_IpHeaderCompression);
								pData->DefaultGateway = GetBooleanString(pRasEntry->dwfOptions & RASEO_RemoteDefaultGateway);

								// network protocols

								strName.Empty();
								if (pRasEntry->dwfNetProtocols & RASNP_Ip)
								{
									strTemp.LoadString(IDS_TCP_IP);
									strName += strTemp;
								}
								if (pRasEntry->dwfNetProtocols & RASNP_Ipx)
								{
									strTemp.LoadString(IDS_IPX_SPX);
									if (!strName.IsEmpty())
										strName += _T(", ");
									strName += strTemp;
								}
								if (pRasEntry->dwfNetProtocols & RASNP_NetBEUI)
								{
									strTemp.LoadString(IDS_NET_BEUI);
									if (!strName.IsEmpty())
										strName += _T(", ");
									strName += strTemp;
								}
								pData->NetworkProtocols = strName;

								// IP addresses

								pData->ServerAssignedIPAddress = GetBooleanString(!(pRasEntry->dwfOptions & RASEO_SpecificIpAddr));
								pData->IPAddress = ConvertIPAddressToString(pRasEntry->ipaddr);
								pData->ServerAssignedNameServer = GetBooleanString(!(pRasEntry->dwfOptions & RASEO_SpecificNameServers));
								pData->PrimaryDNS = ConvertIPAddressToString(pRasEntry->ipaddrDns);
								pData->SecondaryDNS = ConvertIPAddressToString(pRasEntry->ipaddrDnsAlt);
								pData->PrimaryWINS = ConvertIPAddressToString(pRasEntry->ipaddrWins);
								pData->SecondaryWINS = ConvertIPAddressToString(pRasEntry->ipaddrWinsAlt);

								// script filename

								pData->ScriptFileName = pRasEntry->szScript;
							}
							free(pRasEntry);
						}
    				}

					// Making sure the first item in the returned array is the default connection (if one exists)

					if (nDefaultIndex > 0)
					{
						// swapping ptrs so first item is default

						pData = (IE_CONN_SETTINGS*)(*pppIEData)[0];
						(*pppIEData)[0] = (*pppIEData)[nDefaultIndex];
						(*pppIEData)[nDefaultIndex] = pData;
					}

				}
				free(pRasEntryName);
			}
			FreeLibrary(hInstRAS);
		}
	}
	else if (enType == CacheType)
	{
		IE_CACHE *pData;
		CString strTemp, strCachePath, strKey;
		HINSTANCE hInst;
		DWORDLONG cbAvail = 0, cbTotal = 0;
		DWORD dwSyncMode, dwCacheLimit, dwCacheSize;
		int ids;

		if (pCancel)
			if (*pCancel != 0L) return;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_CACHE;
		*pppIEData[0] = pData;
		*plCount = 1;

		// page refresh type

		if (ERROR_SUCCESS == GetRegValue(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, REG_SYNC_MODE_5, dwSyncMode))
		{
			switch (dwSyncMode)
			{
			case WININET_SYNC_MODE_ALWAYS:
				ids = IDS_ALWAYS;
				break;
			case WININET_SYNC_MODE_ONCE_PER_SESSION:
				ids = IDS_ONCE_PER_SESSION;
				break;
			case WININET_SYNC_MODE_AUTOMATIC:
				ids = IDS_AUTOMATIC;
				break;
			case WININET_SYNC_MODE_NEVER:
				ids = IDS_NEVER;
				break;
			default:
				ids = IDS_NOT_AVAILABLE;
			}
		}
		else
			ids = IDS_AUTOMATIC;		// if reg entry not found, set to default

		strTemp.LoadString(ids);
		pData->PageRefreshType = strTemp;

		// temp internet files folder

		GetRegValue(HKEY_CURRENT_USER, REG_SHELL_FOLDERS_KEY, REG_CACHE, pData->TempInternetFilesFolder);

		// adding hidden content.ie5 folder for size calculations
		
		strCachePath = pData->TempInternetFilesFolder.bstrVal;
		if (strCachePath.Right(strlen(CONTENT_IE5)) != CONTENT_IE5)
		{
			if (strCachePath[strCachePath.GetLength() - 1] != _T('\\'))
				strCachePath += '\\';
			strCachePath += CONTENT_IE5;
		}

		// disk space and cache size

		strKey = REG_IE_SETTINGS_KEY;
		strKey += _T('\\');
		strKey += REG_CACHE;
		strKey += _T('\\');
		strKey += REG_CONTENT;

		if (ERROR_SUCCESS == GetRegValue(HKEY_CURRENT_USER, strKey, REG_CACHE_LIMIT, dwCacheLimit))
		{
			if (hInst = GetExports(WININET))
			{
				if (pfnGetDiskInfo((LPTSTR)(LPCTSTR)strCachePath, NULL, &cbAvail, &cbTotal))
				{
					pData->TotalDiskSpace = (float)(signed __int64)(cbTotal / CONSTANT_MEGABYTE);
					pData->AvailableDiskSpace = (float)(signed __int64)(cbAvail / CONSTANT_MEGABYTE);
					pData->MaxCacheSize = (float)(dwCacheLimit / 1024);

					// get size of all files under "Temporary Internet Files" folder

					dwCacheSize = GetDirSize(strCachePath);
					TRACE(_T("Temporary Internet Files Folder Size = %lu\n"), dwCacheSize);
					pData->AvailableCacheSize = ((float)((dwCacheLimit * 1024) - dwCacheSize) / CONSTANT_MEGABYTE);
				}
				FreeLibrary(hInst);
			}
		}
	}

	else if (enType == ObjectType)
	{
		IE_OBJECT *pData;
		CTypedPtrArray<CPtrArray, IE_OBJECT*> ptrs;
		CString strTemp;
		HINSTANCE hInst;
		HANDLE hFindControl, hControl;
		DWORD dwStatus;
		int ids;

		if (hInst = GetExports(OCCACHE))
		{
			if (ERROR_SUCCESS == pfnFindFirstControl(hFindControl, hControl, NULL))
			{
				do
				{
					pData = new IE_OBJECT;
					ptrs.Add(pData);
					char strName[CONTROLNAME_MAXSIZE];
					pfnGetControlInfo(hControl, GCI_NAME, NULL, strName, CONTROLNAME_MAXSIZE);
					//strTemp.ReleaseBuffer();
					pData->ProgramFile = strName;

					pfnGetControlInfo(hControl, GCI_STATUS, &dwStatus, NULL, 0);
					switch (dwStatus)
					{
					case STATUS_CTRL_INSTALLED:
						ids = IDS_INSTALLED;
						break;
					case STATUS_CTRL_SHARED:
						ids = IDS_SHARED;
						break;
					case STATUS_CTRL_DAMAGED:
						ids = IDS_DAMAGED;
						break;
					case STATUS_CTRL_UNPLUGGED:
						ids = IDS_UNPLUGGED;
						break;
					case STATUS_CTRL_UNKNOWN:
					default:
						ids = IDS_NOT_AVAILABLE;
					}
					CString strTemp;
					strTemp.LoadString(ids);
					pData->Status = strTemp;
					char strCodeBase[INTERNET_MAX_URL_LENGTH];
					pfnGetControlInfo(hControl, GCI_CODEBASE, NULL, strCodeBase, INTERNET_MAX_URL_LENGTH);
					//strTemp.ReleaseBuffer();
					pData->CodeBase = strCodeBase;

					pfnReleaseControlHandle(hControl);

				} while (ERROR_SUCCESS == pfnFindNextControl(hFindControl, hControl));
			}
			pfnFindControlClose(hFindControl);

			*plCount = (long) ptrs.GetSize();
			*pppIEData = (void**)new LPVOID[*plCount];

			for (int i = 0; i < *plCount; i++)
				(*pppIEData)[i] = ptrs[i];

			FreeLibrary(hInst);
		}
	}

	else if (enType == ContentType)
	{
		IE_CONTENT *pData;
		HINSTANCE hInst;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_CONTENT;
		*pppIEData[0] = pData;
		*plCount = 1;

		if (hInst = GetExports(MSRATING))
		{
			pData->Advisor = GetBooleanString(pfnRatingEnabledQuery() == S_OK, ENABLED_DISABLED);

			FreeLibrary(hInst);
		}
	}

	else if ((enType == CertificateType))
	{
		CTypedPtrArray<CPtrArray, IE_CERTIFICATE*> ptrs;
		HINSTANCE hInst;

		if (hInst = GetExports(CRYPT32))
		{
			GetPersonalCertificates(ptrs);
			GetOtherPeopleCertificates(ptrs);

			*plCount = (long) ptrs.GetSize();
			*pppIEData = (void**)new LPVOID[*plCount];

			for (int i = 0; i < *plCount; i++)
				(*pppIEData)[i] = ptrs[i];

			FreeLibrary(hInst);
		}
	}

	else if ((enType == PublisherType))
	{
		IE_PUBLISHER *pData;
		HKEY hKey;
		CString strRegName, strRegData;
		DWORD cPublishers, dwIndex, dwNameSize, dwDataSize;

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_PUBLISHERS_KEY, 0, KEY_READ, &hKey))
		{
			if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cPublishers, NULL, NULL, NULL, NULL))
			{
				*plCount = cPublishers;
				*pppIEData = (void**)new LPVOID[cPublishers];

				for (dwIndex = 0; dwIndex < cPublishers; dwIndex++)
				{
					pData = new IE_PUBLISHER;
					(*pppIEData)[dwIndex] = pData;

					dwNameSize = _MAX_FNAME;
					dwDataSize = _MAX_FNAME;
					RegEnumValue(hKey, dwIndex, strRegName.GetBuffer(_MAX_FNAME), &dwNameSize, NULL, NULL, (LPBYTE)strRegData.GetBuffer(_MAX_FNAME), &dwDataSize);
					strRegName.ReleaseBuffer();
					strRegData.ReleaseBuffer();

					pData->Name = strRegData;
				}
			}
			RegCloseKey(hKey);
		}
	}

	else if (enType == SecurityType)
	{
		IE_SECURITY *pData;
		IInternetZoneManager*  pIZoneMgr = NULL;
		DWORD dwEnum;
		DWORD dwCount;
		CTypedPtrArray<CPtrArray, IE_SECURITY*> ptrs;
		try
		{
			HRESULT hr = CoCreateInstance(CLSID_InternetZoneManager,NULL,CLSCTX_INPROC_SERVER,IID_IInternetZoneManager,(void**) &pIZoneMgr);
			if (SUCCEEDED(hr))
			{
				hr = pIZoneMgr->CreateZoneEnumerator(&dwEnum,&dwCount,0);
				if (SUCCEEDED(hr))
				{
					DWORD dwZone;
					ZONEATTRIBUTES zoneAttrib;
					for(DWORD i = 0; i < dwCount; i++)
					{
						hr = pIZoneMgr->GetZoneAt(dwEnum,i,&dwZone);
						if (FAILED(hr))
						{
							break;
						}
						hr = pIZoneMgr->GetZoneAttributes(dwZone,&zoneAttrib);
						if (FAILED(hr))
						{
							break;
						}
						pData = new IE_SECURITY;
						ptrs.Add(pData);
						pData->Zone = zoneAttrib.szDisplayName;
						CString strTemp;
						int ids;
						switch (zoneAttrib.dwTemplateCurrentLevel)
						{
							case URLTEMPLATE_LOW:
								ids = IDS_LOW;
								break;
							case 0x10500:
								ids = IDS_MEDIUM_LOW;
								break;
							case URLTEMPLATE_MEDIUM:
								ids = IDS_MEDIUM;
								break;
							case URLTEMPLATE_HIGH:
								ids = IDS_HIGH;
								break;
							case URLTEMPLATE_CUSTOM:
								ids = IDS_CUSTOM;
								break;
							default:
								ids = IDS_NOT_AVAILABLE;
						}
						strTemp.LoadString(ids);
						pData->Level = strTemp;
						
					}
				}
			


				*plCount = (long) ptrs.GetSize();
				*pppIEData = (void**)new LPVOID[*plCount];

				for (int i = 0; i < *plCount; i++)
					(*pppIEData)[i] = ptrs[i];
			}
		}
		catch(...)
		{

		}
		if (pIZoneMgr)
		{
			pIZoneMgr->Release();
		}

	}
}

///////////////////////////////////////////////////////////////////////////////
// AppDeleteIEData - Deletes previously retrieved IE data.
///////////////////////////////////////////////////////////////////////////////

void CMsieApp::AppDeleteIEData(IEDataType enType, long lCount, void **ppIEData)
{
	for (long i = 0; i < lCount; i++)
	{
		switch (enType)
		{
		case SummaryType:
			delete (IE_SUMMARY*)ppIEData[i];
			break;

		case FileVersionType:
			delete (IE_FILE_VERSION*)ppIEData[i];
			break;

		case ConnSummaryType:
			delete (IE_CONN_SUMMARY*)ppIEData[i];
			break;

		case LanSettingsType:
			delete (IE_LAN_SETTINGS*)ppIEData[i];
			break;

		case ConnSettingsType:
			delete (IE_CONN_SETTINGS*)ppIEData[i];
			break;

		case CacheType:
			delete (IE_CACHE*)ppIEData[i];
			break;

		case ObjectType:
			delete (IE_OBJECT*)ppIEData[i];
			break;

		case ContentType:
			delete (IE_CONTENT*)ppIEData[i];
			break;

		case CertificateType:
			delete (IE_CERTIFICATE*)ppIEData[i];
			break;

		case PublisherType:
			delete (IE_PUBLISHER*)ppIEData[i];
			break;

		case SecurityType:
			delete (IE_SECURITY*)ppIEData[i];
			break;
		}
	}
	delete []ppIEData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\msiectl.h ===
// MsieCtl.h : Declaration of the CMsieCtrl ActiveX Control class.

#if !defined(AFX_MSIECTL_H__25959BFC_E700_11D2_A7AF_00C04F806200__INCLUDED_)
#define AFX_MSIECTL_H__25959BFC_E700_11D2_A7AF_00C04F806200__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <wbemprov.h>

// MSInfo views for IE extension - must match values in Registry

#define MSIVIEW_BEGIN				1
#define MSIVIEW_SUMMARY				1
#define MSIVIEW_FILE_VERSIONS		2
#define MSIVIEW_CONNECTIVITY		3
#define MSIVIEW_CACHE				4
#define MSIVIEW_OBJECT_LIST		5
#define MSIVIEW_CONTENT				6
#define MSIVIEW_PERSONAL_CERTIFICATES	7
#define MSIVIEW_OTHER_PEOPLE_CERTIFICATES	8
#define MSIVIEW_PUBLISHERS			9
#define MSIVIEW_SECURITY			10
#define MSIVIEW_END					10

#define CONNECTIVITY_BASIC_LINES	51

#define ITEM_LEN			128
#define VALUE_LEN			MAX_PATH
#define VERSION_LEN		20
#define DATE_LEN			64
#define SIZE_LEN			16
#define STATUS_LEN		40

typedef struct
{
	UINT		uiView;
	TCHAR		szItem[ITEM_LEN];
	TCHAR		szValue[VALUE_LEN];
} LIST_ITEM;

typedef struct
{
	UINT		uiView;
	TCHAR		szItem[ITEM_LEN];
	TCHAR		szValue[VALUE_LEN];
	BOOL		bBold;
} EDIT_ITEM;

typedef struct
{
	UINT		uiView;
	TCHAR		szFile[_MAX_FNAME];
	TCHAR		szVersion[VERSION_LEN];
	TCHAR		szSize[SIZE_LEN];
	TCHAR		szDate[DATE_LEN];
	TCHAR		szPath[VALUE_LEN];
	TCHAR		szCompany[VALUE_LEN];
	DWORD		dwSize;
	DATE		date;
} LIST_FILE_VERSION;

typedef struct
{
	UINT		uiView;
	TCHAR		szProgramFile[_MAX_FNAME];
	TCHAR		szStatus[STATUS_LEN];
	TCHAR		szCodeBase[MAX_PATH];
} LIST_OBJECT;

typedef struct
{
	UINT		uiView;
	TCHAR		szIssuedTo[_MAX_FNAME];
	TCHAR		szIssuedBy[_MAX_FNAME];
	TCHAR		szValidity[_MAX_FNAME];
	TCHAR		szSignatureAlgorithm[_MAX_FNAME];
} LIST_CERT;

typedef struct
{
	UINT		uiView;
	TCHAR		szName[_MAX_FNAME];
} LIST_NAME;

/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl : See MsieCtl.cpp for implementation.

class CMsieCtrl : public COleControl
{
	DECLARE_DYNCREATE(CMsieCtrl)

// Constructor
public:
	CMsieCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsieCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void Serialize(CArchive& ar);
	protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CMsieCtrl();

	DECLARE_OLECREATE_EX(CMsieCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CMsieCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CMsieCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CMsieCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CMsieCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void OnBasicBtnClicked();
	void OnAdvancedBtnClicked();

// Dispatch maps
	//{{AFX_DISPATCH(CMsieCtrl)
	long m_MSInfoView;
	afx_msg void OnMSInfoViewChanged();
	afx_msg void MSInfoRefresh(BOOL fForSave, long FAR* pCancel);
	afx_msg BOOL MSInfoLoadFile(LPCTSTR szFileName);
	afx_msg void MSInfoSelectAll();
	afx_msg void MSInfoCopy();
	afx_msg void MSInfoUpdateView();
	afx_msg long MSInfoGetData(long dwMSInfoView, long FAR* pBuffer, long dwLength);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Interface maps
	
	DECLARE_INTERFACE_MAP()

	// IWbemProviderInit
	BEGIN_INTERFACE_PART(WbemProviderInit, IWbemProviderInit)
		STDMETHOD(Initialize)(
			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pNamespace,
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink);
		STDMETHOD(GetByPath)(BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext *pCtx) {return WBEM_E_NOT_SUPPORTED;};
	END_INTERFACE_PART(WbemProviderInit)

	//IWbemServices  
	BEGIN_INTERFACE_PART(WbemServices, IWbemServices)
		STDMETHOD(OpenNamespace)( 
         /* [in] */ const BSTR Namespace,
         /* [in] */ long lFlags,
         /* [in] */ IWbemContext __RPC_FAR *pCtx,
         /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
         /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
		STDMETHOD(CancelAsyncCall)( 
			/* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(QueryObjectSink)( 
			/* [in] */ long lFlags,
			/* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(GetObject)( 
			/* [in] */ const BSTR ObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(GetObjectAsync)( 
			/* [in] */ const BSTR ObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(PutClass)( 
			/* [in] */ IWbemClassObject __RPC_FAR *pObject,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(PutClassAsync)( 
			/* [in] */ IWbemClassObject __RPC_FAR *pObject,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(DeleteClass)( 
			/* [in] */ const BSTR Class,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(DeleteClassAsync)( 
			/* [in] */ const BSTR Class,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(CreateClassEnum)( 
			/* [in] */ const BSTR Superclass,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(CreateClassEnumAsync)( 
			/* [in] */ const BSTR Superclass,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(PutInstance)( 
			/* [in] */ IWbemClassObject __RPC_FAR *pInst,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(PutInstanceAsync)( 
			/* [in] */ IWbemClassObject __RPC_FAR *pInst,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(DeleteInstance)( 
			/* [in] */ const BSTR ObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(DeleteInstanceAsync)( 
			/* [in] */ const BSTR ObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(CreateInstanceEnum)( 
			/* [in] */ const BSTR Class,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(CreateInstanceEnumAsync)( 
			/* [in] */ const BSTR Class,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

		STDMETHOD(ExecQuery)( 
			/* [in] */ const BSTR QueryLanguage,
			/* [in] */ const BSTR Query,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(ExecQueryAsync)( 
			/* [in] */ const BSTR QueryLanguage,
			/* [in] */ const BSTR Query,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(ExecNotificationQuery)( 
			/* [in] */ const BSTR QueryLanguage,
			/* [in] */ const BSTR Query,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(ExecNotificationQueryAsync)( 
			/* [in] */ const BSTR QueryLanguage,
			/* [in] */ const BSTR Query,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(ExecMethod)(const BSTR, const BSTR, long, IWbemContext*,
			IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

		STDMETHOD(ExecMethodAsync)(const BSTR, const BSTR, long, 
			IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}
	END_INTERFACE_PART(WbemServices)

// Event maps
	//{{AFX_EVENT(CMsieCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CMsieCtrl)
	dispidMSInfoView = 1L,
	dispidMSInfoRefresh = 2L,
	dispidMSInfoLoadFile = 3L,
	dispidMSInfoSelectAll = 4L,
	dispidMSInfoCopy = 5L,
	dispidMSInfoUpdateView = 6L,
	dispidMSInfoGetData = 7L,
	//}}AFX_DISP_ID
	};

private:
	void DrawLine();
	BOOL FormatColumns();
	BOOL AddColumn(int idsLabel, int nItem, int nSubItem = -1, int size = 0,
		int nMask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM,
		int nFmt = LVCFMT_LEFT);
	BOOL AddItem(int nItem,int nSubItem,LPCTSTR strItem,int nImageIndex = -1);
	void RefigureColumns(CRect& rect);
	void RefreshListControl(BOOL bRedraw);
	void RefreshEditControl(BOOL bRedraw);

	void DeleteArrayObject(void *ptrArray);

	void RefreshArray(int iView, int &iListItem, CPtrArray &ptrarrayNew);
	CString GetStringFromIDS(int ids);
	CString GetStringFromVariant(COleVariant &var, int idsFormat = 0);
	void AddToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszItem, LPCTSTR pszValue);
	void AddToArray(CPtrArray &ptrarray, int itemNum, int idsItem, LPCTSTR pszValue);
	void AddBlankLineToArray(CPtrArray &ptrarray, int itemNum);
	void AddEditBlankLineToArray(CPtrArray &ptrarray, int itemNum);
	void AddFileVersionToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszFile, LPCTSTR pszVersion, LPCTSTR pszSize, LPCTSTR pszDate, LPCTSTR pszPath, LPCTSTR pszCompany, DWORD dwSize, DATE date);
	void AddEditToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszItem, LPCTSTR pszValue, BOOL bBold = FALSE);
	void AddEditToArray(CPtrArray &ptrarray, int itemNum, int idsItem, LPCTSTR pszValue, BOOL bBold = FALSE);
	void AddObjectToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszProgramFile, LPCTSTR pszStatus, LPCTSTR pszCodeBase);
	void AddCertificateToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszIssuedTo, LPCTSTR pszIssuedBy, LPCTSTR pszValidity, LPCTSTR pszSignatureAlgorithm);
	void AddNameToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszName);

	//====================================================================
	// MSInfo Specific...
	//
	// Add members to the control class to keep track of the currently
	// displayed data. In this example, we use a flag to indicate if the
	// data is current or loaded from a file.
	//====================================================================

	CBrush *m_pCtlBkBrush;
	bool m_bCurrent;
	CListCtrl m_list;
	CImageList m_imageList;
	CPtrArray m_ptrarray;
	CStatic m_static;
	CButton m_btnBasic, m_btnAdvanced;
	CRichEditCtrl m_edit;
	CFont m_fontStatic, m_fontBtn;
	UINT m_uiView;

	// The following member variables are used to keep track of the
	// column sizes on the list control.

	int m_cColumns;
	int m_aiRequestedWidths[20];
	int m_aiColumnWidths[20];
	int m_aiMinWidths[20];
	int m_aiMaxWidths[20];

	// WMI 

	bool GetIEType(const BSTR classStr, IEDataType &enType);
	void ConvertDateToWbemString(COleVariant &var);
	void SetIEProperties(IEDataType enType, void *pIEData, IWbemClassObject *pInstance);

	IWbemServices *m_pNamespace;
};

#endif // !defined(AFX_MSIECTL_H__25959BFC_E700_11D2_A7AF_00C04F806200__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\msieppg.cpp ===
// MsiePpg.cpp : Implementation of the CMsiePropPage property page class.

#include "stdafx.h"
#include "Msie.h"
#include "MsiePpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMsiePropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMsiePropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMsiePropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMsiePropPage, "MSIE.MsiePropPage.1",
	0x25959bf0, 0xe700, 0x11d2, 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0)


/////////////////////////////////////////////////////////////////////////////
// CMsiePropPage::CMsiePropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMsiePropPage

BOOL CMsiePropPage::CMsiePropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MSIE_PPG, afxRegApartmentThreading);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMsiePropPage::CMsiePropPage - Constructor

CMsiePropPage::CMsiePropPage() :
	COlePropertyPage(IDD, IDS_MSIE_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMsiePropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMsiePropPage::DoDataExchange - Moves data between page and properties

void CMsiePropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMsiePropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMsiePropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\msieppg.h ===
#if !defined(AFX_MSIEPPG_H__25959BFE_E700_11D2_A7AF_00C04F806200__INCLUDED_)
#define AFX_MSIEPPG_H__25959BFE_E700_11D2_A7AF_00C04F806200__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// MsiePpg.h : Declaration of the CMsiePropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMsiePropPage : See MsiePpg.cpp.cpp for implementation.

class CMsiePropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMsiePropPage)
	DECLARE_OLECREATE_EX(CMsiePropPage)

// Constructor
public:
	CMsiePropPage();

// Dialog Data
	//{{AFX_DATA(CMsiePropPage)
	enum { IDD = IDD_PROPPAGE_MSIE };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMsiePropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSIEPPG_H__25959BFE_E700_11D2_A7AF_00C04F806200__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\msiedata.h ===
// Msiedata.h : Enums, structs and externs exposed by MSIE51.ocx

#ifndef _MSIEDATA_H_
#define _MSIEDATA_H_

enum IEDataType
{
	SummaryType,
	FileVersionType,
	LanSettingsType,
	ConnSummaryType,
	ConnSettingsType,
	CacheType,
	ObjectType,
	ContentType,
	CertificateType,
	PublisherType,
	SecurityType
};

typedef struct
{
	COleVariant Name;
	COleVariant Version;
	COleVariant Build;
	COleVariant ProductID;
	COleVariant Path;
	COleVariant LastInstallDate;
	COleVariant Language;
	COleVariant ActivePrinter;
	COleVariant CipherStrength;
	COleVariant ContentAdvisor;
	COleVariant IEAKInstall;
} IE_SUMMARY;

typedef struct
{
	COleVariant File;
	COleVariant Version;
	COleVariant Size;
	COleVariant Date;
	COleVariant Path;
	COleVariant Company;
} IE_FILE_VERSION;

typedef struct
{
	COleVariant ConnectionPreference;
	COleVariant EnableHttp11;
	COleVariant ProxyHttp11;
} IE_CONN_SUMMARY;

typedef struct
{
	COleVariant AutoConfigProxy;
	COleVariant AutoProxyDetectMode;
	COleVariant AutoConfigURL;
	COleVariant Proxy;
	COleVariant ProxyServer;
	COleVariant ProxyOverride;
} IE_LAN_SETTINGS;

typedef struct
{
	COleVariant Name;
	COleVariant Default;
	COleVariant AutoDial;
	COleVariant AutoProxyDetectMode;
	COleVariant AutoConfigURL;
	COleVariant Proxy;
	COleVariant ProxyServer;
	COleVariant ProxyOverride;
	COleVariant AllowInternetPrograms;
	COleVariant RedialAttempts;
	COleVariant RedialWait;
	COleVariant DisconnectIdleTime;
	COleVariant AutoDisconnect;
	COleVariant Modem;
	COleVariant DialUpServer;
	COleVariant NetworkLogon;
	COleVariant SoftwareCompression;
	COleVariant EncryptedPassword;
	COleVariant DataEncryption;
	COleVariant RecordLogFile;
	COleVariant NetworkProtocols;
	COleVariant ServerAssignedIPAddress;
	COleVariant IPAddress;
	COleVariant ServerAssignedNameServer;
	COleVariant PrimaryDNS;
	COleVariant SecondaryDNS;
	COleVariant PrimaryWINS;
	COleVariant SecondaryWINS;
	COleVariant IPHeaderCompression;
	COleVariant DefaultGateway;
	COleVariant ScriptFileName;
} IE_CONN_SETTINGS;

typedef struct
{
	COleVariant PageRefreshType;
	COleVariant TempInternetFilesFolder;
	COleVariant TotalDiskSpace;
	COleVariant AvailableDiskSpace;
	COleVariant MaxCacheSize;
	COleVariant AvailableCacheSize;
} IE_CACHE;

typedef struct
{
	COleVariant ProgramFile;
	COleVariant Status;
	COleVariant CodeBase;
} IE_OBJECT;

typedef struct
{
	COleVariant Advisor;
} IE_CONTENT;

typedef struct
{
	COleVariant Type;
	COleVariant IssuedTo;
	COleVariant IssuedBy;
	COleVariant Validity;
	COleVariant SignatureAlgorithm;
} IE_CERTIFICATE;

typedef struct
{
	COleVariant Name;
} IE_PUBLISHER;

typedef struct
{
	COleVariant Zone;
	COleVariant Level;
} IE_SECURITY;

#endif _MSIEDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Msie.rc
//
#define IDS_MSIE                        1
#define IDB_MSIE                        1
#define IDS_MSIE_PPG                    2
#define IDS_TRUE                        3
#define IDS_FALSE                       4
#define IDS_NOT_AVAILABLE               5
#define IDS_FILE_MISSING                6
#define IDS_DIAL_NO_NET                 7
#define IDS_ALWAYS_DIAL                 8
#define IDS_NEVER_DIAL                  9
#define IDS_BASIC_INFO                  10
#define IDS_ADVANCED_INFO               11
#define IDS_INF_FILE_MISSING            12
#define IDS_DEFAULT                     13
#define IDS_PROTOCOL_PPP                14
#define IDS_PROTOCOL_SLIP               15
#define IDS_PROTOCOL_RAS                16
#define IDS_TCP_IP                      17
#define IDS_IPX_SPX                     18
#define IDS_NET_BEUI                    19
#define IDS_YES                         20
#define IDS_NO                          21
#define IDS_ALWAYS                      22
#define IDS_ONCE_PER_SESSION            23
#define IDS_AUTOMATIC                   24
#define IDS_NEVER                       25
#define IDS_LOW                         26
#define IDS_MEDIUM_LOW                  27
#define IDS_MEDIUM                      28
#define IDS_HIGH                        29
#define IDS_CUSTOM                      30
#define IDS_INSTALLED                   31
#define IDS_SHARED                      32
#define IDS_DAMAGED                     33
#define IDS_UNPLUGGED                   34
#define IDS_IE_REPAIR_TOOL              35
#define IDS_RUNS_IE_REPAIR_TOOL         36
#define IDS_REPAIR_LOG                  37
#define IDS_VALIDITY_FORMAT             38
#define IDS_ENABLED                     39
#define IDS_DISABLED                    40
#define IDS_NO_CONNECTIONS              41
#define IDS_MSIE_PPG_CAPTION            500
#define IDD_PROPPAGE_MSIE               500
#define IDC_LISTCTRL                    501
#define IDC_EDITCTRL                    502
#define IDC_BTN_BASIC                   503
#define IDC_BTN_ADVANCED                504
#define IDS_MSITEMPLATEBASE             1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        506
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         505
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\regkeys.h ===
#define REG_IE_KEY				_T("SOFTWARE\\Microsoft\\Internet Explorer")
#define REG_VERSION				_T("Version")
#define REG_BUILD					_T("Build")
#define REG_REGISTRATION		_T("Registration")
#define REG_PRODUCT_ID			_T("ProductID")
#define REG_IEXPLORE_EXE_KEY	_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")
#define REG_PATH					_T("Path")
#define REG_CUSTOMIZED_VERSION	_T("CustomizedVersion")
#define REG_IE_SETTINGS_KEY	_T("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REG_AUTO_CONFIG_PROXY	_T("AutoConfigProxy")
#define REG_ENABLE_HTTP_1_1	_T("EnableHttp1_1")
#define REG_PROXY_HTTP_1_1		_T("ProxyHttp1.1")
#define REG_ENABLE_AUTODIAL	_T("EnableAutodial")
#define REG_NO_NET_AUTODIAL	_T("NoNetAutodial")
#define REG_MSINFO_KEY			_T("Software\\Microsoft\\Shared Tools\\MSInfo")
#define REG_REMOTE_ACCESS_PROFILE	_T("RemoteAccess\\Profile")
#define REG_REMOTE_ACCESS		_T("RemoteAccess")
#define REG_INTERNET_PROFILE	_T("InternetProfile")
#define REG_COVER_EXCLUDE		_T("CoverExclude")
#define REG_REDIAL_ATTEMPTS	_T("RedialAttempts")
#define REG_REDIAL_WAIT			_T("RedialWait")
#define REG_DISCONNECT_IDLE_TIME	_T("DisconnectIdleTime")
#define REG_ENABLE_AUTO_DISCONNECT	_T("EnableAutodisconnect")
#define REG_PPP_KEY				_T("SYSTEM\\CurrentControlSet\\Services\\RasMan\\PPP")
#define REG_LOGGING				_T("Logging")
#define REG_ZONES					_T("Zones")
#define REG_FLAGS					_T("Flags")
#define REG_DISPLAY_NAME		_T("DisplayName")
#define REG_CURRENT_LEVEL		_T("CurrentLevel")
#define REG_CATEGORIES			_T("Categories")
#define REG_INTERNET_EXPLORER_6	_T("InternetExplorer6")
#define REG_FILE_VERSIONS		_T("FileVersions")
#define REG_CONNECTIVITY		_T("Connectivity")
#define REG_CACHE					_T("Cache")
#define REG_OBJECT_LIST			_T("ObjectList")
#define REG_CONTENT				_T("Content")
#define REG_PERSONAL_CERTIFICATES	_T("PersonalCertificates")
#define REG_OTHER_PEOPLE_CERTIFICATES	_T("OtherPeopleCertificates")
#define REG_PUBLISHERS			_T("Publishers")
#define REG_SECURITY				_T("Security")
#define REG_CLSID					_T("CLSID")
#define REG_MSINFO_VIEW			_T("MSInfoView")
#define REG_RANK					_T("Rank")
#define REG_TOOLS					_T("Tools")
#define REG_IE_REPAIR			_T("IERepair")
#define REG_COMMAND				_T("command")
#define REG_DESCRIPTION			_T("description")
#define REG_IE_SETUP_KEY		_T("Software\\Microsoft\\IE Setup\\SETUP")
#define REG_TEMPLATES			_T("Templates")
#define REG_IEINFO5				_T("ieinfo5")
#define REG_WBEM_KEY				_T("Software\\Microsoft\\WBEM")
#define REG_MOF_SELF_INSTALL	_T("MOF Self-Install Directory")
#define REG_PUBLISHERS_KEY    _T("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0")
#define REG_SYNC_MODE_5			_T("SyncMode5")
#define REG_SHELL_FOLDERS_KEY	_T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define REG_CACHE_LIMIT			_T("CacheLimit")
#define REG_MICROSOFT_KEY		_T("Software\\Microsoft")
#define REG_SHARED_TOOLS		_T("Shared Tools")
#define REG_CURRENT_VERSION_KEY	_T("Software\\Microsoft\\Windows\\CurrentVersion")
#define REG_COMMON_FILES_DIR	_T("CommonFilesDir")
#define REG_MSINFO				_T("MSInfo")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\resdefs.h ===
// resdefs.h : Defines for friendly names of template resources

#define IDS_INTERNET_EXPLORER_6         IDS_MSITEMPLATEBASE+2
#define IDS_ITEM                        IDS_MSITEMPLATEBASE+7
#define IDS_VALUE                       IDS_MSITEMPLATEBASE+8
#define IDS_VERSION                     IDS_MSITEMPLATEBASE+9
#define IDS_BUILD                       IDS_MSITEMPLATEBASE+11
#define IDS_PRODUCT_ID                  IDS_MSITEMPLATEBASE+12
#define IDS_APP_PATH                    IDS_MSITEMPLATEBASE+13
#define IDS_LAST_INSTALL_DATE           IDS_MSITEMPLATEBASE+14
#define IDS_LANGUAGE                    IDS_MSITEMPLATEBASE+16
#define IDS_ACTIVE_PRINTER              IDS_MSITEMPLATEBASE+17
#define IDS_CIPHER_STRENGTH             IDS_MSITEMPLATEBASE+18
#define IDS_FORMAT_BIT                  IDS_MSITEMPLATEBASE+19
#define IDS_CONTENT_ADVISOR             IDS_MSITEMPLATEBASE+20
#define IDS_IEAK_INSTALL                IDS_MSITEMPLATEBASE+22
#define IDS_FILE_VERSIONS               IDS_MSITEMPLATEBASE+24
#define IDS_FILE                        IDS_MSITEMPLATEBASE+26
#define IDS_SIZE                        IDS_MSITEMPLATEBASE+28
#define IDS_DATE                        IDS_MSITEMPLATEBASE+29
#define IDS_PATH                        IDS_MSITEMPLATEBASE+30
#define IDS_COMPANY                     IDS_MSITEMPLATEBASE+31
#define IDS_FORMAT_KB                   IDS_MSITEMPLATEBASE+32
#define IDS_CONNECTIVITY                IDS_MSITEMPLATEBASE+34
#define IDS_CONN_PREF                   IDS_MSITEMPLATEBASE+38
#define IDS_PROXY_HTTP_1_1              IDS_MSITEMPLATEBASE+40
#define IDS_LAN_SETTINGS                IDS_MSITEMPLATEBASE+41
#define IDS_AUTO_CONFIG_PROXY           IDS_MSITEMPLATEBASE+42
#define IDS_AUTO_PROXY_DETECT_MODE      IDS_MSITEMPLATEBASE+43
#define IDS_AUTO_CONFIG_URL             IDS_MSITEMPLATEBASE+44
#define IDS_PROXY                       IDS_MSITEMPLATEBASE+45
#define IDS_PROXY_SERVER                IDS_MSITEMPLATEBASE+46
#define IDS_PROXY_OVERRIDE              IDS_MSITEMPLATEBASE+47
#define IDS_ALLOW_INTERNET_PROGRAMS     IDS_MSITEMPLATEBASE+49
#define IDS_MAX_ATTEMPTS                IDS_MSITEMPLATEBASE+50
#define IDS_WAIT_BETWEEN_ATTEMPTS       IDS_MSITEMPLATEBASE+51
#define IDS_DISCONNECT_IDLE_TIME        IDS_MSITEMPLATEBASE+52
#define IDS_AUTO_DISCONNECT             IDS_MSITEMPLATEBASE+53
#define IDS_MODEM                       IDS_MSITEMPLATEBASE+54
#define IDS_DIAL_UP_SERVER              IDS_MSITEMPLATEBASE+55
#define IDS_LOG_ON_TO_NETWORK           IDS_MSITEMPLATEBASE+56
#define IDS_ENABLE_SOFTWARE_COMPRESSION IDS_MSITEMPLATEBASE+57
#define IDS_REQUIRE_ENCRYPTED_PASSWORD  IDS_MSITEMPLATEBASE+58
#define IDS_REQUIRE_DATA_ENCRYPTION     IDS_MSITEMPLATEBASE+59
#define IDS_RECORD_LOG_FILE             IDS_MSITEMPLATEBASE+60
#define IDS_NETWORK_PROTOCOLS           IDS_MSITEMPLATEBASE+61
#define IDS_USE_SERVER_ASSIGNED_IP_ADDRESS IDS_MSITEMPLATEBASE+62
#define IDS_IP_ADDRESS                  IDS_MSITEMPLATEBASE+63
#define IDS_USE_SERVER_ASSIGNED_NAME_SERVER IDS_MSITEMPLATEBASE+64
#define IDS_NAME_SERVER_ADDRESSES       IDS_MSITEMPLATEBASE+65
#define IDS_USE_IP_HEADER_COMPRESSION   IDS_MSITEMPLATEBASE+66
#define IDS_USE_DEFAULT_GATEWAY         IDS_MSITEMPLATEBASE+67
#define IDS_SCRIPT_FILE_NAME            IDS_MSITEMPLATEBASE+68
#define IDS_CACHE                       IDS_MSITEMPLATEBASE+70
#define IDS_PAGE_REFRESH_TYPE           IDS_MSITEMPLATEBASE+76
#define IDS_TEMPORARY_INTERNET_FILES_FOLDER IDS_MSITEMPLATEBASE+77
#define IDS_TOTAL_DISK_SPACE            IDS_MSITEMPLATEBASE+78
#define IDS_FORMAT_MB                   IDS_MSITEMPLATEBASE+79
#define IDS_AVAILABLE_DISK_SPACE        IDS_MSITEMPLATEBASE+80
#define IDS_MAX_CACHE_SIZE              IDS_MSITEMPLATEBASE+81
#define IDS_AVAILABLE_CACHE_SIZE        IDS_MSITEMPLATEBASE+82
#define IDS_OBJECT_LIST                 IDS_MSITEMPLATEBASE+84
#define IDS_PROGRAM_FILE                IDS_MSITEMPLATEBASE+86
#define IDS_STATUS                      IDS_MSITEMPLATEBASE+87
#define IDS_CODE_BASE                   IDS_MSITEMPLATEBASE+88
#define IDS_CONTENT                     IDS_MSITEMPLATEBASE+90
#define IDS_SECURITY                    IDS_MSITEMPLATEBASE+97
#define IDS_ZONE                        IDS_MSITEMPLATEBASE+98
#define IDS_SECURITY_LEVEL              IDS_MSITEMPLATEBASE+99
#define IDS_ENABLE_HTTP_1_1             IDS_MSITEMPLATEBASE+102
#define IDS_PERSONAL_CERTIFICATES       IDS_MSITEMPLATEBASE+104
#define IDS_ISSUED_TO                   IDS_MSITEMPLATEBASE+106
#define IDS_ISSUED_BY                   IDS_MSITEMPLATEBASE+107
#define IDS_VALIDITY                    IDS_MSITEMPLATEBASE+108
#define IDS_SIGNATURE_ALGORITHM         IDS_MSITEMPLATEBASE+109
#define IDS_PRIMARY_DNS                 IDS_MSITEMPLATEBASE+110
#define IDS_SECONDARY_DNS               IDS_MSITEMPLATEBASE+111
#define IDS_PRIMARY_WINS                IDS_MSITEMPLATEBASE+112
#define IDS_SECONDARY_WINS              IDS_MSITEMPLATEBASE+113
#define IDS_PERSONAL_TYPE               IDS_MSITEMPLATEBASE+114
#define IDS_OTHER_PEOPLE_CERTIFICATES   IDS_MSITEMPLATEBASE+116
#define IDS_OTHER_PEOPLE_TYPE           IDS_MSITEMPLATEBASE+122
#define IDS_PUBLISHERS                  IDS_MSITEMPLATEBASE+124
#define IDS_NAME                        IDS_MSITEMPLATEBASE+126
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\ieproj\msinfo\stdafx.h ===
#if !defined(AFX_STDAFX_H__25959BF2_E700_11D2_A7AF_00C04F806200__INCLUDED_)
#define AFX_STDAFX_H__25959BF2_E700_11D2_A7AF_00C04F806200__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>

// Delete the two includes below if you do not wish to use the MFC
//  database classes
//#include <afxdb.h>			// MFC database classes
//#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__25959BF2_E700_11D2_A7AF_00C04F806200__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\advpack.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* ADVPACK.H - Self-extracting/Self-installing stub.                       *
//*                                                                         *
//***************************************************************************
// Check out different levels of quiet mode.


#ifndef _ADVPACK_H_
#define _ADVPACK_H_


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <shlobj.h>
#include <shellapi.h>
#include "res.h"
#include "advpub.h"
#include "sdsutils.h"

//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************
#define ADVPACK_VERSION   205           // Format:  MajorVer*100+MinorVer

#define BIG_STRING        512
#define BUF_1K            1024
#define MAX_INFLINE       256

#define SHFREE_ORDINAL    195           // Required for BrowseForDir
#define _OSVER_WIN95      0
#define _OSVER_WINNT3X    1
#define _OSVER_WINNT40    2
#define _OSVER_WINNT50    3
#define _OSVER_WINNT51    4

//#define MAXERRORCHECK
// define quiet modes
#define QUIETMODE_ALL       0x0001
#define QUIETMODE_SHOWMSG   0x0002

// Flags specified in advanced INF file
#define FLAG_VALUE              0x0001              // Bit 0
#define FLAG_FAIL               0x0002              // Bit 1
#define FLAG_QUIET              0x0004              // Bit 2
#define FLAG_NOSTRIP            0x0008              // Bit 3
#define FLAG_NODIRCHECK         0x0010              // Bit 4
#define FLAG_FAIL_NOT           0x0020              // Bit 5
#define FLAG_STRIPAFTER_FIRST   0x0040              
#define DEFAULT_FLAGS   FLAG_VALUE

// Flags specifying how to set the LDID
#define LDID_SFN        0x0001              // Bit 0
#define LDID_OEM_CHARS  0x0002              // Bit 1
#define LDID_SFN_NT_ALSO   0x0004              // Bit 2

// Setup engine types
#define ENGINE_SETUPAPI 0
#define ENGINE_SETUPX   1

// CoreInstall() flags
#define COREINSTALL_PROMPT                  0x0001      // Bit 0
#define COREINSTALL_GRPCONV                 0x0002      // Bit 1
#define COREINSTALL_SMARTREBOOT             0x0004      // Bit 2
#define COREINSTALL_BKINSTALL               0x0008
#define COREINSTALL_ROLLBACK                0x0010
#define COREINSTALL_REBOOTCHECKONINSTALL    0x0020
#define COREINSTALL_ROLLBKDOALL             0x0040
#define COREINSTALL_DELAYREGISTEROCX        0x0080
#define COREINSTALL_SETUPAPI                0x0100
#define COREINSTALL_DELAYREBOOT             0x0200
#define COREINSTALL_DELAYPOSTCMD            0x0400

// Cleanup bitfield
#define CLEN_REMVINF    0x0001

// registeries for store save/restore info
//
#define   REGKEY_SAVERESTORE    "Software\\Microsoft\\Advanced INF Setup"
#define   REGSUBK_REGBK         "RegBackup"
#define   REGSUBK_CATALOGS      "Catalogs"

#define   REGVAL_BKDIR          "BackupPath"
#define   REGVAL_BKSIZE         "BackupFileSize"
#define   REGVAL_BKFILE         "BackupFileName"
#define   REGVAL_BKINSTCAB      "InstallCabFile"
#define   REGVAL_BKINSTINF      "InstallINFFile"
#define   REGVAL_BKINSTSEC      "InstallINFSection"
#define   REGVAL_BKREGDATA      "BackupRegistry"
#define   REGVAL_BKMODVER       "ComponentVersion"

#define   DEF_BACKUPPATH        "Uninstall Information"            // default fullpath: PROGRAMFILES\backup information\<module>

// registeries for system pathes
#define   REGVAL_SM_ACCESSORIES     "SM_AccessoriesName"
#define   REGVAL_PF_ACCESSORIES     "PF_AccessoriesName"
#define   REGVAL_PROGRAMFILESPATH   "ProgramFilesPath"
#define   REGVAL_PROGRAMFILES       "ProgramFilesDir"


//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************
// Required for BrowseForDir()
typedef WINSHELLAPI HRESULT (WINAPI *SHGETSPECIALFOLDERLOCATION)(HWND, int, LPITEMIDLIST *);
typedef WINSHELLAPI LPITEMIDLIST (WINAPI *SHBROWSEFORFOLDER)(LPBROWSEINFO);
typedef WINSHELLAPI void (WINAPI *SHFREE)(LPVOID);
typedef WINSHELLAPI BOOL (WINAPI *SHGETPATHFROMIDLIST)( LPCITEMIDLIST, LPSTR );

// Args passed to directory dialog
typedef struct _DIRDLGPARMS {
    LPSTR lpszPromptText;
    LPSTR lpszDefault;
    LPSTR lpszDestDir;
    ULONG cbDestDirSize;
    DWORD dwInstNeedSize;
} DIRDLGPARMS, *PDIRDLGPARMS;

// list of INF Install Section key names
typedef struct _INFOPT {
    PCSTR pszInfKey;
} INFOPT, *PINFOPT;

// OCX data struct
typedef struct _REGOCXData {
    PSTR pszOCX;
    PSTR pszSwitch;
    PSTR pszParam;
} REGOCXDATA, *PREGOCXDATA;

typedef UINT (WINAPI *MYFILEQUEUECALLBACK)( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );                                      


typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


//***************************************************************************
//* MACRO DEFINITIONS                                                       *
//***************************************************************************
#define MsgBox( hWnd, nMsgID, uIcon, uButtons ) \
    MsgBox2Param( hWnd, nMsgID, NULL, NULL, uIcon, uButtons )
#define MsgBox1Param( hWnd, nMsgID, szParam, uIcon, uButtons ) \
    MsgBox2Param( hWnd, nMsgID, szParam, NULL, uIcon, uButtons )
#define ErrorMsg( hWnd, nMsgID ) \
    MsgBox2Param( hWnd, nMsgID, NULL, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg1Param( hWnd, nMsgID, szParam ) \
    MsgBox2Param( hWnd, nMsgID, szParam, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg2Param( hWnd, nMsgID, szParam1, szParam2 ) \
    MsgBox2Param( hWnd, nMsgID, szParam1, szParam2, MB_ICONERROR, MB_OK )


#define ARRAYSIZE(a)    (sizeof(a) / sizeof((a)[0]))
#define SIZEOF(x)       (sizeof(x))

//***************************************************************************
//* string defines                                                          *
//***************************************************************************
#define szNT4XDelayUntilReboot  "System\\CurrentControlSet\\Control\\Session Manager"
#define szNT4XPendingValue      "PendingFileRenameOperations"
#define szNT3XDelayUntilReboot  "System\\CurrentControlSet\\Control\\Session Manager\\FileRenameOperations"

// install OCX
#define achREGSVREXE    " /RegServer"
#define achUNREGSVREXE  " /UnRegServer"
#define achREGSVRDLL    "DllRegisterServer"
#define achUNREGSVRDLL  "DllUnregisterServer"
#define achIEXREG       "IExpressRegOCX%d"
#define achRUNDLL       "rundll32.exe advpack.dll,RegisterOCX %s,%s,%s"
#define RUNONCEEX       "RunOnceEx"
#define RUNONCEEXDATA   "%s|%s"
#define RUNONCE_IERNONCE "rundll32.exe %s,RunOnceExProcess"

#define W95INF32DLL     "W95INF32.DLL"
#define SETUPAPIDLL     "SETUPAPI.DLL"

// INF Install section keys
#define ADVINF_DELDIRS  "DelDirs"
#define ADVINF_CLEANUP  "Cleanup"

#define ADVINF_MODNAME  "ComponentName"
#define ADVINF_ADDREG   "AddReg"
#define ADVINF_DELREG   "DelReg"
#define ADVINF_BKREG    "BackupReg"
#define ADVINF_COPYFILE "CopyFiles"
#define ADVINF_DELFILE  "DelFiles"
#define ADVINF_PREROLBK "PreRollBack"
#define ADVINF_POSTROLBK "PostRollBack"
#define ADVINF_BACKUPPATH  "BackupPath"
#define ADVINF_CHKADMIN    "CheckAdminRights"
#define ADVINF_PERUSER     "PerUserInstall"
#define ADVINF_PU_DSP      "DisplayName"
#define ADVINF_PU_GUID     "GUID"
#define ADVINF_PU_VER      "Version"
#define ADVINF_PU_LANG     "Locale"
#define ADVINF_PU_ISINST    "IsInstalled"
#define ADVINF_PU_STUB      "StubPath"
#define ADVINF_PU_CID       "ComponentID"
#define ADVINF_PU_ROLLBK    "RollbackUninstall"
#define ADVINF_FLAGS        "AdvOptions"
#define ADVINF_MODVER       "ComponentVersion"
#define ADVINF_UPDINFENG    "UpdateINFEngine"
#define ADVINF_NOBACKPLATF  "NoBackupPlatform"
#define ADVINF_CATALOG_NAME "CatalogName"


//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************

// EXPORTED FUNCTIONS


BOOL    WINAPI DllMain( HINSTANCE, DWORD, LPVOID );
HRESULT WINAPI DoInfInstall( ADVPACKARGS * );
DWORD   WINAPI GetInfInstallSectionName( LPCSTR, LPSTR, DWORD );
INT     WINAPI RegisterOCX( HWND, HINSTANCE, PSTR, INT );


// INTERNAL FUNCTIONS

HRESULT       CommonInstallInit( PCSTR, PCSTR, PSTR, DWORD, PCSTR, BOOL, DWORD );
VOID          CommonInstallCleanup( VOID );
HRESULT       CoreInstall( PCSTR, PCSTR, PCSTR, DWORD, DWORD, PCSTR );
HRESULT       RunCommands( PCSTR, PCSTR, PCSTR, DWORD, BOOL );

DWORD         GetTranslatedInt( PCSTR pszInfFilename, PCSTR pszTranslateSection, 
                                PCSTR pszTranslateKey, DWORD dwDefault );
HRESULT       GetTranslatedString( PCSTR, PCSTR, PCSTR, PSTR, DWORD, PDWORD );
HRESULT       GetTranslatedLine( PCSTR, PCSTR, DWORD, PSTR*,  PDWORD );
DWORD         GetTranslatedSection(PCSTR c_pszInfFilename, PCSTR c_pszTranslateSection,
                                   PSTR pszBuffer, DWORD dwBufSize );

BOOL          MyNTReboot( VOID );
PSTR          GetStringField( PSTR*, PCSTR, CHAR, BOOL );
BOOL          IsSeparator( CHAR, PCSTR );
PSTR          StripWhitespace( PSTR );
PSTR          StripQuotes( PSTR );
BOOL          IsGoodAdvancedInfVersion( PCSTR );
BOOL          SelectSetupEngine( PCSTR, PCSTR, DWORD );
INT           BeginPrompt( PCSTR, PCSTR, PSTR, DWORD );
VOID          EndPrompt( PCSTR, PCSTR );
BOOL          MyGetPrivateProfileString( PCSTR, PCSTR, PCSTR, PSTR, DWORD );
BOOL          LoadSetupLib( PCSTR, PCSTR, BOOL, DWORD );
VOID          UnloadSetupLib( VOID );
BOOL          CheckOSVersion( VOID );
INT           MsgBox2Param( HWND, UINT, LPCSTR, LPCSTR, UINT, UINT );
LPSTR         LoadSz( UINT, LPSTR, UINT );
BOOL          UserDirPrompt( LPSTR, LPSTR, LPSTR, ULONG, DWORD );
INT_PTR CALLBACK DirDlgProc( HWND, UINT, WPARAM, LPARAM );
BOOL          BrowseForDir( HWND, LPCSTR, LPSTR );
BOOL          CenterWindow( HWND, HWND );
BOOL          IsGoodDir( LPCSTR );
HRESULT       CtlSetLddPath( UINT, LPSTR, DWORD );
HRESULT       GenInstall(LPSTR, LPSTR, LPSTR);
BOOL          GetValueFromRegistry( LPSTR, UINT, LPSTR, LPSTR, LPSTR );
HRESULT       SetLDIDs( PCSTR, PCSTR, DWORD, PCSTR );
HRESULT       GetDestinationDir( PCSTR, PCSTR, DWORD, DWORD, PSTR, DWORD );
BOOL          DirExists( LPSTR );
DWORD         ParseDestinationLine( PSTR, PSTR, PSTR *, PDWORD, PDWORD, PDWORD, PDWORD );
BOOL          ParseCustomLine( PSTR, PSTR *, PSTR *, PSTR *, PSTR *, PSTR *, BOOL, BOOL );
BOOL          RegisterOCXs( LPSTR, LPSTR, BOOL, BOOL, DWORD);
BOOL          InstallOCX( PREGOCXDATA, BOOL, BOOL, int );
DWORD         FormStrWithoutPlaceHolders( LPCSTR, LPSTR, DWORD, LPCSTR );
DWORD         IsMyKeyExists( LPCSTR, LPCSTR, LPSTR, UINT, LPCSTR );

DWORD         GetWininitSize();
DWORD         GetRegValueSize(LPCSTR lpcszRegKey, LPCSTR lpcszValue);
DWORD         GetNumberOfValues(LPCSTR lpcszRegKey);
DWORD         InternalNeedRebootInit(WORD wOSVer);
BOOL          InternalNeedReboot(DWORD dwRebootCheck, WORD wOSVer);
BOOL          IsEnoughInstSpace( LPSTR szPath, DWORD cbInstNeedSize, LPDWORD pdwPadSize );
LONG          My_atol( LPSTR );
INT           My_atoi( LPSTR );
BOOL          IsFullPath( PCSTR );
//BOOL          GetUNCroot( LPSTR, LPSTR );
DWORD         MyFileSize( PCSTR );
HRESULT       CreateFullPath( PCSTR, BOOL );
HRESULT       LaunchAndWait( LPSTR, LPSTR, HANDLE *, DWORD, DWORD );
DWORD         RO_GetPrivateProfileSection( LPCSTR lpSec, LPSTR lpBuf, DWORD dwSize, LPCSTR lpFile);
HINSTANCE     MyLoadLibrary( LPSTR lpFile );

BOOL        GetThisModulePath( LPSTR lpPath, int size );
BOOL UpdateHelpDlls( LPCSTR *ppszDlls, INT numDlls, LPSTR pszPath, LPSTR pszMsg, DWORD dwFlag);
void        DoCleanup( LPCSTR szInfFilename, LPCSTR szInstallSection );
void        DelDirs( LPCSTR szInfFilename, LPCSTR szInstallSection );
void        MyRemoveDirectory( LPSTR szFolder );
PSTR        FindFileExt( PSTR pszFile );
BOOL        GetFullInfNameAndSrcDir( PCSTR pszInfFilename, PSTR pszFilename, PSTR pszSrcDir );
HRESULT     ProcessFileSections( PCSTR pszSection, PCSTR pszSrcDir, MYFILEQUEUECALLBACK pMyFileQueueCallback );
HRESULT     SaveRestoreInfo( PCSTR pszInf, PCSTR pszSection, PCSTR pszSrcDir, PCSTR pszCatalogs, DWORD dwFlags );
//HRESULT     ExtractFiles(LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
//                         LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);
//BOOL        GetParentDir( LPSTR szFolder );
PSTR        GetNextToken(PSTR *ppszData, CHAR chDeLim);
HRESULT     RegRestoreAllEx( HKEY hkBckupKey );
HRESULT     ProcessAllRegSec( HWND hw, PCSTR pszTitle, PCSTR pszInf, PCSTR pszSection, HKEY hKey, HKEY hCUKey, DWORD dwFlags, BOOL *lpbOneReg );
HRESULT     ProcessAllFiles( HWND hw, PCSTR pszSection, PCSTR pszSrcDir, PCSTR pszBackupPath,
                             PCSTR pszBaseName, PCSTR pszCatalogs, PCSTR pszModule, DWORD dwFlags  );
BOOL        AddEnvInPath( PSTR pszOldPath, PSTR pszNew );
BOOL        GetProgramFilesDir( LPSTR pszPrgfDir, int iSize );
void        SetSysPathsInReg();
HRESULT     ProcessPerUserSec( PCSTR pcszInf, PCSTR pcszSec );
HRESULT     DirSafe(LPCSTR pszDir);
BOOL        GetUniHiveKeyName( HKEY hKey, LPSTR pszRegHiveKey, DWORD dwSize, LPCSTR pszBackupPath );
void        SetPathForRegHiveUse( LPSTR pszPath, DWORD * adwAttr, int iLevels, BOOL bSave );
HRESULT     RunCommandsSections( PCSTR pcszInf, PCSTR pcszSection, PCSTR c_pszKey, PCSTR c_pszSourceDir, DWORD dwFlags, BOOL bNeedReboot );
void GetNextRunOnceExSubKey( HKEY hKey, PSTR pszSubKey, int *piSubKeyNum );
void GetNextRunOnceValName( HKEY hKey, PCSTR pszFormat, PSTR pszValName, int line );
BOOL UseRunOnceEx();
BOOL RemoveBackupBaseOnVer( LPCSTR pszInf, LPCSTR pszSection );
LPSTR GetStringFieldNoQuote( PSTR *ppszString, PCSTR c_pszSeparators, BOOL bStripWhiteSpace);

BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize);
BOOL InitializeSetupAPI();

HRESULT     RunPatchingCommands(PCSTR c_pszInfFilename, PCSTR szInstallSection, PCSTR c_pszSourceDir);

#endif // _ADVPACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\advpack.c ===
//***************************************************************************
//*   Copyright (c) Microsoft Corporation 1995-1996. All rights reserved.   *
//***************************************************************************
//*                                                                         *
//* ADVPACK.C - Advanced helper-dll for WExtract.                           *
//*                                                                         *
//***************************************************************************

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <io.h>
#include <windows.h>
#include <winerror.h>
#include <ole2.h>
#include "resource.h"
#include "cpldebug.h"
#include "ntapi.h"
#include "advpub.h"
#include "w95pub32.h"
#include "advpack.h"
#include "regstr.h"
#include "globals.h"
#include "sfp.h"

//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************
GETSETUPXERRORTEXT32            pfGetSETUPXErrorText32            = NULL;
CTLSETLDDPATH32                 pfCtlSetLddPath32                 = NULL;
GENINSTALL32                    pfGenInstall32                    = NULL;
GENFORMSTRWITHOUTPLACEHOLDERS32 pfGenFormStrWithoutPlaceHolders32 = NULL;

typedef HRESULT (*DLLINSTALL)(BOOL bInstall, LPCWSTR pszCmdLine);

HFONT   g_hFont = NULL;

LPCSTR c_szAdvDlls[3] = { "advpack.dll",
                          "w95inf16.dll",
                          "w95inf32.dll", };

LPCSTR c_szSetupAPIDlls[2] = { "setupapi.dll",
                               "cfgmgr32.dll" };

LPCSTR c_szSetupXDlls[1] = { "setupx.dll" };

#define UPDHLPDLLS_FORCED           0x00000001
#define UPDHLPDLLS_ALERTREBOOT      0x00000002

#define MAX_NUM_DRIVES      26

const CHAR c_szQRunPreSetupCommands[]  = "QRunPreSetupCommands";
const CHAR c_szQRunPostSetupCommands[] = "QRunPostSetupCommands";
const CHAR c_szRunPreSetupCommands[]  = "RunPreSetupCommands";
const CHAR c_szRunPostSetupCommands[] = "RunPostSetupCommands";

BOOL IsDrvChecked( char chDrv );
void SetControlFont();
void SetFontForControl(HWND hwnd, UINT uiID);
void MyGetPlatformSection(LPCSTR lpSec, LPCSTR lpInfFile, LPSTR szNewSection);

//***************************************************************************
//*                                                                         *
//* NAME:       DllMain                                                     *
//*                                                                         *
//* SYNOPSIS:   Main entry point for the DLL.                               *
//*                                                                         *
//* REQUIRES:   hInst:          Handle to the DLL instance.                 *
//*             dwReason:       Reason for calling this entry point.        *
//*             dwReserved:     Nothing                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if DLL loaded OK, FALSE otherwise.     *
//*                                                                         *
//***************************************************************************
BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID dwReserved )
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    // The DLL is being loaded for the first time by a given process.
	    // Perform per-process initialization here.  If the initialization
	    // is successful, return TRUE; if unsuccessful, return FALSE.

    	//Initialize the global variable holding the hinstance:
        g_hInst = hInst;

        // check if need to start the logging file.

        if ( g_hAdvLogFile == INVALID_HANDLE_VALUE)
        {
            AdvStartLogging();
        }
        AdvWriteToLog("-------------------- advpack.dll is loaded or Attached ------------------------------\r\n");
        AdvLogDateAndTime();

	    break;

	case DLL_PROCESS_DETACH:
	    // The DLL is being unloaded by a given process.  Do any
	    // per-process clean up here, such as undoing what was done in
	    // DLL_PROCESS_ATTACH.  The return value is ignored.

        // if logging is turned on, close here.

        AdvWriteToLog("-------------------- advpack.dll is unloaded or Detached ----------------------------\r\n");
        AdvStopLogging();

	    break ;

	case DLL_THREAD_ATTACH:
	    // A thread is being created in a process that has already loaded
	    // this DLL.  Perform any per-thread initialization here.  The
	    // return value is ignored.
	    //Initialize the global variable holding the hinstance --
		//NOTE: this is probably taken care of already by DLL_PROCESS_ATTACH.
	    break;

	case DLL_THREAD_DETACH:
	    // A thread is exiting cleanly in a process that has already
	    // loaded this DLL.  Perform any per-thread clean up here.  The
	    // return value is ignored.
	    break;
    }
    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       DoInfInstall                                                *
//*                                                                         *
//* SYNOPSIS:   Installs an (advanced) INF file on Win95 or WinNT.          *
//*                                                                         *
//* REQUIRES:   AdvPackArgs:    Structure containing required info. See     *
//*                             AdvPack.H.                                  *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successful, FALSE otherwise.        *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI DoInfInstall( ADVPACKARGS *AdvPackArgs )
{
    BOOL    fSavedContext = FALSE;
    HRESULT hr = E_FAIL;
    DWORD   dwFlags;

    AdvWriteToLog("DoInfInstall: InfFile=%1\r\n", AdvPackArgs->lpszInfFilename);
    if (!SaveGlobalContext())
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    fSavedContext = TRUE;

    ctx.hWnd       = AdvPackArgs->hWnd;
    ctx.lpszTitle  = AdvPackArgs->lpszTitle;
    ctx.wOSVer     = AdvPackArgs->wOSVer;
    ctx.wQuietMode = (WORD) (0xFFFF & AdvPackArgs->dwFlags);
    ctx.bCompressed = (AdvPackArgs->dwFlags & ADVFLAGS_COMPRESSED ) ? TRUE : FALSE;
    ctx.bUpdHlpDlls = (AdvPackArgs->dwFlags & ADVFLAGS_UPDHLPDLLS) ? TRUE : FALSE;

    dwFlags = (AdvPackArgs->dwFlags & ADVFLAGS_NGCONV) ? 0 : COREINSTALL_GRPCONV;
    dwFlags |= (AdvPackArgs->dwFlags & ADVFLAGS_DELAYREBOOT) ? COREINSTALL_DELAYREBOOT : 0;
    dwFlags |= (AdvPackArgs->dwFlags & ADVFLAGS_DELAYPOSTCMD) ? COREINSTALL_DELAYPOSTCMD : 0;

    hr = CoreInstall( AdvPackArgs->lpszInfFilename, AdvPackArgs->lpszInstallSection,
                              AdvPackArgs->lpszSourceDir, AdvPackArgs->dwPackInstSize,
                              dwFlags,
                              NULL );
done:
    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    AdvWriteToLog("DoInfInstall: %1 End hr=0x%2!x!\r\n", AdvPackArgs->lpszInfFilename, hr);
    return hr;
}

//***************************************************************************
//*                                                                         *
//* NAME:       LaunchINFSection                                            *
//*                                                                         *
//* SYNOPSIS:   Entry point for RunDLL.  Takes string parameter and parses  *
//*             it, then performs GenInstall.                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
INT WINAPI LaunchINFSection( HWND hwndOwner, HINSTANCE hInstance,
                             PSTR pszParms, INT nShow )
{
    CHAR szTitle[256]          = "Advanced INF Install";
    PSTR  pszInfFilename        = NULL;
    PSTR  pszSection            = NULL;
    PSTR  pszFlags              = NULL;
    PSTR  pszSmartReboot        = NULL;
    DWORD dwFlags               = 0;
    LPSTR pszTemp               = NULL;
    CHAR chTempChar            = '\0';
    CHAR szSourceDir[MAX_PATH];
    CHAR szFilename[MAX_PATH];
    UINT  uiErrid               = 0;
    PSTR  pszErrParm1           = NULL;
    int   iRet                  = 1;  // meaningless return
    BOOL    fSavedContext = FALSE;

    AdvWriteToLog("LaunchINFSection: Param=%1\r\n", pszParms);
    if (!SaveGlobalContext())
    {
        goto done;
    }

    fSavedContext = TRUE;

    ctx.lpszTitle = szTitle;

    // Parse the arguments, the last param to GetStringField to ask what quote char to check
    pszInfFilename = GetStringField( &pszParms, ",", '\"', TRUE );
    pszSection = GetStringField( &pszParms, ",", '\"', TRUE );
    pszFlags = GetStringField( &pszParms, ",", '\"', TRUE );
    pszSmartReboot = GetStringField( &pszParms, ",", '\"', TRUE );

    if ( pszFlags != NULL ) {
        dwFlags = My_atol(pszFlags);
    }

    if ( dwFlags & LIS_QUIET ) {
        ctx.wQuietMode = QUIETMODE_ALL;
    }

    if ( pszInfFilename == NULL || *pszInfFilename == '\0' ) {
        uiErrid = IDS_ERR_BAD_SYNTAX;
        goto done;
    }

    if ( ! GetFullPathName( pszInfFilename, sizeof(szFilename), szFilename, &pszTemp ) )
    {
        uiErrid = IDS_ERR_GET_PATH;
        pszErrParm1 = pszInfFilename;
        goto done;
    }

    if ( GetFileAttributes( szFilename ) == 0xFFFFFFFF ) {
        // If the file doesn't exist in the current directory, check the
        // Windows\inf directory

        if ( !GetWindowsDirectory( szFilename, sizeof( szFilename ) ) )
        {
            uiErrid = IDS_ERR_GET_WIN_DIR;
            goto done;
        }

        AddPath( szFilename, "inf" );
        lstrcpy( szSourceDir, szFilename );

        if ( (lstrlen(szFilename)+lstrlen(pszInfFilename)+2) > MAX_PATH )
        {
            uiErrid = IDS_ERR_CANT_FIND_FILE;
            pszErrParm1 = pszInfFilename;
            goto done;
        }

        AddPath( szFilename, pszInfFilename );

        if ( GetFileAttributes( szFilename ) == 0xFFFFFFFF )
        {
            uiErrid = IDS_ERR_CANT_FIND_FILE;
            pszErrParm1 = pszInfFilename;
            goto done;
        }
    }
    else
    {
        // Generate the source directory from the inf path.
        chTempChar = *pszTemp;
        *pszTemp = '\0';
        lstrcpy( szSourceDir, szFilename );
        *pszTemp = chTempChar;
    }


    if ( !FAILED( CoreInstall( szFilename, pszSection, szSourceDir, 0,
                              COREINSTALL_PROMPT |
                              ((dwFlags & LIS_NOGRPCONV)?0:COREINSTALL_GRPCONV) |
                              COREINSTALL_SMARTREBOOT,
                              pszSmartReboot ) ) )
    {
        if (fSavedContext)
        {
            RestoreGlobalContext();
        }
        AdvWriteToLog("LaunchINFSection: %1 End Succeed\r\n", szFilename);
        return 0;
    }


done:

    if ( uiErrid != 0 )
        ErrorMsg1Param( ctx.hWnd, uiErrid, pszErrParm1 );

    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    AdvWriteToLog("LaunchINFSection: %1 End Failed\r\n", szFilename);
    return 1;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RunSetupCommand                                             *
//*                                                                         *
//* SYNOPSIS:   Download Component entry point.  Runs a setup command.      *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*             szCmdName:      Name of command to run (INF or EXE)         *
//*             szInfSection:   INF section to install with. NULL=default   *
//*             szDir:          Directory containing source files           *
//*             lpszTitle:      Name to attach to windows.                  *
//*             phEXE:          Handle of EXE to wait on.                   *
//*             dwFlags:        Various flags to control behavior (advpub.h)*
//*             pvReserved:     Reserved for future use.                    *
//*                                                                         *
//* RETURNS:    HRESULT:        See advpub.h                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI RunSetupCommand( HWND hWnd, LPCSTR szCmdName,
                                LPCSTR szInfSection, LPCSTR szDir,
                                LPCSTR lpszTitle, HANDLE *phEXE,
                                DWORD dwFlags, LPVOID pvReserved )
{
    HRESULT hReturnCode     = S_OK;
    DWORD   dwRebootCheck   = 0;
    DWORD   dwCoreInstallFlags = 0;
    BOOL    fSavedContext = FALSE;

    AdvWriteToLog("RunSetupCommand:");
    if (!SaveGlobalContext())
    {
        hReturnCode = E_OUTOFMEMORY;
        goto done;
    }

    fSavedContext = TRUE;

    // Validate parameters:

    if ( szCmdName == NULL || szDir == NULL ) {
        return E_INVALIDARG;
    }

    AdvWriteToLog(" Cmd=%1\r\n", szCmdName);
    ctx.hWnd      = hWnd;
    ctx.lpszTitle = (LPSTR) lpszTitle;

    // If caller passes invalid HWND, we will silently turn off UI.
    // NULL uses Desktop as window and passing INVALID_HANDLE sets quiet mode.

    if ( hWnd && !IsWindow(hWnd) ) {
        dwFlags |= RSC_FLAG_QUIET;
        hWnd = NULL;
    }

    if ( dwFlags & RSC_FLAG_QUIET ) {
        ctx.wQuietMode = QUIETMODE_ALL;
    }
    else
    {
        ctx.wQuietMode = 0;
    }

    ctx.bUpdHlpDlls = ( dwFlags & RSC_FLAG_UPDHLPDLLS ) ? TRUE : FALSE;

    // Check flags to see if it's an INF command
    if ( dwFlags & RSC_FLAG_INF )
    {
        if(!(dwFlags & RSC_FLAG_NGCONV))
           dwCoreInstallFlags |= COREINSTALL_GRPCONV;

        if (dwFlags & RSC_FLAG_DELAYREGISTEROCX)
           dwCoreInstallFlags |= COREINSTALL_DELAYREGISTEROCX;

        if (dwFlags & RSC_FLAG_SETUPAPI )
            dwCoreInstallFlags |= COREINSTALL_SETUPAPI;

        hReturnCode = CoreInstall( (PSTR) szCmdName, szInfSection,
                                   (PSTR) szDir, 0, dwCoreInstallFlags,
                                   NULL );

        if ( FAILED( hReturnCode ) ) {
            goto done;
        }
    } else {
        if ( ! CheckOSVersion() ) {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
            goto done;
        }

        dwRebootCheck = InternalNeedRebootInit( ctx.wOSVer );

        hReturnCode = LaunchAndWait( (LPSTR)szCmdName, (LPSTR)szDir, phEXE, INFINITE, 0 );
        if ( hReturnCode == S_OK )
        {
             if ( phEXE )
            hReturnCode = S_ASYNCHRONOUS;
        }
        else
        {
            hReturnCode = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }

        if (    hReturnCode == S_OK
             && InternalNeedReboot( dwRebootCheck, ctx.wOSVer ) )
        {
            hReturnCode = ERROR_SUCCESS_REBOOT_REQUIRED;
        }
    }

  done:

    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    AdvWriteToLog("RunSetupCommand: Cmd=%1 End hr=0x%2!x!\r\n", szCmdName, hReturnCode);
    return hReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetInfInstallSectionName                                    *
//*                                                                         *
//* SYNOPSIS:   Gets the name of the section to install with.               *
//*                                                                         *
//* REQUIRES:   szInfFilename:  Name of INF to find install section in.     *
//*             szInfSection:   Name of INF section to install with.  If    *
//*                             NULL, then return required size of string.  *
//*                             If "\0", use DefaultInstall.  If            *
//*                             "DefaultInstall" and running NT, then check *
//*                             for "DefaultInstall.NT section. Anything    *
//*                             else will leave the section name alone.     *
//*             dwSize:         Size of szInfSection buffer.  If not big    *
//*                             enough to hold string, then required size   *
//*                             is returned.                                *
//*                                                                         *
//* RETURNS:    DWORD:          0 if error, otherwise size of section name. *
//*                                                                         *
//***************************************************************************
DWORD WINAPI GetInfInstallSectionName( LPCSTR pszInfFilename,
                                       LPSTR pszInfSection, DWORD dwSize )
{
    CHAR achTemp[5];
    char szGivenInfSection[MAX_PATH];
    char szNewInfSection[MAX_PATH];
    DWORD dwStringLength;
    DWORD dwRequiredSize;
    static const CHAR achDefaultInstall[]   = "DefaultInstall";
    //static const CHAR achDefaultInstallNT[] = "DefaultInstall.NT";

    // On NTx86:
    //(1) if  [<Sec>.NTx86] present, this section get GenInstall, exit.
    //(2) if (1) is not present, [<sec>.NT] present and get GenInstal, exitl;
    //(3) if both [<sec>.NTx86] and [<Sec>.NT] not present, [<Sec>] section get GenInstall;
    //(4) if none of the sections in (1), (2), (3) exist, do nothing.
    // the same logic apply to NTAlpha as well.
    // On win9x:
    //(1) if [<sec>.Win] present, GetInstall it.
    //(2) if (1) is not present, GenInstall [<Sec>]
    // otherwise, do nothing.

    if ( ! CheckOSVersion() )  {
        return 0;
    }

    // If we were passed a NULL for the install section, then assume
    // they want the "DefaultInstall" section.

    if ( pszInfSection == NULL || (*pszInfSection) == '\0' )
        lstrcpy(szGivenInfSection, achDefaultInstall);
    else
        lstrcpy(szGivenInfSection, pszInfSection);

    MyGetPlatformSection(szGivenInfSection, pszInfFilename, szNewInfSection);

    dwRequiredSize = lstrlen( szNewInfSection ) + 1;
    if ( pszInfSection != NULL && (dwRequiredSize <= dwSize) )
    {
        lstrcpy( pszInfSection, szNewInfSection );
    }

    return dwRequiredSize;
}

//***************************************************************************
//*                                                                         *
//* NAME:       NeedRebootInit                                              *
//*                                                                         *
//* SYNOPSIS:   Self-registers the OCX.                                     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
DWORD WINAPI NeedRebootInit( VOID )
{
    if ( ! CheckOSVersion() ) {
        return 0;
    }

    return InternalNeedRebootInit( ctx.wOSVer );
}


//***************************************************************************
//*                                                                         *
//* NAME:       NeedReboot                                                  *
//*                                                                         *
//* SYNOPSIS:   Self-registers the OCX.                                     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL WINAPI NeedReboot( DWORD dwRebootCheck )
{
    if ( ! CheckOSVersion() ) {
        return 0;
    }

    return InternalNeedReboot( dwRebootCheck, ctx.wOSVer );
}

//***************************************************************************
//*                                                                         *
//* NAME:       TranslateInfString                                          *
//*                                                                         *
//* SYNOPSIS:   Translates a string in an Advanced inf file -- replaces     *
//*             LDIDs with the directory.                                   *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI TranslateInfString( PCSTR pszInfFilename, PCSTR pszInstallSection,
                                   PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                                   PSTR pszBuffer, DWORD dwBufferSize,
                                   PDWORD pdwRequiredSize, PVOID pvReserved )
{
    HRESULT hReturnCode = S_OK;
    CHAR   szRealInstallSection[256];
    BOOL    fSavedContext = FALSE;
    DWORD  dwFlags = 0;

    AdvWriteToLog("TranslateInfString:" );
    if (!SaveGlobalContext())
    {
        hReturnCode = E_OUTOFMEMORY;
        goto done;
    }
    fSavedContext = TRUE;

    ctx.wQuietMode = QUIETMODE_ALL;

    // Validate parameters
    if ( pszInfFilename == NULL  || pszTranslateSection == NULL
         || pszTranslateKey == NULL || pdwRequiredSize == NULL )
    {
        hReturnCode = E_INVALIDARG;
        goto done;
    }

    AdvWriteToLog("Inf=%1 Sec=%2 Key=%3\r\n", pszInfFilename, pszTranslateSection, pszTranslateKey);

    if ((ULONG_PTR)pvReserved & (ULONG_PTR)RSC_FLAG_SETUPAPI )
            dwFlags |= COREINSTALL_SETUPAPI;

    hReturnCode = CommonInstallInit( pszInfFilename, pszInstallSection,
                                     szRealInstallSection, sizeof(szRealInstallSection), NULL, FALSE, dwFlags );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

    hReturnCode = SetLDIDs( (LPSTR) pszInfFilename, szRealInstallSection, 0, NULL );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

    hReturnCode = GetTranslatedString( pszInfFilename, pszTranslateSection, pszTranslateKey,
                                       pszBuffer, dwBufferSize, pdwRequiredSize );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

  done:

    CommonInstallCleanup();
    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    AdvWriteToLog("TranslateInfString: End hr=0x%1!x!\r\n",hReturnCode);
    return hReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RegisterOCX                                                 *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
INT WINAPI RegisterOCX( HWND hwndOwner, HINSTANCE hInstance, PSTR pszParms, INT nShow )
{
    CHAR szTitle[]       = "Advpack RegisterOCX()";
    BOOL  fOleInitialized = TRUE;
    INT   nReturnCode     = 0;
    REGOCXDATA RegOCX = { 0 };

    AdvWriteToLog("RegisterOCX: Param=%1\r\n", pszParms);
    ctx.lpszTitle = szTitle;

    // Parse the arguments, SETUP engine has processed \" so we only need to check on \'
    RegOCX.pszOCX = GetStringField( &pszParms, ",", '\"', TRUE );
    RegOCX.pszSwitch = GetStringField( &pszParms, ",", '\"', TRUE );
    RegOCX.pszParam = GetStringField( &pszParms, ",", '\"', TRUE );

    if ( RegOCX.pszOCX == NULL || *(RegOCX.pszOCX) == '\0' ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_BAD_SYNTAX2 );
        nReturnCode = 1;
        goto done;
    }

    if ( FAILED( OleInitialize( NULL ) ) ) {
        fOleInitialized = FALSE;
    }

    // single OCX register, use 0, 0 for last params
    //
    if ( ! InstallOCX( &RegOCX, TRUE, TRUE, 0 ) ) {
        ErrorMsg1Param( ctx.hWnd, IDS_ERR_REG_OCX, RegOCX.pszOCX );
        nReturnCode = 1;
    }

  done:

    if ( fOleInitialized ) {
        OleUninitialize();
    }
    AdvWriteToLog("RegisterOCX: Param=%1 End status=%2\r\n", RegOCX.pszOCX, (nReturnCode==0)?"Succeed":"Failed");
    return nReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CommonInstallInit                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT CommonInstallInit( PCSTR c_pszInfFilename, PCSTR c_pszSection,
                           PSTR pszRealSection, DWORD dwRealSectionSize,
                           PCSTR c_pszSourceDir, BOOL fUpdDlls, DWORD dwFlags )
{
    HRESULT hReturnCode   = S_OK;
    DWORD   dwSize        = 0;

    if ( ! CheckOSVersion() ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
        goto done;
    }

    if ( ! ctx.fOSSupportsINFInstalls ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_INF_INSTALLS );
        hReturnCode = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
        goto done;
    }

    if ( c_pszSection == NULL ) {
    	*pszRealSection = '\0';
    } else {
        lstrcpy( pszRealSection, c_pszSection );
    }

    dwSize = GetInfInstallSectionName( c_pszInfFilename, pszRealSection, dwRealSectionSize );
    if ( dwSize == 0 || dwSize > dwRealSectionSize ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }


    if ( ! LoadSetupLib( c_pszInfFilename, pszRealSection, fUpdDlls, dwFlags ) ) {
        hReturnCode = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPAPI ) {
        if ( FAILED(hReturnCode = MySetupOpenInfFile( c_pszInfFilename)) )
            goto done;
    }

    if ( c_pszSourceDir != NULL ) {
        hReturnCode = SetLDIDs( c_pszInfFilename, pszRealSection,
                                0, c_pszSourceDir );
        if ( FAILED(hReturnCode) ) {
            goto done;
        }
    }

    if ( ! IsGoodAdvancedInfVersion( c_pszInfFilename ) ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
        goto done;
    }

  done:

    return hReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CommonInstallCleanup                                        *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID CommonInstallCleanup( VOID )
{
    if ( ctx.dwSetupEngine == ENGINE_SETUPAPI ) {
        MySetupCloseInfFile();
    }

    UnloadSetupLib();
}


//***************************************************************************
//*                                                                         *
//* NAME:       CoreInstall                                                 *
//*                                                                         *
//* SYNOPSIS:   Installs an (advanced) INF file on Win95 or WinNT.          *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT CoreInstall( PCSTR c_pszInfFilename, PCSTR c_pszSection,
                     PCSTR c_pszSourceDir, DWORD dwInstallSize, DWORD dwFlags,
                     PCSTR pcszSmartRebootOverride )
{
    static const CHAR c_szSmartReboot[]          = "SmartReboot";
    static const CHAR c_szSmartRebootDefault[]   = "I";
    HRESULT hReturnCode           = S_OK;
    DWORD   dwRebootCheck         = 0;
    BOOL    fNeedReboot           = FALSE;
    HKEY    hkey                  = NULL;
    CHAR   szInstallSection[256];
    CHAR   szTitle[256];
    PSTR    pszOldTitle           = NULL;
    UINT    id                    = IDCANCEL;
    BOOL    fRebootCheck          = TRUE;
    CHAR   szSmartRebootValue[4];      // Allocate 4 chars for SmartReboot value
    BOOL    fRealNeedReboot       = FALSE;
    CHAR   szCatalogName[512]     = "";

#define GRPCONV "grpconv.exe -o"

    AdvWriteToLog("CoreInstall: InfFile=%1 ", c_pszInfFilename);
    lstrcpy( szSmartRebootValue, c_szSmartRebootDefault );

    hReturnCode = CommonInstallInit( c_pszInfFilename, c_pszSection,
                                     szInstallSection, sizeof(szInstallSection),
                                     c_pszSourceDir, TRUE, dwFlags );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }
    AdvWriteToLog("InstallSection=%1\r\n", szInstallSection);
    // check Admin right if INF specified
    if (GetTranslatedInt(c_pszInfFilename, szInstallSection, ADVINF_CHKADMIN, 0))
    {
        if ( (ctx.wOSVer != _OSVER_WIN95) && !IsNTAdmin( 0, NULL) )
        {
            WORD wSav = ctx.wQuietMode;

            ctx.wQuietMode |= QUIETMODE_SHOWMSG;
            hReturnCode = E_ABORT;
            ErrorMsg( ctx.hWnd, IDS_ERR_NONTADMIN );
            ctx.wQuietMode = wSav;
            goto done;
        }
    }

    if ( (dwFlags & COREINSTALL_PROMPT) && !(dwFlags & COREINSTALL_ROLLBACK) )
    {
        pszOldTitle = ctx.lpszTitle;
        if ( BeginPrompt( c_pszInfFilename, szInstallSection, szTitle, sizeof(szTitle) )
             == IDCANCEL )
        {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            goto done;
        }
    }


    if ( !(dwFlags & COREINSTALL_DELAYREBOOT) )
        dwRebootCheck = InternalNeedRebootInit( ctx.wOSVer );

    // the flag is so far used to control the post setup commands, so pre setup command pass flag 0, NeedReboot FALSE
    hReturnCode = RunCommandsSections( c_pszInfFilename, szInstallSection, c_szRunPreSetupCommands, c_pszSourceDir, 0, FALSE );
    if ( FAILED( hReturnCode ) )
        goto done;

    // first set LDID, then all the INF processing can use LDIDs
    hReturnCode = SetLDIDs( (PSTR) c_pszInfFilename, szInstallSection, dwInstallSize, NULL );
    if ( FAILED( hReturnCode ) )
    {
        goto done;
    }

    hReturnCode = RunPatchingCommands( c_pszInfFilename, szInstallSection, c_pszSourceDir);
    if ( FAILED( hReturnCode ) ) 
    {
        goto done;
    }


    // Remove Old backup if needed; based on the ComponentVersion stamp in INF install section
    //
    if (!(dwFlags & COREINSTALL_ROLLBACK) )
        RemoveBackupBaseOnVer( c_pszInfFilename, szInstallSection );

    // get the catalog name, if specified
    // BUGBUG: (pritobla): if not on Millen, where should we copy the catalog for migration scenario?
    ZeroMemory(szCatalogName, sizeof(szCatalogName));

    // if ROLLBKDOALL is specified, try to get the catalog name from the registry;
    // if not found, get it from the inf
    if (dwFlags & COREINSTALL_ROLLBKDOALL)
    {
        CHAR szModule[MAX_PATH];

        *szModule = '\0';
        GetTranslatedString(c_pszInfFilename, szInstallSection, ADVINF_MODNAME, szModule, sizeof(szModule), NULL);
        if (*szModule)
        {
            CHAR szKey[MAX_PATH];
            HKEY hkCatalogKey;

            lstrcpy(szKey, REGKEY_SAVERESTORE);
            AddPath(szKey, szModule);
            AddPath(szKey, REGSUBK_CATALOGS);

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkCatalogKey) == ERROR_SUCCESS)
            {
                PSTR pszCatalog;
                DWORD dwIndex, dwSize;
                DWORD dwSizeSoFar;

                dwSizeSoFar = 0;

                // build the list of catalogs
                pszCatalog = szCatalogName;
                dwIndex = 0;
                dwSize = sizeof(szCatalogName) - 1;
                while (RegEnumValue(hkCatalogKey, dwIndex, pszCatalog, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                {
                    dwSizeSoFar += dwSize + 1;

                    pszCatalog += dwSize + 1;
                    dwIndex++;
                    dwSize = sizeof(szCatalogName) - 1 - dwSizeSoFar;
                }

                RegCloseKey(hkCatalogKey);
            }
       }
    }

    if (*szCatalogName == '\0')
        GetTranslatedString(c_pszInfFilename, szInstallSection, ADVINF_CATALOG_NAME, szCatalogName, sizeof(szCatalogName), NULL);

    if (*szCatalogName)
    {
        // load sfc.dll and the relevant proc's
        if (!LoadSfcDLL())
        {
            // couldn't load -- so empty out CatalogName
            *szCatalogName = '\0';
        }
    }

    // before we start doing any work, we need to know if this is backup install mode.  If it is,
    // we will have to backup the Reg data and file data before continuing.
    if ( (dwFlags & COREINSTALL_BKINSTALL) || ( dwFlags & COREINSTALL_ROLLBACK ) )
    {
        // if it is rollback case, we don't need to do real GenInstall.  We need to unregister the previous
        // register section first
        //
        if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            RegisterOCXs( (PSTR) c_pszInfFilename, szInstallSection, FALSE, FALSE, dwFlags );
        }

        hReturnCode = SaveRestoreInfo( c_pszInfFilename, szInstallSection, c_pszSourceDir, szCatalogName, dwFlags );
        if ( FAILED( hReturnCode ) )
            goto done;

        // if it is rollback case, we don't need to do real GenInstall.  All needed are registering OCXs
        if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            // here is very tricky, if the reboot needed and old file can not be registerred,
            // if we just add entries blindly to the RunOnce(ex), it will cause the fault at reboot
            // time.  So we have to make sure if we need to do this re-register thing or just use
            // DelReg and AddReg take care it.  Need revisit here!!!
            //
            fRealNeedReboot = InternalNeedReboot( dwRebootCheck, ctx.wOSVer );
            RegisterOCXs( (PSTR) c_pszInfFilename, szInstallSection, fRealNeedReboot, TRUE, dwFlags );
            if ( fRealNeedReboot )
            {
                hReturnCode = ERROR_SUCCESS_REBOOT_REQUIRED;
            }
            // process DelDirs INF line
            DelDirs( c_pszInfFilename, szInstallSection );
            goto done;
        }
    }

    // No error handling because it's an uninstall.  If unregistering fails, we
    // should continue with the uninstall.

    // BUGBUG: if it is COREINSTALL_BKINSTALL case, do we need to unregister the Existing OCXs
    // get ready for registering the new once. Maybe have foll. call do it based on flags
    //
    if ( ctx.wOSVer != _OSVER_WINNT3X )
        RegisterOCXs( (PSTR) c_pszInfFilename, szInstallSection, FALSE, FALSE, dwFlags );

    // if a catalog is specified, try to install it before calling GenInstall()
    if (*szCatalogName)
    {
        DWORD dwRet;
        CHAR szFullCatalogName[MAX_PATH];

        lstrcpy(szFullCatalogName, c_pszSourceDir);
        AddPath(szFullCatalogName, szCatalogName);

        dwRet = g_pfSfpInstallCatalog(szFullCatalogName, NULL);
        AdvWriteToLog("CoreInstall: SfpInstallCatalog returned=%1!lu!\r\n", dwRet);

        UnloadSfcDLL();

        if (dwRet != ERROR_SUCCESS  &&  dwRet != ERROR_FILE_NOT_FOUND)
        {
            // if SfpInstallCatalog return already an HRESULT, use it.
            // otherwise convert to na HRESULT.
            if (dwRet & 0x80000000)
                hReturnCode = dwRet;
            else
                hReturnCode = HRESULT_FROM_WIN32(dwRet);
            goto done;
        }

        if (dwRet == ERROR_FILE_NOT_FOUND)
            *szCatalogName = '\0';
    }

    AdvWriteToLog("GenInstall: Sec=%1\r\n", szInstallSection);
    hReturnCode = GenInstall( (PSTR) c_pszInfFilename, szInstallSection, (PSTR) c_pszSourceDir );
    AdvWriteToLog("GenInstall return: Sec=%1 hr=0x%2!x!\r\n", szInstallSection, hReturnCode);
    if ( FAILED( hReturnCode ) )
        goto done;

    fRealNeedReboot = InternalNeedReboot( dwRebootCheck, ctx.wOSVer );
    fNeedReboot = fRealNeedReboot;

    // Process SmartReboot key
    if ( dwFlags & COREINSTALL_SMARTREBOOT )
    {
        if ( pcszSmartRebootOverride != NULL && *pcszSmartRebootOverride != '\0' )
        {
            lstrcpy( szSmartRebootValue, pcszSmartRebootOverride );
        }
        else
        {
             if ( FAILED( GetTranslatedString( c_pszInfFilename, szInstallSection, c_szSmartReboot,
                                               szSmartRebootValue, sizeof(szSmartRebootValue), NULL) ) )
             {
                lstrcpy( szSmartRebootValue, c_szSmartRebootDefault );
             }
        }

        switch ( szSmartRebootValue[0] )
        {
            case 'a':
            case 'A':
                fNeedReboot = TRUE;
                break;

            case 'N':
            case 'n':
                fNeedReboot = FALSE;
                break;

            case '\0':
                lstrcpy( szSmartRebootValue, c_szSmartRebootDefault );
                break;
       }
    }

    if ( ctx.wOSVer != _OSVER_WINNT3X )
    {
        if ( ! RegisterOCXs( (PSTR) c_pszInfFilename, szInstallSection, (fNeedReboot || fRealNeedReboot), TRUE, dwFlags ) )
        {
            hReturnCode = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }
    }

    // The reason we pass in the reboot flag is to be consistent with register OCX
    hReturnCode = RunCommandsSections( c_pszInfFilename, szInstallSection, c_szRunPostSetupCommands, c_pszSourceDir, dwFlags, (fNeedReboot || fRealNeedReboot) );
    if ( FAILED( hReturnCode ) )
       goto done;

    // process PerUserInstall section
    hReturnCode = ProcessPerUserSec( c_pszInfFilename, szInstallSection );
    if ( FAILED( hReturnCode ) )
       goto done;

    // if /R:P is passed in, check absolute reboot condition rather than delta
    if ( (dwFlags & COREINSTALL_DELAYPOSTCMD) || (hReturnCode == ERROR_SUCCESS_REBOOT_REQUIRED) )
        dwRebootCheck = 0;

    // Do we need a reboot now?  Lets find out...
    fRealNeedReboot = InternalNeedReboot( dwRebootCheck, ctx.wOSVer );
    if (GetTranslatedInt(c_pszInfFilename, szInstallSection, "Reboot", 0))
    {
        fRealNeedReboot = TRUE;
    }

    if ( fRealNeedReboot )
    {
        hReturnCode = ERROR_SUCCESS_REBOOT_REQUIRED;
    }

    // Process SmartReboot key
    if ( szSmartRebootValue[0] == 'i' || szSmartRebootValue[0] == 'I' )
    {
        fNeedReboot = fRealNeedReboot;
    }

    if ( ctx.wOSVer != _OSVER_WINNT3X )
    {
        if ( NeedToRunGrpconv() )
        {
            if ( (dwFlags & COREINSTALL_GRPCONV) && !fNeedReboot && !fRealNeedReboot )
            {
                char   szDir[MAX_PATH];

                GetWindowsDirectory( szDir, sizeof(szDir) );
                // only wait this unmoral member 30 secs
                LaunchAndWait( GRPCONV, szDir, NULL, 30000, (ctx.wQuietMode & QUIETMODE_ALL)? RUNCMDS_QUIET : 0 );
            }
            else
            {
                if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, 0, NULL,
                                    REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, NULL) == ERROR_SUCCESS )
                {
                    RegSetValueEx( hkey, "GrpConv", 0, REG_SZ, (LPBYTE) GRPCONV, lstrlen(GRPCONV) + 1 );
                    RegCloseKey(hkey);
                }
            }
        }
    }

    // process DelDirs INF line
    DelDirs( c_pszInfFilename, szInstallSection );

    if ( dwFlags & COREINSTALL_PROMPT ) {
    	EndPrompt( c_pszInfFilename, szInstallSection );
    }

    // process Cleanup INF line
    DoCleanup( c_pszInfFilename, szInstallSection );

    if ( fNeedReboot && (dwFlags & COREINSTALL_SMARTREBOOT) )
    {
        if ( szSmartRebootValue[1] == 's' || szSmartRebootValue[1] == 'S' )
        {
            id = IDYES;
        }
        else
        {
            id = MsgBox( ctx.hWnd, IDS_RESTARTYESNO, MB_ICONINFORMATION, MB_YESNO );
        }

        if ( id == IDYES )
        {
            if ( ctx.wOSVer == _OSVER_WIN95 )
            {
                // By default (all platforms), we assume powerdown is possible
                id = ExitWindowsEx( EWX_REBOOT, 0 );
            }
            else
            {
                MyNTReboot();
            }
        }
    }

  done:

    if ( dwFlags & COREINSTALL_PROMPT ) {
        ctx.lpszTitle = pszOldTitle;
    }

    if (*szCatalogName)
        UnloadSfcDLL();

    CommonInstallCleanup();

    AdvWriteToLog("CoreInstall: End InfFile=%1 hr=0x%2!x!\r\n", c_pszInfFilename, hReturnCode);
    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RunCommandsSections                                         *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT RunCommandsSections( PCSTR pcszInf, PCSTR pcszSection, PCSTR c_pszKey,
                             PCSTR c_pszSourceDir, DWORD dwFlags, BOOL bNeedReboot )
{
    HRESULT hRet = S_OK;
    char szBuf[MAX_INFLINE];
    LPSTR pszOneSec, pszStr, pszFlag;
    DWORD dwCmdsFlags;

    szBuf[0] = 0;
    pszStr = szBuf;

    if ( FAILED(GetTranslatedString( pcszInf, pcszSection, c_pszKey, szBuf, sizeof(szBuf), NULL)))
        szBuf[0] = 0;

    // Parse the arguments, SETUP engine is not called to process this line.  So we check on \".
    pszOneSec = GetStringField( &pszStr, ",", '\"', TRUE );
    while ( (hRet == S_OK) && pszOneSec && *pszOneSec )
    {
        dwCmdsFlags  = 0;
        pszFlag = ANSIStrChr( pszOneSec, ':' );
        if ( pszFlag && (*pszFlag == ':') )
        {
            pszFlag = CharNext(pszFlag);
            *CharPrev(pszOneSec, pszFlag) = '\0';
            dwCmdsFlags = AtoL(pszFlag);
        }

        if ( (dwFlags & COREINSTALL_DELAYPOSTCMD) &&
             (!lstrcmpi(c_pszKey, c_szRunPostSetupCommands)) )
        {
            dwCmdsFlags |= RUNCMDS_DELAYPOSTCMD;
        }

        hRet = RunCommands( pcszInf, pszOneSec, c_pszSourceDir, dwCmdsFlags, bNeedReboot );

        pszOneSec = GetStringField( &pszStr, ",", '\"', TRUE );
    }

    return hRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RunCommands                                                 *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT RunCommands( PCSTR pcszInfFilename, PCSTR pcszSection, PCSTR c_pszSourceDir,
                     DWORD dwCmdsFlags, BOOL bNeedReboot )
{
    HRESULT hReturnCode = S_OK;
    DWORD i = 0;
    PSTR pszCommand = NULL, pszNewCommand;
    CHAR szMessage[BIG_STRING];

    AdvWriteToLog("RunCommands: Sec=%1\r\n", pcszSection);
    pszNewCommand = (LPSTR) LocalAlloc( LPTR, BUF_1K );
    if ( !pszNewCommand )
    {
        hReturnCode = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    for ( i = 0; ; i += 1 )
    {
        if ( FAILED( GetTranslatedLine( pcszInfFilename, pcszSection,
                                        i, &pszCommand, NULL ) ) || !pszCommand )
        {
            break;
        }

        // check if this command need to be delayed
        // if there is reboot condition regardless who cause it, delay.
        if ( (dwCmdsFlags & RUNCMDS_DELAYPOSTCMD) &&
             (InternalNeedReboot( 0, ctx.wOSVer ) || bNeedReboot ) )
        {
            static int iSubKeyNum = 989;
            static int iLine = 0;
            static BOOL  bRunOnceEx = FALSE;
            HKEY hKey, hSubKey;
            LPSTR lpRegTmp;

            if ( iSubKeyNum == 989 )
            {
                if ( UseRunOnceEx() )
                {
                    bRunOnceEx = TRUE;
                }
            }

            // decide to add the entry to RunOnce or RunOnceEx
            if ( !bRunOnceEx )
            {
                // no ierunonce.dll, use RunOnce key rather than RunOnceEx key
                lpRegTmp = REGSTR_PATH_RUNONCE;
            }
            else
            {
                lpRegTmp = REGSTR_PATH_RUNONCEEX;
            }

            // open RunOnce or RunOnceEx key here
            if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, lpRegTmp, (ULONG)0, NULL,
                                 REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL,
                                 &hKey, NULL ) == ERROR_SUCCESS )
            {
                // SubKey "990" is the one used in one GenInstall section to
                // store all the delayed post cmds.
                if ( bRunOnceEx )
                {
                    if ( iSubKeyNum == 989 )
                        GetNextRunOnceExSubKey( hKey, szMessage, &iSubKeyNum );
                    else
                        wsprintf( szMessage, "%d", iSubKeyNum );

                    // Generate the Value Name and ValueData.
                    //
                    if ( RegCreateKeyEx( hKey, szMessage, (ULONG)0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                         NULL, &hSubKey, NULL ) == ERROR_SUCCESS )
                    {
                        GetNextRunOnceValName( hSubKey, "%03d", szMessage, iLine++ );
                        RegSetValueEx( hSubKey, szMessage, 0, REG_SZ, (LPBYTE)pszCommand, lstrlen(pszCommand)+1 );
                        AdvWriteToLog("RunOnceEx Entry: %1\r\n", pszCommand);
                        RegCloseKey( hSubKey );
                    }
                }
                else
                {
                    GetNextRunOnceValName( hKey, achIEXREG, szMessage, iLine++ );
                    RegSetValueEx( hKey, szMessage, 0, REG_SZ, (LPBYTE)pszCommand, lstrlen(pszCommand)+1 );
                    AdvWriteToLog("RunOnce Entry: %1\r\n", pszCommand);
                }

                RegCloseKey( hKey );

                // if we delay the commands, should trig the reboot.
                hReturnCode = ERROR_SUCCESS_REBOOT_REQUIRED;
            }
        }
        else
        {
            if ( ! IsFullPath( pszCommand ) )
            {
                lstrcpy( pszNewCommand, c_pszSourceDir );
                AddPath( pszNewCommand, pszCommand );
            }

            if ( ( *pszNewCommand == 0 ) ||
                 ( LaunchAndWait( pszNewCommand, NULL, NULL, INFINITE, dwCmdsFlags ) == E_FAIL ) )
            {
                if ( LaunchAndWait( pszCommand, NULL, NULL, INFINITE, dwCmdsFlags ) == E_FAIL )
                {
                    hReturnCode = HRESULT_FROM_WIN32(GetLastError());
                    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                    szMessage, sizeof(szMessage), NULL );
                    ErrorMsg2Param( ctx.hWnd, IDS_ERR_CREATE_PROCESS, pszCommand, szMessage );
                    break;
                }
            }
        }


        // release the buffer allocated by GetTranslatedLine
        LocalFree( pszCommand );
        pszCommand = NULL;
        *pszNewCommand = 0;
    }

    // release the local buffer
    if ( pszNewCommand )
        LocalFree( pszNewCommand );

    // release the buffer allocated by GetTranslatedLine
    if ( pszCommand )
        LocalFree( pszCommand );

  done:
    AdvWriteToLog("RunCommands: Sec=%1 End hr=0x%2!x!\r\n", pcszSection, hReturnCode);
    return hReturnCode;
}
//***************************************************************************
//*                                                                         *
//* NAME:       GetTranslatedInt                                         *
//*                                                                         *
//* SYNOPSIS:   Translates a string in an INF file.                         *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
DWORD GetTranslatedInt( PCSTR pszInfFilename, PCSTR pszTranslateSection,
                        PCSTR pszTranslateKey, DWORD dwDefault )
{
    CHAR    szBuf[100];
    //BOOL    bLocalInitSetupapi = FALSE;
	BOOL	bLocalAssignSetupEng = FALSE;
    DWORD   dwResult, dwRequiredSize;
    DWORD   dwSaveSetupEngine;

    dwResult = dwDefault;
    // since we are no using GetPrivateProfileString anymore if setupapi present
    // there are times this function called and setupapi.dll is not loaded yet.
    // so we need to check on in and initalize it if it is necessary
    if (ctx.hSetupLibrary==NULL)
    {
        if (CheckOSVersion() && (ctx.wOSVer != _OSVER_WIN95))
        {
            //dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPAPI;
            //bLocalAssignSetupEng = TRUE;
            if (InitializeSetupAPI())
            {
				// To avoid multiple times load and unload the NT setupapi DLLs
				// On NT, we are not unload the setuplib unless the INF engine need to be
				// updated.
				//
                if (FAILED(MySetupOpenInfFile(pszInfFilename)))
                {
                    // UnloadSetupLib();
                    goto done;
                }
                //bLocalInitSetupapi = TRUE;
            }
            else
            {
                goto done;
            }
        }
        else
        {
            // if setupx lib is not initialized yet, just use GetPrivateProfileString
            dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPX;
            bLocalAssignSetupEng = TRUE;

        }
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        dwResult = (DWORD)GetPrivateProfileInt(pszTranslateSection, pszTranslateKey, dwDefault, pszInfFilename);
    }
    else
    {
        szBuf[0] = '\0';
        if ( FAILED(MySetupGetLineText( pszTranslateSection, pszTranslateKey, szBuf,
                                          sizeof(szBuf), &dwRequiredSize )))
        {
            goto done;
        }
        // convert the string to DWORD
        if (szBuf[0] != '\0')
            dwResult = (DWORD)AtoL(szBuf);
        else
            dwResult = dwDefault;
    }

done:
    //if (bLocalInitSetupapi)
    //{
        // uninitialize setupapi
        //CommonInstallCleanup();
    //}

    if (bLocalAssignSetupEng)
        ctx.dwSetupEngine = dwSaveSetupEngine;

    return dwResult;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetTranslatedString                                         *
//*                                                                         *
//* SYNOPSIS:   Translates a string in an INF file.                         *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT GetTranslatedString( PCSTR pszInfFilename, PCSTR pszTranslateSection,
                             PCSTR pszTranslateKey, PSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize )
{
    HRESULT hReturnCode = S_OK;
    PSTR    pszPreTranslated = NULL;
    PSTR    pszPostTranslated = NULL;
    DWORD   dwSizePreTranslated = 2048;
    DWORD   dwSizePostTranslated = 4096;
    DWORD   dwRequiredSize = 0;
    //BOOL    bLocalInitSetupapi = FALSE;
	BOOL	bLocalAssignSetupEng = FALSE;
    DWORD   dwSaveSetupEngine;

    // since we are no using GetPrivateProfileString anymore if setupapi present
    // there are times this function called and setupapi.dll is not loaded yet.
    // so we need to check on in and initalize it if it is necessary
    if (ctx.hSetupLibrary==NULL)
    {
        if (CheckOSVersion() && (ctx.wOSVer != _OSVER_WIN95))
        {
  			// To avoid multiple times load and unload the NT setupapi DLLs
			// On NT, we are not unload the setuplib unless the INF engine need to be
			// updated.
			//
	        //dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPAPI;
            //bLocalAssignSetupEng = TRUE;
            if (InitializeSetupAPI())
            {
                hReturnCode = MySetupOpenInfFile(pszInfFilename);
                if (FAILED(hReturnCode))
                {
                    //UnloadSetupLib();
                    goto done;
                }
                //bLocalInitSetupapi = TRUE;
            }
            else
            {
                hReturnCode = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
                goto done;
            }
        }
        else
        {
            // if setupx lib is not initialized yet, just use GetPrivateProfileString
            dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPX;
            bLocalAssignSetupEng = TRUE;
        }
    }

    // NOTE: There should never be a value in an INF greater than 2k
    //       and translated strings shouldn't exceed 4k.

    pszPreTranslated = (PSTR) LocalAlloc( LPTR, dwSizePreTranslated );
    pszPostTranslated = (PSTR) LocalAlloc( LPTR, dwSizePostTranslated );

    if ( ! pszPreTranslated || ! pszPostTranslated ) {
        hReturnCode = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX ) {
        if ( ! MyGetPrivateProfileString( pszInfFilename, pszTranslateSection, pszTranslateKey,
                                          pszPreTranslated, dwSizePreTranslated ) )
        {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto done;
        }

        if ( ctx.hSetupLibrary )
        {
             if (!pfGenFormStrWithoutPlaceHolders32( pszPostTranslated, pszPreTranslated,
                                                 (LPSTR) pszInfFilename ) )
             {
                 hReturnCode = E_UNEXPECTED;
                 goto done;
             }
        }
        else
            FormStrWithoutPlaceHolders( pszPreTranslated, pszPostTranslated, dwSizePostTranslated, pszInfFilename );

        dwRequiredSize = lstrlen( pszPostTranslated ) + 1;
    }
    else
    {
        hReturnCode = MySetupGetLineText( pszTranslateSection, pszTranslateKey, pszPostTranslated,
                                          dwSizePostTranslated, &dwRequiredSize );

        if (FAILED(hReturnCode) && HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hReturnCode) 
        {
            // resize buffer and retry.
            LocalFree(pszPostTranslated);
            pszPostTranslated = LocalAlloc(LPTR, dwRequiredSize);
            dwSizePostTranslated = dwRequiredSize;
            if ( !pszPostTranslated ) {
                hReturnCode = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }

            hReturnCode = MySetupGetLineText( pszTranslateSection, pszTranslateKey,
                                             pszPostTranslated, dwSizePostTranslated,
                                             &dwRequiredSize );
        }

        if ( FAILED(hReturnCode) )
        {
            goto done;
        }
    }

    if ( pszBuffer == NULL ) {
        hReturnCode = S_OK;
        goto done;
    }

    if ( dwRequiredSize > dwBufferSize ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }

    lstrcpy( pszBuffer, pszPostTranslated );

done:
    //if (bLocalInitSetupapi)
    //{
        // uninitialize setupapi
        //CommonInstallCleanup();
    //}

    if (bLocalAssignSetupEng)
        ctx.dwSetupEngine = dwSaveSetupEngine;

    if ( pdwRequiredSize ) {
        *pdwRequiredSize = dwRequiredSize;
    }

    if ( pszPreTranslated != NULL ) {
        LocalFree( pszPreTranslated );
    }

    if ( pszPostTranslated != NULL ) {
        LocalFree( pszPostTranslated );
    }

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetTranslatedLine                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT GetTranslatedLine( PCSTR c_pszInfFilename, PCSTR c_pszTranslateSection,
                           DWORD dwIndex, PSTR *ppszBuffer, PDWORD pdwRequiredSize )
{
    HRESULT hReturnCode      = S_OK;
    PSTR    pszPreTranslated = NULL;
    PSTR    pszPostTranslated = NULL;
    DWORD   dwPreTranslatedSize = 8192;
    DWORD   dwPostTranslatedSize = 4096;
    DWORD   dwRequiredSize = 0;
    DWORD   i             = 0;
    PSTR    pszPoint       = NULL;
    //BOOL    bLocalInitSetupapi = FALSE;
	BOOL	bLocalAssignSetupEng = FALSE;
    DWORD   dwSaveSetupEngine;

    // since we are no using GetPrivateProfileString anymore if setupapi present
    // there are times this function called and setupapi.dll is not loaded yet.
    // so we need to check on in and initalize it if it is necessary
    if (ctx.hSetupLibrary==NULL)
    {
        if (CheckOSVersion() && (ctx.wOSVer != _OSVER_WIN95))
        {
			// To avoid multiple times load and unload the NT setupapi DLLs
			// On NT, we are not unload the setuplib unless the INF engine need to be
			// updated.
			//

            //dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPAPI;
            //bLocalAssignSetupEng = TRUE;
            if (InitializeSetupAPI())
            {
                hReturnCode = MySetupOpenInfFile(c_pszInfFilename);
                if (FAILED(hReturnCode))
                {
                    //UnloadSetupLib();
                    goto done;
                }
                //bLocalInitSetupapi = TRUE;
            }
            else
            {
                hReturnCode = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
                goto done;
            }
        }
        else
        {
            // if setupx lib is not initialized yet, just use GetPrivateProfileString
            dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPX;
            bLocalAssignSetupEng = TRUE;
        }
    }

    // initial to NULL in the case of error, otherwise
    if ( ppszBuffer )
        *ppszBuffer = NULL;

    pszPreTranslated = (PSTR) LocalAlloc( LPTR, dwPreTranslatedSize );
    pszPostTranslated = (PSTR) LocalAlloc( LPTR, dwPostTranslatedSize );

    if ( !pszPreTranslated || !pszPostTranslated ) {
        hReturnCode = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        // BUGBUG:  Should automagically change buffer size until we get a big
        // enough buffer to hold the full section.

        // BUGBUG:  For setupx engine, we don't support the multiple-inf line reading for the new
        // advance INF options.  In most case, there is no need for that.  If really need, set
        // RequireEngine=SETUPAPI,"string"

        dwRequiredSize = RO_GetPrivateProfileSection( c_pszTranslateSection, pszPreTranslated,
                                                      dwPreTranslatedSize, c_pszInfFilename );

        if ( dwRequiredSize == dwPreTranslatedSize - 2 ) {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, c_pszTranslateSection );
            hReturnCode = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto done;
        }

        pszPoint = pszPreTranslated;

        while ( *pszPoint == ';' ) {
            pszPoint += lstrlen(pszPoint) + 1;
        }

        for ( i = 0; i < dwIndex; i += 1 ) {
            pszPoint += lstrlen(pszPoint) + 1;

            if ( *pszPoint == '\0' ) {
                hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
                goto done;
            }

            while ( *pszPoint == ';' ) {
                pszPoint += lstrlen(pszPoint) + 1;
            }
        }

        if ( *pszPoint == '\0' ) {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }

        if ( ctx.hSetupLibrary )
        {
            if ( ! pfGenFormStrWithoutPlaceHolders32( pszPostTranslated, pszPoint,
                                                      (PSTR) c_pszInfFilename ) )
            {
                hReturnCode = E_UNEXPECTED;
                goto done;
            }
        }
        else
            FormStrWithoutPlaceHolders( pszPoint, pszPostTranslated, dwPostTranslatedSize, (PSTR) c_pszInfFilename );

        // strip out the double quotes
        pszPoint = pszPostTranslated;
        pszPostTranslated = GetStringField( &pszPoint, "\0", '\"', TRUE );
        dwRequiredSize = lstrlen( pszPostTranslated ) + 1;
    }
    else
    {
        hReturnCode = MySetupGetLineByIndex( c_pszTranslateSection, dwIndex,
                                             pszPostTranslated, dwPostTranslatedSize,
                                             &dwRequiredSize );
        
        if (FAILED(hReturnCode) && HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hReturnCode)
        {
            // resize buffer and retry.
            LocalFree(pszPostTranslated);
            pszPostTranslated = LocalAlloc(LPTR, dwRequiredSize);
            dwPostTranslatedSize = dwRequiredSize;
            if ( !pszPostTranslated ) {
                hReturnCode = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }

            hReturnCode = MySetupGetLineByIndex( c_pszTranslateSection, dwIndex,
                                             pszPostTranslated, dwPostTranslatedSize,
                                             &dwRequiredSize );
        }

        if ( FAILED(hReturnCode) ) {
            goto done;
        }
    }

    // if NULL, return only size
    //
    if ( !ppszBuffer )
    {
        LocalFree( pszPostTranslated );
    }
    else
    {
        // this buffer has to be released by the caller!!
        //
        *ppszBuffer = (LPSTR)LocalReAlloc( pszPostTranslated, (lstrlen(pszPostTranslated)+1), LMEM_MOVEABLE );
        if ( !*ppszBuffer )
            *ppszBuffer = pszPostTranslated;
    }

done:
    //if (bLocalInitSetupapi)
    //{
        // uninitialize setupapi
        //CommonInstallCleanup();
    //}

    if (bLocalAssignSetupEng)
        ctx.dwSetupEngine = dwSaveSetupEngine;

    if ( pdwRequiredSize ) {
        *pdwRequiredSize = dwRequiredSize;
    }

    if ( pszPreTranslated != NULL ) {
        LocalFree( pszPreTranslated );
    }

    if ( FAILED(hReturnCode) && (pszPostTranslated != NULL) )
    {
        if (ppszBuffer)
            *ppszBuffer = NULL;
        LocalFree( pszPostTranslated );
    }

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetTranslatedSection                                        *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
DWORD GetTranslatedSection(PCSTR c_pszInfFilename, PCSTR c_pszTranslateSection,
                               PSTR pszBuffer, DWORD dwBufSize )
{
    CHAR    szPreTranslated[MAX_INFLINE];
    DWORD   dwSize = 0;
    //BOOL    bLocalInitSetupapi = FALSE,
	BOOL	bLocalAssignSetupEng = FALSE;
    DWORD   dwSaveSetupEngine;

    // since we are no using GetPrivateProfileString anymore if setupapi present
    // there are times this function called and setupapi.dll is not loaded yet.
    // so we need to check on in and initalize it if it is necessary
    if (ctx.hSetupLibrary==NULL)
    {
        if (CheckOSVersion() && (ctx.wOSVer != _OSVER_WIN95))
        {
			// To avoid multiple times load and unload the NT setupapi DLLs
			// On NT, we are not unload the setuplib unless the INF engine need to be
			// updated.
			//

            //dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPAPI;
            //bLocalAssignSetupEng = TRUE;
            if (InitializeSetupAPI())
            {
                if (FAILED(MySetupOpenInfFile(c_pszInfFilename)))
                {
                    //UnloadSetupLib();
                    goto done;
                }
                //bLocalInitSetupapi = TRUE;
            }
            else
            {
                goto done;
            }
        }
        else
        {
            // if setupx lib is not initialized yet, just use GetPrivateProfileString
            dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPX;
            bLocalAssignSetupEng = TRUE;
        }
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        dwSize = RO_GetPrivateProfileSection( c_pszTranslateSection, pszBuffer,
                                              dwBufSize, c_pszInfFilename );

        if ( dwSize == dwBufSize - 2 )
        {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, c_pszTranslateSection );
            goto done;
        }
    }
    else
    {
        int i, len;
        LPSTR pszTmp, pszStart;
        DWORD dwReqSize;
        char szBuf[MAX_INFLINE];

        pszStart = pszBuffer;
        *pszStart = '\0';

        for (i=0; ; i++)
        {
            // if key does not contain ',', setupapi's SetupGetLineText only return the value part
            // we need to get the corespondent key part to makeup the whole line text
            dwReqSize = 0;
            if (SUCCEEDED(MySetupGetStringField(c_pszTranslateSection, i, 0, szBuf,
                                                sizeof(szBuf), &dwReqSize)) && dwReqSize)
            {
                dwReqSize = 0;
                if ( SUCCEEDED(MySetupGetLineText( c_pszTranslateSection, szBuf, szPreTranslated,
                                                sizeof(szPreTranslated), &dwReqSize )) && dwReqSize)
                {
                    // got the key, so the line must be in the form A=B  or Just A forms, no comma.
                    lstrcat(szBuf, "=");
                    lstrcat(szBuf, szPreTranslated);
                }
            }
            else
            {
                // expect the line in the forms of A,B,C=B  or just A,B,C
                if ( FAILED(MySetupGetLineByIndex(c_pszTranslateSection, i,
                                                   szPreTranslated, sizeof(szPreTranslated),
                                                   &dwReqSize )))
                {
                    // should not be here since you are here, the line must have commas or no '='
                    break;
                }

                lstrcpy(szBuf, szPreTranslated);
            }

            len = lstrlen(szBuf)+1;
            if ((dwSize + len) < dwBufSize)
            {
                lstrcpy(pszStart, szBuf);
                pszStart += len;
                dwSize += len;
            }
            else
            {
                dwSize = dwBufSize - 2;
                break;
            }
        }

        if (pszStart > pszBuffer)
            *pszStart = '\0';
        else if (pszStart == pszBuffer)
            *(pszStart+1) = '\0';
    }

done:
    //if (bLocalInitSetupapi)
    //{
        // uninitialize setupapi
        //CommonInstallCleanup();
    //}

    if (bLocalAssignSetupEng)
        ctx.dwSetupEngine = dwSaveSetupEngine;

    return dwSize;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MyNTReboot                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL MyNTReboot( VOID )
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;

    // get a token from this process
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
    {
        ErrorMsg( NULL, IDS_ERR_OPENPROCTK );
        return FALSE;
    }

    // get the LUID for the shutdown privilege
    LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //get the shutdown privilege for this proces
    if ( !AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 ) )
    {
        ErrorMsg( NULL, IDS_ERR_ADJTKPRIV );
        return FALSE;
    }

    // shutdown the system and force all applications to close
    if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        ErrorMsg( NULL, IDS_ERR_EXITWINEX );
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetStringField                                              *
//*                                                                         *
//* SYNOPSIS:   Gets a field (separated with certain characters).           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
PSTR GetStringField( PSTR *ppszString, PCSTR c_pszSeparators, CHAR chQuoteToCheck, BOOL bStripWhiteSpace)
{
    PSTR pszInternalString;
    PSTR pszPoint = NULL;
    BOOL fWithinQuotes = FALSE;
    CHAR ch1, chQuote = 0;
    PSTR pszTmp;

    pszInternalString = *ppszString;

    if ( pszInternalString == NULL )
    {
        return NULL;
    }

    pszPoint = pszInternalString;
    while ( 1 )
    {
        ch1 = *pszInternalString;

        if ( ch1 == chQuoteToCheck )
        {
            pszTmp = CharNext( pszInternalString );
            if ( chQuote == 0 )
            {
                // the first one
                chQuote = ch1;
                fWithinQuotes = !(fWithinQuotes);
                // strip out this quote
                MoveMemory( pszInternalString, pszTmp, lstrlen(pszTmp)+1 );
                if ( *pszInternalString == chQuote )
                    continue;
            }
            else if ( chQuote == ch1 )
            {
                if ( *pszTmp == ch1 )
                {
                    PSTR ptmp = CharNext( pszTmp );
                    // dest, src, count include terminate null char.
                    MoveMemory( pszTmp, ptmp, lstrlen(ptmp)+1 );
                }
                else
                {
                    fWithinQuotes = !(fWithinQuotes);
                    chQuote = 0;
                    MoveMemory( pszInternalString, pszTmp, lstrlen(pszTmp)+1 );
                }
            }
        }

        if ( *pszInternalString == '\0' )
        {
            break;
        }

        if ( !fWithinQuotes && IsSeparator( *pszInternalString, (PSTR) c_pszSeparators ) )
        {
            break;
        }
        pszInternalString = CharNext(pszInternalString);
    }

    if ( *pszInternalString == '\0' )
    {
        pszInternalString = NULL;
    }
    else
    {
       *pszInternalString = '\0';
        pszInternalString += 1;
    }

    if ( bStripWhiteSpace )
        pszPoint = StripWhitespace( pszPoint );

    *ppszString = pszInternalString;
    return pszPoint;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetStringFieldNoQuote                                       *
//*                                                                         *
//* SYNOPSIS:   Gets a field (separated with certain characters).           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
LPSTR GetStringFieldNoQuote( PSTR *ppszString, PCSTR c_pszSeparators, BOOL bStripWhiteSpace)
{
    LPSTR pszInternalString;
    LPSTR pszPoint = NULL;

    pszInternalString = *ppszString;
    if ( pszInternalString == NULL )
    {
        return NULL;
    }

    pszPoint = pszInternalString;
    while ( *pszInternalString )
    {
        if ( IsSeparator( *pszInternalString, c_pszSeparators ) )
        {
            break;
        }
        pszInternalString = CharNext(pszInternalString);
    }

    if ( *pszInternalString == '\0' )
    {
        pszInternalString = NULL;
    }
    else
    {
       *pszInternalString = '\0';
        pszInternalString += 1;
    }

    if ( bStripWhiteSpace )
        pszPoint = StripWhitespace( pszPoint );

    *ppszString = pszInternalString;
    return pszPoint;
}

//***************************************************************************
//*                                                                         *
//* NAME:       IsSeparator                                                 *
//*                                                                         *
//* SYNOPSIS:   Returns TRUE if the character is in the string. Else FALSE. *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL IsSeparator( CHAR chChar, PCSTR pszSeparators )
{
    if ( chChar == '\0' || pszSeparators == NULL ) {
        return FALSE;
    }

    while ( *pszSeparators != chChar ) {
        if ( *pszSeparators == '\0' ) {
            return FALSE;
        }

        pszSeparators += 1;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       StripWhitespace                                             *
//*                                                                         *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
PSTR StripWhitespace( PSTR pszString )
{
    PSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlen(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}

//***************************************************************************
//*                                                                         *
//* NAME:       StripQuotes                                                 *
//*                                                                         *
//* SYNOPSIS:   Strips quotes from both sides of given string.              *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
#if 0
PSTR StripQuotes( PSTR pszString )
{
    PSTR pszTemp = NULL;
    CHAR chQuote;

    if ( pszString == NULL )
    {
        return NULL;
    }

    ch = *pszString;
    if ( ch == '"' || ch == '\'' )
    {
        pszTemp = pszString + 1;
    }
    else
    {
        return pszString;
    }

    pszString += lstrlen(pszString) - 1;

    if ( *pszString == ch )
    {
        *pszString = '\0';
    }
    else
    {
        pszTemp--;
    }

    return pszTemp;
}

#endif
//***************************************************************************
//*                                                                         *
//* NAME:       IsGoodAdvancedInfVersion                                    *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL IsGoodAdvancedInfVersion( PCSTR c_pszInfFilename )
{
    static const CHAR c_szSection[] = "Version";
    static const CHAR c_szKey[] = "AdvancedINF";
    PSTR pszVersionData = NULL;
    PSTR pszMajorVersion = NULL;
    PSTR pszMinorVersion = NULL;
    DWORD dwRequiredSize;
    DWORD dwSize;
    PSTR pszVersion = NULL;
    PSTR pszErrorMsg = NULL;
    DWORD dwVersion = 0;
    BOOL fSuccess = TRUE;
    PSTR pszTmp;

    if ( FAILED( GetTranslatedString( c_pszInfFilename, c_szSection, c_szKey, pszVersionData,
                                      0, &dwRequiredSize ) ) )
    {
        // We return TRUE because even though they didn't specify a version, I still
        // want to process the INF file.
        fSuccess = TRUE;
        goto done;
    }

    pszVersionData = (PSTR) LocalAlloc( LPTR, dwRequiredSize );
    if ( !pszVersionData ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        fSuccess = FALSE;
        goto done;
    }

    if ( FAILED( GetTranslatedString( c_pszInfFilename, c_szSection, c_szKey,
                                      pszVersionData, dwRequiredSize, &dwSize ) ) )
    {
        // This guy should never fail because the call above didn't fail.
        fSuccess = FALSE;
        goto done;
    }

    pszTmp = pszVersionData;
    // Parse the arguments, SETUP engine has processed \" so we only need to check on \'
    pszVersion = GetStringField( &pszTmp, ",", '\'', TRUE );
    pszErrorMsg = GetStringField( &pszTmp, ",", '\'', TRUE );

    if ( pszVersion == NULL || *pszVersion == '\0' ) {
        // If they don't specify a version, process the INF file anyway
        fSuccess = TRUE;
        goto done;
    }

    // Parse the arguments, SETUP engine has processed \" so we only need to check on \'
    pszTmp = pszVersion;
    pszMajorVersion = GetStringField( &pszTmp, ".", '\'', TRUE );
    pszMinorVersion = GetStringField( &pszTmp, ".", '\'', TRUE );

    if ( pszMajorVersion == NULL || pszMajorVersion == '\0' ) {
        fSuccess = TRUE;
        goto done;
    }

    dwVersion = ((DWORD) My_atol(pszMajorVersion)) * 100;

    if ( pszMinorVersion != NULL ) {
    	dwVersion += (DWORD) My_atol(pszMinorVersion);
    }

    if ( dwVersion > ADVPACK_VERSION ) {
        fSuccess = FALSE;
        if ( pszErrorMsg != NULL && *pszErrorMsg != '\0' ) {
            ErrorMsg1Param( ctx.hWnd, IDS_PROMPT, pszErrorMsg );
            AdvWriteToLog("Advpack.dll Version check failed! InfFile=%1\r\n", c_pszInfFilename);

        }
        goto done;
    }

  done:

    if ( pszVersionData ) {
        LocalFree( pszVersionData );
    }

    return fSuccess;
}


//***************************************************************************
//*                                                                         *
//* NAME:       SelectSetupEngine                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL SelectSetupEngine( PCSTR c_pszInfFilename, PCSTR c_pszSection, DWORD dwFlags )
{
    static const CHAR c_szKey[] = "RequiredEngine";
    static const CHAR c_szSetupX[] = "SETUPX";
    static const CHAR c_szSetupAPI[] = "SETUPAPI";
    PSTR  pszEngine = NULL;
    PSTR  pszErrorMsg = NULL;
    BOOL  fSuccess = TRUE;
    PSTR  pszDll = NULL;
    PSTR  pszFilePart = NULL;
    CHAR szBuffer[MAX_PATH];
    CHAR szEngineData[2048];
    PSTR pszStr;
    BOOL bMustSetupapi = FALSE;

    if ( (dwFlags & COREINSTALL_BKINSTALL) || (dwFlags & COREINSTALL_ROLLBACK) ||
         (dwFlags & COREINSTALL_REBOOTCHECKONINSTALL) || (dwFlags & COREINSTALL_SETUPAPI)||(ctx.wOSVer != _OSVER_WIN95))
    {
        ctx.dwSetupEngine = ENGINE_SETUPAPI;
        bMustSetupapi = TRUE;
        if (ctx.wOSVer != _OSVER_WIN95)
            goto done;
    }
    else
    {
        ctx.dwSetupEngine = ENGINE_SETUPX;
    }


    if (FAILED(GetTranslatedString(c_pszInfFilename, c_pszSection, c_szKey,
                                    szEngineData, sizeof(szEngineData), NULL)))
    {
        fSuccess = TRUE;
        goto done;
    }

    // Parse the arguments, SETUP engine is NOT called. So we need to check on \"
    pszStr = szEngineData;
    pszEngine = GetStringField( &pszStr, ",", '\"', TRUE );
    pszErrorMsg = GetStringField( &pszStr, ",", '\"', TRUE );

    if ( pszEngine == NULL || *pszEngine == '\0' ) {
        // If they don't specify an engine, process the INF file anyway
        fSuccess = TRUE;
        goto done;
    }


    if ( !bMustSetupapi && (lstrcmpi( pszEngine, c_szSetupX ) == 0) ) {
        pszDll = W95INF32DLL;
        ctx.dwSetupEngine = ENGINE_SETUPX;
    } else {
        pszDll = SETUPAPIDLL;
        ctx.dwSetupEngine = ENGINE_SETUPAPI;
    }

    // only if you don't have the INF engine file and you don't have the UpdateINFEngine On, error out
    if (!SearchPath( NULL, pszDll, NULL, sizeof(szBuffer), szBuffer, &pszFilePart ) &&
        (GetTranslatedInt(c_pszInfFilename, c_pszSection, ADVINF_UPDINFENG, 0)==0))
    {
        fSuccess = FALSE;
        if ( pszErrorMsg != NULL && *pszErrorMsg != '\0' )
        {
            ErrorMsg1Param( ctx.hWnd, IDS_PROMPT, pszErrorMsg );
        }
        else
            ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, SETUPAPIDLL );
    }

done:

    return fSuccess;
}


//***************************************************************************
//*                                                                         *
//* NAME:       BeginPrompt                                                 *
//*                                                                         *
//* SYNOPSIS:   Displays beginning (confirmation) prompt.                   *
//*									                                        *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
INT BeginPrompt( PCSTR c_pszInfFilename, PCSTR c_pszSection, PSTR pszTitle, DWORD dwTitleSize )
{
    static const CHAR c_szBeginPromptKey[] = "BeginPrompt";
    static const CHAR c_szPromptKey[]      = "Prompt";
    static const CHAR c_szButtonTypeKey[]  = "ButtonType";
    static const CHAR c_szTitleKey[]       = "Title";
    static const CHAR c_szButtonYesNo[]    = "YESNO";
    CHAR szBeginPromptSection[256];
    PSTR  pszPrompt = NULL;
    DWORD dwPromptSize = 2048;
    INT   nReturnCode = 0;
    CHAR szButtonType[128];
    UINT  nButtons = 0;
    DWORD dwSize;


    if ( FAILED( GetTranslatedString( c_pszInfFilename, c_pszSection, c_szBeginPromptKey,
                                      szBeginPromptSection, sizeof(szBeginPromptSection), &dwSize ) ) )
    {
        nReturnCode = IDOK;
        goto done;
    }

    if ( ! FAILED( GetTranslatedString( c_pszInfFilename, szBeginPromptSection, c_szTitleKey,
                                        pszTitle, dwTitleSize, &dwSize ) ) )
    {
        ctx.lpszTitle = pszTitle;
    }

    pszPrompt = (PSTR) LocalAlloc( LPTR, dwPromptSize );
    if ( ! pszPrompt ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        nReturnCode = IDCANCEL;
        goto done;
    }

    if ( FAILED( GetTranslatedString( c_pszInfFilename, szBeginPromptSection, c_szPromptKey,
                                      pszPrompt, dwPromptSize, &dwSize ) ) )
    {
        nReturnCode = IDOK;
        goto done;
    }

    GetTranslatedString( c_pszInfFilename, szBeginPromptSection, c_szButtonTypeKey,
                         szButtonType, sizeof(szButtonType), &dwSize );

    if ( lstrcmpi( szButtonType, c_szButtonYesNo ) == 0 ) {
        nButtons = MB_YESNO;
    } else {
        nButtons = MB_OKCANCEL;
    }

    nReturnCode = MsgBox1Param( ctx.hWnd, IDS_PROMPT, pszPrompt, MB_ICONQUESTION, nButtons | MB_DEFBUTTON2 );
    if ( nReturnCode == 0 ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        nReturnCode = IDCANCEL;
        goto done;
    }

  done:

    if ( pszPrompt ) {
        LocalFree( pszPrompt );
    }

    // Map all cancel buttons to IDCANCEL
    if ( nReturnCode == IDNO ) {
        nReturnCode = IDCANCEL;
    }

    return nReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       EndPrompt                                                   *
//*                                                                         *
//* SYNOPSIS:   Displays end prompt.                                        *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID EndPrompt( PCSTR c_pszInfFilename, PCSTR c_pszSection )
{
    static const CHAR c_szEndPromptKey[] = "EndPrompt";
    static const CHAR c_szPromptKey[] = "Prompt";
    CHAR szEndPromptSection[256];
    PSTR  pszPrompt = NULL;
    DWORD dwPromptSize = 2048;
    DWORD dwSize = 0;

    if ( FAILED( GetTranslatedString( c_pszInfFilename, c_pszSection, c_szEndPromptKey,
                                      szEndPromptSection, sizeof(szEndPromptSection), &dwSize ) ) )
    {
        goto done;
    }

    pszPrompt = (PSTR) LocalAlloc( LPTR, dwPromptSize );
    if ( ! pszPrompt ) {
        goto done;
    }

    if ( FAILED( GetTranslatedString( c_pszInfFilename, szEndPromptSection, c_szPromptKey,
                                      pszPrompt, dwPromptSize, &dwSize ) ) )
    {
        goto done;
    }

    MsgBox1Param( ctx.hWnd, IDS_PROMPT, pszPrompt, MB_ICONINFORMATION, MB_OK );

  done:

    if ( pszPrompt ) {
        LocalFree( pszPrompt );
    }

    return;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MyGetPrivateProfileString                                   *
//*                                                                         *
//* SYNOPSIS:   Gets string from INF file.  TRUE if success, else FALSE.    *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL MyGetPrivateProfileString( PCSTR c_pszInfFilename, PCSTR c_pszSection,
                                PCSTR c_pszKey, PSTR pszBuffer, DWORD dwBufferSize )
{
    DWORD dwSize = 0;
    static const CHAR c_szDefault[] = "ZzZzZzZz";

    dwSize = GetPrivateProfileString( c_pszSection, c_pszKey, c_szDefault,
                                      pszBuffer, dwBufferSize,
                                      c_pszInfFilename );
    if ( dwSize == (dwBufferSize - 1)
        || lstrcmp( pszBuffer, c_szDefault ) == 0 )
    {
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       InitializeSetupAPI                                          *
//*                                                                         *
//* SYNOPSIS:   Load the proper setup library and functions (for Win95)     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL InitializeSetupAPI()
{
	if ( ctx.hSetupLibrary == NULL )
	{
		ctx.hSetupLibrary = MyLoadLibrary( SETUPAPIDLL );
		if ( ctx.hSetupLibrary == NULL )
		{
			ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, SETUPAPIDLL );
			return FALSE;
		}

		if ( ! LoadSetupAPIFuncs() )
		{
			ErrorMsg( NULL, IDS_ERR_GET_PROC_ADDR );
			FreeLibrary( ctx.hSetupLibrary );
			ctx.hSetupLibrary = NULL;
			return FALSE;
		}
	}
	return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       LoadSetupLib                                                *
//*                                                                         *
//* SYNOPSIS:   Load the proper setup library and functions (for Win95)     *
//*                                                                         *
//* REQUIRES:   CheckOSV                                                    *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL LoadSetupLib( PCSTR c_pszInfFilename, PCSTR c_pszSection, BOOL fUpdDlls, DWORD dwFlags )
{
    MSG tmpmsg;

    if ( ! SelectSetupEngine( c_pszInfFilename, c_pszSection, dwFlags) ) {
        return FALSE;
    }

    // update the advpack.dll etc if needed
    if ( fUpdDlls && (ctx.wOSVer < _OSVER_WINNT50) && !RunningOnMillennium())
    {
        if (!UpdateHelpDlls( c_szAdvDlls, ((ctx.wOSVer ==_OSVER_WIN95)?3:1), NULL, "Advpack",
                                      (ctx.bUpdHlpDlls?UPDHLPDLLS_FORCED:0) ) )
        {
            return FALSE;
        }
    }

    // update INF Engine dlls if needed
    if ( GetTranslatedInt(c_pszInfFilename, c_pszSection, ADVINF_UPDINFENG, 0) )
    {
        char szSrcPath[MAX_PATH];

        lstrcpy(szSrcPath, c_pszInfFilename);
        GetParentDir(szSrcPath);
        if (ctx.dwSetupEngine == ENGINE_SETUPAPI)
        {
			// setupapi.dll may be loaded.  So free it up before update
			//
			CommonInstallCleanup();
            if (!UpdateHelpDlls(c_szSetupAPIDlls, 2, szSrcPath, "SetupAPI",
                                UPDHLPDLLS_FORCED|UPDHLPDLLS_ALERTREBOOT) )
            {
                return FALSE;
            }
        }
        else
        {
            if (!UpdateHelpDlls(c_szSetupXDlls, 1, szSrcPath, "SetupX",
                                UPDHLPDLLS_FORCED|UPDHLPDLLS_ALERTREBOOT) )
            {
                return FALSE;
            }
        }
    }

    // Under Win95 load W95INF32.DLL to thunk down to 16-bit land.
    // Under WinNT load SETUPAPI.DLL and call in directly.
    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        ctx.hSetupLibrary = MyLoadLibrary( W95INF32DLL );
        if ( ctx.hSetupLibrary == NULL ) {
            ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, W95INF32DLL );
            return FALSE;
        }

        pfCtlSetLddPath32                 = (CTLSETLDDPATH32) GetProcAddress( ctx.hSetupLibrary, achCTLSETLDDPATH32 );
        pfGenInstall32                    = (GENINSTALL32) GetProcAddress( ctx.hSetupLibrary, achGENINSTALL32 );
        pfGetSETUPXErrorText32            = (GETSETUPXERRORTEXT32) GetProcAddress( ctx.hSetupLibrary, achGETSETUPXERRORTEXT32 );
        pfGenFormStrWithoutPlaceHolders32 = (GENFORMSTRWITHOUTPLACEHOLDERS32) GetProcAddress( ctx.hSetupLibrary, achGENFORMSTRWITHOUTPLACEHOLDERS32 );

        if (    pfCtlSetLddPath32 == NULL
             || pfGenInstall32 == NULL
             || pfGetSETUPXErrorText32 == NULL
             || pfGenFormStrWithoutPlaceHolders32 == NULL )
        {
            ErrorMsg( NULL, IDS_ERR_GET_PROC_ADDR );
            FreeLibrary( ctx.hSetupLibrary );
			ctx.hSetupLibrary = NULL;
            return FALSE;
        }
    }
    else
    {
        if (!InitializeSetupAPI())
            return FALSE;

        // BUGBUG: HACK: On NT if we are kicking off setupapi in silent mode,
        // it hangs in a GetMessage() call. This is probably because the corr.
        // PostThreadMessage() that ted posts fails because no Message Queue has
        // been created. The following call should create a queue. Till Ted
        // fixes SETUPAPI.DLL, I have added thsi hack!!!
        //
        PeekMessage(&tmpmsg, NULL, 0, 0, PM_NOREMOVE) ;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       UnloadSetupLib                                              *
//*                                                                         *
//* SYNOPSIS:   Load the proper setup library and functions (for Win95)     *
//*                                                                         *
//* REQUIRES:   CheckOSV                                                    *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID UnloadSetupLib( VOID )
{
    if ( ctx.hSetupLibrary != NULL )
	{
        FreeLibrary( ctx.hSetupLibrary );
        ctx.hSetupLibrary = NULL;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       CheckOSVersion                                              *
//*                                                                         *
//* SYNOPSIS:   Checks the OS version and sets some global variables.       *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successful, FALSE otherwise.        *
//*                                                                         *
//***************************************************************************
BOOL CheckOSVersion( VOID )
{
    OSVERSIONINFO verinfo;        // Version Check

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx( &verinfo ) == FALSE )
    {
        ErrorMsg( ctx.hWnd, IDS_ERR_OS_VERSION );
        return FALSE;
    }

    switch( verinfo.dwPlatformId )
    {
        case VER_PLATFORM_WIN32_WINDOWS: // Win95
            ctx.wOSVer = _OSVER_WIN95;
            ctx.fOSSupportsINFInstalls = TRUE;
            return TRUE;

        case VER_PLATFORM_WIN32_NT: // Win NT
            ctx.fOSSupportsINFInstalls = TRUE;
            ctx.wOSVer = _OSVER_WINNT40;

            if ( verinfo.dwMajorVersion <= 3 )
            {
                ctx.wOSVer = _OSVER_WINNT3X;
                if ( (verinfo.dwMajorVersion < 3) ||
                     ((verinfo.dwMajorVersion == 3) && (verinfo.dwMinorVersion < 51 )) )
                {
                    // Reject for INF installs and Reject for animations
                    ctx.fOSSupportsINFInstalls = FALSE;
                }
            }
            else if ( verinfo.dwMajorVersion == 5  && 
                      verinfo.dwMinorVersion == 0) 
            {
                    ctx.wOSVer = _OSVER_WINNT50;
            }
            else if ( (verinfo.dwMajorVersion == 5  && 
                       verinfo.dwMinorVersion > 0) || 
                      verinfo.dwMajorVersion > 5)
                ctx.wOSVer = _OSVER_WINNT51;

            return TRUE;

        default:
            ErrorMsg( ctx.hWnd, IDS_ERR_OS_UNSUPPORTED );
            return FALSE;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       MsgBox2Param                                                *
//*                                                                         *
//* SYNOPSIS:   Displays a message box with the specified string ID using   *
//*             2 string parameters.                                        *
//*                                                                         *
//* REQUIRES:   hWnd:           Parent window                               *
//*             nMsgID:         String resource ID                          *
//*             szParam1:       Parameter 1 (or NULL)                       *
//*             szParam2:       Parameter 2 (or NULL)                       *
//*             uIcon:          Icon to display (or 0)                      *
//*             uButtons:       Buttons to display                          *
//*                                                                         *
//* RETURNS:    INT:            ID of button pressed                        *
//*                                                                         *
//* NOTES:      Macros are provided for displaying 1 parameter or 0         *
//*             parameter message boxes.  Also see ErrorMsg() macros.       *
//*                                                                         *
//***************************************************************************
INT MsgBox2Param( HWND hWnd, UINT nMsgID, LPCSTR szParam1, LPCSTR szParam2,
		  UINT uIcon, UINT uButtons )
{
    CHAR achMsgBuf[BIG_STRING];
    CHAR szTitle[MAX_PATH];
    LPSTR szMessage = NULL;
    LPSTR pszTitle;
    INT   nReturn;
    CHAR achError[] = "Unexpected Error.  Could not load resource.";
    LPSTR aszParams[2];

    // BUGBUG: quiet mode return code should be caller's param passed in.
    // we may need to check on FormatMessage's return code and handle it in more completed fashion.
    //
    if ( (ctx.wQuietMode & QUIETMODE_SHOWMSG) || !(ctx.wQuietMode & QUIETMODE_ALL) )
    {
        aszParams[0] = (LPSTR) szParam1;
        aszParams[1] = (LPSTR) szParam2;

        LoadSz( nMsgID, achMsgBuf, sizeof(achMsgBuf) );

        if ( (*achMsgBuf) == '\0' ) {
            lstrcpy( achMsgBuf, achError );
        }

        if ( FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY
                          | FORMAT_MESSAGE_ALLOCATE_BUFFER, achMsgBuf, 0, 0, (LPSTR) (&szMessage),
                            0, (va_list *)aszParams ) )
        {
            MessageBeep( uIcon );

            if ( ctx.lpszTitle == NULL )
            {
                LoadSz( IDS_ADVDEFTITLE, szTitle, sizeof(szTitle) );
                if ( szTitle[0] == '\0' )
                {
                    lstrcpy( szTitle, achError );
                }
                pszTitle = szTitle;
            }
            else
                pszTitle = ctx.lpszTitle;

            nReturn = MessageBox( hWnd, szMessage, pszTitle, uIcon |
                                  uButtons | MB_APPLMODAL | MB_SETFOREGROUND | 
                                  ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0) );

            LocalFree( szMessage );
        }

        return nReturn;
    }
    else
        return IDOK;
}

//***************************************************************************
//*                                                                         *
//* NAME:       LoadSz                                                      *
//*                                                                         *
//* SYNOPSIS:   Loads specified string resource into buffer.                *
//*                                                                         *
//* REQUIRES:   idString:                                                   *
//*             lpszBuf:                                                    *
//*             cbBuf:                                                      *
//*                                                                         *
//* RETURNS:    LPSTR:     Pointer to the passed-in buffer.                 *
//*                                                                         *
//* NOTES:      If this function fails (most likely due to low memory), the *
//*             returned buffer will have a leading NULL so it is generally *
//*             safe to use this without checking for failure.              *
//*                                                                         *
//***************************************************************************
LPSTR LoadSz( UINT idString, LPSTR lpszBuf, UINT cbBuf )
{
    ASSERT( lpszBuf );

    // Clear the buffer and load the string
    if ( lpszBuf ) {
        *lpszBuf = '\0';
        LoadString( g_hInst, idString, lpszBuf, cbBuf );
    }

    return lpszBuf;
}


//***************************************************************************
//*                                                                         *
//* NAME:       UserDirPrompt                                               *
//*                                                                         *
//* SYNOPSIS:   Pops up a dialog to ask the user for a directory.           *
//*                                                                         *
//* REQUIRES:   lpszPromptText: Prompt to display or if null, use next parm *
//*             uiPromptResID:  ID of string to display as prompt           *
//*             lpszDefault:    Default directory to put in edit box.       *
//*             lpszDestDir:    Buffer to store user selected directory     *
//*             cbDestDirSize:  Size of this buffer                         *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if everything went well, FALSE         *
//*                             if the user cancelled, or error.            *
//*                                                                         *
//***************************************************************************
BOOL UserDirPrompt( LPSTR lpszPromptText,
                    LPSTR lpszDefault, LPSTR lpszDestDir,
                    ULONG cbDestDirSize, DWORD dwInstNeedSize )
{
    BOOL        fDlgRC;
    DIRDLGPARMS DirDlgParms;

    DirDlgParms.lpszPromptText   = lpszPromptText;
    DirDlgParms.lpszDefault      = lpszDefault;
    DirDlgParms.lpszDestDir      = lpszDestDir;
    DirDlgParms.cbDestDirSize  = cbDestDirSize;
    DirDlgParms.dwInstNeedSize = dwInstNeedSize;

    SetControlFont();

    fDlgRC = (BOOL) DialogBoxParam( g_hInst, MAKEINTRESOURCE(IDD_DIRDLG),
                                    NULL, DirDlgProc,
                                    (LPARAM) &DirDlgParms );

    if (g_hFont)
    {
        DeleteObject(g_hFont);
        g_hFont = NULL;
    }

    return fDlgRC;
}


//***************************************************************************
//*                                                                         *
//* NAME:       DirDlgProc                                                  *
//*                                                                         *
//* SYNOPSIS:   Dialog Procedure for our dir dialog window.                 *
//*                                                                         *
//* REQUIRES:   hwndDlg:                                                    *
//*             uMsg:                                                       *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
INT_PTR CALLBACK DirDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam,
                             LPARAM lParam )
{
    static CHAR  achDir[MAX_PATH];
    static CHAR  achMsg[BIG_STRING];
    static LPSTR lpszDestDir;
    static LPSTR lpszDefaultDir;
    static ULONG  cbDestDirSize;
    static DWORD  dwInstNeedSize;

    switch (uMsg)  {

      //*********************************************************************
        case WM_INITDIALOG:
      //*********************************************************************
        {
            DIRDLGPARMS *DirDlgParms = (DIRDLGPARMS *) lParam;

            lpszDestDir = DirDlgParms->lpszDestDir;
            lpszDefaultDir = DirDlgParms->lpszDefault;
            cbDestDirSize = DirDlgParms->cbDestDirSize;
            dwInstNeedSize = DirDlgParms->dwInstNeedSize;

            CenterWindow( hwndDlg, GetDesktopWindow() );
            SetWindowText( hwndDlg, ctx.lpszTitle );


            if ( ! SetDlgItemText( hwndDlg, IDC_TEMPTEXT, DirDlgParms->lpszPromptText ) )
            {
                ErrorMsg( hwndDlg, IDS_ERR_UPDATE_DIR );
                EndDialog( hwndDlg, FALSE );
                return TRUE;
            }

            SetFontForControl(hwndDlg, IDC_EDIT_DIR);
            if ( ! SetDlgItemText( hwndDlg, IDC_EDIT_DIR, DirDlgParms->lpszDefault ) )
            {
                ErrorMsg( hwndDlg, IDS_ERR_UPDATE_DIR );
                EndDialog( hwndDlg, FALSE );
                return TRUE;
            }

            // limit edit control length
            SendDlgItemMessage( hwndDlg, IDC_EDIT_DIR, EM_SETLIMITTEXT, (MAX_PATH - 1), 0 );

            if ( ctx.wOSVer == _OSVER_WINNT3X ) {
                EnableWindow( GetDlgItem(  hwndDlg, IDC_BUT_BROWSE ), FALSE );
            }

            return TRUE;
        }


        //*********************************************************************
        case WM_CLOSE:
        //*********************************************************************

            EndDialog( hwndDlg, FALSE );
            return TRUE;


        //*********************************************************************
        case WM_COMMAND:
        //*********************************************************************

            switch ( wParam )
            {

            //*************************************************************
            case IDOK:
            //*************************************************************
            {
                DWORD dwAttribs = 0, dwTemp;

                // Read the user's entry. If it is different from the default 
                // and does not exist, prompt user. If user accepts
                // create it 

               if ( ! GetDlgItemText( hwndDlg, IDC_EDIT_DIR,
                            lpszDestDir, cbDestDirSize - 1 ) || !IsFullPath(lpszDestDir) )
                {
                    ErrorMsg( hwndDlg, IDS_ERR_EMPTY_DIR_FIELD );
                    return TRUE;
                }

                // check on the DestDir size if this is not UNC and this drive has not been checked
                if ( (*lpszDestDir != '\\' ) && !IsDrvChecked( *lpszDestDir ) )
                {
                    if ( !IsEnoughInstSpace( lpszDestDir, dwInstNeedSize, &dwTemp ) )
                    {
                        CHAR szSize[10];

                        if ( dwTemp )
                        {
                            wsprintf( szSize, "%lu", dwTemp );
                            if ( MsgBox1Param( hwndDlg, IDS_ERR_NO_SPACE_INST, szSize,
                                               MB_ICONQUESTION, MB_YESNO|MB_DEFBUTTON2 ) == IDNO )
                                return TRUE;
                        }
                        else // given drive cannot be checked, error has been posted.  no further needed
                            return TRUE;
                    }
                }

                dwAttribs = GetFileAttributes( lpszDestDir );
                if ( dwAttribs == 0xFFFFFFFF )
                {
                    // If this new entry is different from the original, then prompt the user.
                    if ((lstrcmpi(lpszDestDir, lpszDefaultDir) == 0) ||
                        MsgBox1Param( hwndDlg, IDS_CREATE_DIR, lpszDestDir, MB_ICONQUESTION, MB_YESNO )
                                    == IDYES )
                    {
                        if ( FAILED(CreateFullPath( lpszDestDir, FALSE )) )
                        {
                            ErrorMsg1Param( hwndDlg, IDS_ERR_CREATE_DIR, lpszDestDir );
                            return TRUE;
                        }
                    }
                    else
                    {
                        return TRUE;
                    }
                }

                if ( ! IsGoodDir( lpszDestDir ) )  {
                    ErrorMsg( hwndDlg, IDS_ERR_INVALID_DIR );
                    return TRUE;
                }

                EndDialog( hwndDlg, TRUE );

                return TRUE;
            }

            //*************************************************************
            case IDCANCEL:
            //*************************************************************

                EndDialog( hwndDlg, FALSE );
                return TRUE;


            //*************************************************************
            case IDC_BUT_BROWSE:
            //*************************************************************

                if ( LoadString( g_hInst, IDS_SELECTDIR, achMsg,
                                  sizeof(achMsg) ) == 0 )
                {
                    ErrorMsg( hwndDlg, IDS_ERR_NO_RESOURCE );
                    EndDialog( hwndDlg, FALSE );
                    return TRUE;
                }

                if ( ! BrowseForDir( hwndDlg, achMsg, achDir ) )  {
                    return TRUE;
                }

                if ( ! SetDlgItemText( hwndDlg, IDC_EDIT_DIR, achDir ) )
                {
                    ErrorMsg( hwndDlg, IDS_ERR_UPDATE_DIR );
                    EndDialog( hwndDlg, FALSE );
                    return TRUE;
                }

                return TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


int CALLBACK BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch(uMsg) {
        case BFFM_INITIALIZED:
            // lpData is the path string
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
            break;
    }
    return 0;
}


//***************************************************************************
//*                                                                         *
//* NAME:       BrowseForDir                                                *
//*                                                                         *
//* SYNOPSIS:   Let user browse for a directory on their system or network. *
//*                                                                         *
//* REQUIRES:   hwndParent:                                                 *
//*             szTitle:                                                    *
//*             szResult:                                                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//* NOTES:      It would be really cool to set the status line of the       *
//*             browse window to display "Yes, there's enough space", or    *
//*             "no there is not".                                          *
//*                                                                         *
//***************************************************************************
BOOL BrowseForDir( HWND hwndParent, LPCSTR szTitle, LPSTR szResult )
{
    BROWSEINFO   bi;
    LPITEMIDLIST pidl;
    HINSTANCE    hShell32Lib;
    SHFREE       pfSHFree;
    SHGETPATHFROMIDLIST        pfSHGetPathFromIDList;
    SHBROWSEFORFOLDER          pfSHBrowseForFolder;
    static const CHAR achShell32Lib[]                 = "SHELL32.DLL";
    static const CHAR achSHBrowseForFolder[]          = "SHBrowseForFolder";
    static const CHAR achSHGetPathFromIDList[]        = "SHGetPathFromIDList";

    ASSERT( szResult );

    // Load the Shell 32 Library to get the SHBrowseForFolder() features

    if ( ( hShell32Lib = LoadLibrary( achShell32Lib ) ) != NULL )  {

        if ( ( ! ( pfSHBrowseForFolder = (SHBROWSEFORFOLDER)
              GetProcAddress( hShell32Lib, achSHBrowseForFolder ) ) )
            || ( ! ( pfSHFree = (SHFREE) GetProcAddress( hShell32Lib,
              MAKEINTRESOURCE(SHFREE_ORDINAL) ) ) )
            || ( ! ( pfSHGetPathFromIDList = (SHGETPATHFROMIDLIST)
              GetProcAddress( hShell32Lib, achSHGetPathFromIDList ) ) ) )
        {
            FreeLibrary( hShell32Lib );
            ErrorMsg( hwndParent, IDS_ERR_LOADFUNCS );
            return FALSE;
        }
        } else  {
        ErrorMsg( hwndParent, IDS_ERR_LOADDLL );
        return FALSE;
    }

    if ( ! ctx.szBrowsePath[0] )
    {
        GetProgramFilesDir( ctx.szBrowsePath, sizeof(ctx.szBrowsePath) );
    }

    szResult[0]       = 0;

    bi.hwndOwner      = hwndParent;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle      = szTitle;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseCallback;
    bi.lParam         = (LPARAM)ctx.szBrowsePath;

    pidl              = pfSHBrowseForFolder( &bi );


    if ( pidl )  {
        pfSHGetPathFromIDList( pidl, ctx.szBrowsePath );
        if ( ctx.szBrowsePath[0] )  {
            lstrcpy( szResult, ctx.szBrowsePath );
        }
        pfSHFree( pidl );
    }


    FreeLibrary( hShell32Lib );

    if ( szResult[0] != 0 ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

//***************************************************************************
//*                                                                         *
//* NAME:       CenterWindow                                                *
//*                                                                         *
//* SYNOPSIS:   Center one window within another.                           *
//*                                                                         *
//* REQUIRES:   hwndChild:                                                  *
//*             hWndParent:                                                 *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successful, FALSE otherwise         *
//*                                                                         *
//***************************************************************************
BOOL CenterWindow( HWND hwndChild, HWND hwndParent )
{
    RECT rChild;
    RECT rParent;
    int  wChild;
    int  hChild;
    int  wParent;
    int  hParent;
    int  wScreen;
    int  hScreen;
    int  xNew;
    int  yNew;
    HDC  hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return( SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER));
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsGoodDir                                                   *
//*                                                                         *
//* SYNOPSIS:   Find out if it's a good temporary directory or not.         *
//*                                                                         *
//* REQUIRES:   szPath:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if good, FALSE if nogood               *
//*                                                                         *
//***************************************************************************
BOOL IsGoodDir( LPCSTR szPath )
{
    DWORD  dwAttribs;
    HANDLE hFile;
    char   szTestFile[MAX_PATH];

    lstrcpy( szTestFile, szPath );
    AddPath( szTestFile, "TMP4352$.TMP" );
    DeleteFile( szTestFile );
    hFile = CreateFile( szTestFile, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )  {
        return( FALSE );
    }

    CloseHandle( hFile );
    dwAttribs = GetFileAttributes( szPath );

    if ( ( dwAttribs != 0xFFFFFFFF )
         && ( dwAttribs & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        return( TRUE );
    }

    return( FALSE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       CtlSetLDDPath                                               *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT CtlSetLddPath( UINT uiLDID, LPSTR lpszPath, DWORD dwSwitches )
{
    PSTR    pszNewPath    = NULL;
    BOOL    fSuccess      = TRUE;
    DWORD   dwNewPathSize = 0;
    HRESULT hResult       = S_OK;
    PSTR    lpTmp;
    BOOL    bDBC = FALSE;

    dwNewPathSize = max( MAX_PATH, lstrlen(lpszPath) + 1 );

    pszNewPath = (PSTR) LocalAlloc( LPTR, dwNewPathSize );
    if ( !pszNewPath ) {
        hResult = HRESULT_FROM_WIN32(GetLastError());
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        goto done;
    }

    if ( ((ctx.dwSetupEngine == ENGINE_SETUPX) && (dwSwitches & LDID_SFN)) ||
         ((dwSwitches & LDID_SFN_NT_ALSO)&& (ctx.wOSVer == _OSVER_WIN95)) )
    {
        if ( GetShortPathName( lpszPath, pszNewPath, dwNewPathSize ) == 0 )
        {
            hResult = HRESULT_FROM_WIN32(GetLastError());
            ErrorMsg( ctx.hWnd, IDS_ERR_SHORT_NAME );
            goto done;
        }
    }
    else
        lstrcpy( pszNewPath, lpszPath );

    if ( ctx.dwSetupEngine == ENGINE_SETUPX ){

    if ( dwSwitches & LDID_OEM_CHARS ) {
        CharToOem( pszNewPath, pszNewPath );
    }

    lpTmp = pszNewPath + lstrlen(pszNewPath) - 1;
    if (*lpTmp == '\\')     // Is the last byte a backslash
    {
        // Check if it is the trail byte of a DBC
        lpTmp = pszNewPath;
        do
        {
            bDBC = IsDBCSLeadByte(*lpTmp);
            lpTmp = CharNext(lpTmp);
        } while (*lpTmp);

        if (bDBC)
        {
            // The backslash is a trail byte. Add another backslash
            AddPath(pszNewPath, "");
        }
    }

    if ( pfCtlSetLddPath32( uiLDID, pszNewPath ) ) {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_SET_LDID, pszNewPath );
            hResult = E_FAIL;
            goto done;
        }
    }
    else
    {
        hResult = MySetupSetDirectoryId( uiLDID, pszNewPath );
        if (  FAILED( hResult ) ) {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_SET_LDID, pszNewPath );
            goto done;
        }
    }

  done:

    if ( pszNewPath ) {
        LocalFree( pszNewPath );
    }

    return hResult;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GenInstall                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:   lpszInfFileName: Filename of INF file.                      *
//*             lpszSection:     Section of the INF to install              *
//*             lpszDirectory:   Directory of CABs (Temp Dir).              *
//*                                                                         *
//* RETURNS:    BOOL: Error result, FALSE == ERROR                          *
//*                                                                         *
//***************************************************************************
HRESULT GenInstall( LPSTR lpszInfFilename, LPSTR lpszInstallSection, LPSTR lpszSourceDir )
{
    CHAR   szErrorText[BIG_STRING];
    DWORD   dwError                  = 0;
    HRESULT hResult                  = S_OK;
    CHAR   szSourceDir[MAX_PATH];
    DWORD   dwLen                    = 0;

    // Remove trailing backslash from the source directory
    lstrcpy( szSourceDir, lpszSourceDir );
    dwLen = lstrlen( szSourceDir );
    if ( szSourceDir[dwLen-2] != ':' && szSourceDir[dwLen-1] == '\\' ) {
    	szSourceDir[dwLen-1] = '\0';
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        CHAR szSFNInf[MAX_PATH] = { 0 };

        GetShortPathName( lpszInfFilename, szSFNInf, sizeof(szSFNInf) );
        GetShortPathName( szSourceDir, szSourceDir, sizeof(szSourceDir) );
        dwError = pfGenInstall32( szSFNInf, lpszInstallSection,
                                  szSourceDir, (DWORD) ctx.wQuietMode,
                                  HandleToUlong(ctx.hWnd)
								);
        if ( dwError ) {
            szErrorText[0] = '\0';
            pfGetSETUPXErrorText32( dwError, szErrorText, sizeof(szErrorText) );
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_FAIL, szErrorText );
            hResult = E_FAIL;
        }
    } else {
        hResult = InstallOnNT( lpszInstallSection, szSourceDir );
        if ( FAILED( hResult ) )
        {
            if ( !FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                                szErrorText, sizeof(szErrorText), NULL) )
            {
                LoadSz( IDS_ERR_FMTMSG, szErrorText, sizeof(szErrorText) );
                if ( *szErrorText == 0 )
                    lstrcpy( szErrorText, "Could not get the system message. You may run out of the resource." );
            }

            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_FAILURE, szErrorText );
        }
    }

    return hResult;
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetValueFromRegistry                                        *
//*                                                                         *
//* SYNOPSIS:   Get an app-path out of the registry as specified.           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    BOOL: Error result, FALSE == ERROR                          *
//*                                                                         *
//***************************************************************************
BOOL GetValueFromRegistry( LPSTR szPath, UINT cbPath, LPSTR szKey,
                           LPSTR szSubKey, LPSTR szVName )
{
    HKEY  hkPath = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    HKEY  hkRoot = NULL;
    PSTR  pszTemp = NULL;

    // Figure out what root key they want to check

    if ( lstrcmpi( szKey, "HKCR" ) == 0 ) {
        hkRoot = HKEY_CLASSES_ROOT;
    } else if ( lstrcmpi( szKey, "HKCU" ) == 0 ) {
        hkRoot = HKEY_CURRENT_USER;
    } else if ( lstrcmpi( szKey, "HKLM" ) == 0 ) {
        hkRoot = HKEY_LOCAL_MACHINE;
    } else if ( lstrcmpi( szKey, "HKU" ) == 0 ) {
        hkRoot = HKEY_USERS;
    } else if ( *szKey == '\0' ) {
        // If they don't specify a root key, then assume they don't want to check
        // the registry.  So just return as if the registry key doesn't exist.
        return FALSE;
    } else {
        ErrorMsg( ctx.hWnd, IDS_ERR_INVALID_REGROOT );
        return FALSE;
    }

    // Get Path to program from the registry

    if ( RegOpenKeyEx( hkRoot, szSubKey, (ULONG) 0, KEY_READ, &hkPath ) != ERROR_SUCCESS ) {
        return( FALSE );
    }

    dwSize = cbPath;
    if ( RegQueryValueEx( hkPath, szVName, NULL, &dwType, (LPBYTE) szPath, &dwSize)
         != ERROR_SUCCESS )
    {
        RegCloseKey( hkPath );
        return( FALSE );
    }

    RegCloseKey( hkPath );

    // If we got nothing or it wasn't a string then we bail out
    if ( (dwSize == 0) || (dwType != REG_SZ && dwType != REG_EXPAND_SZ) ) {
        return( FALSE );
    }

    if ( dwType == REG_EXPAND_SZ ) {
        pszTemp = (PSTR) LocalAlloc( LPTR, cbPath );
        if ( pszTemp == NULL ) {
            return( FALSE );
        }
        lstrcpy( pszTemp, szPath );
        dwSize = ExpandEnvironmentStrings( pszTemp, szPath, cbPath );
        LocalFree( pszTemp );

        if ( dwSize == 0 || dwSize > cbPath ) {
            return( FALSE );
        }
    }

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       SetLDIDs                                                    *
//*                                                                         *
//* SYNOPSIS:   Sets the LDIDs as specified in the INF file.                *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//* NOTE:       If c_pszSourceDir != NULL then we want to set the source    *
//*             directory and nothing else.                                 *
//*                                                                         *
//***************************************************************************
HRESULT SetLDIDs( PCSTR c_pszInfFilename, PCSTR c_pszInstallSection,
                  DWORD dwInstNeedSize, PCSTR c_pszSourceDir )
{
    CHAR    szDestSection[256];
    CHAR    szDestLDIDs[512];
    PSTR    pszDestLDID          = NULL;
    PSTR    pszNextDestLDID      = NULL;
    CHAR    szDestData[256];
    DWORD   dwStringLength       = 0;
    LPSTR   pszCustomSection;
    DWORD   dwLDID[4]            = { 0 };
    DWORD   dwSwitches           = 0;
    DWORD   i                    = 0;
    DWORD   dwFlag               = 1;
    HRESULT hResult              = S_OK;
    CHAR    szBuffer[MAX_PATH+2];
    static const CHAR c_szCustDest[] = "CustomDestination";
    static const CHAR c_szSourceDirKey[] = "SourceDir";
    PSTR    pszTmp;

    // Get section name that specifies the custom LDID information.

    if ( FAILED(GetTranslatedString( c_pszInfFilename, c_pszInstallSection, c_szCustDest,
                                     szDestSection, sizeof(szDestSection), NULL)))
    {
        // There is no Custom Destination specification -- this probably
        // means they didn't want to have a custom destination section,
        // so we just return with a warm, tingly feeling
        hResult = S_OK;
        goto done;
    }

    // author defined CustomDestination, so add some system directories to the reg before continuing
    SetSysPathsInReg();


    dwStringLength = GetTranslatedSection( c_pszInfFilename, szDestSection,
                                           szDestLDIDs, sizeof(szDestLDIDs));
    if ( dwStringLength == 0 ) {
        ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, szDestSection );
        hResult = E_FAIL;
        goto done;
    }

    pszDestLDID = szDestLDIDs;

    while ( *pszDestLDID != '\0' ) {
        pszNextDestLDID = pszDestLDID + lstrlen(pszDestLDID) + 1;

        if (*pszDestLDID == ';')
        {
            pszDestLDID = pszNextDestLDID;
            continue;
        }

#if 0
        hResult = GetTranslatedString( c_pszInfFilename, szDestSection, pszDestLDID,
                                         szDestData, sizeof(szDestData), NULL);

        if (FAILED(hResult))
        {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, szDestSection );
            goto done;
        }
#endif

        if ( pszTmp = ANSIStrChr(pszDestLDID, '=') )
        {
            lstrcpy(szDestData, CharNext(pszTmp));
            *pszTmp = '\0';
        }
        else
        {
            // invalid define LDID line skip
            pszDestLDID = pszNextDestLDID;
            continue;
        }

        // Parse out the information in this line.
        dwFlag = ParseDestinationLine( pszDestLDID, szDestData, &pszCustomSection,
                                       &dwLDID[0], &dwLDID[1], &dwLDID[2], &dwLDID[3] );
        if ( dwFlag == -1 ) {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, szDestSection );
            hResult = E_FAIL;
            goto done;
        }

        if ( lstrcmpi( pszCustomSection, c_szSourceDirKey ) == 0 )
        {
            if ( c_pszSourceDir == NULL )
            {
                // The line specifies "SourceDir" but we don't want to set the source dir
                pszDestLDID = pszNextDestLDID;
                continue;
            }
        }
        else
        {
            if ( c_pszSourceDir != NULL )
            {
                // The line doesn't specify "SourceDir" but we want to set the source dir
                pszDestLDID = pszNextDestLDID;
                continue;
            }
        }

        if ( c_pszSourceDir != NULL )
        {
            // szBuffer is MAX_PATH big and c_pszSourceDir is a path, so we
            // shouldn't have a problem.

            lstrcpy( szBuffer, c_pszSourceDir );
        }
        else
        {
            hResult = GetDestinationDir( c_pszInfFilename, pszCustomSection, dwFlag,
                                         dwInstNeedSize, szBuffer, sizeof(szBuffer) );
            if ( FAILED(hResult) ) {
            // Error message displayed in GetDestinationDir
            goto done;
            }
        }

        for ( i = 0; i < 4; i += 1 )
        {
            // Default is ANSI LFN
            dwSwitches = 0;

        if ( dwLDID[i] == 0 ) {
            continue;
        }

        if ( i == 0 || i == 3 ) {
            dwSwitches |= LDID_OEM_CHARS;
        }

        if (    (i == 0 || i == 2)
                && (dwFlag & FLAG_VALUE && !(dwFlag & FLAG_NODIRCHECK) ) )
        {
            dwSwitches |= LDID_SFN;
            if ((i==0) && (dwLDID[3] != 0) )
            {
                dwSwitches |= LDID_SFN_NT_ALSO;
            }

            if ((i==2) && (dwLDID[1] != 0))
            {
                dwSwitches |= LDID_SFN_NT_ALSO;
            }
        }

        hResult = CtlSetLddPath( dwLDID[i], szBuffer, dwSwitches );
        if ( FAILED( hResult ) )
        {
            // Error message is displayed in ClSetLddPath function.
            goto done;
        }
     }

     pszDestLDID = pszNextDestLDID;
  }

  done:

    return hResult;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetDestinationDir                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT GetDestinationDir( PCSTR c_pszInfFilename, PCSTR c_pszCustomSection,
                           DWORD dwFlag, DWORD dwInstNeedSize,
                           PSTR pszBuffer, DWORD dwBufferSize )
{
    BOOL    fFoundRegKey         = FALSE;
    BOOL    fFoundLine           = FALSE;
    DWORD   j                    = 0;
    PSTR    pszCustomData        = NULL;
    PSTR    pszCurCustomData     = NULL;
    LPSTR   pszRootKey           = NULL;
    LPSTR   pszBranch            = NULL;
    LPSTR   pszValueName         = NULL;
    LPSTR   pszPrompt            = NULL;
    LPSTR   pszDefault           = NULL;
    HRESULT hResult              = S_OK;
    CHAR   szValue[MAX_PATH+2];

    ASSERT( pszBuffer != NULL );

    // Reset reg key found flag.  For each custom destination, we want to set
    // this flag to TRUE if any one of the registry keys are found.
    fFoundRegKey = FALSE;
    fFoundLine = FALSE;

    for ( j = 0; ; j += 1 )
    {
        if ( FAILED( GetTranslatedLine( c_pszInfFilename, c_pszCustomSection,
                                        j, &pszCurCustomData, NULL ) ) || !pszCurCustomData )
        {
            break;
        }

        fFoundLine = TRUE;

        // save the last valid customData line before the break off
        if ( pszCustomData )
        {
            LocalFree( pszCustomData );
        }
        pszCustomData = pszCurCustomData;

        // Parse out the fields in the custom destination line.
        if ( ! ParseCustomLine( pszCustomData, &pszRootKey, &pszBranch,
                                &pszValueName, &pszPrompt, &pszDefault, TRUE, TRUE ) )
        {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, c_pszCustomSection );
            hResult = E_FAIL;
            goto done;
        }

        // Check the specified registry branch and grab the contents.
        if ( GetValueFromRegistry( szValue, sizeof(szValue), pszRootKey, pszBranch, pszValueName )
                            == TRUE )
        {
            LPSTR pszTmp;

            // If the INF says to strip trailing semi-colon,
            // and there is a trailing semi-colon,
            // then strip it.

            if ( !( dwFlag & FLAG_NOSTRIP ) )
            {
                if ( dwFlag & FLAG_STRIPAFTER_FIRST )
                {
                    pszTmp = ANSIStrChr( szValue, ';' );
                    if ( pszTmp )
                        *pszTmp = '\0';
                }
                else
                {
                   if ( szValue[lstrlen(szValue)-1] == ';' )
                   {
                       szValue[lstrlen(szValue)-1] = '\0';
                   }
                }
            }

           // strip off the trailing blanks
           pszTmp = szValue;
           pszTmp += lstrlen(szValue) - 1;

           while ( *pszTmp == ' ' )
           {
               *pszTmp = '\0';
               pszTmp -= 1;
           }

            // If the INF says to check if directory exists,
            // and the directory doesn't exist,
            // then treat as if the reg key wasn't found

            if ( ! ( dwFlag & FLAG_NODIRCHECK )
                 && ! DirExists( szValue ) )
            {
                // Directory doesn't exist.  Don't break out of loop.
            }
            else
            {
                // Directory exists
                // If the INF says to save the branch in the LDID,
                // then save the branch.
                // Otherwise save the value.
                if ( dwFlag & FLAG_VALUE )
                {
                    pszDefault = szValue;
                }
                else
                {
                    pszDefault = pszBranch;
                }

                fFoundRegKey = TRUE;
                break;
            }
        }
            // Note;  If the registry key is not found, then the defaults as specified in
            // the INF file are used.
    }

    if ( ! fFoundLine ) {
        ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, c_pszCustomSection );
        hResult = E_FAIL;
        goto done;
    }

    // 2 specified + 32 not specified + not found reg
    // 2 specified + 32     specified +     found reg
    if ( ((dwFlag & FLAG_FAIL) && (!(dwFlag & FLAG_FAIL_NOT)) && (fFoundRegKey == FALSE))
         || ((dwFlag & FLAG_FAIL) &&   (dwFlag & FLAG_FAIL_NOT)  && (fFoundRegKey == TRUE)) )
    {
        // NOTE: This uses the prompt specified in the INF file.
        ErrorMsg1Param( ctx.hWnd, IDS_PROMPT, pszPrompt );
        hResult = E_FAIL;
        goto done;
    }

    // Prompt the user for the destination directory.
    if ( (dwFlag & FLAG_VALUE) && (! (dwFlag & FLAG_NODIRCHECK)) )
    {
        if ( ctx.wQuietMode || (dwFlag & FLAG_QUIET) )
        {
            lstrcpy( szValue, pszDefault );

            // check if the directory has enough disk space to install the program
            if ( !IsFullPath(szValue) ) {
                hResult = E_FAIL;
                goto done;
            }

            if ( !IsEnoughInstSpace( szValue, dwInstNeedSize, NULL ) ) {
                ErrorMsg( ctx.hWnd, IDS_ERR_USER_CANCEL_INST );
                hResult = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
                goto done;
            }

            if ( ! DirExists( szValue ) ) {
                hResult = CreateFullPath( szValue, FALSE );
                if ( FAILED(hResult) ) {
                    goto done;
                }
            }
            if ( ! IsGoodDir( szValue ) )  {
                hResult = E_FAIL;
                goto done;
            }

            pszDefault = szValue;
        }
        else
        {
            CHAR szLFNValue[MAX_PATH*2];

            MakeLFNPath(pszDefault, szLFNValue, TRUE);
            if ( UserDirPrompt( pszPrompt, szLFNValue, szValue, sizeof(szValue), dwInstNeedSize ) )
            {
                pszDefault = szValue;
            }
            else
            {
                ErrorMsg( ctx.hWnd, IDS_ERR_USER_CANCEL_INST );
                hResult = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                goto done;
            }
        }
    }

    if ( (DWORD)lstrlen(pszDefault) >= dwBufferSize ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_TOO_BIG );
        hResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }

    lstrcpy( pszBuffer, pszDefault );

  done:
    // free the buf allocated by GetTranslatedLine
    if ( pszCustomData )
    {
        if ( pszCustomData == pszCurCustomData )
            pszCurCustomData = NULL;
        LocalFree( pszCustomData );
    }

    if ( pszCurCustomData )
    {
        LocalFree( pszCurCustomData );
    }

    return hResult;
}


//***************************************************************************
//*                                                                         *
//* NAME:       DirExists                                                   *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL DirExists( LPSTR szDir )
{
    DWORD dwAttribs = 0;

    if ( szDir == NULL ) {
        return FALSE;
    }

    dwAttribs = GetFileAttributes( szDir );
    if ( ( dwAttribs != 0xFFFFFFFF )
         && ( dwAttribs & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        return TRUE;
    }

    return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ParseDestinationLine                                        *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//* Bitwise flags:                                                          *
//*                                                                         *
//*  bit  Off                        On                             Value   *
//*  ---  --------------------       ----------------------------   -----   *
//*  0    Get value                  Get branch                     1       *
//*  1    Use default if none exist  Fail if none exist             2       *
//*  2    Non-quiet mode             Quiet mode                     4       *
//*  3    Strip trailing ";"         Don't strip trailing ";"       8       *
//*  4    Treat value as directory   Treat value as plain string    16      *
//*                                                                         *
//***************************************************************************
DWORD ParseDestinationLine( PSTR pszLDIDs, PSTR pszValue, PSTR *ppszSectionName,
                            PDWORD pdwLDID1, PDWORD pdwLDID2,
                            PDWORD pdwLDID3, PDWORD pdwLDID4 )
{
    PSTR  pszPoint  = NULL;
    DWORD dwFlag    = DEFAULT_FLAGS;
    DWORD dwLDID[4] = { 0 };
    DWORD i         = 0;
    PSTR  pszStr;

    pszPoint = pszLDIDs;

    for ( i = 0; i < 4; i += 1 )
    {
        // Parse the arguments, SETUP engine is not called. So we only need to check on \'
        pszStr = GetStringField( &pszPoint, ",", '\"', TRUE );

        if ( pszStr == NULL )
        {
            dwLDID[i] = 0;
        }
        else
        {
            dwLDID[i] = (DWORD) My_atol(pszStr);
        }
    }

    *pdwLDID1 = dwLDID[0];
    *pdwLDID2 = dwLDID[1];
    *pdwLDID3 = dwLDID[2];
    *pdwLDID4 = dwLDID[3];

    pszStr = pszValue;
    *ppszSectionName = GetStringField( &pszStr, ",", '\"', TRUE );
    if ( *ppszSectionName == NULL || **ppszSectionName == '\0' ) {
        return (DWORD)-1;
    }

    pszPoint = GetStringField( &pszStr, ",", '\"', TRUE );
    if ( pszPoint != NULL && *pszPoint != '\0' ) {
        dwFlag = (DWORD) My_atol(pszPoint);
    }

    // Special case this.  We definitely don't want to prompt the user
    // for a registry branch to use!
    if ( !( dwFlag & FLAG_VALUE ) ) {
        dwFlag |= FLAG_QUIET;
    }

    return dwFlag;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ParseCustomLine                                             *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL ParseCustomLine( PSTR pszCheckKey, PSTR *ppszRootKey, PSTR *ppszBranch,
                      PSTR *ppszValueName, PSTR *ppszPrompt, PSTR *ppszDefault,
                      BOOL bStripWhiteSpace, BOOL bProcQuote )
{
    DWORD i           = 0;
    PSTR  pszField[5] = { NULL };
    BOOL  bRet = TRUE;

    for ( i = 0; i < 5; i++ )
    {
        // Parse the arguments, SETUP engine has processed \" so we only need to check on \'
        if (bProcQuote)
            pszField[i] = GetStringField( &pszCheckKey, ",", '\'', bStripWhiteSpace );
        else
            pszField[i] = GetStringFieldNoQuote( &pszCheckKey, ",", bStripWhiteSpace );

        if ( pszField[i] == NULL )
        {
            bRet = FALSE;
            break;
        }
    }

    *ppszRootKey   = pszField[0];
    *ppszBranch    = pszField[1];
    *ppszValueName = pszField[2];
    *ppszPrompt    = pszField[3];
    *ppszDefault   = pszField[4];

    return bRet;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RegisterOCXs                                                *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL RegisterOCXs( LPSTR szInfFilename, LPSTR szInstallSection,
                   BOOL fNeedReboot, BOOL fRegister, DWORD dwFlags )
{
    HRESULT hReturnCode              = S_OK;
    BOOL    fOleInitialized          = TRUE;
    PSTR    pszOCXLine               = NULL;
    BOOL    fSuccess                 = TRUE;
    PSTR    pszSection               = NULL;
    DWORD   i                        = 0;
    REGOCXDATA  RegOCX = { 0 };
    CHAR   szRegisterSection[256];
    PSTR    pszNotUsed;
    static const CHAR c_szREGISTEROCXSECTION[]   = "RegisterOCXs";
    static const CHAR c_szUNREGISTEROCXSECTION[] = "UnRegisterOCXs";

    // If we want to register, then use the register section.
    // If we want to unregister, then use the unregister section.
    if ( fRegister )
    {
        if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            pszSection = (PSTR) c_szUNREGISTEROCXSECTION;
            if ( FAILED(GetTranslatedString( szInfFilename, szInstallSection, pszSection,
                                             szRegisterSection, sizeof(szRegisterSection), NULL)))
            {
                pszSection = (PSTR) c_szREGISTEROCXSECTION;
            }
        }
        else
            pszSection = (PSTR) c_szREGISTEROCXSECTION;
    }
    else
    {
        // if it is call with ROLLBACKL flag on,
        // we have backed up all the files and reg data.  Now we need to unregist (the new)OCXs from Register list
        // before register the old one.
        //
        if ( dwFlags & COREINSTALL_ROLLBACK )
            pszSection = (PSTR) c_szREGISTEROCXSECTION;
        else
            pszSection = (PSTR) c_szUNREGISTEROCXSECTION;
    }

    // Grab the section name of the Register OCX section
    if ( FAILED(GetTranslatedString( szInfFilename, szInstallSection, pszSection,
                                     szRegisterSection, sizeof(szRegisterSection), NULL)))
    {
        // There is no Register OCX section. Assume the user wanted it that
        // way and return with a big smile.
        return TRUE;
    }

    if ( FAILED( OleInitialize( NULL ) ) )
    {
        fOleInitialized = FALSE;
    }
#pragma prefast(disable:56,"False warning at OemToChar line. Using workaround to disable it - PREfast bug 643")
    for ( i = 0; ; i += 1 )
    {
        if ( pszOCXLine )
        {
            LocalFree( pszOCXLine );
            pszOCXLine = NULL;
        }

        if ( FAILED( GetTranslatedLine( szInfFilename, szRegisterSection, i, &pszOCXLine, NULL ) ) )
        {
            break;
        }

        // process OCX line:  Name [,<switch>,<str>] where switch - i== call both entries; in == only call
        // DllRegister; n == call none;  Empty means just call old  DllRegister.
        ParseCustomLine( pszOCXLine, &(RegOCX.pszOCX), &(RegOCX.pszSwitch), &(RegOCX.pszParam), &pszNotUsed, &pszNotUsed, TRUE, FALSE );

        if ( ctx.dwSetupEngine == ENGINE_SETUPX ) {
            OemToChar( RegOCX.pszOCX, RegOCX.pszOCX );
        }

        // before re-regiester OCX at ROLLBACK case, we need to check if the file exists.
        // IF not, we don't want to try to register it.
        if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            DWORD dwAttr;

            dwAttr = GetFileAttributes( RegOCX.pszOCX );
            if ( (dwAttr == -1 ) || (dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
            {
                //skip this one
                continue;
            }
        }

        // If we need to reboot, then just add registrations to the run once entry.
        // Otherwise try to register right away.
        // If we are unregistering OCXs, then fNeedReboot should always be FALSE,
        // since unregistration happens before a GenInstall.

        if ( !fNeedReboot && ( !fRegister || !(dwFlags & COREINSTALL_DELAYREGISTEROCX) ) )
        {
            // no reboot case, the last one params are ignored.
            if ( !InstallOCX( &RegOCX, TRUE, fRegister, i ) && !(dwFlags & COREINSTALL_ROLLBACK) )
            {
                fSuccess = FALSE;

                if ( fRegister )
                {
                    ErrorMsg1Param( ctx.hWnd, IDS_ERR_REG_OCX, RegOCX.pszOCX );
                    goto done;
                }
                else
                {
                    ErrorMsg1Param( ctx.hWnd, IDS_ERR_UNREG_OCX, RegOCX.pszOCX );
                }
            }
        }
        else
        {

            // Add a runonce entry so that the OCX is registered on next boot.
            //
            if ( !InstallOCX( &RegOCX, FALSE, fRegister, i ) )
            {
                ErrorMsg1Param( ctx.hWnd, IDS_ERR_RUNONCE_REG_OCX, RegOCX.pszOCX );
                fSuccess = FALSE;
                goto done;
            }
        }

    }
#pragma prefast(enable:56,"")
done:

    if ( fOleInitialized ) {
        OleUninitialize();
    }

    if ( pszOCXLine )
    {
        LocalFree( pszOCXLine );
    }

    return fSuccess;
}

//***************************************************************************
//*                                                                         *
//* NAME:       DelDirs                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
void DelDirs( LPCSTR szInfFilename, LPCSTR szInstallSection )
{
    PSTR   pszFolder = NULL;
    CHAR   szDelDirsSection[MAX_PATH];
    DWORD   i = 0;

    if ( FAILED(GetTranslatedString( szInfFilename, szInstallSection, ADVINF_DELDIRS,
                                     szDelDirsSection, sizeof(szDelDirsSection), NULL)))
    {
        // no demands on remove folders
        return;
    }

    for ( i = 0; ; i++ )
    {
        if ( FAILED( GetTranslatedLine( szInfFilename, szDelDirsSection,
                                        i, &pszFolder, NULL ) ) || !pszFolder )
        {
            break;
        }

        MyRemoveDirectory( pszFolder );

        LocalFree( pszFolder );
        pszFolder = NULL;
    }
    return;
}

//***************************************************************************
//*                                                                         *
//* NAME:       DoCleanup                                                    *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
void DoCleanup( LPCSTR szInfFilename, LPCSTR szInstallSection )
{
    int iFlags;

    iFlags = GetTranslatedInt(szInfFilename, szInstallSection, ADVINF_CLEANUP, 0);

    if ( iFlags & CLEN_REMVINF )
    {
    	DeleteFile( szInfFilename );
    }

    return;
}

// greater than 4.71.0219
//
#define ROEX_VERSION_MS 0x00040047      // 4.71
#define ROEX_VERSION_LS 0x00DB0000      // 0219.0


BOOL UseRunOnceEx()
{
    DWORD dwMV, dwLV;
    BOOL  bRet = FALSE;
    char  szPath[MAX_PATH] = "";
    char  szBuf[MAX_PATH] = "";
    DWORD dwTmp;

    GetSystemDirectory( szPath,sizeof( szPath ) );
    AddPath( szPath, "iernonce.dll" );
    GetVersionFromFile( szPath, &dwMV, &dwLV, TRUE );

    // greater than 4.71.0230
    //
    if ( ( dwMV > ROEX_VERSION_MS ) || (( dwMV == ROEX_VERSION_MS ) && ( dwLV >= ROEX_VERSION_LS ))  )
    {
        GetWindowsDirectory( szBuf, MAX_PATH );
        AddPath( szBuf, "explorer.exe" );
        GetVersionFromFile( szBuf, &dwMV, &dwLV, TRUE );
        if (( dwMV < ROEX_VERSION_MS) || (( dwMV == ROEX_VERSION_MS) && ( dwLV < ROEX_VERSION_LS )) )
        {
            HKEY hkey;
            if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, (ULONG)0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dwTmp ) == ERROR_SUCCESS )
            {
                wsprintf( szBuf, RUNONCE_IERNONCE, szPath );
                if ( RegSetValueEx( hkey, RUNONCEEX, 0, REG_SZ, (CONST UCHAR *)szBuf, lstrlen(szBuf)+1 )
                                    != ERROR_SUCCESS )
                {
                    bRet = FALSE;
                    RegCloseKey( hkey );
                    goto done;
                }
                RegCloseKey( hkey );
            }
            else
                bRet = FALSE;
        }
        bRet = TRUE;
    }

done:
    return bRet;
}

void GetNextRunOnceExSubKey( HKEY hKey, PSTR pszSubKey, int *piSubKeyNum )
{
    HKEY hSubKey;

    for (;;)
    {
        wsprintf( pszSubKey, "%d", ++*piSubKeyNum );
        if ( RegOpenKeyEx( hKey, pszSubKey,(ULONG) 0, KEY_READ, &hSubKey ) != ERROR_SUCCESS )
        {
            break;
        }
        else
        {
            RegCloseKey( hSubKey );
        }
    }
}

void GetNextRunOnceValName( HKEY hKey, PCSTR pszFormat, PSTR pszValName, int line )
{

    do
    {
        wsprintf( pszValName, pszFormat, line++ );

    } while ( RegQueryValueEx( hKey, pszValName, 0, NULL, NULL, NULL ) == ERROR_SUCCESS );

}


BOOL DoDllReg( HANDLE hOCX, BOOL fRegister )
{
    FARPROC   lpfnDllRegisterServer = NULL;
    PSTR      pszRegSvr             = NULL;
    BOOL      fSuccess              = FALSE;

    if ( fRegister )
    {
        pszRegSvr = (PSTR) achREGSVRDLL;
    }
    else
    {
        pszRegSvr = (PSTR) achUNREGSVRDLL;
    }

    lpfnDllRegisterServer = GetProcAddress( hOCX, pszRegSvr );
    if ( lpfnDllRegisterServer )
    {
        if ( SUCCEEDED( lpfnDllRegisterServer() ) )
        {
            fSuccess = TRUE;
        }
    }
    return fSuccess;
}

BOOL DoDllInst( HANDLE hOCX, BOOL fRegister, PCSTR pszParam )
{
    WCHAR   pwstrDllInstArg[MAX_PATH];
    DLLINSTALL  pfnDllInstall = NULL;
    BOOL    fSuccess = FALSE;

    if ( pszParam == NULL )
        pszParam = "";

    pfnDllInstall = (DLLINSTALL)GetProcAddress( hOCX, "DllInstall" );
    if ( pfnDllInstall )
    {
        MultiByteToWideChar(CP_ACP, 0, pszParam, -1, pwstrDllInstArg, ARRAYSIZE(pwstrDllInstArg));

        if ( SUCCEEDED( pfnDllInstall( fRegister, pwstrDllInstArg ) ) )
            fSuccess = TRUE;
    }
    return fSuccess;
}


//***************************************************************************
//*                                                                         *
//* NAME:       InstallOCX                                                  *
//*                                                                         *
//* SYNOPSIS:   Self-registers the OCX.                                     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL InstallOCX( PREGOCXDATA pRegOCX, BOOL fDoItNow, BOOL fRegister, int line )
{
    PSTR   lpszCmdLine  = NULL;
    PSTR   lpszCmdLine2  = NULL;
    BOOL    fSuccess     = TRUE;
    HKEY    hKey = NULL, hSubKey = NULL;
    HANDLE  hOCX = NULL;
    BOOL    bDoDllReg = TRUE, bDoDllInst = FALSE;
    PSTR    pszCmds[2] = { 0 };
    int     i;

    AdvWriteToLog("InstallOCX: %1 %2\r\n", pRegOCX->pszOCX, fRegister?"Register":"UnRegister" );
    // parse what kind OCX entry points to call
    if ( pRegOCX->pszSwitch && *pRegOCX->pszSwitch )
    {
        if ( ANSIStrChr( CharUpper(pRegOCX->pszSwitch), 'I' ) )
        {
            bDoDllInst = TRUE;
            if ( ANSIStrChr( CharUpper(pRegOCX->pszSwitch), 'N' ) )
                bDoDllReg = FALSE;
        }
        else
        {
            fSuccess = FALSE;
            goto done;
        }
    }

    lpszCmdLine = (LPSTR) LocalAlloc( LPTR,   BUF_1K );
    lpszCmdLine2 = (LPSTR) LocalAlloc( LPTR,   BUF_1K );
    if ( !lpszCmdLine || !lpszCmdLine2) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        fSuccess = FALSE;
        goto done;
    }

    // fDoItNow says whether we should add to runonce or register the OCX right away
    if ( fDoItNow )
    {
        LPCSTR              szExtension           = NULL;

        // ignore the display name line in this case
        if ( *(pRegOCX->pszOCX) == '@' )
        {
            goto done;
        }

        // Figure out what type of OCX we are trying to register: two choices
        //   1. EXE
        //   2. DLL/OCX/etc
        //
        szExtension = &pRegOCX->pszOCX[lstrlen(pRegOCX->pszOCX)-3];

        if ( lstrcmpi( szExtension, "EXE" ) == 0 )
        {
            PSTR   pszRegSvr;

            if ( fRegister )
                pszRegSvr = (PSTR) achREGSVREXE;
            else
                pszRegSvr = (PSTR) achUNREGSVREXE;

            lstrcpy( lpszCmdLine, pRegOCX->pszOCX );
            lstrcat( lpszCmdLine, pszRegSvr );


            if ( LaunchAndWait( lpszCmdLine, NULL, NULL, INFINITE, 0 ) == E_FAIL )
            {
                AdvWriteToLog("InstallOCX: %1 Failed\r\n", lpszCmdLine);
                fSuccess = FALSE;
                goto done;
            }
            AdvWriteToLog("%1 : Succeeded.\r\n", lpszCmdLine);
        }
        else
        {
            AdvWriteToLog("LoadLibrary %1\r\n", pRegOCX->pszOCX);
            hOCX = LoadLibraryEx( pRegOCX->pszOCX, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
            if ( hOCX == NULL )
            {
                fSuccess = FALSE;
                goto done;
            }

            // Install time order:  DllRegisterServer, DllInstall
            // Uninstall order:  DllInstall, DllRegisterServer
            if ( fRegister )
            {
                if ( bDoDllReg )
                {
                    fSuccess = DoDllReg( hOCX, fRegister );
                    AdvWriteToLog("Register: DoDllReg: %1\r\n", fSuccess?"Succeeded":"Failed" );
                }

                if ( fSuccess && bDoDllInst )
                {
                    fSuccess = DoDllInst( hOCX, fRegister, pRegOCX->pszParam );
                    AdvWriteToLog("Register: DoDllInstall: %1\r\n", fSuccess?"Succeeded":"Failed" );
                }
            }
            else
            {
                if ( bDoDllInst )
                {
                    fSuccess = DoDllInst( hOCX, fRegister, pRegOCX->pszParam );
                    AdvWriteToLog("UnRegister: DoDllReg: %1\r\n", fSuccess?"Succeeded":"Failed" );
                }

                if ( fSuccess && bDoDllReg )
                {
                    fSuccess = DoDllReg( hOCX, fRegister );
                    AdvWriteToLog("UnRegister: DoDllInstall: %1\r\n", fSuccess?"Succeeded":"Failed" );
                }
            }
        }
    }
    else
    {
        // Add to runonce or runonceex
        // from current logic, Unregister OCX will never be here!
        //
        char    szPath[MAX_PATH];
        LPCSTR  lpRegTmp;
        DWORD   dwTmp;
        HKEY    hRealKey;
        static BOOL bRunOnceEx       = FALSE;
        static int iSubKeyNum        = 0;

        if ( iSubKeyNum == 0 )
        {
            if ( UseRunOnceEx() )
            {
                iSubKeyNum = 799;
                bRunOnceEx = TRUE;
            }
        }

        // decide to add the entry to RunOnce or RunOnceEx
        if ( !bRunOnceEx )
        {
            // ignore the display name line in this case
            if ( *(pRegOCX->pszOCX) == '@' )
            {
                goto done;
            }
            // no ierunonce.dll, use RunOnce key rather than RunOnceEx key
            lpRegTmp = REGSTR_PATH_RUNONCE;
        }
        else
        {
            lpRegTmp = REGSTR_PATH_RUNONCEEX;
        }

        // open RunOnce or RunOnceEx key here
        if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, lpRegTmp, (ULONG)0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, &dwTmp ) != ERROR_SUCCESS )
        {
            fSuccess = FALSE;
            goto done;
        }

        // Generate the next unused SubKey name
        //
        if ( bRunOnceEx )
        {
            if ( line == 0 )
                GetNextRunOnceExSubKey( hKey, szPath, &iSubKeyNum );
            else
                wsprintf( szPath, "%d", iSubKeyNum );
        }

        // Generate the Value Name and ValueData.
        //
        if ( bRunOnceEx )
        {
            if ( RegCreateKeyEx( hKey, szPath, (ULONG)0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                 NULL, &hSubKey, &dwTmp ) != ERROR_SUCCESS )
            {
                fSuccess = FALSE;
                goto done;
            }

            // if use RunOnceEx, process @ leaded display name.
            if ( *pRegOCX->pszOCX == '@' )
            {
                if ( RegSetValue( hKey, szPath, REG_SZ, (LPCSTR)CharNext(pRegOCX->pszOCX),
                                  lstrlen(CharNext(pRegOCX->pszOCX))+1 ) != ERROR_SUCCESS )
                {
                    fSuccess = FALSE;
                }
                goto done;
            }

            GetNextRunOnceValName( hSubKey, "%03d", szPath, line );
            if ( bDoDllReg )
            {
                wsprintf( lpszCmdLine, RUNONCEEXDATA, pRegOCX->pszOCX, fRegister? achREGSVRDLL : achUNREGSVRDLL );
            }

            if ( bDoDllInst )
            {
                wsprintf( lpszCmdLine2, "%s|%s|%c,%s",pRegOCX->pszOCX, "DllInstall",
                          fRegister? 'i':'u', pRegOCX->pszParam ? pRegOCX->pszParam : "" );
            }
            hRealKey = hSubKey;
            if ( fRegister )
            {
                pszCmds[0] = lpszCmdLine;
                pszCmds[1] = lpszCmdLine2;
            }
            else
            {
                pszCmds[1] = lpszCmdLine;
                pszCmds[0] = lpszCmdLine2;
            }
        }
        else
        {
            GetNextRunOnceValName( hKey, achIEXREG, szPath, line );
            wsprintf( lpszCmdLine, achRUNDLL, pRegOCX->pszOCX,
                      pRegOCX->pszSwitch ?pRegOCX->pszSwitch:"",
                      pRegOCX->pszParam ? pRegOCX->pszParam : "" );
            hRealKey = hKey;
            pszCmds[0] = lpszCmdLine;
            pszCmds[1] = "";
        }

        for ( i=0; i<2; i++ )
        {
            if (*pszCmds[i])
            {
                AdvWriteToLog("Delay Register: Value=%1  Data=%2\r\n", szPath, pszCmds[i]);
                if ( RegSetValueEx( hRealKey, szPath, 0, REG_SZ, (CONST UCHAR *) pszCmds[i], lstrlen(pszCmds[i])+1 )
                                    != ERROR_SUCCESS )
                {
                    fSuccess = FALSE;
                    goto done;
                }

                if ( bRunOnceEx )
                    GetNextRunOnceValName( hRealKey, "%03d", szPath, line );
            }
        }
    }

done:

    if ( hOCX != NULL ) {
        FreeLibrary( hOCX );
    }

    if ( hSubKey != NULL ) {
        RegCloseKey( hSubKey );
    }

    if ( hKey != NULL ) {
        RegCloseKey( hKey );
    }

    if ( lpszCmdLine != NULL ) {
        LocalFree( lpszCmdLine );
    }

    if ( lpszCmdLine2 != NULL )
        LocalFree( lpszCmdLine2 );

    AdvWriteToLog("InstallOCX: End %1\r\n", pRegOCX->pszOCX);
    return fSuccess;
}


//***************************************************************************
//
// FormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc, LPCSTR lpFile );
//
// This function can be easily described by giving examples of what it
// does:
//        Input:  GenFormStrWithoutPlaceHolders(dest,"desc=%MS_XYZ%", hinf) ;
//                INF file has MS_VGA="Microsoft XYZ" in its [Strings] section!
//
//        Output: "desc=Microsoft XYZ" in buffer dest when done.
//
//
// ENTRY:
//  szDst         - the destination where the string after the substitutions
//                  for the place holders (the ones enclosed in "%' chars!)
//                  is placed. This buffer should be big enough (LINE_LEN)
//  szSrc         - the string with the place holders.
//
// EXIT:
//
//***************************************************************************
DWORD FormStrWithoutPlaceHolders( LPCSTR szSrc, LPSTR szDst, DWORD dwDstSize, LPCSTR szInfFilename )
{
    INT     uCnt ;
    CHAR   *pszTmp;
    LPSTR  pszSaveDst;

    pszSaveDst = szDst;

    // Do until we reach the end of source (null char)
    while( ( *szDst++ = *szSrc ) )
    {
        // Increment source as we have only incremented destination above
        if( *szSrc++ == '%' ) {
            if ( *szSrc == '%' ) {
                // One can use %% to get a single percentage char in message
                szSrc++;
                continue;
            }

            // see if it is well formed -- there should be a '%' delimiter

            pszTmp = (LPSTR) szSrc;
            while ( (*pszTmp != '\0') && (*pszTmp != '%') )
            {
                pszTmp += 1;
            }

            if ( *pszTmp == '%' ) {
                szDst--; // get back to the '%' char to replace

            // yes, there is a STR_KEY to be looked for in [Strings] sect.
            *pszTmp = '\0' ; // replace '%' with a NULL char

            // szSrc points to the replaceable key now as we put the NULL char above.

            if ( ! MyGetPrivateProfileString( szInfFilename, "Strings", szSrc,
                                              szDst, dwDstSize - (DWORD)(szDst - pszSaveDst) ) )
            {
                // key is missing in [Strings] section!
                return (DWORD) -1;
            }
            else
            {
                // all was well, Dst filled right, but unfortunately count not passed
                // back, like it used too... :-( quick fix is a lstrlen()...
                uCnt = lstrlen( szDst ) ;
            }

            *pszTmp = '%'; // put back original character
            szSrc = pszTmp + 1 ;      // set Src after the second '%'
            szDst += uCnt ;           // set Dst also right.
            }
            // else it is ill-formed -- we use the '%' as such!
            else
            {
            return (DWORD)-1;
            }
        }

    } /* while */
    return (DWORD)lstrlen(pszSaveDst);

}


// BUGBUG:BUGBUG:BUGBUG:BUGBUG
// The code below is duplicated in wextract.exe. If you do changed/fixes to this code
// make sure to also change the code in wextract.exe


//***************************************************************************
//*                                                                         *
//* NAME:       GetWininitSize                                              *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Returns the size of wininit.ini in the windows directory.
// 0 if not found
DWORD GetWininitSize()
{
    CHAR   szPath[MAX_PATH];
    HFILE   hFile;
    DWORD   dwSize = (DWORD)0;
    if ( GetWindowsDirectory( szPath, MAX_PATH ) )
    {
        AddPath( szPath, "wininit.ini" );
        if ((hFile = _lopen(szPath, OF_READ|OF_SHARE_DENY_NONE)) != HFILE_ERROR)
        {
            dwSize = _llseek(hFile, 0L, FILE_END);
            _lclose(hFile);
        }
    }
    return dwSize;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetRegValueSize                                             *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Returns the size of the value lpcszValue under lpcszRegKey
// 0 if the registry key or the value were not found
DWORD GetRegValueSize(LPCSTR lpcszRegKey, LPCSTR lpcszValue)
{
    HKEY        hKey;
    DWORD       dwValueSize = (DWORD)0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpcszRegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, lpcszValue, NULL, NULL, NULL,&dwValueSize) != ERROR_SUCCESS)
            dwValueSize = (DWORD)0;
        RegCloseKey(hKey);
    }
    return dwValueSize;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetNumberOfValues                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Returns the number of Values in the key
// 0 if the registry key was not found or RegQueryInfoKey failed
DWORD GetNumberOfValues(LPCSTR lpcszRegKey)
{
    HKEY        hKey;
    DWORD       dwValueSize = (DWORD)0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpcszRegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryInfoKey(hKey,
                            NULL, NULL, NULL, NULL, NULL, NULL,
                            &dwValueSize,
                            NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            dwValueSize = (DWORD)0;
        RegCloseKey(hKey);
    }
    return dwValueSize;
}

//***************************************************************************
//*                                                                         *
//* NAME:       InternalNeedRebootInit                                      *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Returns the rebootcheck value depending on the OS we get passed in.
DWORD InternalNeedRebootInit(WORD wOSVer)
{
    DWORD   dwReturn = (DWORD)0;

    switch (wOSVer)
    {
        case _OSVER_WIN95:
            dwReturn = GetWininitSize();
            break;

        case _OSVER_WINNT40:
        case _OSVER_WINNT50:
        case _OSVER_WINNT51:
            dwReturn = GetRegValueSize(szNT4XDelayUntilReboot, szNT4XPendingValue);
            break;

        case _OSVER_WINNT3X:
            dwReturn = GetNumberOfValues(szNT3XDelayUntilReboot);
            break;

    }
    return dwReturn;
}

//***************************************************************************
//*                                                                         *
//* NAME:       InternalNeedReboot                                          *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Checks the passed in reboot check value against the current value.
// If they are different, we need to reboot.
// The reboot check value is dependend on the OS
BOOL InternalNeedReboot(DWORD dwRebootCheck, WORD wOSVer)
{
    return (dwRebootCheck != InternalNeedRebootInit(wOSVer));
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsEnoughInstSpace                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Checks the install destination dir free disk space
//
BOOL IsEnoughInstSpace( LPSTR szPath, DWORD dwInstNeedSize, LPDWORD pdwPadSize )
{
    DWORD   dwFreeBytes       = 0;
    CHAR    achDrive[MAX_PATH];
    DWORD   dwVolFlags;
    DWORD   dwMaxCompLen;

    ASSERT( szPath );

    // set to zero to indicate to called that the given drive can not be checked.
    if ( pdwPadSize )
        *pdwPadSize = 0;

    // If you are here, we expect that the caller have validated the path which
    // has the Fullpath directory name
    //
    if ( dwInstNeedSize == 0 )
        return TRUE;

    if ( szPath[1] == ':' )
    {
        lstrcpyn( achDrive, szPath, 4 );
    }
    else if ( (szPath[0] == '\\') && (szPath[1] == '\\') )
    {
        return TRUE; //no way to get it
    }
    else
        return FALSE; // you should not get here, if so, we don't know how to check it.

    if ((dwFreeBytes=GetSpace(achDrive))==0)
    {
        ErrorMsg1Param( NULL, IDS_ERR_GET_DISKSPACE, achDrive );
        //SetCurrentDirectory( achOldPath );
        return( FALSE );
    }

    // find out if the drive is compressed
    if ( !GetVolumeInformation( achDrive, NULL, 0, NULL,
            &dwMaxCompLen, &dwVolFlags, NULL, 0 ) )
    {
        ErrorMsg1Param( NULL, IDS_ERR_GETVOLINFOR, achDrive );
        //SetCurrentDirectory( achOldPath );
        return( FALSE );
    }

    if ( pdwPadSize )
        *pdwPadSize = dwInstNeedSize;

    if ( (dwVolFlags & FS_VOL_IS_COMPRESSED) && ctx.bCompressed )
    {
        dwInstNeedSize = dwInstNeedSize + dwInstNeedSize/4;
        if ( pdwPadSize )
            *pdwPadSize = dwInstNeedSize;
    }

    if ( dwInstNeedSize > dwFreeBytes )
        return FALSE;
    else
        return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       My_atol                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
LONG My_atol( LPSTR nptr )
{
    INT  c;
    LONG total;
    INT  sign;

    while ( *nptr == ' ' || *nptr == '\t' ) {
        ++nptr;
    }

    c = (INT)(UCHAR) *nptr++;
    sign = c;
    if ( c == '-' || c == '+' ) {
        c = (INT)(UCHAR) *nptr++;
    }

    total = 0;

    while ( c >= '0' && c <= '9' ) {
        total = 10 * total + (c - '0');
        c = (INT)(UCHAR) *nptr++;
    }

    if ( sign == '-' ) {
        return -total;
    } else {
        return total;
    }
}

//***************************************************************************
//*                                                                         *
//* NAME:       My_atoi                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
INT My_atoi( LPSTR nptr )
{
    return (INT) My_atol(nptr);
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsFullPath                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// return TRUE if given path is FULL pathname
//
BOOL IsFullPath( PCSTR pszPath )
{
    if ( (pszPath == NULL) || (lstrlen(pszPath) < 3) )
    {
        return FALSE;
    }

    if ( (pszPath[1] == ':') || ((pszPath[0] == '\\') && (pszPath[1]=='\\') ) )
        return TRUE;
    else
        return FALSE;
}



//***************************************************************************
//*                                                                         *
//* NAME:       GetUNCroot                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
/*
BOOL GetUNCroot( LPSTR pszinPath, LPSTR pszoutPath )
{
    ASSERT(pszinPath);
    ASSERT(pszoutPath);

    //  if you are called, called is sure that you are UNC path
    // get \\ first
    *pszoutPath++ = *pszinPath++;
    *pszoutPath++ = *pszinPath++;

    if ( *pszinPath == '\\' )
    {
	return FALSE; // catch '\\\' case
    }

    while ( *pszinPath != '\0' )
    {
	if ( *pszinPath == '\\' )
	{
	    break;
	}
	*pszoutPath++ = *pszinPath++;
    }

    if ( *(pszinPath-1) == '\\' )
    {
	return FALSE;
    }

    *pszoutPath = '\0';
    return TRUE;
}
*/



//***************************************************************************
//*                                                                         *
//* NAME:       MyFileSize                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************

DWORD MyFileSize( PCSTR pszFile )
{
    HANDLE hFile;
    DWORD dwSize = 0;

    if ( *pszFile == 0 )
        return 0;

    hFile = CreateFile( pszFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwSize = GetFileSize( hFile, NULL );
        CloseHandle( hFile );
    }

    return dwSize;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CreateFullPath                                              *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT CreateFullPath( PCSTR c_pszPath, BOOL bHiden )
{
    CHAR szPath[MAX_PATH];
    PSTR  pszPoint = NULL;
    BOOL  fLastDir = FALSE;
    HRESULT hReturnCode = S_OK;
    LPSTR szTmp;
    int   i;

    if ( ! IsFullPath( (PSTR)c_pszPath ) ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto done;
    }

    lstrcpy( szPath, c_pszPath );

    if ( lstrlen(szPath) > 3 ) {
        szTmp = CharPrev(szPath, szPath + lstrlen(szPath)) ;
        if ( szTmp > szPath && *szTmp == '\\' )
            *szTmp = '\0';
    }

    // If it's a UNC path, seek up to the first share name.
    if ( szPath[0] == '\\' && szPath[1] == '\\' ) {
        pszPoint = &szPath[2];
        for (i=0; i < 2; i++) {
            while ( *pszPoint != '\\' ) {
                if ( *pszPoint == '\0' ) {

                    // Share name missing? Else, nothing after sare name!
                    if (i == 0)
                        hReturnCode = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);

                    goto done;
                }
                pszPoint = CharNext( pszPoint );
            }
        }
        pszPoint = CharNext( pszPoint );
    } else {
        // Otherwise, just point to the beginning of the first directory
        pszPoint = &szPath[3];
    }

    while ( *pszPoint != '\0' ) 
    {
        while ( *pszPoint != '\\' && *pszPoint != '\0' ) 
        {
            pszPoint = CharNext( pszPoint );
        }

        if ( *pszPoint == '\0' ) 
        {
            fLastDir = TRUE;
        }

        *pszPoint = '\0';

        if ( GetFileAttributes( szPath ) == 0xFFFFFFFF ) 
        {
            if ( ! CreateDirectory( szPath, NULL ) ) 
            {
                hReturnCode = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
            else
            {
                if ( fLastDir && bHiden )
                    SetFileAttributes( szPath, FILE_ATTRIBUTE_HIDDEN );
            }
        }
        if ( fLastDir ) 
        {
            break;
        }

        *pszPoint = '\\';
        pszPoint = CharNext( pszPoint );
    }

  done:

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       LaunchAndWait                                               *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT LaunchAndWait(LPSTR pszCmd, LPSTR pszDir, HANDLE *phProc, DWORD dwWaitTime, DWORD dwCmdsFlags)
{
   STARTUPINFO startInfo = { 0 };
   PROCESS_INFORMATION processInfo;
   HRESULT hr = S_OK;
   BOOL fRet;

   if(phProc)
      *phProc = NULL;

   AdvWriteToLog("LaunchAndWait: Cmd=%1\r\n", pszCmd);
   // Create process on pszCmd
   startInfo.cb = sizeof(startInfo);
   startInfo.dwFlags |= STARTF_USESHOWWINDOW;
   if ( dwCmdsFlags & RUNCMDS_QUIET )
        startInfo.wShowWindow = SW_HIDE;
   else
        startInfo.wShowWindow = SW_SHOWNORMAL ;

   fRet = CreateProcess(NULL, pszCmd, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS,
                        NULL, pszDir, &startInfo, &processInfo);

   if(!fRet)
   {
      // Create Process failed
      hr = E_FAIL;
      goto done;
   }
   else
   {
      HANDLE pHandle;
      BOOL fQuit = FALSE;
      DWORD dwRet;

      CloseHandle( processInfo.hThread );

      pHandle = processInfo.hProcess;

      if( phProc )
      {
          *phProc = processInfo.hProcess;
          goto done;
      }
      else if ( dwCmdsFlags & RUNCMDS_NOWAIT )
      {
          goto done;
      }

      while(!fQuit)
      {
           dwRet = MsgWaitForMultipleObjects(1, &pHandle, FALSE, dwWaitTime, QS_ALLINPUT);
           // Give abort the highest priority
           if( (dwRet == WAIT_OBJECT_0) || ( dwRet == WAIT_TIMEOUT) )
           {
                if (dwRet == WAIT_TIMEOUT)
                    AdvWriteToLog("LaunchAndWait: %1: TimedOut.\r\n", pszCmd);
                fQuit = TRUE;
           }
           else
           {
                MSG msg;
                // read all of the messages in this next loop
                // removing each message as we read it
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {

                    // if it's a quit message we're out of here
                    if (msg.message == WM_QUIT)
                        fQuit = TRUE;
                    else
                    {
                        // otherwise dispatch it
                        DispatchMessage(&msg);
                    } // end of PeekMessage while loop
                }
            }
      }
      CloseHandle( pHandle );
   }

done:
   AdvWriteToLog("LaunchAndWait: End hr=0x%1!x!, %2\r\n", hr, pszCmd);
   return hr;
}


// RO_GetPrivateProfileSection
//   ensure the file attribute is not read-only because the kernel api bug
//
DWORD RO_GetPrivateProfileSection( LPCSTR lpSec, LPSTR lpBuf, DWORD dwSize, LPCSTR lpFile)
{
    DWORD dwRealSize;
    DWORD dwAttr;
    BOOL  bHaveRead = FALSE;

    dwAttr = GetFileAttributes( lpFile );
    if ( (dwAttr != -1) && (dwAttr & FILE_ATTRIBUTE_READONLY) )
    {
        if ( !SetFileAttributes( lpFile, FILE_ATTRIBUTE_NORMAL ) )
        {
            char szInfFilePath[MAX_PATH];
            char szInfFileName[MAX_PATH];

            // ErrorMsg1Param( NULL, IDS_ERR_CANT_SETA_FILE, lpFile );

            if ( GetTempPath(sizeof(szInfFilePath), szInfFilePath) )
            {
                if ( !IsGoodDir( szInfFilePath ) )
                {
                    GetWindowsDirectory( szInfFilePath, sizeof(szInfFilePath) );
                }

                if ( GetTempFileName(szInfFilePath, TEXT("INF"), 0, szInfFileName) )
                {
                    SetFileAttributes( szInfFileName, FILE_ATTRIBUTE_NORMAL );
                    DeleteFile( szInfFileName );
                    CopyFile( lpFile, szInfFileName, FALSE );
                    SetFileAttributes( szInfFileName, FILE_ATTRIBUTE_NORMAL );
                    dwRealSize = GetPrivateProfileSection( lpSec, lpBuf, dwSize, szInfFileName );
                    bHaveRead = TRUE;
                    DeleteFile( szInfFileName );
                }
            }

            //if ( !bHaveRead )
                //ErrorMsg1Param( NULL, IDS_ERR_CANT_SETA_FILE, lpFile );
        }
    }

    if ( !bHaveRead )
        dwRealSize = GetPrivateProfileSection( lpSec, lpBuf, dwSize, lpFile );

    if ( (dwAttr != -1) && (dwAttr & FILE_ATTRIBUTE_READONLY) )
    {
        SetFileAttributes( lpFile, dwAttr );
    }

    return dwRealSize;

}

BOOL GetThisModulePath( LPSTR lpPath, int size )
{
    LPSTR lpTmp;

    ASSERT(lpPath);

    if ( GetModuleFileName( g_hInst, lpPath, size ) )
    {

        lpTmp = CharPrev( lpPath, lpPath+lstrlen(lpPath));

        // chop filename off
        //
        while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
        lpTmp = CharPrev( lpPath, lpTmp );

        if ( *CharPrev( lpPath, lpTmp ) != ':' )
            *lpTmp = '\0';
        else
            *CharNext( lpTmp ) = '\0';
        return TRUE;
    }

    return FALSE;
}

HINSTANCE MyLoadLibrary( LPSTR lpFile )
{
    CHAR szPath[MAX_PATH];
    HINSTANCE hInst = NULL;
    DWORD dwAttr;

    ASSERT( lpFile );

    if ( GetThisModulePath( szPath, sizeof(szPath) ) )
    {
        AddPath( szPath, lpFile );
        if ( ((dwAttr = GetFileAttributes(szPath)) != -1) &&
             !( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) )
        {
            hInst = LoadLibraryEx( szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
        }
    }

    // If we did not load the DLL yet, try plain LoadLibrary
    if (hInst == NULL)
        hInst = LoadLibrary( lpFile );

    return hInst;
}

// typedef into advpack.h file
//typedef struct tagVERHEAD {
//    WORD wTotLen;
//    WORD wValLen;
//    WORD wType;         /* always 0 */
//    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
//    VS_FIXEDFILEINFO vsf;
//} VERHEAD ;

/*
 *  MyGetFileVersionInfo: Maps a file directly without using LoadLibrary.  This ensures
 *   that the right version of the file is examined without regard to where the loaded image
 *   is.  Since this is local, it allocates the memory which is freed by the caller.
 */
BOOL
NTGetFileVersionInfo(LPTSTR lpszFilename, LPVOID *lpVersionInfo)
{
    VS_FIXEDFILEINFO  *pvsFFI = NULL;
    UINT              uiBytes = 0;
    HINSTANCE         hinst;
    HRSRC             hVerRes;
    HANDLE            FileHandle = NULL;
    HANDLE            MappingHandle = NULL;
    LPVOID            DllBase = NULL;
    VERHEAD           *pVerHead;
    BOOL              bResult = FALSE;
    DWORD             dwHandle;
    DWORD             dwLength;

    if (!lpVersionInfo)
        return FALSE;

    *lpVersionInfo = NULL;

    FileHandle = CreateFile( lpszFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );
    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Cleanup;

    MappingHandle = CreateFileMapping( FileHandle,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                      );

    if (MappingHandle == NULL)
        goto Cleanup;

    DllBase = MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );
    if (DllBase == NULL)
        goto Cleanup;

    hinst = (HMODULE)((ULONG_PTR)DllBase | 0x00000001);

    hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
    if (hVerRes == NULL)
    {
        // Probably a 16-bit file.  Fall back to system APIs.
        if(!(dwLength = GetFileVersionInfoSize(lpszFilename, &dwHandle)))
        {
            if(!GetLastError())
                SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
            goto Cleanup;
        }

        if(!(*lpVersionInfo = LocalAlloc(LPTR, dwLength)))
            goto Cleanup;

        if(!GetFileVersionInfo(lpszFilename, 0, dwLength, *lpVersionInfo))
            goto Cleanup;

        bResult = TRUE;
        goto Cleanup;
    }

    pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
    if (pVerHead == NULL)
        goto Cleanup;

    *lpVersionInfo = LocalAlloc(LPTR, pVerHead->wTotLen + pVerHead->wTotLen/2);
    if (*lpVersionInfo == NULL)
        goto Cleanup;

    memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
    bResult = TRUE;

Cleanup:
    if (FileHandle)
        CloseHandle(FileHandle);
    if (MappingHandle)
        CloseHandle(MappingHandle);
    if (DllBase)
        UnmapViewOfFile(DllBase);
    if (*lpVersionInfo && bResult == FALSE)
        LocalFree(*lpVersionInfo);

    return bResult;
}

// this API will always get the version of the disk file

HRESULT WINAPI GetVersionFromFileEx(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion)
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer = NULL;
    LPVOID      lpVerBuffer;
    CHAR        szNewName[MAX_PATH];
    BOOL        bToCleanup = FALSE;
    BOOL        bContinue = FALSE;

    *pdwMSVer = *pdwLSVer = 0L;

    bContinue = NTGetFileVersionInfo(lpszFilename, &lpBuffer);

    if ( bContinue )
    {
        if (bVersion)
        {
            // Get the value for Translation
            if (VerQueryValue(lpBuffer, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) &&
                             (uiSize))

            {
                *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
            }
        }
        else
        {
            if (VerQueryValue(lpBuffer, "\\VarFileInfo\\Translation", &lpVerBuffer, &uiSize) &&
                            (uiSize))
            {
                *pdwMSVer = LOWORD(*((DWORD *) lpVerBuffer));   // Language ID
                *pdwLSVer = HIWORD(*((DWORD *) lpVerBuffer));   // Codepage ID
            }
        }
    }

    if ( bToCleanup )
        DeleteFile( szNewName );
    if ( lpBuffer )
        LocalFree( lpBuffer );
    return  S_OK;
}

//this api will get the version of the file being loaded

HRESULT WINAPI GetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion)
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer;
    LPVOID      lpVerBuffer;
    CHAR        szNewName[MAX_PATH];
    BOOL        bToCleanup = FALSE;

    *pdwMSVer = *pdwLSVer = 0L;

    dwVerInfoSize = GetFileVersionInfoSize(lpszFilename, &dwHandle);
    lstrcpy( szNewName, lpszFilename );
    if ( (dwVerInfoSize == 0) && FileExists( szNewName ) )
    {
        CHAR szPath[MAX_PATH];
        // due to version.dll bug, file in extended character path will failed version.dll apis.
        // So we copy it to a normal path and get its version info from there then clean it up.
        GetWindowsDirectory( szPath, sizeof(szPath) );
        GetTempFileName( szPath, "_&_", 0, szNewName );
        CopyFile( lpszFilename, szNewName, FALSE );
        bToCleanup = TRUE;
        dwVerInfoSize = GetFileVersionInfoSize( szNewName, &dwHandle );
    }

    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            // Read version stamping info
            if (GetFileVersionInfo(szNewName, dwHandle, dwVerInfoSize, lpBuffer))
            {
                if (bVersion)
                {
                    // Get the value for Translation
                    if (VerQueryValue(lpBuffer, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) &&
                                     (uiSize))

                    {
                        *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                        *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                    }
                }
                else
                {
                    if (VerQueryValue(lpBuffer, "\\VarFileInfo\\Translation", &lpVerBuffer, &uiSize) &&
                                    (uiSize))
                    {
                        *pdwMSVer = LOWORD(*((DWORD *) lpVerBuffer));   // Language ID
                        *pdwLSVer = HIWORD(*((DWORD *) lpVerBuffer));   // Codepage ID
                    }
                }
            }
            LocalFree(lpBuffer);
        }
    }

    if ( bToCleanup )
        DeleteFile( szNewName );
    return  S_OK;
}



#define WININIT_INI    "wininit.ini"

// when the files is busy, adding them to wininit.ini
//
BOOL AddWinInit( LPSTR from, LPSTR to)
{
    LPSTR  lpWininit;
    BOOL    bRet = FALSE;

    if ( ctx.wOSVer == _OSVER_WIN95 )
    {
        lpWininit = (LPSTR) LocalAlloc( LPTR, MAX_PATH );
        if ( !lpWininit )
        {
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            return FALSE;
        }

        GetWindowsDirectory( lpWininit, MAX_PATH);
        AddPath( lpWininit, WININIT_INI);

        WritePrivateProfileString( NULL, NULL, NULL, lpWininit );

        if ( WritePrivateProfileString( "Rename", to, from, lpWininit ) )
            bRet = TRUE;

        WritePrivateProfileString( NULL, NULL, NULL, lpWininit );

        LocalFree( lpWininit );
    }
    else
    {
        bRet = MoveFileEx(from, to, MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING);
    }
    return bRet;
}

void GetBackupName( LPSTR lpName, BOOL fOld )
{
    LPSTR pTmp;
    LPSTR pExt;

#define BACK_OLD ".~ol"
#define BACK_NEW ".~nw"

    if ( fOld )
       pExt = BACK_OLD;
    else
       pExt = BACK_NEW;

    pTmp = CharPrev( lpName, lpName + lstrlen(lpName) );

    while ( (pTmp>lpName) && *pTmp && (*pTmp != '\\') && (*pTmp != '.') )
    {
        pTmp = CharPrev( lpName, pTmp );
    }
    if ( (pTmp==lpName) || (*pTmp == '\\') )
    {
        lstrcat( lpName, pExt );
    }
    else
    {
        lstrcpy( pTmp, pExt );
    }

}

BOOL UpdateHelpDlls( LPCSTR *ppszDlls, INT numDlls, LPSTR pszPath, LPSTR pszMsg, DWORD dwFlag)
{
     DWORD   dwSysMsV, dwSysLsV, dwTmpMsV, dwTmpLsV;
     int     i = 0;
     LPSTR  pSysEnd;
     LPSTR  pTmpEnd;
     CHAR   szTmpPath[MAX_PATH] = { 0 };
     CHAR   szSystemPath[MAX_PATH] = { 0 };
     CHAR   szBuf[MAX_PATH];
     BOOL   fCopySucc = TRUE;
     BOOL   bRet = TRUE;
     BOOL   fBackup[3] = {0};
     BOOL   bAlertReboot = FALSE;

     // This function is used to update all the help Dlls: advpack, setupapi or setupx
     // based on passed in ppDlls

     // if not path passed in, get the module path (tmp path)
     if (pszPath==NULL)
     {
         if (!GetThisModulePath( szTmpPath, sizeof(szTmpPath) ) )
         {
            DEBUGMSG("Can not get ModuleFileName directory");
            return FALSE;
         }
     }
     else
         lstrcpy( szTmpPath, pszPath);

     pTmpEnd = szTmpPath + lstrlen(szTmpPath);

     // check if the newer or equal version files exist
     if ( !GetSystemDirectory( szSystemPath, sizeof(szSystemPath) ) )
     {
         DEBUGMSG("Can not get system directory");
         return FALSE;
     }
     pSysEnd = szSystemPath + lstrlen(szSystemPath);

     // check if the.dll need to be updated
     //
     for ( i = 0; i < numDlls; i += 1 )
     {
        // restore the systemPath and ModulePath
        *pTmpEnd = '\0';
        *pSysEnd = '\0';

        AddPath( szTmpPath, ppszDlls[i] );

        if ( GetFileAttributes( szTmpPath ) == -1 )
        {
            continue;
        }
        GetVersionFromFile( szTmpPath, &dwTmpMsV, &dwTmpLsV, TRUE );

        AddPath( szSystemPath, ppszDlls[i] );
        if ( GetFileAttributes( szSystemPath ) != -1 )
        {
            GetVersionFromFile( szSystemPath, &dwSysMsV, &dwSysLsV, TRUE );

            // compare if we need to copy those files
            //
            if ( (dwSysMsV > dwTmpMsV) ||
                 ((dwSysMsV == dwTmpMsV) && (dwSysLsV >= dwTmpLsV)) )
            {
                continue;
            }
            SetFileAttributes( szSystemPath, FILE_ATTRIBUTE_NORMAL );

            //backup the original files first
            lstrcpy( szBuf, szSystemPath );
            GetBackupName( szBuf, TRUE );
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
            if ( MoveFile( szSystemPath, szBuf ) )
            {
                fBackup[i] = TRUE;
            }
        }

        if ( !CopyFile( szTmpPath, szSystemPath, FALSE ) )
        {
            //if forced to update
            if ( dwFlag & UPDHLPDLLS_FORCED )
            {
                // copy to a basename.000 format
                lstrcpy( szBuf, szSystemPath );
                // get the temp name in destination dir to copy to
                GetBackupName( szBuf, FALSE );
                SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
                if ( CopyFile( szTmpPath, szBuf, FALSE ) )
                {
                    if ( AddWinInit( szBuf, szSystemPath ) )
                    {
                        if (dwFlag & UPDHLPDLLS_ALERTREBOOT)
                            bAlertReboot = TRUE;
                        continue;
                    }
                    else
                        bRet = FALSE;
                }
                else
                {
                    wsprintf( szBuf, "Cannot create TMP file for %s Dll.", pszMsg );
                    DEBUGMSG(szBuf);
                    bRet = FALSE;
                }
            }

            // you are here, means the current CopyFile/delay-CopyFile failed.
            // restore the original state, clean-up backup file if there.
            //

            while ( i >= 0 )
            {
                if ( fBackup[i] )
                {
                    *pSysEnd = '\0';
                    AddPath( szSystemPath, ppszDlls[i] );
                    lstrcpy( szBuf, szSystemPath );
                    GetBackupName( szBuf, TRUE );
                    SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
                    DeleteFile( szSystemPath );
                    if( !MoveFile( szBuf, szSystemPath ) )
                    {
                        wsprintf(szBuf, "Cannot restore %s dlls.", pszMsg);
                        DEBUGMSG(szBuf);
                    }
                }
                i--;
            }

            fCopySucc = FALSE;
            break;
        }
     }

     // clean up .~ol files
     if ( fCopySucc )
     {
        for ( i=0; i<numDlls; i++)
        {
            if ( fBackup[i] )
            {
                *pSysEnd = '\0';
                AddPath( szSystemPath, ppszDlls[i]);
                lstrcpy( szBuf, szSystemPath );
                GetBackupName( szBuf, TRUE );
                SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
                DeleteFile( szBuf );
            }
        }

        // if caller want ot alert reboot, means that they want to get false return if the dlls is not
        // in place now.
        if (bAlertReboot)
            bRet = FALSE;
     }
     return bRet;
}

void MyRemoveDirectory( LPSTR szFolder )
{
    while ( RemoveDirectory( szFolder ) )
    {
        GetParentDir( szFolder );
    }
}


BOOL IsDrvChecked( char chDrv )
{
    static char szDrvChecked[MAX_NUM_DRIVES] = { 0 };
    int idx;

    idx = (CHAR)CharUpper( (PSTR)chDrv ) - 'A';

    if ( szDrvChecked[idx] )
        return TRUE;
    else
        szDrvChecked[idx] = chDrv;

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNode
//
// SYNOPSIS:    Deletes a file or directory
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#define ADN_NO_SAFETY_CHECKS    0x40000000                                  // undocumented flag

HRESULT WINAPI DelNode(LPCSTR pszFileOrDirName, DWORD dwFlags)
{
    HRESULT hResult = S_OK;

    // we won't handle relative paths and UNC's(unless flag specified)
    // BUGBUG: <oliverl> we're not checking for UNC server here

    if (!IsFullPath(pszFileOrDirName)  ||  
        (pszFileOrDirName[0] == '\\' && pszFileOrDirName[1] == '\\' && 
        !(dwFlags & ADN_DEL_UNC_PATHS)))
        return E_FAIL;

    if (!(GetFileAttributes(pszFileOrDirName) & FILE_ATTRIBUTE_DIRECTORY))  // file
    {
        SetFileAttributes(pszFileOrDirName, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFile(pszFileOrDirName))
            hResult = E_FAIL;
    }
    else if (dwFlags & ADN_DEL_IF_EMPTY)                                    // delete the dir only if it's empty
    {
        SetFileAttributes(pszFileOrDirName, FILE_ATTRIBUTE_NORMAL);
        if (!RemoveDirectory(pszFileOrDirName))
            hResult = E_FAIL;
    }
    else                                                                    // delete the node
    {
        char szFile[MAX_PATH], *pszPtr;
        WIN32_FIND_DATA fileData;
        HANDLE hFindFile;

        if (!(dwFlags & ADN_NO_SAFETY_CHECKS))
        {
            // if pszFileOrDirName is the root dir or windows dir or system dir or
            // Program Files dir, return E_FAIL; this is just a safety precaution
            hResult = DirSafe(pszFileOrDirName);
        }

        if (SUCCEEDED(hResult))
        {
            lstrcpy(szFile, pszFileOrDirName);
            AddPath(szFile, "");
            pszPtr = szFile + lstrlen(szFile);                              // save this position

            lstrcpy(pszPtr, "*");

            if ((hFindFile = FindFirstFile(szFile, &fileData)) != INVALID_HANDLE_VALUE)
            {
                do
                {
                    // skip "." and ".."; if ADN_DONT_DEL_SUBDIRS is specified, skip all sub-dirs
                    if ((fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)  &&
                        (lstrcmp(fileData.cFileName, ".") == 0  ||
                         lstrcmp(fileData.cFileName, "..") == 0 ||
                         (dwFlags & ADN_DONT_DEL_SUBDIRS)))
                        continue;

                    lstrcpy(pszPtr, fileData.cFileName);

                    // we need to pass along the ADN_DEL_UNC_PATHS flag, but all other flags
                    // are only for the top level node

                    if (dwFlags & ADN_DEL_UNC_PATHS)
                        hResult = DelNode(szFile, ADN_DEL_UNC_PATHS);
                    else
                        hResult = DelNode(szFile, 0);                           // delete the file or sub-dir
                } while (SUCCEEDED(hResult)  &&  FindNextFile(hFindFile, &fileData));

                FindClose(hFindFile);

                if (SUCCEEDED(hResult)  &&  !(dwFlags & ADN_DONT_DEL_DIR))
                {
                    // delete the dir; if DelNode fails, it's an error condition if ADN_DONT_DEL_SUBDIRS is not specified

                    if (dwFlags & ADN_DEL_UNC_PATHS)
                    {
                        if (FAILED(DelNode(pszFileOrDirName, ADN_DEL_IF_EMPTY | ADN_DEL_UNC_PATHS))  &&
                            !(dwFlags & ADN_DONT_DEL_SUBDIRS))
                            hResult = E_FAIL;
                    }
                    else
                    {
                        if (FAILED(DelNode(pszFileOrDirName, ADN_DEL_IF_EMPTY))  &&  !(dwFlags & ADN_DONT_DEL_SUBDIRS))
                            hResult = E_FAIL;
                    }

                }
            }
            else
                hResult = E_FAIL;
        }
    }

    return hResult;
}


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNodeRunDLL32
//
// SYNOPSIS:    Deletes a file or directory; the parameters to this API are of
//              WinMain type
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI DelNodeRunDLL32(HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow)
{
    PSTR pszFileOrDirName = GetStringField(&pszParms, ",", '\"', TRUE);
    PSTR pszFlags = GetStringField(&pszParms, ",", '\"', TRUE);

    return DelNode(pszFileOrDirName, (pszFlags != NULL) ? My_atol(pszFlags) : 0);
}


HRESULT DirSafe(LPCSTR pszDir)
// If pszDir is the root drive of windows dir or windows dir or system dir or
// Program Files dir, return E_FAIL; otherwise, return S_OK
{
    char szUnsafeDir[MAX_PATH], szDir[MAX_PATH];

    lstrcpy(szDir, pszDir);
    AddPath(szDir, "");

    *szUnsafeDir = '\0';
    GetWindowsDirectory(szUnsafeDir, sizeof(szUnsafeDir));
    AddPath(szUnsafeDir, "");

    if (lstrcmpi(szDir, szUnsafeDir) == 0)              // windows dir
        return E_FAIL;
    else
    {
        szUnsafeDir[3] = '\0';

        if (lstrcmpi(szDir, szUnsafeDir) == 0)          // root drive of windows dir
            return E_FAIL;
        else
        {
            *szUnsafeDir = '\0';
            GetSystemDirectory(szUnsafeDir, sizeof(szUnsafeDir));
            AddPath(szUnsafeDir, "");

            if (lstrcmpi(szDir, szUnsafeDir) == 0)      // system dir
                return E_FAIL;
            else
            {
                *szUnsafeDir = '\0';
                GetProgramFilesDir(szUnsafeDir, sizeof(szUnsafeDir));
                AddPath(szUnsafeDir, "");

                if (lstrcmpi(szDir, szUnsafeDir) == 0)  // program files dir
                    return E_FAIL;
                else
                {
                    // check for the short pathname of the program files dir
                    GetShortPathName(szUnsafeDir, szUnsafeDir, sizeof(szUnsafeDir));
                    AddPath(szUnsafeDir, "");

                    if (lstrcmpi(szDir, szUnsafeDir) == 0)  // short pathname of program files dir
                        return E_FAIL;
                }
            }
        }
    }

    return S_OK;
}


void SetControlFont()
{
   LOGFONT lFont;
   if (GetSystemMetrics(SM_DBCSENABLED) &&
       (GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof (lFont), &lFont) > 0))
   {
       g_hFont = CreateFontIndirect((LPLOGFONT)&lFont);
   }
}

void SetFontForControl(HWND hwnd, UINT uiID)
{
   if (g_hFont)
   {
      SendDlgItemMessage(hwnd, uiID, WM_SETFONT, (WPARAM)g_hFont ,0L);
   }
}

void MyGetPlatformSection(LPCSTR lpSec, LPCSTR lpInfFile, LPSTR szNewSection)
{
    OSVERSIONINFO VerInfo;
    SYSTEM_INFO SystemInfo;
    char        szSection[MAX_PATH];
    DWORD       dwReqSize = 0;


    lstrcpy(szSection, lpSec);
    lstrcpy(szNewSection, lpSec);
    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        GetSystemInfo( &SystemInfo );
        switch (SystemInfo.wProcessorArchitecture)
        {
            case PROCESSOR_ARCHITECTURE_INTEL:
                lstrcat( szSection, ".NTx86" );
                break;

            case PROCESSOR_ARCHITECTURE_AMD64:
                lstrcat( szSection, ".NTAmd64" );
                break;
            case PROCESSOR_ARCHITECTURE_IA64:
                lstrcat( szSection, ".NTIa64" );
                break;

            default:
                DEBUGMSG("MyGetPlatformSection - need to deal w/ new PROCESS_ARCHITECTURE type!!");
                ASSERT(FALSE);
                break;
        }

        if (SUCCEEDED(GetTranslatedLine(lpInfFile, szSection, 0,
                                        NULL, &dwReqSize )) && (dwReqSize!=0))
        {
            lstrcpy(szNewSection, szSection);
        }
        else
        {
            lstrcpy(szSection, lpSec);
            lstrcat(szSection, ".NT");
            if (SUCCEEDED(GetTranslatedLine(lpInfFile, szSection, 0,
                                            NULL, &dwReqSize )) && (dwReqSize!=0))
                lstrcpy(szNewSection, szSection);
        }
    }
    else
    {
        lstrcat(szSection, ".WIN");
        if (SUCCEEDED(GetTranslatedLine(lpInfFile, szSection, 0,
                                        NULL, &dwReqSize )) && (dwReqSize!=0))
            lstrcpy(szNewSection, szSection);
    }
}

typedef HRESULT (WINAPI *PFProcessDownloadSection)(HINF, HWND, BOOL, LPCSTR, LPCSTR, LPVOID); 

HRESULT  RunPatchingCommands(PCSTR c_pszInfFilename, PCSTR szInstallSection, PCSTR c_pszSourceDir)
{
    CHAR  szBuf[512];
    CHAR  szDllName[MAX_PATH];
    HRESULT hResult = S_OK;
    INFCONTEXT InfContext;
    static const CHAR c_szPatching[] = "Patching";
    static const CHAR c_szAdvpackExt[] = "LoadAdvpackExtension";
    

    //Check if patching is enabled for this section
    if(!GetTranslatedInt(c_pszInfFilename, szInstallSection, c_szPatching, 0))
    {
        goto done;
    }

    //Read the dllname and entry point from LoadAdvpackExtension= line 
    if(FAILED(GetTranslatedString(c_pszInfFilename, szInstallSection, c_szAdvpackExt, szBuf, sizeof(szBuf), NULL)))
    {
        goto done;
    }

    //Got the extension dll 
    if(GetFieldString(szBuf, 0, szDllName, sizeof(szDllName)))
    {
        CHAR szEntryPoint[MAX_PATH];
        HINSTANCE hInst = LoadLibrary(szDllName);
        if(!hInst)
        {
             hResult = HRESULT_FROM_WIN32(GetLastError());
             goto done;
        }

        if(GetFieldString(szBuf, 1, szEntryPoint, sizeof(szEntryPoint)))
        {
            PFProcessDownloadSection pfn = (PFProcessDownloadSection)GetProcAddress(hInst, szEntryPoint);
            if(!pfn)
            {
                 hResult = HRESULT_FROM_WIN32(GetLastError());
                 goto done;
            }

            hResult = pfn(ctx.hInf, ctx.hWnd, ctx.wQuietMode, szInstallSection, c_pszSourceDir, NULL);
        }

        FreeLibrary(hInst);

    }

done:

    return hResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\crc32.c ===
#pragma warning( disable:4001 ) /* Disable new type remark warning */

/***    crc32.c - 32-bit CRC generator
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Mike Sliger
 *
 *  History:
 *      10-Aug-1993 bens    Initial version
 */

#include <Windows.h>
// #include <types.h>
#include "crc32.h"

static long crc_32_tab[] =
{
        0x00000000L, 0x77073096L, 0xEE0E612CL, 0x990951BAL, 0x076DC419L, 0x706AF48FL, 0xE963A535L, 0x9E6495A3L,
        0x0EDB8832L, 0x79DCB8A4L, 0xE0D5E91EL, 0x97D2D988L, 0x09B64C2BL, 0x7EB17CBDL, 0xE7B82D07L, 0x90BF1D91L,
        0x1DB71064L, 0x6AB020F2L, 0xF3B97148L, 0x84BE41DEL, 0x1ADAD47DL, 0x6DDDE4EBL, 0xF4D4B551L, 0x83D385C7L,
        0x136C9856L, 0x646BA8C0L, 0xFD62F97AL, 0x8A65C9ECL, 0x14015C4FL, 0x63066CD9L, 0xFA0F3D63L, 0x8D080DF5L,
        0x3B6E20C8L, 0x4C69105EL, 0xD56041E4L, 0xA2677172L, 0x3C03E4D1L, 0x4B04D447L, 0xD20D85FDL, 0xA50AB56BL,
        0x35B5A8FAL, 0x42B2986CL, 0xDBBBC9D6L, 0xACBCF940L, 0x32D86CE3L, 0x45DF5C75L, 0xDCD60DCFL, 0xABD13D59L,
        0x26D930ACL, 0x51DE003AL, 0xC8D75180L, 0xBFD06116L, 0x21B4F4B5L, 0x56B3C423L, 0xCFBA9599L, 0xB8BDA50FL,
        0x2802B89EL, 0x5F058808L, 0xC60CD9B2L, 0xB10BE924L, 0x2F6F7C87L, 0x58684C11L, 0xC1611DABL, 0xB6662D3DL,

        0x76DC4190L, 0x01DB7106L, 0x98D220BCL, 0xEFD5102AL, 0x71B18589L, 0x06B6B51FL, 0x9FBFE4A5L, 0xE8B8D433L,
        0x7807C9A2L, 0x0F00F934L, 0x9609A88EL, 0xE10E9818L, 0x7F6A0DBBL, 0x086D3D2DL, 0x91646C97L, 0xE6635C01L,
        0x6B6B51F4L, 0x1C6C6162L, 0x856530D8L, 0xF262004EL, 0x6C0695EDL, 0x1B01A57BL, 0x8208F4C1L, 0xF50FC457L,
        0x65B0D9C6L, 0x12B7E950L, 0x8BBEB8EAL, 0xFCB9887CL, 0x62DD1DDFL, 0x15DA2D49L, 0x8CD37CF3L, 0xFBD44C65L,
        0x4DB26158L, 0x3AB551CEL, 0xA3BC0074L, 0xD4BB30E2L, 0x4ADFA541L, 0x3DD895D7L, 0xA4D1C46DL, 0xD3D6F4FBL,
        0x4369E96AL, 0x346ED9FCL, 0xAD678846L, 0xDA60B8D0L, 0x44042D73L, 0x33031DE5L, 0xAA0A4C5FL, 0xDD0D7CC9L,
        0x5005713CL, 0x270241AAL, 0xBE0B1010L, 0xC90C2086L, 0x5768B525L, 0x206F85B3L, 0xB966D409L, 0xCE61E49FL,
        0x5EDEF90EL, 0x29D9C998L, 0xB0D09822L, 0xC7D7A8B4L, 0x59B33D17L, 0x2EB40D81L, 0xB7BD5C3BL, 0xC0BA6CADL,

        0xEDB88320L, 0x9ABFB3B6L, 0x03B6E20CL, 0x74B1D29AL, 0xEAD54739L, 0x9DD277AFL, 0x04DB2615L, 0x73DC1683L,
        0xE3630B12L, 0x94643B84L, 0x0D6D6A3EL, 0x7A6A5AA8L, 0xE40ECF0BL, 0x9309FF9DL, 0x0A00AE27L, 0x7D079EB1L,
        0xF00F9344L, 0x8708A3D2L, 0x1E01F268L, 0x6906C2FEL, 0xF762575DL, 0x806567CBL, 0x196C3671L, 0x6E6B06E7L,
        0xFED41B76L, 0x89D32BE0L, 0x10DA7A5AL, 0x67DD4ACCL, 0xF9B9DF6FL, 0x8EBEEFF9L, 0x17B7BE43L, 0x60B08ED5L,
        0xD6D6A3E8L, 0xA1D1937EL, 0x38D8C2C4L, 0x4FDFF252L, 0xD1BB67F1L, 0xA6BC5767L, 0x3FB506DDL, 0x48B2364BL,
        0xD80D2BDAL, 0xAF0A1B4CL, 0x36034AF6L, 0x41047A60L, 0xDF60EFC3L, 0xA867DF55L, 0x316E8EEFL, 0x4669BE79L,
        0xCB61B38CL, 0xBC66831AL, 0x256FD2A0L, 0x5268E236L, 0xCC0C7795L, 0xBB0B4703L, 0x220216B9L, 0x5505262FL,
        0xC5BA3BBEL, 0xB2BD0B28L, 0x2BB45A92L, 0x5CB36A04L, 0xC2D7FFA7L, 0xB5D0CF31L, 0x2CD99E8BL, 0x5BDEAE1DL,

        0x9B64C2B0L, 0xEC63F226L, 0x756AA39CL, 0x026D930AL, 0x9C0906A9L, 0xEB0E363FL, 0x72076785L, 0x05005713L,
        0x95BF4A82L, 0xE2B87A14L, 0x7BB12BAEL, 0x0CB61B38L, 0x92D28E9BL, 0xE5D5BE0DL, 0x7CDCEFB7L, 0x0BDBDF21L,
        0x86D3D2D4L, 0xF1D4E242L, 0x68DDB3F8L, 0x1FDA836EL, 0x81BE16CDL, 0xF6B9265BL, 0x6FB077E1L, 0x18B74777L,
        0x88085AE6L, 0xFF0F6A70L, 0x66063BCAL, 0x11010B5CL, 0x8F659EFFL, 0xF862AE69L, 0x616BFFD3L, 0x166CCF45L,
        0xA00AE278L, 0xD70DD2EEL, 0x4E048354L, 0x3903B3C2L, 0xA7672661L, 0xD06016F7L, 0x4969474DL, 0x3E6E77DBL,
        0xAED16A4AL, 0xD9D65ADCL, 0x40DF0B66L, 0x37D83BF0L, 0xA9BCAE53L, 0xDEBB9EC5L, 0x47B2CF7FL, 0x30B5FFE9L,
        0xBDBDF21CL, 0xCABAC28AL, 0x53B39330L, 0x24B4A3A6L, 0xBAD03605L, 0xCDD70693L, 0x54DE5729L, 0x23D967BFL,
        0xB3667A2EL, 0xC4614AB8L, 0x5D681B02L, 0x2A6F2B94L, 0xB40BBE37L, 0xC30C8EA1L, 0x5A05DF1BL, 0x2D02EF8DL
};


/* update running CRC calculation with contents of a buffer */

DWORD CRC32Compute(BYTE FAR *pb,unsigned cb,DWORD crc32)
{
    // ** Put CRC in form loop want it 
    crc32 = (-1L - crc32);

    while (cb--)
    {
        crc32 = crc_32_tab[(BYTE)crc32 ^ *pb++] ^ ((crc32 >> 8) & 0x00FFFFFFL);
    }

    // ** Put CRC in form client wants it
    return (-1L - crc32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\cab_dll.h ===
/* cab_dll.h -- CABINET.DLL high-level APIs */

#ifndef _CAB_DLL_H_INCLUDED
#define _CAB_DLL_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

// File Name List
//
// used as pFilesToExtract to track files in the CAB we need extracted
//
// or a pFileList in PSESSION
//
// We keep track of all files that are in a cabinet
// keeping their names in a list and when the download
// is complete we use this list to delete temp files

struct sFNAME {
    LPSTR               pszFilename;
    struct sFNAME       *pNextName;
    DWORD               status; /* out */
};

typedef struct sFNAME FNAME;
typedef FNAME *PFNAME;


// SFNAME.status: success is 0 or non-zero error code in extraction
#define SFNAME_INIT         1
#define SFNAME_EXTRACTED    0

/***    ERRF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 *
 *  Identical to an FCI/FDI ERF, but renamed to avoid collision.
 */

typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERRF;

//
// Master State Information for File Extraction: used by extract.c
//

typedef struct {
    UINT        cbCabSize;
    ERRF        erf;
    PFNAME      pFileList;              // List of Files in CAB
    UINT        cFiles;
    DWORD       flags;                  // flags: see below for list
    char        achLocation[MAX_PATH];  // Dest Dir
    char        achFile[MAX_PATH];      // Current File
    char        achCabPath[MAX_PATH];   // Current Path to cabs
    PFNAME      pFilesToExtract;        // files to extract;null=enumerate only

} SESSION, *PSESSION;

typedef enum {
    SESSION_FLAG_NONE           = 0x0,
    SESSION_FLAG_ENUMERATE      = 0x1,
    SESSION_FLAG_EXTRACT_ALL    = 0x2,
    SESSION_FLAG_EXTRACTED_ALL  = 0x4
} SESSION_FLAGS;


typedef struct
{
    DWORD   cbStruct;
    DWORD   dwReserved1;
    DWORD   dwReserved2;
    DWORD   dwFileVersionMS;
    DWORD   dwFileVersionLS;

} CABINETDLLVERSIONINFO, *PCABINETDLLVERSIONINFO;


/* export definitions */

typedef LPCSTR WINAPI FN_GETDLLVERSION(VOID);
typedef FN_GETDLLVERSION *PFN_GETDLLVERSION;

typedef VOID WINAPI FN_DLLGETVERSION(PCABINETDLLVERSIONINFO);
typedef FN_DLLGETVERSION *PFN_DLLGETVERSION;

typedef HRESULT WINAPI FN_EXTRACT(PSESSION,LPCSTR);
typedef FN_EXTRACT *PFN_EXTRACT;

typedef VOID WINAPI FN_DELETEEXTRACTEDFILES(PSESSION);
typedef FN_DELETEEXTRACTEDFILES *PFN_DELETEEXTRACTEDFILES;

#ifdef __cplusplus
}
#endif

#endif // _CAB_DLL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\cpldebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME ""
#endif	// SZ_COMPNAME



static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	_asm {int 3};
}

#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\crc32.h ===
/***    crc32.h - 32-bit CRC generator
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Mike Sliger
 *
 *  History:
 *      10-Aug-1993 bens    Copied from IMG2DMF directory.
 *
 *  Usage:
 *      ULONG   crc;
 *      //** Compute first block
 *      crc = CRC32Compute(pb,cb,CRC32_INITIAL_VALUE);
 *      //** Compute remaining blocks
 *      crc = CRC32Compute(pb,cb,crc);
 *      ...
 *      //** When you're done, crc has the CRC.
 *
 *      NOTE: See example function getFileChecksum() below that
 *            computes the checksum of a file!
 */

// ** Must use this as initial value for CRC
#define CRC32_INITIAL_VALUE 0L


/***    CRC32Compute - Compute 32-bit
 *
 *  Entry:
 *      pb    - Pointer to buffer to computer CRC on
 *      cb    - Count of bytes in buffer to CRC
 *      crc32 - Result from previous CRC32Compute call (on first call
 *              to CRC32Compute, must be CRC32_INITIAL_VALUE!!!!).
 *
 *  Exit:
 *      Returns updated CRC value.
 */

DWORD CRC32Compute(BYTE *pb,unsigned cb,ULONG crc32);


//** Include nice sample -- don't compile it
//
#ifdef HERE_IS_A_SAMPLE

/***    getFileChecksum - Compute file checksum
 *
 *  Entry:
 *      pszFile     - Filespec
 *      pchecksum   - Receives 32-bit checksum of file
 *      perr        - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE, *pchecksum filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in with error.
 */
BOOL getFileChecksum(char *pszFile, ULONG *pchecksum, PERROR perr)
{
#define cbCSUM_BUFFER   4096            // File buffer size
    int     cb;                         // Amount of data in read buffer
    ULONG   csum=CRC32_INITIAL_VALUE;   // Initialize CRC
    char   *pb=NULL;                    // Read buffer
    int     hf=-1;                      // File handle
    int     rc;
    BOOL    result=FALSE;               // Assume failure

    //** Initialize returned checksum (assume failure)
    *pchecksum = csum;

    //** Allocate file buffer
    if (!(pb = MemAlloc(cbCSUM_BUFFER))) {
        ErrSet(perr,pszDIAERR_NO_MEMORY_CRC,"%s",pszFile);
        return FALSE;
    }

    //** Open file
    hf = _open(pszFile,_O_RDONLY | _O_BINARY,&rc);
    if (hf == -1) {
        ErrSet(perr,pszDIAERR_OPEN_FAILED,"%s",pszFile);
        goto Exit;
    }

    //** Compute checksum
    while (_eof(hf) == 0) {
        cb = _read(hf,pb,cbCSUM_BUFFER);
        if (cb == -1) {
            ErrSet(perr,pszDIAERR_READ_FAIL_CRC,"%s",pszFile);
            goto Exit;
        }
        if (cb != 0) {
            csum = CRC32Compute(pb,cb,csum); // Accumulate CRC
        }
    }

    //** Success
    result = TRUE;
    *pchecksum = csum;                  // Store checksum for caller

Exit:
    if (hf != -1) {
        _close(hf);
    }
    if (pb != NULL) {
        MemFree(pb);
    }
    return result;
} /* getFileChecksum() */

#endif // HERE_IS_A_SAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\globals.c ===
#include <windows.h>
#include <setupapi.h>
#include "globals.h"
#include "advpack.h"

//
// Note that the global context is initialized to all zeros.
//
ADVCONTEXT ctx = {
    0,                  // wOSVer
    0,                  // wQuietMode
    0,                  // bUpdHlpDlls
    NULL,               // hSetupLibrary
    FALSE,              // fOSSupportsINFInstalls
    NULL,               // lpszTitle
    NULL,               // hWnd
    ENGINE_SETUPAPI,    // dwSetupEngine
    FALSE,              // bCompressed
    { 0 },              // szBrowsePath
    NULL,               // hInf
    FALSE,				// bHiveLoaded
    { 0 }				// szRegHiveKey
};

DWORD cctxSaved = 0;
PADVCONTEXT pctxSave = NULL;
HINSTANCE g_hInst = NULL;
HANDLE g_hAdvLogFile = INVALID_HANDLE_VALUE;

BOOL SaveGlobalContext()
{
    if (pctxSave)
    {
        PADVCONTEXT pctxNew = LocalReAlloc(pctxSave, (cctxSaved + 1) * sizeof(ADVCONTEXT), LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (!pctxNew)
        {
            return FALSE;
        }
        pctxSave = pctxNew;
    }
    else
    {
        pctxSave = LocalAlloc(LPTR, sizeof(ADVCONTEXT));
        if (!pctxSave)
        {
            return FALSE;
        }
    }

    pctxSave[cctxSaved++] = ctx;

    //
    // Note that the global context is initialized to all zeros except the HINSTANCE
    // of this module
    //
    memset(&ctx, 0, sizeof(ADVCONTEXT));

    return TRUE;
}

BOOL RestoreGlobalContext()
{
    if (!cctxSaved)
    {
        return FALSE;
    }

	// before we release the current contex:ctx to make sure there is no opened handle not being released
	if (ctx.hSetupLibrary)
	{
		CommonInstallCleanup();
	}
    cctxSaved--;
    ctx = pctxSave[cctxSaved];
    if (cctxSaved)
    {
        PADVCONTEXT pctxNew = LocalReAlloc(pctxSave, cctxSaved * sizeof(ADVCONTEXT), LMEM_MOVEABLE | LMEM_ZEROINIT);

        if (pctxNew)
        {
            pctxSave = pctxNew;
        }
    }
    else
    {
        LocalFree(pctxSave);
        pctxSave = NULL;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\globals.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* GLOBALS.H - Global Context save / restore                               *
//*                                                                         *
//***************************************************************************

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

typedef struct {
    WORD        wOSVer;
    WORD        wQuietMode;
    BOOL        bUpdHlpDlls;
    HINSTANCE   hSetupLibrary;
    BOOL        fOSSupportsINFInstalls;
    LPSTR       lpszTitle;
    HWND        hWnd;
    DWORD       dwSetupEngine;
    BOOL        bCompressed;
    char        szBrowsePath[MAX_PATH];
    HINF        hInf;
    BOOL		bHiveLoaded;
    CHAR		szRegHiveKey[MAX_PATH];
} ADVCONTEXT, *PADVCONTEXT;

extern ADVCONTEXT ctx;
extern HINSTANCE g_hInst;
extern HANDLE g_hAdvLogFile;


BOOL SaveGlobalContext();
BOOL RestoreGlobalContext();

// related to logging
VOID AdvStartLogging();
VOID AdvWriteToLog(LPCSTR pcszFormatString, ...);
VOID AdvLogDateAndTime();
VOID AdvStopLogging();

#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\extract.c ===
#include <windows.h>
#include <winerror.h>
#include <ole2.h>
#include "cpldebug.h"
#include "cab_dll.h"



//typedef HRESULT (WINAPI *EXTRACT) (PSESSION psess, LPCSTR lpCabName);

VOID FreeFileList(PSESSION psess);
VOID FreeFileNode(PFNAME pfname);
BOOL IsFileInList(LPSTR pszFile, LPSTR pszFileList);
int PrepareFileList(LPSTR pszOutFileList, LPCSTR pszInFileList);

// BUGBUG: Minimum version of Cabinet DLL that supports the new Extract API
// the one that was formerly in URLMON.DLL.
//
#define MIN_CABINETDLL_MSVER 0
#define MIN_CABINETDLL_LSVER 0

//=--------------------------------------------------------------------------=
// ExtractFiles
//=--------------------------------------------------------------------------=
//
// Parameters:
//    LPCSTR	pszCabName	- [in]  full qualified filename to the .CAB file
//    LPCSTR	pszExpandDir- [in]  full qualified path to where to extract the file(s)
//    DWORD     dwFlags		- [in]  Flags, currently not used
//    LPCSTR    pszFileList - [in]  colon separated list of files to extract from pszCabName
//                                  or NULL for all files
//    LPVOID    lpReserved  - [in]  currently not used
//    DWORD		dwReserved	- [in]  currently not used
//
// Return HRESULT:
//      E_INVALIDARG    - if pszCabName or pszExpandDir == NULL
//      E_OUTOFMEMORY   - if we could not allocate our memory
//      E_FAIL          - if no files in pszFileList and pszFileList!=NULL
//                        if not all files from pszFileList are in the .CAB file
//                        if Extract return S_FALSE
//      any E_ code Extract returns
//
// Note: This function would not extract any file from the pszFileList, if not all
//       of them are in the .CAB file. If one or more are not in the .CAB file
//       the function does not extract any and returns E_FAIL
//
HRESULT WINAPI ExtractFiles( LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                             LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved)
{
    HINSTANCE hinst;
    PSESSION  psess = NULL;
    PFNAME    pf = NULL;
    PFNAME    pfPriv = NULL;
    HRESULT   hr = E_FAIL;          // Return error
    LPSTR     pszMyFileList = NULL;
    PFN_EXTRACT   fpExtract = NULL;
    PFN_DLLGETVERSION fpGetVer = NULL;
    int       iFiles = 0;    // number of files in list
    CABINETDLLVERSIONINFO cabDllVer;

    // Do checking for valid values??
    if ((!pszCabName) || (!pszExpandDir))
        return E_INVALIDARG;

    hinst = LoadLibrary("CABINET.DLL");
    if (hinst)
    {
        fpGetVer = (PFN_DLLGETVERSION)GetProcAddress(hinst, "DllGetVersion");

        // Make sure this is the CABINET.DLL that supports the Extract API
        //
        if ( fpGetVer )
        {
            cabDllVer.cbStruct = sizeof(cabDllVer);
            fpGetVer( &cabDllVer );
            if ( (cabDllVer.dwFileVersionMS > MIN_CABINETDLL_MSVER) ||
                 (cabDllVer.dwFileVersionMS == MIN_CABINETDLL_MSVER) /* && (cabDllVer.dwFileVersionLS >= MIN_CABINETDLL_LSVER) */ )
            {
                fpExtract = (PFN_EXTRACT)GetProcAddress(hinst, "Extract");
            }
        }

        if (!fpExtract)
            FreeLibrary(hinst);
    }

    // If we did not get the Extract() API from cabinet.dll go for
    // URLMON.DLL
    //
    if (!fpExtract)
    {
        hinst = LoadLibrary("URLMON.DLL");
        if (hinst)
            fpExtract = (PFN_EXTRACT)GetProcAddress(hinst, "Extract");
    }

    if (fpExtract)
    {
        psess = (PSESSION)LocalAlloc(LPTR, sizeof(SESSION));
        if (psess) 
        {
            lstrcpy(psess->achLocation, pszExpandDir);
            // Initialize the structure
            if (pszFileList == NULL)
            {
                // Extract all
                psess->flags = SESSION_FLAG_EXTRACT_ALL|SESSION_FLAG_ENUMERATE;
                hr = fpExtract(psess, pszCabName);
                // BUGBUG: What if psess->erf reports an error??
            }
            else
            {
                // I append a '/0' therefor +2
                pszMyFileList = (LPSTR)LocalAlloc(LPTR, lstrlen(pszFileList)+2);
                if (pszMyFileList)
                {
                    iFiles = PrepareFileList(pszMyFileList, pszFileList);
                    psess->flags = SESSION_FLAG_ENUMERATE;

                    if  ((iFiles > 0) &&
                         ( !FAILED(hr = fpExtract(psess, pszCabName)) ))
                        // What if psess->erf reports an error??
                    {
                    // If there are files in the list and we enumarated files
                    
                        // Got the list of files in the cab
                        pfPriv = NULL;
                        pf = psess->pFileList;
                        while (pf != NULL )
                        {
                            if (!IsFileInList(pf->pszFilename, pszMyFileList))
                            {
                                // Delete the node from the list
                                if (pfPriv == NULL)
                                {
                                    // Delete the head
                                    psess->pFileList = pf->pNextName;
                                    FreeFileNode(pf);
                                    pf = psess->pFileList;
                                }
                                else
                                {
                                    pfPriv->pNextName = pf->pNextName;
                                    FreeFileNode(pf);
                                    pf = pfPriv->pNextName;
                                }
                            }
                            else
                            {
                                // Just go to the next one
                                pfPriv = pf;
                                pf = pf->pNextName;
                                iFiles--;
                            }
                        }

                        if ((psess->pFileList) && (iFiles == 0))
                        {
                            // Reset the error flag
                            psess->erf.fError = FALSE;
                            psess->erf.erfOper = 0;

                            psess->pFilesToExtract = psess->pFileList;
                            psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated
                            hr = fpExtract(psess, pszCabName);
                            // BUGBUG: What if psess->erf reports an error??
                        }
                        else
                            hr = E_FAIL;    // File(s) is not in cab.
                    }

                    LocalFree(pszMyFileList);
                    pszMyFileList = NULL;

                }
                else
                    hr = E_OUTOFMEMORY;
            }
            FreeFileList(psess);
            LocalFree(psess);
            psess = NULL;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    if (hinst)
        FreeLibrary(hinst);

    // Extract may only return S_FALSE in a failure case.
    if (!FAILED(hr) && (hr == S_FALSE))
        hr = E_FAIL;

    return (hr);
}


VOID FreeFileList(PSESSION psess)
{
    PFNAME      rover = psess->pFileList;
    PFNAME      roverprev;

    while (rover != NULL)  
    {

        roverprev = rover;  // save for free'ing current rover below
        rover = rover->pNextName;

        FreeFileNode(roverprev);
    }

    psess->pFileList = NULL; // prevent use after deletion!
}

VOID FreeFileNode(PFNAME pfname)
{
    CoTaskMemFree(pfname->pszFilename);
    CoTaskMemFree(pfname);
}


BOOL IsFileInList(LPSTR pszFile, LPSTR pszFileList)
{
    char *p;
    int  iLenFile = lstrlen(pszFile);
    BOOL bFound = FALSE;

    p = pszFileList;
    while ((*p != '\0') && (!bFound))
    {
        if (lstrlen(p) == iLenFile)
            bFound = (lstrcmpi(p, pszFile) == 0);
        if (!bFound)
            p += lstrlen(p) + 1;
    }
    return (bFound);
}

int PrepareFileList(LPSTR pszOutFileList, LPCSTR pszInFileList)
{
    int  iFiles = 0;                // number of files in list
    char *p;
    p = (LPSTR)pszInFileList;       // p is used to point into both arrays 

    // trim leading spaces, tabs or : 
    while ((*p == ' ') || (*p == '\t') || (*p == ':'))
        p++;
    lstrcpy(pszOutFileList, p);

    p = pszOutFileList;
    if (lstrlen(pszOutFileList) > 0)
    {
        // Only if we have atleast one character left.
        // This cannot be a space of tab, because we 
        // would have removed this above.
        p += (lstrlen(pszOutFileList) - 1);

        // trim railing spaces, tabs or :
        while ((*p == ' ') || (*p == '\t') || (*p == ':'))
            p--;

        // Put a '\0' for the last space/tab
        *(++p) = '\0';
    }

    if (*pszOutFileList)
    {
        iFiles++;
        // Now replace ':' with '\0'
        p = pszOutFileList;
        while (*p != '\0')
        {
            if (*p == ':')
            {
                *p = '\0';
                iFiles++;
            }
            p++;
        }
        // Make sure we have a double '\0' at the end.
        *(++p) = '\0';
    }
    return iFiles;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\execcab.c ===
//***************************************************************************
//*   Copyright (c) Microsoft Corporation 1995-1996. All rights reserved.   *
//***************************************************************************
//*                                                                         *
//* ADVPACK.C - Advanced INF Installer.                                     *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <io.h>
#include <windows.h>
#include <winerror.h>
#include <ole2.h>
#include "resource.h"
#include "cpldebug.h"
#include "ntapi.h"
#include "advpub.h"
#include "w95pub32.h"
#include "advpack.h"
#include "regstr.h"
#include "globals.h"
#include "cfgmgr32.h"
#include "sfp.h"

//***************************************************************************
//* global defines                                                          *
//***************************************************************************

#define   YES   "1"
#define   NO    "0"

#define   FILELIST_SIZE     10*BUF_1K

//***************************************************************************
//* globals                                                                 *
//***************************************************************************

INFOPT  RegInfOpt[] = { ADVINF_ADDREG, ADVINF_DELREG, ADVINF_BKREG };  // code below depending on this orders

static PSTR gst_pszFiles;    
static PSTR gst_pszEndLastFile = NULL;
static HRESULT  gst_hNeedReboot; 
static PSTR gst_pszSmartReboot = NULL;

const char c_szActiveSetupKey[] = "software\\microsoft\\Active Setup\\Installed Components";

// globals for reg backup key and file names
const char c_szRegUninstPath[] = "BackupRegPathName";
const char c_szRegUninstSize[] = "BackupRegSize";

const char c_szHiveKey_FMT[] = "AINF%04d";

// NoBackupPlatform string table
LPCSTR c_pszPlatform[] = { "win9x", "NT3.5", "NT4", "NT5", "NT5.1" };

//-----------------------------------------------------------------------------------------
//
// PerUser section defines
//
//-----------------------------------------------------------------------------------------

const CHAR REGVAL_OLDDISPN[]=         "OldDisplayName";    
const CHAR REGVAL_OLDVER[]=           "OldVersion";
const CHAR REGVAL_OLDSTUB[]=          "OldStubPath";
const CHAR REGVAL_OLDLANG[]=          "OldLocale";
const CHAR REGVAL_OLDREALSTUBPATH[]=  "OldRealStubPath";

const CHAR REGVAL_REALSTUBPATH[]=     "RealStubPath";

const CHAR ADV_UNINSTSTUBWRAPPER[]=      "rundll32.exe advpack.dll,UserUnInstStubWrapper %s";
const CHAR ADV_INSTSTUBWRAPPER[]=        "rundll32.exe advpack.dll,UserInstStubWrapper %s";

const CHAR c_szRegDontAskValue[] =    "DontAsk";
/* Check the "Don't Ask" value.  If it's present, its value
 * is interpreted as follows:
 *
 * 0 --> ask the user
 * 1 --> do not run the stub
 * 2 --> always run the stub
 */

HRESULT ProcessOneRegSec( HWND hw, PCSTR pszTitle, PCSTR pszInf, PCSTR pszSec, HKEY hKey, HKEY hCUKey, DWORD dwFlags, BOOL *lpbOneRegSave  );
UINT WINAPI MyFileQueueCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );
UINT WINAPI MyFileQueueCallback2( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );
void CleanRegLogFile( PCSTR pcszLogFileSecName );
BOOL VerifyBackupInfo( HKEY hKey, HKEY hCUKey );
void DeleteOldBackupData( HKEY hKey );
//int DeleteSubKey(HKEY root, char *keyname);
BOOL NeedBackupData(LPCSTR pszInf, LPCSTR pszSec);
BOOL GetUniBackupName( HKEY hKey, LPSTR pszBackupBase, DWORD dwInSize, LPCSTR pszBackupPath, LPCSTR pszModule );


//***************************************************************************
extern PFSetupDefaultQueueCallback       pfSetupDefaultQueueCallback;
extern PFSetupInstallFromInfSection      pfSetupInstallFromInfSection;
extern PFSetupInitDefaultQueueCallbackEx pfSetupInitDefaultQueueCallbackEx;
extern PFSetupTermDefaultQueueCallback   pfSetupTermDefaultQueueCallback;

//***************************************************************************
//*                                                                         *
//* NAME:       LaunchINFSectionEx                                          *
//*                                                                         *
//* SYNOPSIS:   Detect which shell mode you are in and flip it over to      *
//*             the other mode                                              *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI LaunchINFSectionEx( HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow )
{
    LPSTR       pszFlags;
    PCABINFO    pcabInfo = NULL;
    HRESULT     hRet = S_OK;
   
    AdvWriteToLog("LaunchINFSectionEx: Param= %1\r\n", pszParms);
    pcabInfo = (PCABINFO)LocalAlloc( LPTR, sizeof(CABINFO) );
    if ( !pcabInfo )
    {
        ErrorMsg( hwnd, IDS_ERR_NO_MEMORY );
        goto done;
    }

    // Parse the arguments, SETUP engine is not called. So we only need to check on \".
    pcabInfo->pszInf = GetStringField( &pszParms, ",", '\"', TRUE );
    pcabInfo->pszSection = GetStringField( &pszParms, ",", '\"', TRUE );
    pcabInfo->pszCab = GetStringField( &pszParms, ",", '\"', TRUE );
    pszFlags = GetStringField( &pszParms, ",", '\"', TRUE );
    gst_pszSmartReboot = GetStringField( &pszParms, ",", '\"', TRUE );

    if ( pszFlags != NULL )
        pcabInfo->dwFlags = My_atol(pszFlags);

    if ( pcabInfo->pszCab != NULL && *pcabInfo->pszCab )
    {
        if ( IsFullPath( pcabInfo->pszCab ) )
        {
            lstrcpy( pcabInfo->szSrcPath, pcabInfo->pszCab );
            GetParentDir( pcabInfo->szSrcPath );
        }
        else
        {
            ErrorMsg1Param( hwnd, IDS_ERR_CABPATH, pcabInfo->pszCab );
            goto done;
        }
    }

    // if we need to switch the mode. call ExecuteCab()
    hRet = ExecuteCab( hwnd, pcabInfo, NULL );

done:
    if ( pcabInfo )
        LocalFree( pcabInfo );
    AdvWriteToLog("LaunchINFSectionEx: End hr=0x%1!x!\r\n",hRet);
    return hRet;

}

//***************************************************************************
//*                                                                         *
//* NAME:       ExecuteCab                                                  *
//*                                                                         *
//* SYNOPSIS:   Get INF from the cab and install it based on the flag.      *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*                                                                         *
//* RETURNS:    HRESULT:        See advpub.h                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI ExecuteCab( HWND hWnd, PCABINFO pcabInfo, PVOID pvReserved )
{
    HRESULT hRet = S_OK, hRet1 = S_OK;
    DWORD   dwFlags;
    char    szFullPathInf[MAX_PATH];
    HKEY    hKey = NULL;
    char    szSec[MAX_PATH] = { 0 };  
    DWORD   dwSecSize = sizeof(szSec);
    BOOL    bExtracF = FALSE;    
    BOOL    bExtractCatalog = FALSE;
    BOOL    fSavedContext = FALSE;
    BOOL    fTmpInf = FALSE;
    char    szModule[MAX_PATH];
    char    szCatalogName[MAX_PATH];

    AdvWriteToLog("ExecuteCab:");
    if (!SaveGlobalContext())
    {
        hRet1 = E_OUTOFMEMORY;
        goto done;
    }

    fSavedContext = TRUE;
    
    // Validate parameters:
    // if INF filename info is missing, invalid.
    if ( !pcabInfo || !(pcabInfo->pszInf) || !*(pcabInfo->pszInf) )
        return E_INVALIDARG;

    AdvWriteToLog("Inf = %1\r\n", pcabInfo->pszInf);

    ctx.hWnd      = hWnd;

    // the flag ALINF_ROLLBACKDOALL includes meaning ALINF_ROLLBACK
    // TO avoid check both flag everywhere, we set both on if DOALL
    if ( pcabInfo->dwFlags & ALINF_ROLLBKDOALL )
    {
        pcabInfo->dwFlags |= ALINF_ROLLBACK;
    }

    // if INF is 8.3 format and the Cab file is given, extract INF out of the cab. Oterwise use it as it is.
    if ( pcabInfo->pszCab && *pcabInfo->pszCab )
    {
        if ( !IsFullPath( pcabInfo->pszInf ) )
        {                
            if ( SUCCEEDED(hRet = ExtractFiles( pcabInfo->pszCab, pcabInfo->szSrcPath, 0, pcabInfo->pszInf, 0, 0) ) )
                bExtracF = TRUE;
        }
    }
    else
    {
        if ( pcabInfo->dwFlags & ALINF_ROLLBACK )
        {
            pcabInfo->dwFlags |= ALINF_ROLLBKDOALL;
        }
    }
            
    if ( !GetFullInfNameAndSrcDir( pcabInfo->pszInf, szFullPathInf, pcabInfo->szSrcPath ) )
    {
        hRet1 = E_INVALIDARG;
        goto done;
    }
   
    // if rollback case, we want to make the tmp INF file to use in case the rollback will delete the real file.
    if ( (pcabInfo->dwFlags & ALINF_ROLLBACK) && !bExtracF )
    {
        PSTR pszFile;
        char szPath[MAX_PATH];
        char ch;

        pszFile = ANSIStrRChr( szFullPathInf, '\\' );
        if ( pszFile )
        {
            ch = *pszFile;
            *pszFile = '\0';
            if ( GetTempFileName( szFullPathInf, "INF", 0, szPath ) )
            {               
                DeleteFile( szPath );
                *pszFile = ch;
                if ( CopyFile( szFullPathInf, szPath, FALSE ) )
                {            
                    AdvWriteToLog("InfFile Rename: %1 becomes %2\r\n", szFullPathInf, szPath);
                    fTmpInf = TRUE;
                    lstrcpy( szFullPathInf, szPath );
                }
            }
        }
    }


    if ( pcabInfo->pszSection )
        lstrcpy( szSec, pcabInfo->pszSection );
    GetInfInstallSectionName( szFullPathInf, szSec, dwSecSize );

    // GetComponent Name
    if ( FAILED(GetTranslatedString( szFullPathInf, szSec, ADVINF_MODNAME,
                                        szModule, sizeof(szModule), NULL)) && szModule[0])
    {
        *szModule = '\0';   // Or should we exit if we don't find a module name????
    }

    // extract the catalog, if specified
    if (pcabInfo->pszCab  &&  *pcabInfo->pszCab)
    {
        *szCatalogName = '\0';

        GetTranslatedString(szFullPathInf, szSec, ADVINF_CATALOG_NAME, szCatalogName, sizeof(szCatalogName), NULL);
        if (*szCatalogName)
        {
            if (SUCCEEDED(ExtractFiles(pcabInfo->pszCab, pcabInfo->szSrcPath, 0, szCatalogName, 0, 0)))
                bExtractCatalog = TRUE;
        }
    }

    // start Pre-rollback
    //
    dwFlags = COREINSTALL_PROMPT;
    dwFlags |= (pcabInfo->dwFlags & ALINF_NGCONV ) ? 0 : COREINSTALL_GRPCONV;
    if ( pcabInfo->dwFlags & ALINF_QUIET ) 
        ctx.wQuietMode = QUIETMODE_ALL;

    if ( pcabInfo->dwFlags & ALINF_CHECKBKDATA || pcabInfo->dwFlags & ALINF_ROLLBACK )
    {
        char szUninstall[MAX_PATH];
        CHAR szBuf[MAX_PATH];
        HKEY hCUKey = NULL;

        if ( pcabInfo->dwFlags & ALINF_ROLLBACK )
        { 
            szUninstall[0] = 0;
            if ( SUCCEEDED(GetTranslatedString( szFullPathInf, szSec, ADVINF_PREROLBK,
                                                szUninstall, sizeof(szUninstall), NULL)) && szUninstall[0])
            {
                hRet = CoreInstall( szFullPathInf, szUninstall, pcabInfo->szSrcPath, 0, dwFlags, NULL );
                if ( FAILED( hRet ) )
                {
                    hRet1 = hRet;
                    goto done;
                }
            }
        }
        // if just want to checking backup data, process here and return
        //       
        hRet1 = E_UNEXPECTED;  //if HKLM does not have the \Advance INF setup\Module, it is unexpected.s

        if (*szModule)
        {
            // backup/restore the reg info referred by AddReg, DelReg, BackupReg lines inside the INF install section
            //
            lstrcpy( szBuf, REGKEY_SAVERESTORE );
            AddPath( szBuf, szModule );
            if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, szBuf, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
            {
                RegOpenKeyEx( HKEY_CURRENT_USER, szBuf, 0, KEY_READ, &hCUKey);
                if ( VerifyBackupInfo( hKey, hCUKey ) )                
                    hRet1 = S_OK;                
                else
                    hRet1 = E_FAIL;
            }                            

            if ( hKey )
                RegCloseKey( hKey );
            if ( hCUKey )
                RegCloseKey( hCUKey );
        }    
        if ( FAILED(hRet1) || (pcabInfo->dwFlags == ALINF_CHECKBKDATA) )
        {
            goto done;
        }
    }

    dwFlags |= (pcabInfo->dwFlags & ALINF_DELAYREGISTEROCX) ? COREINSTALL_DELAYREGISTEROCX : 0;
    dwFlags |= (pcabInfo->dwFlags & ALINF_BKINSTALL) ? COREINSTALL_BKINSTALL : 0;
    dwFlags |= (pcabInfo->dwFlags & ALINF_ROLLBACK) ? COREINSTALL_ROLLBACK : 0;
    dwFlags |= (pcabInfo->dwFlags & ALINF_ROLLBKDOALL) ? COREINSTALL_ROLLBKDOALL : 0;
    dwFlags |= COREINSTALL_SMARTREBOOT;

    hRet1 = CoreInstall( szFullPathInf, szSec, pcabInfo->szSrcPath, 0, dwFlags, gst_pszSmartReboot );                   

    // save the cab file info
    if ( SUCCEEDED( hRet1 ) && pcabInfo->pszCab && *pcabInfo->pszCab && (pcabInfo->dwFlags & ALINF_BKINSTALL) )
    {                
        if ( hRet == ERROR_SUCCESS_REBOOT_REQUIRED )
            hRet1 = hRet;

        if (*szModule)
        {
            // reuse the buf so name is not acurate!!
            lstrcpy( szSec, REGKEY_SAVERESTORE );
            AddPath( szSec, szModule );
        
            if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, szSec, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                 NULL, &hKey, &dwFlags ) == ERROR_SUCCESS )
            {
                RegSetValueEx( hKey, REGVAL_BKINSTCAB, 0, REG_SZ, pcabInfo->pszCab, lstrlen(pcabInfo->pszCab)+1 );
                RegCloseKey( hKey );
            }
        }
    }    
    

done:
    
    if (  bExtracF || fTmpInf )
    {
        // need to delete the INF file
        DeleteFile( szFullPathInf );
    }

    if (bExtractCatalog)
    {
        char szFullCatalogName[MAX_PATH];

        lstrcpy(szFullCatalogName, pcabInfo->szSrcPath);
        AddPath(szFullCatalogName, szCatalogName);
        DeleteFile(szFullCatalogName);
    }

    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    if (pcabInfo->pszInf)
        AdvWriteToLog("ExecuteCab: End hr=0x%1!x! Inf=%2\r\n", hRet1,pcabInfo->pszInf);
    else
        AdvWriteToLog("ExecuteCab: End hr=0x%1!x!\r\n", hRet1);

    return hRet1;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT SaveRestoreInfo( PCSTR pszInf, PCSTR pszSection, PCSTR pszSrcDir, PCSTR pszCatalogs, DWORD dwFlags )
{
    char    szBuf[MAX_PATH];
    char    szModule[MAX_PATH];
    char    szBackupPath[MAX_PATH];
    char    szBackupBase[MAX_PATH];
    UINT    uErrid = 0;
    DWORD   dwTmp;
    PSTR    pszFileList = NULL;
    BOOL    bDeleteKey = FALSE; 
    HKEY    hKey = NULL, hSubKey = NULL, hCUSubKey = NULL;
    HRESULT hRet = S_OK;
    BOOL    bAtleastOneReg = FALSE;
    DWORD   adwAttr[8];
    
    // check if we need to backup the data
    if ( !NeedBackupData(pszInf, pszSection) )
        goto done;        

    AdvWriteToLog("SaveRestoreInfo: ");
    // GetComponent Name
    if ( FAILED(GetTranslatedString( pszInf, pszSection, ADVINF_MODNAME,
                                        szModule, sizeof(szModule), NULL)))
    {
        // error out if no component name
        goto done;
    }

    AdvWriteToLog("CompName=%1 pszInf=%2 Sec=%3\r\n", szModule, pszInf, pszSection);
    // backup/restore the reg info referred by AddReg, DelReg, BackupReg lines inside the INF install section
    //
    lstrcpy( szBuf, REGKEY_SAVERESTORE );
    if ( dwFlags & COREINSTALL_BKINSTALL )
    {
        CleanRegLogFile( REG_SAVE_LOG_KEY );
        CleanRegLogFile( REG_RESTORE_LOG_KEY );
    }

    AddPath( szBuf, szModule );
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                         NULL, &hKey, &dwTmp ) != ERROR_SUCCESS )
    {     
        // If client does not have the access to this key, we may not want to fault out the rest setup process.
        // For some reason with Read only access set, this call return error code 2 instead of 5 access denied
        // so we just skip save rollback if this can not be opened/created
        goto done;
    }

    // create HKCU branch
    AddPath( szBuf, REGSUBK_REGBK );
    if ( RegCreateKeyEx( HKEY_CURRENT_USER, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE,
                         NULL, &hCUSubKey, NULL ) != ERROR_SUCCESS )
    {
        hRet = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // get the bacup info folder
    dwTmp = sizeof( szBackupPath );
    szBackupPath[0] = 0;
    RegQueryValueEx( hKey, REGVAL_BKDIR, NULL, NULL, szBackupPath, &dwTmp );
    if ( szBackupPath[0] == 0 )
    {
        DWORD dwSize;

        // use user specified: either the same as cab location #S or default location #D
        if ( FAILED( GetTranslatedString( pszInf, pszSection, ADVINF_BACKUPPATH, szBackupPath, 
                                          sizeof(szBackupPath), &dwSize) ) || !IsFullPath( szBackupPath )  )
        {
            // use default dir
            GetProgramFilesDir( szBackupPath, sizeof( szBackupPath ) );
            AddPath( szBackupPath, DEF_BACKUPPATH );
            CreateFullPath(szBackupPath, TRUE);
            //CreateDirectory( szBackupPath, NULL );
            //if ( dwFlags & COREINSTALL_BKINSTALL )
                //SetFileAttributes( szBackupPath, FILE_ATTRIBUTE_HIDDEN );
            AddPath( szBackupPath, szModule );
        }
    }

    // set the flags and Process the AddReg/DelReg lines 
    dwTmp = (dwFlags & COREINSTALL_ROLLBACK) ? IE4_RESTORE : 0;
    dwTmp |= (dwFlags & COREINSTALL_ROLLBKDOALL) ? IE4_FRDOALL : 0;
    dwTmp |= IE4_NOPROGRESS;

    // process files first ...
    GetUniBackupName( hKey, szBackupBase, sizeof(szBackupBase), szBackupPath, szModule );    
    hRet = ProcessAllFiles( ctx.hWnd, pszSection, pszSrcDir, szBackupPath, szBackupBase, pszCatalogs, szModule, dwTmp );

    // process regs second ...    
    
    // create/open the subkey where the registry backup info stored
    if ( FAILED(hRet) ) 
        goto done;

    // On win95 and save/rollback client and hive not loaded, proce
    if ( (ctx.wOSVer == _OSVER_WIN95) && !ctx.bHiveLoaded )
    {
        GetUniHiveKeyName( hKey, ctx.szRegHiveKey, sizeof(ctx.szRegHiveKey), szBackupPath );
        lstrcpy( szBuf, szBackupPath );
        // make sure the path folders are not hiden and not LFN
        // flag TRUE: Set the path folders to NORMAL, save the old once in adwAttr
        // BUGBUG:  assume no deep than 8 levels here
        //
        SetPathForRegHiveUse( szBuf, adwAttr, 8, TRUE );
        GetShortPathName( szBuf, szBuf, sizeof(szBuf) );
        AddPath( szBuf, ctx.szRegHiveKey );

        // 4 possibilities exist:
        // Case 1: Reg uinstall file exists but IE4RegBackup doesn't exist
        //          - user is upgrading over IE4, load the file as a hive

        // Case 2: Reg uinstall file doesn't exist and IE4RegBackup doesn't exist
        //          - clean install, create a hive under HKEY_LOCAL_MACHINE

        // Case 3: Reg uninstall file doesn't exist but IE4RegBackup exists
        //          - user is upgrading over an older IE4 build which saved
        //            the reg backup info into the registry itself, call RegSaveKey
        //            to export the backup key to a file, then delete the backup key
        //             and load the file as a hive

        // Case 4: Reg uninstall file exists and IE4RegBackup exists
        //          - THIS CASE SHOULDN'T HAPPEN AT ALL!  If somehow happens,
        //            we will default to Case 1.

        // to be safe, unload any previously loaded hive and delete the key
        RegUnLoadKey(HKEY_LOCAL_MACHINE, ctx.szRegHiveKey);
        RegDeleteKeyRecursively(HKEY_LOCAL_MACHINE, (char *) ctx.szRegHiveKey);

        // Case 1 (or Case 4)
        if (RegLoadKey(HKEY_LOCAL_MACHINE, ctx.szRegHiveKey, szBuf) == ERROR_SUCCESS)
        {
            ctx.bHiveLoaded = TRUE;
        }
        else
        {
            // To create a hive do the following steps:
            // Step 1: Create a subkey under HKEY_LOCAL_MACHINE
            // Step 2: Call RegSaveKey on the subkey to save it to a file
            // Step 3: Delete the subkey
            // Step 4: Load the file as a hive

            // Step 1
            if ( RegCreateKeyEx( hKey, REGSUBK_REGBK, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, 
                                 NULL, &hSubKey, NULL ) == ERROR_SUCCESS )
            {
                LONG lErr;

                // to be safe, delete any old reg unisntall file
                SetFileAttributes(szBuf, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szBuf);

                lErr = RegSaveKey( hSubKey, szBuf, NULL);
                RegCloseKey(hSubKey);
                hSubKey = NULL;

                if (lErr == ERROR_SUCCESS)
                {
                    // Step 3
                    RegDeleteKeyRecursively(hKey, REGSUBK_REGBK);

                    // Step 4
                    if (RegLoadKey(HKEY_LOCAL_MACHINE, ctx.szRegHiveKey, szBuf) == ERROR_SUCCESS)
                    {
                        ctx.bHiveLoaded = TRUE;
                    }
                }
            }
            else
            {
                hRet = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }
        }
    }

    // create/open the backup reg key
    if (RegCreateKeyEx( ctx.bHiveLoaded ? HKEY_LOCAL_MACHINE : hKey,
                        ctx.bHiveLoaded ? ctx.szRegHiveKey : REGSUBK_REGBK,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ|KEY_WRITE, NULL, &hSubKey, NULL ) != ERROR_SUCCESS)
    {
        hRet = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // set the flags and Process the AddReg/DelReg lines 
    dwTmp = (dwFlags & COREINSTALL_ROLLBACK) ? IE4_RESTORE : 0;
    dwTmp |= (dwFlags & COREINSTALL_ROLLBKDOALL) ? IE4_FRDOALL : 0;

    if ( dwFlags & COREINSTALL_ROLLBACK )
    {
        HRESULT hret1;

        // RegRestoreAllEx will restore all the backed-up reg entries in one shot
        hRet = RegRestoreAllEx( hSubKey );
        hret1 = RegRestoreAllEx( hCUSubKey );
        if ( FAILED(hret1) )
            hRet = hret1;
    }
    else
    {
        // Save all reg sections
        hRet = ProcessAllRegSec( ctx.hWnd, NULL, pszInf, pszSection, hSubKey, hCUSubKey, dwTmp, &bAtleastOneReg );
    }

    // after all the reg work, unload the hive to reg backup file and record where those 
    // reg backup data are in registry.
    if ( (ctx.wOSVer == _OSVER_WIN95) && ctx.bHiveLoaded )
    {
        // flush the key and unload the hive
        ctx.bHiveLoaded = FALSE;
        
        RegFlushKey(hSubKey);
        RegCloseKey(hSubKey);
        hSubKey = NULL;

        RegUnLoadKey(HKEY_LOCAL_MACHINE, ctx.szRegHiveKey);
        // Flag:  FALSE; reset the path folders to its orignal attributes
        SetPathForRegHiveUse( szBackupPath, adwAttr, 8, FALSE );

        if ( dwFlags & COREINSTALL_BKINSTALL )
        {
            // write the file<key>, path and size of the reg uninstall file to the registry
            RegSetValueEx( hKey, c_szRegUninstPath, 0, REG_SZ, (LPBYTE)szBuf, lstrlen(szBuf) + 1 );
            // the size can be used to validate the file during RegRestore; currently NOT USED
            dwTmp = MyFileSize( szBuf );
            RegSetValueEx( hKey, c_szRegUninstSize, 0, REG_DWORD, (LPBYTE)&dwTmp, sizeof(dwTmp) );
        }
        else if ( SUCCEEDED( hRet ) )
        {
            // delete reg data backup file
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
            RegDeleteValue(hKey, c_szRegUninstPath);
            RegDeleteValue(hKey, c_szRegUninstSize);
        }            
    }

    // store & cleanup the backup information
    if ( SUCCEEDED( hRet ) )
    {
        PSTR ptmp;
        PCSTR pszCatalogName;

        lstrcpy( szBuf, szBackupPath );
        AddPath( szBuf, szBackupBase );
        ptmp = szBuf + lstrlen(szBuf);
        lstrcpy( ptmp, ".DAT" );        

        if ( dwFlags & COREINSTALL_BKINSTALL )
        {   
            dwTmp = MyFileSize( szBuf );
            RegSetValueEx( hKey, REGVAL_BKFILE, 0, REG_SZ, szBuf, lstrlen(szBuf)+1 );
            RegSetValueEx( hKey, REGVAL_BKSIZE, 0, REG_DWORD, (LPBYTE)&dwTmp, sizeof(DWORD) );
            RegSetValueEx( hKey, REGVAL_BKDIR, 0, REG_SZ, szBackupPath, lstrlen(szBackupPath)+1 );
            RegSetValueEx( hKey, REGVAL_BKINSTINF, 0, REG_SZ, pszInf, lstrlen(pszInf)+1 );
            RegSetValueEx( hKey, REGVAL_BKINSTSEC, 0, REG_SZ, pszSection, lstrlen(pszSection)+1 );
            RegSetValueEx( hKey, REGVAL_BKREGDATA, 0, REG_SZ, bAtleastOneReg ? "y" : "n", 2 );
            if ( SUCCEEDED(GetTranslatedString( pszInf, pszSection, ADVINF_MODVER,
                                                szBuf, sizeof(szBuf), NULL)) && szBuf[0])                        
            {
                RegSetValueEx( hKey, REGVAL_BKMODVER, 0, REG_SZ, szBuf, lstrlen(szBuf)+1 );
            }
            for (pszCatalogName = pszCatalogs;  *pszCatalogName;  pszCatalogName += lstrlen(pszCatalogName) + 1)
            {
                HKEY hkCatalogKey;
                CHAR szFullCatalogName[MAX_PATH];

                if (RegCreateKeyEx(hKey, REGSUBK_CATALOGS, 0, NULL, REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE, NULL, &hkCatalogKey, NULL) == ERROR_SUCCESS)
                {
                    DWORD dwVal = 1;

                    RegSetValueEx(hkCatalogKey, pszCatalogName, 0, REG_DWORD, (CONST BYTE *) &dwVal, sizeof(dwVal));
                    RegCloseKey(hkCatalogKey);
                }

                lstrcpy(szFullCatalogName, szBackupPath);
                AddPath(szFullCatalogName, pszCatalogName);
                if (FileExists(szFullCatalogName))
                    SetFileAttributes(szFullCatalogName, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);
            }
        }
        else if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            // delete the catalogs
            for (pszCatalogName = pszCatalogs;  *pszCatalogName;  pszCatalogName += lstrlen(pszCatalogName) + 1)
            {
                HKEY hkCatalogKey;
                CHAR szFullCatalogName[MAX_PATH];

                if (RegOpenKeyEx(hKey, REGSUBK_CATALOGS, 0, KEY_WRITE, &hkCatalogKey) == ERROR_SUCCESS)
                {
                    RegDeleteValue(hkCatalogKey, pszCatalogName);
                    RegCloseKey(hkCatalogKey);
                }

                lstrcpy(szFullCatalogName, szBackupPath);
                AddPath(szFullCatalogName, pszCatalogName);
                if (FileExists(szFullCatalogName))
                {
                    SetFileAttributes(szFullCatalogName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(szFullCatalogName);
                }
            }

            // delete backup .dat .ini files
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
            lstrcpy( ptmp, ".INI" );
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
            MyRemoveDirectory( szBackupPath );

            // since we have rollback all the files and delete the backup .dat .ini files, we
            // should re-set the backup file size to ZERO to allow reg restore continue for whatever
            // following users.
            dwTmp = 0;
            RegSetValueEx( hKey, REGVAL_BKSIZE, 0, REG_DWORD, (LPBYTE)&dwTmp, sizeof(DWORD) );    
            RegSetValueEx( hKey, REGVAL_BKREGDATA, 0, REG_SZ, "n", 2 );
            RegDeleteValue( hKey, REGVAL_BKMODVER );
        }
    }

done:

    if ( hSubKey )
    {
        RegCloseKey( hSubKey );
    }

    if ( hKey )
    {
        RegCloseKey( hKey );
    }

    if ( hCUSubKey )
    {
        BOOL bEmpty = TRUE;
        DWORD dwKeys, dwValues;

        if ( (RegQueryInfoKey(hCUSubKey, NULL, NULL, NULL, &dwKeys, NULL, NULL, 
                              &dwValues, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) &&
             (dwKeys || dwValues) )
        {
            // not empty key
            bEmpty = FALSE;
        }

        RegCloseKey( hCUSubKey );

        if ( bEmpty )
        {
            // delete the empty key
            if ( RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_SAVERESTORE, 0, KEY_READ|KEY_WRITE, &hCUSubKey) == ERROR_SUCCESS)
            {
                RegDeleteKeyRecursively( hCUSubKey, szModule );
                RegCloseKey( hCUSubKey );
            }
        }

    }

    if ( gst_pszFiles )
    {
        LocalFree( gst_pszFiles );
        gst_pszFiles = NULL;
        gst_pszEndLastFile = NULL;
    }

    AdvWriteToLog("SaveRestoreInfo: End hr=0x%1!x! %2\r\n", hRet, szModule);
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessAllRegSec( HWND hw, PCSTR pszTitle, PCSTR pszInf, PCSTR pszSection, HKEY hKey, HKEY hCUKey, DWORD dwFlags, BOOL *lpbOneReg )
{
    int     i, arraysize;
    PSTR    pszOneSec;
    PSTR    pszStr;
    HRESULT hRet = S_OK;
    char    szBuf[MAX_PATH];

    AdvWriteToLog("ProcessAllRegSec: \r\n");
    arraysize = ARRAYSIZE( RegInfOpt );
    for ( i=0; i<arraysize; i++ )
    {
        szBuf[0] = 0;
        pszStr = szBuf;

        GetTranslatedString( pszInf, pszSection, RegInfOpt[i].pszInfKey,
                             szBuf, sizeof(szBuf), NULL);
        
        // Parse the arguments, SETUP engine is not called to process this line.  So we check on \".
        pszOneSec = GetStringField( &pszStr, ",", '\"', TRUE );
        while ( (hRet == S_OK) && pszOneSec && *pszOneSec )
        {  
            if ( i == 0 )  // AddReg section only
                dwFlags |= IE4_NOENUMKEY;
            else
                dwFlags &= ~IE4_NOENUMKEY;
            
            if (*pszOneSec != '!')
                 hRet = ProcessOneRegSec( hw, pszTitle, pszInf, pszOneSec, hKey, hCUKey, dwFlags, lpbOneReg );

            pszOneSec = GetStringField( &pszStr, ",", '\"', TRUE );
        }

    }
    AdvWriteToLog("ProcessAllRegSec: End hr=0x%1!x!\r\n", hRet);
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessOneRegSec( HWND hw, PCSTR pszTitle, PCSTR pszInf, PCSTR pszSec, HKEY hLMKey, HKEY hCUKey, DWORD dwFlags, BOOL *lpbOneReg  )
{
    int     j;
    PSTR    pszInfLine = NULL;                     
    HRESULT hResult = S_OK;
    PSTR    pszRootKey, pszSubKey, pszValueName, pszTmp1, pszTmp2;    
    HKEY    hKey;  
    
    AdvWriteToLog("ProcessOneRegSec: Section=%1\r\n", pszSec);
    for ( j=0; (hResult==S_OK); j++ ) 
    {
        if ( FAILED(hResult = GetTranslatedLine( pszInf, pszSec, j, &pszInfLine, NULL )) || 
                    !pszInfLine )
        {
        // if the failure due to no more items, set to normal return
        if ( hResult == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) )
            hResult = S_OK;

            break;
        }

        // at least, there is one reg data to be saved
        if ( lpbOneReg && !*lpbOneReg )
            *lpbOneReg = TRUE;

        // Parse out the fields Registry op-line.
        ParseCustomLine( pszInfLine, &pszRootKey, &pszSubKey, &pszValueName, &pszTmp1, &pszTmp2, FALSE, TRUE );

        if ( !lstrcmpi( pszRootKey, "HKCU") || !lstrcmpi( pszRootKey, "HKEY_CURRENT_USER" ) )
             hKey = hCUKey;
        else
             hKey = hLMKey;
        
        // Check the specified registry branch and grab the contents.
        hResult = RegSaveRestore( hw, pszTitle, hKey, pszRootKey, pszSubKey, pszValueName, dwFlags );

        LocalFree( pszInfLine );
        pszInfLine = NULL;
    }

    AdvWriteToLog("ProcessOneRegSec: End hr=0x%1!x! %2\r\n", hResult, pszSec);
    return hResult;
}        

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessAllFiles( HWND hw, PCSTR pszSection, PCSTR pszSrcDir, PCSTR pszBackupPath,
                         PCSTR pszBaseName, PCSTR pszCatalogs, PCSTR pszModule, DWORD dwFlags  )
{    
    HRESULT hRet = S_OK;
    PCSTR pszCatalogName;

    AdvWriteToLog("ProcessAllFiles: Sec=%1, SrcDir=%2, BackupPath=%3\r\n", pszSection, pszSrcDir, pszBackupPath);
    // if CORESINSTALL_ROLLBKDOALL is on, no need to build the filelist.  FileRestore will 
    // rollback everything based on its .INI backup data index file.  Otherwise, build
    // file list gst_pszFiles inside    
    gst_pszFiles = NULL;
    if ( !(dwFlags & IE4_FRDOALL) )
    {
        // backup/restore the files referred by CopyFiles, DelFiles, RenFiles
        //
        gst_pszFiles = (PSTR)LocalAlloc( LPTR, FILELIST_SIZE );  // allocat 10k
        gst_pszEndLastFile = gst_pszFiles; // already will have 2 zeros
        if ( !gst_pszFiles )
        { 
            ErrorMsg( hw, IDS_ERR_NO_MEMORY );
            hRet = E_OUTOFMEMORY;
            return hRet;           
        }

        hRet = ProcessFileSections( pszSection, pszSrcDir, MyFileQueueCallback );
    }

    // if a catalog is specified, backup/restore it
    for (pszCatalogName = pszCatalogs;  SUCCEEDED(hRet) && *pszCatalogName;  pszCatalogName += lstrlen(pszCatalogName) + 1)
    {
        DWORD dwRet;
        CHAR szPrevCatalog[MAX_PATH];

        AdvWriteToLog("ProcessAllFiles: Processing catalog=%1\r\n", pszCatalogName);

        lstrcpy(szPrevCatalog, pszBackupPath);
        AddPath(szPrevCatalog, pszCatalogName);
            
        if ((dwFlags & IE4_RESTORE)  ||  (dwFlags & IE4_FRDOALL))
        {
            // first delete the current catalog and then install the previous one
            dwRet = g_pfSfpDeleteCatalog(pszCatalogName);
            AdvWriteToLog("\tProcessAllFiles: SfpDeleteCatalog returned=%1!lu!\r\n", dwRet);
            if (dwRet != ERROR_SUCCESS)
                hRet = E_FAIL;

            if (SUCCEEDED(hRet)  &&  FileExists(szPrevCatalog))
            {
                dwRet = g_pfSfpInstallCatalog(szPrevCatalog, NULL);
                AdvWriteToLog("\tProcessAllFiles: SfpInstallCatalog returned=%1!lu!\r\n", dwRet);
                if (dwRet != ERROR_SUCCESS)
                    hRet = E_FAIL;
            }
        }
        else
        {
            BOOL bBackupCatalog = FALSE;
            CHAR szBuf[MAX_PATH];

            if (pszModule != NULL)
            {
                HKEY hkCatalogKey;

                lstrcpy(szBuf, REGKEY_SAVERESTORE);
                AddPath(szBuf, pszModule);
                AddPath(szBuf, REGSUBK_CATALOGS);

                // back-up the catalog if it hasn't been already backed up
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_QUERY_VALUE, &hkCatalogKey) == ERROR_SUCCESS)
                {
                    if (RegQueryValueEx(hkCatalogKey, pszCatalogName, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
                        bBackupCatalog = TRUE;

                    RegCloseKey(hkCatalogKey);
                }
                else
                    bBackupCatalog = TRUE;
            }
            else
            {
                // back-up the catalog if the file back-up .dat doesn't exist
                lstrcpy(szBuf, pszBackupPath);
                AddPath(szBuf, pszBaseName);
                lstrcat(szBuf, ".dat");

                if (!FileExists(szBuf))
                    bBackupCatalog = TRUE;
            }

            if (bBackupCatalog)
            {
                dwRet = g_pfSfpDuplicateCatalog(pszCatalogName, pszBackupPath);
                AdvWriteToLog("\tProcessAllFiles: SfpDuplicateCatalog returned=%1!lu!\r\n", dwRet);
                if (dwRet != ERROR_SUCCESS  &&  dwRet != ERROR_FILE_NOT_FOUND)
                    hRet = E_FAIL;
            }
        }
    }

    if ( SUCCEEDED(hRet) )
    {
        hRet = FileSaveRestore( hw, gst_pszFiles, (PSTR)pszBackupPath, (PSTR)pszBaseName, dwFlags );
    }

    AdvWriteToLog("ProcessAllFiles: End hr=0x%1!x!\r\n", hRet);
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessFileSections( PCSTR pszSection, PCSTR pszSrcDir, MYFILEQUEUECALLBACK pMyFileQueueCallback )
{    
    PVOID    pContext = NULL;
    HRESULT  hResult  = S_OK;

    AdvWriteToLog("ProcessFileSections: Sec=%1\r\n", pszSection);
    // Build File list include all the files in CopyFiles/DelFiles/renFiles
    //

    // Setup Context data structure initialized for us for default UI provided by Setup API.
    pContext = pfSetupInitDefaultQueueCallbackEx( NULL, 
                                                  INVALID_HANDLE_VALUE,
                                                  0, 0, NULL );

    if ( pContext == INVALID_HANDLE_VALUE ) 
    {
        hResult = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

    if ( !pfSetupInstallFromInfSection( NULL, ctx.hInf, pszSection, SPINST_FILES, NULL,
                                        pszSrcDir, SP_COPY_NEWER,
                                        pMyFileQueueCallback,
                                        pContext, NULL, NULL ) )
    {
        hResult = HRESULT_FROM_SETUPAPI(GetLastError());
        pfSetupTermDefaultQueueCallback( pContext );
        goto done;
    }

    // Free Context Data structure
    pfSetupTermDefaultQueueCallback( pContext );

done:
    AdvWriteToLog("ProcessFileSections: End hr=0x%1!x!\r\n",hResult);
    return hResult;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

UINT WINAPI MyFileQueueCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 )
{       
    UINT retVal = FILEOP_SKIP;

    switch(Notification)
    {
        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_STARTCOPY:
            {
                FILEPATHS *pFilePath;
                int len;
                PCSTR  pTmp;

                pFilePath = (FILEPATHS *)parm1;

                if ( !gst_pszFiles )
                {
                        retVal = FILEOP_ABORT;
                        SetLastError( ERROR_OUTOFMEMORY );
                        break;
                }
                
                if ( Notification == SPFILENOTIFY_STARTRENAME )
                {
                    len = lstrlen( pFilePath->Source ) + 1;
                    pTmp = pFilePath->Source;
                }
                else
                {
                    len = lstrlen( pFilePath->Target ) + 1;
                    pTmp = pFilePath->Target;
                }

                if ( (FILELIST_SIZE - (gst_pszEndLastFile - gst_pszFiles )) <= (len + 8) )
                {
                    retVal = FILEOP_ABORT;
                    SetLastError( ERROR_OUTOFMEMORY );
                    break;
                }

                lstrcpy( gst_pszEndLastFile, pTmp );
                gst_pszEndLastFile += len;
                *gst_pszEndLastFile = 0;      // the second '\0' to end the list                            
            }
            break;

        case SPFILENOTIFY_NEEDMEDIA:
            return ( MyFileQueueCallback2( Context, Notification, parm1, parm2 ) );

        default:
            return ( pfSetupDefaultQueueCallback( Context, Notification, parm1, parm2 ) );
    }

    return( retVal );
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

BOOL GetFullInfNameAndSrcDir( PCSTR pszInfFilename, PSTR pszFilename, PSTR pszSrcDir )
{
    BOOL bRet = FALSE;
    UINT uiErrid = 0;
    PCSTR pszErrParm1 = NULL;
    char szBuf[MAX_PATH];

    if ( !pszInfFilename || !pszFilename || !(*pszInfFilename) )
        goto done;

    if ( !IsFullPath( pszInfFilename ) && pszSrcDir && *pszSrcDir )
    {
        lstrcpy( szBuf, pszSrcDir );
        AddPath( szBuf, pszInfFilename );
    }
    else
        lstrcpy( szBuf, pszInfFilename );

    if ( GetFileAttributes( szBuf ) == 0xFFFFFFFF ) 
    {
        if ( IsFullPath( szBuf ) )
        {
            uiErrid = IDS_ERR_CANT_FIND_FILE;
            pszErrParm1 = pszInfFilename;
            goto done;
        }

        // If the file doesn't exist in the current directory, check the
        // Windows\inf directory

        if ( !GetWindowsDirectory( szBuf, sizeof(szBuf) ) )
        {
            uiErrid = IDS_ERR_GET_WIN_DIR;
            goto done;
        }

        AddPath( szBuf, "inf" );        
        AddPath( szBuf, pszInfFilename );

        if ( GetFileAttributes( szBuf) == 0xFFFFFFFF ) 
        {
            uiErrid = IDS_ERR_CANT_FIND_FILE;
            pszErrParm1 = pszInfFilename;
            goto done;
        }
    } 
    
    // Generate the source directory from the inf path.
    lstrcpy( pszFilename, szBuf );

    GetParentDir( szBuf );        
    lstrcpy( pszSrcDir, szBuf );    

    bRet = TRUE;

done:

    if ( uiErrid )
        ErrorMsg1Param( ctx.hWnd, uiErrid, pszErrParm1 );

    return bRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

void CleanRegLogFile( PCSTR pcszLogFileSecName )
{
    char szLogFileName[MAX_PATH];
    char szBuf[MAX_PATH];
    HKEY hkSubKey;

    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SAVERESTORE, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
    {
        DWORD dwDataLen = sizeof(szLogFileName);

        if (RegQueryValueEx(hkSubKey, pcszLogFileSecName, NULL, NULL, szLogFileName, &dwDataLen) != ERROR_SUCCESS)
            *szLogFileName = '\0';

        RegCloseKey(hkSubKey);
    }

    if (*szLogFileName)
    {
        if (szLogFileName[1] != ':')           // crude way of determining if fully qualified path is specified or not
        {
            GetWindowsDirectory(szBuf, sizeof(szBuf));          // default to windows dir
            AddPath(szBuf, szLogFileName);
        }
        else
            lstrcpy(szBuf, szLogFileName);

        DeleteFile( szBuf );
    }
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

BOOL VerifyBackupRegData( HKEY hKey )
{
    HKEY    hSubKey;
    char    szBackData[MAX_PATH];
    DWORD   dwSize = 0, dwBkSize;
    BOOL    bRet = FALSE;

    if ( ctx.wOSVer == _OSVER_WIN95 )
    {
        dwSize = sizeof( szBackData );
        if ( RegQueryValueEx( hKey, c_szRegUninstPath, NULL, NULL, szBackData, &dwSize ) == ERROR_SUCCESS )
        {
            dwSize = sizeof( DWORD );
            if ( RegQueryValueEx( hKey, c_szRegUninstSize, NULL, NULL, (LPBYTE)&dwBkSize, &dwSize ) == ERROR_SUCCESS )
            {
                if ( MyFileSize(szBackData) == dwBkSize )
                {
                    bRet = TRUE;
                    return bRet;
                }
            }
        }
    }

    // if you are here, the file backup info is OK. We check on reg backup info
    if ( RegOpenKeyEx( hKey, REGSUBK_REGBK, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
    {
        HKEY hsubsubKey;
    
        if ( RegOpenKeyEx( hSubKey, "0", 0, KEY_READ, &hsubsubKey) == ERROR_SUCCESS)
        {
            if ( (RegQueryInfoKey( hsubsubKey, NULL, NULL, NULL, NULL, NULL, NULL, &dwSize,
                                   NULL, NULL, NULL, NULL ) == ERROR_SUCCESS) && dwSize )
            {
                bRet = TRUE;
            }
            RegCloseKey( hsubsubKey );
        }
        RegCloseKey(hSubKey);
    }

    return bRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

BOOL VerifyBackupInfo( HKEY hKey, HKEY hCUKey )
{
    char    szBackData[MAX_PATH];
    DWORD   dwSize, dwBkSize = 0;
    BOOL    bRet = FALSE;
    HKEY    hSubKey = NULL;
    
    if ( hKey )
    {
        // verify the backup file first
        dwSize = sizeof( szBackData );
        if ( RegQueryValueEx( hKey, REGVAL_BKFILE, NULL, NULL, szBackData, &dwSize ) == ERROR_SUCCESS )
        {
            dwSize = sizeof( DWORD );
            if ( RegQueryValueEx( hKey, REGVAL_BKSIZE, NULL, NULL, (LPBYTE)&dwBkSize, &dwSize ) == ERROR_SUCCESS )
            {
                if ( MyFileSize(szBackData) == dwBkSize )
                {
                    // if you are here, the file backup info is OK. We check on reg backup info
                    dwSize = sizeof( szBackData );
                    if ( (RegQueryValueEx( hKey, REGVAL_BKREGDATA, NULL, NULL, (LPBYTE)szBackData, &dwSize ) == ERROR_SUCCESS )  &&
                         ( szBackData[0] == 'n' ) )
                    {
                        // no registry data backed up, so no need to verify further
                        bRet = TRUE;
                    }
                    else
                    {
                        if ( VerifyBackupRegData( hKey ) || (hCUKey && VerifyBackupRegData( hCUKey )) )
                        {
                            bRet = TRUE;
                        }
                    }
                }
            }
        }
    }
    return bRet;
}


typedef HRESULT (*CHECKTOKENMEMBERSHIP)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

BOOL CheckToken(BOOL *pfIsAdmin)
{
    BOOL bNewNT5check = FALSE;
    HINSTANCE hAdvapi32 = NULL;
    CHECKTOKENMEMBERSHIP pf;
    PSID AdministratorsGroup;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    hAdvapi32 = LoadLibrary("advapi32.dll");
    if (hAdvapi32)
    {
        pf = (CHECKTOKENMEMBERSHIP)GetProcAddress(hAdvapi32, "CheckTokenMembership");
        if (pf)
        {
            bNewNT5check = TRUE;
            *pfIsAdmin = FALSE;
            if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
            {
                pf(NULL, AdministratorsGroup, pfIsAdmin);
                FreeSid(AdministratorsGroup);
            }
        }
        FreeLibrary(hAdvapi32);
    }
    return bNewNT5check;
}
//***************************************************************************
//* Functions:  IsNTAdmin()                                                 *
//*                                                                         *
//* Returns     TRUE if our process has admin priviliges.                   *
//*             FALSE otherwise.                                            *
//***************************************************************************
BOOL WINAPI IsNTAdmin( DWORD dwReserved, DWORD *lpdwReserved )
{
      static int    fIsAdmin = 2;
      HANDLE        hAccessToken;
      PTOKEN_GROUPS ptgGroups;
      DWORD         dwReqSize;
      UINT          i;
      SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
      PSID AdministratorsGroup;
      BOOL bRet;

      //
      // If we have cached a value, return the cached value. Note I never
      // set the cached value to false as I want to retry each time in
      // case a previous failure was just a temp. problem (ie net access down)
      //

      bRet = FALSE;
      ptgGroups = NULL;

      if( fIsAdmin != 2 )
         return (BOOL)fIsAdmin;

      if (!CheckToken(&bRet))
      {
          if(!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hAccessToken ) )
             return FALSE;

          // See how big of a buffer we need for the token information
          if(!GetTokenInformation( hAccessToken, TokenGroups, NULL, 0, &dwReqSize))
          {
              // GetTokenInfo should the buffer size we need - Alloc a buffer
              if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                  ptgGroups = (PTOKEN_GROUPS) LocalAlloc(LMEM_FIXED, dwReqSize);
              
          }
          
          // ptgGroups could be NULL for a coupla reasons here:
          // 1. The alloc above failed
          // 2. GetTokenInformation actually managed to succeed the first time (possible?)
          // 3. GetTokenInfo failed for a reason other than insufficient buffer
          // Any of these seem justification for bailing.
          
          // So, make sure it isn't null, then get the token info
          if(ptgGroups && GetTokenInformation(hAccessToken, TokenGroups, ptgGroups, dwReqSize, &dwReqSize))
          {
              if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
              {
                  
                  // Search thru all the groups this process belongs to looking for the
                  // Admistrators Group.
                  
                  for( i=0; i < ptgGroups->GroupCount; i++ )
                  {
                      if( EqualSid(ptgGroups->Groups[i].Sid, AdministratorsGroup) )
                      {
                          // Yea! This guy looks like an admin
                          fIsAdmin = TRUE;
                          bRet = TRUE;
                          break;
                      }
                  }
                  FreeSid(AdministratorsGroup);
              }
          }
          if(ptgGroups)
              LocalFree(ptgGroups);

          // BUGBUG: Close handle here? doc's aren't clear whether this is needed.
          CloseHandle(hAccessToken);
      }
      else if (bRet)
          fIsAdmin = TRUE;

      return bRet;
}

//-----------------------------------------------------------------------------------------
//
// MyFileCheckCallback()
//
//-----------------------------------------------------------------------------------------

UINT WINAPI MyFileCheckCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 )
{       
    UINT retVal = FILEOP_SKIP;

    switch(Notification)
    {
        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_STARTCOPY:
        {
            FILEPATHS   *pFilePath;
            PCSTR       pTmp;
            HANDLE      hFile;

            pFilePath = (FILEPATHS *)parm1;
            
            if ( Notification == SPFILENOTIFY_STARTRENAME )
            {
                pTmp = pFilePath->Source;
            }
            else
            {
                pTmp = pFilePath->Target;
            }

            if ( FileExists(pTmp) )                        // original file exists
            {
                // check if the File is in use
                if ((hFile = CreateFile(pTmp, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
                {
                    // File is in use which will trig the reboot if we actually install this section.                      
                    gst_hNeedReboot = S_OK;

                    // no need to continue if at least one file is in use, reboot is needed.
                    retVal = FILEOP_ABORT;
                }
                else
                {
                    // file not in use
                    CloseHandle(hFile);
                }
            }
        }
        break;

        case SPFILENOTIFY_NEEDMEDIA:
            return ( MyFileQueueCallback2( Context, Notification, parm1, parm2 ) );

        default:
            return ( pfSetupDefaultQueueCallback( Context, Notification, parm1, parm2 ) );
    }

    return( retVal );
}

//***************************************************************************
//*                                                                         *
//* NAME:       RebootCheckOnInstall                                        *
//*                                                                         *
//* SYNOPSIS:   Check reboot condition if given INF install section is      *
//*             installed.                                                  *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*             PCSTR           The INF filename                            *
//*             PCSTR           INF Section name                            *
//*                                                                         *
//* RETURNS:    HRESULT:                                                    *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI RebootCheckOnInstall( HWND hWnd, PCSTR pszINF, PCSTR pszSection, DWORD dwFlags )
{
    HRESULT hRet = S_FALSE;
    char    szSrcDir[MAX_PATH];
    char    szRealSec[100];
    
    // Validate parameters:
    // if INF filename info is missing, invalid.
    if ( !pszINF || !*pszINF )
        return hRet;

    ctx.wQuietMode = QUIETMODE_ALL;
    ctx.hWnd      = hWnd;

    if ( !IsFullPath( pszINF ) )
    {
         hRet = E_INVALIDARG;
         goto done;
    }
    else
    {
        lstrcpy( szSrcDir, pszINF );
        GetParentDir( szSrcDir );
    }

    hRet = CommonInstallInit( pszINF, pszSection, szRealSec, sizeof(szRealSec), NULL, FALSE, COREINSTALL_REBOOTCHECKONINSTALL );
    if ( FAILED( hRet ) ) 
    {
        goto done;
    }

    hRet = SetLDIDs( pszINF, szRealSec, 0, NULL );
    if ( FAILED( hRet ) ) 
    {
        goto done;
    }

    gst_hNeedReboot = S_FALSE;
    hRet = ProcessFileSections( szRealSec, szSrcDir, MyFileCheckCallback );
    if ( SUCCEEDED(hRet) || (gst_hNeedReboot == S_OK) )
    {
        hRet = gst_hNeedReboot;
    }
    
  done:

    CommonInstallCleanup();
    return hRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RegSaveRestoreOnINF                                         *
//*                                                                         *
//* SYNOPSIS:   Save or restore the given INF section to given reg key      *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*             PCSTR           The Title if messagebox displayed           *
//*             PCSTR           The INF filename                            *
//*             PCSTR           INF Section name                            *
//*             HKEY            The backup reg key handle                   *
//*             DWORD           Flags                                       *
//*                                                                         *
//* RETURNS:    HRESULT:                                                    *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI RegSaveRestoreOnINF( HWND hWnd, PCSTR pcszTitle, PCSTR pszInf, 
                                    PCSTR pszSection, HKEY hLMBackKey, HKEY hCUBackKey, DWORD dwFlags )
{
    HRESULT hRet = S_OK;
    CHAR    szRealInstallSection[100];
    PSTR  pszOldTitle;
    HWND  hwndOld;
    BOOL  bDoCommonInit = FALSE;

    AdvWriteToLog("RegSaveRestoreOnINF: Inf=%1\r\n", pszInf);
    hwndOld = ctx.hWnd;
    pszOldTitle = ctx.lpszTitle;

    if (hWnd != INVALID_HANDLE_VALUE)
        ctx.hWnd = hWnd;

    if ( dwFlags & ARSR_NOMESSAGES )
        ctx.wQuietMode |= QUIETMODE_ALL;

    if ( pcszTitle != NULL )
        ctx.lpszTitle = (PSTR)pcszTitle;

    if ( (dwFlags & ARSR_RESTORE) && !(dwFlags & ARSR_REMOVREGBKDATA) && !pszInf && !pszSection  )
    {       
        HRESULT hret1 = S_OK;
        // restore all case
        if ( hLMBackKey )
            hRet = RegRestoreAllEx( hLMBackKey );
    
        if ( ( hLMBackKey != hCUBackKey) && hCUBackKey )
            hret1 = RegRestoreAllEx( hCUBackKey );

        if ( FAILED(hret1) )
            hRet = hret1;

        goto done;
    }
    
    // params validation checks
    if ( !IsFullPath(pszInf) || (!hLMBackKey && !hCUBackKey) || (dwFlags & ARSR_REGSECTION) && !pszSection 
         || !(dwFlags & ARSR_RESTORE) && (dwFlags & ARSR_REMOVREGBKDATA) )
    {
        hRet = E_INVALIDARG;	
        goto done;
    }

    if ( !hCUBackKey )
        hCUBackKey = hLMBackKey;
    else if ( !hLMBackKey )
        hLMBackKey = hCUBackKey;

    bDoCommonInit = TRUE;
    hRet = CommonInstallInit( pszInf, (dwFlags & ARSR_REGSECTION) ? NULL : pszSection, szRealInstallSection, 
                              sizeof(szRealInstallSection), NULL, FALSE, 0 );
    if ( FAILED( hRet ) ) 
    {
        goto done;
    }
 
    if ( dwFlags & ARSR_REGSECTION )
    {
        // process One Reg Section to do Save / restore based on given flags
        hRet = ProcessOneRegSec( hWnd, pcszTitle, pszInf, pszSection, hLMBackKey, hCUBackKey, dwFlags, NULL );
    }
    else
    {
        // process All Reg sections
        hRet = ProcessAllRegSec( hWnd, pcszTitle, pszInf, szRealInstallSection, hLMBackKey, hCUBackKey, dwFlags, NULL );
    }

done:
    if ( bDoCommonInit )
        CommonInstallCleanup();
    ctx.hWnd = hwndOld;
    ctx.lpszTitle = pszOldTitle;
    AdvWriteToLog("RegSaveRestoreOnINF: End hr=0x%1!x!\r\n", hRet);
    return hRet;

}

//***************************************************************************
//*                                                                         *
//* NAME:       FileSaveRestoreOnINF                                        *
//*                                                                         *
//* SYNOPSIS:   Save or restore Files defined by GenInstall INF section     *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*				PCSTR			The Title if messagebox displayed			*
//*             PCSTR           The INF filename                            *
//*             PCSTR           INF Section name                            *
//*				PCSTR           backup directory path    					*
//*				PCSTR           backup file basename    					*
//*				DWORD			Flags										*
//*                                                                         *
//* RETURNS:    HRESULT:                                                    *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI FileSaveRestoreOnINF( HWND hWnd, PCSTR pszTitle, PCSTR pszInf, 
                                     PCSTR pszSection, PCSTR pszBackupDir, 
                                     PCSTR pszBaseBkFile, DWORD dwFlags )
{
    HRESULT	hRet = S_OK;
    char    szRealInstallSection[100] = {0};
    char    szSrcDir[MAX_PATH] = {0};
    PSTR    pszOldTitle;
    HWND    hOldwnd;
    BOOL    bDoCommonInit = FALSE;
    CHAR    szCatalogName[MAX_PATH];

    AdvWriteToLog("FileSaveRestoreOnINF: Inf=%1\r\n", (pszInf != NULL) ? pszInf : "NULL");
    if ( dwFlags & AFSR_NOMESSAGES )
        ctx.wQuietMode = QUIETMODE_ALL;

    hOldwnd = ctx.hWnd;
    if ( hWnd != INVALID_HANDLE_VALUE )
        ctx.hWnd = hWnd;

    pszOldTitle = ctx.lpszTitle;
    if ( pszTitle != NULL )
        ctx.lpszTitle = (PSTR)pszTitle;

    // params validation checks
    if ( !pszBackupDir || !*pszBackupDir || !pszBaseBkFile || !*pszBaseBkFile )
    {
        hRet = E_INVALIDARG;	
        goto done;
    }


    if ( (dwFlags & AFSR_RESTORE) && !pszInf && !pszSection  )
    {   
        dwFlags |= IE4_FRDOALL;
    }
    
    if ( !(dwFlags & IE4_FRDOALL) )
    {
        if ( !IsFullPath(pszInf) )
        {
            hRet = E_INVALIDARG;
            goto done;
        }
        else
        {
            bDoCommonInit = TRUE;
            hRet = CommonInstallInit( pszInf, pszSection, szRealInstallSection, 
                                      sizeof(szRealInstallSection), NULL, FALSE, 0 );
            if ( FAILED( hRet ) ) 
            {
                goto done;
            }
        }
    }

    if (pszInf != NULL)
    {
        lstrcpy( szSrcDir, pszInf );
        GetParentDir( szSrcDir );
    }

    // get the catalog name, if specified
    ZeroMemory(szCatalogName, sizeof(szCatalogName));

    if (pszInf == NULL)
    {
        CHAR szFullCatalogName[MAX_PATH];

        // NOTE: assume that the catalog name is <BaseBkFile>.cat.
        //       can't use the REGKEY_SAVERESTORE key to read the catalog name
        //       because this API doesn't go thru SaveRestoreInfo which updates
        //       the REGKEY_SAVERESTORE key.

        // check if the catalog file exists in the BackupDir
        lstrcpy(szFullCatalogName, pszBackupDir);
        AddPath(szFullCatalogName, pszBaseBkFile);
        lstrcat(szFullCatalogName, ".cat");
        if (FileExists(szFullCatalogName))
            wsprintf(szCatalogName, "%s.cat", pszBaseBkFile);
    }
    else
        GetTranslatedString(pszInf, szRealInstallSection, ADVINF_CATALOG_NAME, szCatalogName, sizeof(szCatalogName), NULL);

    if (*szCatalogName)
    {
        // load sfc.dll and the relevant proc's
        if (!LoadSfcDLL())
        {
            // couldn't load -- so empty out CatalogName
            *szCatalogName = '\0';
        }
    }

    // Process all the INF file sections
    hRet = ProcessAllFiles( hWnd, szRealInstallSection, szSrcDir, pszBackupDir, pszBaseBkFile, szCatalogName, NULL, dwFlags );

done:
    UnloadSfcDLL();
    if ( bDoCommonInit )
        CommonInstallCleanup();
    ctx.lpszTitle = pszOldTitle;
    ctx.hWnd = hOldwnd;
    AdvWriteToLog("FileSaveRestoreOnINF: End hr=0x%1!x!\r\n", hRet);
    return hRet;

}
#if 0
//-----------------------------------------------------------------------------------------
//
// MyGetSpecialFolder( int )
//
//-----------------------------------------------------------------------------------------
HRESULT MyGetSpecialFolder( HWND hwnd, int nFd, PSTR szPath )
{
    LPITEMIDLIST pidl;
    HRESULT      hRet;
    
    *szPath = 0;

    hRet = SHGetSpecialFolderLocation( hwnd, nFd, &pidl );
    if ( hRet == NOERROR )
    {
        if ( !SHGetPathFromIDList( pidl, szPath ) )
        {
            hRet = E_INVALIDARG;
        }
    }
    return hRet;
}
#endif
    
void MySetSpecialFolder( HKEY hkey, PCSTR pcszValueN, PSTR pszPath )
{
    DWORD dwTmp;

    if ( (ctx.wOSVer >= _OSVER_WINNT40) && AddEnvInPath( pszPath, pszPath ) )
        dwTmp = REG_EXPAND_SZ;
    else
        dwTmp = REG_SZ;

    RegSetValueExA( hkey, pcszValueN, 0, dwTmp, pszPath, lstrlen(pszPath)+1 );
}


//-----------------------------------------------------------------------------------------
//
// SetSysPathsInReg()
//
//-----------------------------------------------------------------------------------------
void SetSysPathsInReg()
{
    HKEY    hkey;
    char    szPath[MAX_PATH];
    char    szAS[100];
    DWORD   dwTmp;
    int     i = 0;
    PSTR    pszValName, pszKeyName;

    // Add StartUp, StartMenu, Programs and accessories sys pathes to registries for further ref
    // only if it is not set before.
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS )
    {        
        // Program Files path
        dwTmp = sizeof( szPath );
        if ( RegQueryValueEx( hkey, REGVAL_PROGRAMFILESPATH, 0, NULL, (LPBYTE)szPath, &dwTmp ) != ERROR_SUCCESS )
        {
            if ( GetProgramFilesDir( szPath, sizeof(szPath) ) )
            {
                MySetSpecialFolder( hkey, REGVAL_PROGRAMFILESPATH, szPath );
            }
        }

        // use wordpad.inf to look into the strings
        GetWindowsDirectory( szPath, sizeof(szPath) );
        AddPath( szPath, "inf\\wordpad.inf" );            

        // accessories Names
        for ( i=0; i<2; i++ )
        {
            if ( i == 0 )
            {
                // start menu name
                pszValName = REGVAL_SM_ACCESSORIES;
                pszKeyName = "APPS_DESC";
            }
            else
            {
                pszValName = REGVAL_PF_ACCESSORIES;
                if ( ctx.wOSVer >= _OSVER_WINNT40 )
                    pszKeyName = "APPS_DESC";
                else
                    pszKeyName = "Accessories";
            }

            dwTmp = sizeof( szAS );
            if ( RegQueryValueEx( hkey, pszValName, 0, NULL, (LPBYTE)szAS, &dwTmp ) != ERROR_SUCCESS )
            {       
                // need to open the new INF so save the current context
                if (SaveGlobalContext())
                {
                    if ( FAILED(GetTranslatedString(szPath, "Strings", pszKeyName, szAS, sizeof(szAS), NULL)))
                    {
                        lstrcpy(szAS, "Accessories");
                    }
                    RegSetValueExA( hkey, pszValName, 0, REG_SZ, szAS, lstrlen(szAS)+1 );
                    RestoreGlobalContext();
                }
            }
        }

        RegCloseKey(hkey);
    }

}

//-----------------------------------------------------------------------------------------
//
// ProcessPerUserSec
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessPerUserSec( PCSTR pcszInf, PCSTR pcszSec )
{
    char szSec[MAX_PATH];
    DWORD dwTmp;
    HRESULT hRet = S_OK;
    PERUSERSECTION PU_Sec = {0};


    if (SUCCEEDED(GetTranslatedString(pcszInf, pcszSec, ADVINF_PERUSER, szSec, sizeof(szSec), NULL)))
    {
        AdvWriteToLog("ProcessPerUserSec: \r\n");
        AdvWriteToLog("Inf=%1, InstallSec=%2, PerUserInstall=%3\r\n", pcszInf, pcszSec, szSec);
        // get GUID to create subkey
        if ( SUCCEEDED( GetTranslatedString( pcszInf, szSec, ADVINF_PU_GUID, PU_Sec.szGUID, sizeof(PU_Sec.szGUID), &dwTmp) ) )
        {                        
            PU_Sec.dwIsInstalled = GetTranslatedInt(pcszInf, szSec, ADVINF_PU_ISINST, 999);
            PU_Sec.bRollback = (BOOL)GetTranslatedInt(pcszInf, szSec, ADVINF_PU_ROLLBK, 0);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_DSP, PU_Sec.szDispName, sizeof(PU_Sec.szDispName), &dwTmp);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_VER, PU_Sec.szVersion, sizeof(PU_Sec.szVersion), &dwTmp);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_STUB, PU_Sec.szStub, sizeof(PU_Sec.szStub), &dwTmp);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_LANG, PU_Sec.szLocale, sizeof(PU_Sec.szLocale), &dwTmp);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_CID, PU_Sec.szCompID, sizeof(PU_Sec.szCompID), &dwTmp);
   
            // since we are close to beta1, we may hack here to avoid the external comp changes
            //if (IsThisRollbkUninst(PU_Sec.szGUID))
            //    PU_Sec.bRollback = TRUE;

            hRet = SetPerUserSecValues(&PU_Sec);
        }
        else
        {
            AdvWriteToLog("Failure: No GUID specified\r\n");
            //hRet = E_FAIL;  //unknown GUID, advpack will do nothing for this comp!
        }
        AdvWriteToLog("ProcessPerUserSec: End hr=0x%1!x!\r\n", hRet);
    }
    
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
// SetPerUserSecValues help functions
//
//-----------------------------------------------------------------------------------------
    
BOOL CopyRegValue( HKEY hFromkey, HKEY hTokey, LPCSTR pszFromVal, LPCSTR pszToVal)
{
    DWORD dwSize,dwType;
    char  szBuf[BUF_1K];
    BOOL  bRet = FALSE;

    //backup the older reg values    
    //AdvWriteToLog("CopyRegValue:");
    dwSize = sizeof(szBuf);
    if (RegQueryValueEx(hFromkey, pszFromVal, NULL, &dwType, (LPBYTE)szBuf, &dwSize)==ERROR_SUCCESS)
    {
        if (RegSetValueEx(hTokey, pszToVal, 0, dwType, szBuf, lstrlen(szBuf)+1)==ERROR_SUCCESS)
        {
            //AdvWriteToLog("From %1 to %2: %3", pszFromVal, pszToVal, szBuf);
            bRet = TRUE;
        }
    }
    //AdvWriteToLog("\r\n");
    return bRet;
}

void SetSecRegValues( HKEY hSubKey, PPERUSERSECTION pPU, BOOL bUseStubWrapper )
{
    char szBuf[BUF_1K];

    if (pPU->szStub[0]) 
    {
        if (ctx.wOSVer >= _OSVER_WINNT40)
        {
            AddEnvInPath( pPU->szStub, szBuf );
            if (bUseStubWrapper)
                RegSetValueEx( hSubKey, REGVAL_REALSTUBPATH, 0, REG_EXPAND_SZ, szBuf, lstrlen(szBuf)+1 );
            else
                RegSetValueEx( hSubKey, ADVINF_PU_STUB, 0, REG_EXPAND_SZ, szBuf, lstrlen(szBuf)+1 );
        }
        else 
        {
            if (bUseStubWrapper)
                RegSetValueEx( hSubKey, REGVAL_REALSTUBPATH, 0, REG_SZ, pPU->szStub, lstrlen(pPU->szStub)+1 );
            else
                RegSetValueEx( hSubKey, ADVINF_PU_STUB, 0, REG_SZ, pPU->szStub, lstrlen(pPU->szStub)+1 );
        }
    }

    if (pPU->szVersion[0])
    {
        RegSetValueEx( hSubKey, ADVINF_PU_VER, 0, REG_SZ, pPU->szVersion, lstrlen(pPU->szVersion)+1 );
        // if we update the base version value, delete the previous QFE version
        RegDeleteValue( hSubKey, "QFEVersion" );
    }

    if (pPU->szLocale[0])        
        RegSetValueEx( hSubKey, ADVINF_PU_LANG, 0, REG_SZ, pPU->szLocale, lstrlen(pPU->szLocale)+1 );

    if (pPU->szCompID[0])
        RegSetValueEx( hSubKey, ADVINF_PU_CID, 0, REG_SZ, pPU->szCompID, lstrlen(pPU->szCompID)+1 );

    if (pPU->szDispName[0])
        RegSetValueEx( hSubKey, "", 0, REG_SZ, pPU->szDispName, lstrlen(pPU->szDispName)+1 );

    RegSetValueEx( hSubKey, ADVINF_PU_ISINST, 0, REG_DWORD, (LPBYTE)&(pPU->dwIsInstalled), sizeof(DWORD) );

}

//-----------------------------------------------------------------------------------------
//
// SetPerUserSecValues
//
//-----------------------------------------------------------------------------------------

HRESULT WINAPI SetPerUserSecValues( PPERUSERSECTION pPU )
{
    HKEY hkey = NULL;
    HKEY hSubKey = NULL;
    HKEY hCUKey;
    HRESULT hRet = S_OK;
    DWORD dwTmp, dwSize;
    char szBuf[BUF_1K];
    BOOL bStubWrapper = FALSE;

    AdvWriteToLog("SetPerUserSecValues:\r\n");

    if ( (pPU == NULL) || (pPU->szGUID[0]==0) )
    {        
        AdvWriteToLog("SetPerUserSecValues: End Warning: No Data\r\n");
        return hRet;
    }

    AdvWriteToLog("Input params: %1,%2,%3,%4,%5,%6\r\n",
                  pPU->szGUID, pPU->szDispName, pPU->szLocale, pPU->szStub, pPU->szVersion,
                  pPU->dwIsInstalled ? "1" : "0");
    
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, c_szActiveSetupKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                         NULL, &hkey, &dwTmp ) != ERROR_SUCCESS )
    {
        hRet = E_FAIL;
        AdvWriteToLog("Failure: Cannot open %1 key\r\n", c_szActiveSetupKey);
        goto done;
    }

    if ( RegCreateKeyEx( hkey, pPU->szGUID, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE,
                         NULL, &hSubKey, &dwTmp ) != ERROR_SUCCESS )
    {
        hRet = E_FAIL;
        AdvWriteToLog("Failure: Cannot create %1 key\r\n", pPU->szGUID);
        goto done;
    }          

    if (pPU->dwIsInstalled == 1)
    {
        // This is the install case. Need to do the following tasks:
        //
        // 1) If the given GUID key exists, has IsInstalled set to 1. Then check
        //    if the existing major version is smaller than the one to be installed. If so,
        //    backup the existing Version, Locale, StubPath values to OldVersion, OldLocale,
        //    OldStubPath first. Set the StubPath to advpack Install Stub Wrapper function.
        //    Set the Version, Locale, InstallStubPath based on the current INF PerUserInstall section values.
        // 2) If there is no exist GUID key or the existing GUID key has IsInstalled set to 0,
        //    just set the current values and set IsInstalled to 1. ( as it is today)
        // 3) Delete {GUID}.Restore key if exists.
        //
        dwSize = sizeof(DWORD);
        if ((pPU->bRollback) &&   
            (RegQueryValueEx(hSubKey, ADVINF_PU_ISINST, NULL, NULL, (LPBYTE)&dwTmp, &dwSize)==ERROR_SUCCESS) &&
            (dwTmp == 1) )
        {
            WORD wRegVer[4], wInfVer[4];

            // case (1)
            dwSize = sizeof(szBuf);
            if (RegQueryValueEx(hSubKey, ADVINF_PU_VER, NULL, NULL, (LPBYTE)szBuf, &dwSize)==ERROR_SUCCESS)
            {
                ConvertVersionString(szBuf, wRegVer, ',');
                if (pPU->szVersion[0])
                {
                    ConvertVersionString(pPU->szVersion, wInfVer, ',');
                    // we only rollback to previous major version now so we only compare major ver.
                    if ( wRegVer[0] < wInfVer[0] )
                    {
                        CopyRegValue(hSubKey, hSubKey, "", REGVAL_OLDDISPN);
                        CopyRegValue(hSubKey, hSubKey, ADVINF_PU_VER, REGVAL_OLDVER);
                        CopyRegValue(hSubKey, hSubKey, ADVINF_PU_LANG, REGVAL_OLDLANG);                        
                        if (CopyRegValue(hSubKey, hSubKey, ADVINF_PU_STUB, REGVAL_OLDSTUB))
                        {
                            CopyRegValue(hSubKey, hSubKey, REGVAL_REALSTUBPATH, REGVAL_OLDREALSTUBPATH);

                            wsprintf(szBuf, ADV_INSTSTUBWRAPPER, pPU->szGUID);                        
                            RegSetValueEx( hSubKey, ADVINF_PU_STUB, 0, REG_SZ, szBuf, lstrlen(szBuf)+1 );
                            bStubWrapper = TRUE;
                        }
                    }
                    else  
                    {
                        // the case user have already backup the previous state, we only update
                        // the real stub path since its StubPath will point to Wrapper function
                        dwSize = sizeof(szBuf);
                        if (RegQueryValueEx(hSubKey, REGVAL_REALSTUBPATH, NULL, NULL, (LPBYTE)szBuf, &dwSize)==ERROR_SUCCESS)
                            bStubWrapper = TRUE;
                    }
                }
            }
        }

        // case (2)
        SetSecRegValues(hSubKey, pPU, bStubWrapper);

        // case (3)
        lstrcpy(szBuf, pPU->szGUID);
        lstrcat(szBuf, ".Restore");
        RegDeleteKey(hkey, szBuf);           
    }
    else if (pPU->dwIsInstalled == 0)
    {
        // This is the uninstall case, need to do the following tasks
        //
        // 1) If the {GUID} key OldVersion, OldStubpath, OldLocale exist, set them back to Version, Locale StubPath value and set IsInstall to 1 to reflect the current install state;
        // 2) Then, Create the '{GUID}.Restore' key with the values of the version ( adjusted max( GUIDs Version, GUIDs MaxRestoreVersion)+1 ), locale, stubpath calling 
        //    advpack.dll UserStubWraper with the {GUID}.Restore as param and the RestoreStubPath with the INF StubPath value.  Set IsInstalled to 1.
        // 3) If none of the above is applied, just set the current GUID key IsInstall to 0 like it is now.
        //
        if (CopyRegValue(hSubKey, hSubKey, REGVAL_OLDVER, ADVINF_PU_VER))
        {
            HKEY hResKey;

            // case (1)
            // restore the old version data
            CopyRegValue(hSubKey, hSubKey, REGVAL_OLDDISPN, "");
            CopyRegValue(hSubKey, hSubKey, REGVAL_OLDLANG, ADVINF_PU_LANG);
            if(CopyRegValue(hSubKey, hSubKey, REGVAL_OLDSTUB, ADVINF_PU_STUB))
            {
                CopyRegValue(hSubKey, hSubKey, REGVAL_OLDREALSTUBPATH, REGVAL_REALSTUBPATH);            

                // case (2)
                lstrcpy(szBuf, pPU->szGUID);
                lstrcat(szBuf, ".Restore" );
                if (RegCreateKeyEx(hkey, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE,
                                   NULL, &hResKey, &dwTmp ) == ERROR_SUCCESS )
                {
                    wsprintf(szBuf, ADV_UNINSTSTUBWRAPPER, pPU->szGUID);
                    RegSetValueEx(hResKey, ADVINF_PU_STUB, 0, REG_SZ, szBuf, lstrlen(szBuf)+1);                
                    bStubWrapper = TRUE;

                    // also copy DontAskFlag
                    CopyRegValue(hSubKey, hResKey, c_szRegDontAskValue, c_szRegDontAskValue);                            

                    SetSecRegValues(hResKey, pPU, bStubWrapper);
                    RegCloseKey(hResKey);
                }
            }

            // cleanup the backup data
            RegDeleteValue(hSubKey, REGVAL_OLDDISPN);
            RegDeleteValue(hSubKey, REGVAL_OLDLANG);
            RegDeleteValue(hSubKey, REGVAL_OLDVER);
            RegDeleteValue(hSubKey, REGVAL_OLDSTUB);
            RegDeleteValue(hSubKey, REGVAL_OLDREALSTUBPATH);
        }
        else
        {
            // case (3)
            SetSecRegValues(hSubKey, pPU, bStubWrapper);
        }
    }

done:
    if ( hSubKey )
        RegCloseKey( hSubKey );

    if ( hkey )
        RegCloseKey( hkey );

    AdvWriteToLog("SetPerUserSecValues: End hr=0x%1!x!\r\n", hRet);

    return hRet;
}

//-----------------------------------------------------------------------------------------
//
//  PerUser Install stub wrapper
//
//-----------------------------------------------------------------------------------------

HRESULT WINAPI UserInstStubWrapper(HWND hwnd, HINSTANCE hInst, LPSTR pszParams, INT nShow)
{
    HKEY hkList, hkcuGUIDRes, hkGUID;
    char szBuf[MAX_PATH];
    DWORD cbData,dwType;
    HRESULT hRet = S_OK;

    /* Component is an uninstall stub. */
    if ((pszParams == NULL) || (*pszParams == 0))
    {
        hRet = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        return hRet;
    }

    AdvWriteToLog("UserInstStubWrapper:\r\n");
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szActiveSetupKey, 0,
                       KEY_READ, &hkList) == ERROR_SUCCESS) 
    {
        if ( RegOpenKeyEx(hkList, pszParams, 0, KEY_READ, &hkGUID) == ERROR_SUCCESS) 
        {
            // run the real stub first
            cbData = sizeof(szBuf);
            if ((RegQueryValueEx(hkGUID, REGVAL_REALSTUBPATH, NULL, &dwType, 
                                (LPBYTE)szBuf, &cbData) == ERROR_SUCCESS) && szBuf[0])
            {
                char szBuf2[MAX_PATH*2];

                if (dwType == REG_EXPAND_SZ)                
                    ExpandEnvironmentStrings(szBuf, szBuf2, sizeof(szBuf2));                
                else
                    lstrcpy(szBuf2,szBuf);

                if ( LaunchAndWait( szBuf2, NULL, NULL, INFINITE, RUNCMDS_QUIET ) == E_FAIL )
                {
                    char szMessage[BIG_STRING];

                    hRet = HRESULT_FROM_WIN32(GetLastError());
                    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                                   szMessage, sizeof(szMessage), NULL );
                    ErrorMsg2Param( ctx.hWnd, IDS_ERR_CREATE_PROCESS, szBuf2, szMessage );
                    RegCloseKey(hkGUID);
                    RegCloseKey(hkList);
                    return hRet;
                }
            }    

            // create {GUID}.Restore to enable the uninstall later
            lstrcpy(szBuf, c_szActiveSetupKey);
            AddPath(szBuf, pszParams);
            lstrcat(szBuf,".Restore");
            if (RegCreateKeyEx( HKEY_CURRENT_USER, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                KEY_READ|KEY_WRITE, NULL, &hkcuGUIDRes, &cbData) == ERROR_SUCCESS) 
            {
                CopyRegValue(hkGUID, hkcuGUIDRes, ADVINF_PU_VER, ADVINF_PU_VER);
                CopyRegValue(hkGUID, hkcuGUIDRes, ADVINF_PU_LANG, ADVINF_PU_LANG);
                
                RegCloseKey(hkcuGUIDRes);                  
            }
            RegCloseKey(hkGUID);            
        }          
        RegCloseKey(hkList);
    }
    AdvWriteToLog("UserInstStubWrapper: End hr=0x%1!x!\r\n", hRet);
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
// PerUser uninstall stub wrapper
//
//-----------------------------------------------------------------------------------------

HRESULT WINAPI UserUnInstStubWrapper(HWND hwnd, HINSTANCE hInst, LPSTR pszParams, INT nShow)
{
    HKEY hkList, hkGUIDRes, hkGUID, hkcuGUID;
    char szBuf[MAX_PATH];
    DWORD cbData, dwType;
    HRESULT hRet = S_OK;

    
    /* Component is an uninstall stub. */
    if ((pszParams == NULL) || (*pszParams == 0))
    {
        hRet = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        return hRet;
    }
    AdvWriteToLog("UserUnInstStubWrapper:\r\n");
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szActiveSetupKey, 0,
                       KEY_READ|KEY_WRITE, &hkList) == ERROR_SUCCESS) 
    {
        // restore the Installed IE version from HKLM
        if ( RegOpenKeyEx( hkList, pszParams, 0, KEY_READ, &hkGUID) == ERROR_SUCCESS) 
        {
            lstrcpy(szBuf, c_szActiveSetupKey);
            AddPath(szBuf, pszParams);
            if ( RegOpenKeyEx( HKEY_CURRENT_USER, szBuf, 0,
                               KEY_READ|KEY_WRITE, &hkcuGUID) == ERROR_SUCCESS) 
            {
                CopyRegValue(hkGUID, hkcuGUID, ADVINF_PU_VER, ADVINF_PU_VER);
                CopyRegValue(hkGUID, hkcuGUID, ADVINF_PU_LANG, ADVINF_PU_LANG);
                RegCloseKey(hkcuGUID);
            }
            RegCloseKey(hkGUID);
        }
          
        // run the stub if needed
        lstrcpy(szBuf, pszParams);
        lstrcat(szBuf,".Restore");

        if (RegOpenKeyEx( hkList, szBuf, 0, KEY_READ, &hkGUIDRes) == ERROR_SUCCESS) 
        {
            cbData = sizeof(szBuf);
            if ((RegQueryValueEx(hkGUIDRes, REGVAL_REALSTUBPATH, NULL, &dwType, 
                                (LPBYTE)szBuf, &cbData) == ERROR_SUCCESS) && szBuf[0])
            {
                char szBuf2[MAX_PATH*2];

                if (dwType == REG_EXPAND_SZ)                
                    ExpandEnvironmentStrings(szBuf, szBuf2, sizeof(szBuf2));                
                else
                    lstrcpy(szBuf2,szBuf);

                if ( LaunchAndWait( szBuf2, NULL, NULL, INFINITE, RUNCMDS_QUIET ) == E_FAIL )
                {
                    char szMessage[BIG_STRING];

                    hRet = HRESULT_FROM_WIN32(GetLastError());
                    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                                   szMessage, sizeof(szMessage), NULL );
                    ErrorMsg2Param( ctx.hWnd, IDS_ERR_CREATE_PROCESS, szBuf2, szMessage );
                }
            }    
            RegCloseKey(hkGUIDRes);
        }    
        RegCloseKey(hkList);
    }
    AdvWriteToLog("UserUnInstStubWrapper: End hr=0x%1!x!\r\n", hRet);
    return hRet;
}

                                                                          
//***************************************************************************
//*                                                                         *
//* NAME:       TranslateInfStringEx                                        *
//*                                                                         *
//* SYNOPSIS:   Translates a string in an Advanced inf file -- replaces     *
//*             LDIDs with the directory. This new API requires called to   *
//*             init the INF first for efficiency.                          *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI TranslateInfStringEx( HINF hInf, PCSTR pszInfFilename, 
                                     PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                                     PSTR pszBuffer, DWORD dwBufferSize,
                                     PDWORD pdwRequiredSize, PVOID pvReserved )
{
    HRESULT hReturnCode = S_OK;

    // Validate parameters
    if ( (hInf != ctx.hInf) || pszInfFilename == NULL  || pszTranslateSection == NULL
         || pszTranslateKey == NULL || pdwRequiredSize == NULL )
    {
        hReturnCode = E_INVALIDARG;
        goto done;
    }

    hReturnCode = GetTranslatedString( pszInfFilename, pszTranslateSection, pszTranslateKey,
                                       pszBuffer, dwBufferSize, pdwRequiredSize );

  done:
    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       OpenINFEngine                                               *
//*                                                                         *
//* SYNOPSIS:   Initialize the INF Engine and open INF file for use.        *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    HINF hInf the opened INF file handle                        *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI OpenINFEngine( PCSTR pszInfFilename, PCSTR pszInstallSection,                                                                      
                              DWORD dwFlags, HINF *phInf, PVOID pvReserved )
{
    HRESULT hReturnCode = S_OK;
    CHAR   szRealInstallSection[256];
    BOOL   fSaveContext = FALSE;

    // Validate parameters
    if ( (pszInfFilename == NULL) || !phInf)         
    {
        hReturnCode = E_INVALIDARG;
        goto done;
    }

    *phInf = NULL;

    if (!SaveGlobalContext())
    {
        hReturnCode = E_OUTOFMEMORY;
        goto done;
    }
    fSaveContext = TRUE;

    ctx.wQuietMode = QUIETMODE_ALL;

   
    hReturnCode = CommonInstallInit( pszInfFilename, pszInstallSection,
                                     szRealInstallSection, sizeof(szRealInstallSection), NULL, FALSE, 0 );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

    if ( ctx.dwSetupEngine != ENGINE_SETUPAPI ) 
    {
        hReturnCode = E_UNEXPECTED;
        goto done;
    }

    hReturnCode = SetLDIDs( (LPSTR)pszInfFilename, szRealInstallSection, 0, NULL );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

    *phInf = ctx.hInf;

done:
    if ( FAILED(hReturnCode) )
    {
        CommonInstallCleanup();
        if ( fSaveContext )
        {
            RestoreGlobalContext();
        }
    }

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CloseINFEngine                                              *
//*                                                                         *
//* SYNOPSIS:   Close the INF Engine and the current INF file.              *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    HINF hInf the opened INF file handle                        *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI CloseINFEngine( HINF hInf )
{
    if ( hInf == ctx.hInf )
    {
        CommonInstallCleanup();
        RestoreGlobalContext();
    }
    else
        return E_INVALIDARG;
            
    return S_OK;
}

#define BACKUPBASE "%s.%03d"

BOOL GetUniBackupName( HKEY hKey, LPSTR pszBackupBase, DWORD dwInSize, LPCSTR pszBackupPath, LPCSTR pszModule )
{
    char szBuf[MAX_PATH];
    DWORD dwSize;
    BOOL  bFound = FALSE;


    // 1st check to see if the backup filename already in registry, if so, we use it.
    dwSize = sizeof( szBuf );
    if ( RegQueryValueEx(hKey, REGVAL_BKFILE, NULL, NULL, szBuf, &dwSize) == ERROR_SUCCESS )
    {
        LPSTR pszTmp;

        pszTmp = ANSIStrRChr( szBuf, '\\' );
        if ( pszTmp )
        {
            lstrcpy( pszBackupBase, CharNext(pszTmp) );
            pszTmp = ANSIStrRChr( pszBackupBase, '.' );
            if ( pszTmp && (lstrcmpi(pszTmp, ".dat")==0) )
            {
               *pszTmp = 0;
            }               
            bFound = TRUE;
        }
    }

    if ( !bFound )
    {
        int i;
        char szFilePath[MAX_PATH];

        // 2nd, check to see if the default Module name has been used as the basename
        lstrcpy( szFilePath, pszBackupPath );
        AddPath( szFilePath, pszModule );
        lstrcat( szFilePath, ".dat" );
        if ( !FileExists(szFilePath) )
        {
           bFound = TRUE;
           lstrcpy( pszBackupBase, pszModule );
        }
        else
        {
           for ( i = 1; i<999; i++ )
           {
               wsprintf( szBuf, BACKUPBASE, pszModule, i );
               lstrcpy( szFilePath, pszBackupPath);
               AddPath( szFilePath, szBuf );
               lstrcat( szFilePath, ".dat" );
               if ( !FileExists(szFilePath) )
               {
                   bFound = TRUE;
                   lstrcpy( pszBackupBase, szBuf );
                   break;
               }
           }
        }
    }

    return bFound;
}


BOOL GetUniHiveKeyName( HKEY hKey, LPSTR pszRegHiveKey, DWORD dwInSize, LPCSTR pszBackupPath )
{
    char szBuf[MAX_PATH];
    DWORD dwSize;
    BOOL  bFound = FALSE;

    // For each component, we always try to get the HIVE key from the reg backup filename
    // 4 possibilities exist:
    // Case 1: Reg uinstall file exists but IE4RegBackup doesn't exist
    //          - user is upgrading over IE4, load the file as a hive

    // Case 2: Reg uinstall file doesn't exist and IE4RegBackup doesn't exist
    //          - clean install, create a hive under HKEY_LOCAL_MACHINE

    // Case 3: Reg uninstall file doesn't exist but IE4RegBackup exists
    //          - user is upgrading over an older IE4 build which saved
    //            the reg backup info into the registry itself, call RegSaveKey
    //            to export the backup key to a file, then delete the backup key
    //             and load the file as a hive

    // Case 4: Reg uninstall file exists and IE4RegBackup exists
    //          - THIS CASE SHOULDN'T HAPPEN AT ALL!  If somehow happens,
    //            we will default to Case 1.

    // For case 1 & 4:  we should get the hive key name out of the existing reg value data
    // For case 2 & 3:  we should generate the unique hive key name with "AINF%d" format
    dwSize = sizeof( szBuf );
    if ( RegQueryValueEx(hKey, c_szRegUninstPath, NULL, NULL, szBuf, &dwSize) == ERROR_SUCCESS )
    {
        LPSTR pszTmp;

        pszTmp = ANSIStrRChr( szBuf, '\\' );
        if ( pszTmp )
        {
            lstrcpy( pszRegHiveKey, CharNext(pszTmp) );
            bFound = TRUE;
        }
    }

    if ( !bFound )
    {
        int i;
        HKEY hKey;
        char szRegFilePath[MAX_PATH];

        for ( i = 0; i<9999; i++ )
        {
            wsprintf( szBuf, c_szHiveKey_FMT, i );
            if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, szBuf, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {
                RegCloseKey( hKey );
            }
            else 
            {
                lstrcpy( szRegFilePath, pszBackupPath);
                AddPath( szRegFilePath, szBuf );
                if ( GetFileAttributes( szRegFilePath ) == (DWORD)-1 )
                {
                  bFound = TRUE;
                  lstrcpy( pszRegHiveKey, szBuf );
                  break;
                }
            }
        }
    }

    return bFound;
}


void SetPathForRegHiveUse( LPSTR pszPath, DWORD * adwAttr, int iLevels, BOOL bSave )
{
    int i;
    char  szBuf[MAX_PATH];

    lstrcpy( szBuf, pszPath );
    // create the folder if it does not exist without hiden
    if ( bSave )
        CreateFullPath( szBuf, FALSE );
    for ( i =0; i<iLevels ; i++ )
    {
        if ( bSave )
        {
            adwAttr[i] = GetFileAttributes( szBuf );
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
        }
        else
        {
            SetFileAttributes( szBuf, adwAttr[i] );
        }
        if ( !GetParentDir( szBuf ) )
            break;
    }
}

BOOL NeedBackupData(LPCSTR pszInf, LPCSTR pszSec)
{
    char szBuf[MAX_PATH];
    BOOL bRet = TRUE;   

    if ( (ctx.wOSVer >= _OSVER_WINNT50) &&
         GetEnvironmentVariable( "Upgrade", szBuf, sizeof(szBuf) ) )
    {
         if ( GetModuleFileName( NULL, szBuf, sizeof(szBuf) ) )
         {
             LPSTR pszFile;

             // if setup.exe is last filenane
             pszFile = ANSIStrRChr( szBuf,'\\' );
             if ( pszFile++ && (lstrcmpi(pszFile,"setup.exe")==0) )
                 bRet = FALSE;
         }
    }
    
    if (bRet)
    {
        // check if INF specify not backup on this platform
        if (SUCCEEDED(GetTranslatedString(pszInf, pszSec, ADVINF_NOBACKPLATF, szBuf, sizeof(szBuf), NULL)) && szBuf[0])
        {
            char szInfPlatform[10];
            int i = 0;
                
            while (GetFieldString(szBuf, i++, szInfPlatform, sizeof(szInfPlatform)))
            {
                if (!lstrcmpi(c_pszPlatform[ctx.wOSVer], szInfPlatform))
                {
                    bRet = FALSE;
                    break;
                }                
            }
        }
    }
        
    return bRet;
}

void DeleteOldBackupData( HKEY hKey )
{
    CHAR szBuf[MAX_PATH];
    DWORD   dwSize;

    // delete the backup files
    dwSize = sizeof(szBuf);
    if ( RegQueryValueEx( hKey, REGVAL_BKFILE, NULL, NULL, szBuf, &dwSize ) == ERROR_SUCCESS )
    {
        LPSTR pszExt;

        SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( szBuf );

        pszExt = ANSIStrRChr( szBuf, '.' );
        if ( pszExt )
        {
            lstrcpy( pszExt, ".INI" );
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
        }

        // delete the catalogs
        dwSize = sizeof(szBuf);
        if (RegQueryValueEx(hKey, REGVAL_BKDIR, NULL, NULL, szBuf, &dwSize) == ERROR_SUCCESS)
        {
            HKEY hkCatalogKey;

            if (RegOpenKeyEx(hKey, REGSUBK_CATALOGS, 0, KEY_READ, &hkCatalogKey) == ERROR_SUCCESS)
            {
                CHAR szCatalogName[MAX_PATH];
                DWORD dwIndex;

                dwIndex = 0;
                dwSize = sizeof(szCatalogName);
                while (RegEnumValue(hkCatalogKey, dwIndex, szCatalogName, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                {
                    CHAR szFullCatalogName[MAX_PATH];

                    lstrcpy(szFullCatalogName, szBuf);
                    AddPath(szFullCatalogName, szCatalogName);

                    SetFileAttributes(szFullCatalogName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(szFullCatalogName);

                    dwIndex++;
                    dwSize = sizeof(szCatalogName);
                }

                RegCloseKey(hkCatalogKey);
            }
        }
    }

    // delete reg data backup file if there
    dwSize = sizeof(szBuf);
    if ( RegQueryValueEx( hKey, c_szRegUninstPath, NULL, NULL, szBuf, &dwSize ) == ERROR_SUCCESS )
    {
        SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( szBuf );
    }

    return;
}   

BOOL RemoveBackupBaseOnVer( LPCSTR pszInf, LPCSTR pszSection )
{ 
    BOOL fRet = TRUE;
    char szBuf[MAX_PATH], szModule[MAX_PATH];
    HKEY hKey, hRootKey;
    DWORD dwSize;
    WORD  wInfVer, wRegVer;

    if (FAILED(GetTranslatedString( pszInf, pszSection, ADVINF_MODNAME, szModule, sizeof(szModule), NULL)))
    {
        // no ops if there is no ComponentName
        goto done;
    }

    // Check if the Component MajorVer matches up the backup data version stamp, if not, delete the old backup data.
    //
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGKEY_SAVERESTORE, 0, KEY_WRITE|KEY_READ, &hRootKey) == ERROR_SUCCESS)
    {
        if ( RegOpenKeyEx( hRootKey, szModule, 0, KEY_WRITE|KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szBuf);
            if ( RegQueryValueEx( hKey, REGVAL_BKMODVER, NULL, NULL, szBuf, &dwSize ) == ERROR_SUCCESS )
            {
                WORD wVer[4];
        
                ConvertVersionString( szBuf, wVer, '.' );
                wRegVer = wVer[0];  // taking Major version only
            }
            else
                wRegVer = 0;       // indication no version stamp

            if (SUCCEEDED(GetTranslatedString(pszInf, pszSection, ADVINF_MODVER, szBuf, sizeof(szBuf), NULL)))
            {
                WORD wVer[4];
        
                ConvertVersionString( szBuf, wVer, '.' );
                wInfVer = wVer[0];  // taking Major version only
            }
            else
                wInfVer = 0;       // indication no version stamp

            if ( wInfVer > wRegVer )
            {
                // delete HKLM branch
                DeleteOldBackupData( hKey );
                RegCloseKey( hKey );                
                RegDeleteKeyRecursively( hRootKey, szModule );
                
                // delete HKCU branch
                if ( RegOpenKeyEx( HKEY_CURRENT_USER, REGKEY_SAVERESTORE, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS)
                {
                    RegDeleteKeyRecursively( hKey, szModule );
                    RegCloseKey( hKey );
                }
                hKey = NULL;
            }
            if ( hKey )
            {
                RegCloseKey( hKey );             
            }
        }
        RegCloseKey( hRootKey );       
    }

done:
    return fRet;
}


VOID AdvStartLogging()
{
    CHAR szBuf[MAX_PATH], szLogFileName[MAX_PATH];
    HKEY hKey;

    // Need to 0 the buffer, becauce if the registry branch below does not exist
    // Advpack would use what ever (garbage) was in the buffer to create a log file
    *szLogFileName = '\0';
    // check if logging is enabled
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SAVERESTORE, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwDataLen = sizeof(szLogFileName);

        if (RegQueryValueEx(hKey, "AdvpackLogFile", NULL, NULL, szLogFileName, &dwDataLen) != ERROR_SUCCESS)
            *szLogFileName = '\0';

        RegCloseKey(hKey);
    }

    if (*szLogFileName)
    {
        if (szLogFileName[1] != ':')           // crude way of determining if fully qualified path is specified or not
        {
            GetWindowsDirectory(szBuf, sizeof(szBuf));          // default to windows dir
            AddPath(szBuf, szLogFileName);
        }
        else
            lstrcpy(szBuf, szLogFileName);

        if ((g_hAdvLogFile == INVALID_HANDLE_VALUE) && 
            (g_hAdvLogFile = CreateFile(szBuf, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
            SetFilePointer(g_hAdvLogFile, 0, NULL, FILE_END);      // append logging info to the file
    }
}


VOID AdvWriteToLog(PCSTR pcszFormatString, ...)
{
    va_list vaArgs;
    LPSTR pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (g_hAdvLogFile != INVALID_HANDLE_VALUE)
    {
        va_start(vaArgs, pcszFormatString);

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pcszFormatString, 0, 0, (LPSTR) &pszFullErrMsg, 0, &vaArgs);

        if (pszFullErrMsg != NULL)
        {
            WriteFile(g_hAdvLogFile, pszFullErrMsg, lstrlen(pszFullErrMsg), &dwBytesWritten, NULL);
            LocalFree(pszFullErrMsg);
        }
    }
}


VOID AdvStopLogging()
{
    if (g_hAdvLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hAdvLogFile);
        g_hAdvLogFile = INVALID_HANDLE_VALUE;
    }
}

VOID AdvLogDateAndTime()
{
    if (g_hAdvLogFile != INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME SystemTime;

        GetLocalTime(&SystemTime);

        AdvWriteToLog("Date: %1!02d!/%2!02d!/%3!04d! (mm/dd/yyyy)\tTime: %4!02d!:%5!02d!:%6!02d! (hh:mm:ss)\r\n",
                                        SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
                                        SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\mrcicode.h ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.H
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#ifndef FAR
#ifdef BIT16
#define     FAR     _far
#else
#define     FAR
#endif
#endif

#ifdef __cplusplus
extern "C"
{
#endif

extern unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\ntapi.c ===
//***************************************************************************
//*   Copyright (c) Microsoft Corporation 1995-1996. All rights reserved.   *
//***************************************************************************
//*                                                                         *
//* NTAPI.C -                                                               *
//*                                                                         *
//***************************************************************************

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "ntapi.h"
#include <winnt.h>
#include "advpack.h"
#include "advpub.h"
#include "globals.h"
#include "resource.h"

UINT WINAPI AIFSetupQueueCallback(PVOID Context, UINT Notification, UINT_PTR Param1, UINT_PTR Param2);
UINT WINAPI AIFQuietSetupQueueCallback(PVOID Context, UINT Notification, UINT_PTR Param1, UINT_PTR Param2);
UINT WINAPI MyFileQueueCallback2( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );
void MakeRootDir(LPSTR pszPath);

//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************
PFSetupDefaultQueueCallback       pfSetupDefaultQueueCallback       = NULL;
PFSetupInstallFromInfSection      pfSetupInstallFromInfSection      = NULL;
PFSetupOpenInfFile                pfSetupOpenInfFile                = NULL;
PFSetupOpenAppendInfFile          pfSetupOpenAppendInfFile          = NULL;
PFSetupCloseInfFile               pfSetupCloseInfFile               = NULL;
PFSetupInitDefaultQueueCallbackEx pfSetupInitDefaultQueueCallbackEx = NULL;
PFSetupTermDefaultQueueCallback   pfSetupTermDefaultQueueCallback   = NULL;
PFSetupSetDirectoryId             pfSetupSetDirectoryId             = NULL;
PFSetupGetLineText                pfSetupGetLineText                = NULL;
PFSetupGetLineByIndex             pfSetupGetLineByIndex             = NULL;
PFSetupFindFirstLine              pfSetupFindFirstLine              = NULL;
PFSetupFindNextLine               pfSetupFindNextLine               = NULL;
PFSetupOpenFileQueue              pfSetupOpenFileQueue              = NULL;
PFSetupCloseFileQueue             pfSetupCloseFileQueue             = NULL;
PFSetupQueueCopy                  pfSetupQueueCopy                  = NULL;
PFSetupCommitFileQueue            pfSetupCommitFileQueue            = NULL;
PFSetupGetStringField             pfSetupGetStringField             = NULL;

//***************************************************************************
//*                                                                         *
//* NAME:                                                                   *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL LoadSetupAPIFuncs( VOID )
{
    pfSetupGetStringField             = (PFSetupGetStringField)             GetProcAddress( ctx.hSetupLibrary, c_szSetupGetStringField );
    pfSetupDefaultQueueCallback       = (PFSetupDefaultQueueCallback)       GetProcAddress( ctx.hSetupLibrary, c_szSetupDefaultQueueCallback );
    pfSetupInstallFromInfSection      = (PFSetupInstallFromInfSection)      GetProcAddress( ctx.hSetupLibrary, c_szSetupInstallFromInfSection );
    pfSetupOpenInfFile                = (PFSetupOpenInfFile)                GetProcAddress( ctx.hSetupLibrary, c_szSetupOpenInfFile );
    pfSetupOpenAppendInfFile          = (PFSetupOpenAppendInfFile)          GetProcAddress( ctx.hSetupLibrary, c_szSetupOpenAppendInfFile );
    pfSetupCloseInfFile               = (PFSetupCloseInfFile)               GetProcAddress( ctx.hSetupLibrary, c_szSetupCloseInfFile );
    pfSetupInitDefaultQueueCallbackEx = (PFSetupInitDefaultQueueCallbackEx) GetProcAddress( ctx.hSetupLibrary, c_szSetupInitDefaultQueueCallbackEx );
    pfSetupTermDefaultQueueCallback   = (PFSetupTermDefaultQueueCallback)   GetProcAddress( ctx.hSetupLibrary, c_szSetupTermDefaultQueueCallback );
    pfSetupSetDirectoryId             = (PFSetupSetDirectoryId)             GetProcAddress( ctx.hSetupLibrary, c_szSetupSetDirectoryId );
    pfSetupGetLineText                = (PFSetupGetLineText)                GetProcAddress( ctx.hSetupLibrary, c_szSetupGetLineText );
    pfSetupGetLineByIndex             = (PFSetupGetLineByIndex)             GetProcAddress( ctx.hSetupLibrary, c_szSetupGetLineByIndex );
    pfSetupFindFirstLine              = (PFSetupFindFirstLine)              GetProcAddress( ctx.hSetupLibrary, c_szSetupFindFirstLine );
    pfSetupFindNextLine               = (PFSetupFindNextLine)               GetProcAddress( ctx.hSetupLibrary, c_szSetupFindNextLine );
    pfSetupOpenFileQueue              = (PFSetupOpenFileQueue)              GetProcAddress( ctx.hSetupLibrary, c_szSetupOpenFileQueue );
    pfSetupCloseFileQueue             = (PFSetupCloseFileQueue)             GetProcAddress( ctx.hSetupLibrary, c_szSetupCloseFileQueue );
    pfSetupQueueCopy                  = (PFSetupQueueCopy)                  GetProcAddress( ctx.hSetupLibrary, c_szSetupQueueCopy );
    pfSetupCommitFileQueue            = (PFSetupCommitFileQueue)            GetProcAddress( ctx.hSetupLibrary, c_szSetupCommitFileQueue );

    if (pfSetupDefaultQueueCallback       == NULL
     || pfSetupInstallFromInfSection      == NULL
     || pfSetupOpenInfFile                == NULL
     || pfSetupCloseInfFile               == NULL
     || pfSetupInitDefaultQueueCallbackEx == NULL
     || pfSetupTermDefaultQueueCallback   == NULL
     || pfSetupSetDirectoryId             == NULL
     || pfSetupGetLineText                == NULL
     || pfSetupGetLineByIndex             == NULL
     || pfSetupFindFirstLine              == NULL
     || pfSetupFindNextLine               == NULL
     || pfSetupOpenFileQueue              == NULL
     || pfSetupCloseFileQueue             == NULL
     || pfSetupQueueCopy                  == NULL
     || pfSetupCommitFileQueue            == NULL
     || pfSetupGetStringField             == NULL )
    {
        return FALSE;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       InstallOnNT                                                 *
//*                                                                         *
//* SYNOPSIS:   This function will make all the calls to WinNT SUR's        *
//*             SETUPAPI.DLL to do the installation on NT SUR.              *
//*                                                                         *
//* REQUIRES:   pszSection:     Section to install                          *
//*             pszSourceDir:   Directory to CABs or expanded files         *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT InstallOnNT( PSTR pszSection, PSTR pszSourceDir )
{
    PVOID    pContext    = NULL;
    HRESULT  hReturnCode = S_OK;
    HSPFILEQ hFileQueue = NULL;
    UINT     uFlags;


    // Install Files

    // Setup Context data structure initialized for us for default UI provided by Setup API.
    pContext = pfSetupInitDefaultQueueCallbackEx( NULL, (ctx.wQuietMode) ?
                          INVALID_HANDLE_VALUE : NULL,
                          0, 0, NULL );

    if ( pContext == NULL ) {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

    if ( ! pfSetupInstallFromInfSection( NULL, ctx.hInf, pszSection, SPINST_FILES, NULL,
                     pszSourceDir, SP_COPY_NEWER,
                     MyFileQueueCallback2,
                     pContext, NULL, NULL ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        pfSetupTermDefaultQueueCallback( pContext );
        goto done;
    }

    // Free Context Data structure
    pfSetupTermDefaultQueueCallback( pContext );

    
    uFlags = SPINST_REGISTRY | SPINST_INIFILES;
    if ( ctx.wOSVer >= _OSVER_WINNT50 )
        uFlags = uFlags | SPINST_PROFILEITEMS;

    // Install registry entries
    if ( ! pfSetupInstallFromInfSection( NULL, ctx.hInf, pszSection,
                     uFlags,
                     HKEY_LOCAL_MACHINE, NULL, 0, NULL,
                     NULL, NULL, NULL ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

  done:

    return hReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupOpenInfFile                                          *
//*                                                                         *
//* SYNOPSIS:   This function will map to a function in setupapi.dll which  *
//*             will open the INF file.                                     *
//*                                                                         *
//* REQUIRES:   pszInfFilename:                                             *
//*                                                                         *
//* RETURNS:    DWORD:          Return value - OK means successfull.        *
//*                                                                         *
//***************************************************************************
HRESULT MySetupOpenInfFile( PCSTR pszInfFilename )
{
    UINT line;

    if ( ctx.hInf == NULL ) 
    {
        ctx.hInf = pfSetupOpenInfFile( pszInfFilename, NULL, INF_STYLE_WIN4, NULL );

        if ( ctx.hInf == NULL || ctx.hInf == INVALID_HANDLE_VALUE ) 
        {
            ctx.hInf = NULL;
            return HRESULT_FROM_SETUPAPI(GetLastError());
        }

        // process LayoutFile line of [version] section if any
        pfSetupOpenAppendInfFile( NULL, ctx.hInf, &line );
    }

    return S_OK;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupCloseInfFile                                         *
//*                                                                         *
//* SYNOPSIS:   This function will map to an API function in setupapi.dll.  *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    VOID                                                        *
//*                                                                         *
//***************************************************************************
VOID MySetupCloseInfFile( VOID )
{
    if ( ctx.hInf ) 
    {
        pfSetupCloseInfFile( ctx.hInf );
        ctx.hInf = NULL;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupSetDirectoryId                                       *
//*                                                                         *
//* SYNOPSIS:   This function will map to a function in setupapi.dll to     *
//*             set the directory ID's that are used in our INF.            *
//*                                                                         *
//* REQUIRES:   dwDirID:        Numerical value used to define the DirID    *
//*             pszPath:        DirID will point to this path.              *
//*                                                                         *
//* RETURNS:    DWORD:          Error value (OK if successfull)             *
//*                                                                         *
//***************************************************************************
HRESULT MySetupSetDirectoryId( DWORD dwDirID, PSTR pszPath )
{
    if ( ! pfSetupSetDirectoryId( ctx.hInf, dwDirID, pszPath ) ) {
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    return S_OK;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupGetLineText                                          *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT MySetupGetLineText( PCSTR pszSection, PCSTR pszKey, PSTR pszReturnBuffer,
                DWORD dwReturnBufferSize, PDWORD pdwRequiredSize )
{
    if ( ! pfSetupGetLineText( NULL, ctx.hInf, pszSection, pszKey,
                   pszReturnBuffer, dwReturnBufferSize,
                   pdwRequiredSize ) )
    {
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    return S_OK;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupGetLineByIndex                                       *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT MySetupGetLineByIndex( PCSTR c_pszSection, DWORD dwIndex,
                   PSTR pszBuffer, DWORD dwBufferSize,
                   PDWORD pdwRequiredSize )
{
    HRESULT hReturnCode = S_OK;
    INFCONTEXT InfContext;
    DWORD i = 0;

    if ( ! pfSetupFindFirstLine( ctx.hInf, c_pszSection, NULL, &InfContext ) ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto done;
    }

    for ( i = 0; i < dwIndex; i += 1 ) {
        if ( !pfSetupFindNextLine( &InfContext, &InfContext ) ) {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }
    }

#if 0
    if ( ! pfSetupGetLineByIndex( ctx.hInf, c_pszSection, dwIndex, &InfContext ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }
#endif

    if ( ! pfSetupGetLineText( &InfContext, NULL, NULL, NULL,
                   pszBuffer, dwBufferSize, pdwRequiredSize ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

  done:

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MySetupGetStringField                                       *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT MySetupGetStringField( PCSTR c_pszSection, DWORD dwLineIndex, DWORD dwFieldIndex,
                               PSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize )
{
    HRESULT hReturnCode = S_OK;
    INFCONTEXT InfContext;
    DWORD i = 0;

    if ( !pfSetupFindFirstLine( ctx.hInf, c_pszSection, NULL, &InfContext ) ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto done;
    }

    for ( i = 0; i < dwLineIndex; i += 1 ) 
    {
        if ( !pfSetupFindNextLine( &InfContext, &InfContext ) ) 
        {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }
    }

    if ( !pfSetupGetStringField( &InfContext, dwFieldIndex, 
                                 pszBuffer, dwBufferSize, pdwRequiredSize ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

  done:

    return hReturnCode;
}


HRESULT WINAPI AdvInstallFile(HWND hwnd, LPCSTR lpszSourceDir, LPCSTR lpszSourceFile,
               LPCSTR lpszDestDir, LPCSTR lpszDestFile, DWORD dwFlags, DWORD dwReserved)
{
    HRESULT     hr = E_FAIL;
    HSPFILEQ    FileQueue;
    char    szSrcDrv[MAX_PATH];
    LPCSTR  lpSrcPath;
    LPVOID  lpContext;
    DWORD   dwCopyFlags;
    DWORD   dwRebootCheck;

    if ( (lpszSourceDir == NULL) || (*lpszSourceDir == '\0') ||
         (lpszSourceFile == NULL) || (*lpszSourceFile == '\0') ||
         (lstrlen(lpszSourceDir) < 3) ||
         (lpszDestDir == NULL) )
        return E_INVALIDARG;

    if (!SaveGlobalContext())
        return hr;

    ctx.hWnd = hwnd;

    if ( !CheckOSVersion() )
    {
        RestoreGlobalContext();
        return HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
    }
    dwRebootCheck = InternalNeedRebootInit( ctx.wOSVer );

    // LoadLibrary for setupapi.dll
    ctx.hSetupLibrary = MyLoadLibrary( SETUPAPIDLL );
    if ( ctx.hSetupLibrary == NULL )
    {
        ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, SETUPAPIDLL );
        hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
        goto Cleanup;
    }
    if ( ! LoadSetupAPIFuncs() )
    {
        ErrorMsg( NULL, IDS_ERR_GET_PROC_ADDR );
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        goto Cleanup;
    }

    // SetupOpenFileQueue
    FileQueue = pfSetupOpenFileQueue();
    if (FileQueue == INVALID_HANDLE_VALUE)
    {
        ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, c_szSetupOpenFileQueue );
        hr = HRESULT_FROM_SETUPAPI(GetLastError());
        goto Cleanup;
    }

    lstrcpy(szSrcDrv, lpszSourceDir);
    MakeRootDir(szSrcDrv);
    lpSrcPath = lpszSourceDir + lstrlen(szSrcDrv);  // This will point to the first subdir.

    dwCopyFlags = SP_COPY_SOURCE_ABSOLUTE |
                  SP_COPY_IN_USE_NEEDS_REBOOT|
                  SP_COPY_NEWER |
                  SP_COPY_LANGUAGEAWARE;

    if (dwFlags & AIF_FORCE_FILE_IN_USE)
        dwCopyFlags |= SP_COPY_FORCE_IN_USE;

    if (dwFlags & AIF_NOVERSIONCHECK)
        dwCopyFlags &= ~SP_COPY_NEWER;

    if (dwFlags & AIF_NOLANGUAGECHECK)
        dwCopyFlags &= ~SP_COPY_LANGUAGEAWARE;

    if (dwFlags & AIF_NO_VERSION_DIALOG)
        dwCopyFlags |= SP_COPY_FORCE_NEWER;

    if (dwFlags & AIF_REPLACEONLY)
        dwCopyFlags |= SP_COPY_REPLACEONLY;

    if (dwFlags & AIF_NOOVERWRITE)
        dwCopyFlags |= SP_COPY_NOOVERWRITE;

    if (dwFlags & AIF_NOSKIP)
        dwCopyFlags |= SP_COPY_NOSKIP;

    if (dwFlags & AIF_WARNIFSKIP)
        dwCopyFlags |= SP_COPY_WARNIFSKIP;

    if (pfSetupQueueCopy(FileQueue,
                 szSrcDrv,
                 lpSrcPath,
                 lpszSourceFile,
                 NULL,
                 NULL,
                 lpszDestDir,
                 lpszDestFile,
                 dwCopyFlags))
    {
        lpContext = pfSetupInitDefaultQueueCallbackEx(hwnd, INVALID_HANDLE_VALUE, 0, 0, NULL);
        hr = S_OK;

        //
        // SetupCommitFileQueue
        if (!pfSetupCommitFileQueue( hwnd, FileQueue,
                                (dwFlags & AIF_QUIET)?AIFQuietSetupQueueCallback:AIFSetupQueueCallback,
                                lpContext))
        {
            hr = HRESULT_FROM_SETUPAPI(GetLastError());
        }

        pfSetupTermDefaultQueueCallback(lpContext);
    }
    else
        hr = HRESULT_FROM_SETUPAPI(GetLastError());

    // SetupCloseFileQueue
    pfSetupCloseFileQueue(FileQueue);

    if ( SUCCEEDED(hr) &&
         InternalNeedReboot( dwRebootCheck, ctx.wOSVer ) )
    {
        hr = ERROR_SUCCESS_REBOOT_REQUIRED;
    }

Cleanup:

    RestoreGlobalContext();

    return hr;
}


// This callback will display error messages, but will not show any progress dialog
UINT WINAPI AIFSetupQueueCallback(PVOID  Context,        // context used by the default callback routine
                                UINT     Notification,  // queue notification
                                UINT_PTR Param1,        // additional notification information
                                UINT_PTR Param2 // additional notification information
                                )
{
    switch (Notification)
    {
        case SPFILENOTIFY_STARTQUEUE:
        case SPFILENOTIFY_ENDQUEUE:
        case SPFILENOTIFY_STARTSUBQUEUE:
        case SPFILENOTIFY_ENDSUBQUEUE:

        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_ENDRENAME:
        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_ENDDELETE:
        case SPFILENOTIFY_STARTCOPY:
        case SPFILENOTIFY_ENDCOPY:
            return FILEOP_DOIT;

        default:
            return (pfSetupDefaultQueueCallback(Context, Notification, Param1, Param2));
    }
}

// This callback will not display any dialog
UINT WINAPI AIFQuietSetupQueueCallback(PVOID Context,   // context used by the default callback routine
                                    UINT     Notification,  // queue notification
                                    UINT_PTR Param1,        // additional notification information
                                    UINT_PTR Param2 // additional notification information
                                    )
{
    return FILEOP_DOIT;
}

UINT WINAPI MyFileQueueCallback2( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 )
{
    switch(Notification)
    {
        case SPFILENOTIFY_NEEDMEDIA:
            {
                CHAR szDrv[5];
                PSOURCE_MEDIA psrcMed;

                psrcMed = (PSOURCE_MEDIA)parm1;

                if ( lstrlen( psrcMed->SourcePath  ) > 3 )
                {
                    lstrcpyn( szDrv, psrcMed->SourcePath, 4 );

                    if ( (szDrv[1] == ':') && (GetDriveType( szDrv ) == DRIVE_REMOVABLE) )
                    {
                        CHAR szFile[MAX_PATH];

                        lstrcpy( szFile, psrcMed->SourcePath );

                        if ( psrcMed->Tagfile && *psrcMed->Tagfile )
                            AddPath( szFile, psrcMed->Tagfile );
                        else
                            AddPath( szFile, psrcMed->SourceFile );

                        if ( FileExists( szFile ) )
                        {
                            lstrcpy( (PSTR)parm2, psrcMed->SourcePath );
                            return ( FILEOP_NEWPATH );
                        }
                    }

                }
            }

        default:
            return ( pfSetupDefaultQueueCallback( Context, Notification, parm1, parm2 ) );
    }
}

void MakeRootDir(LPSTR pszPath)
{
    LPSTR pTmp;
    if (pszPath[1] == ':') 
        pszPath[3] = '\0';
    else if ((pszPath[0] == '\\') && (pszPath[1]=='\\'))
    {
        pTmp = &pszPath[2];
        // Find the sever share separation
        while ((*pTmp) && (*pTmp != '\\'))
            pTmp = CharNext(pTmp);
        if (*pTmp)
        {
            pTmp = CharNext(pTmp);
            // Find the end of the share
            while ((*pTmp) && (*pTmp != '\\'))
                pTmp = CharNext(pTmp);
            if (*pTmp == '\\')
            {
                pTmp = CharNext(pTmp);
                *pTmp ='\0';
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\ntapi.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* NTAPI.H                                                                 *
//*                                                                         *
//***************************************************************************

#ifndef _NTAPI_H_
#define _NTAPI_H_

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <windows.h>
#include <winerror.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <wtypes.h>

//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************
typedef UINT  (WINAPI *PFSetupDefaultQueueCallback)( PVOID, UINT, UINT_PTR, UINT_PTR );
typedef BOOL  (WINAPI *PFSetupInstallFromInfSection)( HWND, HINF, PCSTR, UINT, HKEY, PCSTR, UINT, PSP_FILE_CALLBACK_A, PVOID, HDEVINFO, PSP_DEVINFO_DATA );
typedef HINF  (WINAPI *PFSetupOpenInfFile)( PCSTR, PCSTR, DWORD, PUINT );
typedef BOOL  (WINAPI *PFSetupOpenAppendInfFile)( PCSTR, HINF, PUINT );
typedef VOID  (WINAPI *PFSetupCloseInfFile)( HINF );
typedef PVOID (WINAPI *PFSetupInitDefaultQueueCallbackEx)( HWND,HWND,UINT,DWORD,PVOID );
typedef VOID  (WINAPI *PFSetupTermDefaultQueueCallback)( PVOID );
typedef BOOL  (WINAPI *PFSetupSetDirectoryId)( HINF, DWORD, PCSTR );
typedef BOOL  (WINAPI *PFSetupFindFirstLine)( HINF, PCSTR, PCSTR, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupFindNextMatchLine)( PINFCONTEXT, PCSTR, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupGetLineText)( PINFCONTEXT, HINF, PCSTR, PCSTR, PSTR, DWORD, PDWORD );
typedef BOOL  (WINAPI *PFSetupGetLineByIndex)( HINF, PCSTR, DWORD, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupFindFirstLine)( HINF, PCSTR, PCSTR, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupFindNextLine)( PINFCONTEXT, PINFCONTEXT );
typedef HSPFILEQ (WINAPI *PFSetupOpenFileQueue)( VOID );
typedef BOOL  (WINAPI *PFSetupCloseFileQueue)( HSPFILEQ );
typedef BOOL  (WINAPI *PFSetupQueueCopy)( HSPFILEQ, PCSTR, PCSTR, PCSTR, PCSTR, PCSTR, PCSTR, PCSTR, DWORD );
typedef BOOL  (WINAPI *PFSetupCommitFileQueue)( HWND, HSPFILEQ, PSP_FILE_CALLBACK_A, PVOID );
typedef BOOL  (WINAPI *PFSetupGetStringField)(PINFCONTEXT, DWORD, PSTR, DWORD, PDWORD);  

//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************
static const TCHAR c_szSetupDefaultQueueCallback[]       = "SetupDefaultQueueCallbackA";
static const TCHAR c_szSetupInstallFromInfSection[]      = "SetupInstallFromInfSectionA";
static const TCHAR c_szSetupOpenInfFile[]                = "SetupOpenInfFileA";
static const TCHAR c_szSetupOpenAppendInfFile[]          = "SetupOpenAppendInfFileA";
static const TCHAR c_szSetupCloseInfFile[]               = "SetupCloseInfFile";
static const TCHAR c_szSetupInitDefaultQueueCallbackEx[] = "SetupInitDefaultQueueCallbackEx";
static const TCHAR c_szSetupTermDefaultQueueCallback[]   = "SetupTermDefaultQueueCallback";
static const TCHAR c_szSetupSetDirectoryId[]             = "SetupSetDirectoryIdA";
static const TCHAR c_szSetupGetLineText[]                = "SetupGetLineTextA";
static const TCHAR c_szSetupGetLineByIndex[]             = "SetupGetLineByIndexA";
static const TCHAR c_szSetupFindFirstLine[]              = "SetupFindFirstLineA";
static const TCHAR c_szSetupFindNextLine[]               = "SetupFindNextLine";
static const TCHAR c_szSetupOpenFileQueue[]              = "SetupOpenFileQueue";
static const TCHAR c_szSetupCloseFileQueue[]             = "SetupCloseFileQueue";
static const TCHAR c_szSetupQueueCopy[]                  = "SetupQueueCopyA";
static const TCHAR c_szSetupCommitFileQueue[]            = "SetupCommitFileQueueA";
static const TCHAR c_szSetupGetStringField[]             = "SetupGetStringFieldA";


//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL    LoadSetupAPIFuncs( VOID );
HRESULT InstallOnNT( PSTR, PSTR );
HRESULT MySetupOpenInfFile( PCSTR );
VOID    MySetupCloseInfFile( VOID );
HRESULT MySetupSetDirectoryId( DWORD, PSTR );
BOOL    GetNTInfLine( PSTR, PSTR, DWORD );
HRESULT MySetupGetLineText( PCSTR, PCSTR, PSTR, DWORD, PDWORD );
HRESULT MySetupGetLineByIndex( PCSTR, DWORD, PSTR, DWORD, PDWORD );
HRESULT MySetupGetStringField( PCSTR c_pszSection, DWORD dwLineIndex, DWORD dwFieldIndex,
                               PSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize );


#endif // _NTAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\mrcicode.c ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.C
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#include "mrcicode.h"                   /* prototype verification */

#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location (above will work on ALPHA)*/

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

#ifdef BIT16
#define     FARBSS      _far
#else
#define     FARBSS
#endif

static unsigned abits;                  /* Array of bits */
static unsigned cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed;  /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static unsigned FARBSS ahash[CHASH];    /* Hash table */
static unsigned FARBSS alink[MAXDISPBIG];  /* Links */


/* compression internal functions */

#ifdef BIT16
#define  FAST  _near _pascal            /* speed up local calls */
#else
#define  FAST
#endif

static void FAST inithash(void);
static void FAST charbuf(unsigned c);
static void FAST putbits(unsigned bits,unsigned cbits);
static void FAST outlength(unsigned cb);

static void FAST mrci1outsingle(unsigned ch);
static void FAST mrci1outstring(unsigned disp,unsigned cb);

static void FAST mrci2outsingle(unsigned ch);
static void FAST mrci2outstring(unsigned disp,unsigned cb);

/* decompression internal functions */

static unsigned FAST getbit(void);
static unsigned FAST getbits(unsigned cbits);
static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void FAST inithash(void)
{
    unsigned FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void FAST charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void FAST putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void FAST outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}

/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}

/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void FAST mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}

/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void FAST mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}

/*
 *  (MRCI1) MaxCompress
 */

unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return((unsigned int)(pCompressed - pchcmpBase));   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return((unsigned int)(pCompressed - pchcmpBase));   /* Return compressed size */
}

/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static unsigned FAST getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static unsigned FAST getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char FAR *source;
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return((unsigned int)(pchout - pchdecBase));      /* Return decompressed size */
}

/*
 *  (MRCI2) Decompress
 */

unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return((unsigned int)(pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\resource.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* RESOURCE.H -                                                            *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* STRING RESOURCE IDS                                                     *
//***************************************************************************
#define IDS_SELECTDIR               1000
#define IDS_CREATE_DIR              1001
#define IDS_PROMPT                  1002
#define IDS_RESTARTYESNO            1004

#define IDS_ERR_NO_RESOURCE         1100
#define IDS_ERR_OS_VERSION          1101
#define IDS_ERR_NO_MEMORY           1102
#define IDS_ERR_INVALID_DIR         1103
#define IDS_ERR_EMPTY_DIR_FIELD     1104
#define IDS_ERR_UPDATE_DIR          1105
#define IDS_ERR_LOADFUNCS           1106
#define IDS_ERR_LOADDLL             1107
#define IDS_ERR_NO_INF_INSTALLS     1108
#define IDS_ERR_LOAD_DLL            1109
#define IDS_ERR_GET_PROC_ADDR       1110
#define IDS_ERR_OS_UNSUPPORTED      1111
#define IDS_ERR_CREATE_DIR          1112
#define IDS_ERR_SET_LDID            1113
#define IDS_ERR_INF_FAIL            1114
#define IDS_ERR_INF_FAILURE         1115
#define IDS_ERR_INF_SYNTAX          1117
#define IDS_ERR_USER_CANCEL_INST    1121
#define IDS_ERR_SHORT_NAME          1122
#define IDS_ERR_REG_OCX             1123
#define IDS_ERR_RUNONCE_REG_OCX     1124
#define IDS_ERR_INVALID_REGROOT     1125
#define IDS_ERR_GET_WIN_DIR         1126
#define IDS_ERR_NO_SPACE_INST       1130
#define IDS_ERR_GET_DISKSPACE       1132
#define IDS_ERR_UNREG_OCX           1133
#define IDS_ERR_OPENPROCTK          1134
#define IDS_ERR_ADJTKPRIV           1135
#define IDS_ERR_EXITWINEX           1136
#define IDS_ERR_BAD_SYNTAX          1137
#define IDS_ERR_BAD_SYNTAX2         1138
#define IDS_ERR_GET_PATH            1140
#define IDS_ERR_CREATE_PROCESS      1142
#define IDS_ERR_GETVOLINFOR         1143
#define IDS_ERR_TOO_BIG             1144
#define IDS_ERR_CANT_FIND_FILE      1145
#define IDS_ERR_CABPATH             1149

#define IDS_INVALID_ROOTKEY         1151
#define IDS_NO_SEPARATOR_CHAR       1152
#define IDS_ERR_REGSETVALUE         1153
#define IDS_ERR_REGQUERYVALUE       1154

#define IDS_FILEBACKUP_ERROR        1155
#define IDS_BACKUPINIT_ERROR        1156
#define IDS_BACKUPDAT_ERROR         1157
#define IDS_RESTORE_ERROR           1158
#define IDS_RESTORE_ERROR2          1159
#define IDS_FILEBACKUP_TITLE        1160
#define IDS_FILERESTORE_TITLE       1161
#define IDD_SAVERESTOREDLG          1162
#define IDC_SAVERESTORE_PROGRESS    1163
#define IDS_SAVEINFO_TEXT           1164
#define IDS_RESTOREINFO_TEXT        1165
#define IDS_ERR_NONTADMIN           1166
#define IDS_ADVDEFTITLE             1167
#define IDS_ERR_FMTMSG              1168

//***************************************************************************
//* DIALOG IDS                                                              *
//***************************************************************************
#define IDD_DIRDLG      2000


//***************************************************************************
//* DIALOG CONTROL IDS                                                      *
//***************************************************************************
#define IDC_EDIT_DIR    2100
#define IDC_BUT_BROWSE  2101
#define IDC_TEMPTEXT    2102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\sfp.c ===
#include <windows.h>
#include <setupapi.h>
#include "globals.h"
#include "sfp.h"


// globals
SFPINSTALLCATALOG   g_pfSfpInstallCatalog   = NULL;
SFPDELETECATALOG    g_pfSfpDeleteCatalog    = NULL;
SFPDUPLICATECATALOG g_pfSfpDuplicateCatalog = NULL;


// static variables
static HINSTANCE s_hSfcDll = NULL;


BOOL LoadSfcDLL()
{
    BOOL bRet = FALSE;

    if ((s_hSfcDll = LoadLibrary("sfc.dll")) != NULL)
    {
        // ordinal 8 is SfpInstallCatalog, and
        // ordinal 9 is SfpDeleteCatalog
        g_pfSfpInstallCatalog   = (SFPINSTALLCATALOG)   GetProcAddress(s_hSfcDll, MAKEINTRESOURCE(8));
        g_pfSfpDeleteCatalog    = (SFPDELETECATALOG)    GetProcAddress(s_hSfcDll, MAKEINTRESOURCE(9));
        g_pfSfpDuplicateCatalog = (SFPDUPLICATECATALOG) GetProcAddress(s_hSfcDll, "SfpDuplicateCatalog");

        if (g_pfSfpInstallCatalog   != NULL  &&
            g_pfSfpDeleteCatalog    != NULL  &&
            g_pfSfpDuplicateCatalog != NULL)
        {
            bRet = TRUE;
        }
    }
    else
    {
        DWORD dwRet = GetLastError();
        AdvWriteToLog("LoadSfcDLL: LoadLibrary of sfc.dll failed with %1!lu!\r\n", dwRet);
    }

    return bRet;
}


VOID UnloadSfcDLL()
{
    if (s_hSfcDll != NULL)
    {
        FreeLibrary(s_hSfcDll);
        s_hSfcDll = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\reginst.c ===
/*** reginst.c - RegInstall API
 *
 *  This file contains the RegInstall API and its implementation.
 *
 *  Copyright (c) 1996 Microsoft Corporation
 *  Author:     Matt Squires (MattSq)
 *  Created     08/12/96
 */

#include <windows.h>
#include <ole2.h>
#include <advpub.h>
#include <setupapi.h>
#include "globals.h"
#include "advpack.h"
#include "regstr.h"

// FIXFIX - Sundown - let's use public de
// #define IS_RESOURCE(x)  ((((LPTSTR)(x)) <= MAKEINTRESOURCE(-1)) && (((LPTSTR)(x)) != NULL))
#define IS_RESOURCE(x)     ( (((LPTSTR)(x)) != NULL) && IS_INTRESOURCE(x) )

#define  FILESIZE_63K   64449

BOOL GetProgramFilesDir( LPSTR pszPrgfDir, int iSize )
{
    *pszPrgfDir = 0;

    if ( ctx.wOSVer >= _OSVER_WINNT50 )
    {
        if ( GetEnvironmentVariable( TEXT("ProgramFiles"), pszPrgfDir, iSize ) )
            return TRUE;
    }

    if ( GetValueFromRegistry( pszPrgfDir, iSize, "HKLM", REGSTR_PATH_SETUP, REGVAL_PROGRAMFILES ) )
    {
        if ( ctx.wOSVer >= _OSVER_WINNT40 )
        {
            char szSysDrv[5] = { 0 };

            // combine reg value and systemDrive to get the acurate ProgramFiles dir
            if ( GetEnvironmentVariable( TEXT("SystemDrive"), szSysDrv, ARRAYSIZE(szSysDrv) ) &&
                 szSysDrv[0] )
                *pszPrgfDir = szSysDrv[0];
        }

        return TRUE;
    }
     
    return FALSE;
}

/***LP CreateInfFile - Create an INF file from an hmodule
 *
 *  ENTRY
 *      hm - hmodule that contains the REGINST resource
 *      pszInfFileName -> the location to get the INF filename
 *
 *  EXIT
 *      Standard API return
 */
HRESULT CreateInfFile(HMODULE hm, LPTSTR pszInfFileName, DWORD *pdwFileSize)
{
    HRESULT hr = E_FAIL;
    TCHAR szInfFilePath[MAX_PATH] = { 0 };
    LPVOID pvInfData;
    HRSRC hrsrcInfData;
    DWORD cbInfData, cbWritten;
    HANDLE hfileInf = INVALID_HANDLE_VALUE;

    if ( pdwFileSize )
        *pdwFileSize = 0;

    if (GetTempPath(ARRAYSIZE(szInfFilePath), szInfFilePath) > ARRAYSIZE(szInfFilePath))
    {
        goto Cleanup;
    }

    if ( !IsGoodDir( szInfFilePath ) )
    {
        GetWindowsDirectory( szInfFilePath, sizeof(szInfFilePath) );
    }

    if (GetTempFileName(szInfFilePath, TEXT("RGI"), 0, pszInfFileName) == 0)
    {
        goto Cleanup;
    }

    hrsrcInfData = FindResource(hm, TEXT("REGINST"), TEXT("REGINST"));
    if (hrsrcInfData == NULL)
    {
        goto Cleanup;
    }

    cbInfData = SizeofResource(hm, hrsrcInfData);

    pvInfData = LockResource(LoadResource(hm, hrsrcInfData));
    if (pvInfData == NULL)
    {
        goto Cleanup;
    }

    WritePrivateProfileString( NULL, NULL, NULL, pszInfFileName );

    hfileInf = CreateFile(pszInfFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfileInf == INVALID_HANDLE_VALUE)
    {        
        goto Cleanup;
    }

    if ((WriteFile(hfileInf, pvInfData, cbInfData, &cbWritten, NULL) == FALSE) ||
        (cbWritten != cbInfData))
    {
        goto Cleanup;
    }

    if ( pdwFileSize )
        *pdwFileSize = cbWritten;

    hr = S_OK;

Cleanup:
    if (hfileInf != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hfileInf);
    }

    return hr;
}

#if 0

LPTSTR CheckPrefix(LPTSTR lpszStr,  LPCTSTR lpszSub )
{
    int     ilen;
    TCHAR   chTmp;
    LPTSTR  lpTmp = NULL;

    ilen = lstrlen( lpszSub );
    lpTmp = lpszStr;
    while ( ilen && *lpTmp )
    {
        lpTmp = CharNext( lpTmp );
        ilen--;
    }

    chTmp = *lpTmp;
    *lpTmp = '\0';
    if ( lstrcmpi( lpszSub, lpszStr ) )
    {
        *lpTmp = chTmp;
        lpTmp = NULL;
    }
    else
        *lpTmp = chTmp;
    return lpTmp;
}
#endif

BOOL ReplaceSubString( LPSTR pszOutLine, LPSTR pszOldLine, LPCSTR pszSubStr, LPCSTR pszSubReplacement )
{
    LPSTR lpszStart = NULL;
    LPSTR lpszNewLine;
    LPSTR lpszCur;
    BOOL  bFound = FALSE;
    int   ilen;

    lpszCur = pszOldLine;
    lpszNewLine = pszOutLine;
    while ( lpszStart = ANSIStrStrI( lpszCur, pszSubStr ) )
    {
        // this module path has the systemroot            
        ilen = (int)(lpszStart - lpszCur);
        if ( ilen )
        {
            lstrcpyn( lpszNewLine, lpszCur, ilen + 1 );
            lpszNewLine += ilen;
        }
        lstrcpy( lpszNewLine, pszSubReplacement );

        lpszCur = lpszStart + lstrlen(pszSubStr);
        lpszNewLine += lstrlen(pszSubReplacement);
        bFound = TRUE;
    }

    lstrcpy( lpszNewLine, lpszCur );

    return bFound;
}

//==========================================================================================
//
//==========================================================================================

BOOL AddEnvInPath( PSTR pszOldPath, PSTR pszNew )
{
    CHAR szBuf[MAX_PATH];
    CHAR szBuf2[MAX_PATH];
    CHAR szEnvVar[100];
    CHAR szReplaceStr[100];    
    CHAR szSysDrv[5];
    BOOL bFound = FALSE;
    BOOL bRet;
    LPSTR pszFinalStr;

    pszFinalStr = pszOldPath;

    // replace c:\winnt Windows folder
    if ( GetEnvironmentVariable( "SystemRoot", szEnvVar, ARRAYSIZE(szEnvVar) ) )
    {
        if ( ReplaceSubString( szBuf, pszFinalStr, szEnvVar, "%SystemRoot%" ) )
        {
            bFound = TRUE;
            pszFinalStr = szBuf;
        }
    }

    if ( GetProgramFilesDir( szEnvVar, sizeof(szEnvVar) ) &&  
         GetEnvironmentVariable( "SystemDrive", szSysDrv, ARRAYSIZE(szSysDrv) )  )
    {
        // Get the replacement string first, so c:\program files replacement is
        // %SystemDrive%\program files or %ProgramFiles% if >= WINNT50
        // Replace the c:\Program Files folder 
        //
        if ( ctx.wOSVer >= _OSVER_WINNT50 )
        {
            if ( ReplaceSubString( szBuf2, pszFinalStr, szEnvVar, "%ProgramFiles%" ) )
            {
                bFound = TRUE;
                lstrcpy( szBuf, szBuf2 );
                pszFinalStr = szBuf;
            }
        }
        
        // Replace the c: System Drive letter
        if ( ReplaceSubString( szBuf2, pszFinalStr, szSysDrv, "%SystemDrive%" ) )
        {
            lstrcpy( szBuf, szBuf2 );
            pszFinalStr = szBuf;
            bFound = TRUE;
        }
    }

    // this way, if caller pass the same location for both params, still OK.
    if ( bFound ||  ( pszNew != pszOldPath ) )
        lstrcpy( pszNew, pszFinalStr );
    return bFound;    
}

//==========================================================================================
//
//==========================================================================================

BOOL MySmartWrite( LPCSTR pcszSection, LPCSTR pcszKey, LPCSTR pcszValue, LPCSTR pcszFilename, DWORD dwFileSize )
{
    DWORD cbData, cbWritten = 0;
    BOOL  bRet = FALSE;

    if ( dwFileSize <= FILESIZE_63K )
    {
        bRet = WritePrivateProfileString( pcszSection, pcszKey, pcszValue, pcszFilename );
    }
    else
    {
        HANDLE hfileInf = INVALID_HANDLE_VALUE;
        LPSTR  pszBuf = NULL;
        const char c_szLineTmplate[] = "%s=\"%s\"\r\n";
        const char c_szLineTmplate2[] = "%s=%s\r\n";

        pszBuf = LocalAlloc( LPTR, 1024 );
        if ( !pszBuf )
            return bRet;

        hfileInf = CreateFile( pcszFilename, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL, NULL);
        if (hfileInf == INVALID_HANDLE_VALUE)
        {    
            if ( pszBuf )
                LocalFree( pszBuf );
            return bRet;
        }

        if ( SetFilePointer( hfileInf, 0 , NULL, FILE_END ) != 0xFFFFFFFF )
        {   
            if ( *pcszValue != '"' )
                wsprintf( pszBuf, c_szLineTmplate, pcszKey, pcszValue );
            else
                wsprintf( pszBuf, c_szLineTmplate2, pcszKey, pcszValue );
            cbData = lstrlen(pszBuf);   // key="value"\r\n
            WriteFile(hfileInf, pszBuf, cbData, &cbWritten, NULL);
            bRet = (cbData == cbWritten);
        }
        CloseHandle(hfileInf);

        if ( pszBuf )
            LocalFree( pszBuf );
    }
    return bRet;
}
    

/***LP WritePredefinedStrings - Write all predefined strings to an INF
 *
 *  ENTRY
 *      pszInfFileName -> name of INF file
 *      hm - hmodule of caller
 *
 *  EXIT
 *      Standard API return
 */
HRESULT WritePredefinedStrings( LPCTSTR pszInfFileName, HMODULE hm, DWORD dwFileSize )
{
    HRESULT hr = E_FAIL;
    TCHAR szModulePath[MAX_PATH + 2];
    BOOL  bSysModPath = FALSE;

    szModulePath[0] = '"';
    if (GetModuleFileName(hm, &szModulePath[1], ARRAYSIZE(szModulePath) - 2) == 0)
    {
        goto Cleanup;
    }
    lstrcat( szModulePath, "\"" );

    MySmartWrite(TEXT("Strings"), TEXT("_MOD_PATH"), szModulePath, pszInfFileName, dwFileSize);

    if ( CheckOSVersion() )
    {

        // BOOL  bFound = FALSE;

        if ( ctx.wOSVer >= _OSVER_WINNT40 )
        {
            if ( AddEnvInPath( szModulePath, szModulePath) )
            {    
                MySmartWrite(TEXT("Strings"), TEXT("_SYS_MOD_PATH"), szModulePath, pszInfFileName, dwFileSize);
                bSysModPath = TRUE;
            }
        }
    }

    if ( !bSysModPath )
        MySmartWrite(TEXT("Strings"), TEXT("_SYS_MOD_PATH"), szModulePath, pszInfFileName, dwFileSize);

    hr = S_OK;

Cleanup:

    return hr;
}

/***LP WriteCallerStrings - Write caller supplied strings to an INF
 *
 *  ENTRY
 *      pszInfFileName -> name of INF file
 *      hm - hmodule of caller
 *      pstTable - caller supplied string table
 *
 *  EXIT
 *      Standard API return
 */
HRESULT WriteCallerStrings(LPCTSTR pszInfFileName, HMODULE hm, LPCSTRTABLE pstTable, DWORD dwFileSize)
{
    HRESULT hr = E_FAIL;
    TCHAR szValue[MAX_PATH];
    DWORD i;
    LPSTRENTRY pse;
    TCHAR szQuoteValue[MAX_PATH];
    LPTSTR lpValue;     
    
    for (i=0, pse=pstTable->pse; i<pstTable->cEntries; i++, pse++)
    {
        if (IsBadReadPtr(pse, SIZEOF(*pse)))
        {
            goto Cleanup;
        }

        if (IS_RESOURCE(pse->pszValue))
        {
            if (LoadString(hm, (UINT)(ULONG_PTR)(pse->pszValue), szValue, ARRAYSIZE(szValue)) == 0)
            {
                goto Cleanup;
            }
            else
                lpValue = szValue;
        }
        else
            lpValue = pse->pszValue;

        if ( *lpValue != '"' )
        {
            // if no quote, insert it
            szQuoteValue[0] = '"';
            lstrcpy( &szQuoteValue[1], lpValue );
            lstrcat( szQuoteValue, "\"" );
            lpValue = szQuoteValue;
        }

        MySmartWrite(TEXT("Strings"), pse->pszName, lpValue, pszInfFileName, dwFileSize);        
    }

    hr = S_OK;

Cleanup:

    return hr;
}


BOOL GetRollbackSection( LPCSTR pcszModule, LPSTR pszSec, DWORD dwSize )
{
    HKEY hKey;
    TCHAR szBuf[MAX_PATH];
    DWORD dwTmp;
    BOOL  fRet = FALSE;

    lstrcpy( szBuf, REGKEY_SAVERESTORE );
    AddPath( szBuf, pcszModule );
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ,
                         NULL, &hKey, &dwTmp ) == ERROR_SUCCESS )
    {
        dwTmp = dwSize;
        if ( (RegQueryValueEx( hKey, REGVAL_BKINSTSEC, NULL, NULL, pszSec, &dwTmp ) == ERROR_SUCCESS) && *pszSec )
            fRet = TRUE;

        RegCloseKey( hKey );
    }

    return fRet;
}


/***LP ExecuteInfSection - Ask RunSetupCommand to execute an INF section
 *
 *  ENTRY
 *      pszInfFileName -> name of INF file
 *      pszInfSection -> section to execute
 *
 *  EXIT
 *      Standard API return
 */
HRESULT ExecuteInfSection(LPCTSTR pszInfFileName, LPCTSTR pszInfSection)
{
    HRESULT hr = E_FAIL;
    TCHAR szTempPath[MAX_PATH];
    TCHAR szBuf[MAX_PATH];
    BOOL fSavedContext = FALSE;
    DWORD dwFlags = 0;


    if (!SaveGlobalContext())
    {
        goto Cleanup;
    }

    fSavedContext = TRUE;

    // get the source dir
    if (GetTempPath(ARRAYSIZE(szTempPath), szTempPath) > ARRAYSIZE(szTempPath))
    {
        goto Cleanup;
    }

    // we check if this caller needs to do save/rollback, or just simple GenInstall
    if (SUCCEEDED(GetTranslatedString(pszInfFileName, pszInfSection, ADVINF_MODNAME, szBuf, ARRAYSIZE(szBuf), NULL)))
    {
        dwFlags = GetTranslatedInt(pszInfFileName, pszInfSection, ADVINF_FLAGS, 0);
    }

    if ( (dwFlags & ALINF_BKINSTALL) || (dwFlags & ALINF_ROLLBKDOALL) || (dwFlags & ALINF_ROLLBACK) )
    {
        CABINFO   cabInfo;

        ZeroMemory( &cabInfo, sizeof(CABINFO) );
        cabInfo.pszInf = (LPSTR)pszInfFileName;
        lstrcpy( cabInfo.szSrcPath, szTempPath );
        cabInfo.dwFlags = dwFlags;

        if ( dwFlags & ALINF_BKINSTALL  )
        {
            cabInfo.pszSection = (LPSTR)pszInfSection;
        }
        else
        {
            if ( !GetRollbackSection( szBuf, szTempPath, ARRAYSIZE(szTempPath) ) )
            {
                hr = E_UNEXPECTED;
                goto Cleanup;
            }

            cabInfo.pszSection = szTempPath;
        }                        
            
        hr = ExecuteCab( NULL, &cabInfo, NULL );
    }
    else
    {
        hr = RunSetupCommand(INVALID_HANDLE_VALUE, pszInfFileName, pszInfSection,
                            szTempPath, NULL, NULL, RSC_FLAG_INF | RSC_FLAG_QUIET,
                            NULL);
    }

Cleanup:

    if (fSavedContext)
    {
        RestoreGlobalContext();
    }

    return hr;
}

/***EP RegInstall - Install a registry INF
 *
 *  @doc    API REGINSTALL
 *
 *  @api    STDAPI | RegInstall | Install a registry INF
 *
 *  @parm   HMODULE | hm | The hmodule of the caller.  The INF is extracted
 *          from the module's resources (type="REGINST", name="REGINST").
 *
 *  @parm   LPCTSTR | pszSection | The section of the INF to execute.
 *
 *  @parm   LPCSTRTABLE | pstTable | A table of string mappings.
 *
 *  @rdesc  S_OK - registry INF successfully installed.
 *
 *  @rdesc  E_FAIL - error installing INF.
 */
STDAPI RegInstall(HMODULE hm, LPCTSTR pszSection, LPCSTRTABLE pstTable)
{
    HRESULT hr = E_FAIL;
    TCHAR szInfFileName[MAX_PATH];
    DWORD   dwFileSize = 0;

    AdvWriteToLog("RegInstall: Section=%1\r\n", pszSection);
    //
    // Create the INF file.
    //
    szInfFileName[0] = TEXT('\0');
    hr = CreateInfFile(hm, szInfFileName, &dwFileSize);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Write out our predefined strings.
    //
    hr = WritePredefinedStrings(szInfFileName, hm, dwFileSize);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Write out the user supplied strings.
    //
    if (pstTable)
    {
        hr = WriteCallerStrings(szInfFileName, hm, pstTable, dwFileSize);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    WritePrivateProfileString( NULL, NULL, NULL, szInfFileName );

    //
    // Execute the INF engine on the INF.
    //
    hr = ExecuteInfSection(szInfFileName, pszSection);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:

    //
    // Delete the INF file.
    //
    if (szInfFileName[0])
    {
        DeleteFile(szInfFileName);
    }
    AdvWriteToLog("RegInstall: Section=%1 End hr=%2!x!\r\n", pszSection, hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\regsvrst.c ===
#include "ntapi.h"
#include "advpack.h"
#include "globals.h"
#include "crc32.h"
#include "resource.h"


// macro definitions
#define VDH_EXISTENCE_ONLY  0x01
#define VDH_GET_VALUE       0x02
#define VDH_DEL_VALUE       0x04



#define BIG_BUF_SIZE        (1024 + 512)                    // 1.5K


// type definitions
typedef struct tagROOTKEY
{
    PCSTR pcszRootKey;
    HKEY hkRootKey;
} ROOTKEY;


// prototype declarations
VOID EnumerateSubKey();
BOOL RegSaveRestoreHelperWrapper(PCSTR pcszValueName, PCSTR pcszCRCValueName);

BOOL RegSaveHelper(HKEY hkBckupKey, HKEY hkRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PCSTR pcszCRCValueName);
BOOL RegRestoreHelper(HKEY hkBckupKey, HKEY hkRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PCSTR pcszCRCValueName);

BOOL AddDelMapping(HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, DWORD dwFlags);
BOOL MappingExists(HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName);

BOOL SetValueData(HKEY hkBckupKey, PCSTR pcszValueName, CONST BYTE *pcbValueData, DWORD dwValueDataLen);
BOOL ValueDataExists(HKEY hkBckupKey, PCSTR pcszValueName);
BOOL GetValueData(HKEY hkBckupKey, PCSTR pcszValueName, PBYTE *ppbValueData, PDWORD pdwValueDataLen);
BOOL DelValueData(HKEY hkBckupKey, PCSTR pcszValueName);
BOOL ValueDataHelper(HKEY hkBckupKey, PCSTR pcszValueName, PBYTE *ppbValueData, PDWORD pdwValueDataLen, DWORD dwFlags);
VOID Convert2CRC(PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PSTR pszCRCValueName);

BOOL MapRootRegStr2Key(PCSTR pcszRootKey, HKEY *phkRootKey);
CHAR FindSeparator(PCSTR pcszSubKey, PCSTR pcszValueName);
BOOL RegKeyEmpty(HKEY hkRootKey, PCSTR pcszSubKey);

PSTR GetNextToken(PSTR *ppszData, CHAR chDeLim);

BOOL FRunningOnNT();


// global variables
BOOL g_bRet, g_fRestore, g_fAtleastOneRegSaved, g_fRemovBkData;
HKEY g_hkBckupKey, g_hkRootKey;
PCSTR g_pcszRootKey, g_pcszValueName;
PSTR g_pszCRCTempBuf = NULL, g_pszSubKey = NULL, g_pszCRCSubKey = NULL;


// related to logging
VOID StartLogging(PCSTR pcszLogFileSecName);
VOID WriteToLog(PCSTR pcszFormatString, ...);
VOID StopLogging();

HANDLE g_hLogFile = INVALID_HANDLE_VALUE;


HRESULT WINAPI RegSaveRestore(HWND hWnd, PCSTR pszTitleString, HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, DWORD dwFlags)
{
    HWND hSaveWnd = ctx.hWnd;
    WORD wSaveQuietMode = ctx.wQuietMode;
    LPSTR lpszSaveTitle = ctx.lpszTitle;

    g_bRet = g_fAtleastOneRegSaved = FALSE;

    if ( (hWnd == INVALID_HANDLE_VALUE) || (dwFlags & ARSR_NOMESSAGES) )
        ctx.wQuietMode |= QUIETMODE_ALL;
    
    if ( hWnd != INVALID_HANDLE_VALUE )
        ctx.hWnd = hWnd;

    if (pszTitleString != NULL)
        ctx.lpszTitle = (PSTR)pszTitleString;

    g_hkBckupKey = hkBckupKey;
    g_pcszRootKey = pcszRootKey;
    g_pcszValueName = pcszValueName;

    g_fRestore = (dwFlags & IE4_RESTORE);
    g_fRemovBkData = (dwFlags & IE4_REMOVREGBKDATA) && g_fRestore;

    StartLogging(g_fRestore ? REG_RESTORE_LOG_KEY : REG_SAVE_LOG_KEY);

    if (!MapRootRegStr2Key(pcszRootKey, &g_hkRootKey))
    {
        ErrorMsg1Param(ctx.hWnd, IDS_INVALID_ROOTKEY, pcszRootKey);
        goto ErrExit;
    }

    // allocate a 1.5K buffer for g_pszCRCTempBuf
    if ((g_pszCRCTempBuf = (PSTR) LocalAlloc(LPTR, BIG_BUF_SIZE)) == NULL)
    {
        ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
        goto ErrExit;
    }

    if (!g_fRestore  &&  pcszValueName == NULL  &&  !(dwFlags & IE4_NOENUMKEY))
    {
        HKEY hk;

        // check if pcszSubKey exits; if it doesn't and it has not been already backed up,
        // set the IE4_NOENUMKEY flag so that an entry for this subkey is made in the backup branch
        if (RegOpenKeyEx(g_hkRootKey, pcszSubKey, 0, KEY_READ, &hk) != ERROR_SUCCESS)
        {
            if (!MappingExists(hkBckupKey, pcszRootKey, pcszSubKey, pcszValueName))
                dwFlags |= IE4_NOENUMKEY;
        }
        else
            RegCloseKey(hk);
    }

    if (pcszValueName != NULL  ||  (dwFlags & IE4_NOENUMKEY))
    {
        g_pszSubKey = g_pszCRCSubKey = (PSTR) pcszSubKey;
        g_bRet = RegSaveRestoreHelperWrapper(g_pcszValueName, g_pcszValueName);
        if (!(dwFlags & IE4_NO_CRC_MAPPING)  &&  g_bRet)
        {
            // store the RootKey, SubKey, Flags and ValueName in *.map.
            // this info would be used by the caller during the restore phase.
            g_bRet = AddDelMapping(g_hkBckupKey, g_pcszRootKey, g_pszSubKey, g_pcszValueName, dwFlags);
        }
    }
    else                        // save or restore pcszSubKey recursively
    {
        // allocate a 1K buffer for g_pszCRCSubKey
        if ((g_pszCRCSubKey = (PSTR) LocalAlloc(LPTR, 1024)) == NULL)
        {
            ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
            goto ErrExit;
        }

        if (!g_fRestore)
        {
            // if backup info exists for pcszRootKey\pcszSubKey, then we won't re-backup
            // the key recursively again; if we don't do this, then during an upgrade or reinstall
            // over a build, we would backup potentially newer values that got added during the running
            // of the program.
            if (MappingExists(hkBckupKey, pcszRootKey, pcszSubKey, pcszValueName))
            {
                g_bRet = TRUE;

                LocalFree(g_pszCRCSubKey);
                g_pszCRCSubKey = NULL;

                goto ErrExit;
            }

            // allocate a 1K buffer for g_pszSubKey
            if ((g_pszSubKey = (PSTR) LocalAlloc(LPTR, 1024)) == NULL)
            {
                ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
                LocalFree(g_pszCRCSubKey);
                goto ErrExit;
            }
        }
        else
            g_pszSubKey = (PSTR) pcszSubKey;

        g_bRet = TRUE;
        lstrcpy(g_pszCRCSubKey, pcszSubKey);
        if (!g_fRestore)
            lstrcpy(g_pszSubKey, pcszSubKey);

        EnumerateSubKey();
        if (!(dwFlags & IE4_NO_CRC_MAPPING))
        {
            if (g_fRestore)
            {
                if (g_bRet)
                {
                    // if we couldn't restore everything; then we shouldn't delete the mapping info.
                    g_bRet = AddDelMapping(g_hkBckupKey, g_pcszRootKey, g_pszSubKey, g_pcszValueName, dwFlags);
                }
            }
            else
            {
                if (g_fAtleastOneRegSaved)
                {
                    // save the mapping info only if atleast one reg entry was saved
                    g_bRet = AddDelMapping(g_hkBckupKey, g_pcszRootKey, g_pszSubKey, g_pcszValueName, dwFlags);
                }
            }
        }

        LocalFree(g_pszCRCSubKey);
        g_pszCRCSubKey = NULL;
        if (!g_fRestore)
        {
            LocalFree(g_pszSubKey);
            g_pszSubKey = NULL;
        }

    }

ErrExit:
    StopLogging();

    if (g_pszCRCTempBuf != NULL)
    {
        LocalFree(g_pszCRCTempBuf);
        g_pszCRCTempBuf = NULL;
    }

    ctx.hWnd = hSaveWnd;
    ctx.wQuietMode = wSaveQuietMode;
    ctx.lpszTitle = lpszSaveTitle;

    return g_bRet ? S_OK : E_FAIL;
}


HRESULT WINAPI RegRestoreAll(HWND hWnd, PSTR pszTitleString, HKEY hkBckupKey)
{
    HWND hSaveWnd = ctx.hWnd;
    WORD wSaveQuietMode = ctx.wQuietMode;
    LPSTR lpszSaveTitle = ctx.lpszTitle;
    HRESULT hRet;

    if (hWnd != INVALID_HANDLE_VALUE)
        ctx.hWnd = hWnd;
    else
        ctx.wQuietMode |= QUIETMODE_ALL;

    if (pszTitleString != NULL)
        ctx.lpszTitle = pszTitleString;

    hRet = RegRestoreAllEx( hkBckupKey );

    ctx.hWnd = hSaveWnd;
    ctx.wQuietMode = wSaveQuietMode;
    ctx.lpszTitle = lpszSaveTitle;

    return hRet;
}


HRESULT RegRestoreAllEx( HKEY hkBckupKey )
// In one shot restore all the reg entries by enumerating all the values under hkBckupKey\*.map keys
// and calling RegSaveRestore on each one of them.
{
    BOOL bRet = TRUE;
    PSTR pszMappedValueData = NULL;
    CHAR szBuf[32];
    CHAR szSubKey[32];
    DWORD dwKeyIndex;
    HKEY hkSubKey;
    LONG lRetVal;

    if ((pszMappedValueData = (PSTR) LocalAlloc(LPTR, BIG_BUF_SIZE)) == NULL)
    {
        ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
        return E_FAIL;
    }

    // enumerate all the sub-keys under hkBckupKey
    for (dwKeyIndex = 0;  ; dwKeyIndex++)
    {
        PSTR pszPtr;

        lRetVal = RegEnumKey(hkBckupKey, dwKeyIndex, szSubKey, sizeof(szSubKey));
        if (lRetVal != ERROR_SUCCESS)
        {
            if (lRetVal != ERROR_NO_MORE_ITEMS)
                bRet = FALSE;
            break;
        }

        // check if the keyname is of the form *.map
        if ((pszPtr = ANSIStrChr(szSubKey, '.')) != NULL  &&  lstrcmpi(pszPtr, ".map") == 0)
        {
            if (RegOpenKeyEx(hkBckupKey, szSubKey, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
            {
                DWORD dwValIndex, dwValueLen, dwDataLen;

                // enumerate all the values under this key and restore each one of them
                dwValueLen = sizeof(szBuf);
                dwDataLen = BIG_BUF_SIZE;
                for (dwValIndex = 0;  ;  dwValIndex++)
                {
                    CHAR chSeparator;
                    PSTR pszFlags, pszRootKey, pszSubKey, pszValueName, pszPtr;
                    DWORD dwMappedFlags;

                    lRetVal = RegEnumValue(hkSubKey, dwValIndex, szBuf, &dwValueLen, NULL, NULL, pszMappedValueData, &dwDataLen);
                    if (lRetVal != ERROR_SUCCESS)
                    {
                        if (lRetVal != ERROR_NO_MORE_ITEMS)
                            bRet = FALSE;
                        break;
                    }

                    // get the separator char first and then point to RootKey, SubKey and ValueName in pszMappedValueData
                    pszPtr = pszMappedValueData;
                    chSeparator = *pszPtr++;
                    pszFlags = GetNextToken(&pszPtr, chSeparator);
                    pszRootKey = GetNextToken(&pszPtr, chSeparator);
                    pszSubKey = GetNextToken(&pszPtr, chSeparator);
                    pszValueName = GetNextToken(&pszPtr, chSeparator);

                    dwMappedFlags = (pszFlags != NULL) ? (DWORD) My_atoi(pszFlags) : 0;

                    if (SUCCEEDED(RegSaveRestore( ctx.hWnd, ctx.lpszTitle, hkBckupKey, pszRootKey, pszSubKey, pszValueName, dwMappedFlags)))
                        dwValIndex--;                               // RegSaveRestore would delete this value
                    else
                        bRet = FALSE;

                    dwValueLen = sizeof(szBuf);
                    dwDataLen = BIG_BUF_SIZE;
                }

                RegCloseKey(hkSubKey);
            }
            else
                bRet = FALSE;
        }
    }

    LocalFree(pszMappedValueData);

    // delete all the empty subkeys
    for (dwKeyIndex = 0;  ; dwKeyIndex++)
    {
        lRetVal = RegEnumKey(hkBckupKey, dwKeyIndex, szSubKey, sizeof(szSubKey));
        if (lRetVal != ERROR_SUCCESS)
        {
            if (lRetVal != ERROR_NO_MORE_ITEMS)
                bRet = FALSE;
            break;
        }

        if (RegKeyEmpty(hkBckupKey, szSubKey)  &&  RegDeleteKey(hkBckupKey, szSubKey) == ERROR_SUCCESS)
            dwKeyIndex--;
    }

    return bRet ? S_OK : E_FAIL;
}


VOID EnumerateSubKey()
// Recursively enumerate value names and sub-keys and call Save/Restore on each of them
{
    HKEY hkSubKey;
    DWORD dwIndex;
    static DWORD dwLen;
    static PCSTR pcszSubKeyPrefix = "_$Sub#";
    static PCSTR pcszValueNamePrefix = "_$Val#";
    static PCSTR pcszValueNamePrefix0 = "_$Val#0";
    static CHAR szValueName[MAX_PATH], szBckupCRCValueName[MAX_PATH];
    static PSTR pszPtr;

    if (g_fRestore)
    {
        // check if there is an entry in the back-up branch for just the g_pszCRCSubKey itself
        Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, NULL, szBckupCRCValueName);
        if (ValueDataExists(g_hkBckupKey, szBckupCRCValueName))     // restore the no value names sub-key
            g_bRet = RegSaveRestoreHelperWrapper(NULL, NULL)  &&  g_bRet;
        else
        {
            // enumerate values using the aliases
            for (dwIndex = 0;  ;  dwIndex++)
            {
                wsprintf(szValueName, "%s%lu", pcszValueNamePrefix, dwIndex);
                Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, szValueName, szBckupCRCValueName);
                if (ValueDataExists(g_hkBckupKey, szBckupCRCValueName))
                    g_bRet = RegSaveRestoreHelperWrapper(NULL, szValueName)  &&  g_bRet;
                else
                    break;                                          // no more value names
            }
        }

        // enumerate sub-keys using the aliases
        for (dwIndex = 0;  ;  dwIndex++)
        {
            // check if there is any sub-key under g_pszCRCSubKey; if none, this is our terminating condition.
            // NOTE: a sub-key under g_pszCRCSubKey exists if:
            // (1) the sub-key itself exists OR
            // (2) the sub-key contains atleast one value name.

            // check if a sub-key by itself exists
            pszPtr = g_pszCRCSubKey + lstrlen(g_pszCRCSubKey);
            wsprintf(pszPtr, "\\%s%lu", pcszSubKeyPrefix, dwIndex);
            Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, NULL, szBckupCRCValueName);
            if (ValueDataExists(g_hkBckupKey, szBckupCRCValueName))
                EnumerateSubKey();
            else
            {
                // check if the sub-key has the first value name alias - "_$Val#0"
                Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, pcszValueNamePrefix0, szBckupCRCValueName);
                if (ValueDataExists(g_hkBckupKey, szBckupCRCValueName))
                    EnumerateSubKey();
                else
                {
                    GetParentDir(g_pszCRCSubKey);
                    break;                                          // no more sub-keys
                }
            }

            GetParentDir(g_pszCRCSubKey);
        }
    }
    else                                                            // backup the key
    {
        if (RegOpenKeyEx(g_hkRootKey, g_pszSubKey, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
        {
            dwLen = sizeof(szValueName);
            if (RegEnumValue(hkSubKey, 0, szValueName, &dwLen, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            {
                // no value names; just save the key itself
                g_bRet = g_bRet  &&  RegSaveRestoreHelperWrapper(NULL, NULL);
            }
            else
            {
                // enumerate the values
                dwIndex = 0;
                dwLen = sizeof(szValueName);
                while (RegEnumValue(hkSubKey, dwIndex, szValueName, &dwLen, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                {
                    // szBckupCRCValueName is really szCRCValueName
                    wsprintf(szBckupCRCValueName, "%s%lu", pcszValueNamePrefix, dwIndex);
                    g_bRet = g_bRet  &&  RegSaveRestoreHelperWrapper(szValueName, szBckupCRCValueName);

                    dwIndex++;
                    dwLen = sizeof(szValueName);
                }
            }

            // enumerate sub-keys
            dwIndex = 0;
            // append '\\' to g_pszSubKey and make pszPtr point to the char after this last '\\' so that
            // when RegEnumKey puts a sub-key name at pszPtr, g_pszSubKey would have the complete sub-key path.
            dwLen = lstrlen(g_pszSubKey);
            pszPtr = g_pszSubKey + dwLen;
            *pszPtr++ = '\\';
            while (RegEnumKey(hkSubKey, dwIndex, pszPtr, 1024 - dwLen - 1) == ERROR_SUCCESS)
            {
                // prepare the sub-key alias
                pszPtr = g_pszCRCSubKey + lstrlen(g_pszCRCSubKey);
                wsprintf(pszPtr, "\\%s%lu", pcszSubKeyPrefix, dwIndex);

                EnumerateSubKey();

                GetParentDir(g_pszSubKey);
                GetParentDir(g_pszCRCSubKey);

                dwIndex++;

                // append '\\' to g_pszSubKey and make pszPtr point to the char after this last '\\' so that
                // when RegEnumKey puts a sub-key name at pszPtr, g_pszSubKey would have the complete sub-key path.
                dwLen = lstrlen(g_pszSubKey);
                pszPtr = g_pszSubKey + dwLen;
                *pszPtr++ = '\\';
            }

            *--pszPtr = '\0';                       // chop the last '\\'; no DBCS clash because we added it

            RegCloseKey(hkSubKey);
        }
    }
}


BOOL RegSaveRestoreHelperWrapper(PCSTR pcszValueName, PCSTR pcszCRCValueName)
{
    CHAR szBckupCRCValueName[32];

    // a unique back-up value name is obtained by concatenating pcszRootKey, pcszSubKey and pcszValueName
    // and the concatenated value name is stored as a 16-byte CRC value (space optimization)
    Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, pcszCRCValueName, szBckupCRCValueName);

    WriteToLog("\r\nValueName = %1,%2", g_pcszRootKey, g_pszSubKey);
    if (pcszValueName != NULL)
        WriteToLog(",%1", pcszValueName);
    WriteToLog("\r\nCRCValueName = %1\r\n", szBckupCRCValueName);

    return (g_fRestore) ?
                RegRestoreHelper(g_hkBckupKey, g_hkRootKey, g_pszSubKey, pcszValueName, szBckupCRCValueName) :
                RegSaveHelper(g_hkBckupKey, g_hkRootKey, g_pszSubKey, pcszValueName, szBckupCRCValueName);
}


BOOL RegSaveHelper(HKEY hkBckupKey, HKEY hkRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PCSTR pcszCRCValueName)
// If pcszValueName exists in the registry, back-up its value data; otherwise, remember how much of pcszSubKey
// is present in the registry.  This info would help during restoration.
{
    HKEY hkSubKey = NULL;
    PSTR pszBckupData = NULL, pszCOSubKey = NULL, pszPtr;
    DWORD dwValueDataLen, dwValueType, dwBckupDataLen;
    CHAR chSeparator;
    BOOL fSubKeyValid;

    // don't backup the value data of pcszCRCValueName if it has been already backed-up
    if (ValueDataExists(hkBckupKey, pcszCRCValueName))
        return TRUE;

    // make a copy of pcszSubKey
    if ((pszCOSubKey = (PSTR) LocalAlloc(LPTR, lstrlen(pcszSubKey) + 1)) == NULL)
    {
        ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
        goto RegSaveHelperErr;
    }
    lstrcpy(pszCOSubKey, pcszSubKey);

    // loop through each branch in pszCOSubKey to find out how much of it is already present in the registry.
    // start with the whole sub key first and then chop one branch at a time from the end
    fSubKeyValid = TRUE;
    do
    {
        if (RegOpenKeyEx(hkRootKey, pszCOSubKey, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
            break;
    } while (fSubKeyValid = GetParentDir(pszCOSubKey));

    // NOTE: fSubKeyValid == FALSE here means that no branch of pcszSubKey is present

    if (fSubKeyValid  &&  lstrcmpi(pcszSubKey, pszCOSubKey) == 0)
                                        // entire subkey is present in the registry
    {
        if (pcszValueName != NULL)
        {
            if (*pcszValueName  ||  FRunningOnNT())
            {
                // check if pcszValueName is present in the registry
                if (RegQueryValueEx(hkSubKey, pcszValueName, NULL, &dwValueType, NULL, &dwValueDataLen) != ERROR_SUCCESS)
                    pcszValueName = NULL;
            }
            else
            {
                LONG lRetVal;
                CHAR szDummyBuf[1];

                // On Win95, for the default value name, its existence is checked as follows:
                //  - pass in a dummy buffer for the value data but pass in the size of the buffer as 0
                //  - the query would succeed if and only if there is no value data set
                //  - for all other cases, including the case where the value data is just the empty string,
                //      the query would fail and dwValueDataLen would contain the no. of bytes needed to
                //      fit in the value data
                // On NT4.0, if no value data is set, the query returns ERROR_FILE_NOT_FOUND
                //  NOTE: To minimize risk, we don't follow this code path if running on NT4.0

                dwValueDataLen = 0;
                lRetVal = RegQueryValueEx(hkSubKey, pcszValueName, NULL, &dwValueType, (LPBYTE) szDummyBuf, &dwValueDataLen);
                if (lRetVal == ERROR_SUCCESS  ||  lRetVal == ERROR_FILE_NOT_FOUND)
                    pcszValueName = NULL;
            }
        }
    }
    else
        pcszValueName = NULL;

    WriteToLog("BckupSubKey = ");

    // compute the length required for pszBckupData
    // format of pszBckupData is (assume that the separator char is ','):
    //     ,[<szSubKey>,[<szValueName>,\0<dwValueType><dwValueDataLen><ValueData>]]
    dwBckupDataLen = 1 + 1;     // the separator char + '\0'
    if (fSubKeyValid)
    {
        WriteToLog("%1", pszCOSubKey);
        dwBckupDataLen += lstrlen(pszCOSubKey) + 1;

        if (pcszValueName != NULL)
        {
            WriteToLog(", BckupValueName = %1", pcszValueName);
            dwBckupDataLen += lstrlen(pcszValueName) + 1 + 2 * sizeof(DWORD) + dwValueDataLen;
                                // 2 * sizeof(DWORD) == sizeof(dwValueType) + sizeof(dwValueDataLen)
        }
    }

    WriteToLog("\r\n");

    // determine a valid separator char that is not one of the chars in SubKey and ValueName
    if ((chSeparator = FindSeparator(fSubKeyValid ? pszCOSubKey : NULL, pcszValueName)) == '\0')
    {
        ErrorMsg(ctx.hWnd, IDS_NO_SEPARATOR_CHAR);
        goto RegSaveHelperErr;
    }

    // allocate memory for pszBckupData
    if ((pszBckupData = (PSTR) LocalAlloc(LPTR, dwBckupDataLen)) == NULL)
    {
        ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
        goto RegSaveHelperErr;
    }

    // start building pszBckupData
    // format of pszBckupData is (assume that the separator char is ','):
    //     ,[<szSubKey>,[<szValueName>,\0<dwValueType><dwValueDataLen><ValueData>]]
    pszPtr = pszBckupData;
    *pszPtr++ = chSeparator;
    *pszPtr = '\0';
    if (fSubKeyValid)
    {
        lstrcpy(pszPtr, pszCOSubKey);
        pszPtr += lstrlen(pszPtr);
        *pszPtr++ = chSeparator;
        *pszPtr = '\0';

        if (pcszValueName != NULL)
        {
            lstrcpy(pszPtr, pcszValueName);
            pszPtr += lstrlen(pszPtr);
            *pszPtr++ = chSeparator;
            *pszPtr++ = '\0';                       // include the '\0' char

            *((DWORD UNALIGNED *) pszPtr)++ = dwValueType;
            *((DWORD UNALIGNED *) pszPtr)++ = dwValueDataLen;

            // NOTE: pszPtr points to the start position of value data in pszBckupData
            RegQueryValueEx(hkSubKey, pcszValueName, NULL, &dwValueType, (PBYTE) pszPtr, &dwValueDataLen);
        }
    }

    if (!SetValueData(hkBckupKey, pcszCRCValueName, (CONST BYTE *) pszBckupData, dwBckupDataLen))
    {
        ErrorMsg1Param(ctx.hWnd, IDS_ERR_REGSETVALUE, pcszCRCValueName);
        goto RegSaveHelperErr;
    }
    WriteToLog("Value backed-up\r\n");

    g_fAtleastOneRegSaved = TRUE;

    if (hkSubKey != NULL)
        RegCloseKey(hkSubKey);
    LocalFree(pszCOSubKey);
    LocalFree(pszBckupData);

    return TRUE;

RegSaveHelperErr:
    if (hkSubKey != NULL)
        RegCloseKey(hkSubKey);
    if (pszCOSubKey != NULL)
        LocalFree(pszCOSubKey);
    if (pszBckupData != NULL)
        LocalFree(pszBckupData);

    return FALSE;
}


BOOL RegRestoreHelper(HKEY hkBckupKey, HKEY hkRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PCSTR pcszCRCValueName)
// (1) If the value name in the backed-up value data is not NULL, it means that pcszValueName existed during
//     back-up time; so, restore the original value data.
// (2) If the value name in the backed-up value data is NULL and pcszValueName is not NULL, it means that
//     pcszValueName didn't exist during the back-up time; so, delete it.
// (3) If the backed-up sub key is shorter than pcszSubKey, then delete one branch at a time, if it is empty,
//     from the end in pcszSubKey till pcszSubKey becomes identical to the backed-up sub key.
{
    HKEY hkSubKey = NULL;
    PSTR pszBckupData = NULL, pszCOSubKey, pszPtr, pszBckupSubKey, pszBckupValueName;
    DWORD dwValueDataLen, dwValueType, dwBckupDataLen, dwDisposition;
    CHAR chSeparator;

    if (!GetValueData(hkBckupKey, pcszCRCValueName, &pszBckupData, &dwBckupDataLen))
    {
        ErrorMsg1Param(ctx.hWnd, IDS_ERR_REGQUERYVALUE, pcszCRCValueName);
        goto RegRestoreHelperErr;
    }

    // format of pszBckupData is (assume that the separator char is ','):
    //     ,[<szSubKey>,[<szValueName>,\0<dwValueType><dwValueDataLen><ValueData>]]
    pszPtr = pszBckupData;
    chSeparator = *pszPtr++;                // initialize the separator char; since it is not part of
                                            // Leading or Trailing DBCS Character Set, pszPtr++ is fine
    pszBckupSubKey = GetNextToken(&pszPtr, chSeparator);
    pszBckupValueName = GetNextToken(&pszPtr, chSeparator);
    pszPtr++;                               // skip '\0'

    if (g_fRemovBkData)
        WriteToLog("RemoveRegistryBackupData: ");

    WriteToLog("BckupSubKey = ");
    if (pszBckupSubKey != NULL)
    {
        WriteToLog("%1", pszBckupSubKey);
        if (pcszValueName == NULL  &&  lstrlen(pszBckupSubKey) > lstrlen(pcszSubKey))
        {
            // means that pcszSubKey was backed-up thru EnumerateSubKey
            pcszSubKey = pszBckupSubKey;
        }
    }

    // check to see if we want to restore the reg keys, values or remove reg backup data
    if (g_fRemovBkData)
    {
        if (pszBckupValueName != NULL)              // restore the backed-up value data -- case (1)
        {
            WriteToLog(", BckupValueName = %1", pcszValueName);
        }
        DelValueData(hkBckupKey, pcszCRCValueName);     // delete the back-up value name
        WriteToLog(" <Done>\r\n");
        goto Done;
    }

    if (RegCreateKeyEx(hkRootKey, pcszSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSubKey, &dwDisposition) == ERROR_SUCCESS)
    {
        if (pszBckupValueName != NULL)              // restore the backed-up value data -- case (1)
        {
            WriteToLog(", BckupValueName = %1", pcszValueName);
            dwValueType = *((DWORD UNALIGNED *) pszPtr)++;
            dwValueDataLen = *((DWORD UNALIGNED *) pszPtr)++;
            if (RegSetValueEx(hkSubKey, pszBckupValueName, 0, dwValueType, (CONST BYTE *) pszPtr, dwValueDataLen) != ERROR_SUCCESS)
            {
                ErrorMsg1Param(ctx.hWnd, IDS_ERR_REGSETVALUE, pszBckupValueName);
                goto RegRestoreHelperErr;
            }
        }
        else if (pcszValueName != NULL)
        {
            // means that the value name didn't exist while backing-up; so delete it -- case (2)
            RegDeleteValue(hkSubKey, pcszValueName);
        }

        RegCloseKey(hkSubKey);

        DelValueData(hkBckupKey, pcszCRCValueName);     // delete the back-up value name
        WriteToLog("\r\nBackup Value deleted");
    }

    WriteToLog("\r\n");

    dwBckupDataLen = 0;
    if (pszBckupValueName == NULL  &&  (pszBckupSubKey == NULL  ||  (DWORD) lstrlen(pcszSubKey) > (dwBckupDataLen = lstrlen(pszBckupSubKey))))
    {
        // only a part of the subkey was present in the registry during back-up;
        // delete the remaining branches if they are empty -- case (3)

        // make a copy of pcszSubKey
        if ((pszCOSubKey = (PSTR) LocalAlloc(LPTR, lstrlen(pcszSubKey) + 1)) != NULL)
        {
            lstrcpy(pszCOSubKey, pcszSubKey);

            // start processing one branch at a time from the end in pszCOSubKey;
            // if the branch is empty, delete it;
            // stop processing as soon as pszCOSubKey becomes identical to pszBckupSubKey
            do
            {
                // NOTE: Need to delete a key only if it's empty; otherwise, we would delete
                // more than what we backed up.  For example, if component A wanted to backup
                // HKLM,Software\Microsoft\Windows\CurrentVersion\Uninstall\InternetExplorer
                // and the machine didn't have the Uninstall key, we should not blow away the
                // entire Uninstall key when we uninstall A as other components might have added
                // their uninstall strings there.  So delete a key only if it's empty.
                if (RegKeyEmpty(hkRootKey, pszCOSubKey))
                    RegDeleteKey(hkRootKey, pszCOSubKey);
                else
                    break;
            } while (GetParentDir(pszCOSubKey)  &&  (DWORD) lstrlen(pszCOSubKey) > dwBckupDataLen);

            LocalFree(pszCOSubKey);
        }
    }

Done:
    LocalFree(pszBckupData);

    return TRUE;

RegRestoreHelperErr:
    if (hkSubKey != NULL)
        RegCloseKey(hkSubKey);
    if (pszBckupData != NULL)
        LocalFree(pszBckupData);

    return FALSE;
}


BOOL AddDelMapping(HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, DWORD dwFlags)
{
    CHAR szCRCValueName[32], szBuf[32];
    DWORD dwIndex;
    BOOL bFound = FALSE;
    HKEY hkSubKey = NULL;

    Convert2CRC(pcszRootKey, pcszSubKey, pcszValueName, szCRCValueName);

    // enumerate all the sub-keys under hkBckupKey
    for (dwIndex = 0;  !bFound && RegEnumKey(hkBckupKey, dwIndex, szBuf, sizeof(szBuf)) == ERROR_SUCCESS;  dwIndex++)
    {
        PSTR pszPtr;

        // check if the keyname is of the form *.map
        if ((pszPtr = ANSIStrChr(szBuf, '.')) != NULL  &&  lstrcmpi(pszPtr, ".map") == 0)
        {
            if (RegOpenKeyEx(hkBckupKey, szBuf, 0, KEY_READ | KEY_WRITE, &hkSubKey) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hkSubKey, szCRCValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                    bFound = TRUE;
                else
                {
                    RegCloseKey(hkSubKey);
                    hkSubKey = NULL;
                }
            }
        }
    }

    if (g_fRestore)
    {
        if (bFound)
            RegDeleteValue(hkSubKey, szCRCValueName);
    }
    else
    {
        if (!bFound)
        {
            DWORD dwMapKeyIndex = 0;

            // add the quadruplet, i.e., ",Flags,RootKey,SubKey,ValueName" to hkBckupKey\*.map
            wsprintf(szBuf, "%lu.map", dwMapKeyIndex);
            if (RegCreateKeyEx(hkBckupKey, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSubKey, NULL) == ERROR_SUCCESS)
            {
                PSTR pszPtr;
                CHAR chSeparator;

                // IMPORTANT: the global buffer g_pszCRCTempBuf is used in Convert2CRC;
                // so be very careful if you want to call Convert2CRC after g_pszCRCTempBuf has been initialized here.
                pszPtr = g_pszCRCTempBuf;

                // determine a valid separator char that is not one of the chars in SubKey and ValueName
                if ((chSeparator = FindSeparator(pcszSubKey, pcszValueName)) == '\0')
                {
                    ErrorMsg(ctx.hWnd, IDS_NO_SEPARATOR_CHAR);
                }
                else
                {
                    // reset the IE4_BACKNEW bit and set the IE4_RESTORE bit
                    dwFlags &= ~IE4_BACKNEW;
                    dwFlags |= IE4_RESTORE;
                    wsprintf(szBuf, "%lu", dwFlags);

                    // format of mapping data is (say ',' is chSeparator): ,<Flags>,<RootKey>,<SubKey>,[<ValueName>,]
                    {
                        *pszPtr++ = chSeparator;

                        lstrcpy(pszPtr, szBuf);
                        pszPtr += lstrlen(pszPtr);
                        *pszPtr++ = chSeparator;

                        lstrcpy(pszPtr, pcszRootKey);
                        pszPtr += lstrlen(pszPtr);
                        *pszPtr++ = chSeparator;

                        lstrcpy(pszPtr, pcszSubKey);
                        pszPtr += lstrlen(pszPtr);
                        *pszPtr++ = chSeparator;

                        if (pcszValueName != NULL)
                        {
                            lstrcpy(pszPtr, pcszValueName);
                            pszPtr += lstrlen(pszPtr);
                            *pszPtr++ = chSeparator;
                        }

                        *pszPtr = '\0';
                    }

                    if (RegSetValueEx(hkSubKey, szCRCValueName, 0, REG_SZ, (CONST BYTE *) g_pszCRCTempBuf, lstrlen(g_pszCRCTempBuf) + 1) != ERROR_SUCCESS)
                    {
                        do
                        {
                            // hkBckupKey\<dwIndex>.map key may have reached the 64K limit; create another sub-key
                            RegCloseKey(hkSubKey);
                            hkSubKey = NULL;

                            wsprintf(szBuf, "%lu.map", ++dwMapKeyIndex);
                            if (RegCreateKeyEx(hkBckupKey, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSubKey, NULL) == ERROR_SUCCESS)
                            {
                                bFound = RegSetValueEx(hkSubKey, szCRCValueName, 0, REG_SZ, (CONST BYTE *) g_pszCRCTempBuf, lstrlen(g_pszCRCTempBuf) + 1) == ERROR_SUCCESS;
                            }
                        } while (!bFound  &&  dwMapKeyIndex < 64);
                    }
                    else
                        bFound = TRUE;
                }
            }
        }
    }

    if (hkSubKey != NULL)
        RegCloseKey(hkSubKey);

    return bFound;
}


BOOL MappingExists(HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName)
{
    CHAR szCRCValueName[32], szBuf[32];
    DWORD dwIndex;
    BOOL bFound = FALSE;

    Convert2CRC(pcszRootKey, pcszSubKey, pcszValueName, szCRCValueName);

    // enumerate all the sub-keys under hkBckupKey
    for (dwIndex = 0;  !bFound && RegEnumKey(hkBckupKey, dwIndex, szBuf, sizeof(szBuf)) == ERROR_SUCCESS;  dwIndex++)
    {
        PSTR pszPtr;

        // check if the keyname is of the form *.map
        if ((pszPtr = ANSIStrChr(szBuf, '.')) != NULL  &&  lstrcmpi(pszPtr, ".map") == 0)
        {
            HKEY hkSubKey;

            if (RegOpenKeyEx(hkBckupKey, szBuf, 0, KEY_READ | KEY_WRITE, &hkSubKey) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hkSubKey, szCRCValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                    bFound = TRUE;

                RegCloseKey(hkSubKey);
            }
        }
    }

    return bFound;
}


BOOL SetValueData(HKEY hkBckupKey, PCSTR pcszValueName, CONST BYTE *pcbValueData, DWORD dwValueDataLen)
// Set the (pcszValueName, pcbValueData) pair in hkBckupKey
{
    BOOL fDone = FALSE;
    HKEY hkSubKey;
    DWORD dwDisposition, dwSubKey;
    CHAR szSubKey[16];

    // since a key has a size limit of 64K, automatically generate a new sub-key if the other ones are full
    for (dwSubKey = 0;  !fDone && dwSubKey < 64;  dwSubKey++)
    {
        wsprintf(szSubKey, "%lu", dwSubKey);        // sub-keys are named 0, 1, 2, etc.
        if (RegCreateKeyEx(hkBckupKey, szSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSubKey, &dwDisposition) == ERROR_SUCCESS)
        {
            if (RegSetValueEx(hkSubKey, pcszValueName, 0, REG_BINARY, pcbValueData, dwValueDataLen) == ERROR_SUCCESS)
                fDone = TRUE;

            RegCloseKey(hkSubKey);
        }
    }

    return fDone;
}


BOOL ValueDataExists(HKEY hkBckupKey, PCSTR pcszValueName)
// Return TRUE if pcszValueName exists in hkBckupKey; otherwise, return FALSE
{
    return ValueDataHelper(hkBckupKey, pcszValueName, NULL, NULL, VDH_EXISTENCE_ONLY);
}


BOOL GetValueData(HKEY hkBckupKey, PCSTR pcszValueName, PBYTE *ppbValueData, PDWORD pdwValueDataLen)
// Allocate a buffer of required size and return the value data of pcszValueName in hkBckupKey
{
    return ValueDataHelper(hkBckupKey, pcszValueName, ppbValueData, pdwValueDataLen, VDH_GET_VALUE);
}


BOOL DelValueData(HKEY hkBckupKey, PCSTR pcszValueName)
// Delete pcszValueName from hkBckupKey
{
    return ValueDataHelper(hkBckupKey, pcszValueName, NULL, NULL, VDH_DEL_VALUE);
}


BOOL ValueDataHelper(HKEY hkBckupKey, PCSTR pcszValueName, PBYTE *ppbValueData, PDWORD pdwValueDataLen, DWORD dwFlags)
{
    BOOL fDone = FALSE;
    HKEY hkSubKey;
    CHAR szSubKey[16];
    DWORD dwIndex, dwDataLen;

    if (dwFlags == VDH_GET_VALUE  &&  ppbValueData == NULL)
        return FALSE;

    // search for pcszValueName in all the sub-keys
    for (dwIndex = 0;  !fDone && RegEnumKey(hkBckupKey, dwIndex, szSubKey, sizeof(szSubKey)) == ERROR_SUCCESS;  dwIndex++)
    {
        if ( ANSIStrChr(szSubKey, '.') == NULL)           // check only in non *.map keys
        {
            if (RegOpenKeyEx(hkBckupKey, szSubKey, 0, KEY_READ | KEY_WRITE, &hkSubKey) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hkSubKey, pcszValueName, NULL, NULL, NULL, &dwDataLen) == ERROR_SUCCESS)
                {
                    switch (dwFlags)
                    {
                    case VDH_DEL_VALUE:
                        RegDeleteValue(hkSubKey, pcszValueName);
                        break;

                    case VDH_GET_VALUE:
                        if ((*ppbValueData = (PBYTE) LocalAlloc(LPTR, dwDataLen)) == NULL)
                        {
                            RegCloseKey(hkSubKey);
                            ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
                            return FALSE;
                        }

                        *pdwValueDataLen = dwDataLen;
                        RegQueryValueEx(hkSubKey, pcszValueName, NULL, NULL, *ppbValueData, &dwDataLen);

                        break;

                    case VDH_EXISTENCE_ONLY:
                        break;
                    }

                    fDone = TRUE;
                }

                RegCloseKey(hkSubKey);
            }
        }
    }

    return fDone;
}


VOID Convert2CRC(PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PSTR pszCRCValueName)
// Concatenate pcszRootKey, pcszSubKey and pcszValueName and convert the concatenated value name
// to a 16-byte CRC value.
{
    PSTR pszPtr = g_pszCRCTempBuf;
    ULONG ulCRC = CRC32_INITIAL_VALUE;
    DWORD dwLen;

    // concatenate pcszRootKey, pcszSubKey, pcszValueName
    lstrcpy(pszPtr, pcszRootKey);
    lstrcat(pszPtr, pcszSubKey);
    if (pcszValueName != NULL)
        lstrcat(pszPtr, pcszValueName);

    // call CRC32Compute on each half of szBuf and store the 2-DWORD result in ASCII form (16 bytes)
    for (dwLen = lstrlen(pszPtr) / 2;  dwLen;  dwLen = lstrlen(pszPtr))
    {
        ulCRC = CRC32Compute(pszPtr, dwLen, ulCRC);

        wsprintf(pszCRCValueName, "%08x", ulCRC);
        pszCRCValueName += 8;

        pszPtr += dwLen;                // point to the beginning of the other half
    }
}


static ROOTKEY rkRoots[] =
{
    {"HKEY_LOCAL_MACHINE",  HKEY_LOCAL_MACHINE},
    {"HKLM",                HKEY_LOCAL_MACHINE},
    {"HKEY_CLASSES_ROOT",   HKEY_CLASSES_ROOT},
    {"HKCR",                HKEY_CLASSES_ROOT},
    {"",                    HKEY_CLASSES_ROOT},
    {"HKEY_CURRENT_USER",   HKEY_CURRENT_USER},
    {"HKCU",                HKEY_CURRENT_USER},
    {"HKEY_USERS",          HKEY_USERS},
    {"HKU",                 HKEY_USERS}
};

BOOL MapRootRegStr2Key(PCSTR pcszRootKey, HKEY *phkRootKey)
{
    INT iIndex;

    for (iIndex = 0;  iIndex < ARRAYSIZE(rkRoots);  iIndex++)
        if (lstrcmpi(rkRoots[iIndex].pcszRootKey, pcszRootKey) == 0)
        {
            *phkRootKey = rkRoots[iIndex].hkRootKey;
            return TRUE;
        }

    return FALSE;
}


CHAR FindSeparator(PCSTR pcszSubKey, PCSTR pcszValueName)
// Go through pcszSeparatorList and return the first char that doesn't appear in any of the parameters;
//   if such a char is not found, return '\0'
{
    PCSTR pcszSeparatorList = ",$'?%;:";        // since the separator chars are 'pure' ASCII chars, i.e.,
                                                // they are not part of Leading or Trailing DBCS Character Set,
                                                // IsSeparator(), which assumes a 'pure' ASCII ch to look for,
                                                // can be used
    CHAR ch;

    while (ch = *pcszSeparatorList++)
        if (!IsSeparator(ch, pcszSubKey)  &&  !IsSeparator(ch, pcszValueName))
            break;

    return ch;
}


BOOL RegKeyEmpty(HKEY hkRootKey, PCSTR pcszSubKey)
// Return TRUE if pcszSubKey is emtpy, i.e., no sub keys and value names; otherwise, return FALSE
{
    HKEY hkKey;
    BOOL bRet = FALSE;
    CHAR szBuf[1];
    DWORD dwBufLen = sizeof(szBuf);

    if (RegOpenKeyEx(hkRootKey, pcszSubKey, 0, KEY_READ, &hkKey) == ERROR_SUCCESS)
    {
        if (RegEnumKey(hkKey, 0, szBuf, dwBufLen) == ERROR_NO_MORE_ITEMS  &&
            RegEnumValue(hkKey, 0, szBuf, &dwBufLen, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
            bRet = TRUE;

        RegCloseKey(hkKey);
    }

    return bRet;
}


PSTR GetNextToken(PSTR *ppszData, CHAR chDeLim)
// If the next token in *ppszData is delimited by the chDeLim char, replace chDeLim
//   in *ppszData by '\0', set *ppszData to point to the char after '\0' and return
//   ptr to the beginning of the token; otherwise, return NULL
{
    PSTR pszPos;

    if (ppszData == NULL  ||  *ppszData == NULL  ||  **ppszData == '\0')
        return NULL;

    if ((pszPos = ANSIStrChr(*ppszData, chDeLim)) != NULL)
    {
        PSTR pszT = *ppszData;

        *pszPos = '\0';                 // replace chDeLim with '\0'
        *ppszData = pszPos + 1;
        pszPos = pszT;
    }
    else                                // chDeLim not found; set *ppszData to point to
                                        //   to the end of szData; the next invocation
                                        //   of this function would return NULL
    {
        pszPos = *ppszData;
        *ppszData = pszPos + lstrlen(pszPos);
    }

    return pszPos;
}


BOOL FRunningOnNT()
{
    static BOOL fIsNT4 = 2;

    if (fIsNT4 == 2)
    {
        OSVERSIONINFO osviVerInfo;

        osviVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&osviVerInfo);

        fIsNT4 = osviVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT;
    }

    return fIsNT4;
}


VOID StartLogging(PCSTR pcszLogFileSecName)
{
    CHAR szBuf[MAX_PATH], szLogFileName[MAX_PATH];
    HKEY hkSubKey;

    szLogFileName[0] = '\0';

    // check if logging is enabled
    GetProfileString("RegBackup", pcszLogFileSecName, "", szLogFileName, sizeof(szLogFileName));
    if (*szLogFileName == '\0')               // check in the registry
    {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SAVERESTORE, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
        {
            DWORD dwDataLen = sizeof(szLogFileName);

            if (RegQueryValueEx(hkSubKey, pcszLogFileSecName, NULL, NULL, szLogFileName, &dwDataLen) != ERROR_SUCCESS)
                *szLogFileName = '\0';

            RegCloseKey(hkSubKey);
        }
    }

    if (*szLogFileName)
    {
        if (szLogFileName[1] != ':')           // crude way of determining if fully qualified path is specified or not
        {
            GetWindowsDirectory(szBuf, sizeof(szBuf));          // default to windows dir
            AddPath(szBuf, szLogFileName);
        }
        else
            lstrcpy(szBuf, szLogFileName);

        if ((g_hLogFile = CreateFile(szBuf, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
            SetFilePointer(g_hLogFile, 0, NULL, FILE_END);      // append logging info to the file
    }
}


VOID WriteToLog(PCSTR pcszFormatString, ...)
{
    va_list vaArgs;
    PSTR pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        va_start(vaArgs, pcszFormatString);

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pcszFormatString, 0, 0, (PSTR) &pszFullErrMsg, 0, &vaArgs);

        if (pszFullErrMsg != NULL)
        {
            WriteFile(g_hLogFile, pszFullErrMsg, lstrlen(pszFullErrMsg), &dwBytesWritten, NULL);
            LocalFree(pszFullErrMsg);
        }
    }
}


VOID StopLogging()
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\sfp.h ===
// This file contains the prototype declaration of SFP API's on Millennium (in sfc.dll)


// typedef's
typedef DWORD (WINAPI * SFPINSTALLCATALOG)  (LPCTSTR, LPCTSTR);
typedef DWORD (WINAPI * SFPDELETECATALOG)   (LPCTSTR);
typedef DWORD (WINAPI * SFPDUPLICATECATALOG)(LPCTSTR, LPCTSTR);


// extern declarations
// functions
extern BOOL LoadSfcDLL();
extern VOID UnloadSfcDLL();

// variables
extern SFPINSTALLCATALOG   g_pfSfpInstallCatalog;
extern SFPDELETECATALOG    g_pfSfpDeleteCatalog;
extern SFPDUPLICATECATALOG g_pfSfpDuplicateCatalog;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\uninstal.c ===
#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <wchar.h>
#include <stdlib.h>
#include <limits.h>
#include <commdlg.h>
#include "setupapi.h"
#include "resource.h"
#include "advpack.h"
#include "uninstal.h"
#include "globals.h"
#include "mrcicode.h"
#include "crc32.h"
#include <advpub.h>
#include <regstr.h>

#define MAX_STR_LEN     1024
#define SEC_RENAME  "Rename"
#define MAX_IOSIZE      32768
#define DAT_FILESIG     0x504A4743
#define OK           0
#define CR           13

const char c_szREGKEY_SHAREDLL[] = REGSTR_PATH_SETUP "\\SharedDlls";

const char c_szExtINI[] = ".INI";
const char c_szExtDAT[] = ".DAT";
//const char c_szIE4SECTIONNAME[] = "backup";
const char c_szNoFileLine[] = "-1,0,0,0,0,0,-1";

int RestoreSingleFile(FILELIST *filelist, LPSTR lpszBakFile, HANDLE hDatFile);
extern const char c_szNoFileLine[];

void MySetUninstallFileAttrib(LPSTR lpszPath, LPCSTR lpszBasename);
BOOL UninstallInfoInit(PBAKDATA pbd, LPCSTR lpszPath, LPCSTR lpszBasename, BOOL bBackup);
HRESULT BackupFiles( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags);
HRESULT RestoreFiles( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags);
void FillBackupInfo(LPCSTR lpINIFile, FILELIST *pFileList);
void initcopy(const char * StfWinDir, char * from, char * to);
unsigned long Mystrtoul (const char *nptr, char **endptr, int ibase);
INT_PTR CALLBACK SaveRestoreProgressDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM  lParam);
void GetListFromIniFile(LPSTR lpDir, LPSTR lpBaseName, LPSTR *lplpFileList);
void CreateFullPathForFile(LPSTR lpszBakFile);
DWORD GetRefCountFrReg( LPSTR lpFile );
HRESULT UpdateRefCount( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags );

HRESULT WINAPI FileSaveRestore( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags)
{
    char    szTitle[MAX_STR_LEN];
    LPSTR   lpszOldTitle = ctx.lpszTitle;
    HRESULT hr;

    if (!CheckOSVersion())
        return E_FAIL;

    ctx.lpszTitle = szTitle;        // Do we have to do this??

    if ( hDlg && !IsWindow(hDlg))
        dwFlags |= IE4_NOMESSAGES | IE4_NOPROGRESS;

    if (dwFlags & IE4_RESTORE)
    {
        LoadString(g_hInst, IDS_FILERESTORE_TITLE, szTitle, sizeof(szTitle));
        hr = RestoreFiles( hDlg, lpFileList, lpDir, lpBaseName, dwFlags);
    }
    else if ( dwFlags & AFSR_UPDREFCNT )
    {
        hr = UpdateRefCount( hDlg, lpFileList, lpDir, lpBaseName, dwFlags );
    }
    else
    {
        LoadString(g_hInst, IDS_FILEBACKUP_TITLE, szTitle, sizeof(szTitle));
        hr = BackupFiles( hDlg, lpFileList, lpDir, lpBaseName, dwFlags);
    }

    ctx.lpszTitle = lpszOldTitle;
    return hr;
}

HRESULT UpdateRefCount( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags )
{
    char szIniFile[MAX_PATH];
    char szLine[MAX_STR_LEN];
    char szBuf[MAX_PATH];
    DWORD dwRefCount = -1;
    DWORD dwOldAttr;
    LPSTR lpFile;

    if ( !lpFileList || !*lpFileList )
        return S_OK;

    lpFile = lpFileList;
    BuildPath( szIniFile, lpDir, lpBaseName );
    lstrcat( szIniFile, c_szExtINI );

    if ( FileExists( szIniFile ) )
    {
        dwOldAttr = GetFileAttributes( szIniFile );
        SetFileAttributes( szIniFile, FILE_ATTRIBUTE_NORMAL );
        while ( *lpFile )
        {
            if ( GetPrivateProfileString( c_szIE4SECTIONNAME, lpFile, "", szLine, sizeof(szLine), szIniFile) )
            {
                LPSTR lpszComma;
                int i, j;

                if ( GetFieldString(szLine, 6, szBuf, sizeof(szBuf)) )  // For the Attribute
                {
                    dwRefCount = My_atol( szBuf );
                    if ( dwRefCount == (DWORD)-1 )
                    {
                        dwRefCount = GetRefCountFrReg( lpFile );
                    }
                    else if ( dwFlags & AFSR_EXTRAINCREFCNT )
                        dwRefCount++;
                }
                else
                {
                    dwRefCount = GetRefCountFrReg( lpFile );
                }


                // re-write the updated INI line
                lpszComma = szLine;
                for ( i=0; i<6; i++ )
                {
                    lpszComma = ANSIStrChr(lpszComma, ',');
                    if ( !lpszComma  )
                        break;
                    else
                        lpszComma = CharNext(lpszComma);
                }

                if ( !lpszComma )
                {
                    for ( j=i; j<6; j++ )
                    {
                        lstrcat( szLine, "," );
                    }
                }
                else
                    *(++lpszComma) = '0';

                ULtoA( dwRefCount, szBuf, 10 );
                lstrcat( szLine, szBuf );
                
                WritePrivateProfileString( c_szIE4SECTIONNAME, lpFile, szLine, szIniFile );
            }

            lpFile += lstrlen(lpFile) + 1;
            
        }
        SetFileAttributes( szIniFile, dwOldAttr );

    }
    return S_OK;
}

DWORD GetRefCountFrReg( LPSTR lpFile )
{
    HKEY hKey;
    DWORD dwRefCount = 0;
    DWORD dwType;
    DWORD dwSize;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szREGKEY_SHAREDLL, (ULONG)0, KEY_READ, &hKey ) == ERROR_SUCCESS ) 
    {
        dwSize = sizeof(DWORD);
        if ( RegQueryValueEx( hKey, lpFile, NULL, &dwType, (LPBYTE)&dwRefCount, &dwSize ) != ERROR_SUCCESS ) 
        {
            dwRefCount = 0;
        }
        RegCloseKey( hKey );
    }
    return dwRefCount;
}
         
    

HRESULT BackupFiles( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    BAKDATA  bd;
    FILELIST FileList;
    LPSTR    lpFile;
    char szLine[MAX_STR_LEN];
    char szValue[MAX_PATH];
    DWORD    dwItems = 0;
    HWND     hProgressDlg = NULL;

    if ((lpFileList) && (*lpFileList))
    {
        if (SUCCEEDED(CreateFullPath(lpDir, TRUE)) && UninstallInfoInit(&bd, lpDir, lpBaseName, TRUE))
        {
            if (!(dwFlags & IE4_NOPROGRESS))
            {
                hProgressDlg = CreateDialogParam(g_hInst, MAKEINTRESOURCE(IDD_SAVERESTOREDLG), hDlg, SaveRestoreProgressDlgProc, TRUE);
                ShowWindow(hProgressDlg, SW_SHOWNORMAL);

                lpFile = lpFileList;
                while (*lpFile)
                {
                    dwItems++;
                    lpFile += lstrlen(lpFile) + 1;
                }
                UpdateWindow(hProgressDlg);
                SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_SETRANGE, 0, MAKELONG(0, dwItems));
                SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_SETSTEP, 1, 0L);
            }
            lpFile = lpFileList;
            while ((hr == S_OK) && (*lpFile))
            {
                if (GetPrivateProfileString(c_szIE4SECTIONNAME, lpFile, "", szLine, sizeof(szLine), bd.szIniFileName) == 0)
                {
                    FileList.bak_attribute = GetFileAttributes( lpFile );
                    FileList.bak_exists = 0;
                }
                else
                {
                    FileList.bak_exists = 1;
                    FileList.bak_attribute = (DWORD)NO_FILE;
                    if (GetFieldString(szLine, 0, szValue, sizeof(szValue)))  // For the Attribute
                        FileList.bak_attribute = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

                    // If the file was in the list of files to backup the last time, but did not exist on the user machine
                    // but this time around it exists, only backup the file if the user specifies IE4_BACKUPNEW
                    if ((FileList.bak_attribute == (DWORD)NO_FILE) && (dwFlags & IE4_BACKNEW) )
                    {
                        FileList.bak_attribute = GetFileAttributes( lpFile );
                        FileList.bak_exists = 0;
                    }
                    else
                    {
                        // the existing INI fields: Attri[Filed0],size[Filed1],date-time(low)[Filed2], date-time(high)[Field3],offset[Field4],CRC[Field5]
                        // we are going to add the extra colume of reference count if not there already
                        if ( !GetFieldString(szLine, 6, szValue, sizeof(szValue)) )  // For the Ref-count field
                        {
                            lstrcat( szLine, ",-1" );
                            WritePrivateProfileString( c_szIE4SECTIONNAME, lpFile, szLine, bd.szIniFileName );
                        }
                    }
                }

                if (FileList.bak_exists == 0)
                {
                    if (FileList.bak_attribute != (DWORD)NO_FILE)
                    {
                        FileList.name = lpFile;
                        if (!BackupSingleFile(&FileList, &bd))
                        {  // If something went wrong, Sorry backup failed.
                            if (!(dwFlags & IE4_NOMESSAGES))
                            {
                                if (MsgBox1Param( hDlg, IDS_FILEBACKUP_ERROR, lpFile, MB_ICONEXCLAMATION, MB_YESNO) == IDNO)
                                {
                                    hr = E_FAIL;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // File does not exist, nothing to backup, report this in the INI file.
                        WritePrivateProfileString(c_szIE4SECTIONNAME, lpFile, c_szNoFileLine, bd.szIniFileName);
                    }

                }
                // else we did already backup this file the previous install
                if (!(dwFlags & IE4_NOPROGRESS))
                {
                    UpdateWindow(hProgressDlg);
                    SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_STEPIT, 0, 0L);
                }

                lpFile += lstrlen(lpFile) + 1;
            }

            if (bd.hDatFile != INVALID_HANDLE_VALUE)
               CloseHandle(bd.hDatFile);
            WritePrivateProfileString( NULL, NULL, NULL, bd.szIniFileName); // to make sure the ie4bak.ini file gets flushed
        }
        else
        {
            if (!(dwFlags & IE4_NOMESSAGES))
            {
                if (MsgBox( hDlg, IDS_BACKUPINIT_ERROR, MB_ICONEXCLAMATION , MB_YESNO) == IDNO)
                    hr = E_FAIL;
            }
        }
    }

    if (hProgressDlg)
        DestroyWindow(hProgressDlg);

    MySetUninstallFileAttrib(lpDir, lpBaseName);

    return hr;
}

BOOL UninstallInfoInit(PBAKDATA pbd, LPCSTR lpszPath, LPCSTR lpszBasename, BOOL bBackup)
{
    pbd->hDatFile = INVALID_HANDLE_VALUE;
    lstrcpy(pbd->szFinalDir, lpszPath);

    // the dat file and ini file are made on the first call to backup single file.
    if(pbd->hDatFile == INVALID_HANDLE_VALUE )
    {
        char szTmp[MAX_PATH];
       
        BuildPath(szTmp, pbd->szFinalDir, lpszBasename);
        lstrcat(szTmp, c_szExtDAT);
        SetFileAttributes(szTmp, FILE_ATTRIBUTE_NORMAL);
        pbd->hDatFile = CreateFile(szTmp, GENERIC_READ|GENERIC_WRITE, 0, NULL,
                                  (bBackup ? OPEN_ALWAYS : OPEN_EXISTING) , FILE_ATTRIBUTE_NORMAL, NULL);
        if(pbd->hDatFile == INVALID_HANDLE_VALUE)
            return FALSE;

        pbd->dwDatOffset = SetFilePointer(pbd->hDatFile, 0, NULL, FILE_END);

        BuildPath(pbd->szIniFileName, pbd->szFinalDir, lpszBasename);
        lstrcat(pbd->szIniFileName, c_szExtINI);
        SetFileAttributes(pbd->szIniFileName, FILE_ATTRIBUTE_NORMAL);
    }
    return TRUE;
}

void MySetUninstallFileAttrib(LPSTR lpszPath, LPCSTR lpszBasename)
{
    char szTmp[MAX_PATH];
   
    BuildPath(szTmp, lpszPath, lpszBasename);
    lstrcat(szTmp, c_szExtDAT);
    SetFileAttributes(szTmp, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);

    BuildPath(szTmp, lpszPath, lpszBasename);
    lstrcat(szTmp, c_szExtINI);
    SetFileAttributes(szTmp, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);
    return;
}


HRESULT RestoreFiles( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    int      iErr = 0;
    BAKDATA  bd;
    char     szFile[MAX_PATH];
    char     szWinDir[MAX_PATH];
    DWORD    dwItems = 0;
    HWND     hProgressDlg = NULL;
    LPSTR    lpFile;
    FILELIST FileList;
    BOOL     bGotListFromIniFile = FALSE;

    if (lpFileList == NULL)
    {
        GetListFromIniFile(lpDir, lpBaseName, &lpFileList);
        bGotListFromIniFile = TRUE;
    }

    if ((lpFileList == NULL) || !(*lpFileList))
        return hr;      // Nothing to restore.

    if (!UninstallInfoInit(&bd, lpDir, lpBaseName, FALSE))
    {
        if (!(dwFlags & IE4_NOMESSAGES))
            MsgBox( NULL, IDS_BACKUPDAT_ERROR, MB_ICONEXCLAMATION, MB_OK);
        if (bGotListFromIniFile)
        {
            LocalFree(lpFileList);
            lpFileList = NULL;
        }
        return E_FAIL;
    }

    if (!(dwFlags & IE4_NOPROGRESS))
    {
        hProgressDlg = CreateDialogParam(g_hInst, MAKEINTRESOURCE(IDD_SAVERESTOREDLG), hDlg, SaveRestoreProgressDlgProc, FALSE);
        ShowWindow(hProgressDlg, SW_SHOWNORMAL);

        lpFile = lpFileList;
        while (*lpFile)
        {
            dwItems++;
            lpFile += lstrlen(lpFile) + 1;
        }
        UpdateWindow(hProgressDlg);
        SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_SETRANGE, 0, MAKELONG(0, dwItems));
        SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_SETSTEP, 1, 0L);
    }
    GetWindowsDirectory(szWinDir, sizeof(szWinDir));

    lpFile = lpFileList;
    while ((hr == S_OK) && (*lpFile))
    {
        FileList.name = lpFile;
        FileList.dwSize = 0;
        FileList.dwDatOffset = (DWORD)-1;

        FillBackupInfo(bd.szIniFileName, &FileList);

        if ( (FileList.bak_attribute != NO_FILE) &&
            (FileList.dwSize > 0) && (FileList.dwDatOffset != (DWORD)-1))
        {
            if (!MakeBakName(FileList.name, szFile))
            {
                if (!(dwFlags & IE4_NOMESSAGES))
                {
                    if (MsgBox1Param( hDlg, IDS_RESTORE_ERROR2, FileList.name, MB_ICONEXCLAMATION, MB_YESNO) == IDNO)
                    {
                        // error creating a temp file for file to restore.
                        hr = E_FAIL;
                        break;
                    }
                }
                goto NextFile;
            }

            // if need to use the reg count, we only do it for those files have real ref count to begin with
            if ( (dwFlags & AFSR_USEREFCNT) && (FileList.dwRefCount!=(DWORD)-1) )
            {
                DWORD dwRefCntInReg;

                dwRefCntInReg = GetRefCountFrReg( FileList.name );
                if ( dwRefCntInReg > FileList.dwRefCount )
                    goto NextFile;                    
            }

            iErr = RestoreSingleFile(&FileList, szFile, bd.hDatFile);
            if (iErr != 0)
            {
                if (!(dwFlags & IE4_NOMESSAGES))
                {
                    wsprintf(szFile, "%d", iErr);   // reuse szFile, it is set on every call in MakeBakName
                    if (MsgBox2Param( hDlg, IDS_RESTORE_ERROR, FileList.name, szFile, MB_ICONEXCLAMATION, MB_YESNO) == IDNO)
                        hr = E_FAIL;
                }
            }
            else
            {
               SetFileAttributes( szFile, FileList.bak_attribute );
               if ( CopyFileA(szFile, FileList.name, FALSE))
               {
                   SetFileAttributes( szFile, FILE_ATTRIBUTE_NORMAL );
                   DeleteFile( szFile );
               }
               else
                   initcopy(szWinDir, szFile, FileList.name);
            }
        }
        else
        {
            // the file was never backed up, delete it if the caller want's us to
            if (!(dwFlags & IE4_NODELETENEW) )
            {
                if ( (!DeleteFile(lpFile)) && (GetFileAttributes(lpFile) != (DWORD)-1))
                    initcopy(szWinDir, lpFile, "NUL");  // If we could not delete the file. Add to reboot delete
            }
        }

NextFile:
        lpFile += lstrlen(lpFile) + 1;

        if (!(dwFlags & IE4_NOPROGRESS))
        {
            UpdateWindow(hProgressDlg);
            SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_STEPIT, 0, 0L);
        }

    }

    if (hProgressDlg)
        DestroyWindow(hProgressDlg);

    if (bd.hDatFile != INVALID_HANDLE_VALUE)
        CloseHandle(bd.hDatFile);

    if (bGotListFromIniFile)
    {
        LocalFree(lpFileList);
        lpFileList = NULL;
    }
    return hr;
}

void FillBackupInfo(LPCSTR lpINIFile, FILELIST *pFileList)
{
    char szLine[MAX_STR_LEN];
    char szValue[MAX_PATH];

    pFileList->dwDatOffset = (DWORD)-1;
    pFileList->dwRefCount = (DWORD)-1;
    if (GetPrivateProfileString(c_szIE4SECTIONNAME, pFileList->name, "", szLine, sizeof(szLine), lpINIFile) != 0)
    {
        if (GetFieldString(szLine, 0, szValue, sizeof(szValue)))  // For the Attribute
            pFileList->bak_attribute = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

        if (pFileList->bak_attribute != (DWORD)NO_FILE)
        {
            pFileList->bak_exists = 1;
            if (GetFieldString(szLine, 1, szValue, sizeof(szValue)))  // For the size
                pFileList->dwSize = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 2, szValue, sizeof(szValue)))  // For the time/date
                pFileList->FileTime.dwLowDateTime = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 3, szValue, sizeof(szValue)))  // For the time/date
                pFileList->FileTime.dwHighDateTime = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 4, szValue, sizeof(szValue)))  // For the Offset
                pFileList->dwDatOffset = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 5, szValue, sizeof(szValue)))  // For the CRC
                pFileList->dwFileCRC = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 6, szValue, sizeof(szValue)))  // For the CRC
                pFileList->dwRefCount = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);
        }
        else
            pFileList->bak_exists = 0;

    }
    else
        pFileList->bak_exists = 0;

    return;
}

BOOL MakeBakName(LPSTR lpszName, LPSTR szBakName)
{
static int iNum = 0;
   BOOL bOK = FALSE;
   LPSTR lpTmp;
   char szFilename[14];

   lstrcpy(szBakName, lpszName);
   lpTmp = CharPrev( szBakName, szBakName+lstrlen(szBakName));

   // chop filename off
   //
   while ( (lpTmp > szBakName) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( szBakName, lpTmp );

   if ( *CharPrev( szBakName, lpTmp ) == ':' )
   {
       lpTmp = CharNext(lpTmp) ;
   }
   *lpTmp = '\0';

   while ((iNum < 1000) && !bOK)
   {
        *lpTmp = '\0';
        wsprintf(szFilename, "IEBAK%03d.TMP", iNum++);
        AddPath(szBakName, szFilename);
        bOK = (GetFileAttributes(szBakName) == 0xFFFFFFFF);  // File does not exist, then OK
   }

   if (!bOK)
   {
       // If we could not get a tempfile name with the above methode, try GetTempFileName
       // Retry once, if it does not work fail.
       *lpTmp = '\0';
       CreateFullPath(lpszName, FALSE); // If directory does not exist GetTempFileName() fails.
       bOK = GetTempFileName(szBakName, "IE4", 0, szBakName);
   }
   
   return bOK;
}




// copy files by, adding them to wininit.ini
void initcopy(const char * StfWinDir, char * from, char * to)
{
    char * wininitpath;
    char * wininitname = {"wininit.ini"};
    LPTSTR      lpBuf = NULL;
    LPTSTR      lpTmp;
    static DWORD dwBufSize = MAX_STR_LEN*3;
    DWORD       dwBytes;

    if (ctx.wOSVer == _OSVER_WIN95)
    {
        // 16 is just for padding
        wininitpath = (char*) LocalAlloc(LPTR, lstrlen(StfWinDir) + lstrlen(wininitname) + 2 + 16);
        if (wininitpath)
        {
            lstrcpy(wininitpath, StfWinDir);
            AddPath(wininitpath, wininitname);

            while (TRUE)
            {
                lpBuf = (LPTSTR)LocalAlloc( LPTR, (UINT)dwBufSize );
                if (lpBuf)
                {
                    dwBytes = GetPrivateProfileSection( SEC_RENAME, lpBuf, dwBufSize, wininitname );

                    //The 16 below is just padding (all we probably need is only 3 or so)...
                    if ( (dwBytes >= (dwBufSize - 2)) || (dwBytes+lstrlen(to)+lstrlen(from)+16) > dwBufSize )
                    {
                        // not enough buf size
                        dwBufSize += MAX_STR_LEN;
                        LocalFree( lpBuf );
                    }
                    else
                    {
                        lpTmp = lpBuf+dwBytes;
                        if (lstrcmpi(to, "NUL") == 0)
                            lstrcpy(lpTmp, to);
                        else
                            GetShortPathName( to, lpTmp, (dwBufSize - dwBytes) );
                        lstrcat( lpTmp, "=" );
                        GetShortPathName( from, lpTmp + lstrlen(lpTmp), (dwBufSize - dwBytes - lstrlen(lpTmp)) );

                        // MessageBox(NULL, lpTmp, wininitname, MB_OK);

                        lpTmp += lstrlen(lpTmp);
                        lpTmp++; //jump over the first '\0'
                        *lpTmp = '\0';

                        WritePrivateProfileSection( SEC_RENAME, lpBuf, wininitname );

                        break;
                    }
                }
                else
                    break;
            }

            if (lpBuf)
            {
                LocalFree( lpBuf );
                lpBuf = NULL;
            }

            LocalFree(wininitpath);
        }
    }
    else
    {
        if (lstrcmpi(to, "NUL") == 0)
            MoveFileEx(from, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);    // delete the file
        else
            MoveFileEx(from, to, MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING);      // rename the file
    }   
}

BOOL BackupSingleFile(FILELIST * filelist, PBAKDATA pbd)
{
    HANDLE  hFile;
    BOOL    bErr=FALSE;
    DWORD   cbRead;
    DWORD   cbComp;
    LPBYTE  lpBuff;
    LPBYTE  lpBuffComp;
    DWORD   dwFileSig = DAT_FILESIG;
    DWORD   dwOrigDatOffset = pbd->dwDatOffset;
    DWORD   dwBytesWritten = 0;
    DWORD   dwFileSize;
    ULONG      ulCRC = CRC32_INITIAL_VALUE;
    FILETIME   FileTime = {0, 0};
    BOOL    bRet=TRUE;


    cbRead = (DWORD)MAX_IOSIZE;
    lpBuff = LocalAlloc(LPTR, cbRead + 32 ); 
    lpBuffComp = LocalAlloc(LPTR, cbRead + 32);

    if (!lpBuff || !lpBuffComp) 
    {
        bRet=FALSE;
    } 
    else 
    {
        hFile = CreateFile(filelist->name, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile==INVALID_HANDLE_VALUE) 
        {
           bRet=FALSE;
        } 
        else 
        {
            GetFileTime(hFile, NULL, NULL, &FileTime);
            dwFileSize = GetFileSize(hFile, NULL);

            if (!WriteFile(pbd->hDatFile, &dwFileSig, sizeof(dwFileSig), &dwBytesWritten, NULL))
            {
                cbRead = 0;             // prevent the loop from executing
                bRet=FALSE;
            }
            else
                pbd->dwDatOffset += sizeof(dwFileSig);

            while (cbRead == MAX_IOSIZE) 
            {
                if (!ReadFile (hFile, lpBuff, (DWORD)MAX_IOSIZE, &cbRead, NULL))
                {
                    bRet=FALSE;
                    break;
                }
                if (cbRead == 0)        // no more data, time to leave
                    break;

                ulCRC = CRC32Compute(lpBuff, cbRead, ulCRC);
                
                cbComp = Mrci1MaxCompress(lpBuff, cbRead, lpBuffComp, (DWORD)MAX_IOSIZE);
                if ((cbComp == (DWORD) -1) || (cbComp >= cbRead))
                {
                    cbComp = 0;
                }

                // We want to write out lpBuff if cbComp is ZERO, or
                // lpBuffComp is cbComp is NON-ZERO.  In any case, we
                // precede every chunk with two words:  cbRead and cbComp.

                dwFileSig = cbRead | ((DWORD)cbComp << 16);

                if (!WriteFile(pbd->hDatFile, &dwFileSig, sizeof(dwFileSig), &dwBytesWritten, NULL))
                {
                    bRet=FALSE;
                    break;
                }
                pbd->dwDatOffset += sizeof(dwFileSig);

                if (!cbComp) 
                {
                    bErr = !WriteFile(pbd->hDatFile, lpBuff, cbRead, &dwBytesWritten, NULL);
                } 
                else 
                {
                    bErr = !WriteFile(pbd->hDatFile, lpBuffComp, cbComp, &dwBytesWritten, NULL);
                }
                if (bErr) 
                {
                    bRet=FALSE;
                    break;
                }
                pbd->dwDatOffset += dwBytesWritten;
            }

            CloseHandle(hFile);

            // Write out size/date/time etc to ini file
            if (!bErr)
            {
                DosPrintf(pbd, filelist, 
                              dwFileSize,
                              FileTime,
                              dwOrigDatOffset,
                              ulCRC);
            }
        }
    }
    if (lpBuffComp)
        LocalFree(lpBuffComp);

    if (lpBuff)
        LocalFree(lpBuff);

    return bRet;
}

int DosPrintf(PBAKDATA pbd, FILELIST *filelist, DWORD dwFileSize,
              FILETIME FileTime, DWORD dwDatOffset, DWORD dwCRC)
{
    WORD cb;
    char szTmp[MAX_STR_LEN];

    // BUGBUG: if we rewrite the line, we lose the ref count and becomes -1 again.
    // UpdateRefCnt() will not get a chance to increase the count based on the original data.
    //
    cb = (WORD)wsprintf(szTmp, "%lx,%lx,%lx,%lx,%lx,%lx,%d", 
                         filelist->bak_attribute, 
                         dwFileSize,
                         FileTime.dwLowDateTime, 
                         FileTime.dwHighDateTime,
                         dwDatOffset, dwCRC, -1);
    WritePrivateProfileString(c_szIE4SECTIONNAME, filelist->name, szTmp, pbd->szIniFileName);
    return cb;
}

//
// Copied from Windows 95 unistal.exe cfg.c function CfgGetField
BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize)
{
    int cbField;
    LPSTR lpszChar, lpszEnd;
    // Find the field we are looking for

    lpszChar = lpszLine;

    // Each time we see a separator, decrement iField
    while (iField > 0 && (BYTE)*lpszChar > CR) {

        if (*lpszChar == '=' || *lpszChar == ',' || *lpszChar == ' ' ) {
            iField--;
            while (*lpszChar == '=' || *lpszChar== ',' || *lpszChar == ' ' && (BYTE)*lpszChar > 13)
                lpszChar++;
        }
        else
            lpszChar++;
    }

    // If we still have fields remaining then something went wrong
    if (iField)
        return FALSE;

    // Now find the end of this field
    lpszEnd = lpszChar;
    while (*lpszEnd != '=' && *lpszEnd != ',' && *lpszEnd != ' ' && (BYTE)*lpszEnd > CR)
        lpszEnd++;

    // Find the length of this field - make sure it'll fit in the buffer
    cbField = (int)((lpszEnd - lpszChar) + 1);

    if (cbField > cbSize) {     // I return an error if the requested
      //cbField = cbSize;       // data won't fit, rather than truncating
        return FALSE;           // it at some random point! -JTP
    }

    // Note that the C runtime treats cbField as the number of characters
    // to copy from the source, and if that doesn't happen to transfer a NULL,
    // too bad.  The Windows implementation of _lstrcpyn treats cbField as
    // the number of characters that can be stored in the destination, and
    // always copies a NULL (even if it means copying only cbField-1 characters
    // from the source).

    // The C runtime also pads the destination with NULLs if a NULL in the
    // source is found before cbField is exhausted.  _lstrcpyn essentially quits
    // after copying a NULL.


    lstrcpyn(lpszField, lpszChar, cbField);

    return TRUE;
}

int RestoreSingleFile(FILELIST *filelist, LPSTR lpszBakFile, HANDLE hDatFile)
{
   LPBYTE lpBuff;
   LPBYTE lpBuffDecomp;
   LPBYTE lpWrite;
   HANDLE   hFile;
   DWORD  dwFileSig;
   DWORD  dwByteRead;
   DWORD  dwByteDecomp;
   DWORD  dwBytesWritten;
   ULONG  ulCRC = CRC32_INITIAL_VALUE;
   int    iErr = OK;
   LONG   lSize = (LONG)filelist->dwSize;
   WORD   wComp;
   WORD   wRead;

   lpBuff = LocalAlloc(LPTR, MAX_IOSIZE);
   lpBuffDecomp = LocalAlloc(LPTR, MAX_IOSIZE);
   if ((lpBuff) && (lpBuffDecomp))
   {

      hFile= CreateFile(lpszBakFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
      if (hFile == INVALID_HANDLE_VALUE)
      {
          CreateFullPathForFile(lpszBakFile);
          hFile= CreateFile(lpszBakFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
      }

      if (hFile != INVALID_HANDLE_VALUE)
      {
         if (SetFilePointer(hDatFile, filelist->dwDatOffset, NULL, FILE_BEGIN) != (DWORD)-1)
         {
            if (ReadFile (hDatFile, (LPVOID)&dwFileSig, (DWORD)sizeof(dwFileSig), &dwByteRead, NULL))
            {
               if (dwFileSig != DAT_FILESIG)
                  iErr = MYERROR_BAD_SIG;
            }
            else
               iErr = MYERROR_READ;

         }
         else
            iErr = MYERROR_UNKNOWN;

         while ((iErr == OK) && (lSize > 0))  
         {
            if (!ReadFile (hDatFile, (LPVOID)&dwFileSig, (DWORD)sizeof(dwFileSig), &dwByteRead, NULL))
            {
               iErr = MYERROR_READ;
               break;
            }

            wComp = (WORD)(dwFileSig >> 16);
            wRead = (WORD)(dwFileSig & 0xffff);
            lpWrite = lpBuff;
            dwByteDecomp = (DWORD)wRead;

            if ((wComp > MAX_IOSIZE) ||  (wRead > MAX_IOSIZE))
            {
               iErr = MYERROR_BAD_DATA;
            }
            else if (wComp == 0)
            {
               if (!ReadFile (hDatFile, lpBuff, wRead, &dwByteDecomp, NULL))
               {
                  iErr = MYERROR_READ;
               }
               
            }
            else 
            {
               lpWrite = lpBuffDecomp;
               if (!ReadFile (hDatFile, lpBuff, wComp, &dwByteRead, NULL))
               {
                  iErr = MYERROR_READ;
               }
               else
               {
                  dwByteDecomp = Mrci1Decompress(lpBuff, wComp, lpBuffDecomp, wRead);
                  if (dwByteDecomp != (DWORD)wRead)
                     iErr = MYERROR_DECOMP_FAILURE;
               }
            }
            if (iErr != OK)
            {
               break;
            }
            ulCRC = CRC32Compute(lpWrite, dwByteDecomp, ulCRC);
            if (!WriteFile(hFile, lpWrite, dwByteDecomp, &dwBytesWritten, NULL))
            {
               iErr = MYERROR_WRITE;
               break;
            }
            lSize -= (LONG)dwBytesWritten;
         } // while

         SetFileTime(hFile, NULL, NULL, &filelist->FileTime);
         CloseHandle(hFile);

         if (ulCRC != filelist->dwFileCRC)
         {
            iErr = MYERROR_BAD_CRC;
         }

         if (iErr != OK)
         {
            DeleteFile(lpszBakFile);
         }
      }
      else
      {
         // Could not create backup file
         iErr = MYERROR_BAD_BAK;
      }
   }
   else
   {
      // Alloc failed
      iErr = MYERROR_OUTOFMEMORY;
   }

   if (lpBuff)
      LocalFree(lpBuff);
   if (lpBuffDecomp)
      LocalFree(lpBuffDecomp);

   return iErr;
}



#define IsSpace(c)              ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')

/* flag values */
#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


unsigned long Mystrtoxl (
        const char *nptr,
        const char **endptr,
        int ibase,
        int flags
        )
{
        const char *p;
        char c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while ( IsSpace((int)(unsigned char)c) )
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != '0')
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == '0' && (*p == 'x' || *p == 'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if ( c >= '0' && c <= '9' ) // isdigit
                        digval = c - '0';
                else if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ))
                    // if ( isalpha((int)(unsigned char)c) )
                        digval = (unsigned)(ULONG_PTR)CharUpper((LPSTR)c) - 'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                //errno = 34;     // 34 is the define of ERANGE from errno.h
                if ( flags & FL_UNSIGNED )
                        number = ULONG_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned long)(-LONG_MIN);
                else
                        number = LONG_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        return number;                  /* done. */
}

unsigned long Mystrtoul (
        const char *nptr,
        char **endptr,
        int ibase
        )
{
    return Mystrtoxl(nptr, endptr, ibase, FL_UNSIGNED);
}


INT_PTR CALLBACK SaveRestoreProgressDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM  lParam)
{
    switch( uMsg )
    {
        case WM_INITDIALOG:
            ShowWindow(GetDlgItem(hwndDlg, IDS_SAVEINFO_TEXT), lParam? SW_SHOW : SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDS_RESTOREINFO_TEXT), lParam? SW_HIDE : SW_SHOW );
            CenterWindow( hwndDlg, GetDesktopWindow());
            ShowWindow(hwndDlg, SW_SHOWNORMAL);
            break;
                    
        default:                            // For MSG switch
            return(FALSE);
    }
    return(TRUE);
}

//
// Creates the path for the full qualified file name.
// We have to get rid of the filename first, before we
// can attempt to create the path.
void CreateFullPathForFile(LPSTR lpszBakFile)
{
    char szDir[MAX_PATH];
    lstrcpy(szDir, lpszBakFile);
    GetParentDir(szDir);
    CreateFullPath(szDir, FALSE);
}


void GetListFromIniFile(LPSTR lpDir, LPSTR lpBaseName, LPSTR *lplpFileList)
{
    char szINI[MAX_PATH];
    WIN32_FIND_DATA FindFileData;
    HANDLE  hFind;
    LPSTR   lpTmp;

    BuildPath(szINI, lpDir, lpBaseName);
    lstrcat(szINI, c_szExtINI);
    if ((hFind = FindFirstFile(szINI, &FindFileData)) != INVALID_HANDLE_VALUE)
    {
        if (lpTmp = LocalAlloc(LPTR, FindFileData.nFileSizeLow))
        {
            GetPrivateProfileString(c_szIE4SECTIONNAME, NULL, "", lpTmp, FindFileData.nFileSizeLow, szINI);
            if (*lpTmp)
            {
                *lplpFileList = lpTmp;
            }
            else
                LocalFree(lpTmp);   // Nothing found in the INI file
        }
        FindClose(hFind);
    }

}


HRESULT AddDelBackupEntryHelper(LPCSTR lpcszFileList, LPCSTR lpcszBackupDir, LPCSTR lpcszBaseName, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    LPCSTR   lpcszFile;
    char     szIniFileName[MAX_PATH];

    if ((lpcszFileList) && (*lpcszFileList))
    {
        BuildPath(szIniFileName, lpcszBackupDir, lpcszBaseName);
        lstrcat(szIniFileName, c_szExtINI);
        SetFileAttributes(szIniFileName, FILE_ATTRIBUTE_NORMAL);
        lpcszFile = lpcszFileList;
        while (*lpcszFile)
        {
            WritePrivateProfileString(c_szIE4SECTIONNAME, lpcszFile, (dwFlags & AADBE_ADD_ENTRY) ? c_szNoFileLine : NULL, szIniFileName);
            lpcszFile += lstrlen(lpcszFile) + 1;
        }
        WritePrivateProfileString(NULL, NULL, NULL, szIniFileName);         // flush the INI file
        SetFileAttributes(szIniFileName, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);
    }
    return hr;
}


HRESULT WINAPI FileSaveMarkNotExist( LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName)
{
    return AddDelBackupEntryHelper(lpFileList, lpDir, lpBaseName, AADBE_ADD_ENTRY);
}


HRESULT WINAPI AddDelBackupEntry(LPCSTR lpcszFileList, LPCSTR lpcszBackupDir, LPCSTR lpcszBaseName, DWORD dwFlags)
{
    return AddDelBackupEntryHelper(lpcszFileList, lpcszBackupDir, lpcszBaseName, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\w95pub32.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* W95PUB16.H - Public interface to W95INF16.DLL.                          *
//*                                                                         *
//***************************************************************************

#ifndef _W95PUB16_H_
#define _W95PUB16_H_

static const TCHAR achCTLSETLDDPATH32[]                 = "CtlSetLddPath32@8";
static const TCHAR achGENINSTALL32[]                    = "GenInstall32@20";
static const TCHAR achGETSETUPXERRORTEXT32[]            = "GetSETUPXErrorText32@12";
static const TCHAR achGENFORMSTRWITHOUTPLACEHOLDERS32[] = "GenFormStrWithoutPlaceHolders32@12";

typedef VOID (WINAPI *GETSETUPXERRORTEXT32)( DWORD, LPSTR, DWORD);
typedef WORD (WINAPI *CTLSETLDDPATH32)(UINT, LPSTR);
typedef WORD (WINAPI *GENINSTALL32)(LPSTR, LPSTR, LPSTR, DWORD, DWORD);
typedef BOOL (WINAPI *GENFORMSTRWITHOUTPLACEHOLDERS32)(LPSTR, LPSTR, LPSTR);

#endif // _W95PUB16_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpack\uninstal.h ===
#ifndef _UNINSTAL_H


/*
 * Errors that *we* have defined
 */
#define MYERROR_UNKNOWN         -1      // maps to no msg
#define MYERROR_DISK_FULL       -2      // maps to MSG_ERROR_DISK_FULL
#define MYERROR_BAD_DATA        -3      // maps to MSG_ERROR_BAD_DATA
#define MYERROR_UNEXPECTED_EOF  -4      // maps to MSG_ERROR_UNEXPECTED_EOF
#define MYERROR_READ            -5      
#define MYERROR_WRITE           -6
#define MYERROR_BAD_SIG         -7
#define MYERROR_DECOMP_FAILURE  -8
#define MYERROR_OUTOFMEMORY     -9
#define MYERROR_BAD_BAK         -10
#define MYERROR_BAD_CRC         -11


// define the bad-backup file attribute value
#define NO_FILE     -1

typedef struct _BAKDATA {
    HANDLE  hDatFile;
    DWORD   dwDatOffset;
    char    szIniFileName[MAX_PATH];        // used while making temp ini files
    char    szFinalDir[MAX_PATH];       // Final resting place of w95undo.*
} BAKDATA, FAR *PBAKDATA;

typedef struct _FILELIST {
    char* name;
//    char* bakname;
    UINT   bak_exists;
    DWORD bak_attribute;
    FILETIME FileTime;
    DWORD dwSize;
    DWORD dwDatOffset;
    DWORD dwFileCRC;
    DWORD dwRefCount;
    struct _FILELIST * next;

} FILELIST;



//RC PRIVATE SaveBackups( );
BOOL BackupInit(PBAKDATA pbd, LPCSTR lpszPath);

int Files_need_backup( FILELIST *filelist );
BOOL ReplaceBackups(FILELIST * filelist, char * StfWinDir);
int Files_need_backup( FILELIST *filelist );
void backups_exist(FILELIST * filelist);
BOOL BackupSingleFile(FILELIST * filelist, PBAKDATA pbd);
BOOL GetValueForFileFromIni(FILELIST *FileList);
int DosPrintf(PBAKDATA pbd, FILELIST *filelist, DWORD dwFileSize,
              FILETIME FileTime, DWORD dwDatOffset, DWORD dwCRC);
void WriteUninstallDirToReg(LPSTR lpszUninstallDir);
void DeleteUninstallDirFromToReg();
//BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize); 
BOOL MakeBakName(LPSTR lpszName, LPSTR szBakName);
BOOL DoSaveUninstall(BOOL bStopUninstall);
BOOL GetUninstallDirFromReg(LPSTR lpszUninstallDir);
BOOL DetermineUninstallDir(FILELIST *FileList, LPSTR lpszUninstallDir, DWORD *pdwSizeNeeded);
BOOL UninstallInfoExists();
void DeleteUninstallFilesAndReg();
void SetUninstallFileAttrib(LPSTR szPath);
BOOL ValidateUninstallFiles(LPSTR lpszPath);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\advpext.h ===
#include <setupapi.h>

#ifndef _ADVEXT
#define _ADVEXT


typedef struct _DOWNLOAD_FILEINFO DOWNLOAD_FILEINFO;
typedef DOWNLOAD_FILEINFO* PDOWNLOAD_FILEINFO;

struct _DOWNLOAD_FILEINFO 
{
    LPTSTR lpszFileNameToDownload;
    LPTSTR lpszExistingFileToPatchFrom;     
    LPTSTR lpszExistingFilePatchSignature;  
    DWORD  dwFlags;							
};

typedef struct _DOWNLOAD_INFO 
{
    DWORD dwFilesToDownload;
    DWORD dwFilesRemaining;
    DWORD dwBytesToDownload;
    DWORD dwBytesRemaining;
}DOWNLOAD_INFO, *PDOWNLOAD_INFO;


enum PATCH_DOWNLOAD_REASON 
{
    PATCH_DOWNLOAD_BEGIN,          
    PATCH_DOWNLOAD_FINDINGSITE,          
    PATCH_DOWNLOAD_CONNECTING,          
    PATCH_DOWNLOAD_DOWNLOADINGDATA,          
    PATCH_DOWNLOAD_ENDDOWNLOADINGDATA,          
    PATCH_DOWNLOAD_PROGRESS,            // AdditionalInfo is _DOWNLOAD_INFO
    PATCH_DOWNLOAD_FILE_COMPLETED,      // AdditionalInfo is _DOWNLOAD_FILEINFO
    PATCH_DOWNLOAD_FILE_FAILED,         // AdditionalInfo is _DOWNLOAD_FILEINFO
    PATCH_DOWNLOAD_ABORT  
};


#define PATCH_DOWNLOAD_FLAG_CONTINUE            0x00000001
#define PATCH_DOWNLOAD_FLAG_RETRY               0x00010000
#define PATCH_DOWNLOAD_FLAG_FAILED              0x00020000
#define PATCH_DOWNLOAD_FLAG_HASH_INCORRECT      0x00100000


typedef BOOL (WINAPI * PATCH_DOWNLOAD_CALLBACK)(PATCH_DOWNLOAD_REASON Reason, PVOID AdditionalInfo, PVOID CallBackContext);


HRESULT WINAPI ProcessFileSection(HINF hInf, HWND hWnd, BOOL fQuietMode, LPCSTR lpszSection, 
                                  LPCSTR lpszSrcDir, PATCH_DOWNLOAD_CALLBACK pfn, LPVOID lpvContext);

HRESULT WINAPI GetFileList(HINF hInf, LPCSTR lpszSection, PDOWNLOAD_FILEINFO* pFileList, DWORD* pdwFileCount);

HRESULT WINAPI DownloadAndPatchFiles(DWORD dwFileCount, DOWNLOAD_FILEINFO* pFileInfo,  LPCSTR SourceURLs,  
								LPCSTR   lpszPath, PATCH_DOWNLOAD_CALLBACK  pfnCallback, LPVOID lpvContext); 


BOOL WINAPI PatchCallback(PATCH_DOWNLOAD_REASON Reason, PVOID AdditionalInfo, PVOID CallBackContext);

int WINAPI CompareHashID(LPCTSTR lpszFile, LPCTSTR lpszHash);

HRESULT PrepareInstallDirectory(HINF hInf, LPCSTR lpszSection);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\crc32.h ===
#ifndef _CRC32_H_
#define _CRC32_H_

#ifndef INLINE
#define INLINE __inline
#endif

extern const ULONG CrcTable32[ 256 ];     // defined in crctable.c

VOID GenerateCrc32Table( VOID );          // stubbed in crctable.c, but not used
                                          // (exists for compatibility)

ULONG
INLINE
Crc32(
    IN ULONG InitialCrc,
    IN PVOID Buffer,
    IN ULONG ByteCount
    )
    {

#ifdef _X86_

    __asm {

            mov     ecx, ByteCount          ; number of bytes in buffer
            xor     ebx, ebx                ; ebx (bl) will be our table index
            mov     esi, Buffer             ; buffer pointer
            test    ecx, ecx                ; test for zero length buffer
            mov     eax, InitialCrc         ; CRC-32 value

            jnz     short loopentry         ; if non-zero buffer, start loop
            jmp     short exitfunc          ; else exit (crc already in eax)

looptop:    shr     eax, 8                  ; (crc>>8)                      (U1)
            mov     edx, CrcTable32[ebx*4]  ; fetch Table[ index ]          (V1)

            xor     eax, edx                ; crc=(crc>>8)^Table[index]     (U1)
loopentry:  mov     bl, [esi]               ; fetch next *buffer            (V1)

            inc     esi                     ; buffer++                      (U1)
            xor     bl, al                  ; index=(byte)crc^*buffer       (V1)

            dec     ecx                     ; adjust counter                (U1)
            jnz     short looptop           ; loop while nBytes             (V1)

            shr     eax, 8                  ; remaining math on last byte
            xor     eax, CrcTable32[ebx*4]  ; eax returns new crc value

exitfunc:

        }

#else // ! _X86_

    ULONG Value = InitialCrc;
    ULONG Count = ByteCount;
    PUCHAR p    = Buffer;

    while ( Count-- ) {
        Value = ( Value >> 8 ) ^ CrcTable32[ (UCHAR)( *p++ ^ Value ) ];
        }

    return Value;

#endif // ! _X86_

    }

#endif // _CRC32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\advpext.cpp ===
// advpext.cpp : Defines the entry point for the DLL application.
//
#include <windows.h>
#include <wininet.h>
#include "util.h"
#include "download.h"
#include "patchapi.h"
#include "resource.h"
#include "patchdownload.h"
#include "sdsutils.h"



#define FILECOUNT                    50

PDOWNLOAD_FILEINFO g_pDownloadFileList = NULL;
DWORD g_dwFileCount = 0;
DWORD g_dwArraySize = 0;

HRESULT g_hResult;
HINF g_hInf;
BOOL g_fPreparingDir;
BOOL g_QuietMode = FALSE;
BOOL g_fAbort = FALSE;
HWND g_hProgressDlg = NULL;
HINSTANCE g_hInstance;
HINSTANCE g_hSetupLibrary = NULL;

PFSetupDefaultQueueCallback       pfSetupDefaultQueueCallback       = NULL;
PFSetupInstallFromInfSection      pfSetupInstallFromInfSection      = NULL;
PFSetupInitDefaultQueueCallbackEx pfSetupInitDefaultQueueCallbackEx = NULL;
PFSetupTermDefaultQueueCallback   pfSetupTermDefaultQueueCallback   = NULL;
PFSetupGetLineText                pfSetupGetLineText                = NULL;
PFSetupFindFirstLine              pfSetupFindFirstLine              = NULL;
PFSetupFindNextLine               pfSetupFindNextLine               = NULL;
PFSetupGetStringField             pfSetupGetStringField             = NULL;
PFSetupDecompressOrCopyFile       pfSetupDecompressOrCopyFile       = NULL;




BOOL APIENTRY DllMain( HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    if(DLL_PROCESS_ATTACH == ul_reason_for_call)
    {
        InitLogFile();
        g_hInstance = (HINSTANCE)hModule;
    }

    if(DLL_PROCESS_DETACH == ul_reason_for_call)
    {
        if(g_hLogFile)
            CloseHandle(g_hLogFile);
        if(g_hSetupLibrary)
            FreeLibrary(g_hSetupLibrary);
    }

    return TRUE;
}



HRESULT WINAPI ProcessFileSection(HINF hInf, HWND hWnd, BOOL fQuietMode, LPCSTR lpszSection, LPCSTR lpszSourceDir,
                                  PATCH_DOWNLOAD_CALLBACK pfn, LPVOID lpvContext)
{
    HRESULT hr = S_OK;
    PDOWNLOAD_FILEINFO pFileList = NULL;
    char szUserName[MAX_PATH] = "", szPassword[MAX_PATH] = "", szUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szSrcDir[MAX_PATH];
    DWORD dwFileCount=0;


    WriteToLog("ProcessFileSection: InfHandle= %1!lx!, Source Directory = %2\n", hInf, lpszSourceDir);
    g_hInf = hInf;
    g_fPreparingDir = FALSE;

    if(fQuietMode)
    {
        g_QuietMode = TRUE;
    }


    if(!g_QuietMode)
    {
        g_hProgressDlg = CreateDialog(g_hInstance, MAKEINTRESOURCE(IDD_PROGRESSDLG), hWnd, ProgressDlgProc);
        if (g_hProgressDlg)
        {
            ShowWindow(g_hProgressDlg, SW_SHOWNORMAL);
            UpdateWindow(g_hProgressDlg);
        }
    }

    SetProgressText(IDS_FILELIST);
    hr = GetFileList(hInf, lpszSection, &pFileList, &dwFileCount);
    if(FAILED(hr))
    {
        goto done;
    }

    if(dwFileCount)
    {
        if(!pfSetupGetLineText(NULL, hInf, lpszSection, "Url", szUrl, sizeof(szUrl), NULL))
        {
            hr = HRESULT_FROM_SETUPAPI(GetLastError());
            goto done;
        }

        hr = DownloadAndPatchFiles(dwFileCount, pFileList, szUrl, lpszSourceDir, pfn, lpvContext); 

        if(FAILED(hr) || g_fAbort)
        {
            goto done;
        }
    }

    hr = PrepareInstallDirectory(hInf, lpszSection);

        
done:

    if(pFileList)
    {
        FreeFileList(pFileList);
    }

    if(g_hProgressDlg)
    {
        DestroyWindow(g_hProgressDlg);
    }
    return hr;

}

HRESULT WINAPI GetFileList(HINF hInf, LPCSTR lpszSection, PDOWNLOAD_FILEINFO* pFileList, DWORD* pdwFileCount)
{
    
    HRESULT hr = LoadSetupAPIFuncs();
    if(FAILED(hr))
    {
        return hr;
    }

    WriteToLog("\nGetting the list of files\n");
    g_hResult = S_OK;
    //initially we allocate around 50 entries. We reallocate as and when needed
    g_dwArraySize = FILECOUNT;
    g_pDownloadFileList = (PDOWNLOAD_FILEINFO)ResizeBuffer(NULL, FILECOUNT*sizeof(DOWNLOAD_FILEINFO), FALSE);
    
    if(!g_pDownloadFileList)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    g_dwFileCount = 0;


    PVOID pContext = pfSetupInitDefaultQueueCallbackEx( NULL, (HWND)INVALID_HANDLE_VALUE, 0, 0, NULL );

    if ( pContext == INVALID_HANDLE_VALUE ) 
    {
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    WriteToLog("Adding the Following Files\n");
    if (!pfSetupInstallFromInfSection( NULL, hInf, lpszSection, SPINST_FILES, NULL,
                                        NULL, SP_COPY_NEWER, (PSP_FILE_CALLBACK)MyFileQueueCallback, 
                                        pContext, NULL, NULL ) )
    {
        pfSetupTermDefaultQueueCallback( pContext );
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    pfSetupTermDefaultQueueCallback( pContext );

    if(SUCCEEDED(g_hResult))
    {
        *pFileList = g_pDownloadFileList;
        *pdwFileCount = g_dwFileCount;
    }

    return g_hResult;
}



UINT WINAPI MyFileQueueCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 )
{       
    UINT retVal = FILEOP_SKIP;

    switch(Notification)
    {
        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_COPYERROR:
        case SPFILENOTIFY_DELETEERROR:
        case SPFILENOTIFY_RENAMEERROR:
            break;

        case SPFILENOTIFY_STARTCOPY:
            {
                FILEPATHS *pFilePath;

                pFilePath = (FILEPATHS *)parm1;                            
                
                if (!MyFileSize(pFilePath->Source)) 
                {
                    DeleteFile(pFilePath->Source);

                    //If we are preparing the dir for installaion then copy the file to the current path.
                    //else we are in download mode, add it to the file list if required
                    if(g_fPreparingDir)
                    {

                        if(CopyFile(pFilePath->Target, pFilePath->Source, TRUE))
                            WriteToLog("Copying %1 file to %2\n", pFilePath->Target, pFilePath->Source);
                    }
                    else
                    {
                        //Check in the version in inf to see if we need to download
                        if(IsDownloadedNeeded(pFilePath->Source, pFilePath->Target))
                            AddToFileList(pFilePath->Source, pFilePath->Target);
                    }
                }

            }
            break;

        case SPFILENOTIFY_NEEDMEDIA:
            {
                char szFileName[MAX_PATH];
                PSOURCE_MEDIA psrcMed;

                psrcMed = (PSOURCE_MEDIA)parm1;
                wsprintf(szFileName, "%s\\%s", psrcMed->SourcePath, psrcMed->SourceFile);
                
                if(GetFileAttributes(szFileName) == 0xFFFFFFFF ) 
                {
                    if(g_fPreparingDir)
                    {
                        if(GetFileAttributes(szFileName) != 0xFFFFFFFF)
                            return retVal;
                    }


                    HANDLE hTempFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, 
                        CREATE_NEW, FILE_ATTRIBUTE_TEMPORARY, NULL );
                    

                    if (hTempFile != INVALID_HANDLE_VALUE)
                    {
                        CloseHandle( hTempFile );                        
                    }
                }


            }

        default:
            return (pfSetupDefaultQueueCallback( Context, Notification, parm1, parm2 ) );
    }

    return( retVal );
}


BOOL IsDownloadedNeeded(LPCTSTR lpszSrcFilePath, LPCTSTR lpszFilePath)
{
    char szVersion[MAX_PATH], szSrcFilePath[MAX_PATH];
    INFCONTEXT InfContext;
    LPTSTR lp;

    LPTSTR lpszSrcName = PathFindFileName(lpszSrcFilePath);


    if (!pfSetupFindFirstLine(g_hInf, "SourceDisksFiles", lpszSrcName, &InfContext ))
    {
        //No SourceDisksFiles entry. Assume that this file needs to be downloaded
        return TRUE;
    }

    DWORD   dwMSVer = 0, dwLSVer = 0, dwMSNewFileVer = 0, dwLSNewFileVer = 0;

    if(pfSetupGetStringField(&InfContext, 4, szVersion, sizeof(szVersion), NULL))
    {
        //Get version of file on the machine
        ConvertVersionStrToDwords(szVersion, &dwMSNewFileVer, &dwLSNewFileVer);    
        MyGetVersionFromFile((LPTSTR)lpszFilePath, &dwMSVer, &dwLSVer, TRUE);
    }

    if(dwMSVer == dwMSNewFileVer && dwLSVer == dwLSNewFileVer)
    {
        TCHAR szHashFromInf[40], szHashFromFile[40];

        if(GetHashidFromINF(lpszSrcName, szHashFromInf, sizeof(szHashFromInf)) && 
           GetFilePatchSignatureA(lpszFilePath, PATCH_OPTION_SIGNATURE_MD5, NULL, 0, 0, 0, 0, 
                                    sizeof(szHashFromFile), szHashFromFile))
        {
            if (lstrcmpi(szHashFromFile, szHashFromInf) == 0 ) 
            {
                return FALSE;
            }                
        }
        
        return TRUE;
    }

    if(dwMSVer < dwMSNewFileVer || ((dwMSVer == dwMSNewFileVer) && dwLSVer < dwLSNewFileVer))
    {
        return TRUE;
    }
    return FALSE;
}

void AddToFileList(LPCSTR lpszSrc, LPCSTR lpszTarget)
{
    TCHAR  Signature[40] = "";  // MD5 is 32 hex characters plus terminator


    if(g_dwFileCount >= g_dwArraySize)
    { 
        g_dwArraySize = g_dwArraySize + FILECOUNT;
        g_pDownloadFileList = (PDOWNLOAD_FILEINFO)ResizeBuffer(g_pDownloadFileList, 
                                        g_dwArraySize*sizeof(DOWNLOAD_FILEINFO), FALSE);
        
        if(!g_pDownloadFileList)
        {
            g_hResult = HRESULT_FROM_WIN32(GetLastError());
            return;
        }
    }


    GetFilePatchSignatureA(lpszTarget, PATCH_OPTION_USE_LZX_BEST, NULL, 0 , 0, 0, 0,
                            sizeof(Signature), Signature);
    if ( *Signature ) 
    {
        g_pDownloadFileList[g_dwFileCount].lpszExistingFilePatchSignature = StrDup(Signature);
    }
    else 
    {
        g_pDownloadFileList[g_dwFileCount].lpszExistingFilePatchSignature = NULL;
    }


    WriteToLog("%1  Destination:%2  Patch Signature:%3\n", PathFindFileName(lpszSrc), lpszTarget, Signature);
    g_pDownloadFileList[g_dwFileCount].lpszFileNameToDownload = StrDup(PathFindFileName(lpszSrc));
    g_pDownloadFileList[g_dwFileCount].lpszExistingFileToPatchFrom = StrDup(lpszTarget);     
    g_pDownloadFileList[g_dwFileCount].dwFlags = PATCHFLAG_DOWNLOAD_NEEDED;							
    g_dwFileCount++;

}

void FreeFileList(PDOWNLOAD_FILEINFO pFileList)
{
    int i = g_dwFileCount;
    while(i--)
    {
        if(pFileList[i].lpszFileNameToDownload)
        {
            LocalFree(pFileList[i].lpszFileNameToDownload);
        }

        if(pFileList[i].lpszExistingFileToPatchFrom)
        {
            LocalFree(pFileList[i].lpszExistingFileToPatchFrom);
        }

        if(pFileList[i].lpszExistingFilePatchSignature)
        {
            LocalFree(pFileList[i].lpszExistingFilePatchSignature);
        }
    }
    ResizeBuffer(pFileList, 0, 0);

}


HRESULT PrepareInstallDirectory(HINF hInf, LPCSTR lpszSection)
{
    g_hResult = S_OK; 
    g_fPreparingDir = TRUE;

    PVOID pContext = pfSetupInitDefaultQueueCallbackEx( NULL, (HWND)INVALID_HANDLE_VALUE, 0, 0, NULL );
    if ( pContext == INVALID_HANDLE_VALUE ) 
    {
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    WriteToLog("Copying the Following Files from src dir\n");
    if (!pfSetupInstallFromInfSection( NULL, hInf, lpszSection, SPINST_FILES, NULL,
                                        NULL, SP_COPY_NEWER, (PSP_FILE_CALLBACK)MyFileQueueCallback, 
                                        pContext, NULL, NULL ) )
    {
        pfSetupTermDefaultQueueCallback( pContext );
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    pfSetupTermDefaultQueueCallback( pContext );

    return g_hResult;
}


INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{

    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                CenterWindow (hDlg, GetDesktopWindow());
            }

            break;

        case WM_COMMAND:
            if(LOWORD(wParam) == IDCANCEL)
            {
                g_fAbort = TRUE;
            }

        default:
            return(FALSE);
    }
    return(TRUE);
}

BOOL SetProgressText(LPCTSTR lpszText)
{
    if(g_hProgressDlg)
    {
        SetDlgItemText(g_hProgressDlg, IDC_PROGRESSTEXT, lpszText);
    }
    return TRUE;
}

BOOL SetProgressText(UINT uID)
{
    if(g_hProgressDlg)
    {
        TCHAR szBuffer[MAX_PATH];
        LoadString(g_hInstance, uID, szBuffer, sizeof(szBuffer));
        SetDlgItemText(g_hProgressDlg, IDC_PROGRESSTEXT, szBuffer);
    }
    return TRUE;
}

HRESULT LoadSetupAPIFuncs()
{
    static BOOL fSetupLibLoaded = -1;
    HRESULT hr = S_OK;

    if(fSetupLibLoaded != -1)
    {
        return hr;
    }

    g_hSetupLibrary = LoadLibrary("SETUPAPI.DLL");

    if(!g_hSetupLibrary)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        WriteToLog("LoadLibrary for Setuapi.dll failed with error code:%1!lx!\n", hr);
        return hr;
    }


    pfSetupGetStringField             = (PFSetupGetStringField)             GetProcAddress(g_hSetupLibrary, c_szSetupGetStringField );
    pfSetupDefaultQueueCallback       = (PFSetupDefaultQueueCallback)       GetProcAddress(g_hSetupLibrary, c_szSetupDefaultQueueCallback );
    pfSetupInstallFromInfSection      = (PFSetupInstallFromInfSection)      GetProcAddress(g_hSetupLibrary, c_szSetupInstallFromInfSection );
    pfSetupInitDefaultQueueCallbackEx = (PFSetupInitDefaultQueueCallbackEx) GetProcAddress(g_hSetupLibrary, c_szSetupInitDefaultQueueCallbackEx );
    pfSetupTermDefaultQueueCallback   = (PFSetupTermDefaultQueueCallback)   GetProcAddress(g_hSetupLibrary, c_szSetupTermDefaultQueueCallback );
    pfSetupGetLineText                = (PFSetupGetLineText)                GetProcAddress(g_hSetupLibrary, c_szSetupGetLineText );
    pfSetupFindFirstLine              = (PFSetupFindFirstLine)              GetProcAddress(g_hSetupLibrary, c_szSetupFindFirstLine );
    pfSetupFindNextLine               = (PFSetupFindNextLine)               GetProcAddress(g_hSetupLibrary, c_szSetupFindNextLine );
    pfSetupDecompressOrCopyFile       = (PFSetupDecompressOrCopyFile)       GetProcAddress(g_hSetupLibrary, c_szSetupDecompressOrCopyFile );

    if (pfSetupDefaultQueueCallback       == NULL
     || pfSetupInstallFromInfSection      == NULL
     || pfSetupInitDefaultQueueCallbackEx == NULL
     || pfSetupTermDefaultQueueCallback   == NULL
     || pfSetupGetLineText                == NULL
     || pfSetupFindFirstLine              == NULL
     || pfSetupFindNextLine               == NULL
     || pfSetupDecompressOrCopyFile       == NULL
     || pfSetupGetStringField             == NULL )
    {
        return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
    }

    fSetupLibLoaded = TRUE;
    WriteToLog("Setupapi.dll loaded successfully\n");
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\crctable.c ===
const unsigned long CrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };

void GenerateCrc32Table( void ) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\download.cpp ===
#include <windows.h>
#include "download.h"
#include "util.h"

#define BUFFERSIZE 4096
char g_szBuffer[BUFFERSIZE];

#define TIMEOUT_PERIOD   120


CDownloader::CDownloader()
{
   _pBnd   = NULL;
   _cRef   = 1;
   _pStm   = NULL;
   _hDL    = CreateEvent(NULL, TRUE, FALSE, NULL);
   _hFile  = INVALID_HANDLE_VALUE;
}


CDownloader::~CDownloader()
{
   if(_hDL)
      CloseHandle(_hDL);
}


STDMETHODIMP CDownloader::QueryInterface(const GUID &riid,void **ppv )
{
   *ppv = NULL ;
    if( IsEqualGUID(riid,IID_IUnknown) ) 
    {
        *ppv = (IUnknown *) (IBindStatusCallback *)this;
    } 
    else if (IsEqualGUID(riid,IID_IBindStatusCallback) ) 
    {
        *ppv = (IBindStatusCallback *) this;
    } 
    else if (IsEqualGUID(riid, IID_IAuthenticate))
    {
        *ppv = (IAuthenticate *) this;
    }
    else if (IsEqualGUID(riid,IID_IHttpNegotiate)) 
    {
        *ppv = (IHttpNegotiate*) this;
    } 


    if (*ppv)
    {
        // increment our reference count before we hand out our interface
        ((LPUNKNOWN)*ppv)->AddRef();
        return(NOERROR);
    }

    return( E_NOINTERFACE );
}


STDMETHODIMP_(ULONG) CDownloader::AddRef()
{
   return(++_cRef);
}


STDMETHODIMP_(ULONG) CDownloader::Release()
{
   if(!--_cRef)
   {
      delete this;
      return(0);
   }
   return( _cRef );
}


STDMETHODIMP CDownloader::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
   // clear BINDINFO but keep its size
   DWORD cbSize = pbindInfo->cbSize;
   ZeroMemory( pbindInfo, cbSize );
   pbindInfo->cbSize = cbSize;
   
   *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_RESYNCHRONIZE;
   pbindInfo->dwBindVerb = BINDVERB_GET;
   return(NOERROR);
}


STDMETHODIMP CDownloader::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *p)
{
   _pBnd = p;
   _pBnd->AddRef();
   return(NOERROR);
}


STDMETHODIMP CDownloader::GetPriority(LONG *pnPriority)
{
   return(E_NOTIMPL);
}

STDMETHODIMP CDownloader::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
   return NOERROR;
}

STDMETHODIMP CDownloader::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM *pstgmed)
{
   // bring in major changes here
   HRESULT hr = NOERROR;

   DWORD dwRead = 0;
   DWORD dwReadThisCall = 0;
   DWORD dwWritten = 0;
   
   if(!_pStm)
   {
      _pStm = pstgmed->pstm;
      _pStm->AddRef();
   }
 
   
   // should ignore WAIT_TIMEOUT while getting bytes from urlmon
   _fTimeoutValid = FALSE;

   do
   {
      hr = _pStm->Read(g_szBuffer, BUFFERSIZE, &dwRead);
      if( SUCCEEDED(hr) || ( (hr == E_PENDING) && (dwRead > 0) ) )
      {
         if(_hFile)
            if(!WriteFile(_hFile, g_szBuffer, dwRead, &dwWritten, NULL)) 
            {
               hr = E_FAIL;
               Abort();
            }
      }     
   }  while (hr == NOERROR);

   _uTickCount = 0;
   _fTimeoutValid = TRUE;            // should increment dwTickCount if WAIT_TIMEOUT occurs now
           
	return NOERROR;
}


STDMETHODIMP CDownloader::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
   return(E_NOTIMPL);
}


STDMETHODIMP CDownloader::OnLowResource(DWORD reserved)
{
   _pBnd->Abort();
   return(S_OK);
}

STDMETHODIMP CDownloader::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
   _fTimeoutValid = FALSE;
  
   if((hrError == E_ABORT) && _fTimeout)
   {
      // This is the timeout case
      _hDLResult = INET_E_CONNECTION_TIMEOUT;
   }
   else
   {
      // this is all other cases
      _hDLResult = hrError;
   }
  
   SetEvent(_hDL);
   return(NOERROR);
}

/* IAuthenticate::Authenticate
*/

STDMETHODIMP CDownloader::Authenticate(HWND *phwnd,
                          LPWSTR *pszUserName, LPWSTR *pszPassword)
{
    if (!phwnd || !pszUserName || !pszPassword)
        return E_POINTER;

    *pszUserName = NULL;
    *pszPassword = NULL;
    *phwnd = GetDesktopWindow() ;

    return S_OK;
}


HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
   HRESULT hr = CreateURLMoniker(0,url,ppmkr);
   return( hr );
}


HRESULT CDownloader::DoDownload(LPCSTR pszUrl, LPCSTR lpszFilename)
{
   HRESULT hr = NOERROR;
   BOOL fQuit = FALSE;
   DWORD dwRet;   
      

   if(!pszUrl) return E_INVALIDARG;
   
   WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];
   MultiByteToWideChar(CP_ACP, 0, pszUrl, -1,wszUrl, sizeof(wszUrl)/sizeof(wszUrl[0]));


   IMoniker *ptmpmkr;
   
   hr = GetAMoniker(wszUrl, &ptmpmkr );

   IBindCtx * pBindCtx = 0;

   if( SUCCEEDED(hr) )
   {
      if(SUCCEEDED(::CreateBindCtx(0,&pBindCtx)))
         hr = ::RegisterBindStatusCallback(pBindCtx, (IBindStatusCallback *) this, 0, 0) ;
   }
   
  _fTimeout = FALSE;
  _fTimeoutValid = TRUE;
  _uTickCount = 0;   
  

  if(lpszFilename)
  {
       // Create the file
       _hFile = CreateFile(lpszFilename, GENERIC_READ | GENERIC_WRITE, 0, NULL, 
                     CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);  
   
       if(_hFile == INVALID_HANDLE_VALUE)
          hr = E_FAIL;
  }
    
         
   if( SUCCEEDED(hr) )
      hr = ptmpmkr->BindToStorage(pBindCtx, 0, IID_IStream, (void**)&_pStm );

   // we need this here because it synchronus *FAIL* case, 
   // we Set the event in onstopbinding, but we skip the loop below so it
   // never gets reset.
   // If BindToStorage fails without even sending onstopbinding, we are resetting
   // an unsignalled event, which is OK.
   if(FAILED(hr))
      ResetEvent(_hDL);

   // here we wait for Bind to complete
   //Wait for download event or abort
   while(SUCCEEDED(hr) && !fQuit)
   {
      dwRet = MsgWaitForMultipleObjects(1, &_hDL, FALSE, 1000, QS_ALLINPUT);
      if(dwRet == WAIT_OBJECT_0)
      {
         // Download is finished
         hr = _hDLResult;
         ResetEvent(_hDL);
         break;
      }      
      else if(dwRet == WAIT_TIMEOUT)  // our wait has expired
      {
         if(_fTimeoutValid)
            _uTickCount++;

          // if our tick count is past threshold, abort the download
          // BUGBUG: What about synch. case? We can't time out
          if(_uTickCount >= TIMEOUT_PERIOD)
          {
             _fTimeout = TRUE;
             Abort();
          }
      }  
      else
      {
         MSG msg;
         // read all of the messages in this next loop 
         // removing each message as we read it 
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         { 
             // if it's a quit message we're out of here 
            if (msg.message == WM_QUIT)
               fQuit = TRUE; 
            else
            {
               // otherwise dispatch it 
              DispatchMessage(&msg); 
            } // end of PeekMessage while loop 
         }
      }
   }
   
   // clean up all our stuff
   if(_hFile != INVALID_HANDLE_VALUE)
      CloseHandle(_hFile);

   _hFile = INVALID_HANDLE_VALUE;

   if(_pBnd)
   {
      _pBnd->Release();
      _pBnd = 0;
   }

   
   if(_pStm)
   {
      _pStm->Release();
      _pStm = 0;
   }   

   return hr;
}



HRESULT CDownloader::Abort()
{
   if(_pBnd) 
   {
      _pBnd->Abort();
   }

   return NOERROR;
}

STDMETHODIMP CDownloader::BeginningTransaction(LPCWSTR  szURL,  LPCWSTR  szHeaders, DWORD  dwReserved,
                                        LPWSTR * pszAdditionalHeaders)
{
    return S_OK;
}



STDMETHODIMP CDownloader:: OnResponse(DWORD  dwResponseCode, LPCWSTR  szResponseHeaders, LPCWSTR  szRequestHeaders, 
                                    LPWSTR * pszAdditionalResquestHeaders)
{
    WriteToLog("\nResponse Header\n\n");
    char sz[1024];
    WideCharToMultiByte(CP_ACP, 0, szResponseHeaders, -1, sz, sizeof(sz), NULL, NULL);
    WriteToLog(sz);
    return S_OK;
}


CSiteMgr::CSiteMgr()
{
    m_pSites = NULL;
    m_pCurrentSite = NULL;
}


CSiteMgr::~CSiteMgr()
{
    while(m_pSites)
    {
        SITEINFO* pTemp = m_pSites;
        m_pSites = m_pSites->pNextSite;
        ResizeBuffer(pTemp->lpszUrl, 0, 0);        
        ResizeBuffer(pTemp->lpszSiteName, 0, 0);
        ResizeBuffer(pTemp, 0, 0);       
    }
}


BOOL CSiteMgr::GetNextSite(LPTSTR* lpszUrl, LPTSTR* lpszName)
{
    if(!m_pSites)
        return FALSE;

    if(!m_pCurrentSite)
    {
        m_pCurrentSite = m_pSites;
    }

    *lpszUrl = m_pCurrentSite->lpszUrl;
    *lpszName = m_pCurrentSite->lpszSiteName;
    m_pCurrentSite = m_pCurrentSite->pNextSite;

    return TRUE;
}

HRESULT CSiteMgr::Initialize(LPCTSTR lpszUrl)
{
    CDownloader cdwn;
    TCHAR szFileName[MAX_PATH], szTempPath[MAX_PATH];

    if(!GetTempPath(sizeof(szTempPath), szTempPath))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    GetLanguageString(m_szLang);

    LPTSTR lpszDatUrl = (LPTSTR)ResizeBuffer(NULL, lstrlen(lpszUrl) + 3 + sizeof("PatchSites.dat"), FALSE);
    wsprintf(lpszDatUrl, "%s/PatchSites.dat", lpszUrl);

    CombinePaths(szTempPath, "PatchSites.dat", szFileName);

    WriteToLog("Downloading %1\n", lpszDatUrl);
    HRESULT hr = cdwn.DoDownload(lpszDatUrl, szFileName);

    if(FAILED(hr))
    {
        WriteToLog("Downloading %1 failed with error code:%2!lx!\n", lpszDatUrl, hr);
        DeleteFile(szFileName);
        ResizeBuffer(lpszDatUrl, 0, 0);
        return hr;
    }

    BOOL flag = TRUE;

    hr = ParseSitesFile(szFileName);
    if(hr == E_UNEXPECTED && !m_pSites && flag)
    {
        flag = FALSE;
        lstrcpy(m_szLang, "EN");
        hr = ParseSitesFile(szFileName);
    }

    DeleteFile(szFileName);
    ResizeBuffer(lpszDatUrl, 0, 0);
    return hr;
}

HRESULT CSiteMgr::ParseSitesFile(LPTSTR pszPath)
{       
   DWORD dwSize;
   LPSTR pBuf, pCurrent, pEnd;


   HANDLE hfile = CreateFile(pszPath, GENERIC_READ, 0, NULL, 
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  

   if(hfile == INVALID_HANDLE_VALUE)
      return E_FAIL;

   
   dwSize = GetFileSize(hfile, NULL);
   pBuf = (LPSTR)ResizeBuffer(NULL, dwSize + 1, FALSE);

   if(!pBuf)
   {
      CloseHandle(hfile);
      return E_OUTOFMEMORY;
   }
   // Copy contents of file to our buffer
   
   ReadFile(hfile, pBuf, dwSize, &dwSize, NULL);
   
   pCurrent = pBuf;
   pEnd = pBuf + dwSize;
   *pEnd = 0;

   // One pass thru replacing \n or \r with \0
   while(pCurrent <= pEnd)
   {
      if(*pCurrent == '\r' || *pCurrent == '\n')
         *pCurrent = 0;
      pCurrent++;
   }

   pCurrent = pBuf;
   while(1)
   {
      while(pCurrent <= pEnd && *pCurrent == 0)
         pCurrent++;

      // we are now pointing at begginning of line or pCurrent > pBuf
      if(pCurrent > pEnd)
         break;

      ParseAndAllocateDownloadSite(pCurrent);      
      pCurrent += lstrlen(pCurrent);
   }

   ResizeBuffer(pBuf, 0, 0);
   CloseHandle(hfile);

   if(!m_pSites)
      return E_UNEXPECTED;
   else
      return NOERROR;
}


BOOL CSiteMgr::ParseAndAllocateDownloadSite(LPTSTR psz)
{
   char szUrl[1024];
   char szName[256];
   char szlang[256];
   char szregion[256];
   BOOL bQueryTrue = TRUE;

   GetStringField(psz, 0, szUrl, sizeof(szUrl)); 
   GetStringField(psz,1, szName, sizeof(szName));
   GetStringField(psz, 2, szlang, sizeof(szlang));
   GetStringField(psz, 3, szregion, sizeof(szregion));

   if(szUrl[0] == 0 || szName[0] == 0 || szlang[0] == 0 || szregion[0] == 0)
      return NULL;

   if(lstrcmpi(szlang, m_szLang))
   {
       return FALSE;
   }

   SITEINFO* pNewSite = (SITEINFO*) ResizeBuffer(NULL, sizeof(SITEINFO), FALSE);
   pNewSite->lpszSiteName = (LPTSTR) ResizeBuffer(NULL, lstrlen(szName) + 1, FALSE);
   lstrcpy(pNewSite->lpszSiteName, szName);

   pNewSite->lpszUrl = (LPTSTR) ResizeBuffer(NULL, lstrlen(szUrl) + 1, FALSE);
   lstrcpy(pNewSite->lpszUrl, szUrl);

   pNewSite->pNextSite = m_pSites;
   m_pSites = pNewSite;  

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\patchapi.h ===
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-1998.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC32
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0x80FF0003

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK *PPATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef BOOL (CALLBACK *PPATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be fixed up.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and "named" according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (Internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    );

BOOL
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    );

BOOL
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\resource.h ===
// Used by advpext.rc
//
#define IDS_INIT                        1
#define IDS_BINDS_CONN                  2
#define IDS_BINDS_FINDING               3
#define IDS_BINDS_DOWNLOADING           4
#define IDS_BINDS_ENDDOWNLOAD           5
#define IDS_BYTEINFO                    6
#define IDS_CLEANUP                     7
#define IDS_FILELIST                    8
#define IDS_RETRY                       9

#define IDD_PROGRESSDLG                 101
#define IDC_PROGRESSTEXT                1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\patchdownload.cpp ===
#include <windows.h>
#include <urlmon.h>
#include <wininet.h>
#include "resource.h"

#include "advpext.h"
#include "download.h"
#include "patchdownload.h"
#include "util.h"

extern "C"
{
#include "patchapi.h"
#include "redblack.h"
#include "crc32.h"
}

extern HINF g_hInf;
extern HINSTANCE g_hInstance;
extern HWND g_hProgressDlg;
extern BOOL g_fAbort;

HANDLE g_hDownloadProcess = NULL;




HRESULT WINAPI DownloadAndPatchFiles(DWORD dwFileCount, DOWNLOAD_FILEINFO* pFileInfo,  LPCSTR lpszUrl,  
								LPCSTR lpszPath, PATCH_DOWNLOAD_CALLBACK  pfnCallback, LPVOID lpvContext)
{
    HRESULT hr = S_OK;
    CSiteMgr csite;

    hr = LoadSetupAPIFuncs();
    if(FAILED(hr))
    {
        return hr;
    }


    SetProgressText(IDS_INIT);
    //Download the sites.dat file
    hr = csite.Initialize(lpszUrl);
    if(FAILED(hr))
    {
        return hr;
    }

    CPatchDownloader cpdwn(pFileInfo, dwFileCount, pfnCallback);
    return cpdwn.InternalDownloadAndPatchFiles(lpszPath, &csite, lpvContext);
}

HRESULT CPatchDownloader::InternalDownloadAndPatchFiles(LPCTSTR lpszPath, CSiteMgr* pSite, LPVOID lpvContext)
{

    HRESULT hr = S_OK;
    PATCH_THREAD_INFO PatchThreadInfo;
    HANDLE hThreadPatcher = NULL;
    ULONG DownloadClientId = 0;
    int nCount = 0;
    LPTSTR lpszUrl;
    BOOL fUseWin9xDirectory = FALSE;



    if(!GetTempPath(sizeof(m_lpszDownLoadDir), m_lpszDownLoadDir))
    {
        //Unable to get temp folder, Create a folder  in the path sent to us
        wsprintf(m_lpszDownLoadDir, "%s\\%s", lpszPath, "AdvExt");
    }

    //Since the binary is different for NT and 9x, because of binding, we cannot put the files
    //under same directory on server. So for 9x put it under a subdirectory and modify the
    //url accordingly. 

    HKEY hKey;
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);


    if(VER_PLATFORM_WIN32_NT != osvi.dwPlatformId && 
       ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Advanced INF Setup", 0, 
                                                KEY_ALL_ACCESS, &hKey))
    {
        DWORD dwSize = sizeof(DWORD);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, "Usewin9xDirectory", 0, 0, 
                                                (LPBYTE)&fUseWin9xDirectory, &dwSize))
        {
            RegDeleteValue(hKey, "Usewin9xDirectory");
        }

        RegCloseKey(hKey);
    }

    if (DownloadClientId == 0)
    {

        //  Need to generate a unique DownloadClientId for this machine, but
        //  it needs to be consistent (persistent) if same machine downloads
        //  twice, even across process destroy/restart.  First we check the
        //  registry to see if we have previously generated a unique Id for
        //  this machine, and use that if we find it.  Otherwise, we generate
        //  a unique DownloadClientId and store it in the registry so future
        //  instances will use the same value.
        //

        LONG  RegStatus;
        HKEY  hKey;
        DWORD dwHow;
        DWORD dwValueSize;
        DWORD dwValueType;
        DWORD dwValue;

        RegStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\Microsoft\\Advanced INF Setup\\AdvExt",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwHow
                        );

        if ( RegStatus == ERROR_SUCCESS ) 
        {

            dwValueSize = sizeof(dwValue);
            RegStatus = RegQueryValueEx(hKey, "DownloadClientId",  NULL, &dwValueType, (LPBYTE)&dwValue, &dwValueSize);

            dwValue &= 0xFFFFFFF0;

            if ((RegStatus == ERROR_SUCCESS) && (dwValueType == REG_DWORD) && (dwValue != 0))
            {
                DownloadClientId = dwValue;
            }
            else
            {

                DownloadClientId = GenerateUniqueClientId();
                dwValue = DownloadClientId;

                RegSetValueEx(hKey, "DownloadClientId", 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
            }

            RegCloseKey( hKey );
        }
        else
        {
            //  Failed to open/create registry key, so fall back to just
            //  creating a unique ID for this process instance.  At least
            //  it will show the same client id if the user hits "retry".
            //
            DownloadClientId = GenerateUniqueClientId();
        }
    }

    m_hSubAllocator = CreateSubAllocator(0x10000, 0x10000);
    if(!m_hSubAllocator)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        WriteToLog("Memory allocation failed. Can't do much. Exiting with hr=%1!lx!\n", hr);
        goto done;
    }


    //Set the parameters that needs to be passed on to the thread.
    if(!m_lpfnCallback)
    {
        m_lpfnCallback = PatchCallback;
        m_lpvContext = (LPVOID)lpszPath;
    }
    else
    {
        m_lpvContext = lpvContext;
    }

    PatchThreadInfo.hFileDownloadEvent = _hDL;
    PatchThreadInfo.FileListInfo.FileList = m_lpFileInfo;
    PatchThreadInfo.FileListInfo.FileCount = m_dwFileCount;
    PatchThreadInfo.FileListInfo.Callback = m_lpfnCallback;
    PatchThreadInfo.FileListInfo.CallbackContext = m_lpvContext;

    PatchThreadInfo.lpdwnProgressInfo = &m_DownloadInfo;
        
    m_DownloadInfo.dwFilesRemaining = m_dwFileCount;
    m_DownloadInfo.dwFilesToDownload = m_dwFileCount;
    m_DownloadInfo.dwBytesToDownload = 0;
    m_DownloadInfo.dwBytesRemaining = 0;

    //Create an event to signal patchthread is ready to process download request
    g_hDownloadProcess = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(!g_hDownloadProcess)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        WriteToLog("Create event failed with error code:%1!lx!\n", hr);
        goto done;
    }


    //Do till we have download files or we retry 3 times 
    while(nCount++ < 3 && m_DownloadInfo.dwFilesRemaining && !g_fAbort)
    {
        WriteToLog("\n%1!d! try:  Number of Files:%2!d!\n", nCount, m_DownloadInfo.dwFilesRemaining);
        _hDLResult = 0;

        ResetEvent(g_hDownloadProcess);
        hThreadPatcher = CreateThread(NULL, 0, PatchThread, &PatchThreadInfo, 0, &m_dwPatchThreadId);
        if(!hThreadPatcher)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }

        //Generate the request buffer that would be sent on POST
        hr = CreateRequestBuffer(DownloadClientId);
        if(FAILED(hr))
        {
            WriteToLog("\nCreateRequestBuffer failed with error code:%1!lx!\n", hr);
            goto done;
        } 
        
        //Get the url from where bytes needs to be downloaded.
        if(!pSite->GetNextSite(&lpszUrl, &m_lpszSiteName))
        {
            WriteToLog("GetNextSite returned false. No site info??");
            hr = E_UNEXPECTED;
            goto done;
        }

		TCHAR szURL[INTERNET_MAX_URL_LENGTH];

        if(fUseWin9xDirectory)
        {
			lstrcpy(szURL, lpszUrl);
            if(*(lpszUrl + lstrlen(lpszUrl) - 1) == '/')
            {
                lstrcat(szURL, "win9x");
            }
            else
            {
                lstrcat(szURL, "/win9x");
            }
            lpszUrl = szURL;
        }

        //Notify callback we are about to begin download
        ProtectedPatchDownloadCallback(m_lpfnCallback, PATCH_DOWNLOAD_BEGIN, (LPVOID)lpszUrl, m_lpvContext);
        
        hr = DoDownload(lpszUrl, NULL);
        WriteToLog("DownloadFile returned:%1!lx!\n\n", hr);
        SetProgressText(IDS_CLEANUP);

        //Ask the patch thread to quit once it finishes download.
        SetEvent(_hDL);

        //Wait till patch thread finishes its work
        while(1)
        {
            DWORD dw = MsgWaitForMultipleObjects(1, &hThreadPatcher, FALSE, 1000, QS_ALLINPUT);
            if(dw == WAIT_OBJECT_0)
            {
                break;
            }
                     
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                DispatchMessage(&msg); 
            }
        }

        CloseHandle(hThreadPatcher);
        hThreadPatcher = NULL;
        //Setup the downloadinfo structure, incase we need to re-download some files
        m_DownloadInfo.dwFilesToDownload = m_DownloadInfo.dwFilesRemaining;
        m_DownloadInfo.dwBytesToDownload = 0;
        m_DownloadInfo.dwBytesRemaining = 0;
        if(m_DownloadInfo.dwFilesToDownload)
        {
            SetProgressText(IDS_RETRY);
        }
        m_dwServerFileCount=0;
        ResetEvent(_hDL);
    }


done:

    if(g_hDownloadProcess)
    {
        CloseHandle(g_hDownloadProcess);
    }

    if(!hr && m_DownloadInfo.dwFilesToDownload)
    {
        hr = E_FAIL;
        WriteToLog("\nSome files could not be downloaded\n");
    }

    WriteToLog("DownloadAndPatchFiles returning:%1!lx!\n", hr);
    return hr;
}



HRESULT CPatchDownloader :: CreateRequestBuffer(DWORD dwDownloadClientID)
{
    LPTSTR lpRequestPointer, lpFileNamePortionOfRequest;
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwHeapSize  = 64*1024;

    if(!m_lpFileInfo)
    {
        return E_INVALIDARG;
    }

    m_lpszRequestBuffer = (LPTSTR)ResizeBuffer(NULL, dwHeapSize, FALSE);
    if(!m_lpszRequestBuffer)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }
 

    lpRequestPointer = m_lpszRequestBuffer;

    lpRequestPointer += wsprintf(lpRequestPointer, "SessionId:%u\n", dwDownloadClientID);
    lpRequestPointer += wsprintf(lpRequestPointer, "FileList:%d\n",  m_DownloadInfo.dwFilesToDownload);

    WriteToLog("Download ClientID:%1!lx!  Number of Files:%2!d!\n", dwDownloadClientID, m_DownloadInfo.dwFilesToDownload);

    lpFileNamePortionOfRequest = lpRequestPointer;

    for(i=0; i < m_dwFileCount; i++) 
    {
        if ((DWORD)( lpRequestPointer - m_lpszRequestBuffer ) > (DWORD)( dwHeapSize - (DWORD)MAX_PATH )) 
        {
            dwHeapSize = dwHeapSize * 2;
            m_lpszRequestBuffer =  (LPTSTR)ResizeBuffer(m_lpszRequestBuffer, dwHeapSize, FALSE);
            if(!m_lpszRequestBuffer)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }
        }

        if(m_lpFileInfo[i].dwFlags != PATCHFLAG_DOWNLOAD_NEEDED)
        {
            //Probably already downloaded
            continue;
        }

        if ((m_lpFileInfo[i].lpszExistingFilePatchSignature == NULL ) ||
            (*m_lpFileInfo[i].lpszExistingFilePatchSignature == 0 )) 
        {
            //  No file to patch from, request whole file.

            lpRequestPointer += wsprintf(lpRequestPointer, "%s\n", m_lpFileInfo[i].lpszFileNameToDownload);
        }
        else 
        {
            lpRequestPointer += wsprintf(lpRequestPointer, "%s,%s\n", m_lpFileInfo[i].lpszFileNameToDownload, 
                                            m_lpFileInfo[i].lpszExistingFilePatchSignature);
        }

    }

    //  Now terminate list with "empty" entry.
    *lpRequestPointer++ = '\n';
    *lpRequestPointer++ = 0;

    m_dwRequestDataLength = lpRequestPointer - m_lpszRequestBuffer;

    //  Now lowercase all the filenames in the request (this offloads the case consistency work from 
    //  the server -- the server expects the request to be all lowercase).

    MyLowercase(lpFileNamePortionOfRequest);
    WriteToLog("RequestBuffer: Size=%1!d!\n\n", m_dwRequestDataLength);
    WriteToLog("%1", m_lpszRequestBuffer);

done:
    if(FAILED(hr))
    {
        ResizeBuffer(m_lpszRequestBuffer, 0, 0);
    }

    WriteToLog("\nCreateRequestBuffer returning %1!lx!\n", hr);
    return hr;
}


CPatchDownloader::CPatchDownloader(DOWNLOAD_FILEINFO* pdwn, DWORD dwFileCount, PATCH_DOWNLOAD_CALLBACK lpfn)
{
    m_lpFileInfo = pdwn;
    m_dwFileCount = dwFileCount;
    m_lpfnCallback = lpfn;
    m_hCurrentFileHandle = NULL;
    m_dwCurrentFileIndex = 0;
    m_lpFileList = NULL;
    m_dwServerFileCount = 0;
}

CPatchDownloader::~CPatchDownloader()
{
    DestroySubAllocator(m_hSubAllocator);    
}




STDMETHODIMP CPatchDownloader::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
   *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_RESYNCHRONIZE | BINDF_NOWRITECACHE;
   pbindInfo->cbSize = sizeof(BINDINFO);
   
   memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
   pbindInfo->stgmedData.tymed = TYMED_HGLOBAL;
   pbindInfo->stgmedData.hGlobal = m_lpszRequestBuffer;
   pbindInfo->grfBindInfoF = BINDINFOF_URLENCODESTGMEDDATA;
   pbindInfo->dwBindVerb = BINDVERB_POST;
   pbindInfo->szCustomVerb = NULL;
   pbindInfo->cbstgmedData = m_dwRequestDataLength;
   pbindInfo->szExtraInfo = NULL;
   return(NOERROR);
}


STDMETHODIMP CPatchDownloader::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
    int PatchStatusCode = -1;
    UINT uID;
    switch(ulStatusCode)
    {
    case BINDSTATUS_FINDINGRESOURCE:
        PatchStatusCode = PATCH_DOWNLOAD_FINDINGSITE;
        uID = IDS_BINDS_FINDING;
        break;

    case BINDSTATUS_CONNECTING:
        PatchStatusCode = PATCH_DOWNLOAD_CONNECTING;
        uID = IDS_BINDS_CONN;
        break;

    case BINDSTATUS_BEGINDOWNLOADDATA:
        PatchStatusCode = PATCH_DOWNLOAD_DOWNLOADINGDATA;
        uID = IDS_BINDS_DOWNLOADING;
        break;


    case BINDSTATUS_ENDDOWNLOADDATA:
        PatchStatusCode = PATCH_DOWNLOAD_ENDDOWNLOADINGDATA;
        uID = IDS_BINDS_ENDDOWNLOAD;
        break;
    }

    if(PatchStatusCode != -1 && pwzStatusText)
    {
        TCHAR szBuffer[MAX_PATH], szTemplate[MAX_PATH];
        LoadString(g_hInstance, uID, szTemplate, sizeof(szTemplate));
        wsprintf(szBuffer, szTemplate, m_lpszSiteName);
        ProtectedPatchDownloadCallback(m_lpfnCallback, (PATCH_DOWNLOAD_REASON)PatchStatusCode, szBuffer, m_lpvContext);
    }
   return NOERROR;
}


STDMETHODIMP CPatchDownloader::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM *pstgmed)
{
   HRESULT hr = NOERROR;
   TCHAR szBuffer[4096];
   DWORD dwRead = 0, dwWritten=0;
   do
   {
      hr = pstgmed->pstm->Read(szBuffer, 4096, &dwRead);
      if((SUCCEEDED(hr) || (hr == E_PENDING)) && dwRead > 0)
      {
          if(!ProcessDownloadChunk(szBuffer, dwRead))
          {
              WriteToLog("ProcessDownloadChunk returning FALSE. Aborting downloading\n");
              hr = E_ABORT;
          }
      }     
   }  while (hr == NOERROR && !g_fAbort);

   if(g_fAbort)
       Abort();           
   return hr;
}


BOOL CPatchDownloader :: ProcessDownloadChunk(LPTSTR lpBuffer, DWORD dwLength)    
{
    CHAR  TargetFile[ MAX_PATH ];
    ULONG Actual;
    ULONG WriteSize;
    BOOL  Success;


    if ( m_dwServerFileCount == 0 ) 
    {

        //
        //  Haven't processed headers yet.
        //
        //  We expect header to look like this:
        //
        //             "<head><title>"
        //             "Download Stream of Files"
        //             "</title></head>\n"
        //             "<body>\n"
        //             "FileList:%d\n"
        //             "filename,%d\n"
        //             "filename,%d\n"
        //             ...etc...
        //             "filename,%d\n"
        //             "</body>\n"
        //
        //  BUGBUG: if headers don't all fit in first chunk, we're screwed.
        //

        PCHAR EndOfHeader;
        PCHAR FileCountText;
        PCHAR FileNameText;
        PCHAR FileSizeText;
        ULONG FileSize;
        ULONG FileBytes;
        ULONG i;
        PCHAR p;

        EndOfHeader = ScanForSequence(lpBuffer, dwLength,
                          "</body>\n",
                          sizeof( "</body>\n" ) - 1   // not including terminator
                          );

        if( EndOfHeader == NULL ) {
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
            }

        EndOfHeader += sizeof( "</body>\n" ) - 1 ;

        p = ScanForSequence(lpBuffer, EndOfHeader - lpBuffer, "FileList:", sizeof( "FileList:" ) - 1);

        if ( p == NULL ) 
        {
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        p += sizeof( "FileList:" ) - 1;

        FileCountText = p;

        p = ScanForChar( p, '\n', EndOfHeader - p );

        *p++ = 0;

        m_dwServerFileCount = StrToInt( FileCountText );
        
        WriteToLog("Total Files to be downloaded:%1!d!\n", m_dwServerFileCount);

        if(m_dwServerFileCount == 0 ) 
        {
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        m_lpFileList = (LPFILE) SubAllocate(m_hSubAllocator, m_dwServerFileCount * sizeof(FILE));
        if(!m_lpFileList)
        {
            return FALSE;
        }

        m_dwCurrentFileIndex = 0;
        FileBytes = 0;

        for ( i = 0; i < m_dwServerFileCount; i++ ) 
        {

            FileNameText = p;
            p = ScanForChar( p, ',', EndOfHeader - p );

            if (( p == NULL ) || ( p == FileNameText )) 
            {
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;
            }

            *p++ = 0;

            FileSizeText = p;

            p = ScanForChar( p, '\n', EndOfHeader - p );

            if ( p == NULL ) 
            {
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;
            }

            *p++ = 0;

            FileSize = TextToUnsignedNum(FileSizeText);

            if ( FileSize == 0 ) 
            {
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;
            }

            FileBytes += FileSize;

            m_lpFileList[i].dwFileSize = FileSize;
            m_lpFileList[i].lpszFileName = MySubAllocStrDup(m_hSubAllocator, FileNameText);

            if (m_lpFileList[i].lpszFileName == NULL) 
            {
                return FALSE;
            }

            WriteToLog("File Name:%1 \t  File Size:%2!d!\n", m_lpFileList[i].lpszFileName, m_lpFileList[i].dwFileSize);
        }

        //  If we get to here, all the files in the header have been processed,
        //  so we can set the state variables and continue with parsing raw
        //  file data.

        m_DownloadInfo.dwBytesToDownload  = FileBytes;
        m_DownloadInfo.dwBytesRemaining = FileBytes;
        dwLength -= ( EndOfHeader - lpBuffer );
        lpBuffer = EndOfHeader;  

        WriteToLog("\nTotal %1!d! bytes(%2!d! Files) to be downloaded\n", FileBytes, m_dwServerFileCount);

    }

    //  Process raw file info.

    m_DownloadInfo.dwBytesRemaining -= dwLength;    
    if(!ProtectedPatchDownloadCallback(m_lpfnCallback, PATCH_DOWNLOAD_PROGRESS, (LPVOID)&m_DownloadInfo, m_lpvContext))
    {
        g_fAbort = TRUE;
        return FALSE;
    }


    while(dwLength > 0) 
    {

        if (m_hCurrentFileHandle == NULL  || m_hCurrentFileHandle == INVALID_HANDLE_VALUE) 
        {

            if (m_dwCurrentFileIndex >= m_dwServerFileCount) 
            {
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;    // more data than we expected                
            }

            //  Now open this file.
            CombinePaths(m_lpszDownLoadDir, m_lpFileList[m_dwCurrentFileIndex].lpszFileName, TargetFile );

            m_dwCurrentFileSize = m_lpFileList[m_dwCurrentFileIndex].dwFileSize;
            m_dwCurrFileSizeRemaining = m_dwCurrentFileSize;
            
            m_hCurrentFileHandle = CreateFile(TargetFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                                              CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

            if (m_hCurrentFileHandle == INVALID_HANDLE_VALUE ) 
            {
                return FALSE;                
            }            
        }

        WriteSize = min( dwLength, m_dwCurrFileSizeRemaining);

        Success = WriteFile(m_hCurrentFileHandle, lpBuffer, WriteSize, &Actual, NULL);

        if(!Success) 
        {
            return FALSE;            
        }

        if(Actual != WriteSize) 
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            WriteToLog("Error:Actual size not equal to write size for %1. Aborting\n", 
                        m_lpFileList[m_dwCurrentFileIndex].lpszFileName);
            return FALSE;            
        }

        m_dwCurrFileSizeRemaining -= WriteSize;

        if(m_dwCurrFileSizeRemaining == 0 ) 
        {

            CloseHandle(m_hCurrentFileHandle);
            m_hCurrentFileHandle = NULL;

            //  Pass this file off to the patch thread.
            LPTSTR lpszFileName =  (LPTSTR)ResizeBuffer(NULL, MAX_PATH, FALSE);
            CombinePaths(m_lpszDownLoadDir, m_lpFileList[m_dwCurrentFileIndex].lpszFileName, TargetFile );
            lstrcpy(lpszFileName, TargetFile);
            WaitForSingleObject(g_hDownloadProcess, 10000);
            PostThreadMessage(m_dwPatchThreadId, WM_FILEAVAILABLE, 0, (LPARAM)lpszFileName);
            m_dwCurrentFileIndex += 1;            
        }

        lpBuffer     += WriteSize;
        dwLength -= WriteSize;        
    }

    return TRUE;    
}


    
  
    
DWORD WINAPI PatchThread(IN LPVOID ThreadParam)
{
    PPATCH_THREAD_INFO        PatchThreadInfo = (PPATCH_THREAD_INFO) ThreadParam;
    PFILE_LIST_INFO           FileListInfo    = &PatchThreadInfo->FileListInfo;
    PDOWNLOAD_INFO            ProgressInfo    = PatchThreadInfo->lpdwnProgressInfo;
    
    NAME_TREE                 FileNameTree;
    PNAME_NODE                FileNameNode;
    PDOWNLOAD_FILEINFO        FileInfo;
    DWORD                     Status;
    BOOL                      bIsPatch;
    HANDLE                    hSubAllocator;
    ULONG                     i;
    BOOL                      fSuccess, fQuit = FALSE;
    MSG msg;

    //
    //  First thing we need to do is construct a btree of the filenames
    //  we expect to get in the queue so we can quickly find the corresponding
    //  FileList entry when given a filename by the downloader.  It will take
    //  the downloader a little while to get connected, so this CPU intensive
    //  task shouldn't slow anything down.
    //

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE); 
    hSubAllocator = CreateSubAllocator( 0x10000, 0x10000 );

    if ( hSubAllocator == NULL ) 
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    NameRbInitTree( &FileNameTree, hSubAllocator );
    TCHAR SourceFileName[MAX_PATH];

    for ( i = 0; i < FileListInfo->FileCount; i++ ) 
    {

        if(FileListInfo->FileList[ i ].dwFlags != PATCHFLAG_DOWNLOAD_NEEDED)
        {
            //Probably already downloaded and this is the second attempt
            continue;
        }

        lstrcpy( SourceFileName, FileListInfo->FileList[ i ].lpszFileNameToDownload);
        MyLowercase( SourceFileName );

        FileNameNode = NameRbInsert(&FileNameTree,  SourceFileName);

        if ( FileNameNode == NULL ) 
        {
            DestroySubAllocator( hSubAllocator );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (FileNameNode->Context != NULL ) 
        {

            //
            //  BUGBUG: Same filename in list twice.  Should never be the
            //          case since we check for duplicates before putting
            //          them in the queue.
            //
        }

        FileNameNode->Context = &FileListInfo->FileList[ i ];

        //  Now add another node in the tree based on the compressed filename.
        ConvertToCompressedFileName( SourceFileName );

        FileNameNode = NameRbInsert(&FileNameTree, SourceFileName);

        if ( FileNameNode == NULL ) 
        {
            DestroySubAllocator( hSubAllocator );
            return ERROR_NOT_ENOUGH_MEMORY;            
        }

        if ( FileNameNode->Context != NULL ) 
        {

            //  BUGBUG: Same filename in list twice.  This can happen if two
            //          different files collide on a compressed name (like
            //          foo.db1 and foo.db2 colliding on foo.db_).
            //
            //          We don't have a good solution for this right now.
            //

         }

        //Set the contect to the file info. When we get back the file from server, we can get the full
        //info about this
        FileNameNode->Context = &FileListInfo->FileList[ i ]; 

        //Make sure we are not asked to quit
        if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) && msg.message == WM_QUIT)
        {
            goto done;
        }
    }

    //
    //  Now wait for file downloads to be delivered to us.
    //

    SetEvent(g_hDownloadProcess);
    while (!g_fAbort && !fQuit) 
    {
        LPTSTR  lpszDownloadFileName, lpszSourceFileName;
        TCHAR szRealFileName[MAX_PATH];

        //
        //  We're going to wait here with a timeout so that if the download
        //  is stuck in InternetReadFile waiting for data, we can keep a
        //  heartbeat going to the progress dialog and also check for cancel.
        //

        Status = MsgWaitForMultipleObjects(1, &PatchThreadInfo->hFileDownloadEvent, FALSE, 1000, QS_ALLINPUT);
        if (Status == WAIT_TIMEOUT ) 
        {
            //Keep updating the callback 
            fSuccess = ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_PROGRESS, 
                                                    ProgressInfo, FileListInfo->CallbackContext);
            if (!fSuccess) 
            {
                g_fAbort = TRUE;
                break;
            }
            continue;
        }

        if(Status == WAIT_OBJECT_0)
        {
            fQuit = TRUE;
        }
            
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if(msg.message == WM_FILEAVAILABLE)
            {
                lpszDownloadFileName = (LPTSTR)msg.lParam;
            }
            else
            {
                continue;
            } 

            //  Ok, now we have a filename lpszDownloadFileName that was just downloaded to the 
            //  temp directory.The filename may be in one of the following 
            //  forms:
            //      foo.dll
            //      foo.dl_
            //      foo.dll._p
            //
            //  We have both "foo.dll" and "foo.dl_" in our name tree, but we
            //  don't have "foo.dll._p", so we look for that form of the name
            //  first and convert it to "foo.dll" before looking in name tree.

            fSuccess = TRUE;
            lpszSourceFileName = PathFindFileName(lpszDownloadFileName);
            ASSERT(lpszSourceFileName);

            lstrcpyn(szRealFileName, lpszDownloadFileName, lpszSourceFileName - lpszDownloadFileName + 1);

            MyLowercase(lpszSourceFileName);
        
            LPTSTR lpExt = PathFindExtension(lpszSourceFileName);
            bIsPatch = FALSE;

            if(lpExt && !lstrcmp(lpExt, "._p"))
            {
                bIsPatch = TRUE;
                *lpExt = 0;         // truncate trailing "._p" to leave base file name            
            }

            FileNameNode = NameRbFind( &FileNameTree, lpszSourceFileName);

            if ( bIsPatch ) 
            {
                *lpExt = '.';       // restore complete patch source file name
            }

            if (FileNameNode != NULL) 
            {

                FileInfo = (PDOWNLOAD_FILEINFO)FileNameNode->Context;
                lstrcat(szRealFileName, FileInfo->lpszFileNameToDownload);
                if ( bIsPatch ) 
                {
                    fSuccess = ApplyPatchToFile(
                                  lpszDownloadFileName,                     // patch file
                                  FileInfo->lpszExistingFileToPatchFrom,  // old file
                                  szRealFileName,                     // new file
                                  0
                                  );
                }
                else 
                {

                    FixTimeStampOnCompressedFile(lpszSourceFileName);
                    if(lstrcmpi(lpszDownloadFileName, szRealFileName))
                    {
                        fSuccess = MySetupDecompressOrCopyFile(
                                  lpszDownloadFileName,             // compressed or whole file
                                  szRealFileName                  // new file
                                  );
                    }
                 }

                if (fSuccess) 
                {
                    //Notify callback. If it thinks that the hash is incorrect, don't mark the file
                    //as downloaded, so that we may retry download of this file.

                    fSuccess = VerifyHash(szRealFileName);

                    if(fSuccess)
                    {
                        fSuccess = ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_FILE_COMPLETED,
                                  szRealFileName, FileListInfo->CallbackContext);
                        
                        if(fSuccess == FALSE)
                        {
                            //If callback returned false, we need to abort
                            WriteToLog("\tDownload complete callback returned false. Aborting\n");
                            ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_ABORT,
                                          NULL, FileListInfo->CallbackContext);
                            break;
                        }
                        else
                        {
                            FileInfo->dwFlags = 0;
                            //Notify callback that 1 file was successfully downloaded
                            WriteToLog("\tSuccesssfully downloaded %1\n", FileInfo->lpszFileNameToDownload);
                            ProgressInfo->dwFilesRemaining -= 1;
                            fSuccess = ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_PROGRESS,
                                          ProgressInfo, FileListInfo->CallbackContext);
                            if(!fSuccess)    
                            {
                                g_fAbort = TRUE;
                                return FALSE;
                            }

                        }
                    }
                    else 
                    {
                        //Mark it so that we resend the request. Remove patch signature so we get full files instead
                        // of patches.
                        WriteToLog("\tHash Incorrect. Need to Re-download %1\n", FileInfo->lpszFileNameToDownload);
                        FileInfo->dwFlags = PATCHFLAG_DOWNLOAD_NEEDED;
                        if(FileInfo->lpszExistingFilePatchSignature)
                        {
                            LocalFree(FileInfo->lpszExistingFilePatchSignature);
                            FileInfo->lpszExistingFilePatchSignature = NULL;
                        }
                    }




                }            
                else 
                {
                    //  Patch or decompress failed. notify callback it failed.

                    WriteToLog("\tPatch or decompression failed for %1\n", FileInfo->lpszFileNameToDownload);
                    fSuccess = ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_FILE_FAILED,
                                  FileInfo, FileListInfo->CallbackContext);
                    //If callback says to continue or retry download, we do so. If it needs to abort, it return 0
                    if (!fSuccess) 
                    {
                        ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_ABORT,
                                      NULL, FileListInfo->CallbackContext);
                        break;                    
                    }

                    if(fSuccess == PATCH_DOWNLOAD_FLAG_RETRY)
                    {
                        FileInfo->dwFlags = PATCHFLAG_DOWNLOAD_NEEDED;
                        if(FileInfo->lpszExistingFilePatchSignature)
                        {
                            LocalFree(FileInfo->lpszExistingFilePatchSignature);
                            FileInfo->lpszExistingFilePatchSignature = NULL;
                        }
                    }
                    else if(fSuccess == PATCH_DOWNLOAD_FLAG_CONTINUE)
                    {
                        FileInfo->dwFlags = 0;
                    }                    
                }                    
            
                //Delete the temp file. We might be having 2 temp files if this was a patch.
                if(lstrcmpi(lpszDownloadFileName, szRealFileName))
                {
                    DeleteFile(lpszDownloadFileName);
                }
                DeleteFile(szRealFileName); 
                ResizeBuffer(lpszDownloadFileName, 0, 0);
            }   
        }
    }

done:
    DestroySubAllocator( hSubAllocator );   // free entire btree
    return 0;
}


BOOL VerifyHash(LPTSTR lpszFile)
{

    TCHAR szHashFromInf[40];
    TCHAR szHashFromFile[40];

    //   Verify MD5 of new file against the MD5 from inf. If we cannot verify
    //   the MD5 for any reason, then leave the file alone (success).
    //   Only if computed MD5 does not match do we reject the file.


    LPTSTR lpFileName = PathFindFileName(lpszFile);

    if(GetHashidFromINF(lpFileName, szHashFromInf, sizeof(szHashFromInf)) && 
       GetFilePatchSignatureA(lpszFile, PATCH_OPTION_SIGNATURE_MD5, NULL, 0, 0, 0, 0, 
                                sizeof(szHashFromFile), szHashFromFile))
    {
        if (lstrcmpi(szHashFromFile, szHashFromInf)) 
        {
            WriteToLog("Hash Incorrect. File hash: %1 Inf hash: %2. Need to Re-download %3\n", 
                        szHashFromFile, szHashFromInf, lpFileName);
            return FALSE;
        }                
    }
    else
    {
         WriteToLog("Warning:Could not get hashid for %1 in inf file\n", lpFileName);
    }

    return TRUE;
}

BOOL ProtectedPatchDownloadCallback(PATCH_DOWNLOAD_CALLBACK  Callback, IN PATCH_DOWNLOAD_REASON CallbackReason, 
                                    IN PVOID CallbackData, IN PVOID CallBackContext)
{
    
    BOOL Success = TRUE;
    
    if (Callback != NULL )
    {
        __try 
        {            
            Success = Callback(CallbackReason, CallbackData, CallBackContext);            
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) 
        {
            SetLastError( GetExceptionCode());
            Success = FALSE;            
        }
    }

    return Success;    
}

BOOL WINAPI PatchCallback(PATCH_DOWNLOAD_REASON Reason, PVOID lpvInfo, PVOID lpvCallBackContext)
{

    switch (Reason) 
    {
        case PATCH_DOWNLOAD_ENDDOWNLOADINGDATA:
        case PATCH_DOWNLOAD_CONNECTING:   
        case PATCH_DOWNLOAD_FINDINGSITE:
        case PATCH_DOWNLOAD_DOWNLOADINGDATA:
            {
                LPTSTR lpsz = (LPTSTR)lpvInfo;
                lpsz[90] = NULL;
                SetProgressText(lpsz);
            }
            break;

        case PATCH_DOWNLOAD_PROGRESS:
            {
                char szBuffer[100], szText[MAX_PATH];
                PDOWNLOAD_INFO ProgressInfo = (PDOWNLOAD_INFO)lpvInfo;
                LoadString(g_hInstance, IDS_BYTEINFO, szBuffer, sizeof(szBuffer));
                DWORD dwBytesDownloaded = ProgressInfo->dwBytesToDownload - ProgressInfo->dwBytesRemaining;
                wsprintf(szText, szBuffer, dwBytesDownloaded, ProgressInfo->dwBytesToDownload);
                if(g_hProgressDlg && ProgressInfo->dwBytesToDownload)
                {
                    SetProgressText(szText);
                }
                break;
            }


        case PATCH_DOWNLOAD_FILE_COMPLETED:     // AdditionalInfo is Source file downloaded
            {
                TCHAR szDstFile[MAX_PATH];
                LPTSTR lpFileName = PathFindFileName((LPCTSTR)lpvInfo);
                CombinePaths((LPTSTR)lpvCallBackContext, lpFileName, szDstFile);
                CopyFile((LPCTSTR)lpvInfo, szDstFile, FALSE);
            }

            break;
        case PATCH_DOWNLOAD_FILE_FAILED:
            //ask it to retry
            return PATCH_DOWNLOAD_FLAG_RETRY;
        default:
            break;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\redblack.h ===
/*
    redblack.h

    Prototypes and node structure definition for red-black binary trees.
    See redblack.c for details and implementation.

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.h for debug symbol lookups.
    8/98, modified this version of redblack.h for generic name table.

*/

#ifndef _REDBLACK_H_
#define _REDBLACK_H_

#pragma warning( disable: 4200 )    // zero-sized array in struct/union

typedef struct _NAME_NODE NAME_NODE, *PNAME_NODE;
typedef struct _NAME_TREE NAME_TREE, *PNAME_TREE;

struct _NAME_NODE {
    PNAME_NODE Left;
    PNAME_NODE Right;
    ULONG      Hash;
    union {
      ULONG    NameLengthAndColorBit;
      struct {
        ULONG  NameLength:31;
        ULONG  Red:1;
        };
      };
    PVOID Context;
    CHAR  Name[ 0 ];
    };

struct _NAME_TREE {
    PNAME_NODE Root;
    HANDLE SubAllocator;
    };


#define RBNIL ((PNAME_NODE)&NameRbEmptyNode)

extern const NAME_NODE NameRbEmptyNode;


//
//  Although "Red" can be stored in its own 1-byte or 4-byte field, keeping the
//  nodes smaller by encoding "Red" as a one-bit field with another value
//  provides better performance (more nodes tend to stay in the cache).  To
//  provide flexibility in storage of the RED property, all references to RED
//  and BLACK are made through the following macros which can be changed as
//  necessary:
//

#define IS_RED( Node )            (   (Node)->Red )
#define IS_BLACK( Node )          ( ! (Node)->Red )
#define MARK_RED( Node )          (   (Node)->Red = 1 )
#define MARK_BLACK( Node )        (   (Node)->Red = 0 )

//
//  The maximum tree depth is 2*Lg(N).  Since we could never have more than
//  2^X nodes with X-bit pointers, we can safely say the absolute maximum
//  depth will be 2*Lg(2^X) which is 2*X.  The size of a pointer in bits is
//  its size in bytes times 8 bits, so 2*(sizeof(p)*8) is our maximum depth.
//  So for 32-bit pointers, our maximum depth is 64.
//
//  If you know the maximum possible number of nodes in advance (like the size
//  of the address space divided by the size of a node), you can tweak this
//  value a bit smaller to 2*Lg(N).  Note that it's important for this max
//  depth be evalutated to a constant value at compile time.
//
//  For this implementation, we'll assume the maximum number of nodes is
//  1 million, so the max depth is 40 (2*Lg(2^20)).  Note that no runtime
//  checks are made to ensure we don't exceed this number.
//

#define MAX_DEPTH 40


//
//  The following prototypes are the red-black tree interface.
//

VOID
NameRbInitTree(
    IN OUT PNAME_TREE Tree,
    IN HANDLE SubAllocator
    );

PNAME_NODE
NameRbInsert(
    IN OUT PNAME_TREE Tree,
    IN     LPCSTR Name
    );

PNAME_NODE
NameRbFind(
    IN PNAME_TREE Tree,
    IN LPCSTR Name
    );

#endif // _REDBLACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\redblack.c ===
#include <windows.h>
#include "redblack.h"
/*
    redblack.c

    Implementation of red-black binary tree insertion, deletion, and search.
    This algorithm efficiently guarantees that the tree depth will never exceed
    2*Lg(N), so a one million node tree would have a worst case depth of 40.
    This insertion implementation is non-recursive and very efficient (the
    average insertion speed is less than twice the average search speed).

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.c for debug symbol lookups.
    8/98, modified this version of redblack.h for generic name table.

*/

//
//  Rather than storing NULL links as NULL, we point NULL links to a special
//  "Empty" node which is always black and its children links point to itself.
//  We do this to simplify the color testing for children and grandchildren
//  such that any link can be dereferenced and even double-dereferenced without
//  explicitly checking for NULL.  The empty node must be colored black.
//

const NAME_NODE NameRbEmptyNode = { RBNIL, RBNIL };

extern PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size);

ULONG
__fastcall
NameRbHash(
    IN LPCSTR Name,
    IN ULONG  Length
    )
    {
    ULONG Hash = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ *Name++;
        }

    return Hash;
    }


VOID
NameRbInitTree(
    IN OUT PNAME_TREE Tree,
    IN HANDLE SubAllocator
    )
    {
    Tree->Root = RBNIL;
    Tree->SubAllocator = SubAllocator;
    }


PNAME_NODE
NameRbFind(
    IN PNAME_TREE Tree,
    IN LPCSTR Name
    )
    {
    PNAME_NODE Node;
    ULONG      NameLength;
    ULONG      Hash;
    int        Compare;

    NameLength = strlen( Name );

    Hash = NameRbHash( Name, NameLength );

    Node = Tree->Root;

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            Node = Node->Right;
            }
        else {

            //
            //  Hashes equal, switch to strlen
            //

            do  {

                if ( NameLength < Node->NameLength ) {
                    Node = Node->Left;
                    }
                else if ( NameLength > Node->NameLength ) {
                    Node = Node->Right;
                    }
                else {

                    //
                    //  Lengths equal, switch to memcmp
                    //

                    do  {

                        Compare = memcmp( Name, Node->Name, NameLength );

                        if ( Compare == 0 ) {
                            return Node;
                            }
                        else if ( Compare < 0 ) {
                            Node = Node->Left;
                            }
                        else {
                            Node = Node->Right;
                            }
                        }

                    while ( Node != RBNIL );

                    }
                }

            while ( Node != RBNIL );

            }
        }

    return NULL;
    }


PNAME_NODE
NameRbInsert(
    IN OUT PNAME_TREE Tree,
    IN     LPCSTR Name
    )
    {
    PNAME_NODE * Stack[ MAX_DEPTH ];
    PNAME_NODE **StackPointer = Stack;
    PNAME_NODE * Link;
    PNAME_NODE   Node;
    PNAME_NODE   Sibling;
    PNAME_NODE   Parent;
    PNAME_NODE   Child;
    PNAME_NODE   NewNode;
    ULONG        NameLength;
    ULONG        Hash;
    int          Compare;

    NameLength = strlen( Name );

    Hash = NameRbHash( Name, NameLength );

    *StackPointer++ = &Tree->Root;

    Node = Tree->Root;

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
            }
        else {

            //
            //  Hashes equal, switch to strlen
            //

            do  {

                if ( NameLength < Node->NameLength ) {
                    *StackPointer++ = &Node->Left;
                    Node = Node->Left;
                    }
                else if ( NameLength > Node->NameLength ) {
                    *StackPointer++ = &Node->Right;
                    Node = Node->Right;
                    }
                else {

                    //
                    //  Lengths equal, switch to memcmp
                    //

                    do  {

                        Compare = memcmp( Name, Node->Name, NameLength );

                        if ( Compare == 0 ) {
                            return Node;
                            }
                        else if ( Compare < 0 ) {
                            *StackPointer++ = &Node->Left;
                            Node = Node->Left;
                            }
                        else {
                            *StackPointer++ = &Node->Right;
                            Node = Node->Right;
                            }
                        }

                    while ( Node != RBNIL );

                    }
                }

            while ( Node != RBNIL );

            }
        }


    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.  Note that we're not allocating space for a terminator
    //  for the name data since we store the length of the name in the node.
    //

    NewNode = SubAllocate( Tree->SubAllocator, ( sizeof( NAME_NODE ) + NameLength ));

    if ( NewNode == NULL ) {
        return NULL;
        }

    NewNode->Left  = RBNIL;
    NewNode->Right = RBNIL;
    NewNode->Hash  = Hash;
    NewNode->NameLengthAndColorBit = NameLength | 0x80000000;   // MARK_RED
    memcpy( NewNode->Name, Name, NameLength );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = RBNIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return NewNode;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );
    return NewNode;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\patchdownload.h ===
#ifndef _PATCHDOWNLOAD
#define _PATCHDOWNLOAD

#include "advpext.h"
#include "download.h"

#define WM_FILEAVAILABLE            WM_USER + 1
#define PATCHFLAG_DOWNLOAD_NEEDED   0x00000001



typedef struct {
    WORD        wOSVer;
    WORD        wQuietMode;
    BOOL        bUpdHlpDlls;
    HINSTANCE   hSetupLibrary;
    BOOL        fOSSupportsINFInstalls;
    LPSTR       lpszTitle;
    HWND        hWnd;
    DWORD       dwSetupEngine;
    BOOL        bCompressed;
    char        szBrowsePath[MAX_PATH];
    HINF        hInf;
    BOOL		bHiveLoaded;
    CHAR		szRegHiveKey[MAX_PATH];
} ADVCONTEXT, *PADVCONTEXT;


HRESULT ProcessFileSection(ADVCONTEXT ctx, LPCSTR lpszSrcDir);


typedef struct _FILE_LIST_INFO 
{
    PDOWNLOAD_FILEINFO          FileList;              //original file list
    DWORD                       FileCount;
    PATCH_DOWNLOAD_CALLBACK     Callback;
    PVOID                       CallbackContext;
}FILE_LIST_INFO, *PFILE_LIST_INFO;


typedef struct _PATCH_THREAD_INFO 
{
    //PATCH_QUEUE              PatchQueue;
    FILE_LIST_INFO           FileListInfo;          //original file list
    DOWNLOAD_INFO*           lpdwnProgressInfo;
    HANDLE                   hFileDownloadEvent;
}PATCH_THREAD_INFO, *PPATCH_THREAD_INFO;


typedef struct _FILE
{
    LPTSTR lpszFileName;
    DWORD  dwFileSize;
} FILE, *LPFILE;


class CPatchDownloader : public CDownloader
{
    DOWNLOAD_FILEINFO*  m_lpFileInfo;
    PATCH_DOWNLOAD_CALLBACK m_lpfnCallback;
    LPTSTR  m_lpszRequestBuffer;
    LPTSTR  m_lpszSiteName;
    TCHAR m_lpszDownLoadDir[MAX_PATH];

    DWORD m_dwFileCount;
    DWORD m_dwServerFileCount;
    DWORD m_dwRequestDataLength;
    DWORD m_dwCurrentFileSize;
    DWORD m_dwCurrFileSizeRemaining;
    DWORD m_dwCurrentFileIndex;
    DWORD m_dwPatchThreadId;

    HANDLE m_hCurrentFileHandle;
    HANDLE m_hSubAllocator;
    
    LPFILE m_lpFileList;
    LPVOID m_lpvContext;
    DOWNLOAD_INFO m_DownloadInfo;


    HRESULT CreateRequestBuffer(DWORD);
    BOOL ProcessDownloadChunk(LPTSTR lpBuffer, DWORD dwLength);

public:
    CPatchDownloader(DOWNLOAD_FILEINFO* pdwn, DWORD dwFileCount, PATCH_DOWNLOAD_CALLBACK lpfn);
    ~CPatchDownloader();
          
    STDMETHOD(GetBindInfo)(/* [out] */ DWORD *grfBINDINFOF,  /* [unique][out][in] */ BINDINFO *pbindinfo);
    
    STDMETHOD(OnProgress)(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    STDMETHOD(OnDataAvailable)(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);



    HRESULT InternalDownloadAndPatchFiles(LPCTSTR lpszPath, CSiteMgr*, LPVOID lpvContext);
};

DWORD WINAPI PatchThread(IN LPVOID ThreadParam);
BOOL ProtectedPatchDownloadCallback(PATCH_DOWNLOAD_CALLBACK  Callback, IN PATCH_DOWNLOAD_REASON    CallbackReason, 
                                    IN PVOID CallbackData, IN PVOID CallbackContext);

void AddToFileList(LPCSTR lpszSrc, LPCSTR lpszTarget);
UINT WINAPI MyFileQueueCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );
void FreeFileList(PDOWNLOAD_FILEINFO pFileList);
HRESULT CreateRequestBuffer(DOWNLOAD_FILEINFO*pFileInfo, DWORD dwFileCount, DWORD dwDownloadClientID, 
                            LPTSTR* lpRequestBuffer, LPDWORD);


BOOL IsDownloadedNeeded(LPCTSTR lp, LPCTSTR lpszFileName);
BOOL CALLBACK ProgressDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
BOOL SetProgressText(LPCTSTR lpszText);
BOOL SetProgressText(UINT uID);
BOOL VerifyHash(LPTSTR lpszFile);
HRESULT LoadSetupAPIFuncs();
HRESULT ApplyPatchesToLocalFiles(DOWNLOAD_FILEINFO* pFileList, DWORD dwFileCount);


static const TCHAR c_szSetupDefaultQueueCallback[]       = "SetupDefaultQueueCallbackA";
static const TCHAR c_szSetupInstallFromInfSection[]      = "SetupInstallFromInfSectionA";
static const TCHAR c_szSetupInitDefaultQueueCallbackEx[] = "SetupInitDefaultQueueCallbackEx";
static const TCHAR c_szSetupTermDefaultQueueCallback[]   = "SetupTermDefaultQueueCallback";
static const TCHAR c_szSetupGetLineText[]                = "SetupGetLineTextA";
static const TCHAR c_szSetupFindFirstLine[]              = "SetupFindFirstLineA";
static const TCHAR c_szSetupFindNextLine[]               = "SetupFindNextLine";
static const TCHAR c_szSetupGetStringField[]             = "SetupGetStringFieldA";
static const TCHAR c_szSetupDecompressOrCopyFile[]       = "SetupDecompressOrCopyFileA";

typedef UINT  (WINAPI *PFSetupDefaultQueueCallback)( PVOID, UINT, UINT_PTR, UINT_PTR );
typedef BOOL  (WINAPI *PFSetupInstallFromInfSection)( HWND, HINF, PCSTR, UINT, HKEY, PCSTR, UINT, PSP_FILE_CALLBACK_A, PVOID, HDEVINFO, PSP_DEVINFO_DATA );
typedef PVOID (WINAPI *PFSetupInitDefaultQueueCallbackEx)( HWND,HWND,UINT,DWORD,PVOID );
typedef VOID  (WINAPI *PFSetupTermDefaultQueueCallback)( PVOID );
typedef BOOL  (WINAPI *PFSetupFindFirstLine)( HINF, PCSTR, PCSTR, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupGetLineText)( PINFCONTEXT, HINF, PCSTR, PCSTR, PSTR, DWORD, PDWORD );
typedef BOOL  (WINAPI *PFSetupFindNextLine)( PINFCONTEXT, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupGetStringField)(PINFCONTEXT, DWORD, PSTR, DWORD, PDWORD);  
typedef DWORD (WINAPI *PFSetupDecompressOrCopyFile)(PCTSTR, PCTSTR, PUINT);  


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\download.h ===
#include <wininet.h>
#include <urlmon.h>

#ifndef _DOWNLOAD
#define _DOWNLOAD

class CDownloader
        : public IBindStatusCallback,
          public IAuthenticate,
          public IHttpNegotiate
   
{
   public:
      CDownloader();
      ~CDownloader();
    
      HRESULT DoDownload(LPCSTR pszUrl, LPCSTR szFilename);
      HRESULT Abort();

      
      STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
      STDMETHOD_(ULONG, AddRef)();
      STDMETHOD_(ULONG, Release)();

      STDMETHOD(OnStartBinding)(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

      STDMETHOD(GetPriority)(
            /* [out] */ LONG *pnPriority);

      STDMETHOD(OnLowResource)(
            /* [in] */ DWORD reserved);

      STDMETHOD(OnProgress)(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

      STDMETHOD(OnStopBinding)(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

      STDMETHOD(GetBindInfo)(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

      STDMETHOD(OnDataAvailable)(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

      STDMETHOD(OnObjectAvailable)(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);

              // IAuthenticate methods
      STDMETHOD(Authenticate)(HWND *phwnd,
                              LPWSTR *pszUserName, LPWSTR *pszPassword);

      //IHttpNegotiate methods
              
      STDMETHODIMP BeginningTransaction(LPCWSTR  szURL,  LPCWSTR  szHeaders, DWORD  dwReserved,
                                        LPWSTR * pszAdditionalHeaders);

        
      STDMETHODIMP OnResponse(DWORD  dwResponseCode, LPCWSTR  szResponseHeaders, LPCWSTR  szRequestHeaders, 
                                    LPWSTR * pszAdditionalResquestHeaders);


   protected:
      IBinding            *_pBnd;
      DWORD                _cRef;
      IStream             *_pStm;
      BOOL                 _fTimeout;
      BOOL                 _fTimeoutValid;
      HANDLE               _hFile;
      HANDLE               _hDL;
      HRESULT              _hDLResult;
      UINT                 _uTickCount;
};


HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr );

typedef struct _SITEINFO SITEINFO;
struct _SITEINFO
{
    LPTSTR lpszUrl;
    LPTSTR lpszSiteName;
    SITEINFO* pNextSite;
};

class CSiteMgr
{

    SITEINFO* m_pSites;
    SITEINFO* m_pCurrentSite;
    char m_szLang[10];
    HRESULT ParseSitesFile(LPTSTR);
    BOOL ParseAndAllocateDownloadSite(LPTSTR);

public:
    CSiteMgr();
    ~CSiteMgr();
    BOOL GetNextSite(LPTSTR* lpszUrl, LPTSTR* lpszName);
    HRESULT Initialize(LPCTSTR);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\util.h ===
#ifndef __UTIL
#define __UTIL

#include <windows.h>


#define LOGFILENAME     "AdvpackExt.log"
#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#define MINIMUM_VM_ALLOCATION 0x10000
#define SUBALLOCATOR_ALIGNMENT 8

#define StrToInt TextToUnsignedNum

#ifndef ASSERT
    #ifdef DEBUG
        #define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))
    #else
        #define ASSERT( a )
    #endif
#endif

extern HANDLE g_hLogFile;

extern "C"
{
struct _SUBALLOCATOR 
{
    PVOID  VirtualListTerminator;
    PVOID *VirtualList;
    PCHAR  NextAvailable;
    PCHAR  LastAvailable;
    ULONG  GrowSize;
};

typedef struct _SUBALLOCATOR SUBALLOCATOR, *PSUBALLOCATOR;


PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size);
VOID DestroySubAllocator(IN HANDLE hAllocator);
HANDLE CreateSubAllocator(IN ULONG InitialCommitSize,  IN ULONG GrowthCommitSize);
}


HLOCAL ResizeBuffer(IN HLOCAL BufferHandle, IN DWORD Size,  IN BOOL Moveable);


VOID MyLowercase(IN OUT LPSTR String);
DWORD GenerateUniqueClientId();
BOOL MySetupDecompressOrCopyFile(IN LPCSTR SourceFile, IN LPCSTR TargetFile);
LPSTR CombinePaths(IN  LPCSTR ParentPath, IN  LPCSTR ChildPath, OUT LPSTR  TargetPath);
BOOL FixTimeStampOnCompressedFile(IN LPCSTR FileName);

BOOL MyMapViewOfFile(IN  LPCSTR  FileName, OUT ULONG  *FileSize, OUT HANDLE *FileHandle, OUT PVOID  *MapBase);
VOID MyUnmapViewOfFile(IN HANDLE FileHandle, IN PVOID  MapBase );
VOID __fastcall ConvertToCompressedFileName(IN OUT LPSTR FileName);
LPTSTR __fastcall MySubAllocStrDup(IN HANDLE SubAllocator, IN LPCSTR String);

BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize);
void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);
DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize);
BOOL GetHashidFromINF(LPCTSTR lpFileName, LPTSTR lpszHash, DWORD dwSize);


PCHAR ScanForSequence(IN PCHAR Buffer,  IN ULONG BufferLength,  IN PCHAR Sequence, IN ULONG SequenceLength);
LPSTR ScanForChar(IN LPSTR Buffer, IN CHAR  SearchFor, IN ULONG MaxLength);
ULONG __fastcall TextToUnsignedNum(IN LPCSTR Text);
LPTSTR PathFindFileName(LPCTSTR pPath);
LPTSTR PathFindExtension(LPCTSTR pszPath);
LPSTR StrDup(LPCSTR psz);
DWORD MyFileSize(PCSTR pszFile);
void GetLanguageString(LPTSTR lpszLang);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);


    
void InitLogFile();
void WriteToLog(char *pszFormatString, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\base.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module