 NtOfsUpdateRecord( IrpContext,
                           QuotaScb,
                           1,
                           &IndexRow,
                           &QuickIndexHint,
                           &MapHandle );

        ClearFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS );

    } finally {

        //
        //  Release the index map handle and scb.
        //

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        NtOfsReleaseMap( IrpContext, &MapHandle );
        NtfsReleaseScb( IrpContext, QuotaScb );
    }

    //
    //  If the quota tracking has been requested and the quotas need to be
    //  repaired then try to repair them now.
    //

    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED ) &&
        FlagOn( Vcb->QuotaFlags,
                QUOTA_FLAG_OUT_OF_DATE | QUOTA_FLAG_CORRUPT | QUOTA_FLAG_PENDING_DELETES )) {

        NtfsPostRepairQuotaIndex( IrpContext, Vcb );
    }

    return;
}


NTSTATUS
NtfsVerifyOwnerIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine iterates over the owner id index and verifies the pointer
    to the quota user data index.

Arguments:

    Vcb - Pointer to the volume control block whoes index is to be operated
          on.

Return Value:

    Returns a status indicating if the owner index was ok.

--*/

{
    INDEX_KEY IndexKey;
    INDEX_ROW QuotaRow;
    MAP_HANDLE MapHandle;
    PQUOTA_USER_DATA UserData;
    PINDEX_ROW OwnerRow;
    PVOID RowBuffer;
    NTSTATUS Status;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    ULONG Count;
    ULONG i;
    PSCB QuotaScb = Vcb->QuotaTableScb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;
    PINDEX_ROW IndexRow = NULL;
    PREAD_CONTEXT ReadContext = NULL;
    BOOLEAN IndexAcquired = FALSE;

    NtOfsInitializeMapHandle( &MapHandle );

    //
    //  Allocate a buffer lager enough for several rows.
    //

    RowBuffer = NtfsAllocatePool( PagedPool, PAGE_SIZE );

    try {

        //
        //  Allocate a bunch of index row entries.
        //

        Count = PAGE_SIZE / sizeof( SID );

        IndexRow = NtfsAllocatePool( PagedPool,
                                     Count * sizeof( INDEX_ROW ));

        //
        //  Iterate through the owner id entries.  Start with a zero sid.
        //

        RtlZeroMemory( IndexRow, sizeof( SID ));
        IndexKey.KeyLength = sizeof( SID );
        IndexKey.Key = IndexRow;

        Status = NtOfsReadRecords( IrpContext,
                                   OwnerIdScb,
                                   &ReadContext,
                                   &IndexKey,
                                   NtOfsMatchAll,
                                   NULL,
                                   &Count,
                                   IndexRow,
                                   PAGE_SIZE,
                                   RowBuffer );

        while (NT_SUCCESS( Status )) {

            //
            //  Acquire the VCB shared and check whether we should
            //  continue.
            //

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

            if (!NtfsIsVcbAvailable( Vcb )) {

                //
                //  The volume is going away, bail out.
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
            NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );
            IndexAcquired = TRUE;

            OwnerRow = IndexRow;

            for (i = 0; i < Count; i += 1, OwnerRow += 1) {

                IndexKey.KeyLength = OwnerRow->DataPart.DataLength;
                IndexKey.Key = OwnerRow->DataPart.Data;

                //
                //  Look up the Owner id in the quota index.
                //

                Status = NtOfsFindRecord( IrpContext,
                                          QuotaScb,
                                          &IndexKey,
                                          &QuotaRow,
                                          &MapHandle,
                                          NULL );


                ASSERT( NT_SUCCESS( Status ));

                if (!NT_SUCCESS( Status )) {

                    //
                    //  The quota entry is missing just delete this row;
                    //

                    NtOfsDeleteRecords( IrpContext,
                                        OwnerIdScb,
                                        1,
                                        &OwnerRow->KeyPart );

                    continue;
                }

                UserData = QuotaRow.DataPart.Data;

                ASSERT( (OwnerRow->KeyPart.KeyLength == QuotaRow.DataPart.DataLength - SIZEOF_QUOTA_USER_DATA) &&
                        RtlEqualMemory( OwnerRow->KeyPart.Key, &UserData->QuotaSid, OwnerRow->KeyPart.KeyLength ));

                if ((OwnerRow->KeyPart.KeyLength != QuotaRow.DataPart.DataLength - SIZEOF_QUOTA_USER_DATA) ||
                    !RtlEqualMemory( OwnerRow->KeyPart.Key,
                                     &UserData->QuotaSid,
                                     OwnerRow->KeyPart.KeyLength )) {

                    NtOfsReleaseMap( IrpContext, &MapHandle );

                    //
                    //  The Sids do not match delete both of these records.
                    //  This causes the user whatever their Sid is to get
                    //  the defaults.
                    //


                    NtOfsDeleteRecords( IrpContext,
                                        OwnerIdScb,
                                        1,
                                        &OwnerRow->KeyPart );

                    NtOfsDeleteRecords( IrpContext,
                                        QuotaScb,
                                        1,
                                        &IndexKey );

                    ReturnStatus = STATUS_QUOTA_LIST_INCONSISTENT;
                }

                NtOfsReleaseMap( IrpContext, &MapHandle );
            }

            //
            //  Release the indexes and commit what has been done so far.
            //

            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
            IndexAcquired = FALSE;

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            //
            //  Look up the next set of entries in the quota index.
            //

            Count = PAGE_SIZE / sizeof( SID );
            Status = NtOfsReadRecords( IrpContext,
                                       OwnerIdScb,
                                       &ReadContext,
                                       NULL,
                                       NtOfsMatchAll,
                                       NULL,
                                       &Count,
                                       IndexRow,
                                       PAGE_SIZE,
                                       RowBuffer );
        }

        ASSERT( (Status == STATUS_NO_MORE_MATCHES) || (Status == STATUS_NO_MATCH) );

    } finally {

        NtfsFreePool( RowBuffer );
        NtOfsReleaseMap( IrpContext, &MapHandle );

        if (IndexAcquired) {
            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (IndexRow != NULL) {
            NtfsFreePool( IndexRow );
        }

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }
    }

    return ReturnStatus;
}


RTL_GENERIC_COMPARE_RESULTS
NtfsQuotaTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

    This is a generic table support routine to compare two quota table elements

Arguments:

    Table - Supplies the generic table being queried.  Not used.

    FirstStruct - Supplies the first quota table element to compare

    SecondStruct - Supplies the second quota table element to compare

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/
{
    ULONG Key1 = ((PQUOTA_CONTROL_BLOCK) FirstStruct)->OwnerId;
    ULONG Key2 = ((PQUOTA_CONTROL_BLOCK) SecondStruct)->OwnerId;

    PAGED_CODE();

    if (Key1 < Key2) {

        return GenericLessThan;
    }

    if (Key1 > Key2) {

        return GenericGreaterThan;
    }

    return GenericEqual;

    UNREFERENCED_PARAMETER( Table );
}

PVOID
NtfsQuotaTableAllocate (
    IN PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    Table - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    PAGED_CODE();

    return NtfsAllocatePoolWithTag( PagedPool, ByteSize, 'QftN' );

    UNREFERENCED_PARAMETER( Table );
}

VOID
NtfsQuotaTableFree (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine to free memory

Arguments:

    Table - Supplies the generic table being used

    Buffer - Supplies pointer to the buffer to be freed

Return Value:

    None

--*/

{
    PAGED_CODE();

    NtfsFreePool( Buffer );

    UNREFERENCED_PARAMETER( Table );
}


ULONG
NtfsGetCallersUserId (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine finds the calling thread's SID and translates it to an
    owner id.

Arguments:

Return Value:

    Returns the owner id.

--*/

{
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    PACCESS_TOKEN Token;
    PTOKEN_USER UserToken = NULL;
    NTSTATUS Status;
    ULONG OwnerId;

    PAGED_CODE();

    SeCaptureSubjectContext( &SubjectContext );

    try {

        Token = SeQuerySubjectContextToken( &SubjectContext );

        Status = SeQueryInformationToken( Token, TokenOwner, &UserToken );


        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }


        OwnerId = NtfsGetOwnerId( IrpContext, UserToken->User.Sid, FALSE, NULL );

        if (OwnerId == QUOTA_INVALID_ID) {

            //
            //  If the user does not currently have an id on this
            //  system just use the current defaults.
            //

            OwnerId = QUOTA_DEFAULTS_ID;
        }

    } finally {

        if (UserToken != NULL) {
            NtfsFreePool( UserToken);
        }

        SeReleaseSubjectContext( &SubjectContext );
    }

    return OwnerId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfsstru.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsStru.h

Abstract:

    This module defines the data structures that make up the major
    internal part of the Ntfs file system.

    The global data structures start with the NtfsData record.  It
    contains a pointer to a File System Device object, and a queue of
    Vcb's.  There is a Vcb for every currently mounted volume.  The
    Vcb's are allocated as the extension to a volume device object.

        +--------+
        |NtfsData|     +--------+
        |        | --> |FilSysDo|
        |        |     |        |
        |        | <+  +--------+
        +--------+  |
                    |
                    |  +--------+     +--------+
                    |  |VolDo   |     |VolDo   |
                    |  |        |     |        |
                    |  +--------+     +--------+
                    +> |Vcb     | <-> |Vcb     | <-> ...
                       |        |     |        |
                       +--------+     +--------+

    The File System Device Object contains the global work queue for
    NTFS while each volume device object contains an overflow work queue.

    Each Vcb contains a table of all Fcbs for the volume indexed by their
    file reference (Called the FcbTable).  And each Vcb contains a pointer
    a root Lcb for the volume.  An Lcb is used to connect an indexed Scb
    (i.e., a directory) to an Fcb and give it a name.

    The following diagram shows the root structure.

        +--------+
        |Vcb     |
        |        |  +---+   +--------+
        |        | -|Lcb|-> |RootFcb |
        +--------+  |'\'|   |        |
                    +---+   |        |
                            +--------+

    Each Scb will only have one parent Fcb but multiple Fcb children (each
    connected via an Lcb).  An Fcb can have multiple Scb parents (via
    Lcbs) and multiple Scb Children.

    Now associated with each Fcb is potentially many Scbs.  An Scb
    is allocated for each opened stream file object (i.e., an attribute
    that the file system is manipulating as a stream file).  Each Scb
    contains a common fsrtl header and information necessary for doing
    I/O to the stream.

        +--------+
        |Fcb     |     +--------+     +--------+
        |        | <-> |Scb     | <-> |Scb     | <-> ...
        +--------+     |        |     |        |
                       +--------+     +--------+

    In the following diagram we have two index scb (Scb1 and Scb2).  The
    are two file opened under Scb1 both for the same File.  The file was
    opened once with the name LcbA and another time with the name LcbB.
    Scb2 also has two opened file one is Fcb1 and named LcbC and the other
    is Fcb2 and named LcbD.  Fcb1 has two opened Scbs under it (Scb3 and
    Scb4), and Fcb2 has one opened Scb underneath it (Scb5).


           +--------+                +--------+
           |Scb     |                |Scb     |
           |    1   |                |    2   |
           |        |                |        |
           +--------+                +--------+

             |    |                    |    |

            Lcb  Lcb                  Lcb  Lcb
             A    B                    C    D

             |    |     +--------+     |    |     +--------+
             |    +---> |Fcb     | <---+    +---> |Fcb     |
             |          |    1   |                |    2   |
             +--------> |        |                |        |
                        +--------+                +--------+
                          ^    ^                    ^    ^
             +------------+    +------------+  +----+    +----+
             |                              |  |              |
             |  +--------+      +--------+  |  |  +--------+  |
             +> |Scb     | <--> |Scb     | <+  +> |Scb     | <+
                |    3   |      |    4   |        |    5   |
                |        |      |        |        |        |
                +--------+      +--------+        +--------+

    In addition off of each Lcb is a list of Ccb and Prefix entries.  The
    Ccb list is for each ccb that has opened that File (fcb) via the name.
    The Prefix list contains the prefix table entries that we are caching.


    The NtfsData, all Vcbs, and the paging file Fcb, and all Scbs are
    allocated out of nonpaged pool.  The Fcbs are allocated out of paged
    pool.

    The resources protecting the NTFS memory structures are setup as
    follows:

    1. There is a global resource in the NtfsData record.  This resource
       protects the NtfsData record which includes any changes to its
       Vcb queue.

    2. There is a resource per Vcb.  This resource pretects the Vcb record
       which includes adding and removing Fcbs, and Scbs

    3. There is a single resource protecting an Fcb and its assigned
       Scbs.  This resource protects any changes to the Fcb, and Scb
       records.  The way this one works is that each Fcb, and Scb point
       to the resource.  The Scb also contain back pointers to their
       parent Fcb but we cannot use this pointer to get the resource
       because the Fcb might be in nonpaged pool.

        +--------+
        |Fcb     |     +--------+     +--------+
        |        | <-> |Scb     | <-> |Scb     | <-> ...
        +--------+     |        |     |        |
                       +--------+     +--------+
               |
               |           |            |
               |           v            |
               |                        |
               |       +--------+       |
               +-----> |Resource| <-----+
                       |        |
                       +--------+



    There are several types of opens possible for each file object handled by
    NTFS.  They are UserFileOpen, UserDirectoryOpen, UserVolumeOpen, StreamFileOpen,
    UserViewIndexOpen, and UserProperytSetOpen.  The first three types correspond
    to user opens on files, directories, and dasd respectively.  UserViewIndexOpen
    indicates that a user mode application has opened a view index stream such
    as the quota or object id index.  The last type of open is for any file object
    created by NTFS for its stream I/O (e.g., the volume bitmap).  The file system
    uses the FsContext and FsContext2 fields of the file object to store the
    fcb/scb/ccb associated with the file object.

        Type of open                FsContext                   FsContext2
        ------------                ---------                   ----------

        UserFileOpen                Pointer to Scb              Pointer to Ccb

        UserDirectoryOpen           Pointer to Scb              Pointer to Ccb

        UserVolumeOpen              Pointer to Scb              Pointer to Ccb

        StreamFileOpen              Pointer to Scb              null

    The only part of the NTFS code that actually needs to know this
    information is in FilObSup.c.  But we talk about it here to help
    developers debug the system.


    To mount a new NTFS volume requires a bit of juggling.  The idea is
    to have as little setup in memory as necessary to recoginize the
    volume, call a restart routine that will recover the volume, and then
    precede with the mounting.  To aid in this the regular directory
    structures of the Fcb is bypassed.  In its place we have a linked list
    of Fcbs off of the Vcb.  This is done because during recovery we do
    not know where an Fcb belongs in the directory hierarchy.  So at
    restart time all new fcbs get put in this prerestart Fcb list.  Then
    after restart whenever we create a new Fcb we search this list for a
    match (on file reference).  If we find one we remove the fcb from this
    list and move it to the proper place in the directory hierarchy tree
    (fcb tree).

Author:

    Brian Andrew    [BrianAn]       21-May-1991
    David Goebel    [DavidGoe]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:

--*/

#ifndef _NTFSSTRU_
#define _NTFSSTRU_

//
//  Forward typedefs
//

typedef struct _SCB *PSCB;

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module

typedef enum _NTFS_OWNERSHIP_STATE NTFS_OWNERSHIP_STATE;
typedef enum _NTFS_RESOURCE_NAME NTFS_RESOURCE_NAME;

//
//  Define how many freed structures we are willing to keep around
//

#define FREE_FCB_TABLE_SIZE              (8)

#define MAX_DELAYED_CLOSE_COUNT         (0x10)
#define ASYNC_CLOSE_POST_THRESHOLD      (500)
#define INITIAL_DIRTY_TABLE_HINT        (0x20)

//
//  Checkpoint activity status.  There are used to control number of outstanding
//  checkpoints.  We only want one to be posted at a time so they don't swallow
//  up the worker threads in case the current checkpoint is not completed before
//  the checkpoint timer fires.
//

#define CHECKPOINT_POSTED               (0x00000001)
#define CHECKPOINT_PENDING              (0x00000002)

//
//  Timer status types.  These are used in NtfsSetDirtyBcb synchronization with
//  checkpoint-all-volumes activity.
//

typedef enum TIMER_STATUS {
    TIMER_SET = 0,
    TIMER_NOT_SET = 1,
} TIMER_STATUS;


//
//  The NTFS_DATA record is the top record in the NTFS file system
//  in-memory data structure.  This structure must be allocated from
//  non-paged pool.
//

typedef struct _NTFS_DATA {

    //
    //  The type and size of this record (must be NTFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  A queue of all the devices that are mounted by the file system.
    //  Corresponds to the field Vcb->VcbLinks;
    //

    LIST_ENTRY VcbQueue;

    //
    //  A resource variable to control access to the global NTFS data
    //  record
    //

    ERESOURCE Resource;

    //
    //  The following list entry is used for performing closes that can't
    //  be done in the context of the original caller.
    //

    LIST_ENTRY AsyncCloseList;

    BOOLEAN AsyncCloseActive;
    BOOLEAN ReduceDelayedClose;

    ULONG AsyncCloseCount;

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

    //
    //  The following fields describe the deferred close file objects.
    //

    ULONG DelayedCloseCount;

    LIST_ENTRY DelayedCloseList;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    WORK_QUEUE_ITEM NtfsCloseItem;

    UCHAR FreeFcbTableSize;
    UCHAR UnusedUchar[3];

    PVOID *FreeFcbTableArray[ FREE_FCB_TABLE_SIZE ];
    //
    //  Free arrays are dynamically sized
    //

    ULONG FreeEresourceSize;
    ULONG FreeEresourceTotal;
    ULONG FreeEresourceMiss;
    PERESOURCE *FreeEresourceArray;

    //
    //  Cache manager call back structures, which must be passed on each
    //  call to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerVolumeCallbacks;

    //
    //  The following fields are used for the CheckpointVolumes()
    //  callback.
    //

    KDPC VolumeCheckpointDpc;
    KTIMER VolumeCheckpointTimer;
    ULONG VolumeCheckpointStatus;

    WORK_QUEUE_ITEM VolumeCheckpointItem;
    TIMER_STATUS TimerStatus;

    KDPC UsnTimeOutDpc;
    KTIMER UsnTimeOutTimer;
    WORK_QUEUE_ITEM UsnTimeOutItem;

    //
    //  Flags.  These are the flags for the volume.
    //

    USHORT Flags;

    //
    //  This is a list of all of the threads currently doing read ahead.
    //  We will not hot fix for these threads.
    //

    LIST_ENTRY ReadAheadThreads;

    //
    //  The following table of unicode values is the case mapping, with
    //  the size in number of Unicode characters.  We keep a global copy
    //  and let each Vcb use this copy if the upcase table for the volume
    //  matches.
    //

    PWCH UpcaseTable;
    ULONG UpcaseTableSize;

    //
    //  Pointer to a default security descriptor.
    //

    PSECURITY_DESCRIPTOR DefaultDescriptor;
    ULONG DefaultDescriptorLength;

    //
    //  Mutex to serialize internal NtfsData structures.
    //

    FAST_MUTEX NtfsDataLock;

    //
    //  Service and callback table for encryption.
    //

    ENCRYPTION_CALL_BACK EncryptionCallBackTable;

    //
    //  Useful information when debugging dismount memory leakage, etc.
    //

#ifdef DISMOUNT_DBG
    ULONG DismountCount;
#endif

    ULONG VolumeNameLookupsInProgress;

} NTFS_DATA;
typedef NTFS_DATA *PNTFS_DATA;

#define NTFS_FLAGS_SMALL_SYSTEM                 (0x0001)
#define NTFS_FLAGS_MEDIUM_SYSTEM                (0x0002)
#define NTFS_FLAGS_LARGE_SYSTEM                 (0x0004)
#define NTFS_FLAGS_CREATE_8DOT3_NAMES           (0X0010)
#define NTFS_FLAGS_ALLOW_EXTENDED_CHAR          (0x0020)
#define NTFS_FLAGS_DISABLE_LAST_ACCESS          (0x0040)
#define NTFS_FLAGS_ENCRYPTION_DRIVER            (0x0080)
#define NTFS_FLAGS_DISABLE_UPGRADE              (0x0100)
#define NTFS_FLAGS_PERSONAL                     (0x0200)


//
//  The record allocation context structure is used by the routines that
//  allocate and deallocate records based on a bitmap (for example the mft
//  bitmap or the index bitmap).  The context structure needs to be
//  defined here because the mft bitmap context is declared as part of the
//  vcb.
//

typedef struct _RECORD_ALLOCATION_CONTEXT {

    //
    //  The following field is a pointer to the scb for the data part of
    //  the file that this bitmap controls.  For example, it is a pointer
    //  to the data attribute for the MFT.
    //
    //  NOTE !!!!  The Data Scb must remain the first entry in this
    //  structure.  If we need to uninitialize and reinitialize this
    //  structure in the running system we don't want to touch this field.
    //
    //  NOTE !!!!  The code that clears the record allocation context
    //  expects the BitmapScb field to follow the Data Scb field.
    //

    PSCB DataScb;

    //
    //  The following field is used to indicate if the bitmap attribute is
    //  in a resident form or a nonresident form.  If the bitmap is in a
    //  resident form then the pointer is null, and whenever a bitmap
    //  routine is called it must also be passed an attribute enumeration
    //  context to be able to read the bitmap.  If the field is not null
    //  then it points to the scb for the non resident bitmap attribute
    //

    PSCB BitmapScb;

    //
    //  The following two fields describe the current size of the bitmap
    //  (in bits) and the number of free bits currently in the bitmap.
    //  A value of MAXULONG in the CurrentBitmapSize indicates that we
    //  need to reinitialize the record context structure.
    //

    ULONG CurrentBitmapSize;
    ULONG NumberOfFreeBits;

    //
    //  The following field contains the index of last bit that we know
    //  to be set.  This is used for truncation purposes.
    //

    LONG IndexOfLastSetBit;

    //
    //  The following three fields are used to indicate the allocation
    //  size for the bitmap (i.e., each bit in the bitmap represents how
    //  many bytes in the data attribute).  Also it indicates the
    //  granularity with which we will either extend or shrink the bitmap.
    //

    ULONG BytesPerRecord;

    ULONG ExtendGranularity;
    ULONG TruncateGranularity;

    //
    //  Scanning a large bitmap can be inefficient.  Use the following fields
    //  to quickly locate a likely starting position.
    //

    ULONG StartingHint;
    ULONG LowestDeallocatedIndex;

} RECORD_ALLOCATION_CONTEXT;
typedef RECORD_ALLOCATION_CONTEXT *PRECORD_ALLOCATION_CONTEXT;


//
//  The Vcb (Volume control Block) record corresponds to every volume
//  mounted by the file system.  They are ordered in a queue off of
//  NtfsData.VcbQueue.  This structure must be allocated from non-paged
//  pool
//

#define DEFAULT_ATTRIBUTE_TABLE_SIZE     (32)
#define DEFAULT_TRANSACTION_TABLE_SIZE   (32)
#define DEFAULT_DIRTY_PAGES_TABLE_SIZE   (64)

//
//  The Restart Pointers structure is the actual structure supported by
//  routines and macros to get at a Restart Table.  This structure is
//  required since the restart table itself may move, so one must first
//  acquire the resource to synchronize, then follow the pointer to the
//  table.
//

typedef struct _RESTART_POINTERS {

    //
    //  Resource to synchronize with table moves.  This resource must
    //  be held shared while dealing with pointers to table entries,
    //  and exclusive to move the table.
    //

    ERESOURCE Resource;

    //
    //  Pointer to the actual Restart Table.
    //

    struct _RESTART_TABLE *Table;

    //
    //  Spin Lock synchronizing allocates and deletes of entries in the
    //  table.  The resource must be held at least shared.
    //

    KSPIN_LOCK SpinLock;

    //
    //  Remember if the resource was initialized.
    //

    BOOLEAN ResourceInitialized;

    //
    //  Are we waiting for the table to empty - currently only used in the
    //  transaction table - the event used with it is in the Vcb->NoTransactionsEvent
    //  if all the tables need this capability it should move directly into the
    //  restart ptrs
    //

    BOOLEAN DrainPending;

    //
    //  For quad & cache line alignment
    //

    UCHAR Unused[6];

} RESTART_POINTERS, *PRESTART_POINTERS;

#define NtfsInitializeRestartPointers(P) {          \
    RtlZeroMemory( (P), sizeof(RESTART_POINTERS) ); \
    KeInitializeSpinLock( &(P)->SpinLock );         \
    ExInitializeResourceLite( &(P)->Resource );         \
    (P)->ResourceInitialized = TRUE;                \
}

//
//  Our Advanced FCB common header which includes all the normal fields +
//  the NTFS specific pending eof advances, compressed fileobject and
//  section object ptrs. This used to all be in the FSRTL_ADVANCED_FCB_HEADER
//

#ifdef __cplusplus
typedef struct _NTFS_ADVANCED_FCB_HEADER:FSRTL_ADVANCED_FCB_HEADER {
#else   // __cplusplus
typedef struct _NTFS_ADVANCED_FCB_HEADER {

    //
    //  Put in the standard FsRtl header fields
    //

    FSRTL_ADVANCED_FCB_HEADER ;

#endif  // __cplusplus

    //
    //  This is a pointer to a list head which may be used to queue
    //  up advances to EOF (end of file), via calls to the appropriate
    //  FsRtl routines.  This listhead may be paged.
    //

    PLIST_ENTRY PendingEofAdvances;

    //
    //  When FSRTL_FLAG_ADVANCED_HEADER is set, the following fields
    //  are present in the header.  If the compressed stream has not
    //  been initialized, all of the following fields will be NULL.
    //

#ifdef  COMPRESS_ON_WIRE
    //
    //  This is the FileObect for the stream in which data is cached
    //  in its compressed form.
    //

    PFILE_OBJECT FileObjectC;
#endif

} NTFS_ADVANCED_FCB_HEADER, *PNTFS_ADVANCED_FCB_HEADER;


//
//  The NTFS MCB structure is a super set of the FsRtl Large Mcb package
//
//  This structure is ideally aligned on an odd quadword (address ends in 8).
//

typedef struct _NTFS_MCB_ENTRY {

    LIST_ENTRY LruLinks;
    struct _NTFS_MCB *NtfsMcb;
    struct _NTFS_MCB_ARRAY *NtfsMcbArray;
    LARGE_MCB LargeMcb;

} NTFS_MCB_ENTRY;
typedef NTFS_MCB_ENTRY *PNTFS_MCB_ENTRY;

typedef struct _NTFS_MCB_ARRAY {

    VCN StartingVcn;
    VCN EndingVcn;
    PNTFS_MCB_ENTRY NtfsMcbEntry;
    PVOID Unused;

} NTFS_MCB_ARRAY;
typedef NTFS_MCB_ARRAY *PNTFS_MCB_ARRAY;

typedef struct _NTFS_MCB {

    PNTFS_ADVANCED_FCB_HEADER FcbHeader;
    POOL_TYPE PoolType;
    ULONG NtfsMcbArraySizeInUse;
    ULONG NtfsMcbArraySize;
    PNTFS_MCB_ARRAY NtfsMcbArray;
    PFAST_MUTEX FastMutex;

} NTFS_MCB;
typedef NTFS_MCB *PNTFS_MCB;

//
//  Define some additional Ntfs Mcb structures to accomodate small to
//  medium files with fewer pool allocations.  This space will be
//  unused for large files (more than three ranges).
//

#define MCB_ARRAY_PHASE1_SIZE 1
#define MCB_ARRAY_PHASE2_SIZE 3

typedef union {

    //
    //  For the first phase, embed one array element and its Mcb entry.
    //

    struct {

        NTFS_MCB_ARRAY SingleMcbArrayEntry;

        NTFS_MCB_ENTRY McbEntry;

    } Phase1;

    //
    //  For the second phase, we can at least store three entries in
    //  the Mcb Array.
    //

    struct {

        NTFS_MCB_ARRAY ThreeMcbArrayEntries[MCB_ARRAY_PHASE2_SIZE];

    } Phase2;

} NTFS_MCB_INITIAL_STRUCTS;
typedef NTFS_MCB_INITIAL_STRUCTS *PNTFS_MCB_INITIAL_STRUCTS;


//
//  Structure used to track the deallocated clusters.
//

//
//  How many pairs maximum we want stored in an mcb before starting a new one
//

#define NTFS_DEALLOCATED_MCB_LIMIT (PAGE_SIZE / sizeof( LONGLONG ))

typedef struct _DEALLOCATED_CLUSTERS {

    LIST_ENTRY Link;
    LARGE_MCB Mcb;
    LSN Lsn;
    LONGLONG ClusterCount;

} DEALLOCATED_CLUSTERS, *PDEALLOCATED_CLUSTERS;


//
//  The Ntfs ReservedBitmapRange is used to describe the reserved
//  clusters in a range of the file.  This data structure comes in
//  several forms.
//
//  The basic unit is an RtlBitmap and bitmap embedded
//  in a single pool block.  The entire structure is reallocated
//  as it grows past its current size.  This is meant to handle
//  small files.
//
//  As the file gets larger we will allocate a fixed size block
//  which descibes a set range in the file.
//
//  As the file continues to grow then we will link fixed size
//  ranges together.  Only the ranges being accessed will need a
//  bitmap.  We will only allocate the needed space for the
//  bitmap.
//

//
//  RANGE_SIZE - number of compression units per range.
//  RANGE_SHIFT - shift value to convert from compression unit to range.
//

#define NTFS_BITMAP_RANGE_SIZE              (0x2000)
#define NTFS_BITMAP_RANGE_MASK              (NTFS_BITMAP_RANGE_SIZE - 1)
#define NTFS_BITMAP_RANGE_SHIFT             (13)
#define NTFS_BITMAP_MAX_BASIC_SIZE          (NTFS_BITMAP_RANGE_SIZE - ((sizeof( RTL_BITMAP ) + sizeof( LIST_ENTRY )) * 8))

//
//  Grow the basic bitmap in full pool blocks so we don't constantly reallocate
//  as the bitmap grows.  Add the requested bits (converted to bytes) to
//  the pool header and the header of the bitmap
//

#define NtfsBasicBitmapSize(Size)       (                                                               \
    ((((Size + 7) / 8) + 8 + sizeof( LIST_ENTRY ) + sizeof( RTL_BITMAP ) + 0x20 - 1) & ~(0x20 - 1)) -8  \
)

#define NtfsBitmapSize(Size)            (                   \
    ((((Size + 7) / 8) + 8 + 0x20 - 1) & ~(0x20 - 1)) - 8   \
)

typedef struct _RESERVED_BITMAP_RANGE {

    //
    //  Overload the first field.  The Flink field is NULL if we are using
    //  the basic structure.  The Blink field will be the count of dirty
    //  bits for the basic case.  Keeping track of the dirty bits will allow
    //  us to cut off the scan if there are no dirty bits.
    //

    union {

        //
        //  Links for the separate ranges.  A NULL in the Flink
        //  field indicates that this the basic unit and the
        //  bitmap is integrated into the structure.
        //

        LIST_ENTRY Links;

        struct {

            ULONG_PTR Flink;
            USHORT BasicDirtyBits;
            USHORT BasicUnused;
        };
    };

    //
    //  Bitmap structure for this range.
    //

    RTL_BITMAP Bitmap;

    //
    //  The following fields are only valid if this is not
    //  the basic structure.  In the basic structure the
    //  buffer for the bitmap will begin at the following
    //  location.
    //

    //
    //  Range offset.  The size of the bitmap range is
    //  determined by the range shift and mask values above.
    //  Each range will describe a certain number of compression
    //  units.  The range offset is the position of this range
    //  in the file.
    //

    ULONG RangeOffset;

    //
    //  Number of dirty bits.  A zero value indicates that this
    //  range can be reused.
    //

    USHORT DirtyBits;

    //
    //  Unused at this point.
    //

    USHORT Unused;

} RESERVED_BITMAP_RANGE, *PRESERVED_BITMAP_RANGE;


//
//  Following structure is embedded in the Vcb to control the Usn delete operation.
//

typedef struct _NTFS_DELETE_JOURNAL_DATA {

    FILE_REFERENCE DeleteUsnFileReference;

    PSCB PriorJournalScb;
    ULONG DeleteState;
    NTSTATUS FinalStatus;

} NTFS_DELETE_JOURNAL_DATA, *PNTFS_DELETE_JOURNAL_DATA;

#define DELETE_USN_RESET_MFT                (0x00000001)
#define DELETE_USN_REMOVE_JOURNAL           (0x00000002)
#define DELETE_USN_FINAL_CLEANUP            (0x00000004)


//
//  Local structures to manage the cached free clusters.
//

#define NTFS_INITIAL_CACHED_RUNS        (0x20)
#define NTFS_MAX_CACHED_RUNS_DELTA      (0x200)

//
//  Define the maximum run index
//

#define NTFS_CACHED_RUNS_MAX_INDEX      (MAXSHORT)

//
//  Define a run index that will be used to identify an entry whose
//  corresponding entry in the other sorted list no longer refers
//  to it.  This is used when an entry is deleted from one sorted
//  list and hasn't yet been removed from the other.
//

#define NTFS_CACHED_RUNS_DEL_INDEX      (MAXUSHORT)

//
//  Define the number of bins of run lengths to keep track of.
//

#define NTFS_CACHED_RUNS_BIN_COUNT          (32)

//
//  Define the number of windows of deleted entries to keep track of for
//  each sort table.
//

#define NTFS_CACHED_RUNS_MAX_DEL_WINDOWS    (64)

typedef struct _NTFS_LCN_CLUSTER_RUN {

    //
    //  The cluster number where the free run begins
    //

    LCN Lcn;

    //
    //  The number of clusters in the free run starting at Lcn.
    //

    LONGLONG RunLength;

    //
    //  This is the index of the corresponding entry in the length-sorted list
    //

    USHORT LengthIndex;

    //
    //  Pad the structure out to 64-bit alignment
    //

    USHORT Pad0;
    ULONG Pad1;

} NTFS_LCN_CLUSTER_RUN, *PNTFS_LCN_CLUSTER_RUN;

typedef struct _NTFS_DELETED_RUNS {

    //
    //  The starting and ending indices of a window of cached runs that have
    //  been deleted.  These are indices into the Lcn-sorted or length-sorted
    //  arrays.
    //

    USHORT StartIndex;
    USHORT EndIndex;

} NTFS_DELETED_RUNS, *PNTFS_DELETED_RUNS;

typedef struct _NTFS_CACHED_RUNS {

    //
    //  Pointer to the array of free runs sorted by Lcn
    //

    PNTFS_LCN_CLUSTER_RUN LcnArray;

    //
    //  Pointer to an array of indices of the Lcn-sorted array
    //  above, sorted by RunLength, and sub-sorted by Lcn.
    //

    PUSHORT LengthArray;

    //
    //  Pointer to an array of bins.  Each bin contains the number of
    //  entries in LengthArray of a given run length.  BinArray[0] contains
    //  the count of entries with run length 1.  BinArray[1] contains run
    //  length 2, and so on.
    //
    //  This array is used to keep track of how many small free runs are
    //  cached so that we keep a sufficient number of them around.
    //

    PUSHORT BinArray;

    //
    //  An array of windows of cached runs in LcnArray that have been
    //  deleted.
    //

    PNTFS_DELETED_RUNS DeletedLcnWindows;

    //
    //  An array of windows of cached runs in LengthArray that have been
    //  deleted.
    //

    PNTFS_DELETED_RUNS DeletedLengthWindows;

    //
    //  The longest freed run so far.
    //

    LONGLONG LongestFreedRun;

    //
    //  The maximum number of entries to which LcnArray should grow.  The same
    //  limit applies to LengthArray.
    //

    USHORT MaximumSize;

    //
    //  The desired number of small length free runs to keep cached for
    //  each size.
    //

    USHORT MinCount;

    //
    //  The allocated number of entries in LcnArray.  The same number are
    //  available in LengthArray.
    //

    USHORT Avail;

    //
    //  The number of entries used in LcnArray.  The same number are used
    //  in LengthArray.
    //

    USHORT Used;

    //
    //  The number of entries in DeletedLcnWindows.
    //

    USHORT DelLcnCount;

    //
    //  The number of entries in DeletedLengthWindows.
    //

    USHORT DelLengthCount;

    //
    //  The number of entries in BinArray.
    //

    USHORT Bins;

#ifdef NTFS_CHECK_CACHED_RUNS
    struct _VCB *Vcb;
#endif

} NTFS_CACHED_RUNS, *PNTFS_CACHED_RUNS;


//
//  The following structures are used for the filename hash table.
//

//
//  Constants controlling the total number of buckets
//

#define HASH_MAX_SEGMENT_COUNT          (32)
#define HASH_SEGMENT_SHIFT              (5)
#define HASH_MAX_INDEX_COUNT            (1024)
#define HASH_INDEX_SHIFT                (10)
#define HASH_MAX_BUCKET_COUNT           (HASH_MAX_SEGMENT_COUNT * HASH_MAX_INDEX_COUNT)

//
//  This is the basic structure for a hash entry.  A hash entry is described by the
//  the hash value computed from a full path name.  We will only store hash entries
//  for files without DOS-only components.
//
//  We will only allow one entry in the table for each (Lcb, string length, hash value)
//  triplet.  We don't want to store the full string in the table for each entry.
//  After a lookup it will be up to the caller to verify the string.
//
//  We keep a loose coherency between the hash table and the Lcb.  The hash table
//  points definitively back to an Lcb but the Lcb only suggests that there is an
//  entry in the table.  This way if we remove an entry from the table we won't
//  have to track down the Lcb.
//

typedef struct _NTFS_HASH_ENTRY {

    //
    //  Pointer to the next entry in the same bucket.  Note that the chain
    //  of entries in the same bucket don't all have the hash value.
    //

    struct _NTFS_HASH_ENTRY *NextEntry;

    //
    //  The entry is described by the hash value, filename length and the Lcb for the
    //  last component.
    //

    struct _LCB *HashLcb;
    ULONG HashValue;
    ULONG FullNameLength;

} NTFS_HASH_ENTRY, *PNTFS_HASH_ENTRY;

//
//  The hash segments consists of an array of hash entry pointers.
//

typedef PNTFS_HASH_ENTRY NTFS_HASH_SEGMENT[ HASH_MAX_INDEX_COUNT ];
typedef NTFS_HASH_SEGMENT *PNTFS_HASH_SEGMENT;

//
//  The basic table consists of an array of segments.  Each segment contains a fixed
//  number of buckets.  Once the initial segment has buckets which are deeper than
//  our max optimal depth then we will double the number of segments and split the
//  existing entries across the new segments.  The process of splitting is done bucket
//  by bucket until we reach the new size.  During this process we need to keep track
//  of whether the new entry belongs to a bucket which has already been split.
//

//
//  Table state value
//

#define TABLE_STATE_STABLE              (0x00000000)
#define TABLE_STATE_EXPANDING           (0x00000001)
#define TABLE_STATE_REDUCING            (0x00000002)

typedef struct _NTFS_HASH_TABLE {

    //
    //  Max bucket is always 2^n.  When we grow the table we double the number of buckets
    //  but need to split the existing buckets to find which entries should be moved
    //  to the expanded region.  The SplitPoint is our current position to do this
    //  work.
    //

    ULONG MaxBucket;
    ULONG SplitPoint;

    ULONG TableState;

#ifdef NTFS_HASH_DATA
    ULONG HashLookupCount;
    ULONG SkipHashLookupCount;
    ULONG FileMatchCount;
    ULONG ParentMatchCount;

    ULONG CreateNewFileInsert;
    ULONG OpenFileInsert;
    ULONG OpenExistingInsert;
    ULONG ParentInsert;

    ULONG OpenFileConflict;
    ULONG OpenExistingConflict;
    ULONG ParentConflict;

    ULONG CreateScbFails;
    ULONG CreateLcbFails;

    ULONG Histogram[16];
    ULONG ExtendedHistogram[16];

#endif

    PNTFS_HASH_SEGMENT HashSegments[ HASH_MAX_SEGMENT_COUNT ];

} NTFS_HASH_TABLE, *PNTFS_HASH_TABLE;

//
//  Scrambling values for generating hash
//

#define HASH_STRING_CONVERT_CONSTANT        (314159269)
#define HASH_STRING_PRIME                   (1000000007)

//
//  Build an intermediate hash based on processing a number of WCHAR characters
//  pointed to by an input string.  In most cases this will be a UNICODE_STRING.
//  It might also be a pointer though.
//

//
//  VOID
//  NtfsConvertNameToHash (
//      IN PWCHAR Buffer,
//      IN ULONG Length,
//      IN PWCH UpcaseTable,
//      IN OUT PULONG Hash
//      );
//

#define NtfsConvertNameToHash(B,L,U,H) {        \
    PWCHAR _Current = (B);                      \
    PWCHAR _End = Add2Ptr( _Current, (L) );     \
    ULONG _Hash = *(H);                         \
    do {                                        \
                                                \
        _Hash = 37 * _Hash + (U)[*(_Current)];  \
        _Current += 1;                          \
                                                \
    } while (_Current != _End);                 \
    *(H) = _Hash;                               \
}

//
//  ULONG
//  NtfsGenerateHashFromUlong (
//      IN ULONG Ulong
//      );
//

#define NtfsGenerateHashFromUlong(U) (                              \
    abs( HASH_STRING_CONVERT_CONSTANT * (U) ) % HASH_STRING_PRIME   \
)


#ifdef PERF_STATS

//
//  Some structures to capture performance statisics during checkpoints
//

typedef struct _CHECKPOINT_ENTRY {

    ULONG Reason;
    LONGLONG StartTime;
    LONGLONG ElapsedTime;
    ULONG NumAttributes;
    ULONG NumIos;
    LSN RestartArea;
    ULONG LogFileFulls;

} CHECKPOINT_ENTRY, *PCHECKPOINT_ENTRY;

#define LF_LOG_SPACE 1
#define LF_DIRTY_PAGES 2
#define LF_OPEN_ATTRIBUTES 3
#define LF_TRANSACTION_DRAIN 4
#define LF_FASTIO_CALLBACK 5
#define LF_DEALLOCATED_CLUSTERS 6
#define LF_DEALLOCATED_CLUSTERS_MEM 7
#define LF_RECORD_STACK_CHECK 8
#define LF_DISMOUNT 9
#define LF_COMPRESSION 10
#define LF_SNAPSHOT 11
#define LF_MOUNT 12
#define LF_SHUTDOWN 13
#define LF_RECURSIVE_COMPRESSION 14

#define NUM_CHECKPOINT_ENTRIES 50

#endif


//
//  The Vcb structure corresponds to every mounted NTFS volume in the
//  system
//

#define VCB_SECURITY_CACHE_BY_ID_SIZE   31
#define VCB_SECURITY_CACHE_BY_HASH_SIZE 31

//
//  Default Minimum Usn Journal Size.
//

#define MINIMUM_USN_JOURNAL_SIZE        (0x100000)

typedef struct _VCB {

    //
    //  The type and size of this record (must be NTFS_NTC_VCB)
    //
    //  Assumption here is that this structure is embedded within a
    //  device object and the base of this structure in on an even
    //  64-bit boundary.  We will put the embedded structures on
    //  the same boundaries they would be on if allocated from pool
    //  (odd 64-bit boundary) except if the structure would fit
    //  within a 16 byte cache line.
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The internal state of the volume.  The VcbState is synchronized with the Vcb resource.
    //

    ULONG VcbState;

    //
    //  The links for the queue of all the Vcbs in the system.
    //  Corresponds to the filld NtfsData.VcbQueue
    //

    LIST_ENTRY VcbLinks;

    //
    //  Pointer to the Scb for the special system file.  If the field is
    //  null then we haven't yet built the scb for that system file.  Also
    //  the pointer to the stream file object is located in the scb.
    //
    //  NOTE: AcquireExclusiveFiles depends on this order.  Any change
    //  here should be checked with the code there.
    //

    PSCB RootIndexScb;
    PSCB UsnJournal;
    PSCB MftScb;
    PSCB Mft2Scb;
    PSCB LogFileScb;
    PSCB BitmapScb;
    PSCB AttributeDefTableScb;
    PSCB BadClusterFileScb;
    PSCB ExtendDirectory;
    PSCB SecurityDescriptorStream;
    PSCB SecurityIdIndex;
    PSCB SecurityDescriptorHashIndex;
    PSCB UpcaseTableScb;
    PSCB QuotaTableScb;
    PSCB OwnerIdTableScb;
    PSCB ReparsePointTableScb;
    PSCB ObjectIdTableScb;
    PSCB VolumeDasdScb;
    PSCB MftBitmapScb;

    //
    //  File object for log file.  We always dereference the file object for the
    //  log file last.  This will allow us to synchronize when the Vpb for the
    //  volume is deleted.
    //

    PFILE_OBJECT LogFileObject;

    //
    //  A pointer the device object passed in by the I/O system on a mount
    //  This is the target device object that the file system talks to
    //  when it needs to do any I/O (e.g., the disk stripper device
    //  object).
    //
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  Lfs Log Handle for this volume
    //

    LFS_LOG_HANDLE LogHandle;

    //
    //  The root Lcb for this volume.
    //

    struct _LCB *RootLcb;

    //
    //  A pointer to the VPB for the volume passed in by the I/O system on
    //  a mount.
    //

    PVPB Vpb;

    //
    //  A count of the number of file objects that have any file/directory
    //  opened on this volume. And a count of the number of special system
    //  files that we have open
    //

    CLONG CleanupCount;
    CLONG CloseCount;
    CLONG ReadOnlyCloseCount;
    CLONG SystemFileCloseCount;

    //
    //  The following fields are used by the BitmpSup routines.  The first
    //  value contains the total number of clusters on the volume, this
    //  is computed from the boot sector information.  The second value
    //  is the current number of free clusters available for allocation on
    //  the volume.  Allocation is handled by using a free space mcb that
    //  describes some small window of known clusters that are free.
    //
    //  The last field is for storing local volume specific data needed by
    //  the bitmap routines
    //

    LONGLONG TotalClusters;
    LONGLONG FreeClusters;
    LONGLONG DeallocatedClusters;

    //
    //  Total number of reserved clusters on the volume, must be less than
    //  or equal to FreeClusters.  Use the security fast mutex as a
    //  convenient end resource for this field.
    //

    LONGLONG TotalReserved;

    //
    //  If we are growing the volume bitmap then we need to restore the total number of
    //  clusters.
    //

    LONGLONG PreviousTotalClusters;

    //
    //  This field contains a calculated value which determines when an
    //  individual attribute is large enough to be moved to free up file
    //  record space.  (The calculation of this variable must be
    //  considered in conjunction with the constant
    //  MAX_MOVEABLE_ATTRIBUTES below.)
    //

    ULONG BigEnoughToMove;

    //
    //  The following volume-specific parameters are extracted from the
    //  Boot Sector.
    //

    ULONG DefaultBlocksPerIndexAllocationBuffer;
    ULONG DefaultBytesPerIndexAllocationBuffer;

    ULONG BytesPerSector;
    ULONG BytesPerCluster;
    ULONG BytesPerFileRecordSegment;

    //
    //  Zero clusters per file record segment indicates that clusters are larger than
    //  file records.  Zero file record segments per clusters indicates that
    //  file records are larger than clusters.
    //

    ULONG ClustersPerFileRecordSegment;
    ULONG FileRecordsPerCluster;

    ULONG ClustersPer4Gig;

    //
    //  Clusters per page will be 1 if the cluster size is larger than the page size
    //

    ULONG ClustersPerPage;

    LCN MftStartLcn;
    LCN Mft2StartLcn;
    LONGLONG NumberSectors;

    //
    //  The following fields are used to verify that an NTFS volume hasn't
    //  changed.  The serial number is stored in the boot sector on disk,
    //  and the four times are from the standard information field of the
    //  volume file.
    //

    LONGLONG VolumeSerialNumber;

    LONGLONG VolumeCreationTime;
    LONGLONG VolumeLastModificationTime;
    LONGLONG VolumeLastChangeTime;
    LONGLONG VolumeLastAccessTime;

    //
    //  Convenient constants for the conversion macros.  Shift and mask values are for
    //
    //      Clusters <=> Bytes
    //      FileRecords <=> Bytes
    //      FileRecords <=> Clusters
    //
    //  Note that you must know whether to shift right or left when using the
    //  file record/cluster shift value.
    //

    ULONG ClusterMask;              //  BytesPerCluster - 1
    LONG InverseClusterMask;        //  ~ClusterMask - signed for 64-bit system
    ULONG ClusterShift;             //  2**ClusterShift == BytesPerCluster

    ULONG MftShift;                 //  2**MftShift == BytesPerFileRecord
    ULONG MftToClusterShift;        //  2**MftClusterShift == ClusterPerFileRecordSegment
                                    //  2**MftToClusterShift == FileRecordsPerCluster

    ULONG MftReserved;
    ULONG MftCushion;

    //
    //  Synchronization objects for checkpoint operations.
    //

    ULONG CheckpointFlags;
    FAST_MUTEX CheckpointMutex;
    KEVENT CheckpointNotifyEvent;

    //
    //  Mutex to synchronize access to the Fcb table.
    //

    FAST_MUTEX FcbTableMutex;

    //
    //  Mutex to synchronize access to the security descriptors.
    //

    FAST_MUTEX FcbSecurityMutex;

    //
    //  Mutex to synchronize access to reserved clusters.
    //

    FAST_MUTEX ReservedClustersMutex;

    //
    //  Mutex for the hash table.
    //

    FAST_MUTEX HashTableMutex;

    //
    //  We don't allow compression on a system with a cluster size greater than
    //  4k.  Use a mask value here to quickly check allowed compression on
    //  this volume.
    //

    USHORT AttributeFlagsMask;

    //
    //  Remember what version this volume is so we can selectively enable
    //  certain features.
    //

    UCHAR MajorVersion;
    UCHAR MinorVersion;

    //
    //  The count of free records is based on the size of the Mft and the
    //  allocated records.  The hole count is the count of how many file
    //  records are not allocated.
    //

    ULONG MftHoleGranularity;

    ULONG MftFreeRecords;
    ULONG MftHoleRecords;

    //
    //  Variables for Mft hole calculations.
    //

    ULONG MftHoleMask;
    LONG MftHoleInverseMask;

    //
    //  The count of the bitmap bits per hole.  This is the number of file
    //  records per hole.  Must be converted to clusters to find a hole in
    //  the Mft Mcb.
    //

    ULONG MftClustersPerHole;
    ULONG MftHoleClusterMask;
    ULONG MftHoleClusterInverseMask;

    //
    //  The following table of unicode values is the case mapping, with
    //  the size in number of Unicode characters.  If the upcase table
    //  that is stored in NtfsData matches the one for the volume then
    //  we'll simply use that one and not allocate a special one for the
    //  volume.
    //

    ULONG UpcaseTableSize;
    PWCH UpcaseTable;

    //
    //  A pointer to an array of structs to hold performance counters,
    //  one array element for each processor.  The array is allocated
    //  from non-paged pool.  If this member is deleted, replace with
    //  padding.
    //

    struct _FILE_SYSTEM_STATISTICS *Statistics;

    //
    //  Open attribute table.
    //

    LSN LastRestartArea;
    RESTART_POINTERS OpenAttributeTable;

    //
    //  Transaction table.
    //

    LSN LastBaseLsn;
    RESTART_POINTERS TransactionTable;

    //
    //  Latest Lsn at the beginning of a transaction before LsnWrite returns
    //  the actual Lsn used and got stored into the transaction entry.
    //  This field is synchronized by acquiring the transaction table.
    //

    LSN LastTransactionLsn;

    //
    //  A count of writes to LastTransactionLsn.
    //  This field is synchronized by acquiring the transaction table exclusive.
    //  There are a few places where we can only share the transaction table,
    //  we then decrement this field using Interlocked routines.
    //

    ULONG LastTransactionLsnCount;

    //
    //  LSNs of the end of the last checkpoint and the last RestartArea.
    //  Normally the RestartArea Lsn is greater than the other one,
    //  however if the VcbState indicates that a checkpoint is in
    //  progress, then these Lsns are in flux.
    //

    LSN EndOfLastCheckpoint;

    //
    //  Current Lsn we used at mount time
    //

    LSN CurrentLsnAtMount;

    //
    //  OldestDirtyLsn
    //

    LSN OldestDirtyLsn;

    //
    //   The LSN of the restart area at the first logfile full not handled
    //   since the last clean checkpoint. This is only incremented for non-top-level
    //   request
    //

    LSN LastRestartAreaAtNonTopLevelLogFull;

    //
    //  The following string contains the device name for this partition.
    //

    UNICODE_STRING DeviceName;

    //
    //  A table of all the fcb that have been created for this volume.
    //

    RTL_GENERIC_TABLE FcbTable;

    //
    //  The following is the head of a list of notify Irps for directories.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  The following is the head of a list of notify Irps for view indices.
    //

    LIST_ENTRY ViewIndexNotifyList;

    //
    //  The following is used to synchronize the dir notify lists.
    //

    PNOTIFY_SYNC NotifySync;

    //
    //  The following field is a pointer to the file object that has the
    //  volume locked. if the VcbState has the locked flag set.
    //

    PFILE_OBJECT FileObjectWithVcbLocked;

    //
    //  The following two fields are used by the bitmap routines to
    //  determine what is called the mft zone.  The Mft zone are those
    //  clusters on the disk were we will try and put the mft and only the
    //  mft unless the disk is getting too full.
    //

    LCN MftZoneStart;
    LCN MftZoneEnd;

    //
    //  Information to track activity in the volume bitmap.  If we are extending
    //  the Mft we don't want to constantly force a rescan of the bitmap if
    //  there is no activity.
    //

    LONGLONG ClustersRecentlyFreed;

    //
    //  The following are used to track the deallocated clusters waiting
    //  for a checkpoint.  The pointers are used so we can toggle the
    //  use of the structures.
    //

    LIST_ENTRY DeallocatedClusterListHead;

    DEALLOCATED_CLUSTERS DeallocatedClusters1;
    DEALLOCATED_CLUSTERS DeallocatedClusters2;

    //
    //  Fields associated with the Usn Journal.  MaximumSize is the size in
    //  bytes that the Journal is allowed to occupy.  StartUsn is the lowest Usn
    //  in the allocated range of the Journal.  LowestOpenUsn remembers a Usn
    //  from restart from which a scan for Fcbs not closed at the time of a
    //  crash must be done.  ModifiedOpenFiles is a listhead of Fcbs with
    //  active Usn records but have not written the final cleanup record.
    //  These fields and the list are synchronized by the UsnJournal resource.
    //

    USN_JOURNAL_INSTANCE UsnJournalInstance;
    USN FirstValidUsn;                      //  Synchronized by main file resource
    USN LowestOpenUsn;
    FILE_REFERENCE UsnJournalReference;
    LONGLONG UsnCacheBias;
    LIST_ENTRY ModifiedOpenFiles;           //  Synchronized by the NtfsLockFcb on UsnJournal
    LIST_ENTRY NotifyUsnDeleteIrps;         //  Synchronized with NtfsLock/UnlockUsnNotify.

    PLIST_ENTRY CurrentTimeOutFiles;
    PLIST_ENTRY AgedTimeOutFiles;

    LIST_ENTRY TimeOutListA;
    LIST_ENTRY TimeOutListB;

    NTFS_DELETE_JOURNAL_DATA DeleteUsnData;

    //
    //  A resource variable to control access to the volume specific data
    //  structures
    //

    ERESOURCE Resource;

    //
    //  Resource to manage mft lazywrite flushes and mft defrag
    //

    ERESOURCE MftFlushResource;

    //
    //  Log header reservation.  This is the amount to add to the reservation
    //  amount to compensate for the commit record.  Lfs reserves differently
    //  for its log record header and the body of a log record.
    //

    ULONG LogHeaderReservation;

    //
    //  Count of outstanding notify handles.  If zero we can noop the notify calls.
    //

    ULONG NotifyCount;

    //
    //  Count of outstanding view index notify handles.  If zero we can noop view
    //  index notify calls.
    //

    ULONG ViewIndexNotifyCount;

    //
    //  Count of media changes before this volume was mounted.  Helps NtfsPingVolume
    //  notice when we've missed a media change notification.
    //

    ULONG DeviceChangeCount;

    struct _SHARED_SECURITY **SecurityCacheById[VCB_SECURITY_CACHE_BY_ID_SIZE];
    struct _SHARED_SECURITY *SecurityCacheByHash[VCB_SECURITY_CACHE_BY_HASH_SIZE];

    SECURITY_ID NextSecurityId;

    //
    //  Quota state and flags are protected by the QuotaControlLock above
    //

    ULONG QuotaState;

    //
    //  QuotaFlags are a copy of the flags from default user index entry.
    //

    ULONG QuotaFlags;

    //
    // The next owner Id to be allocated.
    //

    ULONG QuotaOwnerId;

    //
    //  Delete sequence number.  The value gets incremented each time
    //  an owner id is marked for deletion.
    //

    ULONG QuotaDeleteSecquence;

    //
    //  Quota control delete sequence. This values gets incremented each time
    //  a quota control block is removed from table.
    //

    ULONG QuotaControlDeleteCount;

    //
    // The following items are for Quota support.
    // The QuotaControlTable is the root of the quota control blocks.
    //

    RTL_GENERIC_TABLE QuotaControlTable;

    //
    // Lock used for QuotaControlTable;
    //

    FAST_MUTEX QuotaControlLock;

    //
    //  Current file reference used by the quota repair code.
    //

    FILE_REFERENCE QuotaFileReference;

    //
    // Administrator Owner Id.
    //

    ULONG AdministratorId;

    //
    //  ObjectIdState indicates the state of the object id index.
    //

    ULONG ObjectIdState;

    //
    // Quota Control template used addin entry to the quota control table.
    //

    struct _QUOTA_CONTROL_BLOCK *QuotaControlTemplate;

    //
    //  This is a pointer to the attribute definitions for the volume
    //  which are loaded into nonpaged pool.
    //

    PATTRIBUTE_DEFINITION_COLUMNS AttributeDefinitions;

    //
    //  File property (shortname/longname/createtime) tunneling structure
    //

    TUNNEL Tunnel;

    //
    //  Size and number of clusters in the sparse file unit.
    //  Initially this is 64K.
    //

    ULONG SparseFileUnit;
    ULONG SparseFileClusters;

    //
    //  Save away the maximum cluster count for this volume (limit to
    //  MAXFILESIZE).
    //

    LONGLONG MaxClusterCount;

    //
    //  Embed the Lfs WRITE_DATA structure so we can trim the writes
    //  from MM.
    //

    LFS_WRITE_DATA LfsWriteData;

    //
    //  Count of AcquireAllFiles.
    //

    ULONG AcquireFilesCount;

    ULONG LogFileFullCount;
    ULONG CleanCheckpointMark;
    ULONG UnhandledLogFileFullCount;

    //
    //  What restart version are we currently using.
    //

    ULONG RestartVersion;
    ULONG OatEntrySize;

    //
    //  Total number of entries on the async and delayed close queues for this Vcb.
    //

    CLONG QueuedCloseCount;

    //
    //  Spare Vpb for dismount.  Avoid using MustSucceed pool by preallocating
    //  the Vpb that might be needed for a dismount.
    //

    PVPB SpareVpb;

    //
    //  Open attribute table to store on disk.  It may point to the embedded
    //  open attribute table if the on-disk and in-memory version are the same.
    //

    PRESTART_POINTERS OnDiskOat;

    //
    //  Linked list of OpenAttribute extended data structures.
    //

    LIST_ENTRY OpenAttributeData;

    //
    //  The volume object id, if any.  This can only be set for upgraded volumes.
    //

    UCHAR VolumeObjectId[OBJECT_ID_KEY_LENGTH];

    NTFS_CACHED_RUNS CachedRuns;

    //
    //  Last Lcn used for fresh allocation
    //

    LCN LastBitmapHint;

    //
    //  File name hash table.
    //

    NTFS_HASH_TABLE HashTable;

    //
    //  The MftDefragState is synchronized with the CheckpointEvent.
    //  The MftReserveFlags are sychronized with the MftScb.
    //

    ULONG MftReserveFlags;
    ULONG MftDefragState;

    //
    //  Event for synchronizing when the transaction table is empty
    //  if all the tables need this capability it should move directly into the
    //  restart ptrs.
    //

    KEVENT TransactionsDoneEvent;

    //  Checkpoint owner thread.
    //

    PVOID CheckpointOwnerThread;

    //
    //  Hint for dirty page table size
    //

    ULONG DirtyPageTableSizeHint;

    //
    //  Reserved mapping we can use to map in user addresses
    //

    PVOID ReservedMapping;
    FAST_MUTEX ReservedMappingMutex;

#ifdef NTFS_CHECK_BITMAP
    PRTL_BITMAP BitmapCopy;
    ULONG BitmapPages;
#endif

#ifdef BENL_DBG
    LIST_ENTRY RestartRedoHead;
    LIST_ENTRY RestartUndoHead;
#endif

#ifdef SYSCACHE_DEBUG
    PSCB SyscacheScb;
#endif

#ifdef PERF_STATS

    //
    //  Create related
    //

    ULONG NumCreates;
    LONGLONG TimePerCreates;
    ULONG IosPerCreates;
    LONGLONG TimePerCreateIos;

    //
    //  Checkpoint related
    //

    CHECKPOINT_ENTRY ChkPointEntry[ NUM_CHECKPOINT_ENTRIES ];
    ULONG CurrentCheckpoint;

#endif

} VCB;
typedef VCB *PVCB;

#ifdef PERF_STATS
#define IRP_MN_CREATE_NEW 0xff
#endif

//
//  These are the VcbState flags.  Synchronized with the Vcb resource.
//

#define VCB_STATE_VOLUME_MOUNTED            (0x00000001)
#define VCB_STATE_LOCKED                    (0x00000002)
#define VCB_STATE_REMOVABLE_MEDIA           (0x00000004)
#define VCB_STATE_VOLUME_MOUNTED_DIRTY      (0x00000008)
#define VCB_STATE_RESTART_IN_PROGRESS       (0x00000010)
#define VCB_STATE_FLAG_SHUTDOWN             (0x00000020)
#define VCB_STATE_NO_SECONDARY_AVAILABLE    (0x00000040)
#define VCB_STATE_RELOAD_FREE_CLUSTERS      (0x00000080)
#define VCB_STATE_PRELOAD_MFT               (0x00000100)
#define VCB_STATE_VOL_PURGE_IN_PROGRESS     (0x00000200)
#define VCB_STATE_TEMP_VPB                  (0x00000400)
#define VCB_STATE_PERFORMED_DISMOUNT        (0x00000800)
#define VCB_STATE_VALID_LOG_HANDLE          (0x00001000)
#define VCB_STATE_DELETE_UNDERWAY           (0x00002000)
#define VCB_STATE_REDUCED_MFT               (0x00004000)
#define VCB_STATE_EXPLICIT_LOCK             (0x00008000)
#define VCB_STATE_DISALLOW_DISMOUNT         (0x00010000)
#define VCB_STATE_VALID_OBJECT_ID           (0x00020000)
#define VCB_STATE_OBJECT_ID_CLEANUP         (0x00040000)

#define VCB_STATE_USN_JOURNAL_ACTIVE        (0x00080000)
#define VCB_STATE_USN_DELETE                (0x00100000)
#define VCB_STATE_USN_JOURNAL_PRESENT       (0x00200000)
#define VCB_STATE_INCOMPLETE_USN_DELETE     (0x00400000)

#define VCB_STATE_EXPLICIT_DISMOUNT         (0x00800000)
#define VCB_STATE_LOCK_IN_PROGRESS          (0x01000000)
#define VCB_STATE_MOUNT_READ_ONLY           (0x02000000)

#define VCB_STATE_TARGET_DEVICE_STOPPED     (0x08000000)
#define VCB_STATE_MOUNT_COMPLETED           (0x10000000)

#define VCB_STATE_BAD_RESTART               (0x20000000)

//
//  These are the flags for the Mft and the reserveration state.
//  Although these are in the Vcb they are synchronized with
//  the resource in the MftScb.
//

#define VCB_MFT_RECORD_RESERVED             (0x00000001)
#define VCB_MFT_RECORD_15_USED              (0x00000002)

//
//  These are the MftDefragState flags.  Synchronized with the
//  CheckpointEvent.
//

#define VCB_MFT_DEFRAG_PERMITTED            (0x00000001)
#define VCB_MFT_DEFRAG_ENABLED              (0x00000002)
#define VCB_MFT_DEFRAG_TRIGGERED            (0x00000004)
#define VCB_MFT_DEFRAG_ACTIVE               (0x00000008)
#define VCB_MFT_DEFRAG_EXCESS_MAP           (0x00000010)

//
//  These are the Checkpoint flags.  Synchronized with the
//  CheckpointEvent.  These flags are in the CheckpointFlags
//  field.
//

#define VCB_DUMMY_CHECKPOINT_POSTED         (0x00000001)
#define VCB_CHECKPOINT_IN_PROGRESS          (0x00000002)
#define VCB_LAST_CHECKPOINT_CLEAN           (0x00000004)
#define VCB_DEREFERENCED_LOG_FILE           (0x00000008)
#define VCB_STOP_LOG_CHECKPOINT             (0x00000010)
#define VCB_LAST_CHECKPOINT_PSEUDO_CLEAN    (0x00000020)

#define VCB_CHECKPOINT_SYNC_FLAGS           (VCB_CHECKPOINT_IN_PROGRESS | VCB_STOP_LOG_CHECKPOINT)

//
//  These are Vcb quota state flags.  Synchronized with the
//  QuotaControlLock.  These flags are in the QuotaState field.
//

#define VCB_QUOTA_REPAIR_POSTED             (0x00000100)
#define VCB_QUOTA_CLEAR_RUNNING             (0x00000200)
#define VCB_QUOTA_INDEX_REPAIR              (0x00000300)
#define VCB_QUOTA_OWNER_VERIFY              (0x00000400)
#define VCB_QUOTA_RECALC_STARTED            (0x00000500)
#define VCB_QUOTA_DELETEING_IDS             (0x00000600)
#define VCB_QUOTA_REPAIR_RUNNING            (0x00000700)
#define VCB_QUOTA_SAVE_QUOTA_FLAGS          (0x00001000)

//
//  These are Vcb object id state flags.  Synchronized with the
//  ObjectIdTableScb->Resource.  These flags are in the ObjectIdState field.
//

#define VCB_OBJECT_ID_CORRUPT               (0x00000001)
#define VCB_OBJECT_ID_REPAIR_RUNNING        (0x00000002)

//
//  This is the maximum number of attributes in a file record which could
//  be considered for moving.  This value should be changed only in
//  conjunction with the initialization of the BigEnoughToMove field
//  above.
//

#define MAX_MOVEABLE_ATTRIBUTES          (3)

//
//  Define the file system statistics struct.  Vcb->Statistics points to an
//  array of these (one per processor) and they must be 64 byte aligned to
//  prevent cache line tearing.
//

typedef struct _FILE_SYSTEM_STATISTICS {

        //
        //  This contains the actual data.
        //

        FILESYSTEM_STATISTICS Common;
        NTFS_STATISTICS Ntfs;

        //
        //  Pad this structure to a multiple of 64 bytes.
        //

        UCHAR Pad[64-(sizeof(FILESYSTEM_STATISTICS)+sizeof(NTFS_STATISTICS))%64];

} FILE_SYSTEM_STATISTICS;

typedef FILE_SYSTEM_STATISTICS *PFILE_SYSTEM_STATISTICS;


//
//  The Volume Device Object is an I/O system device object with a
//  workqueue and an VCB record appended to the end.  There are multiple
//  of these records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload
//  of work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow
    //  queue.  The Overflow queue is a list of IRP's linked via the IRP's
    //  ListEntry field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  Event used to synchronize entry into the queue when its heavily used
    //

    KEVENT OverflowQueueEvent;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;
typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;



//
//  The following structure is used to perform a quick lookup of an
//  index entry for the update duplicate information call.
//

typedef struct _QUICK_INDEX {

    //
    //  Change count for the Scb Index stream when this snapshot is made.
    //

    ULONG ChangeCount;

    //
    //  This is the offset of the entry in the buffer.  A value of zero is
    //  used for an entry in the root index.
    //

    ULONG BufferOffset;

    //
    //  Captured Lsn for page containing this entry.
    //

    LSN CapturedLsn;

    //
    //  This is the IndexBlock for the index bucket.
    //

    LONGLONG IndexBlock;

} QUICK_INDEX;

typedef QUICK_INDEX *PQUICK_INDEX;

//
//  This structure is used to contain a link name and connections into
//  the splay tree for the parent.
//

typedef struct _NAME_LINK {

    UNICODE_STRING LinkName;
    RTL_SPLAY_LINKS Links;

} NAME_LINK, *PNAME_LINK;

//
//  The Lcb record corresponds to every open path between an Scb and an
//  Fcb.  It denotes the name which was used to go from the scb to the fcb
//  and it also contains a queue of ccbs that have opened the fcb via that
//  name and also a queue of Prefix Entries that will get us to this lcb
//

typedef struct _OVERLAY_LCB {

    //
    //  We will need a FILE_NAME_ATTR in order to lookup the entry
    //  for the UpdateDuplicateInfo calls.  We would like to keep
    //  one around but there are 0x38 bytes in it which will be unused.
    //  Instead we will overlay the Lcb with one of these.  Then we can
    //  store other data within the unused bytes.
    //
    //  NOTE - This will save an allocation but the sizes must match exactly
    //  or the name will be in the wrong location.  This structure will
    //  overlay a FILE_NAME attribute exactly.  The fields below which are
    //  prefaced with 'Overlay' correspond to the fields in the filename
    //  attribute which are being used with this structure.
    //
    //  We will put an assert in NtfsInit to verify this.
    //

    FILE_REFERENCE OverlayParentDirectory;

    //
    // On 32-bit systems the remainder of the structure members up to the
    // overlay entries previously occupied exactly the required amount of
    // space for the DUPLICATE_INFOMATION structure. On 64-bit systems,
    // this is not true and a little difference layout must be used.
    //

    union {

        DUPLICATED_INFORMATION Alignment;

        struct {

            //
            //  This is used for lookups in the directory containing this link.
            //

            QUICK_INDEX QuickIndex;

            //
            //  This is the number of references to this link.  The parent
            //  Scb must be owned to modify this count.
            //

            ULONG ReferenceCount;

            //
            //  These are the flags for the changes to this link and the
            //  change count for the duplicated information on this link.
            //

            ULONG InfoFlags;

            //
            //  Hash value for this Lcb.  Note - it is not guaranteed to be in the table.
            //

            ULONG HashValue;

            //
            //  This is the number of unclean handles on this link.
            //

            ULONG CleanupCount;

            //
            //  Internal reference to FileName attribute either embedded in overlay or external
            //  allocation (if size doesn't fit into storage).  On Win64 systems this will
            //  fill the overlay.  On Win32 systems we waste 4 bytes.
            //

            PFILE_NAME FileNameAttr;
        };
    };

    UCHAR OverlayFileNameLength;

    UCHAR OverlayFlags;

    WCHAR OverlayFileName[1];

} OVERLAY_LCB, *POVERLAY_LCB;

typedef struct _LCB {

    //
    //  Type and size of this record must be NTFS_NTC_LCB
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Internal state of the Lcb
    //

    ULONG LcbState;

    //
    //  The links for all the Lcbs that emminate out of an Scb and a
    //  pointer back to the Scb.  Corresponds to Scb->LcbQueue.
    //

    LIST_ENTRY ScbLinks;
    PSCB Scb;

    //
    //  The links for all the Lcbs that go into an Fcb and a pointer
    //  back to the Fcb.  Corresponds to Fcb->LcbQueue.
    //

    struct _FCB *Fcb;
    LIST_ENTRY FcbLinks;

    //
    //  The following is the case-insensitive name link.
    //

    NAME_LINK IgnoreCaseLink;

    //
    //  The following is the case-sensitive name link.
    //
    //  This field is here on the 64-bit system and in the overlay lcb
    //  structure on the 32-bit system.
    //

    NAME_LINK ExactCaseLink;

    //
    //  A queue of Ccbs that have the Fcb (via this edge) opened.
    //  Corresponds to Ccb->LcbLinks
    //

    LIST_ENTRY CcbQueue;

    //
    //  We will need a FILE_NAME_ATTR in order to lookup the entry
    //  for the UpdateDuplicateInfo calls.  We would like to keep
    //  one around but there are 0x38 bytes in it which will be unused.
    //  Instead we will overlay the Lcb with one of these.  Then we can
    //  store other data within the unused bytes.
    //
    //  NOTE - This will save an allocation but the sizes much match exactly
    //  or the name will be in the wrong location.
    //

    union {

        FILE_NAME;
        OVERLAY_LCB;
    };

} LCB;
typedef LCB *PLCB;

#define LCB_STATE_DELETE_ON_CLOSE        (0x00000001)
#define LCB_STATE_LINK_IS_GONE           (0x00000002)
#define LCB_STATE_EXACT_CASE_IN_TREE     (0x00000004)
#define LCB_STATE_IGNORE_CASE_IN_TREE    (0x00000008)
#define LCB_STATE_DESIGNATED_LINK        (0x00000010)
#define LCB_STATE_VALID_HASH_VALUE       (0x00000020)

#define LcbSplitPrimaryLink( LCB )                      \
    ((LCB)->FileNameAttr->Flags == FILE_NAME_NTFS       \
     || (LCB)->FileNameAttr->Flags == FILE_NAME_DOS )

#define LcbSplitPrimaryComplement( LCB )                \
    (((LCB)->FileNameAttr->Flags == FILE_NAME_NTFS) ?   \
     FILE_NAME_DOS : FILE_NAME_NTFS)

#define LcbLinkIsDeleted( LCB )                                                 \
    ((FlagOn( (LCB)->LcbState, LCB_STATE_DELETE_ON_CLOSE ))                     \
    || ((FlagOn( (LCB)->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS ))  \
    && (FlagOn((LCB)->Fcb->FcbState,FCB_STATE_PRIMARY_LINK_DELETED ))))

#define SIZEOF_LCB              (FIELD_OFFSET( LCB, FileName ) + sizeof( WCHAR ))

//
//  This structure serves as a Usn record buffer for a file, and also is linked
//  into the list of ModifiedOpenFiles to capture the lowest Modified Usn that has
//  not been through cleanup yet.
//
//  This structure is synchronized by the NtfsLockFcb for the file, however see
//  comments below for Fcb->FcbUsnRecord field.  The ModifiedOpenFiles list is
//  synchronized by NtfsLockFcb on the UsnJournal.
//

typedef struct _FCB_USN_RECORD {

    //
    //  Type and size of this record must be NTFS_NTC_USN
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer back to the Fcb
    //

    struct _FCB *Fcb;

    //
    //  Links for the aged OpenFiles queue.  This is used to generate close records
    //  for files which are idle but have pending changes to report.  Prime example is
    //  mapped page write where MM doesn't dereference the file object for an extended
    //  period of time.  A NULL flink indicates it is not in this queue.
    //

    LIST_ENTRY TimeOutLinks;

    //
    //  Links for the Vcb ModifiedOpenFiles list.
    //

    LIST_ENTRY ModifiedOpenFilesLinks;

    //
    //  The Usn Record buffer.
    //

    USN_RECORD UsnRecord;

} FCB_USN_RECORD;
typedef FCB_USN_RECORD *PFCB_USN_RECORD;


//
//  The Fcb record corresponds to every open file and directory, and to
//  every directory on an opened path.
//
//  The structure is really divided into two parts.  FCB can be allocated
//  from paged pool while the SCB must be allocated from non-paged
//  pool.  There is an SCB for every file stream associated with the Fcb.
//
//  Note that the Fcb, multiple Scb records all use the same resource so
//  if we need to grab exclusive access to the Fcb we only need to grab
//  one resource and we've blocked all the scbs
//

typedef struct _FCB {

    //
    //  Type and size of this record must be NTFS_NTC_FCB
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The internal state of the Fcb.
    //  Sync: Some flags are set on creation and then left.  Safe to test at any time.
    //        Otherwise use Fcb X | Fcb S with Fcb mutex to change.  Critical flags which
    //        reflect state of file (DELETED, etc) will always be changed with Fcb X.
    //

    ULONG FcbState;

    //
    //  The following field contains the file reference for the Fcb
    //

    FILE_REFERENCE FileReference;

    //
    //  A count of the number of file objects that have been opened for
    //  this file, but not yet been cleaned up yet.
    //  This count gets decremented in NtfsCommonCleanup,
    //  while the CloseCount below gets decremented in NtfsCommonClose.
    //  Sync: Vcb X | Vcb S and Fcb X.
    //

    CLONG CleanupCount;

    //
    //  A count of the number of file objects that have opened
    //  this file.
    //  Sync: Use InterlockedIncrement/Decrement to change.  Critical users
    //  have Vcb X | Vcb S and Fcb X.  Other callers will temporarily increment
    //  and decrement this value but they always start at a non-zero value.
    //

    CLONG CloseCount;

    //
    //  A count of other references to this Fcb.
    //  Sync: Use the FcbTable mutex in Vcb.
    //

    CLONG ReferenceCount;

    //
    //  Relevant counts for delete checking.
    //

    ULONG FcbDenyDelete;
    ULONG FcbDeleteFile;

    //
    //  This is the count of the number of times the current transaction
    //  has acquired the main resource.
    //

    USHORT BaseExclusiveCount;

    //
    //  This counts the number of times the Ea's on this file have been
    //  modified.
    //

    USHORT EaModificationCount;

    //
    //  The Queue of all the Lcb that we are part of.  The list is
    //  actually ordered in a small sense.  The get next scb routine that
    //  traverses the Fcb/Scb graph always will put the current lcb edge
    //  that it is traversing into the front of this queue.
    //

    LIST_ENTRY LcbQueue;

    //
    //  A queue of Scb associated with the fcb.  Corresponds to Scb->FcbLinks.
    //  Sync: Must own Fcb X | Fcb S with FcbMutex.
    //

    LIST_ENTRY ScbQueue;

    //
    //  These are the links for the list of exclusively-owned Scbs off of
    //  the IrpContext.  We need to keep track of the exclusive count
    //  in the Fcb before our acquire so we know how many times to release
    //  it.
    //

    LIST_ENTRY ExclusiveFcbLinks;

    //
    //  A pointer to the Vcb containing this Fcb
    //

    PVCB Vcb;

    //
    //  Fast Mutex used to synchronize access to Fcb fields.  This is also used as
    //  the fast mutex for the individual Scb's except for those that may need their
    //  own (Mft, PagingFile, AttributeList).
    //

    PFAST_MUTEX FcbMutex;

    //
    //  The following field is used to store a pointer to the resource
    //  protecting the Fcb
    //

    PERESOURCE Resource;

    //
    //  The following field contains a pointer to the resource
    //  synchronizing a changing FileSize with paging Io.
    //

    PERESOURCE PagingIoResource;

    //
    //  Copy of the duplicated information for this Fcb.
    //  Also a flags field to tell us what has changed in the structure.
    //

    DUPLICATED_INFORMATION Info;
    ULONG InfoFlags;

    //
    //  LinkCount is the number of non deleted links to the file
    //  TotalLinks is the number of total links - including deleted ones
    //

    USHORT LinkCount;
    USHORT TotalLinks;

    //
    //  This is the actual last access for the main stream of this file.
    //  We don't store it in the duplicated information until we are ready
    //  to write it out to disk.  Whenever we update the standard
    //  information we will copy the data out of the this field into the
    //  duplicate information.
    //

    LONGLONG CurrentLastAccess;

    //
    //  The following fields contains a pointer to the security descriptor
    //  for this file.  The field can start off null and later be loaded
    //  in by any of the security support routines.  On delete Fcb the
    //  field pool should be deallocated when the fcb goes away
    //

    struct _SHARED_SECURITY *SharedSecurity;

    //
    //  Pointer to the Quota Control block for the file.
    //

    struct _QUOTA_CONTROL_BLOCK *QuotaControl;

    //
    //  The Lsn to flush to before allowing any data to hit the disk.  Synchronized
    //  by NtfsLockFcb on this file.
    //

    LSN UpdateLsn;

    //
    //  Id for file owner, from bidir security index
    //

    ULONG OwnerId;

    //
    //  This is the count of file objects for this Fcb on the delayed
    //  close queue.  Used to determine whether we need to dereference
    //  a file object we create in the compressed write path.
    //  Synchronize this field with the interlocked routines.
    //

    ULONG DelayedCloseCount;

    //
    //  SecurityId for the file - translates via bidir index to
    //  granted access Acl.
    //

    ULONG SecurityId;

    //
    //  Update sequence number for this file.
    //

    USN Usn;

    //
    //  Pointer to the Usn Record buffer for this Fcb, or NULL if none is
    //  yet allocated.  To test or dereference this field, you must either
    //  have the main file resource at least shared (because NtfsSetRenameInfo
    //  will reallocate this structure.), or else NtfsLockFcb on the file.  To
    //  modify the fields of this record, see comments above.
    //

    PFCB_USN_RECORD FcbUsnRecord;

    //
    //  Pointer to a context pointer to track operations in recursive calls.
    //  Lifespan of this pointer is typically a single request.
    //

    struct _FCB_CONTEXT *FcbContext;

} FCB;
typedef FCB *PFCB;

#define FCB_STATE_FILE_DELETED           (0x00000001)
#define FCB_STATE_NONPAGED               (0x00000002)
#define FCB_STATE_PAGING_FILE            (0x00000004)
#define FCB_STATE_DUP_INITIALIZED        (0x00000008)
#define FCB_STATE_UPDATE_STD_INFO        (0x00000010)
#define FCB_STATE_PRIMARY_LINK_DELETED   (0x00000020)
#define FCB_STATE_IN_FCB_TABLE           (0x00000040)
#define FCB_STATE_SYSTEM_FILE            (0x00000100)
#define FCB_STATE_COMPOUND_DATA          (0x00000200)
#define FCB_STATE_COMPOUND_INDEX         (0x00000400)
#define FCB_STATE_LARGE_STD_INFO         (0x00000800)
#define FCB_STATE_MODIFIED_SECURITY      (0x00001000)
#define FCB_STATE_DIRECTORY_ENCRYPTED    (0x00002000)
#define FCB_STATE_VALID_USN_NAME         (0x00004000)
#define FCB_STATE_USN_JOURNAL            (0x00008000)
#define FCB_STATE_ENCRYPTION_PENDING     (0x00010000)

#define FCB_INFO_CHANGED_CREATE          FILE_NOTIFY_CHANGE_CREATION        //  (0x00000040)
#define FCB_INFO_CHANGED_LAST_MOD        FILE_NOTIFY_CHANGE_LAST_WRITE      //  (0x00000010)
#define FCB_INFO_CHANGED_LAST_CHANGE     (0x80000000)
#define FCB_INFO_CHANGED_LAST_ACCESS     FILE_NOTIFY_CHANGE_LAST_ACCESS     //  (0x00000020)
#define FCB_INFO_CHANGED_ALLOC_SIZE      (0x40000000)
#define FCB_INFO_CHANGED_FILE_SIZE       FILE_NOTIFY_CHANGE_SIZE            //  (0x00000008)
#define FCB_INFO_CHANGED_FILE_ATTR       FILE_NOTIFY_CHANGE_ATTRIBUTES      //  (0x00000004)
#define FCB_INFO_CHANGED_EA_SIZE         FILE_NOTIFY_CHANGE_EA              //  (0x00000080)

#define FCB_INFO_MODIFIED_SECURITY       FILE_NOTIFY_CHANGE_SECURITY        //  (0x00000100)
#define FCB_INFO_UPDATE_LAST_ACCESS      (0x20000000)

//
//  Subset of the Fcb Info flags used to track duplicate info.
//

#define FCB_INFO_DUPLICATE_FLAGS         (FCB_INFO_CHANGED_CREATE      | \
                                          FCB_INFO_CHANGED_LAST_MOD    | \
                                          FCB_INFO_CHANGED_LAST_CHANGE | \
                                          FCB_INFO_CHANGED_LAST_ACCESS | \
                                          FCB_INFO_CHANGED_ALLOC_SIZE  | \
                                          FCB_INFO_CHANGED_FILE_SIZE   | \
                                          FCB_INFO_CHANGED_FILE_ATTR   | \
                                          FCB_INFO_CHANGED_EA_SIZE )

//
//  Subset of the Fcb Info flags used to track notifies.
//

#define FCB_INFO_NOTIFY_FLAGS            (FCB_INFO_CHANGED_CREATE      | \
                                          FCB_INFO_CHANGED_LAST_MOD    | \
                                          FCB_INFO_CHANGED_LAST_ACCESS | \
                                          FCB_INFO_CHANGED_ALLOC_SIZE  | \
                                          FCB_INFO_CHANGED_FILE_SIZE   | \
                                          FCB_INFO_CHANGED_FILE_ATTR   | \
                                          FCB_INFO_CHANGED_EA_SIZE     | \
                                          FCB_INFO_MODIFIED_SECURITY )

//
//  Subset of the Fcb Info flags used to track notifies.  The allocation flag
//  is removed from the full notify flags because dir notify overloads
//  the file size flag for allocation and file size.
//

#define FCB_INFO_VALID_NOTIFY_FLAGS      (FCB_INFO_CHANGED_CREATE      | \
                                          FCB_INFO_CHANGED_LAST_MOD    | \
                                          FCB_INFO_CHANGED_LAST_ACCESS | \
                                          FCB_INFO_CHANGED_FILE_SIZE   | \
                                          FCB_INFO_CHANGED_FILE_ATTR   | \
                                          FCB_INFO_CHANGED_EA_SIZE     | \
                                          FCB_INFO_MODIFIED_SECURITY )

#define FCB_CREATE_SECURITY_COUNT        (5)
#define FCB_LARGE_ACL_SIZE               (512)

//
//  Fcb Context structure.  If a pointer to one of these is in the Fcb then recursive calls will update
//  it as appropriate.
//

typedef struct _FCB_CONTEXT {

    BOOLEAN FcbDeleted;

} FCB_CONTEXT, *PFCB_CONTEXT;


//
//  The following three structures are the separate union structures for
//  Scb structure.
//

typedef enum _RWC_OPERATION {

    SetDirty = 0,
    FullOverwrite,
    StartOfWrite,
    StartOfRead,
    EndOfRead,
    ReadUncompressed,
    ReadZeroes,
    PartialBcb,
    WriteCompressed,
    FaultIntoUncompressed,
    TrimCopyRead,
    ZeroCompressedRead,
    TrimCompressedRead,
    TrimCompressedWrite

} RWC_OPERATION;

#ifdef NTFS_RWC_DEBUG
typedef struct _RWC_HISTORY_ENTRY {

    ULONG Operation;
    ULONG Information;
    ULONG FileOffset;
    ULONG Length;

} RWC_HISTORY_ENTRY, *PRWC_HISTORY_ENTRY;

#define MAX_RWC_HISTORY_INDEX       (300)
#endif

typedef struct _SCB_DATA {

    //
    //  Total number of reserved bytes
    //

    LONGLONG TotalReserved;

    //
    //  The following field is used by the oplock module
    //  to maintain current oplock information.
    //

    OPLOCK Oplock;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //

    PFILE_LOCK FileLock;

    //
    //  List of wait for length blocks, for threads waiting for the
    //  file to exceed the specified length.
    //

    LIST_ENTRY WaitForNewLength;

#ifdef COMPRESS_ON_WIRE

    //
    //  List of compression synchronization objects.
    //

    LIST_ENTRY CompressionSyncList;

#endif

    //
    //  Pointer to an Mcb describing the reserved space for
    //  dirty compression units in compressed files which do
    //  not currently have a user section.
    //

    PRESERVED_BITMAP_RANGE ReservedBitMap;

#ifdef NTFS_RWC_DEBUG

    ULONG RwcIndex;
    PRWC_HISTORY_ENTRY HistoryBuffer;
#endif

} SCB_DATA, *PSCB_DATA;

typedef struct _SCB_INDEX {

    //
    //  This is a list of records within the index allocation stream which
    //  have been deallocated in the current transaction.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  Record allocation context, for managing the allocation of the
    //  INDEX_ALLOCATION_ATTRIBUTE, if one exists.
    //

    RECORD_ALLOCATION_CONTEXT RecordAllocationContext;

    //
    //  A queue of all the lcbs that are opened under this Scb.
    //  Corresponds to Lcb->ScbLinks
    //

    LIST_ENTRY LcbQueue;

    //
    //  The following are the splay links of Lcbs opened under this
    //  Scb.  Note that not all of the Lcb in the list above may
    //  be in the splay links below.
    //

    PRTL_SPLAY_LINKS ExactCaseNode;
    PRTL_SPLAY_LINKS IgnoreCaseNode;

    //
    //  Normalized name.  This is the path from the root to this directory
    //  without any of the short-name-only links.  The hash value is based
    //  on this NormalizedName.
    //
    //  The normalized name can be in an indeterminant state.  If the length is zero
    //  then the name is invalid (there should be no hash value at that point).  However
    //  the MaximumLength and Buffer could still be present.  A non-NULL buffer indicates
    //  that there is cleanup that needs to be done.  Anybody changing this field should
    //  hold the hash mutex, this means swapping the buffers or changing the length field.
    //  Anyone changing the name on the file should hold the main resource exclusive of
    //  course.
    //

    UNICODE_STRING NormalizedName;

#ifdef BENL_DBG
    UNICODE_STRING NormalizedRelativeName;
    ULONG FullNormalizedPathLength;
#endif

    ULONG HashValue;

    //
    //  A change count incremented every time an index buffer is deleted.
    //

    ULONG ChangeCount;

    //
    //  Define a union to distinguish directory indices from view indices
    //

    union {

        //
        //  For directories we store the following.
        //

        struct {

            //
            //  Type of attribute being indexed.
            //

            union {
                ATTRIBUTE_TYPE_CODE AttributeBeingIndexed;
                PVOID Alignment;
            };

            //
            //  Collation rule, for how the indexed attribute is collated.
            //

            ULONG_PTR CollationRule;
        };

        //
        //  For view indexes we store the CollationFunction and data.
        //

        struct {

            PCOLLATION_FUNCTION CollationFunction;
            PVOID CollationData;
        };
    };

    //
    //  Size of Index Allocation Buffer in bytes, or 0 if not yet
    //  initialized.
    //

    ULONG BytesPerIndexBuffer;

    //
    //  Size of Index Allocation Buffers in units of blocks, or 0
    //  if not yet initialized.
    //

    UCHAR BlocksPerIndexBuffer;

    //
    //  Shift value when converting from index blocks to bytes.
    //

    UCHAR IndexBlockByteShift;

    //
    //  Flag to indicate whether the RecordAllocationContext has been
    //  initialized or not.  If it is not initialized, this means
    //  either that there is no external index allocation, or that
    //  it simply has not been initialized yet.
    //

    BOOLEAN AllocationInitialized;

    UCHAR PadUchar;

    //
    //  Index Depth Hint
    //

    USHORT IndexDepthHint;

    USHORT PadUshort;

} SCB_INDEX, *PSCB_INDEX;

typedef struct _SCB_MFT {

    //
    //  NOTE - The following fields must be in the same positions in the Index and Mft
    //  specific extensions.
    //
    //      RecentlyDeallocatedQueue
    //      RecordAllocationContext
    //

    //
    //  This is a list of records within the Mft Scb stream which
    //  have been deallocated in the current transaction.
    //

    LIST_ENTRY RecentlyDeallocatedQueue;

    //
    //  Record allocation context, for managing the allocation of the
    //  INDEX_ALLOCATION_ATTRIBUTE, if one exists.
    //

    RECORD_ALLOCATION_CONTEXT RecordAllocationContext;

    //
    //  The following Mcb's are used to track clusters being added and
    //  removed from the Mcb for the Scb.  This Scb must always be fully
    //  loaded after an abort.  We can't depend on reloading on the next
    //  LookupAllocation call.  Instead we keep one Mcb with the clusters
    //  added and one Mcb with the clusters removed.  During the restore
    //  phase of abort we will adjust the Mft Mcb by reversing the
    //  operations done during the transactions.
    //

    LARGE_MCB AddedClusters;
    LARGE_MCB RemovedClusters;

    //
    //  The following are the changes made to the Mft file as file records
    //  are added, freed or allocated.  Also the change in the number of
    //  file records which are part of holes.
    //

    LONG FreeRecordChange;
    LONG HoleRecordChange;

    //
    //  The following field contains the index of a reserved free record.  To
    //  keep us out of the chicken & egg problem of the Mft being able to
    //  be self mapping we added the ability to reserve an mft record
    //  to describe additional mft data allocation within previous mft
    //  run.  A value of zero means that index has not been reserved.
    //

    ULONG ReservedIndex;

    ULONG PadUlong;

} SCB_MFT, *PSCB_MFT;

//
//  The following is the non-paged part of the scb.
//

typedef struct _SCB_NONPAGED {

    //
    //  Type and size of this record must be NTFS_NTC_SCB_NONPAGED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Index allocated for this file in the Open Attribute Table.
    //

    ULONG OpenAttributeTableIndex;
    ULONG OnDiskOatIndex;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to
    //  point to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  Copy of the Vcb pointer so we can find the Vcb in the dirty page
    //  callback routine.
    //

    PVCB Vcb;
#ifdef  COMPRESS_ON_WIRE
    SECTION_OBJECT_POINTERS SegmentObjectC;
#endif

} SCB_NONPAGED, *PSCB_NONPAGED;


//
//  The following are structures used only in syscache debugging privates
//


#define SCE_VDL_CHANGE          0
#define SCE_ZERO_NC             1
#define SCE_ZERO_C              2
#define SCE_READ                3
#define SCE_WRITE               4
#define SCE_ZERO_CAV            5
#define SCE_ZERO_MF             6
#define SCE_ZERO_FST            7
#define SCE_CC_FLUSH            8
#define SCE_CC_FLUSH_AND_PURGE  9
#define SCE_WRITE_FILE_SIZES   10
#define SCE_ADD_ALLOCATION     11
#define SCE_ADD_SP_ALLOCATION  12
#define SCE_SETCOMP_ADD_ALLOCATION     13
#define SCE_SETSPARSE_ADD_ALLOCATION   14
#define SCE_MOD_ATTR_ADD_ALLOCATION    15
#define SCE_REALLOC1                   16
#define SCE_REALLOC2                   17
#define SCE_REALLOC3                   18
#define SCE_SETCOMPRESS                19
#define SCE_SETSPARSE                  20
#define SCE_ZERO_STREAM                21
#define SCE_VDD_CHANGE                 22
#define SCE_CC_SET_SIZE                23
#define SCE_ZERO_TAIL_COMPRESSED       24
#define SCE_ZERO_HEAD_COMPRESSED       25
#define SCE_TRIM_WRITE                 26
#define SCE_DISK_FULL                  27
#define SCE_SKIP_PURGE                 28
#define SCE_ZERO_HEAD_SECTOR           29

#define SCE_MAX_EVENT           30


#define SCE_FLAG_WRITE 0x1
#define SCE_FLAG_READ  0x2
#define SCE_FLAG_PAGING 0x4
#define SCE_FLAG_ASYNC  0x8
#define SCE_FLAG_SET_ALLOC 0x10
#define SCE_FLAG_SET_EOF   0x20
#define SCE_FLAG_CANT_WAIT 0x40
#define SCE_FLAG_SYNC_PAGING 0x80
#define SCE_FLAG_LAZY_WRITE 0x100
#define SCE_FLAG_CACHED 0x200
#define SCE_FLAG_ON_DISK_READ 0x400
#define SCE_FLAG_RECURSIVE  0x800
#define SCE_FLAG_NON_CACHED  0x1000
#define SCE_FLAG_UPDATE_FROM_DISK  0x2000
#define SCE_FLAG_SET_VDL 0x4000
#define SCE_FLAG_COMPLETION 0x8000
#define SCE_FLAG_COMPRESSED 0x10000
#define SCE_FLAG_FASTIO 0x20000
#define SCE_FLAG_ZERO 0x40000
#define SCE_FLAG_PREPARE_BUFFERS 0x80000
#define SCE_FLAG_END_BUFFER 0x100000
#define SCE_FLAG_MDL 0x200000
#define SCE_FLAG_SUB_WRITE 0x400000

#define SCE_MAX_FLAG   0x800000

#define NUM_SC_EVENTS 100
#define NUM_SC_LOGSETS 35

typedef struct _SYSCACHE_LOG {
    int            Event;
    int            Flags;
    LONGLONG       Start;
    LONGLONG       Range;
    LONGLONG       Result;
//    ULONG          ulDump;
} SYSCACHE_LOG, *PSYSCACHE_LOG;

typedef struct _ON_DISK_SYSCACHE_LOG {
    ULONG  SegmentNumberUnsafe;
    SYSCACHE_LOG;
} ON_DISK_SYSCACHE_LOG, *PON_DISK_SYSCACHE_LOG;

typedef struct _SYSCACHE_LOG_SET {
    PSCB            Scb;
    PSYSCACHE_LOG   SyscacheLog;
    ULONG           SegmentNumberUnsafe;
} SYSCACHE_LOG_SET, PSYSCACHE_LOG_SET;


#if defined( SYSCACHE_DEBUG ) || defined( SYSCACHE_DEBUG_ALLOC )

//
//  Global set of syscache logs
//

SYSCACHE_LOG_SET NtfsSyscacheLogSet[NUM_SC_LOGSETS];
LONG             NtfsCurrentSyscacheLogSet;
LONG             NtfsCurrentSyscacheOnDiskEntry;

#endif


//
//  The following structure is the stream control block.  There can
//  be multiple records per fcb.  One is created for each attribute being
//  handled as a stream file.
//

typedef struct _SCB {

    //
    //  The following field is used for fast I/O.  It contains the node
    //  type code and size, indicates if fast I/O is possible, contains
    //  allocation, file, and valid data size, a resource, and call back
    //  pointers for FastIoRead and FastMdlRead.
    //
    //  The node type codes for the Scb must be either NTFS_NTC_SCB_INDEX,
    //  NTFS_NTC_SCB_ROOT_INDEX, or NTFS_NTC_SCB_DATA.  Which one it is
    //  determines the state of the union below.
    //

    NTFS_ADVANCED_FCB_HEADER Header;

    //
    //  The links for the queue of Scb off of a given Fcb.  And a pointer
    //  back to the Fcb.  Corresponds to Fcb->ScbQueue
    //

    LIST_ENTRY FcbLinks;
    PFCB Fcb;

    //
    //  A pointer to the Vcb containing this Scb
    //

    PVCB Vcb;

    //
    //  The internal state of the Scb.
    //

    ULONG ScbState;

    //
    //  A count of the number of file objects opened on this stream
    //  which represent user non-cached handles.  We use this count to
    //  determine when to flush and purge the data section in only
    //  non-cached handles remain on the file.
    //

    CLONG NonCachedCleanupCount;

    //
    //  A count of the number of file objects that have been opened for
    //  this attribute, but not yet been cleaned up yet.
    //  This count gets decremented in NtfsCommonCleanup,
    //  while the CloseCount below gets decremented in NtfsCommonClose.
    //

    CLONG CleanupCount;

    //
    //  A count of the number of file objects that have opened
    //  this attribute.
    //

    CLONG CloseCount;

    //
    //  Share Access structure for this stream.
    //

    SHARE_ACCESS ShareAccess;

    //
    //  The following two fields identify the actual attribute for this
    //  Scb with respect to its file.   We identify the attribute by
    //  its type code and name.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    UNICODE_STRING AttributeName;

    //
    //  Stream File Object for internal use.  This field is NULL if the
    //  file stream is not being accessed internally.
    //

    PFILE_OBJECT FileObject;

    //
    //  These pointers are used to detect writes that eminated from the
    //  cache manager's worker thread.  It prevents lazy writer threads,
    //  who already have the Fcb shared, from trying to acquire it
    //  exclusive, and thus causing a deadlock.  We have to store two
    //  threads, because the second thread could be writing the compressed
    //  stream
    //

#ifdef COMPRESS_ON_WIRE
    PVOID LazyWriteThread[2];
#endif

    //
    //  Pointer to the non-paged section objects and open attribute
    //  table index.
    //

    PSCB_NONPAGED NonpagedScb;

    //
    //  The following field contains the mcb for this Scb and some initial
    //  structures for small and medium files.
    //

    NTFS_MCB Mcb;
    NTFS_MCB_INITIAL_STRUCTS McbStructs;

    //
    //  Compression unit from attribute record.
    //

    ULONG CompressionUnit;

    //
    //  AttributeFlags and CompressionUnitShift from attribute record
    //

    USHORT AttributeFlags;
    UCHAR CompressionUnitShift;
    UCHAR PadUchar;

    //
    //  Valid Data to disk - as updated by NtfsPrepareBuffers
    //

    LONGLONG ValidDataToDisk;

    //
    //  Actual allocated bytes for this file.
    //

    LONGLONG TotalAllocated;

    //
    //  Used by advanced Scb Header
    //

    LIST_ENTRY EofListHead;

    //
    //  Link of all Ccb's that were created for this Scb
    //

    LIST_ENTRY CcbQueue;

    //
    //  Pointer to structure containing snapshotted Scb values, or NULL
    //  if the values have not been snapshotted.
    //

    struct _SCB_SNAPSHOT * ScbSnapshot;

    //
    //  Pointer to encryption context and length.
    //

    PVOID EncryptionContext;
    ULONG EncryptionContextLength;

    //
    //  Persistent Scb flags.  These are set and cleared synchronized with
    //  the main resource and tend to remain in the same state.
    //

    ULONG ScbPersist;

#if (DBG || defined( NTFS_FREE_ASSERTS ))

    //
    //  Keep the thread ID of the thread owning IO at EOF.
    //

    PERESOURCE_THREAD IoAtEofThread;
#endif

#ifdef  SYSCACHE_DEBUG

    int            SyscacheLogEntryCount;
    LONG           CurrentSyscacheLogEntry;
    SYSCACHE_LOG * SyscacheLog;
    LONG           LogSetNumber;
#endif

    //
    //  Scb Type union, for different types of Scbs
    //

    union {

        SCB_DATA Data;
        SCB_INDEX Index;
        SCB_MFT Mft;

    } ScbType;

} SCB;
typedef SCB *PSCB;

#define SIZEOF_SCB_DATA \
    (FIELD_OFFSET(SCB,ScbType)+sizeof(SCB_DATA))

#define SIZEOF_SCB_INDEX      \
    (FIELD_OFFSET(SCB,ScbType)+sizeof(SCB_INDEX))

#define SIZEOF_SCB_MFT        \
    (FIELD_OFFSET(SCB,ScbType)+sizeof(SCB_MFT))

//
//  The following flags are bits in the ScbState field.
//

#define SCB_STATE_TRUNCATE_ON_CLOSE         (0x00000001)
#define SCB_STATE_DELETE_ON_CLOSE           (0x00000002)
#define SCB_STATE_CHECK_ATTRIBUTE_SIZE      (0x00000004)
#define SCB_STATE_ATTRIBUTE_RESIDENT        (0x00000008)
#define SCB_STATE_UNNAMED_DATA              (0x00000010)
#define SCB_STATE_HEADER_INITIALIZED        (0x00000020)
#define SCB_STATE_NONPAGED                  (0x00000040)
#define SCB_STATE_USA_PRESENT               (0x00000080)
#define SCB_STATE_ATTRIBUTE_DELETED         (0x00000100)
#define SCB_STATE_FILE_SIZE_LOADED          (0x00000200)
#define SCB_STATE_MODIFIED_NO_WRITE         (0x00000400)
#define SCB_STATE_SUBJECT_TO_QUOTA          (0x00000800)
#define SCB_STATE_UNINITIALIZE_ON_RESTORE   (0x00001000)
#define SCB_STATE_RESTORE_UNDERWAY          (0x00002000)
#define SCB_STATE_NOTIFY_ADD_STREAM         (0x00004000)
#define SCB_STATE_NOTIFY_REMOVE_STREAM      (0x00008000)
#define SCB_STATE_NOTIFY_RESIZE_STREAM      (0x00010000)
#define SCB_STATE_NOTIFY_MODIFY_STREAM      (0x00020000)
#define SCB_STATE_TEMPORARY                 (0x00040000)
#define SCB_STATE_WRITE_COMPRESSED          (0x00080000)
#define SCB_STATE_REALLOCATE_ON_WRITE       (0x00100000)
#define SCB_STATE_DELAY_CLOSE               (0x00200000)
#define SCB_STATE_WRITE_ACCESS_SEEN         (0x00400000)
#define SCB_STATE_CONVERT_UNDERWAY          (0x00800000)
#define SCB_STATE_VIEW_INDEX                (0x01000000)
#define SCB_STATE_DELETE_COLLATION_DATA     (0x02000000)
#define SCB_STATE_VOLUME_DISMOUNTED         (0x04000000)
#define SCB_STATE_PROTECT_SPARSE_MCB        (0x08000000)
#define SCB_STATE_MULTIPLE_OPENS            (0x10000000)
#define SCB_STATE_COMPRESSION_CHANGE        (0x20000000)
#define SCB_STATE_WRITE_FILESIZE_ON_CLOSE   (0x40000000)

//
//  The following flags are bits in the ScbPersist field.
//

#define SCB_PERSIST_USN_JOURNAL             (0x00000001)
#define SCB_PERSIST_DENY_DEFRAG             (0x00000002)

#ifdef SYSCACHE_DEBUG
#define SCB_PERSIST_SYSCACHE_DIR            (0x80000000)
#endif

#ifdef SYSCACHE

//
//  Note: this flag's value is now superseded by SCB_STATE_WRITE_FILESIZE_ON_CLOSE
//  code must be modified if this is to be used again
//

#define SCB_STATE_SYSCACHE_FILE             (0x80000000)

#define SYSCACHE_SET_FILE_SIZE              (0x00000001)
#define SYSCACHE_SET_ALLOCATION_SIZE        (0x00000002)
#define SYSCACHE_PAGING_WRITE               (0x00000003)
#define SYSCACHE_NORMAL_WRITE               (0x00000004)

//
//  Syscache event list element.
//

typedef struct _SYSCACHE_EVENT {

    //
    //  Corresponds to scb_data's SyscacheEventList
    //

    LIST_ENTRY EventList;

    //
    //  Choose from SYSCACHE_PAGING_WRITE, etc.
    //

    ULONG EventTypeCode;

    ULONG Pad;

    //
    //  Write start & size, or truncate point & junk, etc.  Unionize?
    //

    LONGLONG Data1;
    LONGLONG Data2;

} SYSCACHE_EVENT;

typedef SYSCACHE_EVENT *PSYSCACHE_EVENT;
#endif

//
//  Determine whether an attribute type code can be compressed.  The current
//  implementation of Ntfs does not allow logged streams to be compressed.
//

#define NtfsIsTypeCodeCompressible(C)   ((C) == $DATA)

//
//  Determine whether an attribute type code can be encrypted.  The current
//  implementation of Ntfs does not allow logged streams to be encrypted.
//

#define NtfsIsTypeCodeEncryptible(C)    ((C) == $DATA)

//
//  Detect whether an attribute contains user data
//

#define NtfsIsTypeCodeUserData(C)       ((C) == $DATA)


//
//  Detect whether an attribute should be subject to quota enforcement
//

#define NtfsIsTypeCodeSubjectToQuota(C) NtfsIsTypeCodeUserData(C)

//
//  Detect whether an attribute is a logged utility stream
//

#define NtfsIsTypeCodeLoggedUtilityStream(C)   ((C) == $LOGGED_UTILITY_STREAM)

//
//  Define FileObjectFlags flags that should be propagated to stream files
//  so that the Cache Manager will see them.
//

#define NTFS_FO_PROPAGATE_TO_STREAM         (FO_SEQUENTIAL_ONLY | FO_TEMPORARY_FILE)


//
//  Structure to contain snapshotted Scb values for error recovery.
//

typedef struct _SCB_SNAPSHOT {

    //
    //  Links for list snapshot structures off of IrpContext
    //

    LIST_ENTRY SnapshotLinks;

    //
    //  Saved values of the corresponding Scb (or FsRtl Header) fields
    //  The low bit of allocation size is set to remember when the
    //  attribute was resident.  The next bit, bit 1, is set to remember
    //  when the attribute was compressed.
    //

    LONGLONG AllocationSize;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;
    LONGLONG ValidDataToDisk;
    LONGLONG TotalAllocated;

    VCN LowestModifiedVcn;
    VCN HighestModifiedVcn;

    //
    //  Pointer to the Scb which has been snapped.
    //

    PSCB Scb;

    //
    // Used to hold the Scb State.
    //

    ULONG ScbState;

    //
    //  IrpContext that owns the snapshot and can use it to rollback the values
    //

    PIRP_CONTEXT OwnerIrpContext;

} SCB_SNAPSHOT;
typedef SCB_SNAPSHOT *PSCB_SNAPSHOT;


//
//  The Ccb record is allocated for every file object.  This is the full
//  CCB including the index-specific fields.
//

typedef struct _CCB {

    //
    //  Type and size of this record (must be NTFS_NTC_CCB_DATA or
    //  NTFS_NTC_CCB_INDEX)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Ccb flags.
    //

    ULONG Flags;

    //
    //  This is a unicode string for the full filename used to
    //  open this file.
    //  We use InterlockedExchange of pointers to synchronize this
    //  field between NtfsFsdClose and NtfsUpdateFileDupInfo.
    //

    UNICODE_STRING FullFileName;
    USHORT LastFileNameOffset;

    //
    //  This is the Ccb Ea modification count.  If this count is in
    //  sync with the Fcb value, then the above offset is valid.
    //

    USHORT EaModificationCount;

    //
    //  This is the offset of the next Ea to return to the user.
    //

    ULONG NextEaOffset;

    //
    //  The links for the queue of Ccb off of a given Lcb and a pointer
    //  back to the Lcb.  Corresponds to Lcb->CcbQueue
    //

    LIST_ENTRY LcbLinks;
    PLCB Lcb;

    //
    //  The links for the queue of Ccb's off a given Scb.  Corresponds to
    //  Scb->CcbQueue
    //

    LIST_ENTRY CcbLinks;

    //
    //  Type of Open for this Ccb
    //

    UCHAR TypeOfOpen;
    UCHAR Reserved;

    //
    //  Count of the number of times this handle has extended the stream through
    //  writes.
    //

    USHORT WriteExtendCount;

    //
    //  Keeps the owner id of the opener.  Used by quota to determine the
    //  amount of free space.
    //

    ULONG OwnerId;

    //
    //  Last returned owner id.  Used by QueryQuotaInformationFile.
    //

    ULONG LastOwnerId;

    //
    //  Usn source information for this handle.
    //

    ULONG UsnSourceInfo;

    //
    //  Flags specifying the type of access granted for this handle.
    //  The flags, such as BACKUP_ACCESS, are defined in ntfsexp.h.
    //

    USHORT AccessFlags;

    USHORT Alignment;

#ifdef CCB_FILE_OBJECT
    PFILE_OBJECT FileObject;
    PEPROCESS Process;
#endif

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    //  READ BELOW BEFORE CHANGING THIS STRUCTURE                           //
    //                                                                      //
    //  All of the enumeration fields must be after this point.  Otherwise  //
    //  we will waste space in the CCB_DATA defined below.                  //
    //                                                                      //
    //  Also - The first defined field past this point must be used in      //
    //  defining the CCB_DATA structure below.                              //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    //
    //  Pointer to the index context structure for enumerations.
    //

    struct _INDEX_CONTEXT *IndexContext;

    //
    //  The query template is used to filter directory query requests.
    //  It originally is set to null and on the first call the
    //  NtQueryDirectory it is set the the input filename or "*" if no
    //  name is supplied.  All subsquent queries then use this template.
    //

    ULONG QueryLength;
    PVOID QueryBuffer;

    //
    //  The last returned value.  A copy of an IndexEntry is saved.  We
    //  only grow this buffer, to avoid always deallocating and
    //  reallocating.
    //

    ULONG IndexEntryLength;
    PINDEX_ENTRY IndexEntry;

    //
    //  File reference for file record we need to read for another name,
    //  and for which Fcb should be found and acquired when restarting
    //  an enumeration.
    //

    union {

        LONGLONG LongValue;

        FILE_REFERENCE FileReference;

    } FcbToAcquire;

    //
    //  File reference for next file reference to consider when doing a
    //  Mft scan looking for the next file owned by a specified Sid
    //

    FILE_REFERENCE MftScanFileReference;

    //
    //  Lists of waiters on this Ccb.  A NULL value indicates no waiters.
    //

    LIST_ENTRY EnumQueue;

} CCB;
typedef CCB *PCCB;

//
//  The size of the CCB_DATA is the quadaligned size of the common
//  header.
//
//  NOTE - This define assumes the first field of the index portion is the
//  IndexContext field.
//

typedef struct _CCB_DATA {

    LONGLONG Opaque[ (FIELD_OFFSET( CCB, IndexContext ) + 7) / 8 ];

} CCB_DATA;
typedef CCB_DATA *PCCB_DATA;

#define CCB_FLAG_IGNORE_CASE                (0x00000001)
#define CCB_FLAG_OPEN_AS_FILE               (0x00000002)
#define CCB_FLAG_WILDCARD_IN_EXPRESSION     (0x00000004)
#define CCB_FLAG_OPEN_BY_FILE_ID            (0x00000008)

#define CCB_FLAG_USER_SET_LAST_MOD_TIME     (0x00000010)
#define CCB_FLAG_USER_SET_LAST_CHANGE_TIME  (0x00000020)
#define CCB_FLAG_USER_SET_LAST_ACCESS_TIME  (0x00000040)
#define CCB_FLAG_TRAVERSE_CHECK             (0x00000080)

#define CCB_FLAG_RETURN_DOT                 (0x00000100)
#define CCB_FLAG_RETURN_DOTDOT              (0x00000200)
#define CCB_FLAG_DOT_RETURNED               (0x00000400)
#define CCB_FLAG_DOTDOT_RETURNED            (0x00000800)

#define CCB_FLAG_DELETE_FILE                (0x00001000)
#define CCB_FLAG_DENY_DELETE                (0x00002000)
#define CCB_FLAG_ALLOCATED_FILE_NAME        (0x00004000)
#define CCB_FLAG_CLEANUP                    (0x00008000)

#define CCB_FLAG_SYSTEM_HIVE                (0x00010000)
#define CCB_FLAG_PARENT_HAS_DOS_COMPONENT   (0x00020000)
#define CCB_FLAG_DELETE_ON_CLOSE            (0x00040000)
#define CCB_FLAG_CLOSE                      (0x00080000)

#define CCB_FLAG_UPDATE_LAST_MODIFY         (0x00100000)
#define CCB_FLAG_UPDATE_LAST_CHANGE         (0x00200000)
#define CCB_FLAG_SET_ARCHIVE                (0x00400000)
#define CCB_FLAG_DIR_NOTIFY                 (0x00800000)

#define CCB_FLAG_ALLOW_XTENDED_DASD_IO      (0x01000000)
#define CCB_FLAG_READ_CONTEXT_ALLOCATED     (0x02000000)
#define CCB_FLAG_DELETE_ACCESS              (0x04000000)
#define CCB_FLAG_DENY_DEFRAG                (0x08000000)

#define CCB_FLAG_PROTECT_NAME               (0x10000000)
#define CCB_FLAG_FLUSH_VOLUME_ON_IO         (0x20000000)

//
//  Reusing a bit from the file name index enumeration path for the view index path
//
#define CCB_FLAG_LAST_INDEX_ROW_RETURNED    (0x00000800)


//
//  We will attempt to allocate the following out of a single pool block
//  on a per file basis.
//
//      FCB, LCB, SCB, CCB, FILE_NAME
//
//  The following compound Fcb's will be allocated and then the individual
//  components can be allocated out of them.  The FCB will never be allocated
//  individually but it is possible that the embedded structures may be.
//  A zero in the node type field means these are available.  These sizes are
//  selected to fill the Fcb out to a pool block boundary (0x20) bytes.
//  Note that we leave room for both the exact and ignore case names.
//

#define MAX_DATA_FILE_NAME                  (17)
#define MAX_INDEX_FILE_NAME                 (17)

typedef struct _FCB_DATA {

    FCB Fcb;
    UCHAR Scb[SIZEOF_SCB_DATA];
    CCB_DATA Ccb;
    UCHAR Lcb[SIZEOF_LCB];
    WCHAR FileName[(2*MAX_DATA_FILE_NAME) - 1];

} FCB_DATA;
typedef FCB_DATA *PFCB_DATA;

typedef struct _FCB_INDEX {

    FCB Fcb;
    UCHAR Scb[SIZEOF_SCB_INDEX];
    CCB Ccb;
    UCHAR Lcb[SIZEOF_LCB];
    WCHAR FileName[(2*MAX_INDEX_FILE_NAME) - 1];

} FCB_INDEX;
typedef FCB_INDEX *PFCB_INDEX;


typedef VOID
(*POST_SPECIAL_CALLOUT) (
    IN struct _IRP_CONTEXT *IrpContext,
    IN OUT PVOID Context
    );

//
//  The IrpContext contains a cache of file records mapped within the current
//  call.  These are used to reduce the number of maps that take place
//

typedef struct _IRP_FILE_RECORD_CACHE_ENTRY {
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PBCB FileRecordBcb;
    ULONG UnsafeSegmentNumber;
} IRP_FILE_RECORD_CACHE_ENTRY, *PIRP_FILE_RECORD_CACHE_ENTRY;

#define IRP_FILE_RECORD_MAP_CACHE_SIZE  4

//
//  Chained Usn Fcbs.  The IrpContext has a built-in UsnFcb but some requests require more than
//  one.  In that case we will allocate and chain these together.
//
//  The flags field has the following flags
//
//      USN_FCB_FLAG_NEW_REASON - Indicates that we have something to report via
//          WriteUsnJournalChanges.  We need something to indicate whether we have any
//          new reasons since we don't clear out the NewReasons field when writing the
//          USN record so the presence of the reasons isn't enough.
//

typedef struct _USN_FCB {

    //
    //  Chain to next usnfcb record
    //

    struct _USN_FCB *NextUsnFcb;

    //
    //  Info to apply to the new record for the given fcb when its written
    //

    PFCB CurrentUsnFcb;
    ULONG NewReasons;
    ULONG RemovedSourceInfo;

    //
    //  Flags - see above
    //

    ULONG UsnFcbFlags;

    //
    //  For abort purpose - the old fcb state before we changed it only used if
    //  USN_FCB_FLAG_NEW_FCB_STATE flag is set
    //

    ULONG OldFcbState;

} USN_FCB, *PUSN_FCB;

//
//  USN_FCB_FLAG_NEW_FCB_STATE tracks whether we changed the fcbstate by growing
//  standard info while writing a usn journal record - we'll need to revert it if
//  transaction aborts
//


#define USN_FCB_FLAG_NEW_REASON         (0x00000001)
#define USN_FCB_FLAG_NEW_FCB_STATE      (0x00000002)

//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the
//  NtfsComplete request routine.
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be NTFS_NTC_IRP_CONTEXT)
    //
    //  Assumption here is that this structure is allocated from pool so
    //  base of structure is on an odd 64-bit boundary.
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  State of the operation.  These flags describe the current state of a request and
    //  are reset on either retry or post.
    //

    ULONG Flags;

    //
    //  State of the IrpContext.  These are persistent through the life of a request and
    //  are explicitly set and cleared.
    //

    ULONG State;

    //
    //  The following field contains the NTSTATUS value used when we are
    //  unwinding due to an exception.  We will temporarily store the Ccb
    //  for a delayed or deferred close here while the request is queued.
    //

    NTSTATUS ExceptionStatus;

    //
    //  Transaction Id for this request, which must be qualified by Vcb.
    //  We will store the type of open for a delayed or async close here
    //  while the request is queued.
    //

    TRANSACTION_ID TransactionId;

    //
    //  Major and minor function codes copied from the Irp
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  Length of Scb array for transactions below.  Zero indicates unused.  One indicates
    //  to treat it as a pointer to an Scb.  Greater than one indicates it is an allocated
    //  pool block with an array of Scb's.
    //

    USHORT SharedScbSize;

    //
    //  Pointer to Scb acquired shared for transaction or pointer to array of Scb's acquired
    //  shared for transaction.  Use the SharedScbSize field above to determine
    //  meaning of this pointer.
    //

    PVOID SharedScb;

    //
    //  This is a pointer to a structure which requires further cleanup when we cleanup the
    //  IrpContext.  Currently it can be either an Fcb or Scb.
    //
    //      Fcb - We need to release the paging Io resource for this.
    //      Scb - We need to clear the IOAtEof flag.
    //

    PVOID CleanupStructure;

    //
    //  Vcb for the operation this IrpContext is processing.
    //

    PVCB Vcb;

    //
    //  A pointer to the originating Irp.  We will store the Scb for
    //  delayed or async closes here while the request is queued.
    //

    PIRP OriginatingIrp;

    //
    //  This is the IrpContext for the top level request.
    //

    struct _IRP_CONTEXT *TopLevelIrpContext;


    union {

        struct {

            //
            //  This is a list of exclusively-owned Scbs which may only be
            //  released after the transaction is committed.
            //

            LIST_ENTRY ExclusiveFcbList;

            //
            //  The following field is used to maintain a queue of records that
            //  have been deallocated while processing this irp context.
            //

            LIST_ENTRY RecentlyDeallocatedQueue;
        };

        //
        //  This structure is used for posting to the Ex worker threads.
        //

        WORK_QUEUE_ITEM WorkQueueItem;
    };


    //
    //  The following is the number of clusters deallocated in the current
    //  request.  We want to ignore them when figuring if a request for
    //  clusters (NtfsAllocateClusters) should free the clusters in the
    //  recently deallocated queue.
    //

    LONGLONG DeallocatedClusters;

    //
    //  This is the Last Restart Area Lsn captured from the Vcb at
    //  the time log file full was raised.  The caller will force
    //  a checkpoint if this has not changed by the time he gets
    //  the global resource exclusive.
    //

    LSN LastRestartArea;

    //
    //  This is the change in the free clusters on the volume during the
    //  transaction for this IrpContext.  If we abort the current request
    //  we will subtract these from the current count of free clusters
    //  in the Vcb.  This is signed because we may be allocating or
    //  deallocating the clusters.
    //

    LONGLONG FreeClusterChange;

    //
    //  The following union contains pointers to the IoContext for I/O
    //  based requests and a pointer to a security context for requests
    //  which need to capture the subject context in the calling thread.
    //

    union {

        //
        //  The following context block is used for non-cached Io.
        //

        struct _NTFS_IO_CONTEXT *NtfsIoContext;

        //
        //  The following field is used for cached compressed reads/writes
        //

        PFSRTL_AUXILIARY_BUFFER AuxiliaryBuffer;

        //
        //  The following is the captured subject context.
        //

        PSECURITY_SUBJECT_CONTEXT SubjectContext;

        //
        //  The following is used during create for oplock cleanup.
        //

        struct _OPLOCK_CLEANUP *OplockCleanup;

        //
        //  The following is used to transfer the create context between fsp and fsp
        //  if a create is posted
        //

        struct _CREATE_CONTEXT *CreateContext;


        //
        //  The following is used by NtfsPostSpecial to pass the
        //  function to be called.
        //

        POST_SPECIAL_CALLOUT PostSpecialCallout;

        //
        //  The following is used by NtfsReadFileRecordUsnData for cleanup
        //

        PMDL MdlToCleanup;

    } Union;

    //
    //  Collect all of the streams which have been extended which may have waiters
    //  on the new length.
    //

    PVOID CheckNewLength;

    //
    //  The Fcb for which some new Usn reasons must be journalled, and the reasons.
    //

    USN_FCB Usn;
    ULONG SourceInfo;

    //
    //  This structure contains the first ScbSnapshot for a modifying
    //  request which acquires files exclusive and snaps Scb values.
    //  If the SnapshotLinks field contains NULLs, then no data has
    //  been snapshot for this request, and the list is empty.  If
    //  the links are not NULL, then this snapshot structure is in
    //  use.  If the SnapshotLinks are not NULL, and do not represent
    //  an empty list, then there are addtional dynamically allocated
    //  snapshot structures in this list.
    //

    SCB_SNAPSHOT ScbSnapshot;

    //
    //  Some calls require reading the base file record for the specified file
    //  multiple times.  We cache the pointer to the base file record and the
    //  BCB for that file record.
    //

    ULONG CacheCount;
    IRP_FILE_RECORD_CACHE_ENTRY FileRecordCache[IRP_FILE_RECORD_MAP_CACHE_SIZE];

#ifdef NTFS_LOG_FULL_TEST
    //
    //  Debugging field for breadth-first verification of log-file-full.  When the
    //  NextFailCount is non-zero, we decrement the CurrentFailCount.  When
    //  CurrentFailCount goes to zero, we increment NextFailCount, set
    //  CurrentFailCount to NextFailCount and raise STATUS_LOG_FILE_FULL.
    //

    ULONG CurrentFailCount;
    ULONG NextFailCount;
#endif

#ifdef MAPCOUNT_DBG
    ULONG MapCount;
#endif

#ifdef NTFSDBG
    ULONG FilesOwnedCount;
    NTFS_OWNERSHIP_STATE OwnershipState;
#endif

#ifdef PERF_STATS
    LARGE_INTEGER StartTick;
    ULONG Ios;
    ULONG LogFullReason;
#endif

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

//
//  The following are the Irp Context flags.  They will be cleared
//  on either retry or post.  If we start to run out of bits then we
//  can combine some of these because they are only tested locally and
//  have the same behavior on retry or post.
//

#define IRP_CONTEXT_FLAG_LARGE_ALLOCATION       (0x00000001)
#define IRP_CONTEXT_FLAG_WRITE_SEEN             (0x00000002)
#define IRP_CONTEXT_FLAG_CREATE_MOD_SCB         (0x00000004)
#define IRP_CONTEXT_FLAG_DEFERRED_WRITE         (0x00000008)
#define IRP_CONTEXT_FLAG_EXCESS_LOG_FULL        (0x00000010)
#define IRP_CONTEXT_FLAG_WROTE_LOG              (0x00000020)
#define IRP_CONTEXT_FLAG_MFT_REC_15_USED        (0x00000040)
#define IRP_CONTEXT_FLAG_MFT_REC_RESERVED       (0x00000080)
#define IRP_CONTEXT_FLAG_RAISED_STATUS          (0x00000100)
#define IRP_CONTEXT_FLAG_CALL_SELF              (0x00000200)
#define IRP_CONTEXT_FLAG_DONT_DELETE            (0x00000400)
#define IRP_CONTEXT_FLAG_FORCE_POST             (0x00000800)
#define IRP_CONTEXT_FLAG_MODIFIED_BITMAP        (0x00001000)
#define IRP_CONTEXT_FLAG_RELEASE_USN_JRNL       (0x00002000)
#define IRP_CONTEXT_FLAG_RELEASE_MFT            (0x00004000)
#define IRP_CONTEXT_FLAG_DEFERRED_PUSH          (0x00008000)
#define IRP_CONTEXT_FLAG_ACQUIRE_PAGING         (0x00010000)
#define IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY        (0x00020000)
#define IRP_CONTEXT_FLAG_RETAIN_FLAGS           (0x00040000)
#define IRP_CONTEXT_FLAG_ONLY_SYNCH_CHECKPOINT  (0x00080000)
//
//  The following flags need to be cleared when a request is posted.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_POST   \
    (IRP_CONTEXT_FLAG_LARGE_ALLOCATION  | \
     IRP_CONTEXT_FLAG_WRITE_SEEN        | \
     IRP_CONTEXT_FLAG_CREATE_MOD_SCB    | \
     IRP_CONTEXT_FLAG_EXCESS_LOG_FULL   | \
     IRP_CONTEXT_FLAG_WROTE_LOG         | \
     IRP_CONTEXT_FLAG_MFT_REC_15_USED   | \
     IRP_CONTEXT_FLAG_MFT_REC_RESERVED  | \
     IRP_CONTEXT_FLAG_RAISED_STATUS     | \
     IRP_CONTEXT_FLAG_CALL_SELF         | \
     IRP_CONTEXT_FLAG_DONT_DELETE       | \
     IRP_CONTEXT_FLAG_FORCE_POST        | \
     IRP_CONTEXT_FLAG_MODIFIED_BITMAP   | \
     IRP_CONTEXT_FLAG_RELEASE_USN_JRNL  | \
     IRP_CONTEXT_FLAG_RELEASE_MFT       | \
     IRP_CONTEXT_FLAG_DEFERRED_PUSH     | \
     IRP_CONTEXT_FLAG_ACQUIRE_PAGING    | \
     IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY   | \
     IRP_CONTEXT_FLAG_RETAIN_FLAGS)

//
//  The following flags need to be cleared when a request is retried.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY  \
    (IRP_CONTEXT_FLAG_LARGE_ALLOCATION  | \
     IRP_CONTEXT_FLAG_WRITE_SEEN        | \
     IRP_CONTEXT_FLAG_CREATE_MOD_SCB    | \
     IRP_CONTEXT_FLAG_DEFERRED_WRITE    | \
     IRP_CONTEXT_FLAG_EXCESS_LOG_FULL   | \
     IRP_CONTEXT_FLAG_WROTE_LOG         | \
     IRP_CONTEXT_FLAG_MFT_REC_15_USED   | \
     IRP_CONTEXT_FLAG_MFT_REC_RESERVED  | \
     IRP_CONTEXT_FLAG_RAISED_STATUS     | \
     IRP_CONTEXT_FLAG_CALL_SELF         | \
     IRP_CONTEXT_FLAG_DONT_DELETE       | \
     IRP_CONTEXT_FLAG_FORCE_POST        | \
     IRP_CONTEXT_FLAG_MODIFIED_BITMAP   | \
     IRP_CONTEXT_FLAG_RELEASE_USN_JRNL  | \
     IRP_CONTEXT_FLAG_RELEASE_MFT       | \
     IRP_CONTEXT_FLAG_DEFERRED_PUSH     | \
     IRP_CONTEXT_FLAG_ACQUIRE_PAGING    | \
     IRP_CONTEXT_FLAG_RETAIN_FLAGS)

//
//  State flags.  IrpContext flags which span the life of an IrpContext
//  and must be explicitly set and cleared.  If we start to run out
//  of these some of them can be shared be they are only tested
//  in specific operations.
//

#define IRP_CONTEXT_STATE_WAIT                          (0x00000001)        //  Specifically 1 so we don't have to cast to boolean.
#define IRP_CONTEXT_STATE_EFS_CREATE                    (0x00000002)
#define IRP_CONTEXT_STATE_FAILED_CLOSE                  (0x00000004)
#define IRP_CONTEXT_STATE_WRITE_THROUGH                 (0x00000008)
#define IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT              (0x00000010)
#define IRP_CONTEXT_STATE_ALLOC_SECURITY                (0x00000020)
#define IRP_CONTEXT_STATE_IN_FSP                        (0x00000040)
#define IRP_CONTEXT_STATE_IN_TEARDOWN                   (0x00000080)
#define IRP_CONTEXT_STATE_ACQUIRE_EX                    (0x00000100)
#define IRP_CONTEXT_STATE_DASD_OPEN                     (0x00000200)
#define IRP_CONTEXT_STATE_DASD_UNLOCK                   (0x00000200)  // overloaded
#define IRP_CONTEXT_STATE_QUOTA_DISABLE                 (0x00000400)
#define IRP_CONTEXT_STATE_LAZY_WRITE                    (0x00000800)
#define IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE             (0x00001000)
#define IRP_CONTEXT_STATE_FORCE_PUSH                    (0x00002000)
#define IRP_CONTEXT_STATE_READ_ONLY_FO                  (0x00004000)
#define IRP_CONTEXT_STATE_VOL_UPGR_FAILED               (0x00008000)
#define IRP_CONTEXT_STATE_PERSISTENT                    (0x00010000)
#define IRP_CONTEXT_STATE_WRITING_AT_EOF                (0x00020000)
#define IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH            (0x00040000)
#define IRP_CONTEXT_STATE_ALLOC_FROM_POOL               (0x00080000)
#define IRP_CONTEXT_STATE_OWNS_TOP_LEVEL                (0x00100000)
#define IRP_CONTEXT_STATE_ENCRYPTION_RETRY              (0x00200000)
#define IRP_CONTEXT_STATE_ALLOC_MDL                     (0x00400000)
#define IRP_CONTEXT_STATE_BAD_RESTART                   (0x00800000)
#define IRP_CONTEXT_STATE_NO_FAILURES_EXPECTED          (0x02000000)

#ifdef PERF_STATS
#define IRP_CONTEXT_STATE_TRACK_IOS                     (0x04000000)
#endif


//
//  The top level context is used to determine whether this request has
//  other requests below it on the stack.
//

typedef struct _TOP_LEVEL_CONTEXT {

    BOOLEAN TopLevelRequest;
    BOOLEAN ValidSavedTopLevel;
    BOOLEAN OverflowReadThread;

    ULONG Ntfs;

    VCN VboBeingHotFixed;

    PSCB ScbBeingHotFixed;

    PIRP SavedTopLevelIrp;

    PIRP_CONTEXT ThreadIrpContext;

} TOP_LEVEL_CONTEXT;
typedef TOP_LEVEL_CONTEXT *PTOP_LEVEL_CONTEXT;


//
//  The found attribute part of the attribute enumeration context
//  describes an attribute record that had been located or created.  It
//  may refer to either a base or attribute list.
//

typedef struct _FOUND_ATTRIBUTE {

    //
    //  The following identify the attribute which was mapped.  These are
    //  necessary if forcing the range of bytes into memory by pinning.
    //  These include the Bcb on which the attribute was read (if this
    //  field is NULL, this is the initial attribute) and the offset of
    //  the record segment in the Mft.
    //

    LONGLONG MftFileOffset;

    //
    //  Pointer to the Attribute Record
    //

    PATTRIBUTE_RECORD_HEADER Attribute;

    //
    //  Pointer to the containing record segment.
    //

    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    //
    //  Bcb for mapped/pinned FileRecord
    //

    PBCB Bcb;

    //
    //  Some state information.
    //

    BOOLEAN AttributeDeleted;

} FOUND_ATTRIBUTE;
typedef FOUND_ATTRIBUTE *PFOUND_ATTRIBUTE;

//
//  The structure guides enumeration through the attribute list.
//

typedef struct _ATTRIBUTE_LIST_CONTEXT {

    //
    //  This points to the first attribute list entry; it is advanced
    //  when we are searching for a particular exteral attribute.
    //

    PATTRIBUTE_LIST_ENTRY Entry;

    //
    //  A Bcb for the attribute list.
    //

    PBCB Bcb;

    //
    //  This field is used to remember the location of the Attribute
    //  List attribute within the base file record, if existent.
    //

    PATTRIBUTE_RECORD_HEADER AttributeList;

    //
    //  This points to the first entry in the attribute list.  This is
    //  needed when the attribute list is non-resident.
    //

    PATTRIBUTE_LIST_ENTRY FirstEntry;

    //
    //  This points just beyond the final attribute list entry.
    //

    PATTRIBUTE_LIST_ENTRY BeyondFinalEntry;

    //
    //  This is the Bcb for the data portion of a non-resident attribute.
    //

    PBCB NonresidentListBcb;

} ATTRIBUTE_LIST_CONTEXT;
typedef ATTRIBUTE_LIST_CONTEXT *PATTRIBUTE_LIST_CONTEXT;

//
//  The Attribute Enumeration Context structure returns information on an
//  attribute which has been found by one of the Attribute Lookup or
//  Creation routines.  It is also used as an IN OUT structure to perform
//  further lookups/modifications to attributes.  It does not have a node
//  type code and size since it is usually allocated on the caller's
//  stack.
//

typedef struct _ATTRIBUTE_ENUMERATION_CONTEXT {

    //
    //  Contains the actual attribute we found.
    //

    FOUND_ATTRIBUTE FoundAttribute;

    //
    //  Allows enumeration through the attribute list.
    //

    ATTRIBUTE_LIST_CONTEXT AttributeList;

} ATTRIBUTE_ENUMERATION_CONTEXT;
typedef ATTRIBUTE_ENUMERATION_CONTEXT *PATTRIBUTE_ENUMERATION_CONTEXT;


//
//  Define struct which will be used to remember the path that was
//  followed to locate a given INDEX_ENTRY or insertion point for an
//  INDEX_ENTRY.  This structure is always filled in by LookupIndexEntry.
//
//  The Index Lookup Stack is generally allocated as a local variable in
//  one of the routines in this module that may be called from another
//  module.  A pointer to this stack is then passed in to some of the
//  internal routines.
//
//  The first entry in the stack describes context in the INDEX attribute
//  in the file record, and all subsequent stack entries refer to Index
//  buffers in the INDEX_ALLOCATION attribute.
//
//  Outside of indexsup.c, this structure should only be passed as an
//  "opaque" context, and individual fields should not be referenced.
//

typedef struct _INDEX_LOOKUP_STACK {

    //
    //  Bcb pointer for the Index Buffer.  In the "bottom" (first entry)
    //  of the stack this field contains a NULL, and the Bcb must be found
    //  via the Attribute Enumeration Context.
    //

    PBCB Bcb;

    //
    //  Pointer to the start of the File Record or Index Buffer
    //

    PVOID StartOfBuffer;

    //
    //  Pointer to Index Header in the File Record or Index Buffer
    //

    PINDEX_HEADER IndexHeader;

    //
    //  Pointer to to the current INDEX_ENTRY on search path
    //

    PINDEX_ENTRY IndexEntry;

    //
    //  Index block of the index buffer
    //

    LONGLONG IndexBlock;

    //
    //  Saved Lsn for faster enumerations
    //

    LSN CapturedLsn;

} INDEX_LOOKUP_STACK;

typedef INDEX_LOOKUP_STACK *PINDEX_LOOKUP_STACK;

#define INDEX_LOOKUP_STACK_SIZE      (3)

//
//  Index Context structure.
//
//  This structure maintains a context which describes the lookup stack to
//  a given index entry.  It includes the Attribute Enumeration Context
//  for the Index Root, the Index lookup stack remembering the path to the
//  index entry, and the current stack pointer within the stack pointing
//  to the stack entry for the current index entry or where we are at in a
//  bucket split or delete operation.
//
//  Outside of indexsup.c, this structure should only be passed as an
//  "opaque" context, and individual fields should not be referenced.
//

typedef struct _INDEX_CONTEXT {

    //
    //  Attribute Enumeration Context for the Index Root
    //

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

    //
    //  Captured Lsn of file record containing Index Root.  We capture the Lsn
    //  of the file record when we find the Index Root.  Later, we can
    //  check to see if the file record had changed (compare Lsn's) before
    //  doing the expensive attribute lookup
    //

    LSN IndexRootFileRecordLsn;

    //
    //  Base of dynamically allocated lookup stack - either points
    //  to the one above or a dynamically allocated larger one.
    //

    PINDEX_LOOKUP_STACK Base;

    //
    //  Stack pointer to top of Lookup Stack.  This field essentially
    //  remembers how deep the index Btree is.
    //

    PINDEX_LOOKUP_STACK Top;

    //
    //  Index lookup stack.
    //

    INDEX_LOOKUP_STACK LookupStack[INDEX_LOOKUP_STACK_SIZE];

    //
    //  Stack pointer within the Index Lookup Stack
    //

    PINDEX_LOOKUP_STACK Current;

    //
    //  Captured Scb (Index type) change count
    //

    ULONG ScbChangeCount;

    //
    //  This field remembers where the index root attribute was last
    //  seen, to support correct operation of FindMoveableIndexRoot.
    //

    PATTRIBUTE_RECORD_HEADER OldAttribute;

    //
    //  Number of entries allocated in the lookup stack.
    //

    USHORT NumberEntries;

    //
    //  Flags
    //

    USHORT Flags;

    //
    //  For enumerations via NtOfsReadRecords, the MatchFunction and MatchData
    //  are stored here.
    //

    PMATCH_FUNCTION MatchFunction;
    PVOID MatchData;

    //
    //  Fcb which was acquired and must be released.
    //

    PFCB AcquiredFcb;

    //
    //  Add field to preserve quad & cache line alignment
    //

    ULONG Unused;

} INDEX_CONTEXT;

typedef INDEX_CONTEXT *PINDEX_CONTEXT;

//
//  Fcb table is acquired and must be freed.
//

#define INDX_CTX_FLAG_FCB_TABLE_ACQUIRED (01)


//
//  Context structure for asynchronous I/O calls.  Most of these fields
//  are actually only required for the Read/Write Multiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _NTFS_IO_CONTEXT {

    //
    //  These two fields are used for multiple run Io
    //

    LONG IrpCount;

    //
    //  Flags for the context
    //

    ULONG Flags;

    PIRP MasterIrp;

    union {

        //
        //  This element handles the asynchronous non-cached Io
        //

        struct {

            PERESOURCE Resource;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;

        } Async;

        //
        //  and this element handles the synchronous non-cached Io.
        //

        KEVENT SyncEvent;

    } Wait;

} NTFS_IO_CONTEXT;

typedef NTFS_IO_CONTEXT *PNTFS_IO_CONTEXT;

//
//  NTFS_IO_CONTEXT Flags
//

#define NTFS_IO_CONTEXT_ALLOCATED               (0x00000001)
#define NTFS_IO_CONTEXT_PAGING_IO               (0x00000002)
#define NTFS_IO_CONTEXT_ASYNC                   (0x00000004)
#define NTFS_IO_CONTEXT_INLINE_OPLOCK           (0x00000008)


//
//  An array of these structures is passed to NtfsMultipleAsync describing
//  a set of runs to execute in parallel.  Risc compilers will add an
//  unused long word anyway to align each array entry.
//

typedef struct _IO_RUN {

    VBO StartingVbo;
    LBO StartingLbo;
    ULONG BufferOffset;
    ULONG ByteCount;
    PIRP SavedIrp;
    ULONG Unused;

} IO_RUN;
typedef IO_RUN *PIO_RUN;


//
//  This structure is used by the name manipulation routines to described
//  a parsed file name componant.
//

typedef struct _NTFS_NAME_DESCRIPTOR {

    //
    //  The follow flag tells which fields were present in the name.
    //

    ULONG FieldsPresent;

    UNICODE_STRING FileName;
    UNICODE_STRING AttributeType;
    UNICODE_STRING AttributeName;
    ULONG VersionNumber;

} NTFS_NAME_DESCRIPTOR;
typedef NTFS_NAME_DESCRIPTOR *PNTFS_NAME_DESCRIPTOR;

//
//  Define the bits in FieldsPresent above.
//

#define FILE_NAME_PRESENT_FLAG          (1)
#define ATTRIBUTE_TYPE_PRESENT_FLAG     (2)
#define ATTRIBUTE_NAME_PRESENT_FLAG     (4)
#define VERSION_NUMBER_PRESENT_FLAG     (8)


//
//  The following is used to perform Ea related routines.
//

typedef struct _EA_LIST_HEADER {

    //
    //  The size of buffer needed to pack these Ea's
    //

    ULONG PackedEaSize;

    //
    //  This is the count of Ea's with their NEED_EA
    //  bit set.
    //

    USHORT NeedEaCount;

    //
    //  The size of the buffer needed to return all Ea's
    //  in their unpacked form.
    //

    ULONG UnpackedEaSize;

    //
    //  This is the size of the buffer used to store the ea's
    //

    ULONG BufferSize;

    //
    //  This is the pointer to the first entry in the list.
    //

    PFILE_FULL_EA_INFORMATION FullEa;

} EA_LIST_HEADER;
typedef EA_LIST_HEADER *PEA_LIST_HEADER;


//
//  The following structure is used to maintain a list of recently
//  deallocated records so that the file system will not reuse a recently
//  deallocated record until it is safe to do so.  Each instance of this
//  structure is placed on two queues.  One queue is per index SCB and the
//  other queue is per Irp Context.
//
//  Whenever we delete a record we allocate a new structure if necessary
//  and add it to the scb queue and the irp context queue.  We indicate in
//  the structure the index of the record we just deallocated.
//
//  Whenever we need to allocate a new record we filter out any canidate
//  we want to allocate to avoid allocating one in the scb's recently
//  deallocated queue.
//
//  Whenever we delete an irp context we scan through its recently
//  deallocated queue removing it from the scb queue.
//

#define DEALLOCATED_RECORD_ENTRIES          32

typedef struct _DEALLOCATED_RECORDS {

    //
    //  The following field links this structure into the
    //  Scb->RecentlyDeallocatedQueue
    //

    LIST_ENTRY ScbLinks;

    //
    //  The following field links this structure into the
    //  IrpContext->RecentlyDeallocatedQueue
    //

    LIST_ENTRY IrpContextLinks;

    //
    //  This is a pointer to the Scb that this record is part of
    //

    PSCB Scb;

    //
    //  The following two fields describe the total size of this structure
    //  and the number of entries actually being used.  NumberOfEntries is
    //  the size of the Index array and NextFreeEntryis the index of the
    //  next free slot.  If NumberOfEntries is equal to NextFreeEntry then
    //  this structure is full
    //

    ULONG NumberOfEntries;
    ULONG NextFreeEntry;

    //
    //  This is an array of indices that have been dealloated.
    //

    ULONG Index[DEALLOCATED_RECORD_ENTRIES];

} DEALLOCATED_RECORDS;
typedef DEALLOCATED_RECORDS *PDEALLOCATED_RECORDS;

#define DEALLOCATED_RECORDS_HEADER_SIZE \
    (FIELD_OFFSET( DEALLOCATED_RECORDS, Index ))

#pragma pack(8)
typedef struct _FCB_TABLE_ELEMENT {

    FILE_REFERENCE FileReference;
    PFCB Fcb;

} FCB_TABLE_ELEMENT;
typedef FCB_TABLE_ELEMENT *PFCB_TABLE_ELEMENT;
#pragma pack()

#ifdef NTFS_CACHE_RIGHTS

//
//  Computed access rights information.  This structure is used to cache
//  what access rights a given security token is granted relative to a
//  security descriptors.
//

typedef struct _COMPUTED_ACCESS_RIGHTS {

    //
    //  The token id.  Note that a specific TokenId will only appear once
    //  in the cache.
    //

    LUID TokenId;

    //
    //  The modification id of the token.  This changes whenever the token
    //  is updated such that the access rights might change.
    //

    LUID ModifiedId;

    //
    //  All of the access rights held by this token that do not require
    //  privileges. The rights will also not include MAXIMUM_ALLOWED.
    //  Note that we don't include rights that require privileges
    //  because we wouldn't be able to determine in a future
    //  use of the cached information whether the privileges were needed
    //  or not to gain a desired set of rights.  The use of privileges
    //  affects auditing.
    //

    ACCESS_MASK Rights;

} COMPUTED_ACCESS_RIGHTS, *PCOMPUTED_ACCESS_RIGHTS;


//
//  Cached access rights information.  This structure is used to cache
//  what access rights are known to be available for all security tokens
//  and for the most recently used specific security tokens.
//

#define NTFS_MAX_CACHED_RIGHTS 2

typedef struct _CACHED_ACCESS_RIGHTS {

    //
    //  The list of computed access rights for specific tokens.
    //

    COMPUTED_ACCESS_RIGHTS TokenRights[NTFS_MAX_CACHED_RIGHTS];

    //
    //  The access rights that all users are known to have.
    //  The rights will not include MAXIMUM_ALLOWED.
    //

    ACCESS_MASK EveryoneRights;

    //
    //  The number of valid entries in TokenRights.
    //

    UCHAR Count;

    //
    //  The index of the next entry to add to TokenRights.
    //

    UCHAR NextInsert;

    //
    //  This indicates whether we have acquired EveryoneRights.
    //

    BOOLEAN HaveEveryoneRights;

} CACHED_ACCESS_RIGHTS, *PCACHED_ACCESS_RIGHTS;
#endif


//
//  Security descriptor information.  This structure is used to allow
//  Fcb's to share security descriptors.
//

typedef struct _SHARED_SECURITY {

#ifdef NTFS_CACHE_RIGHTS
    CACHED_ACCESS_RIGHTS CachedRights;
#endif
    ULONG ReferenceCount;
    SECURITY_DESCRIPTOR_HEADER Header;
    UCHAR SecurityDescriptor[1];

} SHARED_SECURITY, *PSHARED_SECURITY;

#define GetSharedSecurityLength(SS)         (GETSECURITYDESCRIPTORLENGTH( &(SS)->Header ))
#define SetSharedSecurityLength(SS,LENGTH)  (SetSecurityDescriptorLength( &(SS)->Header,(LENGTH) ))


//
//  The following structure is used to store the state of an Scb to use
//  during unwind operations.  We keep a copy of all of the file sizes.
//

typedef struct _OLD_SCB_SNAPSHOT {

    LONGLONG AllocationSize;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;
    LONGLONG TotalAllocated;

    UCHAR CompressionUnit;
    BOOLEAN Resident;
    USHORT AttributeFlags;

} OLD_SCB_SNAPSHOT, *POLD_SCB_SNAPSHOT;

//
//  Structure used to track the number of threads doing read ahead, so
//  that we do not hot fix for them.
//

typedef struct _READ_AHEAD_THREAD {

    //
    //  Links of read ahead structures.
    //

    LIST_ENTRY Links;

    //
    //  Thread Id
    //

    PVOID Thread;

} READ_AHEAD_THREAD, *PREAD_AHEAD_THREAD;

//
//  Structure used to post to Defrag Mft routine.
//

typedef struct _DEFRAG_MFT {

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    PVCB Vcb;

    BOOLEAN DeallocateWorkItem;

} DEFRAG_MFT, *PDEFRAG_MFT;

//
//  Structure for remembering file records to delete.
//

typedef struct _NUKEM {

    struct _NUKEM *Next;
    ULONG RecordNumbers[4];

} NUKEM, *PNUKEM;

//
//  Structure for picking up file name pairs for property tunneling. Space is allocated for
//  the names so that this can be used on the stack. The size of LongBuffer should be sized
//  so that it will capture the vast majority of long names. Fallback code can go to pool
//  if required - but rarely.
//


typedef struct _NAME_PAIR {

    //
    //  The FILE_NAME_DOS component
    //

    UNICODE_STRING Short;

    //
    //  The FILE_NAME_NTFS component
    //

    UNICODE_STRING Long;

    //  Allocate space for an 8.3 name and a 26 char name. 26 isn't quite random -
    //  it puts this structure at 96 bytes.
    //

    WCHAR ShortBuffer[8+1+3];
    WCHAR LongBuffer[26];

} NAME_PAIR, *PNAME_PAIR;

//
//  The following is used to synchronize the create path.  It is passed to the completion
//  callback to restore the top level context and signal any waiting thread.
//

typedef struct _NTFS_COMPLETION_CONTEXT {

    PIRP_CONTEXT IrpContext;
    KEVENT Event;

} NTFS_COMPLETION_CONTEXT, *PNTFS_COMPLETION_CONTEXT;

//
//  Following structure is used at the time a request is posted to the oplock package
//  to perform any cleanup to do at that time.
//

typedef struct _OPLOCK_CLEANUP {

    //
    //  This is the original name and any allocated name buffer used during create.
    //  We must restore the original name in the file object on error.
    //
    //  We also store information about the original lengths of the attribute name
    //  and attribute code (or type) name.
    //

    UNICODE_STRING OriginalFileName;
    UNICODE_STRING FullFileName;
    UNICODE_STRING ExactCaseName;
    PFILE_OBJECT FileObject;
    ACCESS_MASK RemainingDesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    ACCESS_MASK DesiredAccess;
    PNTFS_COMPLETION_CONTEXT CompletionContext;
    USHORT AttributeNameLength;
    USHORT AttributeCodeNameLength;

} OPLOCK_CLEANUP, *POPLOCK_CLEANUP;

//
//  Context used to track state and cleanup work during create
//

typedef struct _CREATE_CONTEXT {

    //
    //  The oplock cleanup structure
    //

    OPLOCK_CLEANUP Cleanup;

    //
    //  Hash package values
    //

    ULONG FileHashValue;
    ULONG FileHashLength;
    ULONG ParentHashValue;
    ULONG ParentHashLength;

    //
    //  Common parameters - these are the current fcb node and the output
    //  scb and ccb for the opened file
    //

    PFCB CurrentFcb;
    PSCB ThisScb;
    PCCB ThisCcb;

    //
    //  Output buffer to put network info into if its specified - this is optional
    //  and implies that the create is not a full one
    //

    PVOID NetworkInfo;

    //
    //  Create Flags for the create
    //

    ULONG CreateFlags;

    //
    //  A combination of FILE_NEW, etc. to be passed to the encryption callout and
    //  to assist in cleaning up after creates that fail in the PostCreate callout.
    //

    ULONG EncryptionFileDirFlags;

    //
    //  A context value needs to be preserved throughout an encyrpted file create.
    //  Given the importance of making creates fast, adding one more pointer to
    //  this struct is better than making create push another parameter to its
    //  various local routines like NtfsOpenExistingPrefixFcb.
    //

    PVOID EncryptionContext;

} CREATE_CONTEXT, *PCREATE_CONTEXT;


//
//  The following structure is used to serialize the compressed IO path.
//

typedef struct _COMPRESSION_SYNC {

    //
    //  Links of synchronization objects, attached to Scb.
    //  NOTE - this field must appear first.  We make this assumption
    //  when walking the links.
    //

    LIST_ENTRY CompressionLinks;

    //
    //  Offset in the file for the link.  Rounded down to cache manager views.
    //

    LONGLONG FileOffset;

    //
    //  Resource for synchronization.  Allows shared or exclusive access to view.
    //

    ERESOURCE Resource;

    //
    //  Backpointer to Scb.
    //

    PSCB Scb;

    //
    //  Reference count for number of users of this view.  Someone waiting
    //  for the offset wants to make sure it doesn't go away when
    //  another thread is finished with it.
    //

    ULONG ReferenceCount;

} COMPRESSION_SYNC, *PCOMPRESSION_SYNC;


//
//  This is the quota control block which are stored as table elments in the quota
//  control table.
//

typedef struct _QUOTA_CONTROL_BLOCK {
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    ULONG OwnerId;
    ULONG Flags;
    LONG ReferenceCount;
    QUICK_INDEX_HINT QuickIndexHint;
    PFAST_MUTEX QuotaControlLock;
} QUOTA_CONTROL_BLOCK, *PQUOTA_CONTROL_BLOCK;

//
//  Define the quota control flags.
//

#define QUOTA_FLAG_LIMIT_POSTED            (0x00000001)

//
//  Define the minimum amount of time between quota events.  Currently this is
//  1 hour.
//

#define MIN_QUOTA_NOTIFY_TIME (60i64 * 60 * 1000 * 1000 * 10)


//
//  NTFS_TUNNELED_DATA is a structure for keeping the information which is
//  preserved when a file is tunneled.  This is the structure that we pass to
//  and get back from the tunneling routines in FsRtl.
//

typedef struct _NTFS_TUNNELED_DATA {
    LONGLONG CreationTime;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    BOOLEAN HasObjectId;
} NTFS_TUNNELED_DATA, *PNTFS_TUNNELED_DATA;

//
//  Following macro is used to initialize UNICODE strings
//

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }

#define USN_PAGE_BOUNDARY               (0x2000)
#define USN_JOURNAL_CACHE_BIAS          (0x0000000000400000)
#define USN_MAXIMUM_JOURNAL_SIZE        (0x0000000100000000)

#ifdef NTFS_RWCMP_TRACE
extern ULONG NtfsCompressionTrace;

#define IsSyscache(H) (FlagOn(((PSCB)(H))->ScbState, SCB_STATE_SYSCACHE_FILE))
#endif


#ifdef BENL_DBG
typedef struct {
    LIST_ENTRY Links;
    LSN Lsn;
    ULONG Data;
    ULONG OldData;
    ULONG Length;
} RESTART_LOG, *PRESTART_LOG;
#endif

//
//  Maximum entries in the overflow queue at one time
//

#define OVERFLOW_QUEUE_LIMIT 1000

#define RESERVE_POOL_TAG ('bftN')

#endif // _NTFSSTRU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\read.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Ntfs called by the
    dispatch driver.

Author:

    Brian Andrew    BrianAn         15-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"
#include "lockorder.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

#ifdef NTFS_RWC_DEBUG
PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    );
BOOLEAN NtfsBreakOnConflict = TRUE;
#endif

//
//  Define stack overflow read threshhold.
//

#ifdef _X86_
#if DBG
#define OVERFLOW_READ_THRESHHOLD         (0xD00)
#else
#define OVERFLOW_READ_THRESHHOLD         (0xA00)
#endif
#else
#define OVERFLOW_READ_THRESHHOLD         (0x1000)
#endif // _X86_

//
//  Local procedure prototypes
//

//
//  The following procedure is used to handling read stack overflow operations.
//

VOID
NtfsStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

VOID 
NtfsNonCachedResidentRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount
    );

#define CollectReadStats(VCB,OPEN_TYPE,SCB,FCB,BYTE_COUNT) {                             \
    PFILE_SYSTEM_STATISTICS FsStats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()]; \
    if (!FlagOn( (FCB)->FcbState, FCB_STATE_SYSTEM_FILE)) {                              \
        if (NtfsIsTypeCodeUserData( (SCB)->AttributeTypeCode )) {                        \
            FsStats->Common.UserFileReads += 1;                                          \
            FsStats->Common.UserFileReadBytes += (ULONG)(BYTE_COUNT);                    \
        } else {                                                                         \
            FsStats->Ntfs.UserIndexReads += 1;                                           \
            FsStats->Ntfs.UserIndexReadBytes += (ULONG)(BYTE_COUNT);                     \
        }                                                                                \
    } else {                                                                             \
        if ((SCB) != (VCB)->LogFileScb) {                                                \
            FsStats->Common.MetaDataReads += 1;                                          \
            FsStats->Common.MetaDataReadBytes += (ULONG)(BYTE_COUNT);                    \
        } else {                                                                         \
            FsStats->Ntfs.LogFileReads += 1;                                             \
            FsStats->Ntfs.LogFileReadBytes += (ULONG)(BYTE_COUNT);                       \
        }                                                                                \
                                                                                         \
        if ((SCB) == (VCB)->MftScb) {                                                    \
            FsStats->Ntfs.MftReads += 1;                                                 \
            FsStats->Ntfs.MftReadBytes += (ULONG)(BYTE_COUNT);                           \
        } else if ((SCB) == (VCB)->RootIndexScb) {                                       \
            FsStats->Ntfs.RootIndexReads += 1;                                           \
            FsStats->Ntfs.RootIndexReadBytes += (ULONG)(BYTE_COUNT);                     \
        } else if ((SCB) == (VCB)->BitmapScb) {                                          \
            FsStats->Ntfs.BitmapReads += 1;                                              \
            FsStats->Ntfs.BitmapReadBytes += (ULONG)(BYTE_COUNT);                        \
        } else if ((SCB) == (VCB)->MftBitmapScb) {                                       \
            FsStats->Ntfs.MftBitmapReads += 1;                                           \
            FsStats->Ntfs.MftBitmapReadBytes += (ULONG)(BYTE_COUNT);                     \
        }                                                                                \
    }                                                                                    \
}


NTSTATUS
NtfsFsdRead (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    For synchronous requests, the CommonRead is called with Wait == TRUE,
    which means the request will always be completed in the current thread,
    and never passed to the Fsp.  If it is not a synchronous request,
    CommonRead is called with Wait == FALSE, which means the request
    will be passed to the Fsp only if there is a need to block.

Arguments:

    IrpContext - If present this an IrpContext put on the caller's stack
        to avoid having to allocate it from pool.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;
    ULONG RetryCount = 0;

    ASSERT_IRP( Irp );

    DebugTrace( +1, Dbg, ("NtfsFsdRead\n") );

    //
    //  Call the common Read routine
    //

    FsRtlEnterFileSystem();

    //
    //  Always make the reads appear to be top level.  As long as we don't have
    //  log file full we won't post these requests.  This will prevent paging
    //  reads from trying to attach to uninitialized top level requests.
    //    

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );

    ASSERT( ThreadTopLevelContext == &TopLevelContext );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {
                                                                             
                //
                //  Allocate the Irp and update the top level storage. For synchronous
                //  paging io allocate the irp on the stack
                //

                if (CanFsdWait( Irp ) && FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                    //
                    //  AllocateFromStack is only called in the first pass of the
                    //  loop.  Once the IrpContext exists we don't call this again.
                    //

                    IrpContext = (PIRP_CONTEXT) NtfsAllocateFromStack( sizeof( IRP_CONTEXT ));
                }

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                if (ThreadTopLevelContext->ScbBeingHotFixed != NULL) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY );
                }

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            //
            //  If this is an Mdl complete request, don't go through
            //  common read.
            //

            ASSERT( !FlagOn( IrpContext->MinorFunction, IRP_MN_DPC ) );

            if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                DebugTrace( 0, Dbg, ("Calling NtfsCompleteMdl\n") );

                Status = NtfsCompleteMdl( IrpContext, Irp );

            //
            //  Check if we have enough stack space to process this request.  If there
            //  isn't enough then we will create a new thread to process this single
            //  request
            //

            } else if (IoGetRemainingStackSize() < OVERFLOW_READ_THRESHHOLD) {

                KEVENT Event;
                PFILE_OBJECT FileObject;
                TYPE_OF_OPEN TypeOfOpen;
                PVCB Vcb;
                PFCB Fcb;
                PSCB Scb;
                PCCB Ccb;
                PERESOURCE Resource;

                DebugTrace( 0, Dbg, ("Getting too close to stack limit pass request to Fsp\n") );

                //
                //  Decode the file object to get the Scb
                //

                FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

                TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );
                if ((TypeOfOpen != UserFileOpen) &&
                    (TypeOfOpen != StreamFileOpen) &&
                    (TypeOfOpen != UserVolumeOpen)) {

                    NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }

                //
                //  We cannot post any compressed reads, because that would interfere
                //  with our reserved buffer strategy.  We may currently own
                //  NtfsReservedBufferResource, and it is important for our read to
                //  be able to get a buffer.
                //

                ASSERT( (Scb->CompressionUnit == 0) ||
                        !ExIsResourceAcquiredExclusiveLite(&NtfsReservedBufferResource) );

                //
                //  To avoid deadlocks we only should post recursive paging file and mft requests
                //  o.w we might need to do lockups for example and reacquire the main in a diff. thread
                //  from where it was preacquired
                //

//                ASSERT( (Scb == Vcb->MftScb) || (FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) );

                //
                //  Allocate an event and get shared on the scb.  We won't grab the
                //  Scb for the paging file path or for non-cached io for our
                //  system files.
                //

                KeInitializeEvent( &Event, NotificationEvent, FALSE );

                if ((FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )
                     && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) ||
                    (NtfsLeqMftRef( &Fcb->FileReference, &VolumeFileReference ))) {

                    //
                    //  There is nothing to release in this case.
                    //

                    Resource = NULL;

                } else {

                    NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                    Resource = Fcb->Resource;

                }

                try {

                    //
                    //  Make the Irp just like a regular post request and
                    //  then send the Irp to the special overflow thread.
                    //  After the post we will wait for the stack overflow
                    //  read routine to set the event that indicates we can
                    //  now release the scb resource and return.
                    //

                    NtfsPrePostIrp( IrpContext, Irp );

                    if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                        FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                        FsRtlPostPagingFileStackOverflow( IrpContext, &Event, NtfsStackOverflowRead );

                    } else {

                        FsRtlPostStackOverflow( IrpContext, &Event, NtfsStackOverflowRead );
                    }

                    //
                    //  And wait for the worker thread to complete the item
                    //

                    (VOID) KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );

                    Status = STATUS_PENDING;

                } finally {

                    if (Resource != NULL) {

                        NtfsReleaseResource( IrpContext, Scb );
                    }
                }

            //
            //  Identify read requests which can't wait and post them to the
            //  Fsp.
            //

            } else {

#ifdef COMPRESS_ON_WRITE

                //
                //  Capture the auxiliary buffer and clear its address if it
                //  is not supposed to be deleted by the I/O system on I/O completion.
                //

                if (Irp->Tail.Overlay.AuxiliaryBuffer != NULL) {

                    IrpContext->Union.AuxiliaryBuffer =
                      (PFSRTL_AUXILIARY_BUFFER)Irp->Tail.Overlay.AuxiliaryBuffer;

                    if (!FlagOn(IrpContext->Union.AuxiliaryBuffer->Flags,
                                FSRTL_AUXILIARY_FLAG_DEALLOCATE)) {

                        Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
                    }
                }
#endif

                Status = NtfsCommonRead( IrpContext, Irp, TRUE );
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NTSTATUS ExceptionCode;

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  exception code
            //

            ExceptionCode = GetExceptionCode();

            if (ExceptionCode == STATUS_FILE_DELETED) {
                IrpContext->ExceptionStatus = ExceptionCode = STATUS_END_OF_FILE;

                Irp->IoStatus.Information = 0;
            }

            Status = NtfsProcessException( IrpContext,
                                           Irp,
                                           ExceptionCode );
        }

    //
    //  Retry if this is a top level request, and the Irp was not completed due
    //  to a retryable error.
    //

    RetryCount += 1;

    } while ((Status == STATUS_CANT_WAIT || Status == STATUS_LOG_FILE_FULL) &&
             TopLevelContext.TopLevelRequest);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdRead -> %08lx\n", Status) );

    return Status;

    UNREFERENCED_PARAMETER( VolumeDeviceObject );
}


//
//  Internal support routine
//

VOID
NtfsStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine processes a read request that could not be processed by
    the fsp thread because of stack overflow potential.

Arguments:

    Context - Supplies the IrpContext being processed

    Event - Supplies the event to be signaled when we are done processing this
        request.

Return Value:

    None.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    PIRP_CONTEXT IrpContext = Context;

    //
    //  Make it now look like we can wait for I/O to complete
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );

    //
    //  Do the read operation protected by a try-except clause
    //

    try {

        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

        //
        //  Set the flag to indicate that we are in the overflow thread.
        //

        ThreadTopLevelContext->OverflowReadThread = TRUE;

        (VOID) NtfsCommonRead( IrpContext, IrpContext->OriginatingIrp, FALSE );

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        NTSTATUS ExceptionCode;

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        ExceptionCode = GetExceptionCode();

        if (ExceptionCode == STATUS_FILE_DELETED) {

            IrpContext->ExceptionStatus = ExceptionCode = STATUS_END_OF_FILE;
            IrpContext->OriginatingIrp->IoStatus.Information = 0;
        }

        (VOID) NtfsProcessException( IrpContext, IrpContext->OriginatingIrp, ExceptionCode );
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    //
    //  Set the stack overflow item's event to tell the original
    //  thread that we're done and then go get another work item.
    //

    KeSetEvent( Event, 0, FALSE );
}


NTSTATUS
NtfsCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN BOOLEAN AcquireScb
    )

/*++

Routine Description:

    This is the common routine for Read called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

    AcquireScb - Indicates if this routine should acquire the scb

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PNTFS_ADVANCED_FCB_HEADER Header;

    PTOP_LEVEL_CONTEXT TopLevelContext;

    VBO StartingVbo;
    LONGLONG ByteCount;
    LONGLONG ByteRange;
    ULONG RequestedByteCount;

    BOOLEAN PostIrp = FALSE;
    BOOLEAN OplockPostIrp = FALSE;

    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN ReleaseScb;
    BOOLEAN PagingIoAcquired = FALSE;
    BOOLEAN DoingIoAtEof = FALSE;

    BOOLEAN Wait;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN SynchronousIo;
    BOOLEAN PagingFileIo;

#ifdef  COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
    BOOLEAN CompressedIo = FALSE;
#endif

    NTFS_IO_CONTEXT LocalContext;

    //
    // A system buffer is only used if we have to access the
    // buffer directly from the Fsp to clear a portion or to
    // do a synchronous I/O, or a cached transfer.  It is
    // possible that our caller may have already mapped a
    // system buffer, in which case we must remember this so
    // we do not unmap it on the way out.
    //

    PVOID SystemBuffer = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonRead\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("ByteCount  = %08lx\n", IrpSp->Parameters.Read.Length) );
    DebugTrace( 0, Dbg, ("ByteOffset = %016I64x\n", IrpSp->Parameters.Read.ByteOffset) );
    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Let's kill invalid read requests.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != StreamFileOpen) &&
        (TypeOfOpen != UserVolumeOpen)) {

        DebugTrace( 0, Dbg, ("Invalid file object for read\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonRead:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Initialize the appropriate local variables.
    //

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    PagingIo = BooleanFlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = BooleanFlagOn( Irp->Flags,IRP_NOCACHE );
    SynchronousIo = BooleanFlagOn( FileObject->Flags, FO_SYNCHRONOUS_IO );
    PagingFileIo = FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

#ifdef COMPRESS_ON_WIRE
    if (FileObject->SectionObjectPointer == &Scb->NonpagedScb->SegmentObjectC) {

        CompressedIo = TRUE;
    }
#endif

    //
    //  Extract starting Vbo and offset.
    //

    StartingVbo = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    ByteCount = (LONGLONG)IrpSp->Parameters.Read.Length;

    //
    // Check for overflow and underflow.
    //

    if (MAXLONGLONG - StartingVbo < ByteCount) {

        ASSERT( !PagingIo );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    ByteRange = StartingVbo + ByteCount;
    RequestedByteCount = (ULONG)ByteCount;

    //
    //  Check for a null request, and return immediately
    //

    if ((ULONG)ByteCount == 0) {

        DebugTrace( 0, Dbg, ("No bytes to read\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonRead:  Exit -> %08lx\n", STATUS_SUCCESS) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Convert all paging i/o against a usa_protected_sequence or compressed file
    //  to synchrnonous because we must do the transform after finishing the i/o
    //  If the header isn't initialized just do the op synchronous rather than
    //  trying to figure out if its compressed by resyncing with disk
    //

    if (!Wait &&
        PagingIo &&
        (FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT ) ||
         (Scb->CompressionUnit != 0) ||
         Scb->EncryptionContext) ||
         !FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

        Wait = TRUE;
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    }


    //
    //  Make sure there is an initialized NtfsIoContext block.
    //

    if (!PagingFileIo) {
        NtfsInitializeIoContext( IrpContext, &LocalContext, PagingIo );
    }
        
    //
    //  Handle volume Dasd here.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        //
        //  If the caller has not asked for extended DASD IO access then
        //  limit with the volume size.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_XTENDED_DASD_IO )) {

            //
            //  If the starting vbo is past the end of the volume, we are done.
            //

            if (Scb->Header.FileSize.QuadPart <= StartingVbo) {

                DebugTrace( 0, Dbg, ("No bytes to read\n") );
                DebugTrace( -1, Dbg, ("NtfsCommonRead:  Exit -> %08lx\n", STATUS_END_OF_FILE) );

                NtfsCompleteRequest( IrpContext, Irp, STATUS_END_OF_FILE );
                return STATUS_END_OF_FILE;

            //
            //  If the write extends beyond the end of the volume, truncate the
            //  bytes to write.
            //

            } else if (Scb->Header.FileSize.QuadPart < ByteRange) {
                
                ByteCount = Scb->Header.FileSize.QuadPart - StartingVbo;
            }
        }

        //
        //  Set the io context async if necc. before doing the i/o
        //  

        if (!Wait) {
            NtfsSetIoContextAsync( IrpContext, NULL, (ULONG)ByteCount ); 
        }

        Status = NtfsVolumeDasdIo( IrpContext,
                                   Irp,
                                   Scb,
                                   Ccb,
                                   StartingVbo,
                                   (ULONG)ByteCount );

        //
        //  If the volume was opened for Synchronous IO, update the current
        //  file position.
        //

        if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

            IrpSp->FileObject->CurrentByteOffset.QuadPart = StartingVbo + Irp->IoStatus.Information;
        }

        DebugTrace( 0, Dbg, ("Complete with %08lx bytes read\n", Irp->IoStatus.Information) );
        DebugTrace( -1, Dbg, ("NtfsCommonRead:  Exit -> %08lx\n", Status) );

    
        if (Wait) {
            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
        return Status;
    }

    //
    //  Keep a pointer to the common fsrtl header.
    //

    Header = &Scb->Header;

    //
    //  If this is a paging file, just send it to the device driver.
    //  We assume Mm is a good citizen.
    //

    if (PagingFileIo) {

        if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
        }

        //
        //  Do the usual STATUS_PENDING things.
        //

        IoMarkIrpPending( Irp );

        //
        //  Perform the actual IO, it will be completed when the io finishes.
        //

        NtfsPagingFileIo( IrpContext,
                          Irp,
                          Scb,
                          StartingVbo,
                          (ULONG)ByteCount );

        //
        //  We, nor anybody else, need the IrpContext any more.
        //

        NtfsCompleteRequest( IrpContext, NULL, 0 );
        return STATUS_PENDING;
    }

    //
    //  Accumulate interesting statistics.
    //

    if (PagingIo) {
        CollectReadStats( Vcb, TypeOfOpen, Scb, Fcb, ByteCount );
    }


    //
    //  Use a try-finally to free Scb and buffers on the way out.
    //  At this point we can treat all requests identically since we
    //  have a usable Scb for each of them.  (Volume, User or Stream file)
    //

    try {

        //
        // This case corresponds to a non-directory file read.
        //

        LONGLONG FileSize;
        LONGLONG ValidDataLength;

        //
        //  If this is a noncached transfer and is not a paging I/O, and
        //  the file has a data section, then we will do a flush here
        //  to avoid stale data problems.  Note that we must flush before
        //  acquiring the Fcb shared since the write may try to acquire
        //  it exclusive.  This is not necessary for compressed files, since
        //  we will turn user noncached writes into cached writes.
        //

        if (!PagingIo &&
            NonCachedIo &&
            (FileObject->SectionObjectPointer->DataSectionObject != NULL)) {
            
            //
            //  Acquire the paging exclusive to avoid collided flushes
            //  

            NtfsAcquirePagingResourceExclusive( IrpContext, Scb, TRUE );

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                //
                //  It is possible that this read is part of a top level request or
                //  is being called by MM to create an image section.  We will update
                //  the top-level context to reflect this.  All of the exception
                //  handling will correctly handle the log file full in this case.
                //

                TopLevelContext = NtfsGetTopLevelContext();

                if (TopLevelContext->SavedTopLevelIrp != NULL) {

                    TopLevelContext->TopLevelRequest = FALSE;
                }

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    ULONG Flags = SCE_FLAG_READ;

                    if (PagingIo) {
                        SetFlag( Flags, SCE_FLAG_PAGING );
                    }
                    if (!SynchronousIo) {
                        SetFlag( Flags, SCE_FLAG_ASYNC );
                    }

                    FsRtlLogSyscacheEvent( Scb, SCE_CC_FLUSH, Flags, StartingVbo, ByteCount, 0 );
                }
#endif


                CcFlushCache( FileObject->SectionObjectPointer,
                              (PLARGE_INTEGER)&StartingVbo,
                              (ULONG)ByteCount,
                              &Irp->IoStatus );

                NtfsReleasePagingResource( IrpContext, Scb );

                //
                //  Check for errors in the flush.
                //

                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                    &Irp->IoStatus.Status,
                                                    TRUE,
                                                    STATUS_UNEXPECTED_IO_ERROR );

            } else {

                NtfsReleasePagingResource( IrpContext, Scb );
            }

        }

#ifdef  COMPRESS_ON_WIRE

        //
        //  For top-level noncached reads (including page reads and read-ahead paged reads),
        //  to the normal data section when a compressed section exists, we have to flush the
        //  range in the compressed section first.  Note that NtfsSynchronizeUncompressedIo
        //  is used to synchronize the cached case below.
        //
        //  Currently only cached access is supported to the compressed section, and the
        //  coherency to that section is synchronized in rwcmpsup.c.  You do not see a similar
        //  block of code in write.c, which would only be concerned about user-mapped files,
        //  since user-mapping is incompatible with writes to the compressed stream, and in
        //  fact the user mapper would break the oplocks that allow the only compressed stream
        //  access supported at this time.
        //

        if ((Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) &&
            !CompressedIo &&
            NonCachedIo &&
            (NtfsGetTopLevelContext()->SavedTopLevelIrp == NULL)) {

            LONGLONG LocalVbo;
            ULONG LocalCount;

            NtfsAcquirePagingResourceShared( IrpContext, Scb, TRUE );

            LocalVbo = BlockAlignTruncate( StartingVbo, (LONG)Scb->CompressionUnit );
            LocalCount = BlockAlign( (ULONG)((ByteCount + (StartingVbo - LocalVbo)), (LONG)Scb->CompressionUnit ); 

            CcFlushCache( &Scb->NonpagedScb->SegmentObjectC,
                          (PLARGE_INTEGER)&LocalVbo,
                          LocalCount,
                          &Irp->IoStatus );

            NtfsReleasePagingResource( IrpContext, Scb );

#ifdef NTFS_RWC_DEBUG
            ASSERT( !NtfsBreakOnConflict ||
                    (IrpContext->TopLevelIrpContext->ExceptionStatus != STATUS_CANT_WAIT) );
#endif

            //
            //  Check for errors in the flush.
            //

            NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                &Irp->IoStatus.Status,
                                                TRUE,
                                                STATUS_UNEXPECTED_IO_ERROR );

        }
#endif
        //
        //  We need shared access to the Scb before proceeding.
        //  We won't acquire the Scb for a non-cached read of the first 4
        //  file records.
        //

        if (AcquireScb &&

            (!NonCachedIo || NtfsGtrMftRef( &Fcb->FileReference, &VolumeFileReference))) {

            //
            //  Figure out if we have been entered during the posting
            //  of a top level request.
            //

            TopLevelContext = NtfsGetTopLevelContext();

            //
            //  Initially we always force reads to appear to be top level
            //  requests.  If we reach this point the read not to the paging
            //  file so it is safe to determine if we are really a top level
            //  request.  If there is an Ntfs request above us we will clear
            //  the TopLevelRequest field in the TopLevelContext.
            //

            if (TopLevelContext->ValidSavedTopLevel) {
                TopLevelContext->TopLevelRequest = FALSE;
            }

            //
            //  If this is not a paging I/O (cached or user noncached I/O),
            //  then acquire the paging I/O resource.  (Note, you can only
            //  do cached I/O to user streams, and they always have a paging
            //  I/O resource.
            //

            if (!PagingIo) {

                //
                //  If we cannot acquire the resource, then raise.
                //

                if (!NtfsAcquirePagingResourceSharedWaitForExclusive( IrpContext, Scb, Wait )) {
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }
                PagingIoAcquired = TRUE;

                //
                //  Check if we have already gone through cleanup on this handle.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_CLEANUP )) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CLOSED, NULL, NULL );
                }

                //
                //  The reason that we always handle the user requests through the cache,
                //  is that there is no better way to deal with alignment issues, for
                //  the frequent case where the user noncached I/O is not an integral of
                //  the Compression Unit.  Also, the way we synchronize the case where
                //  a compression unit is being moved to a different spot on disk during
                //  a write, is to keep the pages locked in memory during the write, so
                //  that there will be no need to read the disk at the same time.  (If
                //  we allowed real noncached I/O, then we would somehow have to synchronize
                //  the noncached read with the write of the same data.)
                //
                //  Bottom line is we can only really support cached reads to compresed
                //  files.
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) && NonCachedIo) {

                    NonCachedIo = FALSE;

                    if (Scb->FileObject == NULL) {

                        //
                        //  Make sure we are serialized with the FileSizes, and
                        //  will remove this condition if we abort.
                        //

                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;

                        NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }

                    FileObject = Scb->FileObject;
                }

                //
                //  Now check if the attribute has been deleted or if the
                //  volume has been dismounted.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED)) {

                    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
                    } else {
                        NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                    }
                }

            //
            //  If this is a paging I/O, and there is a paging I/O resource, then
            //  we acquire the main resource here.  Note that for most paging I/Os
            //  (like faulting for cached I/O), we already own the paging I/O resource,
            //  so we acquire nothing here!  But, for other cases like user-mapped files,
            //  we do check if paging I/O is acquired, and acquire the main resource if
            //  not.  The point is, we need some guarantee still that the file will not
            //  be truncated.
            //

            } else if ((Scb->Header.PagingIoResource != NULL) &&
                        !NtfsIsSharedScbPagingIo( Scb )) {

                //
                //  If we cannot acquire the resource, then raise.
                //

                if (!NtfsAcquireResourceShared( IrpContext, Scb, Wait )) {
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                ScbAcquired = TRUE;

                //
                //  Now check if the attribute has been deleted or if the
                //  volume has been dismounted.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED )) {
                    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
                    } else {
                        NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                    }
                }
            }
        }

        //
        //  If the Scb is uninitialized, we initialize it now.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );

            ReleaseScb = FALSE;

            if (AcquireScb && !ScbAcquired) {

                NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                ScbAcquired = TRUE;
                ReleaseScb = TRUE;
            }

            NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

            if (ReleaseScb) {

                NtfsReleaseResource( IrpContext, Scb );
                ScbAcquired = FALSE;
            }
        }

        //
        //  We check whether we can proceed
        //  based on the state of the file oplocks.
        //

        if (TypeOfOpen == UserFileOpen) {

            Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NtfsOplockComplete,
                                       NtfsPrePostIrp );

            if (Status != STATUS_SUCCESS) {

                OplockPostIrp = TRUE;
                PostIrp = TRUE;
                try_return( NOTHING );
            }

            //
            //  This oplock call can affect whether fast IO is possible.
            //  We may have broken an oplock to no oplock held.  If the
            //  current state of the file is FastIoIsNotPossible then
            //  recheck the fast IO state.
            //

            if (Scb->Header.IsFastIoPossible == FastIoIsNotPossible) {

                NtfsAcquireFsrtlHeader( Scb );
                Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
                NtfsReleaseFsrtlHeader( Scb );
            }

            //
            // We have to check for read access according to the current
            // state of the file locks.
            //

            if (!PagingIo
                && Scb->ScbType.Data.FileLock != NULL
                && !FsRtlCheckLockForReadAccess( Scb->ScbType.Data.FileLock,
                                                 Irp )) {

                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
            }
        }

        //
        //  Now synchronize with the FsRtl Header
        //

        NtfsAcquireFsrtlHeader( (PSCB) Header );
        
        //
        //  Now see if we are reading beyond ValidDataLength.  We have to
        //  do it now so that our reads are not nooped.  We only need to block
        //  on nonrecursive I/O (cached or page fault to user section, because
        //  if it is paging I/O, we must be part of a reader or writer who is
        //  synchronized.
        //

        if ((ByteRange > Header->ValidDataLength.QuadPart) && !PagingIo) {

            //
            //  We must serialize with anyone else doing I/O at beyond
            //  ValidDataLength, and then remember if we need to declare
            //  when we are done.  If our caller has already serialized
            //  with EOF then there is nothing for us to do here.
            //

            if ((IrpContext->TopLevelIrpContext->CleanupStructure == Fcb) ||
                (IrpContext->TopLevelIrpContext->CleanupStructure == Scb)) {

                DoingIoAtEof = TRUE;

            } else {

                DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                               NtfsWaitForIoAtEof( Header,
                                                   (PLARGE_INTEGER)&StartingVbo,
                                                   (ULONG)ByteCount );

                //
                //  Set the Flag if we are in fact beyond ValidDataLength.
                //

                if (DoingIoAtEof) {
                    SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
                    IrpContext->CleanupStructure = Scb;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();

                } else {

                    ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                }
            }
        }

        //
        //  Get file sizes from the Scb.
        //
        //  We must get ValidDataLength first since it is always
        //  increased second (the case we are unprotected) and
        //  we don't want to capture ValidDataLength > FileSize.
        //

        ValidDataLength = Header->ValidDataLength.QuadPart;
        FileSize = Header->FileSize.QuadPart;

        NtfsReleaseFsrtlHeader( (PSCB) Header );
        
        //
        //  Optimize for the case where we are trying to fault in an entire
        //  compression unit, even if past the end of the file.  Go ahead
        //  and round the local FileSize to a compression unit boundary.
        //  This will allow all of these pages to come into memory when
        //  CC touches the first page out of memory.  Otherwise CC will
        //  force them into memory one page at a time.
        //

        if (PagingIo) {

            if (NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ) &&
                FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                !FlagOn(Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT)) {

                FileSize = BlockAlign( FileSize, (LONG)Scb->CompressionUnit );
            }

#ifdef  COMPRESS_ON_WIRE
            
            //
            //  If we are reading the compressed stream then we may need the
            //  data past file size.
            //

            if (CompressedIo) {

                ValidDataLength = BlockAlign( ValidDataLength, (LONG)Scb->CompressionUnit );
            }
#endif

            //
            //  If this is the Usn Journal then bias the Io to the correct location in the
            //  file.
            //

            if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

                StartingVbo += Vcb->UsnCacheBias;
                ByteRange = StartingVbo + (LONGLONG) IrpSp->Parameters.Read.Length;
            }
        }

        //
        // If the read starts beyond End of File, return EOF.
        //

        if (StartingVbo >= FileSize) {

            DebugTrace( 0, Dbg, ("End of File\n") );

            try_return ( Status = STATUS_END_OF_FILE );
        }

        //
        //  If the read extends beyond EOF, truncate the read
        //

        if (ByteRange > FileSize) {

#ifdef NTFS_RWC_DEBUG
#ifdef  COMPRESS_ON_WIRE
            if (CompressedIo &&
                (StartingVbo < NtfsRWCHighThreshold) &&
                (ByteRange > NtfsRWCLowThreshold)) {

                PRWC_HISTORY_ENTRY NextBuffer;

                NextBuffer = NtfsGetHistoryEntry( Scb );

                NextBuffer->Operation = TrimCompressedRead;
                NextBuffer->Information = Scb->Header.FileSize.LowPart;
                NextBuffer->FileOffset = (ULONG) StartingVbo;
                NextBuffer->Length = (ULONG) ByteRange;
            }
#endif
#endif
            ByteCount = FileSize - StartingVbo;
            ByteRange = StartingVbo + ByteCount;

            RequestedByteCount = (ULONG)ByteCount;
        }


        //
        //  HANDLE THE NONCACHED RESIDENT ATTRIBUTE CASE
        //
        //  We let the cached case take the normal path for the following
        //  reasons:
        //
        //    o To insure data coherency if a user maps the file
        //    o To get a page in the cache to keep the Fcb around
        //    o So the data can be accessed via the Fast I/O path
        //
        //  The disadvantage is the overhead to fault the data in the
        //  first time, but we may be able to do this with asynchronous
        //  read ahead.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT | SCB_STATE_CONVERT_UNDERWAY ) && NonCachedIo) {

            ReleaseScb = FALSE;

            if (AcquireScb && !ScbAcquired) {
                NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                ScbAcquired = TRUE;
                ReleaseScb = TRUE;
            }

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {
                
                NtfsNonCachedResidentRead( IrpContext, Irp, Scb, (ULONG)StartingVbo, (ULONG)ByteCount );
                try_return( Status = STATUS_SUCCESS );

            } else {

                if (ReleaseScb) {
                    NtfsReleaseResource( IrpContext, Scb );
                    ScbAcquired = FALSE;
                }
            }
        }


        //
        //  HANDLE THE NON-CACHED CASE
        //

        if (NonCachedIo) {

            ULONG BytesToRead;

            ULONG SectorSize;

            ULONG ZeroOffset;
            ULONG ZeroLength = 0;

            DebugTrace( 0, Dbg, ("Non cached read.\n") );

            //
            //  For a compressed stream, which is user-mapped, reserve space
            //  as pages come in.
            //

            if (FlagOn( Header->Flags, FSRTL_FLAG_USER_MAPPED_FILE ) &&
                FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                !NtfsReserveClusters( IrpContext, Scb, StartingVbo, (ULONG)ByteCount )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
            }

            //
            //  If this is a read of an encrypted file then make it synchronous.  We
            //  need to do this so that the encryption driver has a thread to run in.
            //

            if ((Scb->EncryptionContext != NULL) &&
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) &&
                (NtfsData.EncryptionCallBackTable.AfterReadProcess != NULL) &&
                NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                Wait = TRUE;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
            }

            //
            //  Start by zeroing any part of the read after Valid Data
            //

            if (ByteRange > ValidDataLength) {

                ReleaseScb = FALSE;

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    //
                    //  For compressed files we need to look at ValidDataToDisk, because it could be higher.
                    //  This requires the main resource
                    //

                    if (AcquireScb && !ScbAcquired) {
                        NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                        ScbAcquired = TRUE;
                        ReleaseScb = TRUE;
                    }

                    //
                    //  If ValidDataToDisk is actually greater than
                    //  ValidDataLength, then we must have lost a page
                    //  during the middle of a write, and we should not
                    //  zero that data on the way back in!
                    //

                    if (ValidDataLength < Scb->ValidDataToDisk) {
                        ValidDataLength = Scb->ValidDataToDisk;
                    }
                }

                if (ByteRange > ValidDataLength) {

                    if (StartingVbo < ValidDataLength) {

                        //
                        //  Assume we will zero the entire amount.
                        //

                        ZeroLength = (ULONG)ByteCount;

                        //
                        //  The new byte count and the offset to start filling with zeroes.
                        //

                        ByteCount = ValidDataLength - StartingVbo;
                        ZeroOffset = (ULONG)ByteCount;

                        //
                        //  Now reduce the amount to zero by the zero offset.
                        //

                        ZeroLength -= ZeroOffset;

                        //
                        //  If this was non-cached I/O then convert it to synchronous.
                        //  This is because we don't want to zero the buffer now or
                        //  we will lose the data when the driver purges the cache.
                        //

                        if (!Wait) {

                            Wait = TRUE;
                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
                        }

                        //
                        //  Reserve the clusters in the range beyond VDL
                        //

                        if ((PagingIo) &&
                            (FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) &&
                            (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE)) {

                            if (!NtfsReserveClusters( IrpContext,
                                                      Scb,
                                                      ZeroOffset,
                                                      ZeroLength )) {

                                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                            }
                        }


                    } else {

                        //
                        //  Reserve space for mapped sparse files which would normally be
                        //  done in NtfsPrepareBuffers
                        //

                        if ((PagingIo) &&
                            (FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) &&
                            (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE)) {

                            if (!NtfsReserveClusters( IrpContext,
                                                      Scb,
                                                      StartingVbo,
                                                      (ULONG)ByteCount )) {

                                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                            }
                        }

                        //
                        //  All we have to do now is sit here and zero the
                        //  user's buffer, no reading is required.
                        //

                        NtfsFillIrpBuffer( IrpContext, Irp, (ULONG)ByteCount, 0, 0 );

#ifdef SYSCACHE_DEBUG
                        
                        if (ScbIsBeingLogged( Scb )) {
                            ULONG Flags = SCE_FLAG_READ;

                            if (PagingIo) {
                                Flags |= SCE_FLAG_PAGING;
                            }
                            if (!SynchronousIo) {
                                Flags |= SCE_FLAG_ASYNC;
                            }

                            ASSERT( Scb->NonpagedScb->SegmentObject.ImageSectionObject == NULL );

                            FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, Flags, StartingVbo, ByteCount, ValidDataLength );
                        }
#endif


                        Irp->IoStatus.Information = (ULONG)ByteCount;

                        try_return ( Status = STATUS_SUCCESS );
                    }
                }

                //
                //  Now free the Scb if we only acquired it here.
                //

                if (ReleaseScb) {
                    NtfsReleaseResource( IrpContext, Scb );
                    ScbAcquired = FALSE;
                }
            }

            //
            //  Get the sector size
            //

            SectorSize = Vcb->BytesPerSector;

            //
            //  Round up to a sector boundry
            //

            BytesToRead = BlockAlign( (ULONG)ByteCount, (LONG)SectorSize );

            //
            //  Call a special routine if we do not have sector alignment
            //  and the file is not compressed.
            //

            if (((((ULONG) StartingVbo) & (SectorSize - 1)) ||
                 (BytesToRead > IrpSp->Parameters.Read.Length))

                         &&

                !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                //
                //  If we can't wait, we must post this.
                //

                if (!Wait) {

                    try_return( PostIrp = TRUE );
                }

                //
                //  Do the physical read.
                //

#ifdef  COMPRESS_ON_WIRE
                ASSERT( !CompressedIo );
#endif
                ASSERT( Wait );

                NtfsNonCachedNonAlignedIo( IrpContext,
                                           Irp,
                                           Scb,
                                           StartingVbo,
                                           (ULONG)ByteCount );

                BytesToRead = (ULONG)ByteCount;

            } else {

                //
                //  Just to help reduce confusion.  At this point:
                //
                //  RequestedByteCount - is the number of bytes originally
                //                       taken from the Irp, but constrained
                //                       to filesize.
                //
                //  ByteCount -          is RequestedByteCount constrained to
                //                       ValidDataLength.
                //
                //  BytesToRead -        is ByteCount rounded up to sector
                //                       boundry.  This is the number of bytes
                //                       that we must physically read.
                //

                if (!Wait) {

                    //
                    //  Setup the async io context info 
                    //  

                    if (!PagingIo) {
                        NtfsSetIoContextAsync( IrpContext, Scb->Header.PagingIoResource, RequestedByteCount );
                    } else if (ScbAcquired) {
                        NtfsSetIoContextAsync( IrpContext, Scb->Header.Resource, RequestedByteCount );
                    } else {
                        NtfsSetIoContextAsync( IrpContext, NULL, RequestedByteCount );
                    }
                }

#if defined( BENL_DBG ) || defined( NTFSDBG )
                try {
#endif

                //
                //  Perform the actual IO - all resources will be released by
                //  the completion routine after this point if its successful
                //

                Status = NtfsNonCachedIo( IrpContext,
                                          Irp,
                                          Scb,
                                          StartingVbo,
                                          BytesToRead,
#ifdef  COMPRESS_ON_WIRE
                                          (CompressedIo ? COMPRESSED_STREAM : 0)
#else
                                          0 );
#endif

#if defined( BENL_DBG ) || defined( NTFSDBG )
                } finally {
#endif

#if defined( BENL_DBG ) || defined( NTFSDBG )
                }
#endif


                if (Status == STATUS_PENDING)  {

                    //
                    //  Ownership of the irp / iocontext  and paging resource
                    //  is passed to the async completion routine
                    //  

                    IrpContext->Union.NtfsIoContext = NULL;
                    PagingIoAcquired = FALSE;

#ifdef NTFSDBG
                    //
                    //  Reflect transfer of main ownership to completion routine
                    //

                    if (ScbAcquired) {
    
                        NTFS_RESOURCE_NAME ResourceName;
    
                        ResourceName = NtfsIdentifyFcb( Vcb, Scb->Fcb );
                        NtfsChangeResourceOrderState( IrpContext, ResourceName, TRUE, FALSE );

                    }
#endif
                    
                    ScbAcquired = FALSE;
                    Irp = NULL;

                    try_return( Status );
                }
            }

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

                NtfsNormalizeAndRaiseStatus( IrpContext,
                                             Status,
                                             STATUS_UNEXPECTED_IO_ERROR );
            }

            //
            //  Else set the Irp information field to reflect the
            //  entire desired read.
            //

            ASSERT( Irp->IoStatus.Information == BytesToRead );

            Irp->IoStatus.Information = RequestedByteCount;

            //
            //  If we rounded up to a sector boundry before, zero out
            //  the other garbage we read from the disk.
            //

            if (BytesToRead > (ULONG)ByteCount) {

                NtfsFillIrpBuffer( IrpContext, Irp, BytesToRead - (ULONG)ByteCount, (ULONG)ByteCount, 0 );

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    ULONG Flags = SCE_FLAG_READ;

                    if (PagingIo)
                    {
                        Flags |= SCE_FLAG_PAGING;
                    }
                    if (!SynchronousIo)
                    {
                        Flags |= SCE_FLAG_ASYNC;
                    }

                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, Flags, ByteCount + StartingVbo, BytesToRead - ByteCount, 0 );
                }
#endif

            }

            //
            //  If we need to zero the tail of the buffer because of valid data
            //  then do so now.
            //

            if (ZeroLength != 0) {

                NtfsFillIrpBuffer( IrpContext, Irp, ZeroLength, ZeroOffset, 0 );

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    ULONG Flags = SCE_FLAG_READ;

                    if (PagingIo)
                    {
                        Flags |= SCE_FLAG_PAGING;
                    }
                    if (!SynchronousIo)
                    {
                        Flags |= SCE_FLAG_ASYNC;
                    }

                    ASSERT( Scb->NonpagedScb->SegmentObject.ImageSectionObject == NULL );
                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, Flags, ZeroOffset + StartingVbo, ZeroLength, 0 );
                }
#endif

            }

            //
            // The transfer is complete.
            //

            try_return( Status );

        }   // if No Intermediate Buffering


        //
        //  HANDLE THE CACHED CASE
        //

        else {

            //
            //  We need to go through the cache for this
            //  file object.  First handle the noncompressed calls.
            //

#ifdef  COMPRESS_ON_WIRE
            if (!FlagOn(IrpContext->MinorFunction, IRP_MN_COMPRESSED)) {
#endif

                //
                // We delay setting up the file cache until now, in case the
                // caller never does any I/O to the file, and thus
                // FileObject->PrivateCacheMap == NULL.
                //

                if (FileObject->PrivateCacheMap == NULL) {

                    DebugTrace( 0, Dbg, ("Initialize cache mapping.\n") );

                    //
                    //  Now initialize the cache map.
                    //
                    //  Make sure we are serialized with the FileSizes, and
                    //  will remove this condition if we abort.
                    //

                    if (!DoingIoAtEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

                    CcInitializeCacheMap( FileObject,
                                          (PCC_FILE_SIZES)&Header->AllocationSize,
                                          FALSE,
                                          &NtfsData.CacheManagerCallbacks,
                                          Scb );

                    if (!DoingIoAtEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }

                    CcSetReadAheadGranularity( FileObject, READ_AHEAD_GRANULARITY );
                }

                //
                // DO A NORMAL CACHED READ, if the MDL bit is not set,
                //

                DebugTrace( 0, Dbg, ("Cached read.\n") );

                //
                //  If there is a compressed section, we have to do cache coherency for
                //  that stream, and loop here to do a Cache Manager view at a time.
                //

#ifdef  COMPRESS_ON_WIRE
                if (Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                    LONGLONG LocalOffset = StartingVbo;
                    ULONG LocalLength;
                    ULONG LengthLeft = (ULONG) ByteCount;

                    //
                    //  Create the compressed stream if not there.
                    //

                    if (Header->FileObjectC == NULL) {
                        NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );
                    }

                    if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                        //
                        //  Get hold of the user's buffer.
                        //

                        SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
                    }

                    //
                    //  We must loop to do a view at a time, because that is how much
                    //  we synchronize at once below.
                    //

                    do {

                        ULONG PageCount;
                        ULONG ViewOffset;

                        //
                        //  Calculate length left in view.
                        //

                        LocalLength = LengthLeft;
                        if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                            LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                        }

                        //
                        //  Trim the read so we don't inadvertently go beyond the end of the
                        //  view because of the MM read ahead.
                        //

                        ViewOffset = ((ULONG) LocalOffset & (VACB_MAPPING_GRANULARITY - 1));
                        PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(((PVOID)(ULONG_PTR)((ULONG)LocalOffset)), LocalLength);

                        if (LocalLength > (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset)) {

#ifdef NTFS_RWC_DEBUG
                            if ((LocalOffset < NtfsRWCHighThreshold) &&
                                (LocalOffset + LocalLength > NtfsRWCLowThreshold)) {

                                PRWC_HISTORY_ENTRY NextBuffer;

                                NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                                NextBuffer->Operation = TrimCopyRead;
                                NextBuffer->Information = PageCount;
                                NextBuffer->FileOffset = (ULONG) LocalOffset;
                                NextBuffer->Length = (ULONG) LocalLength;
                            }
#endif
                            LocalLength = (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset);
                        }

                        Status = NtfsSynchronizeUncompressedIo( Scb,
                                                                &LocalOffset,
                                                                LocalLength,
                                                                FALSE,
                                                                &CompressionSync );

                        //
                        //  If we successfully synchronized, then do a piece of the transfer.
                        //

                        if (NT_SUCCESS(Status)) {

                            if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                                //
                                // Now try to do the copy.
                                //

                                if (!CcCopyRead( FileObject,
                                                 (PLARGE_INTEGER)&LocalOffset,
                                                 LocalLength,
                                                 Wait,
                                                 SystemBuffer,
                                                 &Irp->IoStatus )) {

                                    DebugTrace( 0, Dbg, ("Cached Read could not wait\n") );

                                    try_return( PostIrp = TRUE );
                                }

                                SystemBuffer = Add2Ptr( SystemBuffer, LocalLength );

                            //
                            //  HANDLE A MDL READ
                            //

                            } else {

                                DebugTrace( 0, Dbg, ("MDL read.\n") );

                                ASSERT( Wait );

#ifdef NTFS_RWCMP_TRACE
                                if (NtfsCompressionTrace && IsSyscache(Header)) {
                                    DbgPrint("CcMdlRead: FO = %08lx, Len = %08lx\n", (ULONG)LocalOffset, LocalLength );
                                }
#endif

                                CcMdlRead( FileObject,
                                           (PLARGE_INTEGER)&LocalOffset,
                                           LocalLength,
                                           &Irp->MdlAddress,
                                           &Irp->IoStatus );
                            }

                            Status = Irp->IoStatus.Status;

                            LocalOffset += LocalLength;
                            LengthLeft -= LocalLength;
                        }

                    } while ((LengthLeft != 0) && NT_SUCCESS(Status));

                    //
                    //  Make sure to return the total of all of the IOs.
                    //

                    Irp->IoStatus.Information = (ULONG) ByteCount;
                    try_return( Status );
                }
#endif

                if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                    //
                    //  Get hold of the user's buffer.
                    //

                    SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        ULONG Flags = SCE_FLAG_READ;
    
                        if (PagingIo)
                        {
                            Flags |= SCE_FLAG_PAGING;
                        }
                        if (!SynchronousIo)
                        {
                            Flags |= SCE_FLAG_ASYNC;
                        }
    
                        ASSERT( Scb->NonpagedScb->SegmentObject.ImageSectionObject == NULL );
                        FsRtlLogSyscacheEvent( Scb, SCE_READ, Flags, StartingVbo, ByteCount, (LONGLONG)FileObject );
                    }
#endif


                    //
                    // Now try to do the copy.
                    //

                    if (!CcCopyRead( FileObject,
                                     (PLARGE_INTEGER)&StartingVbo,
                                     (ULONG)ByteCount,
                                     Wait,
                                     SystemBuffer,
                                     &Irp->IoStatus )) {

                        DebugTrace( 0, Dbg, ("Cached Read could not wait\n") );

                        try_return( PostIrp = TRUE );
                    }

                //
                //  HANDLE A MDL READ
                //

                } else {

                    DebugTrace( 0, Dbg, ("MDL read.\n") );

                    ASSERT( Wait );

#ifdef NTFS_RWCMP_TRACE
                    if (NtfsCompressionTrace && IsSyscache(Header)) {
                        DbgPrint("CcMdlRead: FO = %08lx, Len = %08lx\n", (ULONG)StartingVbo, (ULONG)ByteCount );
                    }
#endif

                    CcMdlRead( FileObject,
                               (PLARGE_INTEGER)&StartingVbo,
                               (ULONG)ByteCount,
                               &Irp->MdlAddress,
                               &Irp->IoStatus );
                }

                Status = Irp->IoStatus.Status;

                ASSERT( NT_SUCCESS( Status ));

                try_return( Status );

#ifdef  COMPRESS_ON_WIRE

            //
            //  Handle the compressed calls.
            //

            } else {

                PCOMPRESSED_DATA_INFO CompressedDataInfo;
                PMDL *NewMdl;

                ASSERT((StartingVbo & (NTFS_CHUNK_SIZE - 1)) == 0);

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT | SCB_STATE_REALLOCATE_ON_WRITE )) {
                    try_return( Status = STATUS_INVALID_READ_MODE );
                }

                //
                //  Get out if COW is not supported.
                //

                if (!NtfsEnableCompressedIO) {

                    try_return( Status = STATUS_INVALID_READ_MODE );
                }

                if ((Header->FileObjectC == NULL) ||
                    (Header->FileObjectC->PrivateCacheMap == NULL)) {

                    //
                    //  Make sure we are serialized with the FileSizes, and
                    //  will remove this condition if we abort.
                    //

                    if (!DoingIoAtEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

                    NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );

                    if (!DoingIoAtEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }
                }

                //
                //  Assume success.
                //

                Irp->IoStatus.Status = Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG)(ByteRange - StartingVbo);

                //
                //  Based on the Mdl minor function, set up the appropriate
                //  parameters for the call below.
                //

                if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                    //
                    //  Get hold of the user's buffer.
                    //

                    SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
                    NewMdl = NULL;

                } else {

                    //
                    //  We will deliver the Mdl directly to the Irp.
                    //

                    SystemBuffer = NULL;
                    NewMdl = &Irp->MdlAddress;
                }

                CompressedDataInfo = (PCOMPRESSED_DATA_INFO)IrpContext->Union.AuxiliaryBuffer->Buffer;

                CompressedDataInfo->CompressionFormatAndEngine =
                    (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1);
                CompressedDataInfo->CompressionUnitShift = (UCHAR)(Scb->CompressionUnitShift + Vcb->ClusterShift);
                CompressedDataInfo->ChunkShift = NTFS_CHUNK_SHIFT;
                CompressedDataInfo->ClusterShift = (UCHAR)Vcb->ClusterShift;
                CompressedDataInfo->Reserved = 0;

                //
                //  Do the compressed read in common code with the Fast Io path.
                //  We do it from a loop because we may need to create the other
                //  data stream.
                //

                while (TRUE) {

                    //
                    //  Make sure to reset this if we pass through the loop again.
                    //

                    CompressedDataInfo->NumberOfChunks = 0;

                    Status = NtfsCompressedCopyRead( FileObject,
                                                     (PLARGE_INTEGER)&StartingVbo,
                                                     (ULONG)ByteCount,
                                                     SystemBuffer,
                                                     NewMdl,
                                                     CompressedDataInfo,
                                                     IrpContext->Union.AuxiliaryBuffer->Length,
                                                     IoGetRelatedDeviceObject(FileObject),
                                                     Header,
                                                     Scb->CompressionUnit,
                                                     NTFS_CHUNK_SIZE );

                    //
                    //  On successful Mdl requests we hang on to the PagingIo resource.
                    //

                    if ((NewMdl != NULL) && NT_SUCCESS(Status) && (*NewMdl != NULL)) {
                        PagingIoAcquired = FALSE;
                    }

                    //
                    //  Check for the status that says we need to create the normal
                    //  data stream, else we are done.
                    //

                    if (Status != STATUS_NOT_MAPPED_DATA) {
                        break;
                    }

                    //
                    //  Make sure we are serialized with the FileSizes, and
                    //  will remove this condition if we abort.
                    //

                    if (!DoingIoAtEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

                    //
                    //  Create the normal data stream and loop back to try again.
                    //

                    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

                    if (!DoingIoAtEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }
                }
            }
#endif

        }

    try_exit: NOTHING;

        //
        //  If the request was not posted, deal with it.
        //

        if (Irp) {

            if (!PostIrp) {

                DebugTrace( 0, Dbg, ("Completing request with status = %08lx\n",
                            Status));

                DebugTrace( 0, Dbg, ("                   Information = %08lx\n",
                            Irp->IoStatus.Information));

                //
                //  If the file was opened for Synchronous IO, update the current
                //  file position.  Make sure to use the original file object
                //  not an internal stream we may use within this routine.
                //  Information field contains the actual bytes read
                //

                if (!PagingIo) {

                    if (SynchronousIo) {

                        IrpSp->FileObject->CurrentByteOffset.QuadPart = StartingVbo + Irp->IoStatus.Information;
                    }

                    //
                    //  On success, do the following to let us update last access time.
                    //

                    if (NT_SUCCESS( Status )) {

                        SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );
                    }
                }

                //
                //  Abort transaction on error by raising.
                //

                NtfsCleanupTransaction( IrpContext, Status, FALSE );

            }
        }

    } finally {

        DebugUnwind( NtfsCommonRead );

#ifdef  COMPRESS_ON_WIRE
        //
        //  Clean up any Bcb from read/synchronize compressed.
        //

        if (CompressionSync != NULL) {
            NtfsReleaseCompressionSync( CompressionSync );
        }
#endif

        //
        // If the Scb has been acquired, release it.
        //

        if (PagingIoAcquired) {
            NtfsReleasePagingResource( IrpContext, Scb );
        }

        if (Irp) {

            if (ScbAcquired) {

                NtfsReleaseResource( IrpContext, Scb );
            }
        }
    }

    //
    //  Complete the request if we didn't post it and no exception
    //
    //  Note that NtfsCompleteRequest does the right thing if either
    //  IrpContext or Irp are NULL
    //

    if (!PostIrp) {

        NtfsCompleteRequest( IrpContext, Irp, Status );

    } else if (!OplockPostIrp) {

        Status = NtfsPostRequest( IrpContext, Irp );
    }


    return Status;
}


VOID 
NtfsNonCachedResidentRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    Read a resident file record directly for the non cached path. This is 
    done separately to scope the attribute enumeration context so its not present
    in most of the read path and for simplicity

Arguments:

    IrpContext - If present this an IrpContext put on the caller's stack
        to avoid having to allocate it from pool.

    Irp - Supplies the Irp being processed
    
    Scb -  scb to read from
    
    StartingVbo - start offset in the file - since its resident can be stored in a ulong
    
    ByteCount - bytes to read  - since its resident can be stored in a ulong

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    PVOID SystemBuffer;
    PUCHAR AttrValue;
    PVCB Vcb = IrpContext->Vcb;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    UCHAR Buffer[sizeof( MDL ) + sizeof( PFN_NUMBER ) * 2];
    PMDL PartialMdl = (PMDL) Buffer;
    BOOLEAN ReservedInUse = FALSE;

    //
    //  We're reading from a resident attribute
    //

    ASSERT( ByteCount < 0x400 );

    //
    //  Get hold of the user's buffer.
    //

    SystemBuffer = NtfsMapUserBufferNoRaise( Irp, NormalPagePriority );

    if (!SystemBuffer) {

        ASSERT( Irp->MdlAddress != NULL );

        MmInitializeMdl( PartialMdl, NULL, 2 * PAGE_SIZE );
        ExAcquireFastMutexUnsafe( &Vcb->ReservedMappingMutex );

        ReservedInUse = TRUE;

        IoBuildPartialMdl( Irp->MdlAddress, PartialMdl, Add2Ptr( MmGetMdlBaseVa( Irp->MdlAddress ), MmGetMdlByteOffset( Irp->MdlAddress )), ByteCount );
        SystemBuffer = MmMapLockedPagesWithReservedMapping( Vcb->ReservedMapping,
                                                            RESERVE_POOL_TAG,
                                                            PartialMdl,
                                                            MmCached );

        ASSERT( SystemBuffer != NULL );
        
    }

    //
    //  This is a resident attribute, we need to look it up
    //  and copy the desired range of bytes to the user's
    //  buffer.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    try {
        
        NtfsLookupAttributeForScb( IrpContext,
                                   Scb,
                                   NULL,
                                   &AttrContext );

        AttrValue = NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

        RtlCopyMemory( SystemBuffer,
                       Add2Ptr( AttrValue, StartingVbo ),
                       ByteCount );

        Irp->IoStatus.Information = ByteCount;
   
    } finally {

        if (ReservedInUse) {
            MmUnmapReservedMapping( Vcb->ReservedMapping, RESERVE_POOL_TAG, PartialMdl );
            MmPrepareMdlForReuse( PartialMdl );
            ExReleaseFastMutexUnsafe( &Vcb->ReservedMappingMutex );
        }

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\secursup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SecurSup.c

Abstract:

    This module implements the Ntfs Security Support routines

Author:

    Gary Kimura     [GaryKi]    27-Dec-1991

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg                              (DEBUG_TRACE_SECURSUP)
#define DbgAcl                           (DEBUG_TRACE_SECURSUP | DEBUG_TRACE_ACLINDEX)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('SFtN')

UNICODE_STRING FileString = CONSTANT_UNICODE_STRING( L"File" );

//
//  Local procedure prototypes
//

PSHARED_SECURITY
NtfsCacheSharedSecurityByDescriptor (
    IN PIRP_CONTEXT IrpContext,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    );

VOID
NtfsStoreSecurityDescriptor (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN LogIt
    );

PSHARED_SECURITY
FindCachedSharedSecurityByHashUnsafe (
    IN PVCB Vcb,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN ULONG Hash
    );

VOID
AddCachedSharedSecurityUnsafe (
    IN PVCB Vcb,
    PSHARED_SECURITY SharedSecurity
    );

BOOLEAN
MapSecurityIdToSecurityDescriptorHeaderUnsafe (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN SECURITY_ID SecurityId,
    OUT PSECURITY_DESCRIPTOR_HEADER *SecurityDescriptorHeader,
    OUT PBCB *Bcb
    );

NTSTATUS
NtOfsMatchSecurityHash (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    );

VOID
NtOfsLookupSecurityDescriptorInIndex (
    PIRP_CONTEXT IrpContext,
    IN OUT PSHARED_SECURITY SharedSecurity
    );

PSHARED_SECURITY
GetSharedSecurityFromDescriptorUnsafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    );

#ifdef NTFS_CACHE_RIGHTS
//
//  Local procedure prototypes for access rights cache
//

VOID
NtfsAddCachedRights (
    IN PVCB Vcb,
    IN PSHARED_SECURITY SharedSecurity,
    IN ACCESS_MASK Rights,
    IN PLUID TokenId,
    IN PLUID ModifiedId
    );

INLINE ACCESS_MASK
NtfsGetCachedRightsWorld (
    IN PCACHED_ACCESS_RIGHTS CachedRights
    )
{
    return CachedRights->EveryoneRights;
}

INLINE VOID
NtfsSetCachedRightsWorld (
    IN PSHARED_SECURITY SharedSecurity
    )
{
    SeGetWorldRights( &SharedSecurity->SecurityDescriptor,
                      IoGetFileObjectGenericMapping(),
                      &SharedSecurity->CachedRights.EveryoneRights );

    //
    //  Make certain that MAXIMUM_ALLOWED is not in the rights.
    //

    ClearFlag( SharedSecurity->CachedRights.EveryoneRights, MAXIMUM_ALLOWED );

    return;
}
#endif

#if (DBG || defined( NTFS_FREE_ASSERTS ))
VOID
NtfsVerifySecurity (
    PIRP_CONTEXT IrpContext,
    PVCB Vcb
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAssignSecurity)
#pragma alloc_text(PAGE, NtfsCacheSharedSecurityByDescriptor)
#pragma alloc_text(PAGE, NtfsModifySecurity)
#pragma alloc_text(PAGE, NtfsQuerySecurity)
#pragma alloc_text(PAGE, NtfsAccessCheck)
#pragma alloc_text(PAGE, NtfsCheckFileForDelete)
#pragma alloc_text(PAGE, NtfsCheckIndexForAddOrDelete)
#pragma alloc_text(PAGE, GetSharedSecurityFromDescriptorUnsafe)
#pragma alloc_text(PAGE, NtfsSetFcbSecurityFromDescriptor)
#pragma alloc_text(PAGE, NtfsNotifyTraverseCheck)
#pragma alloc_text(PAGE, NtfsInitializeSecurity)
#pragma alloc_text(PAGE, NtfsCacheSharedSecurityBySecurityId)
#pragma alloc_text(PAGE, FindCachedSharedSecurityByHashUnsafe)
#pragma alloc_text(PAGE, AddCachedSharedSecurityUnsafe)
#pragma alloc_text(PAGE, NtOfsPurgeSecurityCache)
#pragma alloc_text(PAGE, MapSecurityIdToSecurityDescriptorHeaderUnsafe)
#pragma alloc_text(PAGE, NtfsLoadSecurityDescriptor)
#pragma alloc_text(PAGE, NtOfsMatchSecurityHash)
#pragma alloc_text(PAGE, NtOfsLookupSecurityDescriptorInIndex)
#pragma alloc_text(PAGE, GetSecurityIdFromSecurityDescriptorUnsafe)
#pragma alloc_text(PAGE, NtfsStoreSecurityDescriptor)
#pragma alloc_text(PAGE, NtfsCacheSharedSecurityForCreate)
#pragma alloc_text(PAGE, NtOfsCollateSecurityHash)
#pragma alloc_text(PAGE, NtfsCanAdministerVolume)
#endif

#ifdef NTFS_CACHE_RIGHTS
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsGetCachedRightsById)
#pragma alloc_text(PAGE, NtfsGetCachedRights)
#pragma alloc_text(PAGE, NtfsAddCachedRights)
#endif
#endif


VOID
NtfsAssignSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN PIRP Irp,
    IN PFCB NewFcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PBCB FileRecordBcb,
    IN LONGLONG FileOffset,
    IN OUT PBOOLEAN LogIt
    )

/*++

Routine Description:

    LEGACY NOTE - this routine disappears when all volumes go to Cairo.

    This routine constructs and assigns a new security descriptor to the
    specified file/directory.  The new security descriptor is placed both
    on the fcb and on the disk.

    This will only be called in the context of an open/create operation.
    It currently MUST NOT be called to store a security descriptor for
    an existing file, because it instructs NtfsStoreSecurityDescriptor
    to not log the change.

    If this is a large security descriptor then it is possible that
    AllocateClusters may be called twice within the call to AddAllocation
    when the attribute is created.  If so then the second call will always
    log the changes.  In that case we need to log all of the operations to
    create this security attribute and also we must log the current state
    of the file record.

    It is possible that our caller has already started logging operations against
    this log record.  In that case we always log the security changes.

Arguments:

    ParentFcb - Supplies the directory under which the new fcb exists

    Irp - Supplies the Irp being processed

    NewFcb - Supplies the fcb that is being assigned a new security descriptor

    FileRecord - Supplies the file record for this operation.  Used if we
        have to log against the file record.

    FileRecordBcb - Bcb for the file record above.

    FileOffset - File offset in the Mft for this file record.

    LogIt - On entry this indicates whether our caller wants this operation
        logged.  On exit we return TRUE if we logged the security change.

Return Value:

    None.

--*/

{
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    NTSTATUS Status;
    BOOLEAN IsDirectory;
    PACCESS_STATE AccessState;
    PIO_STACK_LOCATION IrpSp;
    ULONG SecurityDescLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( ParentFcb );
    ASSERT_IRP( Irp );
    ASSERT_FCB( NewFcb );

    PAGED_CODE();

    if (NewFcb->Vcb->SecurityDescriptorStream != NULL) {
        return;
    }

    DebugTrace( +1, Dbg, ("NtfsAssignSecurity...\n") );

    //
    //  First decide if we are creating a file or a directory
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (FlagOn(IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE)) {

        IsDirectory = TRUE;

    } else {

        IsDirectory = FALSE;
    }

    //
    //  Extract the parts of the Irp that we need to do our assignment
    //

    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Check if we need to load the security descriptor for the parent.
    //

    if (ParentFcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );

    }

    ASSERT( ParentFcb->SharedSecurity != NULL );

    //
    //  Create a new security descriptor for the file and raise if there is
    //  an error
    //

    if (!NT_SUCCESS( Status = SeAssignSecurity( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                                AccessState->SecurityDescriptor,
                                                &SecurityDescriptor,
                                                IsDirectory,
                                                &AccessState->SubjectSecurityContext,
                                                IoGetFileObjectGenericMapping(),
                                                PagedPool ))) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

    }

    //
    //  Load the security descriptor into the Fcb
    //

    SecurityDescLength = RtlLengthSecurityDescriptor( SecurityDescriptor );

    try {

        //
        //  Make sure the length is non-zero.
        //

        if (SecurityDescLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );

        }

        ASSERT( SeValidSecurityDescriptor( SecurityDescLength, SecurityDescriptor ));


        NtfsSetFcbSecurityFromDescriptor(
                               IrpContext,
                               NewFcb,
                               SecurityDescriptor,
                               SecurityDescLength,
                               TRUE );

    } finally {

        //
        //  Free the security descriptor created by Se
        //

        SeDeassignSecurity( &SecurityDescriptor );
    }

    //
    //  If the security descriptor is large enough that it may cause us to
    //  start logging in the StoreSecurity call below then make sure everything
    //  is logged.
    //

    if (!(*LogIt) &&
        (SecurityDescLength > BytesFromClusters( NewFcb->Vcb, MAXIMUM_RUNS_AT_ONCE ))) {

        //
        //  Log the current state of the file record.
        //

        FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                        NewFcb->Vcb->MftScb,
                                        FileRecordBcb,
                                        InitializeFileRecordSegment,
                                        FileRecord,
                                        FileRecord->FirstFreeByte,
                                        Noop,
                                        NULL,
                                        0,
                                        FileOffset,
                                        0,
                                        0,
                                        NewFcb->Vcb->BytesPerFileRecordSegment );

        *LogIt = TRUE;
    }

    //
    //  Write out the new security descriptor
    //

    NtfsStoreSecurityDescriptor( IrpContext, NewFcb, *LogIt );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsAssignSecurity -> VOID\n") );

    return;
}


PSHARED_SECURITY
NtfsCacheSharedSecurityByDescriptor (
    IN PIRP_CONTEXT IrpContext,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    )

/*++

Routine Description:

    This routine finds or constructs a security id and SHARED_SECURITY from
    a specific file or directory.

Arguments:

    IrpContext - Context of the call

    SecurityDescriptor - the actual security descriptor being stored

    SecurityDescriptorLength - length of security descriptor

    RaiseIfInvalid - raise status if sd is invalid

Return Value:

    Referenced shared security.

--*/

{
    PSHARED_SECURITY SharedSecurity = NULL;
    SECURITY_ID SecurityId;
    ULONG FcbSecurityAcquired;
    ULONG OwnerCount;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    //
    //  LEGACY NOTE - this goes away when all volumes become NT 5.0
    //

    if (IrpContext->Vcb->SecurityDescriptorStream == NULL) {
        return NULL;
    }

    DebugTrace( +1, DbgAcl, ("NtfsCacheSharedSecurityByDescriptor...\n") );

    //
    //  Serialize access to the security cache and use a try/finally to make
    //  sure we release it
    //

    NtfsAcquireFcbSecurity( IrpContext->Vcb );
    FcbSecurityAcquired = TRUE;

    //
    //  Capture our owner count on the mft - so we can release it if we acquired it later on
    //  growing the file record for the security stream
    //

    OwnerCount = NtfsIsSharedScb( IrpContext->Vcb->MftScb );

    try {

        //
        //  We have a security descriptor.  Create a shared security descriptor.
        //

        SharedSecurity = GetSharedSecurityFromDescriptorUnsafe( IrpContext,
                                                                SecurityDescriptor,
                                                                SecurityDescriptorLength,
                                                                RaiseIfInvalid );

        //
        //  Make sure the shared security doesn't go away
        //

        SharedSecurity->ReferenceCount += 1;
        DebugTrace( 0, DbgAcl, ("NtfsCacheSharedSecurityByDescriptor bumping refcount %08x\n", SharedSecurity ));

        //
        //  If we found a shared security descriptor with no Id assigned, then
        //  we must assign it.  Since it is known that no Id was assigned we
        //  must also add it into the cache.
        //

        if (SharedSecurity->Header.HashKey.SecurityId == SECURITY_ID_INVALID) {

            //
            //  Find unique SecurityId for descriptor and set SecurityId in Fcb.
            //

            SecurityId = GetSecurityIdFromSecurityDescriptorUnsafe( IrpContext,
                                                                    SharedSecurity );

            ASSERT( SharedSecurity->Header.HashKey.SecurityId == SecurityId );
            SharedSecurity->Header.HashKey.SecurityId = SecurityId;
            DebugTrace( 0, DbgAcl, ("NtfsCacheSharedSecurityByDescriptor setting security Id to new %08x\n", SecurityId ));

            //
            //  We need to drop the FcbSecurity before performing the checkpoint, to avoid
            //  deadlocks, but this is ok since we have incremented the reference count on
            //  our SharedSecurity.
            //

            NtfsReleaseFcbSecurity( IrpContext->Vcb );
            FcbSecurityAcquired = FALSE;

            //
            //  Checkpoint the current transaction so that we can safely add this
            //  shared security to the cache.  Once this call is complete, we are
            //  guaranteed that the security index modifications make it out to
            //  disk before the newly allocated security ID does.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Release the security descriptor and mft if owned
            //

            NtfsReleaseExclusiveScbIfOwned( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );

            //
            //  Check if the mft has been acquired during the call before releasing it
            //

            if (NtfsIsSharedScb( IrpContext->Vcb->MftScb ) != OwnerCount) {
                NtfsReleaseScb( IrpContext, IrpContext->Vcb->MftScb );
            }

            //
            //  Cache this shared security for faster access.
            //

            NtfsAcquireFcbSecurity( IrpContext->Vcb );
            FcbSecurityAcquired = TRUE;
            AddCachedSharedSecurityUnsafe( IrpContext->Vcb, SharedSecurity );
        }

    } finally {

        if (AbnormalTermination( )) {
            if (SharedSecurity != NULL) {
                if (!FcbSecurityAcquired) {

                    NtfsAcquireFcbSecurity( IrpContext->Vcb );
                    RemoveReferenceSharedSecurityUnsafe( &SharedSecurity );
                    FcbSecurityAcquired = TRUE;
                }
            }
        }

        if (FcbSecurityAcquired) {
            NtfsReleaseFcbSecurity( IrpContext->Vcb );
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, DbgAcl, ( "NtfsCacheSharedSecurityByDescriptor -> %08x\n", SharedSecurity ) );

    return SharedSecurity;
}


NTSTATUS
NtfsModifySecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine modifies an existing security descriptor for a file/directory.

Arguments:

    Fcb - Supplies the Fcb whose security is being modified

    SecurityInformation - Supplies the security information structure passed to
        the file system by the I/O system.

    SecurityDescriptor - Supplies the security information structure passed to
        the file system by the I/O system.

Return Value:

    NTSTATUS - Returns an appropriate status value for the function results

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR DescriptorPtr;
    ULONG DescriptorLength;
    PSCB Scb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    DebugTrace( +1, DbgAcl, ("NtfsModifySecurity...\n") );

    //
    //  First check if we need to load the security descriptor for the file
    //

    if (Fcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, Fcb );

    }

    ASSERT( Fcb->SharedSecurity != NULL);

    DescriptorPtr = &Fcb->SharedSecurity->SecurityDescriptor;

    //
    //  Do the modify operation.  SeSetSecurityDescriptorInfo no longer
    //  frees the passed security descriptor.
    //

    if (!NT_SUCCESS( Status = SeSetSecurityDescriptorInfo( NULL,
                                                           SecurityInformation,
                                                           SecurityDescriptor,
                                                           &DescriptorPtr,
                                                           PagedPool,
                                                           IoGetFileObjectGenericMapping() ))) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    DescriptorLength = RtlLengthSecurityDescriptor( DescriptorPtr );

    try {

        //
        //  Check for a zero length.
        //

        if (DescriptorLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );

        }

        //
        //  LEGACY NOTE - remove this test when all volumes go to NT 5
        //

        if (Fcb->Vcb->SecurityDescriptorStream != NULL) {
            PSHARED_SECURITY SharedSecurity;
            PSHARED_SECURITY OldSharedSecurity = NULL;
            SECURITY_ID OldSecurityId;
            ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

            //
            //  Cache security descriptor
            //

            //
            //  After the SeSetSecurityDescriptorInfo we should have a valid sd
            //

            ASSERT( SeValidSecurityDescriptor( DescriptorLength, DescriptorPtr ));

            SharedSecurity = NtfsCacheSharedSecurityByDescriptor( IrpContext, DescriptorPtr, DescriptorLength, TRUE );

            NtfsInitializeAttributeContext( &AttributeContext );

            try {

                //
                //  Move Quota to new owner as described in descriptor.
                //

                NtfsMoveQuotaOwner( IrpContext, Fcb, DescriptorPtr );

                //
                //  Set in new shared security
                //

                OldSharedSecurity = Fcb->SharedSecurity;
                OldSecurityId = Fcb->SecurityId;

                Fcb->SharedSecurity = SharedSecurity;
                Fcb->SecurityId = SharedSecurity->Header.HashKey.SecurityId;

                DebugTrace( 0, DbgAcl, ("NtfsModifySecurity setting Fcb securityId to %08x\n", Fcb->SecurityId ));

                //
                //  We are called to replace an existing security descriptor.  In the
                //  event that we have a downlevel $STANDARD_INFORMATION attribute, we
                //  must convert it to large form so that the security ID is stored.
                //

                if (!FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO) ) {

                    DebugTrace( 0, DbgAcl, ("Growing standard information\n") );

                    NtfsGrowStandardInformation( IrpContext, Fcb );
                }

                //
                //  Despite having a large $STANDARD_INFORMATION, we may have
                //  a security descriptor present.  This occurs if the SecurityId
                //  is invalid
                //

                if (OldSecurityId == SECURITY_ID_INVALID) {

                    //
                    //  Read in the security descriptor attribute. If it
                    //  doesn't exist then we're done, otherwise simply delete the
                    //  attribute
                    //

                    if (NtfsLookupAttributeByCode( IrpContext,
                                                         Fcb,
                                                         &Fcb->FileReference,
                                                         $SECURITY_DESCRIPTOR,
                                                         &AttributeContext )) {

                        UNICODE_STRING NoName = CONSTANT_UNICODE_STRING( L"" );

                        DebugTrace( 0, DbgAcl, ("Delete existing Security Descriptor\n") );

                        NtfsDeleteAttributeRecord( IrpContext,
                                                   Fcb,
                                                   DELETE_LOG_OPERATION |
                                                    DELETE_RELEASE_FILE_RECORD |
                                                    DELETE_RELEASE_ALLOCATION,
                                                   &AttributeContext );

                        //
                        //  If the $SECURITY_DESCRIPTOR was non resident, the above
                        //  delete call created one for us under the covers.  We
                        //  need to mark it as deleted otherwise, we detect the
                        //  volume as being corrupt.
                        //

                        Scb = NtfsCreateScb( IrpContext,
                                             Fcb,
                                             $SECURITY_DESCRIPTOR,
                                             &NoName,
                                             TRUE,
                                             NULL );

                        if (Scb != NULL) {
                            ASSERT_EXCLUSIVE_SCB( Scb );
                            SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                        }
                    }
                }

                //
                //  The security descriptor in the FCB is now changed and may not
                //  reflect what is $STANDARD_INFORMATION.  The caller is responsible
                //  for making this update.
                //

            } finally {

                NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

                if (AbnormalTermination()) {

                    if (OldSharedSecurity != NULL) {

                        //
                        //  Put back the security the way we found it
                        //

                        Fcb->SharedSecurity = OldSharedSecurity;
                        Fcb->SecurityId = OldSecurityId;
                        DebugTrace( 0, DbgAcl, ("NtfsModifySecurity resetting Fcb->SecurityId to %08x\n", Fcb->SecurityId ));
                    }

                    OldSharedSecurity = SharedSecurity;
                }

                //
                //  release old security descriptor (or new one if
                //  NtfsMoveQuotaOwner raises
                //

                ASSERT( OldSharedSecurity != NULL );
                NtfsAcquireFcbSecurity( Fcb->Vcb );
                RemoveReferenceSharedSecurityUnsafe( &OldSharedSecurity );
                NtfsReleaseFcbSecurity( Fcb->Vcb );
            }

        } else {

            //  LEGACY NOTE - delete this clause when all volumes go to NT 5

            //
            //  Update the move the quota to the new owner if necessary.
            //

            NtfsMoveQuotaOwner( IrpContext, Fcb, DescriptorPtr );


            //
            //  Load the security descriptor into the Fcb
            //

            NtfsAcquireFcbSecurity( Fcb->Vcb );

            RemoveReferenceSharedSecurityUnsafe( &Fcb->SharedSecurity );

            NtfsReleaseFcbSecurity( Fcb->Vcb );

            NtfsSetFcbSecurityFromDescriptor(
                                       IrpContext,
                                       Fcb,
                                       DescriptorPtr,
                                       DescriptorLength,
                                       TRUE );

            //
            //  Now we need to store the new security descriptor on disk
            //

            NtfsStoreSecurityDescriptor( IrpContext, Fcb, TRUE );

        }

    } finally {

        SeDeassignSecurity( &DescriptorPtr );

    }

    //
    //  Remember that we modified the security on the file.
    //

    SetFlag( Fcb->InfoFlags, FCB_INFO_MODIFIED_SECURITY );

    //
    //  And return to our caller
    //

    DebugTrace( -1, DbgAcl, ("NtfsModifySecurity -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsQuerySecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG SecurityDescriptorLength
    )

/*++

Routine Description:

    This routine is used to query the contents of an existing security descriptor for
    a file/directory.

Arguments:

    Fcb - Supplies the file/directory being queried

    SecurityInformation - Supplies the security information structure passed to
        the file system by the I/O system.

    SecurityDescriptor - Supplies the security information structure passed to
        the file system by the I/O system.

    SecurityDescriptorLength - Supplies the length of the input security descriptor
        buffer in bytes.

Return Value:

    NTSTATUS - Returns an appropriate status value for the function results

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR LocalPointer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQuerySecurity...\n") );

    //
    //  First check if we need to load the security descriptor for the file
    //

    if (Fcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, Fcb );

    }

    LocalPointer = &Fcb->SharedSecurity->SecurityDescriptor;

    //
    //  Now with the security descriptor loaded do the query operation but
    //  protect ourselves with a exception handler just in case the caller's
    //  buffer isn't valid
    //

    try {

        Status = SeQuerySecurityDescriptorInfo( SecurityInformation,
                                                SecurityDescriptor,
                                                SecurityDescriptorLength,
                                                &LocalPointer );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsQuerySecurity -> %08lx\n", Status) );

    return Status;
}


#define NTFS_SE_CONTROL (((SE_DACL_PRESENT | SE_SELF_RELATIVE) << 16) | SECURITY_DESCRIPTOR_REVISION1)
#define NTFS_DEFAULT_ACCESS_MASK 0x001f01ff

ULONG NtfsWorldAclFile[] = {
        0x00000000,     // Null Sacl
        0x00000014,     // Dacl
        0x001c0002,     // Acl header
        0x00000001,     // One ACE
        0x00140000,     // ACE Header
        NTFS_DEFAULT_ACCESS_MASK,
        0x00000101,     // World Sid
        0x01000000,
        0x00000000
        };

ULONG NtfsWorldAclDir[] = {
        0x00000000,     // Null Sacl
        0x00000014,     // Dacl
        0x00300002,     // Acl header
        0x00000002,     // Two ACEs
        0x00140000,     // ACE Header
        NTFS_DEFAULT_ACCESS_MASK,
        0x00000101,     // World Sid
        0x01000000,
        0x00000000,
        0x00140b00,     // ACE Header
        NTFS_DEFAULT_ACCESS_MASK,
        0x00000101,     // World Sid
        0x01000000,
        0x00000000
        };


VOID
NtfsAccessCheck (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PIRP Irp,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN CheckOnly
    )

/*++

Routine Description:

    This routine does a general access check for the indicated desired access.
    This will only be called in the context of an open/create operation.

    If access is granted then control is returned to the caller
    otherwise this function will do the proper Nt security calls to log
    the attempt and then raise an access denied status.

Arguments:

    Fcb - Supplies the file/directory being examined

    ParentFcb - Optionally supplies the parent of the Fcb being examined

    Irp - Supplies the Irp being processed

    DesiredAccess - Supplies a mask of the access being requested

    CheckOnly - Indicates if this operation is to check the desired access
        only and not accumulate the access granted here.  In this case we
        are guaranteed that we have passed in a hard-wired desired access
        and MAXIMUM_ALLOWED will not be one of them.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    NTSTATUS AccessStatus;
    NTSTATUS AccessStatusError;

    PACCESS_STATE AccessState;

    PIO_STACK_LOCATION IrpSp;

#ifdef NTFS_CACHE_RIGHTS
    ACCESS_MASK TmpDesiredAccess;
#endif

    KPROCESSOR_MODE EffectiveMode;
    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    PISECURITY_DESCRIPTOR SecurityDescriptor;
    PPRIVILEGE_SET Privileges;
    PUNICODE_STRING FileName;
    PUNICODE_STRING RelatedFileName;
    PUNICODE_STRING PartialFileName;
    UNICODE_STRING FullFileName;
    UNICODE_STRING NormalizedName;
    PUNICODE_STRING DeviceObjectName;
    USHORT DeviceObjectNameLength;
    ULONG FullFileNameLength;

    BOOLEAN LeadingSlash;
    BOOLEAN RelatedFileNamePresent;
    BOOLEAN PartialFileNamePresent;
    BOOLEAN MaximumRequested;
    BOOLEAN MaximumDeleteAcquired;
    BOOLEAN MaximumReadAttrAcquired;
    BOOLEAN PerformAccessValidation;
    BOOLEAN PerformDeleteAudit;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAccessCheck...\n") );

    //
    //  First extract the parts of the Irp that we need to do our checking
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Check if we need to load the security descriptor for the file
    //

    if (Fcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, Fcb );
    }

    ASSERT( Fcb->SharedSecurity != NULL );

    SecurityDescriptor = (PISECURITY_DESCRIPTOR) Fcb->SharedSecurity->SecurityDescriptor;

    //
    //  Check to see if auditing is enabled and if this is the default world ACL.
    //

    SeLockSubjectContext(&AccessState->SubjectSecurityContext);

    if ((*((PULONG) SecurityDescriptor) == NTFS_SE_CONTROL) &&
        !SeAuditingFileEventsWithContext( TRUE, SecurityDescriptor, &AccessState->SubjectSecurityContext )) {

        //
        //  Directories and files have different default ACLs.
        //

        if (((Fcb->Info.FileAttributes & DUP_FILE_NAME_INDEX_PRESENT) &&
             RtlEqualMemory( &SecurityDescriptor->Sacl,
                             NtfsWorldAclDir,
                             sizeof( NtfsWorldAclDir ))) ||

            RtlEqualMemory( &SecurityDescriptor->Sacl,
                            NtfsWorldAclFile,
                            sizeof(NtfsWorldAclFile))) {

            if (FlagOn( DesiredAccess, MAXIMUM_ALLOWED )) {
                GrantedAccess = NTFS_DEFAULT_ACCESS_MASK;
            } else {
                GrantedAccess = DesiredAccess & NTFS_DEFAULT_ACCESS_MASK;
            }

            if (!CheckOnly) {

                SetFlag( AccessState->PreviouslyGrantedAccess, GrantedAccess );
                ClearFlag( AccessState->RemainingDesiredAccess, GrantedAccess | MAXIMUM_ALLOWED );
            }

            DebugTrace( -1, Dbg, ("NtfsAccessCheck -> DefaultWorldAcl\n") );

            SeUnlockSubjectContext(&AccessState->SubjectSecurityContext);
            return;
        }
    } 
    
    SeUnlockSubjectContext(&AccessState->SubjectSecurityContext);


    Privileges = NULL;
    FileName = NULL;
    RelatedFileName = NULL;
    PartialFileName = NULL;
    DeviceObjectName = NULL;
    MaximumRequested = FALSE;
    MaximumDeleteAcquired = FALSE;
    MaximumReadAttrAcquired = FALSE;
    PerformAccessValidation = TRUE;
    PerformDeleteAudit = FALSE;

    RtlZeroMemory( &NormalizedName, sizeof( UNICODE_STRING ) );

    //
    //  Check to see if we need to perform access validation
    //

    ClearFlag( DesiredAccess, AccessState->PreviouslyGrantedAccess );

#ifdef NTFS_CACHE_RIGHTS
    //
    //  Get any cached knowledge about rights that all callers are known to
    //  have for this security descriptor.
    //

    GrantedAccess = NtfsGetCachedRightsWorld( &Fcb->SharedSecurity->CachedRights );

    if (!CheckOnly) {

        SetFlag( AccessState->PreviouslyGrantedAccess,
                 FlagOn( DesiredAccess, GrantedAccess ));
    }

    ClearFlag( DesiredAccess, GrantedAccess );
#endif

    if (DesiredAccess == 0) {

        //
        //  Nothing to check, skip AVR and go straight to auditing
        //

        PerformAccessValidation = FALSE;
        AccessGranted = TRUE;
    }

    //
    //  Remember the case where MAXIMUM_ALLOWED was requested.
    //

    if (FlagOn( DesiredAccess, MAXIMUM_ALLOWED )) {

        MaximumRequested = TRUE;
    }

    if (FlagOn( IrpSp->Parameters.Create.SecurityContext->FullCreateOptions, FILE_DELETE_ON_CLOSE )) {
        PerformDeleteAudit = TRUE;
    }

    //
    //  SL_FORCE_ACCESS_CHECK causes us to use an effective RequestorMode
    //  of UserMode.
    //

    EffectiveMode = NtfsEffectiveMode( Irp, IrpSp );

    //
    //  Lock the user context, do the access check and then unlock the context
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (PerformAccessValidation) {

#ifdef NTFS_CACHE_RIGHTS
            BOOLEAN EntryCached = FALSE;

            //
            //  Check the cached information only if the effective
            //  RequestorMode is UserMode.

            if (EffectiveMode == UserMode) {

                //
                //  Add in any cached knowledge about rights that this caller
                //  is known to have for this security descriptor.
                //

                (VOID)NtfsGetCachedRights( Fcb->Vcb,
                                           &AccessState->SubjectSecurityContext,
                                           Fcb->SharedSecurity,
                                           &GrantedAccess,
                                           &EntryCached,
                                           NULL,
                                           NULL );

                //
                //  Make certain that GrantedAccess has no rights not
                //  originally requested.
                //

                ClearFlag( GrantedAccess, ~DesiredAccess );

                TmpDesiredAccess = DesiredAccess;
                ClearFlag( TmpDesiredAccess, GrantedAccess );

                if (EntryCached) {

                    ClearFlag( TmpDesiredAccess, MAXIMUM_ALLOWED );
                }

                //
                //  If all rights are available, then access is granted.
                //

                if (TmpDesiredAccess == 0) {

                    AccessGranted = TRUE;
                    AccessStatus = STATUS_SUCCESS;

                //
                //  Otherwise, we don't know.
                //

                } else {

                    AccessGranted = FALSE;

                }
            } else {

                AccessGranted = FALSE;

            }
#endif

            //
            //  We need to take the slow path.
            //

#ifdef NTFS_CACHE_RIGHTS
            if (!AccessGranted) {
#endif

                //
                //  Get the rights information.
                //

                AccessGranted = SeAccessCheck( &Fcb->SharedSecurity->SecurityDescriptor,
                                               &AccessState->SubjectSecurityContext,
                                               TRUE,                           // Tokens are locked
                                               DesiredAccess,
                                               0,
                                               &Privileges,
                                               IoGetFileObjectGenericMapping(),
                                               EffectiveMode,
                                               &GrantedAccess,
                                               &AccessStatus );

                if (Privileges != NULL) {

                    Status = SeAppendPrivileges( AccessState, Privileges );
                    SeFreePrivileges( Privileges );
                    Privileges = NULL;
                }
#ifdef NTFS_CACHE_RIGHTS
            }
#endif

            if (AccessGranted) {

                ClearFlag( DesiredAccess, GrantedAccess | MAXIMUM_ALLOWED );

                if (!CheckOnly) {

                    SetFlag( AccessState->PreviouslyGrantedAccess, GrantedAccess );

                    //
                    //  Remember the case where MAXIMUM_ALLOWED was requested and we
                    //  got everything requested from the file.
                    //

                    if (MaximumRequested) {

                        //
                        //  Check whether we got DELETE and READ_ATTRIBUTES.  Otherwise
                        //  we will query the parent.
                        //

                        if (FlagOn( AccessState->PreviouslyGrantedAccess, DELETE )) {

                            MaximumDeleteAcquired = TRUE;
                        }

                        if (FlagOn( AccessState->PreviouslyGrantedAccess, FILE_READ_ATTRIBUTES )) {

                            MaximumReadAttrAcquired = TRUE;
                        }
                    }

                    ClearFlag( AccessState->RemainingDesiredAccess, (GrantedAccess | MAXIMUM_ALLOWED) );
                }

            } else {

                AccessStatusError = AccessStatus;
            }

            //
            //  Check if the access is not granted and if we were given a parent fcb, and
            //  if the desired access was asking for delete or file read attributes.  If so
            //  then we need to do some extra work to decide if the caller does get access
            //  based on the parent directories security descriptor.  We also do the same
            //  work if MAXIMUM_ALLOWED was requested and we didn't get DELETE or
            //  FILE_READ_ATTRIBUTES.
            //

            if ((ParentFcb != NULL) && 
                ((!AccessGranted && FlagOn( DesiredAccess, DELETE | FILE_READ_ATTRIBUTES )) || 
                 (MaximumRequested && 
                  (!MaximumDeleteAcquired || !MaximumReadAttrAcquired)))) {

                BOOLEAN DeleteAccessGranted = TRUE;
                BOOLEAN ReadAttributesAccessGranted = TRUE;

                ACCESS_MASK DeleteChildGrantedAccess = 0;
                ACCESS_MASK ListDirectoryGrantedAccess = 0;

                //
                //  Before we proceed load in the parent security descriptor.
                //  Acquire the parent shared while doing this to protect the
                //  security descriptor.
                //

                SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
                NtfsAcquireResourceShared( IrpContext, ParentFcb, TRUE );
                SeLockSubjectContext( &AccessState->SubjectSecurityContext );

                try {

                    if (ParentFcb->SharedSecurity == NULL) {

                        NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );
                    }

                    ASSERT( ParentFcb->SharedSecurity != NULL);

                    //
                    //  Now if the user is asking for delete access then check if the parent
                    //  will granted delete access to the child, and if so then we munge the
                    //  desired access
                    //

#ifdef NTFS_CACHE_RIGHTS
                    //
                    //  Check the cached information only if the effective
                    //  RequestorMode is UserMode.
                    //

                    if (EffectiveMode == UserMode) {

                        //
                        //  Acquire in any cached knowledge about rights that
                        //  this caller is known to have for this security
                        //  descriptor.
                        //

                        (VOID)NtfsGetCachedRights( ParentFcb->Vcb,
                                                   &AccessState->SubjectSecurityContext,
                                                   ParentFcb->SharedSecurity,
                                                   &GrantedAccess,
                                                   NULL,
                                                   NULL,
                                                   NULL );

                        //
                        //  Add in the results of the parent directory access.
                        //

                        if (FlagOn( GrantedAccess, FILE_DELETE_CHILD) ) {

                            SetFlag( DeleteChildGrantedAccess, DELETE );
                            ClearFlag( DesiredAccess, DELETE );
                            MaximumDeleteAcquired = TRUE;

                        }

                        if (FlagOn( GrantedAccess, FILE_LIST_DIRECTORY) ) {

                            SetFlag( ListDirectoryGrantedAccess, FILE_READ_ATTRIBUTES );
                            ClearFlag( DesiredAccess, FILE_READ_ATTRIBUTES );
                            MaximumReadAttrAcquired = TRUE;

                        }

                    }
#endif

                    if (FlagOn( DesiredAccess, DELETE ) ||
                        (MaximumRequested && !MaximumDeleteAcquired)) {

                        DeleteAccessGranted = SeAccessCheck( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                                             &AccessState->SubjectSecurityContext,
                                                             TRUE,                           // Tokens are locked
                                                             FILE_DELETE_CHILD,
                                                             0,
                                                             &Privileges,
                                                             IoGetFileObjectGenericMapping(),
                                                             EffectiveMode,
                                                             &DeleteChildGrantedAccess,
                                                             &AccessStatus );

                        if (Privileges != NULL) {

                            SeFreePrivileges( Privileges );
                            Privileges = NULL;
                        }

                        if (DeleteAccessGranted) {

                            SetFlag( DeleteChildGrantedAccess, DELETE );
                            ClearFlag( DeleteChildGrantedAccess, FILE_DELETE_CHILD );
                            ClearFlag( DesiredAccess, DELETE );

                        } else {

                            AccessStatusError = AccessStatus;
                        }
                    }

                    //
                    //  Do the same test for read attributes and munge the desired access
                    //  as appropriate
                    //

                    if (FlagOn(DesiredAccess, FILE_READ_ATTRIBUTES) || 
                        (MaximumRequested && !MaximumReadAttrAcquired)) {

                        ReadAttributesAccessGranted = SeAccessCheck( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                                                     &AccessState->SubjectSecurityContext,
                                                                     TRUE,                           // Tokens are locked
                                                                     FILE_LIST_DIRECTORY,
                                                                     0,
                                                                     &Privileges,
                                                                     IoGetFileObjectGenericMapping(),
                                                                     EffectiveMode,
                                                                     &ListDirectoryGrantedAccess,
                                                                     &AccessStatus );

                        if (Privileges != NULL) {

                            SeFreePrivileges( Privileges );
                            Privileges = NULL;
                        }

                        if (ReadAttributesAccessGranted) {

                            SetFlag( ListDirectoryGrantedAccess, FILE_READ_ATTRIBUTES );
                            ClearFlag( ListDirectoryGrantedAccess, FILE_LIST_DIRECTORY );
                            ClearFlag( DesiredAccess, FILE_READ_ATTRIBUTES );

                        } else {

                            AccessStatusError = AccessStatus;
                        }
                    }

                } finally {

                    NtfsReleaseResource( IrpContext, ParentFcb );
                }

                if (DesiredAccess == 0) {

                    //
                    //  If we got either the delete or list directory access then
                    //  grant access.
                    //

                    if (ListDirectoryGrantedAccess != 0 ||
                        DeleteChildGrantedAccess != 0) {

                        AccessGranted = TRUE;
                    }

                } else {

                    //
                    //  Now the desired access has been munged by removing everything the parent
                    //  has granted so now do the check on the child again
                    //

                    AccessGranted = SeAccessCheck( &Fcb->SharedSecurity->SecurityDescriptor,
                                                   &AccessState->SubjectSecurityContext,
                                                   TRUE,                           // Tokens are locked
                                                   DesiredAccess,
                                                   0,
                                                   &Privileges,
                                                   IoGetFileObjectGenericMapping(),
                                                   EffectiveMode,
                                                   &GrantedAccess,
                                                   &AccessStatus );

                    if (Privileges != NULL) {

                        Status = SeAppendPrivileges( AccessState, Privileges );
                        SeFreePrivileges( Privileges );
                        Privileges = NULL;
                    }

                    //
                    //  Suppose that we asked for MAXIMUM_ALLOWED and no access was allowed
                    //  on the file.  In that case the call above would fail.  It's possible
                    //  that we were given DELETE or READ_ATTR permission from the
                    //  parent directory.  If we have granted any access and the only remaining
                    //  desired access is MAXIMUM_ALLOWED then grant this access.
                    //

                    if (!AccessGranted) {

                        AccessStatusError = AccessStatus;

                        if (DesiredAccess == MAXIMUM_ALLOWED &&
                            (ListDirectoryGrantedAccess != 0 ||
                             DeleteChildGrantedAccess != 0)) {

                            GrantedAccess = 0;
                            AccessGranted = TRUE;
                        }

                    }
                }

                //
                //  If we are given access this time then by definition one of the earlier
                //  parent checks had to have succeeded, otherwise we would have failed again
                //  and we can update the access state
                //

                if (!CheckOnly && AccessGranted) {

                    SetFlag( AccessState->PreviouslyGrantedAccess,
                             (GrantedAccess | DeleteChildGrantedAccess | ListDirectoryGrantedAccess) );

                    ClearFlag( AccessState->RemainingDesiredAccess,
                               (GrantedAccess | MAXIMUM_ALLOWED | DeleteChildGrantedAccess | ListDirectoryGrantedAccess) );
                }
            }
        }

        //
        //  Now call a routine that will do the proper open audit/alarm work
        //
        //  ****    We need to expand the audit alarm code to deal with
        //          create and traverse alarms.
        //

        //
        //  First we take a shortcut and see if we should bother setting up
        //  and making the audit call.
        //

        //
        // NOTE: Calling SeAuditingFileEvents below disables per-user auditing functionality.
        // To make per-user auditing work again, it is necessary to change the call below to
        // be SeAuditingFileOrGlobalEvents, which also takes the subject context.
        //
        // The reason for calling SeAuditingFileEvents here is because per-user auditing is
        // not currently exposed to users, and this routine imposes less of a performance
        // penalty than does calling SeAuditingFileOrGlobalEvents.
        //

        if (SeAuditingFileEventsWithContext( AccessGranted, &Fcb->SharedSecurity->SecurityDescriptor, &AccessState->SubjectSecurityContext )) {

            //
            //  Construct the file name.  The file name
            //  consists of:
            //
            //  The device name out of the Vcb +
            //
            //  The contents of the filename in the File Object +
            //
            //  The contents of the Related File Object if it
            //    is present and the name in the File Object
            //    does not start with a '\'
            //
            //
            //  Obtain the file name.
            //

            PartialFileName = &IrpSp->FileObject->FileName;
            PartialFileNamePresent = (PartialFileName->Length != 0);

            if (!PartialFileNamePresent &&
                FlagOn(IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID) ||
                (IrpSp->FileObject->RelatedFileObject != NULL &&
                 IrpSp->FileObject->RelatedFileObject->FsContext2 != NULL &&
                 FlagOn(((PCCB) IrpSp->FileObject->RelatedFileObject->FsContext2)->Flags,
                     CCB_FLAG_OPEN_BY_FILE_ID))) {

                NtfsBuildNormalizedName( IrpContext, Fcb, NULL, &NormalizedName );

                PartialFileNamePresent = TRUE;
                PartialFileName = &NormalizedName;
            }

            //
            //  Obtain the device name.
            //

            DeviceObjectName = &Fcb->Vcb->DeviceName;
            DeviceObjectNameLength = DeviceObjectName->Length;

            //
            //  Compute how much space we need for the final name string
            //

            FullFileNameLength = (ULONG)DeviceObjectNameLength +
                                 PartialFileName->Length +
                                 sizeof( UNICODE_NULL )  +
                                 sizeof((WCHAR)'\\');

            if ((FullFileNameLength & 0xffff0000L) != 0) {
                NtfsRaiseStatus( IrpContext, STATUS_OBJECT_NAME_INVALID, NULL, NULL );
            }

            FullFileName.MaximumLength = DeviceObjectNameLength  +
                                         PartialFileName->Length +
                                         sizeof( UNICODE_NULL )  +
                                         sizeof((WCHAR)'\\');

            //
            //  If the partial file name starts with a '\', then don't use
            //  whatever may be in the related file name.
            //

            if (PartialFileNamePresent &&
                ((WCHAR)(PartialFileName->Buffer[0]) == L'\\')) {

                LeadingSlash = TRUE;

            } else {

                //
                //  Since PartialFileName either doesn't exist or doesn't
                //  start with a '\', examine the RelatedFileName to see
                //  if it exists.
                //

                LeadingSlash = FALSE;

                if (IrpSp->FileObject->RelatedFileObject != NULL) {

                    RelatedFileName = &IrpSp->FileObject->RelatedFileObject->FileName;
                }

                if (RelatedFileNamePresent = ((RelatedFileName != NULL) && (RelatedFileName->Length != 0))) {

                    FullFileName.MaximumLength += RelatedFileName->Length;
                }
            }

            FullFileName.Buffer = NtfsAllocatePool(PagedPool, FullFileName.MaximumLength );

            RtlCopyUnicodeString( &FullFileName, DeviceObjectName );

            //
            //  RelatedFileNamePresent is not initialized if LeadingSlash == TRUE,
            //  but in that case we won't even examine it.
            //

            if (!LeadingSlash && RelatedFileNamePresent) {

                Status = RtlAppendUnicodeStringToString( &FullFileName, RelatedFileName );

                ASSERTMSG("RtlAppendUnicodeStringToString of RelatedFileName", NT_SUCCESS( Status ));

                //
                //  RelatedFileName may simply be '\'.  Don't append another
                //  '\' in this case.
                //

                if (RelatedFileName->Length != sizeof( WCHAR )) {

                    FullFileName.Buffer[ (FullFileName.Length / sizeof( WCHAR )) ] = L'\\';
                    FullFileName.Length += sizeof(WCHAR);
                }
            }

            if (PartialFileNamePresent) {

                Status = RtlAppendUnicodeStringToString( &FullFileName, PartialFileName );

                //
                //  This should not fail
                //

                ASSERTMSG("RtlAppendUnicodeStringToString of PartialFileName failed", NT_SUCCESS( Status ));
            }


            if (PerformDeleteAudit) {
                SeOpenObjectForDeleteAuditAlarm( &FileString,
                                                 NULL,
                                                 &FullFileName,
                                                 &Fcb->SharedSecurity->SecurityDescriptor,
                                                 AccessState,
                                                 FALSE,
                                                 AccessGranted,
                                                 EffectiveMode,
                                                 &AccessState->GenerateOnClose );
            } else {
                SeOpenObjectAuditAlarm( &FileString,
                                        NULL,
                                        &FullFileName,
                                        &Fcb->SharedSecurity->SecurityDescriptor,
                                        AccessState,
                                        FALSE,
                                        AccessGranted,
                                        EffectiveMode,
                                        &AccessState->GenerateOnClose );

            }

            NtfsFreePool( FullFileName.Buffer );
        }

    } finally {

        if (NormalizedName.Buffer) {
            NtfsFreePool( NormalizedName.Buffer );
        }
        
        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
    }

    //
    //  If access is not granted then we will raise
    //

    if (!AccessGranted) {

        DebugTrace( -1, Dbg, ("NtfsAccessCheck -> Access Denied\n") );

        NtfsRaiseStatus( IrpContext, AccessStatusError, NULL, NULL );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsAccessCheck -> VOID\n") );

    return;
}


NTSTATUS
NtfsCheckFileForDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN BOOLEAN FcbExisted,
    IN PINDEX_ENTRY IndexEntry
    )

/*++

Routine Description:

    This routine checks that the caller has permission to delete the target
    file of a rename or set link operation.

Arguments:

    ParentScb - This is the parent directory for this file.

    ThisFcb - This is the Fcb for the link being removed.

    FcbExisted - Indicates if this Fcb was just created.

    IndexEntry - This is the index entry on the disk for this file.

Return Value:

    NTSTATUS - Indicating whether access was granted or the reason access
        was denied.

--*/

{
    UNICODE_STRING LastComponentFileName;
    PFILE_NAME IndexFileName;
    PLCB ThisLcb;
    PFCB ParentFcb = ParentScb->Fcb;

    PSCB NextScb = NULL;

    BOOLEAN LcbExisted = FALSE;

    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN UnlockSubjectContext = FALSE;

    PPRIVILEGE_SET Privileges = NULL;
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckFileForDelete:  Entered\n") );

    ThisLcb = NULL;

    IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

    //
    //  If the unclean count is non-zero, we exit with an error.
    //

    if (ThisFcb->CleanupCount != 0) {

        DebugTrace( 0, Dbg, ("Cleanup count of target is non-zero\n") );

        return STATUS_ACCESS_DENIED;
    }

    //
    //  We look at the index entry to see if the file is either a directory
    //  or a read-only file.  We can't delete this for a target directory open.
    //

    if (IsDirectory( &ThisFcb->Info )
        || IsReadOnly( &ThisFcb->Info )) {

        DebugTrace( -1, Dbg, ("NtfsCheckFileForDelete:  Read only or directory\n") );

        return STATUS_ACCESS_DENIED;
    }

    //
    //  We want to scan through all of the Scb for data streams on this file
    //  and look for image sections.  We must be able to remove the image section
    //  in order to delete the file.  Otherwise we can get the case where an
    //  active image (with no handle) could be deleted and subsequent faults
    //  through the image section will return zeroes.
    //

    if (ThisFcb->LinkCount == 1) {

        BOOLEAN DecrementScb = FALSE;

        //
        //  We will increment the Scb count to prevent this Scb from going away
        //  if the flush call below generates a close.  Use a try-finally to
        //  restore the count.
        //

        try {

            while ((NextScb = NtfsGetNextChildScb( ThisFcb, NextScb )) != NULL) {

                InterlockedIncrement( &NextScb->CloseCount );
                DecrementScb = TRUE;

                if (NtfsIsTypeCodeUserData( NextScb->AttributeTypeCode ) &&
                    !FlagOn( NextScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) &&
                    (NextScb->NonpagedScb->SegmentObject.ImageSectionObject != NULL)) {

                    if (!MmFlushImageSection( &NextScb->NonpagedScb->SegmentObject,
                                              MmFlushForDelete )) {

                        Status = STATUS_ACCESS_DENIED;
                        leave;
                    }
                }

                InterlockedDecrement( &NextScb->CloseCount );
                DecrementScb = FALSE;
            }

        } finally {

            if (DecrementScb) {

                InterlockedDecrement( &NextScb->CloseCount );
            }
        }

        if (Status != STATUS_SUCCESS) {

            return Status;
        }
    }

    //
    //  We need to check if the link to this file has been deleted.  We
    //  first check if we definitely know if the link is deleted by
    //  looking at the file name flags and the Fcb flags.
    //  If that result is uncertain, we need to create an Lcb and
    //  check the Lcb flags.
    //

    if (FcbExisted) {

        if (FlagOn( IndexFileName->Flags, FILE_NAME_NTFS | FILE_NAME_DOS )) {

            if (FlagOn( ThisFcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED )) {

                DebugTrace( -1, Dbg, ("NtfsCheckFileForDelete:  Link is going away\n") );
                return STATUS_DELETE_PENDING;
            }

        //
        //  This is a Posix link.  We need to create the link to test it
        //  for deletion.
        //

        } else {

            LastComponentFileName.MaximumLength =
            LastComponentFileName.Length = IndexFileName->FileNameLength * sizeof( WCHAR );

            LastComponentFileName.Buffer = (PWCHAR) IndexFileName->FileName;

            ThisLcb = NtfsCreateLcb( IrpContext,
                                     ParentScb,
                                     ThisFcb,
                                     LastComponentFileName,
                                     IndexFileName->Flags,
                                     &LcbExisted );

            //
            //  If no Lcb was returned, there's no way that the Lcb has been
            //  marked for deletion already.
            //

            if ((ThisLcb != NULL) &&
                (FlagOn( ThisLcb->LcbState, LCB_STATE_DELETE_ON_CLOSE ))) {

                DebugTrace( -1, Dbg, ("NtfsCheckFileForDelete:  Link is going away\n") );

                return STATUS_DELETE_PENDING;
            }
        }
    }

    //
    //  Finally call the security package to check for delete access.
    //  We check for delete access on the target Fcb.  If this succeeds, we
    //  are done.  Otherwise we will check for delete child access on the
    //  the parent.  Either is sufficient to perform the delete.
    //

    //
    //  Check if we need to load the security descriptor for the file
    //

    if (ThisFcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, ThisFcb );
    }

    ASSERT( ThisFcb->SharedSecurity != NULL );

#ifdef NTFS_CACHE_RIGHTS
    //
    //  Get any cached knowledge about rights that all callers are known to
    //  have for this security descriptor.
    //

    GrantedAccess = NtfsGetCachedRightsWorld( &ThisFcb->SharedSecurity->CachedRights );
    if (FlagOn( GrantedAccess, DELETE )) {

        return STATUS_SUCCESS;
    }
#endif

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Lock the user context, do the access check and then unlock the context
        //

        SeLockSubjectContext( IrpContext->Union.SubjectContext );
        UnlockSubjectContext = TRUE;

#ifdef NTFS_CACHE_RIGHTS
        //
        //  Acquire any cached knowledge about rights that this caller
        //  is known to have for this security descriptor.
        //

        (VOID)NtfsGetCachedRights( ThisFcb->Vcb,
                                   IrpContext->Union.SubjectContext,
                                   ThisFcb->SharedSecurity,
                                   &GrantedAccess,
                                   NULL,
                                   NULL,
                                   NULL );

        if (FlagOn( GrantedAccess, DELETE )) {

            AccessGranted = TRUE;
            Status = STATUS_SUCCESS;

        } else {
#endif
            AccessGranted = SeAccessCheck( &ThisFcb->SharedSecurity->SecurityDescriptor,
                                           IrpContext->Union.SubjectContext,
                                           TRUE,                           // Tokens are locked
                                           DELETE,
                                           0,
                                           &Privileges,
                                           IoGetFileObjectGenericMapping(),
                                           UserMode,
                                           &GrantedAccess,
                                           &Status );
#ifdef NTFS_CACHE_RIGHTS
        }
#endif

        //
        //  Check if the access is not granted and if we were given a parent fcb, and
        //  if the desired access was asking for delete or file read attributes.  If so
        //  then we need to do some extra work to decide if the caller does get access
        //  based on the parent directories security descriptor
        //

        if (!AccessGranted) {

            //
            //  Before we proceed load in the parent security descriptor
            //

            if (ParentFcb->SharedSecurity == NULL) {

                NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );
            }

            ASSERT( ParentFcb->SharedSecurity != NULL);

            //
            //  Now if the user is asking for delete access then check if the parent
            //  will granted delete access to the child, and if so then we munge the
            //  desired access
            //

#ifdef NTFS_CACHE_RIGHTS
            //
            //  Add in any cached knowledge about rights that this caller
            //  is known to have for this security descriptor.
            //

            (VOID)NtfsGetCachedRights( ParentFcb->Vcb,
                                       IrpContext->Union.SubjectContext,
                                       ParentFcb->SharedSecurity,
                                       &GrantedAccess,
                                       NULL,
                                       NULL,
                                       NULL );

            if (FlagOn( GrantedAccess, FILE_DELETE_CHILD )) {

                AccessGranted = TRUE;
                Status = STATUS_SUCCESS;

            } else {
#endif

                AccessGranted = SeAccessCheck( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                               IrpContext->Union.SubjectContext,
                                               TRUE,                           // Tokens are locked
                                               FILE_DELETE_CHILD,
                                               0,
                                               &Privileges,
                                               IoGetFileObjectGenericMapping(),
                                               UserMode,
                                               &GrantedAccess,
                                               &Status );

#ifdef NTFS_CACHE_RIGHTS
            }
#endif
        }

    } finally {

        DebugUnwind( NtfsCheckFileForDelete );

        if (UnlockSubjectContext) {

            SeUnlockSubjectContext( IrpContext->Union.SubjectContext );
        }

        DebugTrace( -1, Dbg, ("NtfsCheckFileForDelete:  Exit\n") );
    }

    return Status;
}


VOID
NtfsCheckIndexForAddOrDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreatePrivileges
    )

/*++

Routine Description:

    This routine checks if a caller has permission to remove or add a link
    within a directory.

Arguments:

    ParentFcb - This is the parent directory for the add or delete operation.

    DesiredAccess - Indicates the type of operation.  We could be adding or
        removing and entry in the index.

    CreatePriveleges - Backup and restore priveleges captured at create time.

Return Value:

    None - This routine raises on error.

--*/

{
    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    NTSTATUS Status;

    BOOLEAN UnlockSubjectContext = FALSE;

    PPRIVILEGE_SET Privileges = NULL;
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckIndexForAddOrDelete:  Entered\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we have restore privelege then we can add either a file or directory.
        //

        if (FlagOn( CreatePrivileges, TOKEN_HAS_RESTORE_PRIVILEGE )) {

            ClearFlag( DesiredAccess,
                       DELETE | FILE_ADD_SUBDIRECTORY | FILE_ADD_FILE );
        }

        //
        //  Do a security check if there is more being asked for.
        //

        if (DesiredAccess != 0) {

            //
            //  Finally call the security package to check for delete access.
            //  We check for delete access on the target Fcb.  If this succeeds, we
            //  are done.  Otherwise we will check for delete child access on the
            //  the parent.  Either is sufficient to perform the delete.
            //

            //
            //  Check if we need to load the security descriptor for the file
            //

            if (ParentFcb->SharedSecurity == NULL) {

                NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );

            }

            ASSERT( ParentFcb->SharedSecurity != NULL );

#ifdef NTFS_CACHE_RIGHTS
            //
            //  Get any cached knowledge about rights that all callers are known to
            //  have for this security descriptor.
            //

            GrantedAccess = NtfsGetCachedRightsWorld( &ParentFcb->SharedSecurity->CachedRights );

            ClearFlag( DesiredAccess, GrantedAccess );
        }

        if (DesiredAccess != 0) {

            //
            //  Finally call the security package to check for delete access.
            //  We check for delete access on the target Fcb.  If this succeeds, we
            //  are done.  Otherwise we will check for delete child access on the
            //  the parent.  Either is sufficient to perform the delete.
            //
#endif

            //
            //  Capture and lock the user context, do the access check and then unlock the context
            //

            SeLockSubjectContext( IrpContext->Union.SubjectContext );
            UnlockSubjectContext = TRUE;

#ifdef NTFS_CACHE_RIGHTS
            //
            //  Acquire any cached knowledge about rights that this caller
            //  is known to have for this security descriptor.
            //

            (VOID)NtfsGetCachedRights( ParentFcb->Vcb,
                                       IrpContext->Union.SubjectContext,
                                       ParentFcb->SharedSecurity,
                                       &GrantedAccess,
                                       NULL,
                                       NULL,
                                       NULL );

            if (FlagOn( GrantedAccess, DELETE )) {

                AccessGranted = TRUE;
                Status = STATUS_SUCCESS;

            } else {
#endif
                AccessGranted = SeAccessCheck( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                               IrpContext->Union.SubjectContext,
                                               TRUE,                           // Tokens are locked
                                               DesiredAccess,
                                               0,
                                               &Privileges,
                                               IoGetFileObjectGenericMapping(),
                                               UserMode,
                                               &GrantedAccess,
                                               &Status );

                //
                //  If access is not granted then we will raise
                //

                if (!AccessGranted) {

                    DebugTrace( 0, Dbg, ("Access Denied\n") );

                    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

                }
#ifdef NTFS_CACHE_RIGHTS
            }
#endif
        }

    } finally {

        DebugUnwind( NtfsCheckIndexForAddOrDelete );

        if (UnlockSubjectContext) {

            SeUnlockSubjectContext( IrpContext->Union.SubjectContext );
        }

        DebugTrace( -1, Dbg, ("NtfsCheckIndexForAddOrDelete:  Exit\n") );
    }

    return;
}


PSHARED_SECURITY
GetSharedSecurityFromDescriptorUnsafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    )

/*++

Routine Description:

    This routine is called to create or find a shared security structure
    given an security descriptor. We check the parent if present to determine
    if we have a matching security descriptor and reference the existing one if
    so.  This routine must be called while holding the Vcb so we can
    safely access the parent structure.

Arguments:

    IrpContext - context of call

    SecurityId - Id (if known) of security descriptor.

    SecurityDescriptor - Security Descriptor for this file.

    SecurityDescriptorLength - Length of security descriptor for this file

    RaiseIfInvalid - raise if the sd is invalid rather than supplying a default
                     used during a create as opposed to an open

Return Value:

    PSHARED_SECURITY if found, NULL otherwise.

--*/

{
    ULONG Hash = 0;
    PSHARED_SECURITY SharedSecurity;

    PAGED_CODE();

    //
    //  Make sure the security descriptor we just read in is valid
    //

    if ((SecurityDescriptorLength == 0) ||
        !SeValidSecurityDescriptor( SecurityDescriptorLength, SecurityDescriptor )) {

        if (RaiseIfInvalid) {
            NtfsRaiseStatus( IrpContext, STATUS_INVALID_SECURITY_DESCR, NULL, NULL );
        }

        SecurityDescriptor = NtfsData.DefaultDescriptor;
        SecurityDescriptorLength = NtfsData.DefaultDescriptorLength;

        if (!SeValidSecurityDescriptor( SecurityDescriptorLength, SecurityDescriptor )) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
        }
    }

    //
    //  Hash security descriptor.  This hash must be position independent to
    //  allow for multiple instances of the same descriptor.  It is assumed
    //  that the bits within the security descriptor are all position
    //  independent, i.e, no pointers, all offsets.
    //
    //  For speed in the hash, we consider the security descriptor as an array
    //  of ULONGs.  The fragment at the end that is ignored should not affect
    //  the collision nature of this hash.
    //

    {
        PULONG Rover = (PULONG)SecurityDescriptor;
        ULONG Count = SecurityDescriptorLength / 4;

        while (Count--) {

            Hash = ((Hash << 3) | (Hash >> (32-3))) + *Rover++;
        }
    }

    DebugTrace( 0, DbgAcl, ("Hash is %08x\n", Hash) );

    //
    //  try to find it by hash
    //

    SharedSecurity = FindCachedSharedSecurityByHashUnsafe( IrpContext->Vcb,
                                                           SecurityDescriptor,
                                                           SecurityDescriptorLength,
                                                           Hash );

    //
    //  If we can't find an existing descriptor allocate new pool and copy
    //  security descriptor into it.
    //

    if (SharedSecurity == NULL) {
        SharedSecurity = NtfsAllocatePool( PagedPool,
                                           FIELD_OFFSET( SHARED_SECURITY, SecurityDescriptor )
                                               + SecurityDescriptorLength );

        SharedSecurity->ReferenceCount = 0;

        //
        //  Initialize security index data in shared security
        //

        //
        //  Set the security id in the shared structure.  If it is not
        //  invalid, also cache this shared security structure
        //

        SharedSecurity->Header.HashKey.SecurityId = SECURITY_ID_INVALID;
        SharedSecurity->Header.HashKey.Hash = Hash;
        SetSharedSecurityLength(SharedSecurity, SecurityDescriptorLength);
        SharedSecurity->Header.Offset = (ULONGLONG) 0xFFFFFFFFFFFFFFFFi64;

        RtlCopyMemory( &SharedSecurity->SecurityDescriptor,
                       SecurityDescriptor,
                       SecurityDescriptorLength );

#ifdef NTFS_CACHE_RIGHTS
        //
        //  Initialize the cached rights.
        //

        RtlZeroMemory( &SharedSecurity->CachedRights,
                       sizeof( CACHED_ACCESS_RIGHTS ));
#endif
    }

    DebugTrace( 0, DbgAcl, ("GetSharedSecurityFromDescriptorUnsafe found %08x with Id %08x\n",
                            SharedSecurity, SharedSecurity->Header.HashKey.SecurityId ));

    return SharedSecurity;
}


VOID
NtfsSetFcbSecurityFromDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB Fcb,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    )

/*++

Routine Description:

    This routine is called to fill in the shared security structure in
    an Fcb.  We check the parent if present to determine if we have
    a matching security descriptor and reference the existing one if
    so.  This routine must be called while holding the Vcb so we can
    safely access the parent structure.

Arguments:

    IrpContext - context of call

    Fcb - Supplies the fcb for the file being operated on

    SecurityDescriptor - Security Descriptor for this file.

    SecurityDescriptorLength - Length of security descriptor for this file

Return Value:

    None.

--*/

{
    PSHARED_SECURITY SharedSecurity;

    PAGED_CODE( );

    NtfsAcquireFcbSecurity( Fcb->Vcb );

    try {
        SharedSecurity = GetSharedSecurityFromDescriptorUnsafe( IrpContext,
                                                                SecurityDescriptor,
                                                                SecurityDescriptorLength,
                                                                RaiseIfInvalid );

        SharedSecurity->ReferenceCount += 1;
        DebugTrace( +1, DbgAcl, ("NtfsSetFcbSecurityFromDescriptor bumping refcount %08x\n", SharedSecurity ));

        ASSERT( Fcb->SharedSecurity == NULL );
        Fcb->SharedSecurity = SharedSecurity;

        AddCachedSharedSecurityUnsafe( IrpContext->Vcb, SharedSecurity );

    } finally {

        NtfsReleaseFcbSecurity( Fcb->Vcb );
    }

    return;
}


BOOLEAN
NtfsNotifyTraverseCheck (
    IN PCCB Ccb,
    IN PFCB Fcb,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    )

/*++

Routine Description:

    This routine is the callback routine provided to the dir notify package
    to check that a caller who is watching a tree has traverse access to
    the directory which has the change.  This routine is only called
    when traverse access checking was turned on for the open used to
    perform the watch.

Arguments:

    Ccb - This is the Ccb associated with the directory which is being
        watched.

    Fcb - This is the Fcb for the directory which contains the file being
        modified.  We want to walk up the tree from this point and check
        that the caller has traverse access across that directory.
        If not specified then there is no work to do.

    SubjectContext - This is the subject context captured at the time the
        dir notify call was made.

Return Value:

    BOOLEAN - TRUE if the caller has traverse access to the file which was
        changed.  FALSE otherwise.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    PFCB TopFcb;

    IRP_CONTEXT LocalIrpContext;
    IRP LocalIrp;

    PIRP_CONTEXT IrpContext;

    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    NTSTATUS Status = STATUS_SUCCESS;
#ifdef NTFS_CACHE_RIGHTS
    NTSTATUS TokenInfoStatus = STATUS_UNSUCCESSFUL;
#endif

    PPRIVILEGE_SET Privileges = NULL;
    PAGED_CODE();

    //
    //  If we have no Fcb then we can return immediately.
    //

    if (Fcb == NULL) {

        return TRUE;
    }

    IrpContext = &LocalIrpContext;
    NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );

    IrpContext->OriginatingIrp = &LocalIrp;
    IrpContext->Vcb = Fcb->Vcb;

    //
    //  Make sure we don't get any pop-ups
    //

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
    ASSERT( ThreadTopLevelContext == &TopLevelContext );

    NtfsUpdateIrpContextWithTopLevel( IrpContext, &TopLevelContext );

    TopFcb = Ccb->Lcb->Fcb;

    //
    //  Use a try-except to catch all of the errors.
    //

    try {

        //
        //  Always lock the subject context.
        //

        SeLockSubjectContext( SubjectContext );

        //
        //  Use a try-finally to perform local cleanup.
        //

        try {

            //
            //  We look while walking up the tree.
            //

            do {

#ifdef NTFS_CACHE_RIGHTS
                LUID ModifiedId;
                LUID TokenId;
#endif
                PLCB ParentLcb;

                //
                //  Since this is a directory it can have only one parent.  So
                //  we can use any Lcb to walk upwards.
                //

                ParentLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                               LCB,
                                               FcbLinks );

                Fcb = ParentLcb->Scb->Fcb;

                //
                //  Check if we need to load the security descriptor for the file
                //

                if (Fcb->SharedSecurity == NULL) {

                    NtfsLoadSecurityDescriptor( IrpContext, Fcb );
                }

#ifdef NTFS_CACHE_RIGHTS
                //
                //  Acquire any cached knowledge about rights that this caller
                //  is known to have for this security descriptor.
                //
                //  Note that we can trust that TokenId and ModifiedId won't
                //  change inside this block of code because we have locked
                //  the subject context above.
                //

                if (TokenInfoStatus != STATUS_SUCCESS) {

                    //
                    //  We have not previously acquired the Id information.
                    //

                    TokenInfoStatus = NtfsGetCachedRights( Fcb->Vcb,
                                                           SubjectContext,
                                                           Fcb->SharedSecurity,
                                                           &GrantedAccess,
                                                           NULL,
                                                           &TokenId,
                                                           &ModifiedId );
                } else {

                    NtfsGetCachedRightsById( Fcb->Vcb,
                                             &TokenId,
                                             &ModifiedId,
                                             SubjectContext,
                                             Fcb->SharedSecurity,
                                             NULL,
                                             &GrantedAccess );
                }

                if (FlagOn( GrantedAccess, FILE_TRAVERSE )) {

                    AccessGranted = TRUE;

                } else {
#endif
                    AccessGranted = SeAccessCheck( &Fcb->SharedSecurity->SecurityDescriptor,
                                                   SubjectContext,
                                                   TRUE,                           // Tokens are locked
                                                   FILE_TRAVERSE,
                                                   0,
                                                   &Privileges,
                                                   IoGetFileObjectGenericMapping(),
                                                   UserMode,
                                                   &GrantedAccess,
                                                   &Status );
#ifdef NTFS_CACHE_RIGHTS
                }
#endif

            } while (AccessGranted && (Fcb != TopFcb));

        } finally {

            SeUnlockSubjectContext( SubjectContext );
        }

    } except (NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        NOTHING;
    }

    NtfsCleanupIrpContext( IrpContext, TRUE );

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    return AccessGranted;
}


VOID
NtfsInitializeSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to initialize the security indexes and descriptor
    stream.

Arguments:

    IrpContext - context of call

    Vcb - Supplies the volume being initialized

    Fcb - Supplies the file containing the seurity indexes and descriptor
        stream.

Return Value:

    None.

--*/

{
    UNICODE_STRING SecurityIdIndexName = CONSTANT_UNICODE_STRING( L"$SII" );
    UNICODE_STRING SecurityDescriptorHashIndexName = CONSTANT_UNICODE_STRING( L"$SDH" );
    UNICODE_STRING SecurityDescriptorStreamName = CONSTANT_UNICODE_STRING( L"$SDS" );

    MAP_HANDLE Map;
    NTSTATUS Status;

    PAGED_CODE( );

    //
    //  Open/Create the security descriptor stream
    //

    NtOfsCreateAttribute( IrpContext,
                          Fcb,
                          SecurityDescriptorStreamName,
                          CREATE_OR_OPEN,
                          TRUE,
                          &Vcb->SecurityDescriptorStream );

    NtfsAcquireSharedScb( IrpContext, Vcb->SecurityDescriptorStream );

    //
    //  Load the run information for the Security data stream.
    //  Note this call must be done after the stream is nonresident.
    //

    if (!FlagOn( Vcb->SecurityDescriptorStream->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {
        NtfsPreloadAllocation( IrpContext,
                               Vcb->SecurityDescriptorStream,
                               0,
                               MAXLONGLONG );
    }

    //
    //  Open the Security descriptor indexes and storage.
    //

    NtOfsCreateIndex( IrpContext,
                      Fcb,
                      SecurityIdIndexName,
                      CREATE_OR_OPEN,
                      0,
                      COLLATION_NTOFS_ULONG,
                      NtOfsCollateUlong,
                      NULL,
                      &Vcb->SecurityIdIndex );

    NtOfsCreateIndex( IrpContext,
                      Fcb,
                      SecurityDescriptorHashIndexName,
                      CREATE_OR_OPEN,
                      0,
                      COLLATION_NTOFS_SECURITY_HASH,
                      NtOfsCollateSecurityHash,
                      NULL,
                      &Vcb->SecurityDescriptorHashIndex );

    //
    //  Retrieve the next security Id to allocate
    //

    try {

        SECURITY_ID LastSecurityId = 0xFFFFFFFF;
        INDEX_KEY LastKey;
        INDEX_ROW LastRow;

        LastKey.KeyLength = sizeof( SECURITY_ID );
        LastKey.Key = &LastSecurityId;

        Map.Bcb = NULL;

        Status = NtOfsFindLastRecord( IrpContext,
                                      Vcb->SecurityIdIndex,
                                      &LastKey,
                                      &LastRow,
                                      &Map );

        //
        //  If we've found the last key, set the next Id to allocate to be
        //  one greater than this last key.
        //

        if (Status == STATUS_SUCCESS) {

            ASSERT( LastRow.KeyPart.KeyLength == sizeof( SECURITY_ID ) );
            if (LastRow.KeyPart.KeyLength != sizeof( SECURITY_ID )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            DebugTrace( 0, DbgAcl, ("Found last security Id in index\n") );
            Vcb->NextSecurityId = *(SECURITY_ID *)LastRow.KeyPart.Key + 1;

        //
        //  If the index is empty, then set the next Id to be the beginning of the
        //  user range.
        //

        } else if (Status == STATUS_NO_MATCH) {

            DebugTrace( 0, DbgAcl, ("Security Id index is empty\n") );
            Vcb->NextSecurityId = SECURITY_ID_FIRST;

        } else {

            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        //
        //  Update the fcb info from disk to pick up info changed like the FILE_VIEW_INDEX_PRESENT
        //  flags. Then update the duplicate info in the parent fcb (the root)
        //  

        NtfsUpdateFcbInfoFromDisk( IrpContext, FALSE, Fcb, NULL );
        NtfsUpdateDuplicateInfo( IrpContext, Fcb, NULL, NULL );

        DebugTrace( 0, DbgAcl, ("NextSecurityId is %x\n", Vcb->NextSecurityId) );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        NtfsVerifySecurity( IrpContext, Vcb );
#endif

    } finally {

        NtOfsReleaseMap( IrpContext, &Map );
    }
}


PSHARED_SECURITY
NtfsCacheSharedSecurityBySecurityId (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN SECURITY_ID SecurityId
    )

/*++

Routine Description:

    This routine maps looks up a shared security structure given the security Id by
    looking in the per-Vcb cache or loads it if not present.

Arguments:

    IrpContext - Context of call

    Vcb - Volume where security Id is cached

    SecurityId - security Id for descriptor that is being retrieved

Return Value:

    Referenced PSHARED_SECURITY of found descriptor.

--*/

{
    PSHARED_SECURITY *Bucket;
    PSHARED_SECURITY SharedSecurity;
    PBCB Bcb;
    PSECURITY_DESCRIPTOR_HEADER SecurityDescriptorHeader;

    PAGED_CODE( );

    NtfsAcquireFcbSecurity( Vcb );

    //
    //  Probe the cache by Id
    //

    Bucket = Vcb->SecurityCacheById[SecurityId % VCB_SECURITY_CACHE_BY_ID_SIZE];

    //
    //  We get a match under the following conditions.
    //
    //      - There is a corresponding entry in the SecurityID array
    //      - This entry points to an entry in the SecurityHash array
    //      - The entry in the SecurityHash array has the correct SecurityID
    //

    if ((Bucket != NULL) &&
        ((SharedSecurity = *Bucket) != NULL) &&
        (SharedSecurity->Header.HashKey.SecurityId == SecurityId)) {

        DebugTrace( 0, DbgAcl, ("Found cached security descriptor %x %x\n",
            SharedSecurity, SharedSecurity->Header.HashKey.SecurityId) );

        DebugTrace( 0, DbgAcl, ("NtfsCacheSharedSecurityBySecurityId bumping refcount %08x\n", SharedSecurity ));

        //
        //  We found the correct shared security.  Make sure it cannot go
        //  away on us.
        //

        SharedSecurity->ReferenceCount += 1;
        NtfsReleaseFcbSecurity( Vcb );
        return SharedSecurity;
    }

    //
    //  If we get here we didn't find a matching descriptor.  Throw away
    //  the incorrect security descriptor we may have found through the
    //  SecurityID array.
    //

    SharedSecurity = NULL;
    NtfsReleaseFcbSecurity( Vcb );

    //
    //  If we don't have a security index, then return the default security descriptor.
    //  This should only happen in cases of corrupted volumes or security indices.
    //

    if (Vcb->SecurityDescriptorStream == NULL) {

        DebugTrace( 0, 0, ("No security index present in Vcb, using default descriptor\n") );
        return NULL;
    }

    //
    //  We don't have the descriptor in the cache and have to load it from disk.
    //

    Bcb = NULL;

    DebugTrace( 0, DbgAcl, ("Looking up security descriptor %x\n", SecurityId) );

    //
    //  Lock down the security stream
    //

    NtfsAcquireSharedScb( IrpContext, Vcb->SecurityDescriptorStream );

    //
    //  Reacquire the security mutex
    //

    NtfsAcquireFcbSecurity( Vcb );

    try {

        //
        //  Consult the Vcb index to map to the security descriptor
        //

        if (!MapSecurityIdToSecurityDescriptorHeaderUnsafe( IrpContext,
                                                            Vcb,
                                                            SecurityId,
                                                            &SecurityDescriptorHeader,
                                                            &Bcb )) {

            //
            //  We couldn't find the Id.  We generate a security descriptor from
            //  the default one.
            //

            leave;
        }

        DebugTrace( 0, DbgAcl, ("Found it at %16I64X\n", SecurityDescriptorHeader->Offset) );

        //
        //  Look up the security descriptor by hash (just in case)
        //

        SharedSecurity = FindCachedSharedSecurityByHashUnsafe( Vcb,
                                                               (PSECURITY_DESCRIPTOR) ( SecurityDescriptorHeader + 1 ),
                                                               GETSECURITYDESCRIPTORLENGTH( SecurityDescriptorHeader ),
                                                               SecurityDescriptorHeader->HashKey.Hash );

        //
        //  If not found
        //

        if (SharedSecurity == NULL) {

            DebugTrace( 0, DbgAcl, ("Not in hash table, creating new SHARED SECURITY\n") );

            SharedSecurity = NtfsAllocatePool( PagedPool,
                                               FIELD_OFFSET( SHARED_SECURITY, Header ) + SecurityDescriptorHeader->Length );

            SharedSecurity->ReferenceCount = 0;

            RtlCopyMemory( &SharedSecurity->Header,
                           SecurityDescriptorHeader,
                           SecurityDescriptorHeader->Length );

#ifdef NTFS_CACHE_RIGHTS
            //
            //  Initialize the cached rights.
            //

            RtlZeroMemory( &SharedSecurity->CachedRights,
                           sizeof( CACHED_ACCESS_RIGHTS ));
#endif

        } else {
            DebugTrace( 0, DbgAcl, ("Found in hash table %x, promoting header\n", SharedSecurity) );
            //
            //  We found the descriptor by hash.  Perform some consistency checks
            //


#if DBG
            if (SharedSecurity->Header.HashKey.SecurityId != SECURITY_ID_INVALID &&
                SharedSecurity->Header.HashKey.SecurityId != SecurityId )
                DebugTrace( 0, 0, ("Duplicate hash entry found %x %x\n", SecurityId,
                                   SharedSecurity->Header.HashKey.SecurityId ));
#endif

            SharedSecurity->Header = *SecurityDescriptorHeader;
        }

        //
        //  reference the security descriptor
        //

        SharedSecurity->ReferenceCount += 1;

        //
        //  Regardless of whether we found it by hash (since the earlier Id probe missed)
        //  or created it anew.  Let's put it back into the cache
        //

        AddCachedSharedSecurityUnsafe( Vcb, SharedSecurity );

    } finally {

        NtfsUnpinBcb( IrpContext, &Bcb );
        NtfsReleaseScb( IrpContext, Vcb->SecurityDescriptorStream );

        //
        //  Release access to security cache
        //

        NtfsReleaseFcbSecurity( Vcb );
    }

    //
    //  if we did not generate a shared security, then build one from
    //  the default security descriptor
    //

    if (SharedSecurity == NULL) {
        DebugTrace( 0, 0, ("Security Id %x not found, using default\n", SecurityId) );
        SharedSecurity = NtfsCacheSharedSecurityByDescriptor( IrpContext,
                                                              NtfsData.DefaultDescriptor,
                                                              NtfsData.DefaultDescriptorLength,
                                                              FALSE );
    }

    return SharedSecurity;
}


//
//  Local Support routine
//

PSHARED_SECURITY
FindCachedSharedSecurityByHashUnsafe (
    IN PVCB Vcb,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN ULONG Hash
    )

/*++

Routine Description:

    This routine maps looks up a shared security structure given the Hash by
    looking in the per-Vcb cache.  This routine assumes exclusive access to the
    security cache.

Arguments:

    Vcb - Volume where security Id is cached

    SecurityDescriptor - Security descriptor being retrieved

    SecurityDescriptorLength - length of descriptor.

    Hash - Hash for descriptor that is being retrieved

Return Value:

    PSHARED_SECURITY of found shared descriptor.  Otherwise, NULL is returned.

--*/

{
    PSHARED_SECURITY SharedSecurity;

    PAGED_CODE( );

    //
    //  Hash the hash into the per-volume table

    SharedSecurity = Vcb->SecurityCacheByHash[Hash % VCB_SECURITY_CACHE_BY_HASH_SIZE];

    //
    //  If there is no shared descriptor there, then no match
    //

    if (SharedSecurity == NULL) {
        return NULL;
    }

    //
    //  if the hash doesn't match then no descriptor found
    //

    if (SharedSecurity->Header.HashKey.Hash != Hash) {
        return NULL;
    }

    //
    //  If the lengths don't match then no descriptor found
    //

    if (GetSharedSecurityLength( SharedSecurity ) != SecurityDescriptorLength) {
        return NULL;
    }

    //
    //  If the security descriptor bits don't compare then no match
    //

    if (!RtlEqualMemory( SharedSecurity->SecurityDescriptor,
                         SecurityDescriptor,
                         SecurityDescriptorLength) ) {
        return NULL;
    }


    //
    //  The shared security was found
    //

    return SharedSecurity;
}


//
//  Local Support routine
//

VOID
AddCachedSharedSecurityUnsafe (
    IN PVCB Vcb,
    PSHARED_SECURITY SharedSecurity
    )

/*++

Routine Description:

    This routine adds shared security to the Vcb Cache.  This routine assumes
    exclusive access to the security cache.  The shared security being added
    may have a ref count of one and may already be in the table.

Arguments:

    Vcb - Volume where security Id is cached

    SharedSecurity - descriptor to be added to the cache

Return Value:

    None.

--*/

{
    PSHARED_SECURITY *Bucket;
    PSHARED_SECURITY Old;

    PAGED_CODE( );

    //
    //  Is there an item already in the hash bucket?
    //

    Bucket = &Vcb->SecurityCacheByHash[SharedSecurity->Header.HashKey.Hash % VCB_SECURITY_CACHE_BY_HASH_SIZE];

    Old = *Bucket;

    //
    //  Place it into the bucket and reference it
    //

    *Bucket = SharedSecurity;
    SharedSecurity->ReferenceCount += 1;
    DebugTrace( 0, DbgAcl, ("AddCachedSharedSecurityUnsafe bumping refcount %08x\n", SharedSecurity ));

    //
    //  Set up hash to point to bucket
    //

    Vcb->SecurityCacheById[SharedSecurity->Header.HashKey.SecurityId % VCB_SECURITY_CACHE_BY_ID_SIZE] = Bucket;

    //
    //  Handle removing the old value from the bucket.  We do this after advancing
    //  the ReferenceCount above in the case where the item is already in the bucket.
    //

    if (Old != NULL) {

        //
        //  Remove and dereference the item in the bucket
        //

        RemoveReferenceSharedSecurityUnsafe( &Old );
    }

    return;
}


VOID
NtOfsPurgeSecurityCache (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine removes all shared security from the per-Vcb cache.

Arguments:

    Vcb - Volume where descriptors are cached

Return Value:

    None.

--*/

{
    ULONG i;

    PAGED_CODE( );

    //
    //  Serialize access to the security cache
    //

    NtfsAcquireFcbSecurity( Vcb );

    //
    //  Walk through the cache looking for cached security
    //

    for (i = 0; i < VCB_SECURITY_CACHE_BY_ID_SIZE; i++)
    {
        if (Vcb->SecurityCacheByHash[i] != NULL) {
            //
            //  Remove the reference to the security
            //

            PSHARED_SECURITY SharedSecurity = Vcb->SecurityCacheByHash[i];
            Vcb->SecurityCacheByHash[i] = NULL;
            RemoveReferenceSharedSecurityUnsafe( &SharedSecurity );
        }
    }

    //
    //  Release access to the cache
    //

    NtfsReleaseFcbSecurity( Vcb );
}


//
//  Local Support routine
//

BOOLEAN
MapSecurityIdToSecurityDescriptorHeaderUnsafe (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN SECURITY_ID SecurityId,
    OUT PSECURITY_DESCRIPTOR_HEADER *SecurityDescriptorHeader,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine maps from a security Id to the descriptor bits stored in the
    security descriptor stream using the security Id index.

Arguments:

    IrpContext - Context of the call

    Vcb - Volume where descriptor is stored

    SecurityId - security Id for descriptor that is being retrieved

    SecurityDescriptorHeader - returned security descriptor pointer

    Bcb - returned mapping control structure

Return Value:

    True if the descriptor header was successfully mapped.

--*/

{
    SECURITY_DESCRIPTOR_HEADER Header;
    NTSTATUS Status;
    MAP_HANDLE Map;
    INDEX_ROW Row;
    INDEX_KEY Key;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    PAGED_CODE( );

    DebugTrace( 0, DbgAcl, ("Mapping security ID %08x\n", SecurityId) );

    //
    //  Lookup descriptor stream position information.
    //  The format of the key is simply the ULONG SecurityId
    //

    Key.KeyLength = sizeof( SecurityId );
    Key.Key = &SecurityId;

    Status = NtOfsFindRecord( IrpContext,
                              Vcb->SecurityIdIndex,
                              &Key,
                              &Row,
                              &Map,
                              NULL );

    DebugTrace( 0, DbgAcl, ("Security Id lookup status = %08x\n", Status) );

    //
    //  If the security Id is not found, we let the called decide if the volume
    //  needs fixing or whether a default descriptor should be used.
    //

    if (Status == STATUS_NO_MATCH) {
        return FALSE;
    }

    //
    //  Save security descriptor offset and length information
    //

    Header = *(PSECURITY_DESCRIPTOR_HEADER)Row.DataPart.Data;
    ASSERT( Header.HashKey.SecurityId == SecurityId );

    //
    //  Release mapping information
    //

    NtOfsReleaseMap( IrpContext, &Map );

    //
    //  Make sure that the data is the correct size.  This is a true failure case
    //  where we must fix the disk up. We can just return false because caller
    //  will then use a default sd and chkdsk will replace with the same default
    //  when it next  verifies the disk
    //

    ASSERT( Row.DataPart.DataLength == sizeof( SECURITY_DESCRIPTOR_HEADER ) );
    if (Row.DataPart.DataLength != sizeof( SECURITY_DESCRIPTOR_HEADER )) {
        DebugTrace( 0, DbgAcl, ("SecurityId data doesn't have the correct length\n") );
        return FALSE;
    }

    //
    //  Don't try to map clearly invalid sections of the sds stream
    //

    if (Header.Offset > (ULONGLONG)(Vcb->SecurityDescriptorStream->Header.FileSize.QuadPart) ||
        Header.Offset + Header.Length > (ULONGLONG)(Vcb->SecurityDescriptorStream->Header.FileSize.QuadPart)) {
        DebugTrace( 0, DbgAcl, ("SecurityId data doesn't have a correct position\n") );
        return FALSE;
    }

    //
    //  Map security descriptor
    //

    DebugTrace( 0, DbgAcl, ("Mapping security descriptor stream at %I64x, len %x\n",
                    Header.Offset, Header.Length) );

    NtfsMapStream(
        IrpContext,
        Vcb->SecurityDescriptorStream,
        Header.Offset,
        Header.Length,
        Bcb,
        SecurityDescriptorHeader );

    //
    //  Sanity check the found descriptor
    //

    if (RtlCompareMemory( &Header, *SecurityDescriptorHeader, sizeof( Header )) != sizeof( Header )) {
        DebugTrace( 0, DbgAcl, ("Index data does not match stream header\n") );
        return FALSE;
    }

    //
    //  Now actually verify the descriptor is valid. If length is too small (even 0)
    //  SeValidSecurityDescriptor will safely return false so we don't need to test this
    //  before calling
    //

    SecurityDescriptor = (PSECURITY_DESCRIPTOR) Add2Ptr( (*SecurityDescriptorHeader), sizeof( SECURITY_DESCRIPTOR_HEADER ) );

    if (!SeValidSecurityDescriptor( GETSECURITYDESCRIPTORLENGTH( *SecurityDescriptorHeader ), SecurityDescriptor )) {
        DebugTrace( 0, DbgAcl, ("SecurityId data is not valid\n") );
        return FALSE;
    }

#if DBG
    {
        ULONG SecurityDescLength;

        SecurityDescLength = RtlLengthSecurityDescriptor( SecurityDescriptor );
        ASSERT( SecurityDescLength == GETSECURITYDESCRIPTORLENGTH( *SecurityDescriptorHeader ) );
    }
#endif

    return TRUE;
}


VOID
NtfsLoadSecurityDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine loads the shared security descriptor into the fcb for the
    file from disk using either the SecurityId or the $Security_Descriptor

Arguments:

    Fcb - Supplies the fcb for the file being operated on

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERTMSG("Must only be called with a null value here", Fcb->SharedSecurity == NULL);

    DebugTrace( +1, DbgAcl, ("NtfsLoadSecurityDescriptor...\n") );

    //
    //  If the file has a valid SecurityId then retrieve the security descriptor
    //  from the security descriptor index
    //

    if ((Fcb->SecurityId != SECURITY_ID_INVALID) &&
        (Fcb->Vcb->SecurityDescriptorStream != NULL)) {

        ASSERT( Fcb->SharedSecurity == NULL );
        Fcb->SharedSecurity = NtfsCacheSharedSecurityBySecurityId( IrpContext,
                                                                   Fcb->Vcb,
                                                                   Fcb->SecurityId );

        ASSERT( Fcb->SharedSecurity != NULL );

    } else {

        PBCB Bcb = NULL;
        PSECURITY_DESCRIPTOR SecurityDescriptor;
        ULONG SecurityDescriptorLength;
        ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
        PATTRIBUTE_RECORD_HEADER Attribute;

        try {
            //
            //  Read in the security descriptor attribute, and if it is not present
            //  then there then the file is not protected.  In that case we will
            //  use the default descriptor.
            //

            NtfsInitializeAttributeContext( &AttributeContext );

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $SECURITY_DESCRIPTOR,
                                            &AttributeContext )) {

                DebugTrace( 0, DbgAcl, ("Security Descriptor attribute does not exist\n") );

                SecurityDescriptor = NtfsData.DefaultDescriptor;
                SecurityDescriptorLength = NtfsData.DefaultDescriptorLength;

            } else {

                //
                //  There must be a security descriptor with a non-zero length; only
                //  applies for non-resident descriptors with valid data length.
                //

                Attribute = NtfsFoundAttribute( &AttributeContext );

                if (NtfsIsAttributeResident( Attribute ) ?
                    (Attribute->Form.Resident.ValueLength == 0) :
                    (Attribute->Form.Nonresident.ValidDataLength == 0)) {

                    SecurityDescriptor = NtfsData.DefaultDescriptor;
                    SecurityDescriptorLength = NtfsData.DefaultDescriptorLength;

                } else {

                    NtfsMapAttributeValue( IrpContext,
                                           Fcb,
                                           (PVOID *)&SecurityDescriptor,
                                           &SecurityDescriptorLength,
                                           &Bcb,
                                           &AttributeContext );
                }
            }

            NtfsSetFcbSecurityFromDescriptor(
                                   IrpContext,
                                   Fcb,
                                   SecurityDescriptor,
                                   SecurityDescriptorLength,
                                   FALSE );
            } finally {

            DebugUnwind( NtfsLoadSecurityDescriptor );

            //
            //  Cleanup our attribute enumeration context and the Bcb
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            NtfsUnpinBcb( IrpContext, &Bcb );
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, DbgAcl, ("NtfsLoadSecurityDescriptor -> VOID\n") );

    return;
}


//
//  Local Support routine
//

NTSTATUS
NtOfsMatchSecurityHash (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

/*++

Routine Description:

    Test whether an index row is worthy of returning based on its contents as
    a row in the SecurityDescriptorHashIndex.

Arguments:

    IndexRow - row that is being tested

    MatchData - a PVOID that is the hash function we look for.

Returns:

    STATUS_SUCCESS if the IndexRow matches
    STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should
        continue
    STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration
        should terminate


--*/

{
    ASSERT(IndexRow->KeyPart.KeyLength == sizeof( SECURITY_HASH_KEY ) );

    PAGED_CODE( );

    if (((PSECURITY_HASH_KEY)IndexRow->KeyPart.Key)->Hash == (ULONG)((ULONG_PTR) MatchData)) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_NO_MORE_MATCHES;
    }
}

#if (DBG || defined( NTFS_FREE_ASSERTS ))
VOID
NtfsVerifySecurity (
    PIRP_CONTEXT IrpContext,
    PVCB Vcb
    )
/*++

Routine Description:

    Scan through all the security descriptors in the sds stream and verify their hash
    values in the sdh stream match

Arguments:

    IrpContext - context of the call

    SharedSecurity - shared security for a file

Return Value:

    None.

--*/

{
    
    PSECURITY_DESCRIPTOR_HEADER SdHeader;
    PSECURITY_DESCRIPTOR_HEADER SdHeader2;
    LONGLONG Offset = 0;
    ULONG Length = sizeof( SECURITY_DESCRIPTOR_HEADER );
    PBCB Bcb;
    ULONG Hash;
    ULONG SecurityDescriptorLength;
    INDEX_KEY IndexKey;
    INDEX_ROW FoundRow;
    SECURITY_HASH_KEY HashKey;
    PREAD_CONTEXT ReadContext = NULL;
    ULONG FoundCount = 1;
    UCHAR HashDescriptorHeader[2 * (sizeof( SECURITY_DESCRIPTOR_HEADER ) + sizeof( ULONG ))];
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  This covers both sds and sdh since they both share the same main resource
    //  

    NtfsAcquireSharedScb( IrpContext, IrpContext->Vcb->SecurityDescriptorHashIndex );

    //
    //  Enumerate the security hash index
    //    

    try {
        
        HashKey.Hash = 0;
        HashKey.SecurityId = 0;
        IndexKey.KeyLength = sizeof( SECURITY_HASH_KEY );
        IndexKey.Key = &HashKey;

        NtOfsReadRecords( IrpContext,
                          IrpContext->Vcb->SecurityDescriptorHashIndex,
                          &ReadContext,
                          &IndexKey,
                          NtOfsMatchAll,
                          NULL,
                          &FoundCount,
                          &FoundRow,
                          sizeof( HashDescriptorHeader ),
                          &HashDescriptorHeader[0]);
        

        while ((Status == STATUS_SUCCESS) && (FoundCount == 1)) {

            SdHeader = (PSECURITY_DESCRIPTOR_HEADER)FoundRow.DataPart.Data; 
            
            //
            //  Read the raw security descriptor
            //  

            NtfsMapStream( IrpContext,
                           Vcb->SecurityDescriptorStream,
                           SdHeader->Offset,
                           SdHeader->Length,
                           &Bcb,
                           &SdHeader2 );
            //
            //  Calculate its hash and length
            //  

            SecurityDescriptor = (PSECURITY_DESCRIPTOR) Add2Ptr( SdHeader2, sizeof( SECURITY_DESCRIPTOR_HEADER ) );

            ASSERT( SeValidSecurityDescriptor( SdHeader->Length - sizeof( SECURITY_DESCRIPTOR_HEADER ), SecurityDescriptor ));

            if (SeValidSecurityDescriptor( SdHeader->Length - sizeof( SECURITY_DESCRIPTOR_HEADER ) , SecurityDescriptor )) {
            
                SecurityDescriptorLength = RtlLengthSecurityDescriptor( SecurityDescriptor );
                NtfsUnpinBcb( IrpContext, &Bcb );

                //
                //  Read the raw security descriptor
                //  

                NtfsMapStream( IrpContext,
                               Vcb->SecurityDescriptorStream,
                               SdHeader->Offset,
                               SecurityDescriptorLength,
                               &Bcb,
                               &SdHeader2 );

                SecurityDescriptor = (PSECURITY_DESCRIPTOR) Add2Ptr( SdHeader2, sizeof( SECURITY_DESCRIPTOR_HEADER ) );


                {
                    PULONG Rover = (PULONG)SecurityDescriptor;
                    ULONG Count = SecurityDescriptorLength / 4;
                    Hash = 0;

                    while (Count--) {

                        Hash = ((Hash << 3) | (Hash >> (32-3))) + *Rover++;
                    }
                }

                ASSERT( Hash == SdHeader->HashKey.Hash );
                ASSERT( Hash == SdHeader2->HashKey.Hash );
                ASSERT( SdHeader2->Length == SdHeader->Length );
                ASSERT( SecurityDescriptorLength + sizeof( SECURITY_DESCRIPTOR_HEADER ) == SdHeader->Length );
            }

            NtfsUnpinBcb( IrpContext, &Bcb );

            //
            //  Find the next record
            //  

            Status = NtOfsReadRecords( IrpContext,
                                        IrpContext->Vcb->SecurityDescriptorHashIndex,
                                        &ReadContext,
                                        NULL,
                                        NtOfsMatchAll,
                                        NULL,
                                        &FoundCount,
                                        &FoundRow,
                                        sizeof( HashDescriptorHeader ),
                                        &HashDescriptorHeader[0]);
        }

    } finally {
        
        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }

        NtfsReleaseScb( IrpContext, IrpContext->Vcb->SecurityDescriptorHashIndex );
    }
}
#endif


//
//  Local Support routine
//

VOID
NtOfsLookupSecurityDescriptorInIndex (
    PIRP_CONTEXT IrpContext,
    IN OUT PSHARED_SECURITY SharedSecurity
    )

/*++

Routine Description:

    Look up the security descriptor in the index.  If found, return the
    security ID.

Arguments:

    IrpContext - context of the call

    SharedSecurity - shared security for a file

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    DebugTrace( +1, DbgAcl, ("NtOfsLookupSecurityDescriptorInIndex...\n") );

    //
    //  For each matching hash record in the index, see if the actual security
    //  security descriptor matches.
    //

    {
        INDEX_KEY IndexKey;
        INDEX_ROW FoundRow;
        PSECURITY_DESCRIPTOR_HEADER Header;
        UCHAR HashDescriptorHeader[2 * (sizeof( SECURITY_DESCRIPTOR_HEADER ) + sizeof( ULONG ))];

        PINDEX_KEY Key = &IndexKey;
        PREAD_CONTEXT ReadContext = NULL;
        ULONG FoundCount = 0;
        PBCB Bcb = NULL;

        IndexKey.KeyLength = sizeof( SharedSecurity->Header.HashKey );
        IndexKey.Key = &SharedSecurity->Header.HashKey.Hash;

        try {
            //
            //  We keep reading hash records until we find a hash.
            //

            while (SharedSecurity->Header.HashKey.SecurityId == SECURITY_ID_INVALID) {

                //
                //  Read next matching SecurityHashIndex record
                //

                FoundCount = 1;
                NtOfsReadRecords( IrpContext,
                                  IrpContext->Vcb->SecurityDescriptorHashIndex,
                                  &ReadContext,
                                  Key,
                                  NtOfsMatchSecurityHash,
                                  ULongToPtr( SharedSecurity->Header.HashKey.Hash ),
                                  &FoundCount,
                                  &FoundRow,
                                  sizeof( HashDescriptorHeader ),
                                  &HashDescriptorHeader[0]);

                //
                //  Set next read to read sequentially rather than explicitly
                //  seek.
                //

                Key = NULL;

                //
                //  If there were no more records found, then go and establish a
                //  a new security Id.
                //

                if (FoundCount == 0) {
                    break;
                }

                //
                //  Examine the row to see if the descriptors are
                //  the same.  Verify the cache contents.
                //

                ASSERT( FoundRow.DataPart.DataLength == sizeof( SECURITY_DESCRIPTOR_HEADER ) );
                if (FoundRow.DataPart.DataLength != sizeof( SECURITY_DESCRIPTOR_HEADER )) {
                    DebugTrace( 0, DbgAcl, ("Found row has a bad size\n") );
                    NtfsRaiseStatus( IrpContext,
                                     STATUS_DISK_CORRUPT_ERROR,
                                     NULL, NULL );
                }

                Header = (PSECURITY_DESCRIPTOR_HEADER)FoundRow.DataPart.Data;

                //
                //  If the length of the security descriptor in the stream is NOT
                //  the same as the current security descriptor, then a match is
                //  not possible
                //

                if (SharedSecurity->Header.Length != Header->Length) {
                    DebugTrace( 0, DbgAcl, ("Descriptor has wrong length\n") );
                    continue;
                }

                //
                //  Map security descriptor given descriptor stream position.
                //

                try {
                    PSECURITY_DESCRIPTOR_HEADER TestHeader;

                    NtfsMapStream( IrpContext,
                                   IrpContext->Vcb->SecurityDescriptorStream,
                                   Header->Offset,
                                   Header->Length,
                                   &Bcb,
                                   &TestHeader );

                    //
                    //  Make sure index data matches stream data
                    //

                    ASSERT( (TestHeader->HashKey.Hash == Header->HashKey.Hash) &&
                            (TestHeader->HashKey.SecurityId == Header->HashKey.SecurityId) &&
                            (TestHeader->Length == Header->Length) );

                    //
                    //  Compare byte-for-byte the security descriptors.  We do not
                    //  perform any rearranging of descriptors into canonical forms.
                    //

                    if (RtlEqualMemory( SharedSecurity->SecurityDescriptor,
                                        TestHeader + 1,
                                        GetSharedSecurityLength( SharedSecurity )) ) {
                        //
                        //  We have a match.  Save the found header
                        //

                        SharedSecurity->Header = *TestHeader;
                        DebugTrace( 0, DbgAcl, ("Reusing indexed security Id %x\n",
                                    TestHeader->HashKey.SecurityId) );
                        leave;
                    }

                    DebugTrace( 0, 0, ("Descriptors different in bits %x\n", TestHeader->HashKey.SecurityId));

                } finally {
                    NtfsUnpinBcb( IrpContext, &Bcb );
                }
            }

        } finally {
            if (ReadContext != NULL) {
                NtOfsFreeReadContext( ReadContext );
            }
        }
    }

    DebugTrace( -1, DbgAcl, ("NtOfsLookupSecurityDescriptorInIndex...Done\n") );

    return;
}


//
//  Local Support routine
//

SECURITY_ID
GetSecurityIdFromSecurityDescriptorUnsafe (
    PIRP_CONTEXT IrpContext,
    IN OUT PSHARED_SECURITY SharedSecurity
    )

/*++

Routine Description:

    Return the security Id associated with a given security descriptor. If
    there is an existing Id, return it.  If no Id exists, create one. This assumes
    security mutex is already acquired

Arguments:

    IrpContext - context of the call

    SharedSecurity - Shared security used by file

Return Value:

    SECURITY_ID corresponding to the unique instantiation of the security
            descriptor on the volume.

--*/

{
    SECURITY_ID SavedSecurityId;
    LONGLONG DescriptorOffset;
    LONGLONG PaddedDescriptorOffset;
    BOOLEAN IncrementedSecId = FALSE;
    PAGED_CODE( );

    DebugTrace( +1, DbgAcl, ("GetSecurityIdFromSecurityDescriptorUnsafe...\n") );

    //
    //  Drop the security mutex since we are going to acquire / extend the descriptor stream
    //  and the mutex is basically an end resource. Inc ref. count to keep
    //  shared security around
    //

    SharedSecurity->ReferenceCount += 1;
    NtfsReleaseFcbSecurity( IrpContext->Vcb );

    //
    //  Find descriptor in indexes/stream
    //

    try {

        //
        //  Make sure the data structures don't change underneath us
        //

        NtfsAcquireSharedScb( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );

        //
        //  Save next Security Id.  This is used if we fail to find the security
        //  descriptor in the descriptor stream.
        //

        SavedSecurityId = IrpContext->Vcb->NextSecurityId;

        NtOfsLookupSecurityDescriptorInIndex( IrpContext, SharedSecurity );

        //
        //  If we've found the security descriptor in the stream we're done.
        //

        if (SharedSecurity->Header.HashKey.SecurityId != SECURITY_ID_INVALID) {
            leave;
        }

        //
        //  The security descriptor is not found.  Reacquire the security
        //  stream exclusive since we are about to modify it.
        //

        NtfsReleaseScb( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );
        NtfsAcquireExclusiveScb( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );

        //
        //  During the short interval above, we did not own the security stream.
        //  It is possible that another thread has gotten in and created this
        //  descriptor.  Therefore, we must probe the indexes again.
        //
        //  Rather than perform this expensive test *always*, we saved the next
        //  security id to be allocated above.  Now that we've obtained the stream
        //  exclusive we can check to see if the saved one is the same as the next
        //  one.  If so, then we need to probe the indexes.  Otherwise
        //  we know that no modifications have taken place.
        //

        if (SavedSecurityId != IrpContext->Vcb->NextSecurityId) {
            DebugTrace( 0, DbgAcl, ("SecurityId changed, rescanning\n") );

            //
            //  The descriptor cache has been edited.  We must search again
            //

            NtOfsLookupSecurityDescriptorInIndex( IrpContext, SharedSecurity );

            //
            //  If the Id was found this time, simply return it
            //

            if (SharedSecurity->Header.HashKey.SecurityId != SECURITY_ID_INVALID) {
                leave;
            }
        }

        //
        //  Allocate security id.  This does not need to be logged since we only
        //  increment this and initialize this from the max key in the index at
        //  mount time.
        //

        SharedSecurity->Header.HashKey.SecurityId = IrpContext->Vcb->NextSecurityId++;
        IncrementedSecId = TRUE;

        //
        //  Determine allocation location in descriptor stream.  The alignment
        //  requirements for security descriptors within the stream are:
        //
        //      DWORD alignment
        //      Not spanning a VACB_MAPPING_GRANULARITY boundary
        //

        //
        //  Get current EOF for descriptor stream.  This includes the replicated
        //  region.  Remove the replicated region (& ~VACB_MAPPING_GRANULARITY)
        //

#if DBG
        {
            LONGLONG Tmp = NtOfsQueryLength( IrpContext->Vcb->SecurityDescriptorStream );
            ASSERT( Tmp == 0 || (Tmp & VACB_MAPPING_GRANULARITY) );
        }
#endif

        DescriptorOffset = NtOfsQueryLength( IrpContext->Vcb->SecurityDescriptorStream ) & ~VACB_MAPPING_GRANULARITY;

        //
        //  Align to 16 byte boundary.
        //

        PaddedDescriptorOffset =
        SharedSecurity->Header.Offset = BlockAlign( DescriptorOffset, 0x10 );

        DebugTrace( 0,
                    DbgAcl,
                    ("Allocating SecurityId %x at %016I64x\n",
                     SharedSecurity->Header.HashKey.SecurityId,
                     SharedSecurity->Header.Offset) );

        //
        //  Make sure we don't span a VACB_MAPPING_GRANULARITY boundary and
        //  have enough room for a completely-zero header.
        //  Compare space left in this vacb view with the space needed for the current
        //  record double quad word aligned + an empty header
        //

        if (VACB_MAPPING_GRANULARITY - (PaddedDescriptorOffset & (VACB_MAPPING_GRANULARITY - 1)) <
            BlockAlign( SharedSecurity->Header.Length, 0x10 ) + (ULONG)sizeof( SharedSecurity->Header )) {


            //
            //  We are about to span the mapping granularity of the cache manager
            //  so we want to place this into the next cache window.  However,
            //  the following window is where the replicated descriptors are
            //  stored.  We must advance to the window beyond that.
            //

            SharedSecurity->Header.Offset =

                //
                //  Round down to previous VACB_MAPPING GRANULARITY
                //

                (SharedSecurity->Header.Offset & ~(VACB_MAPPING_GRANULARITY - 1))

                //
                //  Move past this window and replicated window
                //

                + 2 * VACB_MAPPING_GRANULARITY;

            //
            //  The next descriptor offset is used for zeroing out the padding
            //

            PaddedDescriptorOffset = SharedSecurity->Header.Offset - VACB_MAPPING_GRANULARITY;
        }

        //
        //  Grow security stream to make room for new descriptor and header. This
        //  takes into account the replicated copy of the descriptor.
        //

        NtOfsSetLength( IrpContext,
                        IrpContext->Vcb->SecurityDescriptorStream,
                        (SharedSecurity->Header.Offset +
                         SharedSecurity->Header.Length +
                         VACB_MAPPING_GRANULARITY) );

        //
        //  Zero out any alignment padding since Chkdsk verifies the replication by
        //  doing 256K memcmp's.
        //

        NtOfsPutData( IrpContext,
                      IrpContext->Vcb->SecurityDescriptorStream,
                      DescriptorOffset + VACB_MAPPING_GRANULARITY,
                      (ULONG)(PaddedDescriptorOffset - DescriptorOffset),
                      NULL );

        NtOfsPutData( IrpContext,
                      IrpContext->Vcb->SecurityDescriptorStream,
                      DescriptorOffset,
                      (ULONG)(PaddedDescriptorOffset - DescriptorOffset),
                      NULL );

        //
        //  Put the new descriptor into the stream in both the "normal"
        //  place and in the replicated place.
        //

        NtOfsPutData( IrpContext,
                      IrpContext->Vcb->SecurityDescriptorStream,
                      SharedSecurity->Header.Offset,
                      SharedSecurity->Header.Length,
                      &SharedSecurity->Header );

        NtOfsPutData( IrpContext,
                      IrpContext->Vcb->SecurityDescriptorStream,
                      SharedSecurity->Header.Offset + VACB_MAPPING_GRANULARITY,
                      SharedSecurity->Header.Length,
                      &SharedSecurity->Header );

        //
        //  add id->data map
        //

        {
            INDEX_ROW Row;

            Row.KeyPart.KeyLength = sizeof( SharedSecurity->Header.HashKey.SecurityId );
            Row.KeyPart.Key = &SharedSecurity->Header.HashKey.SecurityId;

            Row.DataPart.DataLength = sizeof( SharedSecurity->Header );
            Row.DataPart.Data = &SharedSecurity->Header;

            NtOfsAddRecords( IrpContext,
                             IrpContext->Vcb->SecurityIdIndex,
                             1,
                             &Row,
                             FALSE );
        }

        //
        //  add hash|id->data map
        //

        {
            INDEX_ROW Row;

            Row.KeyPart.KeyLength =
                sizeof( SharedSecurity->Header.HashKey );
            Row.KeyPart.Key = &SharedSecurity->Header.HashKey;

            Row.DataPart.DataLength = sizeof( SharedSecurity->Header );
            Row.DataPart.Data = &SharedSecurity->Header;

            NtOfsAddRecords( IrpContext,
                             IrpContext->Vcb->SecurityDescriptorHashIndex,
                             1,
                             &Row,
                             FALSE );
        }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        NtfsVerifySecurity( IrpContext, IrpContext->Vcb );
#endif

    } finally {

        NtfsReleaseScb( IrpContext, IrpContext->Vcb->SecurityDescriptorStream );

        //
        //  Reacquire fcb security mutex and deref count
        //

        NtfsAcquireFcbSecurity( IrpContext->Vcb );
        SharedSecurity->ReferenceCount -= 1;

        if (IncrementedSecId && AbnormalTermination()) {
#ifdef BENL_DBG
            KdPrint(( "NTFS: incremented secid to %x and failing %x\n", IrpContext->Vcb->NextSecurityId, IrpContext->ExceptionStatus ));
#endif
        }
    }

    DebugTrace( -1,
                DbgAcl,
                ("GetSecurityIdFromSecurityDescriptorUnsafe returns %08x\n",
                 SharedSecurity->Header.HashKey.SecurityId) );

    return SharedSecurity->Header.HashKey.SecurityId;
}


VOID
NtfsStoreSecurityDescriptor (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN LogIt
    )

/*++

Routine Description:

    LEGACY NOTE - this routine disappears when all volumes become NT 5

    This routine stores a new security descriptor already stored in the fcb
    from memory onto the disk.

Arguments:

    Fcb - Supplies the fcb for the file being operated on

    LogIt - Supplies whether or not the creation of a new security descriptor
            should/ be logged or not.  Modifications are always logged.  This
            parameter must only be specified as FALSE for a file which is currently
            being created.

Return Value:

    None.

Note:
    This will dirty the standard information in the FCB but will not update it on
    disk.  The caller needs to bring these into sync.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

    ATTRIBUTE_ENUMERATION_CONTEXT StdInfoContext;
    BOOLEAN CleanupStdInfoContext = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsStoreSecurityDescriptor...\n") );

    ASSERT_EXCLUSIVE_FCB( Fcb );

    //
    //  Initialize the attribute and find the security attribute
    //

    NtfsInitializeAttributeContext( &AttributeContext );
    try {

        ASSERT( Fcb->Vcb->SecurityDescriptorStream == NULL);

        //
        //  Check if the attribute is first being modified or deleted, a null
        //  value means that we are deleting the security descriptor
        //

        if (Fcb->SharedSecurity == NULL) {

            DebugTrace( 0, Dbg, ("Security Descriptor is null\n") );

            //
            //  If it already doesn't exist then we're done, otherwise simply
            //  delete the attribute
            //

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $SECURITY_DESCRIPTOR,
                                           &AttributeContext )) {

                DebugTrace( 0, Dbg, ("Delete existing Security Descriptor\n") );

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &AttributeContext );
            }

            leave;
        }

        //
        //  At this point we are modifying the security descriptor so read in the
        //  security descriptor,  if it does not exist then we will need to create
        //  one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $SECURITY_DESCRIPTOR,
                                        &AttributeContext )) {

            DebugTrace( 0, Dbg, ("Create a new Security Descriptor\n") );

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            NtfsInitializeAttributeContext( &AttributeContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          $SECURITY_DESCRIPTOR,
                                          NULL,                          // attribute name
                                          &Fcb->SharedSecurity->SecurityDescriptor,
                                          GetSharedSecurityLength(Fcb->SharedSecurity),
                                          0,                             // attribute flags
                                          NULL,                          // where indexed
                                          LogIt,                         // logit
                                          &AttributeContext );

            //
            //  We may be modifying the security descriptor of an NT 5.0 volume.
            //  We want to store a SecurityID in the standard information field so
            //  that if we reboot on 5.0 NTFS will know where to find the most
            //  recent security descriptor.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {

                LARGE_STANDARD_INFORMATION StandardInformation;

                //
                //  Initialize the context structure.
                //

                NtfsInitializeAttributeContext( &StdInfoContext );
                CleanupStdInfoContext = TRUE;

                //
                //  Locate the standard information, it must be there.
                //

                if (!NtfsLookupAttributeByCode( IrpContext,
                                                Fcb,
                                                &Fcb->FileReference,
                                                $STANDARD_INFORMATION,
                                                &StdInfoContext )) {

                    DebugTrace( 0, Dbg, ("Can't find standard information\n") );

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }

                ASSERT( NtfsFoundAttribute( &StdInfoContext )->Form.Resident.ValueLength >= sizeof( LARGE_STANDARD_INFORMATION ));

                //
                //  Copy the existing standard information to our buffer.
                //

                RtlCopyMemory( &StandardInformation,
                               NtfsAttributeValue( NtfsFoundAttribute( &StdInfoContext )),
                               sizeof( LARGE_STANDARD_INFORMATION ));

                StandardInformation.SecurityId = SECURITY_ID_INVALID;
                StandardInformation.OwnerId = 0;

                //
                //  Call to change the attribute value.
                //

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          0,
                                          &StandardInformation,
                                          sizeof( LARGE_STANDARD_INFORMATION ),
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          &StdInfoContext );
            }

        } else {

            DebugTrace( 0, Dbg, ("Change an existing Security Descriptor\n") );

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      0,                                 // Value offset
                                      &Fcb->SharedSecurity->SecurityDescriptor,
                                      GetSharedSecurityLength( Fcb->SharedSecurity ),
                                      TRUE,                              // logit
                                      TRUE,
                                      FALSE,
                                      FALSE,
                                      &AttributeContext );
        }

    } finally {

        DebugUnwind( NtfsStoreSecurityDescriptor );

        //
        //  Cleanup our attribute enumeration context
        //

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

        if (CleanupStdInfoContext) {

            NtfsCleanupAttributeContext( IrpContext, &StdInfoContext );
        }

    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsStoreSecurityDescriptor -> VOID\n") );

    return;
}


PSHARED_SECURITY
NtfsCacheSharedSecurityForCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb
    )

/*++

Routine Description:

    This routine finds or constructs a security id and SHARED_SECURITY from
    a specific file or directory.

Arguments:

    IrpContext - Context of the call

    ParentFcb - Supplies the directory under which the new fcb exists

Return Value:

    Referenced shared security.

--*/

{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSHARED_SECURITY SharedSecurity;
    NTSTATUS Status;
    BOOLEAN IsDirectory;
    PACCESS_STATE AccessState;
    PIO_STACK_LOCATION IrpSp;
    ULONG SecurityDescLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( ParentFcb );

    PAGED_CODE();

    DebugTrace( +1, DbgAcl, ("NtfsCacheSharedSecurityForCreate...\n") );

    //
    //  First decide if we are creating a file or a directory
    //

    IrpSp = IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp);
    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

        IsDirectory = TRUE;

    } else {

        IsDirectory = FALSE;
    }

    //
    //  Extract the parts of the Irp that we need to do our assignment
    //

    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Check if we need to load the security descriptor for the parent.
    //

    if (ParentFcb->SharedSecurity == NULL) {

        NtfsLoadSecurityDescriptor( IrpContext, ParentFcb );
    }

    ASSERT( ParentFcb->SharedSecurity != NULL );

    //
    //  Create a new security descriptor for the file and raise if there is
    //  an error
    //

    if (!NT_SUCCESS( Status = SeAssignSecurity( &ParentFcb->SharedSecurity->SecurityDescriptor,
                                                AccessState->SecurityDescriptor,
                                                &SecurityDescriptor,
                                                IsDirectory,
                                                &AccessState->SubjectSecurityContext,
                                                IoGetFileObjectGenericMapping(),
                                                PagedPool ))) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

    }

    SecurityDescLength = RtlLengthSecurityDescriptor( SecurityDescriptor );

    ASSERT( SeValidSecurityDescriptor( SecurityDescLength, SecurityDescriptor ));

    try {

        //
        //  Make sure the length is non-zero.
        //

        if (SecurityDescLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );

        }

        //
        //  We have a security descriptor.  Create a shared security descriptor.
        //

        SharedSecurity = NtfsCacheSharedSecurityByDescriptor( IrpContext,
                                                              SecurityDescriptor,
                                                              SecurityDescLength,
                                                              TRUE );

    } finally {

        //
        //  Free the security descriptor created by Se
        //

        SeDeassignSecurity( &SecurityDescriptor );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, DbgAcl, ("NtfsCacheSharedSecurityForCreate -> VOID\n") );

    return SharedSecurity;
}


/*++

Routine Descriptions:

    Collation routines for security hash index.  Collation occurs by Hash first,
    then security Id

Arguments:

    Key1 - First key to compare.

    Key2 - Second key to compare.

    CollationData - Optional data to support the collation.

Return Value:

    LessThan, EqualTo, or Greater than, for how Key1 compares
    with Key2.

--*/

FSRTL_COMPARISON_RESULT
NtOfsCollateSecurityHash (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    PSECURITY_HASH_KEY HashKey1 = (PSECURITY_HASH_KEY) Key1->Key;
    PSECURITY_HASH_KEY HashKey2 = (PSECURITY_HASH_KEY) Key2->Key;

    UNREFERENCED_PARAMETER(CollationData);

    PAGED_CODE( );

    ASSERT( Key1->KeyLength == sizeof( SECURITY_HASH_KEY ) );
    ASSERT( Key2->KeyLength == sizeof( SECURITY_HASH_KEY ) );

    if (HashKey1->Hash < HashKey2->Hash) {
        return LessThan;
    } else if (HashKey1->Hash > HashKey2->Hash) {
        return GreaterThan;
    } else if (HashKey1->SecurityId < HashKey2->SecurityId) {
        return LessThan;
    } else if (HashKey1->SecurityId > HashKey2->SecurityId) {
        return GreaterThan;
    } else {
        return EqualTo;
    }
}


BOOLEAN
NtfsCanAdministerVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PSECURITY_DESCRIPTOR TestSecurityDescriptor OPTIONAL,
    IN PULONG TestDesiredAccess OPTIONAL
    )

/*++

Routine Descriptions:

    For volume open irps test if the user has enough access to administer the volume
    This means retesting the original requested access

Arguments:

    Irp - The create irp

    Fcb - The fcb to be tested - this should always be the volumedasd fcb

    TestSecurityDescriptor - If specified then use then apply this descriptor for the
        test.

    TestDesiredAccess - If specified then this is the access to apply.

Return Value:

    TRUE  if the user can administer the volume

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN ManageAccessGranted;
    ULONG ManageDesiredAccess;
    ULONG ManageGrantedAccess;
    NTSTATUS ManageAccessStatus;
    PPRIVILEGE_SET Privileges = NULL;
    PACCESS_STATE AccessState;
    KPROCESSOR_MODE EffectiveMode;

    PAGED_CODE();

    ASSERT( IrpContext->MajorFunction == IRP_MJ_CREATE );
    ASSERT( Fcb == Fcb->Vcb->VolumeDasdScb->Fcb );

    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;
    ManageDesiredAccess = AccessState->OriginalDesiredAccess;

    if (ARGUMENT_PRESENT( TestDesiredAccess )) {

        ManageDesiredAccess = *TestDesiredAccess;
    }

    //
    //  SL_FORCE_ACCESS_CHECK causes us to use an effective RequestorMode
    //  of UserMode.
    //

    EffectiveMode = NtfsEffectiveMode( Irp, IrpSp );

    //
    //  Lock the user context, do the access check and then unlock the context
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    try {

        ManageAccessGranted = SeAccessCheck( (ARGUMENT_PRESENT( TestSecurityDescriptor ) ?
                                              TestSecurityDescriptor :
                                              &Fcb->SharedSecurity->SecurityDescriptor),
                                             &AccessState->SubjectSecurityContext,
                                             TRUE,                           // Tokens are locked
                                             ManageDesiredAccess,
                                             0,
                                             &Privileges,
                                             IoGetFileObjectGenericMapping(),
                                             EffectiveMode,
                                             &ManageGrantedAccess,
                                             &ManageAccessStatus );
    } finally {

        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
    }


    if (Privileges != NULL) {
        SeFreePrivileges( Privileges );
    }

    return ManageAccessGranted;

    UNREFERENCED_PARAMETER( IrpContext );
}

#ifdef NTFS_CACHE_RIGHTS

VOID
NtfsGetCachedRightsById (
    IN PVCB Vcb,
    IN PLUID TokenId,
    IN PLUID ModifiedId,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PSHARED_SECURITY SharedSecurity,
    OUT PBOOLEAN EntryCached OPTIONAL,
    OUT PACCESS_MASK Rights
    )

/*++

Routine Descriptions:

    This call returns the access rights held by the effective
    ACCESS_TOKEN for the given security information, if available.

Arguments:

    Vcb - Volume where security Id is cached

    TokenId - The effective token's id.

    ModifiedId - The effective token's modification id.

    SubjectSecurityContext - A pointer to the subject's captured and locked
        security context

    SharedSecurity - Shared security used by file

    EntryCached - If the token-specific rights are cached at all, TRUE is
        optionally returned here, otherwise FALSE is returned.

    Rights - The access rights are returned here.  If an entry is not found
        in the cache for the effective token, only the world rights are
        returned.

Return Value:

    None.

--*/

{
    UCHAR Index;
    BOOLEAN AccessGranted;
    BOOLEAN LockHeld = FALSE;
    BOOLEAN IsCached = FALSE;
    NTSTATUS AccessStatus = STATUS_UNSUCCESSFUL;
    ACCESS_MASK GrantedAccess;
    PCACHED_ACCESS_RIGHTS CachedRights;

    PAGED_CODE( );

    NtfsAcquireFcbSecurity( Vcb );
    LockHeld = TRUE;

    try {

        CachedRights = &SharedSecurity->CachedRights;

        *Rights = CachedRights->EveryoneRights;

        //
        //  Search the list for the given TokenId.
        //  It is assumed that a specific TokenId will only appear
        //  once in the cache.
        //

        for (Index = 0;
             Index < CachedRights->Count;
             Index += 1) {

            //
            //  Check for a match on TokenId and ModifiedId.
            //

            if (RtlEqualLuid( &CachedRights->TokenRights[Index].TokenId,
                              TokenId )) {

                if (RtlEqualLuid( &CachedRights->TokenRights[Index].ModifiedId,
                                  ModifiedId )) {

                    //
                    //  We have a match.
                    //

                    SetFlag( *Rights, CachedRights->TokenRights[Index].Rights );
                    IsCached = TRUE;
                }
                break;
            }
        }

        //
        //  If the entry is not cached, get the maximum rights.
        //  Note that it is assumed that this call will not return
        //  rights that require privileges, even if they are currently
        //  enabled.  This is the behavior when only MAXIMUM_ALLOWED
        //  is requested.
        //

        if (!IsCached) {

            //
            //  Drop our lock across this call.
            //

            NtfsReleaseFcbSecurity( Vcb );
            LockHeld = FALSE;

            AccessGranted = SeAccessCheck( &SharedSecurity->SecurityDescriptor,
                                           SubjectSecurityContext,
                                           TRUE,                           // Tokens are locked
                                           MAXIMUM_ALLOWED,
                                           0,
                                           NULL,
                                           IoGetFileObjectGenericMapping(),
                                           UserMode,
                                           &GrantedAccess,
                                           &AccessStatus );


            if (AccessGranted) {

                //
                //  Update the cached knowledge about rights that this
                //  caller is known to have for this security descriptor.
                //

                NtfsAddCachedRights( Vcb,
                                     SharedSecurity,
                                     GrantedAccess,
                                     TokenId,
                                     ModifiedId );

                IsCached = TRUE;
            }
        }

    } finally {

        if (LockHeld) {

            NtfsReleaseFcbSecurity( Vcb );
        }
    }

    if (ARGUMENT_PRESENT( EntryCached )) {

        *EntryCached = IsCached;
    }

    return;
}


NTSTATUS
NtfsGetCachedRights (
    IN PVCB Vcb,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PSHARED_SECURITY SharedSecurity,
    OUT PACCESS_MASK Rights,
    OUT PBOOLEAN EntryCached OPTIONAL,
    OUT PLUID TokenId OPTIONAL,
    OUT PLUID ModifiedId OPTIONAL
    )

/*++

Routine Descriptions:

    This call returns the access rights known to be held by the effective
    ACCESS_TOKEN for the given security information.  It is assumed that
    the subject context is locked.

Arguments:

    Vcb - Volume where security Id is cached

    SubjectSecurityContext - A pointer to the subject's captured and locked
        security context

    SharedSecurity - Shared security used by file

    Rights - The access rights are returned here.  If an entry is not found
        in the cache for the effective token, only the world rights are
        returned.

    EntryCached - If the token-specific rights are cached at all, TRUE is
        optionally returned here, otherwise FALSE is returned.

    TokenId - The effective token's id is optionally returned here.

    ModifiedId - The effective token's modification id is optionally
        returned here.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS if and only if we have obtained at
        least the TokenId and ModifiedId information.

--*/

{
    NTSTATUS Status;
    PACCESS_TOKEN EToken;
    PTOKEN_STATISTICS Info = NULL;

    PAGED_CODE( );

    DebugTrace( +1, Dbg, ("NtfsGetCachedRights...\n") );

    //
    //  First obtain the effective token's id and modification id.
    //

    EToken = SeQuerySubjectContextToken( SubjectSecurityContext );
    Status = SeQueryInformationToken( EToken, TokenStatistics, &Info );

    //
    //  If we have the TokenId and ModifiedId, get the cached rights.
    //

    if (Status == STATUS_SUCCESS) {

        NtfsGetCachedRightsById( Vcb,
                                 &Info->TokenId,
                                 &Info->ModifiedId,
                                 SubjectSecurityContext,
                                 SharedSecurity,
                                 EntryCached,
                                 Rights );

        //
        //  Return the Tokenid and ModifiedId to the caller.
        //

        if (ARGUMENT_PRESENT( TokenId )) {

            RtlCopyLuid( TokenId, &Info->TokenId );
        }

        if (ARGUMENT_PRESENT( ModifiedId )) {

            RtlCopyLuid( ModifiedId, &Info->ModifiedId );
        }

    } else {

        //
        //  Just return the rights everyone is known to have.
        //

        *Rights = SharedSecurity->CachedRights.EveryoneRights;

        if (ARGUMENT_PRESENT( EntryCached )) {

            *EntryCached = FALSE;
        }
    }

    if (Info != NULL) {

        ExFreePool( Info );
    }

    DebugTrace( -1, Dbg, ("NtfsGetCachedRights -> %08lx, Rights=%08lx\n", Status, *Rights) );
    return Status;
}


VOID
NtfsAddCachedRights (
    IN PVCB Vcb,
    IN PSHARED_SECURITY SharedSecurity,
    IN ACCESS_MASK Rights,
    IN PLUID TokenId,
    IN PLUID ModifiedId
    )

/*++

Routine Descriptions:

    This call caches the access rights held by the effective ACCESS_TOKEN
    for the given security information.  It is assumed that the subject
    context is locked.

Arguments:

    Vcb - Volume where security Id is cached

    SharedSecurity - Shared security used by file

    Rights - The access rights.

    TokenId - The effective token's id.

    ModifiedId - The effective token's modification id.

Return Value:

    None.

--*/

{
    BOOLEAN GetEveryoneRights = FALSE;
    UCHAR Index;
    PCACHED_ACCESS_RIGHTS CachedRights;

    PAGED_CODE( );

    DebugTrace( +1, Dbg, ("NtfsAddCachedRights...\n") );

    //
    //  Make certain that MAXIMUM_ALLOWED is not in the rights.
    //

    ClearFlag( Rights, MAXIMUM_ALLOWED );

    //
    //  Acquire the security mutex
    //

    NtfsAcquireFcbSecurity( Vcb );

    try {

        //
        //  Search the list for the given TokenId.
        //  It is assumed that a specific TokenId will only appear
        //  once in the cache.
        //

        for (Index = 0, CachedRights = &SharedSecurity->CachedRights;
             Index < CachedRights->Count;
             Index += 1) {

            //
            //  Check for a match on TokenId and ModifiedId.
            //

            if (RtlEqualLuid( &CachedRights->TokenRights[Index].TokenId,
                              TokenId )) {

                //
                //  Replace ModifiedId if it doesn't match.  That will
                //  happen when the token's enabled groups or privileges
                //  have changed since the last time we cached information
                //  for it.
                //

                if (!RtlEqualLuid( &CachedRights->TokenRights[Index].ModifiedId,
                                   ModifiedId )) {

                    RtlCopyLuid( &CachedRights->TokenRights[Index].ModifiedId,
                                 ModifiedId );
                }

                //
                //  We have a match.  Set the rights.
                //

                CachedRights->TokenRights[Index].Rights = Rights;

                //
                //  Remember the next entry to use.
                //

                CachedRights->NextInsert = Index + 1;
                break;
            }
        }

        //
        //  If the entry was not found above, add the new entry into the cache.
        //

        if (Index == CachedRights->Count) {

            if ((CachedRights->Count >= 1) &&
                !CachedRights->HaveEveryoneRights) {

                //
                //  Once we add the second TokenId to the cache, we have a
                //  good indicator that having the world rights could be
                //  useful.
                //

                GetEveryoneRights = TRUE;

                //
                //  Set the indicator that we have the rights now so that
                //  there is no need in the acquisition routine to acquire
                //  the security mutex.  This will prevent multiple threads
                //  from attempting to acquire the everyone rights.
                //
                //  Note that until we actually acquire the rights information
                //  caller will assume that the rights are 0 and go through
                //  the normal per-token access check path.
                //

                CachedRights->HaveEveryoneRights = TRUE;
            }

            Index = CachedRights->NextInsert;

            //
            //  We will just replace the first entry in the list.
            //

            if (Index == NTFS_MAX_CACHED_RIGHTS) {

                Index = 0;
            }

            ASSERT( Index < NTFS_MAX_CACHED_RIGHTS );

            //
            //  Copy in the information.
            //

            CachedRights->TokenRights[Index].Rights = Rights;
            RtlCopyLuid( &CachedRights->TokenRights[Index].TokenId,
                         TokenId );
            RtlCopyLuid( &CachedRights->TokenRights[Index].ModifiedId,
                         ModifiedId );

            if (Index == CachedRights->Count) {

                //
                //  Bump the count of entries.
                //

                CachedRights->Count += 1;
            }

            //
            //  Remember the next entry to use.
            //

            CachedRights->NextInsert = Index + 1;
        }

    } finally {

        NtfsReleaseFcbSecurity( Vcb );
    }

    if (GetEveryoneRights) {

        NtfsSetCachedRightsWorld( SharedSecurity );
    }

    DebugTrace( -1, Dbg, ("NtfsAddCachedRights -> VOID\n") );
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\restrsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RestrSup.c

Abstract:

    This module implements the Ntfs routine to perform Restart on an
    Ntfs volume, i.e., to restore a consistent state to the volume that
    existed before the last failure.

Author:

    Tom Miller      [TomM]          24-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  ****    This is a way to disable a restart to get a volume going "as-is".
//

BOOLEAN NtfsDisableRestart = FALSE;

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOGSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('RFtN')

//
//  Size for initial in memory dirty page table
//

#define INITIAL_NUMBER_DIRTY_PAGES 32

//
//  The following macro returns the length of the log record header of
//  of log record.
//
//
//  ULONG
//  NtfsLogRecordHeaderLength (
//      IN PIRP_CONTEXT IrpContext,
//      IN PNTFS_LOG_RECORD_HEADER LogRecord
//      );
//

#define NtfsLogRecordHeaderLength( IC, LR )                     \
    (sizeof( NTFS_LOG_RECORD_HEADER )                           \
     + (((PNTFS_LOG_RECORD_HEADER) (LR))->LcnsToFollow > 1      \
        ? (((PNTFS_LOG_RECORD_HEADER) (LR))->LcnsToFollow - 1)  \
          * sizeof( LCN )                                       \
        : 0 ))

//
//
//  Local procedure prototypes
//

VOID
InitializeRestartState (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PRESTART_POINTERS DirtyPageTable,
    OUT PATTRIBUTE_NAME_ENTRY *AttributeNames,
    OUT PLSN CheckpointLsn,
    OUT PBOOLEAN UnrecognizedRestart
    );

VOID
ReleaseRestartState (
    IN PVCB Vcb,
    IN PRESTART_POINTERS DirtyPageTable,
    IN PATTRIBUTE_NAME_ENTRY AttributeNames,
    IN BOOLEAN ReleaseVcbTables
    );

VOID
AnalysisPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LSN CheckpointLsn,
    IN OUT PRESTART_POINTERS DirtyPageTable,
    OUT PLSN RedoLsn
    );

VOID
RedoPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LSN RedoLsn,
    IN OUT PRESTART_POINTERS DirtyPageTable
    );

VOID
UndoPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
DoAction (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN NTFS_LOG_OPERATION Operation,
    IN PVOID Data,
    IN ULONG Length,
    IN ULONG LogRecordLength,
    IN PLSN RedoLsn OPTIONAL,
    IN PSCB Scb OPTIONAL,
    OUT PBCB *Bcb,
    OUT PLSN *PageLsn
    );

VOID
PinMftRecordForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord
    );

VOID
OpenAttributeForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN OUT PSCB *Scb
    );

VOID
PinAttributeForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN ULONG Length OPTIONAL,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN OUT PSCB *Scb
    );

BOOLEAN
FindDirtyPage (
    IN PRESTART_POINTERS DirtyPageTable,
    IN ULONG TargetAttribute,
    IN VCN Vcn,
    OUT PDIRTY_PAGE_ENTRY *DirtyPageEntry
    );

VOID
PageUpdateAnalysis (
    IN PVCB Vcb,
    IN LSN Lsn,
    IN OUT PRESTART_POINTERS DirtyPageTable,
    IN PNTFS_LOG_RECORD_HEADER LogRecord
    );

VOID
OpenAttributesForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PRESTART_POINTERS DirtyPageTable
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AnalysisPass)
#pragma alloc_text(PAGE, DoAction)
#pragma alloc_text(PAGE, FindDirtyPage)
#pragma alloc_text(PAGE, InitializeRestartState)
#pragma alloc_text(PAGE, NtfsAbortTransaction)
#pragma alloc_text(PAGE, NtfsCloseAttributesFromRestart)
#pragma alloc_text(PAGE, NtfsRestartVolume)
#pragma alloc_text(PAGE, OpenAttributeForRestart)
#pragma alloc_text(PAGE, OpenAttributesForRestart)
#pragma alloc_text(PAGE, PageUpdateAnalysis)
#pragma alloc_text(PAGE, PinAttributeForRestart)
#pragma alloc_text(PAGE, PinMftRecordForRestart)
#pragma alloc_text(PAGE, RedoPass)
#pragma alloc_text(PAGE, ReleaseRestartState)
#pragma alloc_text(PAGE, UndoPass)
#endif


BOOLEAN
NtfsRestartVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PBOOLEAN UnrecognizedRestart
    )

/*++

Routine Description:

    This routine is called by the mount process after the log file has been
    started, to restart the volume.  Restarting the volume means restoring
    it to a consistent state as of the last request which was successfully
    completed and written to the log for this volume.

    The Restart process is a standard recovery from the Log File in three
    passes: Analysis Pass, Redo Pass and Undo pass.  Each one of these passes
    is implemented in a separate routine in this module.

Arguments:

    Vcb - Vcb for the volume which is to be restarted.

    UnrecognizedRestart - Indicates that this version of Ntfs doesn't recognize the
        restart area.  Chkdsk should run to repair the disk.

Return Value:

    FALSE - if no updates were applied during restart
    TRUE - if updates were applied

--*/

{
    RESTART_POINTERS DirtyPageTable;
    LSN CheckpointLsn;
    LSN RedoLsn;
    PATTRIBUTE_NAME_ENTRY AttributeNames = NULL;
    BOOLEAN UpdatesApplied = FALSE;
    BOOLEAN ReleaseVcbTables = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartVolume:\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );

#ifdef SYSCACHE
    DebugTrace( 0, Dbg, ("Syscache test build\n") );
#endif


    RtlZeroMemory( &DirtyPageTable, sizeof(RESTART_POINTERS) );

    //
    //  Use try-finally to insure cleanup on the way out.
    //

    try {

        //
        //  First we initialize the Open Attribute Table, Transaction Table,
        //  and Dirty Page Table from our last Checkpoint (as found from our
        //  Restart Area) in the log.
        //

        InitializeRestartState( IrpContext,
                                Vcb,
                                &DirtyPageTable,
                                &AttributeNames,
                                &CheckpointLsn,
                                UnrecognizedRestart );

        ReleaseVcbTables = TRUE;

        //
        //  If the CheckpointLsn is zero, then this is a freshly formattted
        //  disk and we have no work to do.
        //

        if (CheckpointLsn.QuadPart == 0) {

            LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );
            try_return(NOTHING);
        }

#ifdef BENL_DBG
        {
            PRESTART_LOG RedoLog;

            RedoLog = (PRESTART_LOG) NtfsAllocatePoolNoRaise( NonPagedPool, sizeof( RESTART_LOG ) );
            if (RedoLog) {
                RedoLog->Lsn = CheckpointLsn;
                InsertTailList( &(Vcb->RestartRedoHead), &(RedoLog->Links) );
            } else {
                KdPrint(( "NTFS: Out of memory during restart1\n" ));
            }
        }
#endif


        //
        //  Start the analysis pass from the Checkpoint Lsn.  This pass potentially
        //  updates all of the tables, and returns the RedoLsn, which is the Lsn
        //  at which the Redo Pass is to begin.
        //

        if (!NtfsDisableRestart &&
            !FlagOn( Vcb->VcbState, VCB_STATE_BAD_RESTART )) {
            AnalysisPass( IrpContext, Vcb, CheckpointLsn, &DirtyPageTable, &RedoLsn );
        }

        //
        //  Only proceed if the the Dirty Page Table or Transaction table are
        //  not empty.
        //
        //  REM: Once we implement the new USN journal restart optimization, this
        //  won't be a simple !empty test.
        //

        if (!IsRestartTableEmpty(&DirtyPageTable)

                ||

            !IsRestartTableEmpty(&Vcb->TransactionTable)) {

            //
            //  If the user wants to mount this readonly, we can't go on.
            //

            if (NtfsIsVolumeReadOnly( Vcb )) {

                LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );
                NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
            }

            UpdatesApplied = TRUE;

            //
            //  Before starting the Redo Pass, we have to reopen all of the
            //  attributes with dirty pages, and preinitialize their Mcbs with the
            //  mapping information from the Dirty Page Table.
            //

            OpenAttributesForRestart( IrpContext, Vcb, &DirtyPageTable );

            //
            //  Perform the Redo Pass, to restore all of the dirty pages to the same
            //  contents that they had immediately before the crash.
            //

            RedoPass( IrpContext, Vcb, RedoLsn, &DirtyPageTable );

            //
            //  Finally, perform the Undo Pass to undo any updates which may exist
            //  for transactions which did not complete.
            //

            UndoPass( IrpContext, Vcb );

        } else {

            //
            //  We know that there's no restart work left to do.
            //  Hence, if the user has requested a readonly mount, go ahead.
            //

            if (NtfsIsVolumeReadOnly( Vcb )) {

                //
                //  REM: Make sure the USN journal is clean too.
                //

                //
                //  Make sure that the pagingfile isn't on this volume?

            }

        }

        //
        //  Now that we know that there is no one to abort, we can initialize our
        //  Undo requirements, to our standard starting point to include the size
        //  of our Restart Area (for a clean checkpoint) + a page, which is the
        //  worst case loss when flushing the volume causes Lfs to flush to Lsn.
        //

        LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );

    //
    //  If we got an exception, we can at least clean up on the way out.
    //

    try_exit: NOTHING;

    } finally {

        DebugUnwind( NtfsRestartVolume );

        //
        //  Free up any resources tied down with the Restart State.
        //

        ReleaseRestartState( Vcb,
                             &DirtyPageTable,
                             AttributeNames,
                             ReleaseVcbTables );
    }

    DebugTrace( -1, Dbg, ("NtfsRestartVolume -> %02lx\n", UpdatesApplied) );

    return UpdatesApplied;
}


VOID
NtfsAbortTransaction (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PTRANSACTION_ENTRY Transaction OPTIONAL
    )

/*++

Routine Description:

    This routine aborts a transaction by undoing all of its actions.

    The Undo actions are all performed in the common routine DoAction,
    which is also used by the Redo Pass.

Arguments:

    Vcb - Vcb for the Volume.  NOTE - This argument is not guaranteed to
          be valid if Transaction is NULL and there is no Transaction ID
          in the IrpContext.

    Transaction - Pointer to the transaction entry of the transaction to be
                  aborted, or NULL to abort current transaction (if there is
                  one).

Return Value:

    None.

--*/

{
    LFS_LOG_CONTEXT LogContext;
    PNTFS_LOG_RECORD_HEADER LogRecord;
    ULONG LogRecordLength;
    PVOID Data;
    LONG Length;
    LSN LogRecordLsn;
    LSN UndoRecordLsn;
    LFS_RECORD_TYPE RecordType;
    TRANSACTION_ID TransactionId;
    LSN UndoNextLsn;
    LSN PreviousLsn;
    TRANSACTION_ID SavedTransaction = IrpContext->TransactionId;

    DebugTrace( +1, Dbg, ("NtfsAbortTransaction:\n") );

    //
    //  If a transaction was specified, then we have to set our transaction Id
    //  into the IrpContext (it was saved above), since NtfsWriteLog requires
    //  it.
    //

    if (ARGUMENT_PRESENT(Transaction)) {

        IrpContext->TransactionId = GetIndexFromRestartEntry( &Vcb->TransactionTable,
                                                              Transaction );

        UndoNextLsn = Transaction->UndoNextLsn;

        //
        //  Set the flag in the IrpContext so we will always write the commit
        //  record.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG );

    //
    //  Otherwise, we are aborting the current transaction, and we must get the
    //  pointer to its transaction entry.
    //

    } else {

        if (IrpContext->TransactionId == 0) {

            DebugTrace( -1, Dbg, ("NtfsAbortTransaction->VOID (no transaction)\n") );

            return;
        }

        //
        //  Synchronize access to the transaction table in case the table
        //  is growing.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                          TRUE );

        Transaction = GetRestartEntryFromIndex( &Vcb->TransactionTable,
                                                IrpContext->TransactionId );

        UndoNextLsn = Transaction->UndoNextLsn;

        NtfsReleaseRestartTable( &Vcb->TransactionTable );
    }

    ASSERT( !NtfsIsVolumeReadOnly( Vcb ) );

    //
    //  If we are aborting the current transaction (by default or explicit
    //  request), then restore 0 on return because he will be gone.
    //

    if (IrpContext->TransactionId == SavedTransaction) {

        SavedTransaction = 0;
    }

    DebugTrace( 0, Dbg, ("Transaction = %08lx\n", Transaction) );

    //
    //  We only have to do anything if the transaction has something in its
    //  UndoNextLsn field.
    //

    if (UndoNextLsn.QuadPart != 0) {

        PBCB PageBcb = NULL;

        //
        //  Read the first record to be undone by this transaction.
        //

        LfsReadLogRecord( Vcb->LogHandle,
                          UndoNextLsn,
                          LfsContextUndoNext,
                          &LogContext,
                          &RecordType,
                          &TransactionId,
                          &UndoNextLsn,
                          &PreviousLsn,
                          &LogRecordLength,
                          (PVOID *)&LogRecord );

        //
        //  Now loop to read all of our log records forwards, until we hit
        //  the end of the file, cleaning up at the end.
        //

        try {

            do {

                PLSN PageLsn;

                //
                //  Check that the log record is valid.
                //

                if (!NtfsCheckLogRecord( LogRecord,
                                         LogRecordLength,
                                         TransactionId,
                                         Vcb->OatEntrySize )) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                DebugTrace( 0, Dbg, ("Undo of Log Record at: %08lx\n", LogRecord) );
                DebugTrace( 0, Dbg, ("Log Record Lsn = %016I64x\n", LogRecordLsn) );

                //
                //  Log the Undo operation as a CLR, i.e., it has no undo,
                //  and the UndoNext points to the UndoNext of the current
                //  log record.
                //
                //  Don't do this if the undo is a noop.  This is not only
                //  efficient, but in the case of a clean shutdown, there
                //  will be no Scb to pick up from the table below.
                //

                if (LogRecord->UndoOperation != Noop) {

                    ULONG i;
                    PSCB Scb;

                    VCN Vcn;
                    LONGLONG Size;

                    //
                    //  Acquire and release the restart table.  We must synchronize
                    //  even though our entry can't be removed because the table
                    //  could be growing (or shrinking) and the table pointer
                    //  could be changing.
                    //

                    NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable,
                                                      TRUE );

                    //
                    //  We are getting the attribute index from a log record on disk.  We
                    //  may have to go through the on-disk Oat.
                    //

                    if (Vcb->RestartVersion == 0) {

                        ULONG InMemoryIndex;

                        //
                        //  Go through the on-disk Oat.
                        //

                        InMemoryIndex = ((POPEN_ATTRIBUTE_ENTRY_V0) GetRestartEntryFromIndex( Vcb->OnDiskOat,
                                                                                              LogRecord->TargetAttribute ))->OatIndex;

                        ASSERT( InMemoryIndex != 0 );

                        Scb = ((POPEN_ATTRIBUTE_ENTRY) GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                                                 InMemoryIndex ))->OatData->Overlay.Scb;

                    } else {

                        ASSERT( Vcb->RestartVersion == 1 );
                        ASSERT( LogRecord->TargetAttribute != 0 );

                        Scb = ((POPEN_ATTRIBUTE_ENTRY)GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                                                LogRecord->TargetAttribute))->OatData->Overlay.Scb;


                    }
                    NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );

                    //
                    //  If we have Lcn's to process and restart is in progress,
                    //  then we need to check if this is part of a partial page.
                    //

                    if (FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                        (LogRecord->LcnsToFollow != 0)) {

                        LCN TargetLcn;
                        LONGLONG SectorCount, SectorsInRun;
                        BOOLEAN MappingInMcb;

                        //
                        //  If the mapping isn't already in the table or the
                        //  mapping corresponds to a hole in the mapping, we
                        //  need to make sure there is no partial page already
                        //  in memory.
                        //

                        if (!(MappingInMcb = NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                                                     LogRecord->TargetVcn,
                                                                     &TargetLcn,
                                                                     &SectorCount,
                                                                     NULL,
                                                                     &SectorsInRun,
                                                                     NULL,
                                                                     NULL )) ||
                            (TargetLcn == UNUSED_LCN) ||
                            ((ULONG)SectorCount) < LogRecord->LcnsToFollow) {

                            VCN StartingPageVcn;
                            ULONG ClusterOffset;
                            BOOLEAN FlushAndPurge;

                            FlushAndPurge = FALSE;

                            //
                            //  Remember the Vcn at the start of the containing
                            //  page.
                            //

                            ClusterOffset = ((ULONG)LogRecord->TargetVcn) & (Vcb->ClustersPerPage - 1);

                            StartingPageVcn = BlockAlignTruncate( LogRecord->TargetVcn, (LONG)Vcb->ClustersPerPage );

                            //
                            //  If this mapping was not in the Mcb, then if the
                            //  Mcb is empty or the last entry is not in this page
                            //  then there is nothing to do.
                            //

                            if (!MappingInMcb) {

                                LCN LastLcn;
                                VCN LastVcn;

                                if ((ClusterOffset != 0) &&
                                    NtfsLookupLastNtfsMcbEntry( &Scb->Mcb,
                                                                &LastVcn,
                                                                &LastLcn ) &&
                                    (LastVcn >= StartingPageVcn)) {

                                    FlushAndPurge = TRUE;
                                }

                            //
                            //  If the mapping showed a hole, then the entire
                            //  page needs to be a hole.  We know that this mapping
                            //  can't be the last mapping on the page.  We just
                            //  need to starting point and the number of clusters
                            //  required for the run.
                            //

                            } else if (TargetLcn == UNUSED_LCN) {

                                if (((ClusterOffset + (ULONG) SectorCount) < Vcb->ClustersPerPage) ||
                                    ((ClusterOffset + (ULONG) SectorCount) > (ULONG) SectorsInRun)) {

                                    FlushAndPurge = TRUE;
                                }

                            //
                            //  In the rare case where we are extending an existing mapping
                            //  let's flush and purge.
                            //

                            } else {

                                FlushAndPurge = TRUE;
                            }

                            if (FlushAndPurge) {

                                LONGLONG StartingOffset;
                                IO_STATUS_BLOCK Iosb;

                                StartingOffset = LlBytesFromClusters( Vcb, StartingPageVcn );
                                StartingOffset += BytesFromLogBlocks( LogRecord->ClusterBlockOffset );

                                CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                                              (PLARGE_INTEGER)&StartingOffset,
                                              PAGE_SIZE,
                                              &Iosb );

                                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                                    &Iosb.Status,
                                                                    TRUE,
                                                                    STATUS_UNEXPECTED_IO_ERROR );

                                if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                          (PLARGE_INTEGER)&StartingOffset,
                                                          PAGE_SIZE,
                                                          FALSE )) {

                                    KdPrint(("NtfsUndoPass:  Unable to purge page\n"));

                                    NtfsRaiseStatus( IrpContext, STATUS_INTERNAL_ERROR, NULL, NULL );
                                }
                            }
                        }
                    }

                    //
                    //  Loop to add the allocated Vcns.  Note that the page
                    //  may not have been dirty, which means we may not have
                    //  added the run information in the Redo Pass, so we
                    //  add it here.
                    //

                    for (i = 0, Vcn = LogRecord->TargetVcn, Size = LlBytesFromClusters( Vcb, Vcn + 1 );
                         i < (ULONG)LogRecord->LcnsToFollow;
                         i++, Vcn = Vcn + 1, Size = Size + Vcb->BytesPerCluster ) {

                        //
                        //  Add this run to the Mcb if the Vcn has not been deleted,
                        //  and it is not for the fixed part of the Mft.
                        //

                        if ((LogRecord->LcnsForPage[i] != 0)

                                &&

                            (NtfsSegmentNumber( &Scb->Fcb->FileReference ) > MASTER_FILE_TABLE2_NUMBER ||
                             (Size >= ((VOLUME_DASD_NUMBER + 1) * Vcb->BytesPerFileRecordSegment)) ||
                             (Scb->AttributeTypeCode != $DATA))) {

                            //
                            //  We test here if we are performing restart.  In that case
                            //  we need to test if the Lcn's are already in the Mcb.
                            //  If not, then we want to flush and purge the page in
                            //  case we have zeroed any half pages.
                            //

                            while (!NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                                         Vcn,
                                                         LogRecord->LcnsForPage[i],
                                                         (LONGLONG)1,
                                                         FALSE )) {

                                NtfsRemoveNtfsMcbEntry( &Scb->Mcb,
                                                        Vcn,
                                                        1 );
                            }
                        }

                        if (Size > Scb->Header.AllocationSize.QuadPart) {

                            Scb->Header.AllocationSize.QuadPart =
                            Scb->Header.FileSize.QuadPart =
                            Scb->Header.ValidDataLength.QuadPart = Size;

                            //
                            //  Update the Cache Manager if we have a file object.
                            //

                            if (Scb->FileObject != NULL) {

                                ASSERT( !FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL ) );

                                CcSetFileSizes( Scb->FileObject,
                                                (PCC_FILE_SIZES)&Scb->Header.AllocationSize );
                            }
                        }
                    }

                    //
                    //  Point to the Redo Data and get its length.
                    //

                    Data = (PVOID)((PCHAR)LogRecord + LogRecord->UndoOffset);
                    Length = LogRecord->UndoLength;

                    //
                    //  Once we have logged the Undo operation, it is time to apply
                    //  the undo action.
                    //

                    DoAction( IrpContext,
                              Vcb,
                              LogRecord,
                              LogRecord->UndoOperation,
                              Data,
                              Length,
                              LogRecordLength,
                              NULL,
                              Scb,
                              &PageBcb,
                              &PageLsn );

                    UndoRecordLsn =
                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  PageBcb,
                                  LogRecord->UndoOperation,
                                  Data,
                                  Length,
                                  CompensationLogRecord,
                                  (PVOID)&UndoNextLsn,
                                  LogRecord->RedoLength,
                                  LlBytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset ),
                                  LogRecord->RecordOffset,
                                  LogRecord->AttributeOffset,
                                  BytesFromClusters( Vcb, LogRecord->LcnsToFollow ));

                    if (PageLsn != NULL) {
                        *PageLsn = UndoRecordLsn;
                    }

                    NtfsUnpinBcb( IrpContext, &PageBcb );
                }

            //
            //  Keep reading and looping back until we have read the last record
            //  for this transaction.
            //

            } while (LfsReadNextLogRecord( Vcb->LogHandle,
                                           LogContext,
                                           &RecordType,
                                           &TransactionId,
                                           &UndoNextLsn,
                                           &PreviousLsn,
                                           &LogRecordLsn,
                                           &LogRecordLength,
                                           (PVOID *)&LogRecord ));

            //
            //  Now "commit" this guy, just to clean up the transaction table and
            //  make sure we do not try to abort him again.  Also don't wake any
            //  waiters.
            //

            if (IrpContext->CheckNewLength != NULL) {
                NtfsProcessNewLengthQueue( IrpContext, TRUE );
            }

            NtfsCommitCurrentTransaction( IrpContext );

        } finally {

            NtfsUnpinBcb( IrpContext, &PageBcb );

            //
            //  Finally we can kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );

            //
            //  If we raised out of this routine, we want to be sure to remove
            //  this entry from the transaction table.  Otherwise it will
            //  be written to disk with the transaction table.
            //

            if (AbnormalTermination() && 
                (IrpContext->TransactionId != 0)) {

                NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                                  TRUE );

                NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                           IrpContext->TransactionId );

                //
                //  signal any waiters if there are no transactions left
                //

                if (Vcb->TransactionTable.Table->NumberAllocated == 0) {

                    KeSetEvent( &Vcb->TransactionsDoneEvent, 0, FALSE );
                }


                NtfsReleaseRestartTable( &Vcb->TransactionTable );
                IrpContext->TransactionId = 0;
            }
        }

    //
    //  This is a wierd case where we are aborting a guy who has not written anything.
    //  Either his empty transaction entry was captured during a checkpoint and we are
    //  in restart, or he failed to write his first log record.  The important thing
    //  is to at least go ahead and free his transaction entry.
    //

    } else {

        //
        //  We can now free the transaction table index, because we are
        //  done with it now.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                          TRUE );

        NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                   IrpContext->TransactionId );

        //
        //  signal any waiters if there are no transactions left
        //

        if (Vcb->TransactionTable.Table->NumberAllocated == 0) {

            KeSetEvent( &Vcb->TransactionsDoneEvent, 0, FALSE );
        }

        NtfsReleaseRestartTable( &Vcb->TransactionTable );
    }

    IrpContext->TransactionId = SavedTransaction;

    DebugTrace( -1, Dbg, ("NtfsAbortTransaction->VOID\n") );
}


//
//  Internal support routine
//

VOID
InitializeRestartState (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PRESTART_POINTERS DirtyPageTable,
    OUT PATTRIBUTE_NAME_ENTRY *AttributeNames,
    OUT PLSN CheckpointLsn,
    OUT PBOOLEAN UnrecognizedRestart
    )

/*++

Routine Description:

    This routine initializes the volume state for restart, as a first step
    in performing restart on the volume.  Essentially it reads the last
    Ntfs Restart Area on the volume, and then loads all of the Restart
    Tables.  The Open Attribute Table and Transaction Table are allocated,
    read in, and linked to the Vcb in the normal way.  (The names for the
    Open Attribute Table are separately read into pool, in order to fix
    up the Unicode Name Strings in the Attribute Entries, for the duration
    of Restart, after which they must switch over to use the same name as
    in the Scb as they do in the running system.)  In addition, the Dirty
    Pages Table is read and returned directly, since it is only during
    Restart anyway.

    The Checkpoint Lsn is also returned.  This is the Lsn at which the
    Analysis Pass should start.

Arguments:

    Vcb - Vcb for volume which is being restarted.

    DirtyPageTable - Returns the Dirty Page Table read from the log.

    AttributeNames - Returns pointer to AttributeNames buffer, which should
                     be deleted at the end of Restart, if not NULL

    CheckpointLsn - Returns the Checkpoint Lsn to be passed to the
                    Analysis Pass.

    UnrecognizedRestart - Indicates that this version of Ntfs doesn't recognize the
        restart area.  Chkdsk should run to repair the disk.

Return Value:

    None.

--*/

{
    PRESTART_AREA RestartArea;
    RESTART_AREA RestartAreaBuffer[2];
    LFS_LOG_CONTEXT LogContext;
    LSN RestartAreaLsn;
    PNTFS_LOG_RECORD_HEADER LogRecord;
    ULONG LogHeaderLength;
    PATTRIBUTE_NAME_ENTRY Name;
    LFS_RECORD_TYPE RecordType;
    TRANSACTION_ID TransactionId;
    LSN UndoNextLsn;
    LSN PreviousLsn;
    ULONG RestartAreaLength = 2 * sizeof(RESTART_AREA);
    BOOLEAN CleanupLogContext = FALSE;
    BOOLEAN ReleaseTransactionTable = FALSE;
    BOOLEAN ReleaseAttributeTable = FALSE;
    BOOLEAN ReleaseDirtyPageTable = FALSE;
    PRESTART_POINTERS NewTable = NULL;
    LOG_FILE_INFORMATION LogFileInformation;
    ULONG InfoLength = sizeof(LogFileInformation);
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("InitializeRestartState:\n") );
    DebugTrace( 0, Dbg, ("DirtyPageTable = %08lx\n", DirtyPageTable) );

    *AttributeNames = NULL;
    *CheckpointLsn = Li0;

    //
    //  Use the correct version for the dirty pages.
    //

    NtfsInitializeRestartTable( sizeof( DIRTY_PAGE_ENTRY ) + ((Vcb->ClustersPerPage - 1) * sizeof( LCN )),
                                INITIAL_NUMBER_DIRTY_PAGES,
                                DirtyPageTable );

    //
    //  Read our Restart Area.  Use a larger buffer than this version understands
    //  in case a later version of Ntfs wants to tack some information to
    //  the end of the restart area.
    //

    RestartArea = &RestartAreaBuffer[0];

    if (!NtfsDisableRestart &&
        !FlagOn( Vcb->VcbState, VCB_STATE_BAD_RESTART )) {

        Status = LfsReadRestartArea( Vcb->LogHandle,
                                     &RestartAreaLength,
                                     RestartArea,
                                     &RestartAreaLsn );

        if (STATUS_BUFFER_TOO_SMALL == Status) {

            RestartArea = NtfsAllocatePool( PagedPool , RestartAreaLength );
            Status = LfsReadRestartArea( Vcb->LogHandle,
                                         &RestartAreaLength,
                                         RestartArea,
                                         &RestartAreaLsn );
        }

        ASSERT( NT_SUCCESS( Status ) );

        DebugTrace( 0, Dbg, ("RestartArea read at %08lx\n", &RestartArea) );
    }

    //
    //  Record the current lsn at this point
    //

    LfsReadLogFileInformation( Vcb->LogHandle,
                               &LogFileInformation,
                               &InfoLength );

    ASSERT( InfoLength != 0 );
    Vcb->CurrentLsnAtMount = LogFileInformation.LastLsn;


    //
    //  If we get back zero for Restart Area Length, then zero it and proceed.
    //  Generally this will only happen on a virgin disk.
    //

    if ((RestartAreaLength == 0) ||
        NtfsDisableRestart ||
        FlagOn( Vcb->VcbState, VCB_STATE_BAD_RESTART )) {

        RtlZeroMemory( RestartArea, sizeof(RESTART_AREA) );
        RestartAreaLength = sizeof(RESTART_AREA);

    //
    //  If the restart version is unrecognized then use the default.
    //

    } else if ((RestartArea->MajorVersion != 1) &&
               ((RestartArea->MajorVersion != 0) || (RestartArea->MinorVersion != 0))) {

        *UnrecognizedRestart = TRUE;
        RtlZeroMemory( RestartArea, sizeof(RESTART_AREA) );
        RestartAreaLength = sizeof(RESTART_AREA);
        RestartAreaLsn.QuadPart = 0;

    } else {

        //
        //  Use the Restart version number from the disk.  Update the Vcb version if needed.
        //

        if (RestartArea->MajorVersion != Vcb->RestartVersion) {

            NtfsUpdateOatVersion( Vcb, RestartArea->MajorVersion );
        }

        //
        //  If the RestartArea does not include an LowestOpenUsn, then just set it to 0.
        //  Also default the Usn file reference and cache bias to zero.
        //

        if (RestartAreaLength == SIZEOF_OLD_RESTART_AREA) {
            RestartArea->LowestOpenUsn = 0;
            RestartAreaLength = sizeof(RESTART_AREA);

            *((PLONGLONG) &RestartArea->UsnJournalReference) = 0;
            RestartArea->UsnCacheBias = 0;
        }
    }

    Vcb->LowestOpenUsn = RestartArea->LowestOpenUsn;
    Vcb->UsnJournalReference = RestartArea->UsnJournalReference;
    Vcb->UsnCacheBias = 0;

    //
    //  Return the Start Of Checkpoint Lsn.  Typically we can use the value we stored
    //  in our restart area.  The exception is where we have never written a fuzzy
    //  checkpoint since mounting the volume.  In that case the CheckpointLsn will
    //  be zero but we may have log records on the disk.  Use our restart area
    //  Lsn in that case.
    //

    *CheckpointLsn = RestartArea->StartOfCheckpoint;

    if (RestartArea->StartOfCheckpoint.QuadPart == 0) {

        *CheckpointLsn = RestartAreaLsn;
    }

    try {

        //
        //  Allocate and Read in the Transaction Table.
        //

        if (RestartArea->TransactionTableLength != 0) {

            //
            //  Workaround for compiler bug.
            //

            PreviousLsn = RestartArea->TransactionTableLsn;

            LfsReadLogRecord( Vcb->LogHandle,
                              PreviousLsn,
                              LfsContextPrevious,
                              &LogContext,
                              &RecordType,
                              &TransactionId,
                              &UndoNextLsn,
                              &PreviousLsn,
                              &RestartAreaLength,
                              (PVOID *) &LogRecord );

            CleanupLogContext = TRUE;

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     RestartAreaLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Now check that this is a valid restart table.
            //

            if (!NtfsCheckRestartTable( Add2Ptr( LogRecord, LogRecord->RedoOffset ),
                                        RestartAreaLength - LogRecord->RedoOffset)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Subtract the length of the log page header and increment the
            //  pointer for
            //

            LogHeaderLength = NtfsLogRecordHeaderLength( IrpContext, LogRecord );

            RestartAreaLength -= LogHeaderLength;

            ASSERT( RestartAreaLength >= RestartArea->TransactionTableLength );

            //
            //  TEMPCODE    RESTART_DEBUG   There is already a buffer.
            //

            NtfsFreePool( Vcb->TransactionTable.Table );

            Vcb->TransactionTable.Table =
              NtfsAllocatePool( NonPagedPool, RestartAreaLength  );

            RtlCopyMemory( Vcb->TransactionTable.Table,
                           Add2Ptr( LogRecord, LogHeaderLength ),
                           RestartAreaLength  );

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
            CleanupLogContext = FALSE;
        }

        //
        //  TEMPCODE    RESTART_DEBUG   There is already a structure.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
        ReleaseTransactionTable = TRUE;

        //
        //  The next record back should be the Dirty Pages Table.
        //

        if (RestartArea->DirtyPageTableLength != 0) {

            //
            //  Workaround for compiler bug.
            //

            PreviousLsn = RestartArea->DirtyPageTableLsn;

            LfsReadLogRecord( Vcb->LogHandle,
                              PreviousLsn,
                              LfsContextPrevious,
                              &LogContext,
                              &RecordType,
                              &TransactionId,
                              &UndoNextLsn,
                              &PreviousLsn,
                              &RestartAreaLength,
                              (PVOID *) &LogRecord );

            CleanupLogContext = TRUE;

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     RestartAreaLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Now check that this is a valid restart table.
            //

            if (!NtfsCheckRestartTable( Add2Ptr( LogRecord, LogRecord->RedoOffset ),
                                        RestartAreaLength - LogRecord->RedoOffset)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Subtract the length of the log page header and increment the
            //  pointer for
            //

            LogHeaderLength = NtfsLogRecordHeaderLength( IrpContext, LogRecord );

            RestartAreaLength -= LogHeaderLength;

            ASSERT( RestartAreaLength >= RestartArea->DirtyPageTableLength );

            //
            //  If the version number in the restart table is version 0 then
            //  we need to pull the entries out of the on-disk table and put them
            //  into in-memory version.
            //

            if (RestartArea->MajorVersion == 0) {

                RESTART_POINTERS OldTable;
                PDIRTY_PAGE_ENTRY_V0 OldEntry;
                PDIRTY_PAGE_ENTRY NewEntry;



                OldTable.Table = Add2Ptr( LogRecord, LogHeaderLength );

                //
                //  Check that our assumption about clusters per page matches the data on disk
                //  if not in sync reallocate the table using the number of on disk lcns
                //

                if (OldTable.Table->EntrySize - sizeof( DIRTY_PAGE_ENTRY_V0 ) > DirtyPageTable->Table->EntrySize - sizeof( DIRTY_PAGE_ENTRY )) {

                    DebugTrace(+1, Dbg, ("NTFS: resizing table in initrestartstate\n"));

                    NtfsFreeRestartTable( DirtyPageTable );
                    NtfsInitializeRestartTable( sizeof( DIRTY_PAGE_ENTRY ) + OldTable.Table->EntrySize - sizeof( DIRTY_PAGE_ENTRY_V0 ),
                            INITIAL_NUMBER_DIRTY_PAGES,
                            DirtyPageTable );
                }

                OldEntry = NtfsGetFirstRestartTable( &OldTable );

                while (OldEntry != NULL) {

                    ULONG PageIndex;

                    PageIndex = NtfsAllocateRestartTableIndex( DirtyPageTable, TRUE );
                    NewEntry = GetRestartEntryFromIndex( DirtyPageTable, PageIndex );

                    RtlCopyMemory( NewEntry, OldEntry, FIELD_OFFSET( DIRTY_PAGE_ENTRY_V0, Reserved ));
                    NewEntry->Vcn = OldEntry->Vcn;
                    NewEntry->OldestLsn = OldEntry->OldestLsn;
                    if (NewEntry->LcnsToFollow != 0) {

                        RtlCopyMemory( &NewEntry->LcnsForPage[0],
                                       &OldEntry->LcnsForPage[0],
                                       sizeof( LCN ) * NewEntry->LcnsToFollow );
                    }

                    OldEntry = NtfsGetNextRestartTable( &OldTable, OldEntry );
                }

            } else {

                //
                //  Simply copy the old data over.
                //

                NtfsFreePool( DirtyPageTable->Table );
                DirtyPageTable->Table = NULL;
                DirtyPageTable->Table =
                  NtfsAllocatePool( NonPagedPool, RestartAreaLength );

                RtlCopyMemory( DirtyPageTable->Table,
                               Add2Ptr( LogRecord, LogHeaderLength ),
                               RestartAreaLength );
            }

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
            CleanupLogContext = FALSE;

            //
            //  If the cluster size is larger than the page size we may have
            //  multiple entries for the same Vcn.  Go through the table
            //  and remove the duplicates, remembering the oldest Lsn values.
            //

            if (Vcb->BytesPerCluster > PAGE_SIZE) {

                PDIRTY_PAGE_ENTRY CurrentEntry;
                PDIRTY_PAGE_ENTRY NextEntry;

                CurrentEntry = NtfsGetFirstRestartTable( DirtyPageTable );

                while (CurrentEntry != NULL) {

                    NextEntry = CurrentEntry;

                    while ((NextEntry = NtfsGetNextRestartTable( DirtyPageTable, NextEntry )) != NULL) {

                        if ((NextEntry->TargetAttribute == CurrentEntry->TargetAttribute) &&
                            (NextEntry->Vcn == CurrentEntry->Vcn)) {

                            if (NextEntry->OldestLsn.QuadPart < CurrentEntry->OldestLsn.QuadPart) {

                                CurrentEntry->OldestLsn.QuadPart = NextEntry->OldestLsn.QuadPart;
                            }

                            NtfsFreeRestartTableIndex( DirtyPageTable,
                                                       GetIndexFromRestartEntry( DirtyPageTable,
                                                                                 NextEntry ));
                        }
                    }

                    CurrentEntry = NtfsGetNextRestartTable( DirtyPageTable, CurrentEntry );
                }
            }
        }

        NtfsAcquireExclusiveRestartTable( DirtyPageTable, TRUE );
        ReleaseDirtyPageTable = TRUE;

        //
        //  The next record back should be the Attribute Names.
        //

        if (RestartArea->AttributeNamesLength != 0) {

            //
            //  Workaround for compiler bug.
            //

            PreviousLsn = RestartArea->AttributeNamesLsn;

            LfsReadLogRecord( Vcb->LogHandle,
                              PreviousLsn,
                              LfsContextPrevious,
                              &LogContext,
                              &RecordType,
                              &TransactionId,
                              &UndoNextLsn,
                              &PreviousLsn,
                              &RestartAreaLength,
                              (PVOID *) &LogRecord );

            CleanupLogContext = TRUE;

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     RestartAreaLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Subtract the length of the log page header and increment the
            //  pointer for
            //

            LogHeaderLength = NtfsLogRecordHeaderLength( IrpContext, LogRecord );

            RestartAreaLength -= LogHeaderLength;

            ASSERT( RestartAreaLength >= RestartArea->AttributeNamesLength );

            *AttributeNames =
              NtfsAllocatePool( NonPagedPool, RestartAreaLength );

            RtlCopyMemory( *AttributeNames,
                           Add2Ptr( LogRecord, LogHeaderLength ),
                           RestartAreaLength );

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
            CleanupLogContext = FALSE;
        }

        //
        //  The next record back should be the Attribute Table.
        //

        if (RestartArea->OpenAttributeTableLength != 0) {

            POPEN_ATTRIBUTE_ENTRY OpenEntry;

            //
            //  Workaround for compiler bug.
            //

            PreviousLsn = RestartArea->OpenAttributeTableLsn;

            LfsReadLogRecord( Vcb->LogHandle,
                              PreviousLsn,
                              LfsContextPrevious,
                              &LogContext,
                              &RecordType,
                              &TransactionId,
                              &UndoNextLsn,
                              &PreviousLsn,
                              &RestartAreaLength,
                              (PVOID *) &LogRecord );

            CleanupLogContext = TRUE;

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     RestartAreaLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Now check that this is a valid restart table.
            //

            if (!NtfsCheckRestartTable( Add2Ptr( LogRecord, LogRecord->RedoOffset ),
                                        RestartAreaLength - LogRecord->RedoOffset)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  Subtract the length of the log page header and increment the
            //  pointer for
            //

            LogHeaderLength = NtfsLogRecordHeaderLength( IrpContext, LogRecord );

            RestartAreaLength -= LogHeaderLength;

            ASSERT( RestartAreaLength >= RestartArea->OpenAttributeTableLength );

            //
            //  If the restart version is version 0 then we need to create
            //  a corresponding in-memory structure and refer back to it.
            //

            if (RestartArea->MajorVersion == 0) {

                POPEN_ATTRIBUTE_ENTRY_V0 OldEntry;

                NewTable = NtfsAllocatePool( NonPagedPool, RestartAreaLength );

                NtfsFreePool( Vcb->OnDiskOat->Table );
                Vcb->OnDiskOat->Table = (PRESTART_TABLE) NewTable;
                NewTable = NULL;

                RtlCopyMemory( Vcb->OnDiskOat->Table,
                               Add2Ptr( LogRecord, LogHeaderLength ),
                               RestartAreaLength );

                //
                //  Now for each entry in this table create one in our in-memory version.
                //

                OldEntry = NtfsGetFirstRestartTable( Vcb->OnDiskOat );

                while (OldEntry != NULL) {

                    //
                    //  Allocate the attribute data structure.
                    //

                    NewTable = NtfsAllocatePool( PagedPool, sizeof( OPEN_ATTRIBUTE_DATA ) );
                    RtlZeroMemory( NewTable, sizeof( OPEN_ATTRIBUTE_DATA ));

                    //
                    //  Now get an new index for the data.
                    //

                    OldEntry->OatIndex = NtfsAllocateRestartTableIndex( &Vcb->OpenAttributeTable, TRUE );

                    //
                    //  Initialize the new entry with data from the on-disk entry.
                    //

                    OpenEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, OldEntry->OatIndex );
                    InsertTailList( &Vcb->OpenAttributeData, &((POPEN_ATTRIBUTE_DATA) NewTable)->Links );
                    OpenEntry->OatData = (POPEN_ATTRIBUTE_DATA) NewTable;
                    NewTable = NULL;

                    OpenEntry->OatData->OnDiskAttributeIndex = GetIndexFromRestartEntry( Vcb->OnDiskOat,
                                                                                         OldEntry );
                    OpenEntry->BytesPerIndexBuffer = OldEntry->BytesPerIndexBuffer;
                    OpenEntry->AttributeTypeCode = OldEntry->AttributeTypeCode;
                    OpenEntry->FileReference = OldEntry->FileReference;
                    OpenEntry->LsnOfOpenRecord.QuadPart = OldEntry->LsnOfOpenRecord.QuadPart;

                    OldEntry = NtfsGetNextRestartTable( Vcb->OnDiskOat, OldEntry );
                }

            //
            //  If the restart version is version 1 then simply copy it over.
            //  We also need to allocate the auxiliary data structure.
            //

            } else {

                //
                //  TEMPCODE    RESTART_DEBUG   There is already a buffer.
                //

                NewTable = NtfsAllocatePool( NonPagedPool, RestartAreaLength );
                NtfsFreePool( Vcb->OpenAttributeTable.Table );
                Vcb->OpenAttributeTable.Table = (PRESTART_TABLE) NewTable;
                NewTable = NULL;

                RtlCopyMemory( Vcb->OpenAttributeTable.Table,
                               Add2Ptr( LogRecord, LogHeaderLength ),
                               RestartAreaLength );


                //
                //  First loop to clear all of the Scb pointers in case we
                //  have a premature abort and want to clean up.
                //

                OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

                //
                //  Loop to end of table.
                //

                while (OpenEntry != NULL) {

                    //
                    //  Allocate the attribute data structure.
                    //

                    NewTable = NtfsAllocatePool( PagedPool, sizeof( OPEN_ATTRIBUTE_DATA ) );
                    RtlZeroMemory( NewTable, sizeof( OPEN_ATTRIBUTE_DATA ));

                    InsertTailList( &Vcb->OpenAttributeData, &((POPEN_ATTRIBUTE_DATA) NewTable)->Links );
                    OpenEntry->OatData = (POPEN_ATTRIBUTE_DATA) NewTable;
                    NewTable = NULL;

                    //
                    //  The on-disk index is the same as the in-memory index.
                    //

                    OpenEntry->OatData->OnDiskAttributeIndex = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                                                                                         OpenEntry );
                    //
                    //  Point to next entry in table, or NULL.
                    //

                    OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                         OpenEntry );
                }
            }

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
            CleanupLogContext = FALSE;
        }

        //
        //  Here is a case where there was no attribute table on disk.  Make sure we have the
        //  correct on-disk version in the Vcb if this is version 0.
        //

        ASSERT( (RestartArea->OpenAttributeTableLength != 0) ||
                (Vcb->RestartVersion != 0) ||
                (Vcb->OnDiskOat != NULL) );

        //
        //  TEMPCODE    RESTART_DEBUG   There is already a structure.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
        ReleaseAttributeTable = TRUE;

        //
        //  The only other thing we have to do before returning is patch up the
        //  Unicode String's in the Attribute Table to point to their respective
        //  attribute names.
        //

        if (RestartArea->AttributeNamesLength != 0) {

            Name = *AttributeNames;

            while (Name->Index != 0) {

                POPEN_ATTRIBUTE_ENTRY Entry;

                if (!IsRestartIndexWithinTable( Vcb->OnDiskOat, Name->Index )) {
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                Entry = GetRestartEntryFromIndex( Vcb->OnDiskOat, Name->Index );

                //
                //  Check if we have a level of indirection.
                //

                if (Vcb->RestartVersion == 0) {

                    if (!IsRestartIndexWithinTable( &Vcb->OpenAttributeTable, ((POPEN_ATTRIBUTE_ENTRY_V0) Entry)->OatIndex )) {

                        NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                    }

                    Entry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                      ((POPEN_ATTRIBUTE_ENTRY_V0) Entry)->OatIndex );
                }

                Entry->OatData->AttributeName.MaximumLength =
                Entry->OatData->AttributeName.Length = Name->NameLength;
                Entry->OatData->AttributeName.Buffer = (PWSTR)&Name->Name[0];

                Name = (PATTRIBUTE_NAME_ENTRY)((PCHAR)Name +
                                               sizeof(ATTRIBUTE_NAME_ENTRY) +
                                               (ULONG)Name->NameLength );
            }
        }

    } finally {

        //
        //  Release any transaction tables we acquired if we raised during
        //   this routine.
        //

        if (AbnormalTermination()) {

            if (ReleaseTransactionTable) {
                NtfsReleaseRestartTable( &Vcb->TransactionTable );
            }

            if (ReleaseAttributeTable) {
                NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
            }

            if (ReleaseDirtyPageTable) {
                NtfsReleaseRestartTable( DirtyPageTable );
            }
        }

        if (CleanupLogContext) {

            //
            //  Kill the log handle.
            //

            LfsTerminateLogQuery( Vcb->LogHandle, LogContext );
        }

        //
        //  Did we fail to create the new table.
        //

        if (NewTable != NULL) {

            NtfsFreePool( NewTable );
        }

        //
        //  If we allocated a restart area rather than using the stack
        //  free it here
        //

        if (RestartArea != &RestartAreaBuffer[0]) {

            NtfsFreePool( RestartArea );
        }
    }

    DebugTrace( 0, Dbg, ("AttributeNames > %08lx\n", *AttributeNames) );
    DebugTrace( 0, Dbg, ("CheckpointLsn > %016I64x\n", *CheckpointLsn) );
    DebugTrace( -1, Dbg, ("NtfsInitializeRestartState -> VOID\n") );
}


VOID
ReleaseRestartState (
    IN PVCB Vcb,
    IN PRESTART_POINTERS DirtyPageTable,
    IN PATTRIBUTE_NAME_ENTRY AttributeNames,
    IN BOOLEAN ReleaseVcbTables
    )

/*++

Routine Description:

    This routine releases all of the restart state.

Arguments:

    Vcb - Vcb for the volume being restarted.

    DirtyPageTable - pointer to the dirty page table, if one was allocated.

    AttributeNames - pointer to the attribute names buffer, if one was allocated.

    ReleaseVcbTables - TRUE if we are to release the restart tables in the Vcb,
        FALSE otherwise.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  If the caller successfully had a successful restart, then we must release
    //  the transaction and open attribute tables.
    //

    if (ReleaseVcbTables) {
        NtfsReleaseRestartTable( &Vcb->TransactionTable );
        NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
    }

    //
    //  Free the dirty page table, if there is one.
    //

    if (DirtyPageTable != NULL) {
        NtfsFreeRestartTable( DirtyPageTable );
    }

    //
    //  Free the temporary attribute names buffer, if there is one.
    //

    if (AttributeNames != NULL) {
        NtfsFreePool( AttributeNames );
    }
}


//
//  Internal support routine
//

VOID
AnalysisPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LSN CheckpointLsn,
    IN OUT PRESTART_POINTERS DirtyPageTable,
    OUT PLSN RedoLsn
    )

/*++

Routine Description:

    This routine performs the analysis phase of Restart.  Starting at
    the CheckpointLsn, it reads all records written by Ntfs, and takes
    the following actions:

        For all log records which create or update attributes, a check is
        made to see if the affected page(s) are already in the Dirty Pages
        Table.  For any page that is not, it is added, and the OldestLsn
        field is set to the Lsn of the log record.

        The transaction table is updated on transaction state changes,
        and also to maintain the PreviousLsn and UndoNextLsn fields.

        If any attributes are truncated or deleted (including delete of
        an entire file), then any corrsponding pages in the Dirty Page
        Table are deleted.

        When attributes or entire files are deleted, the respective entries
        are deleted from the Open Attribute Table.

        For Hot Fix records, the Dirty Pages Table is scanned for the HotFixed
        Vcn, and if one is found, the Lcn field in the table is updated to
        the new location.

    When the end of the log file is encountered, the Dirty Page Table is
    scanned for the Oldest of the OldestLsn fields.  This value is returned
    as the RedoLsn, i.e., the point at which the Redo Pass must occur.

Arguments:

    Vcb - Volume which is being restarted.

    CheckpointLsn - Lsn at which the Analysis Pass is to begin.

    DirtyPageTable - Pointer to a pointer to the Dirty Page Table, as
                     found from the last Restart Area.

    RedoLsn - Returns point at which the Redo Pass should begin.

Return Value:

    None.

--*/

{
    LFS_LOG_CONTEXT LogContext;
    PNTFS_LOG_RECORD_HEADER LogRecord;
    ULONG LogRecordLength;
    LSN LogRecordLsn = CheckpointLsn;
    PRESTART_POINTERS TransactionTable = &Vcb->TransactionTable;
    PRESTART_POINTERS OpenAttributeTable = &Vcb->OpenAttributeTable;
    LFS_LOG_HANDLE LogHandle = Vcb->LogHandle;
    LFS_RECORD_TYPE RecordType;
    TRANSACTION_ID TransactionId;
    PTRANSACTION_ENTRY Transaction;
    LSN UndoNextLsn;
    LSN PreviousLsn;
    POPEN_ATTRIBUTE_DATA OatData = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("AnalysisPass:\n") );
    DebugTrace( 0, Dbg, ("CheckpointLsn = %016I64x\n", CheckpointLsn) );

    *RedoLsn = Li0; //**** LfsZeroLsn;

    //
    //  Read the first Lsn.
    //

    LfsReadLogRecord( LogHandle,
                      CheckpointLsn,
                      LfsContextForward,
                      &LogContext,
                      &RecordType,
                      &TransactionId,
                      &UndoNextLsn,
                      &PreviousLsn,
                      &LogRecordLength,
                      (PVOID *)&LogRecord );

    //
    //  Use a try-finally to cleanup the query context.
    //

    try {

        //
        //  Since the checkpoint remembers the previous Lsn, not the one he wants to
        //  start at, we must always skip the first record.
        //
        //  Loop to read all subsequent records to the end of the log file.
        //

        while ( LfsReadNextLogRecord( LogHandle,
                                      LogContext,
                                      &RecordType,
                                      &TransactionId,
                                      &UndoNextLsn,
                                      &PreviousLsn,
                                      &LogRecordLsn,
                                      &LogRecordLength,
                                      (PVOID *)&LogRecord )) {

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     LogRecordLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  The first Lsn after the previous Lsn remembered in the checkpoint is
            //  the first candidate for the RedoLsn.
            //

            if (RedoLsn->QuadPart == 0) {
                *RedoLsn = LogRecordLsn;
            }

            if (RecordType != LfsClientRecord) {
                continue;
            }

            DebugTrace( 0, Dbg, ("Analysis of LogRecord at: %08lx\n", LogRecord) );
            DebugTrace( 0, Dbg, ("Log Record Lsn = %016I64x\n", LogRecordLsn) );
            DebugTrace( 0, Dbg, ("LogRecord->RedoOperation = %08lx\n", LogRecord->RedoOperation) );
            DebugTrace( 0, Dbg, ("TransactionId = %08lx\n", TransactionId) );

            //
            //  Now update the Transaction Table for this transaction.  If there is no
            //  entry present or it is unallocated we allocate the entry.
            //

            Transaction = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex( &Vcb->TransactionTable,
                                                                        TransactionId );

            if (!IsRestartIndexWithinTable( &Vcb->TransactionTable, TransactionId ) ||
                !IsRestartTableEntryAllocated( Transaction )) {

                Transaction = (PTRANSACTION_ENTRY) NtfsAllocateRestartTableFromIndex( &Vcb->TransactionTable,
                                                                                      TransactionId );

                Transaction->TransactionState = TransactionActive;
                Transaction->FirstLsn = LogRecordLsn;
            }

            Transaction->PreviousLsn =
            Transaction->UndoNextLsn = LogRecordLsn;

            //
            //  If this is a compensation log record (CLR), then change the UndoNextLsn to
            //  be the UndoNextLsn of this record.
            //

            if (LogRecord->UndoOperation == CompensationLogRecord) {

                Transaction->UndoNextLsn = UndoNextLsn;
            }

            //
            //  Dispatch to handle log record depending on type.
            //

            switch (LogRecord->RedoOperation) {

            //
            //  The following cases are performing various types of updates
            //  and need to make the appropriate updates to the Transaction
            //  and Dirty Page Tables.
            //

            case InitializeFileRecordSegment:
            case DeallocateFileRecordSegment:
            case WriteEndOfFileRecordSegment:
            case CreateAttribute:
            case DeleteAttribute:
            case UpdateResidentValue:
            case UpdateNonresidentValue:
            case UpdateMappingPairs:
            case SetNewAttributeSizes:
            case AddIndexEntryRoot:
            case DeleteIndexEntryRoot:
            case AddIndexEntryAllocation:
            case DeleteIndexEntryAllocation:
            case WriteEndOfIndexBuffer:
            case SetIndexEntryVcnRoot:
            case SetIndexEntryVcnAllocation:
            case UpdateFileNameRoot:
            case UpdateFileNameAllocation:
            case SetBitsInNonresidentBitMap:
            case ClearBitsInNonresidentBitMap:
            case UpdateRecordDataRoot:
            case UpdateRecordDataAllocation:

                PageUpdateAnalysis( Vcb,
                                    LogRecordLsn,
                                    DirtyPageTable,
                                    LogRecord );

                break;

            //
            //  This case is deleting clusters from a nonresident attribute,
            //  thus it deletes a range of pages from the Dirty Page Table.
            //  This log record is written each time a nonresident attribute
            //  is truncated, whether explicitly or as part of deletion.
            //
            //  Processing one of these records is pretty compute-intensive
            //  (three nested loops, where a couple of them can be large),
            //  but this is the code that prevents us from dropping, for example,
            //  index updates into the middle of user files, if the index stream
            //  is truncated and the sectors are reallocated to a user file
            //  and we crash after the user data has been written.
            //
            //  I.e., note the following sequence:
            //
            //      <checkpoint>
            //      <Index update>
            //      <Index page deleted>
            //      <Same cluster(s) reallocated to user file>
            //      <User data written>
            //
            //      CRASH!
            //
            //  Since the user data was not logged (else there would be no problem),
            //  It could get overwritten while applying the index update after a
            //  crash - Pisses off the user as well as the security dudes!
            //

            case DeleteDirtyClusters:

                {
                    PDIRTY_PAGE_ENTRY DirtyPage;
                    PLCN_RANGE LcnRange;
                    ULONG i, j;
                    LCN FirstLcn, LastLcn;
                    ULONG RangeCount = LogRecord->RedoLength / sizeof(LCN_RANGE);

                    //
                    //  Point to the Lcn range array.
                    //

                    LcnRange = Add2Ptr(LogRecord, LogRecord->RedoOffset);

                    //
                    //  Loop through all of the Lcn ranges in this log record.
                    //

                    for (i = 0; i < RangeCount; i++) {

                        FirstLcn = LcnRange[i].StartLcn;
                        LastLcn = FirstLcn + (LcnRange[i].Count - 1);

                        DebugTrace( 0, Dbg, ("Deleting from FirstLcn = %016I64x\n", FirstLcn));
                        DebugTrace( 0, Dbg, ("Deleting to LastLcn =  %016I64x\n", LastLcn ));

                        //
                        //  Point to first Dirty Page Entry.
                        //

                        DirtyPage = NtfsGetFirstRestartTable( DirtyPageTable );

                        //
                        //  Loop to end of table.
                        //

                        while (DirtyPage != NULL) {

                            //
                            //  Loop through all of the Lcns for this dirty page.
                            //

                            for (j = 0; j < (ULONG)DirtyPage->LcnsToFollow; j++) {

                                if ((DirtyPage->LcnsForPage[j] >= FirstLcn) &&
                                    (DirtyPage->LcnsForPage[j] <= LastLcn)) {

                                    DirtyPage->LcnsForPage[j] = 0;
                                }
                            }

                            //
                            //  Point to next entry in table, or NULL.
                            //

                            DirtyPage = NtfsGetNextRestartTable( DirtyPageTable,
                                                                 DirtyPage );
                        }
                    }
                }

                break;

            //
            //  When a record is encountered for a nonresident attribute that
            //  was opened, we have to add an entry to the Open Attribute Table.
            //

            case OpenNonresidentAttribute:

                {
                    POPEN_ATTRIBUTE_ENTRY AttributeEntry;
                    ULONG NameSize;

                    //
                    //  If the table is not currently big enough, then we must
                    //  expand it.
                    //

                    if (!IsRestartIndexWithinTable( Vcb->OnDiskOat,
                                                    (ULONG)LogRecord->TargetAttribute )) {

                        ULONG NeededEntries;

                        //
                        //  Compute how big the table needs to be.  Add 10 extra entries
                        //  for some cushion.
                        //

                        NeededEntries = (LogRecord->TargetAttribute / Vcb->OnDiskOat->Table->EntrySize);
                        NeededEntries = (NeededEntries + 10 - Vcb->OnDiskOat->Table->NumberEntries);

                        NtfsExtendRestartTable( Vcb->OnDiskOat,
                                                NeededEntries,
                                                MAXULONG );
                    }

                    ASSERT( IsRestartIndexWithinTable( Vcb->OnDiskOat,
                                                       (ULONG)LogRecord->TargetAttribute ));

                    //
                    //  Calculate size of Attribute Name Entry, if there is one.
                    //

                    NameSize = LogRecord->UndoLength;

                    //
                    //  Point to the entry being opened.
                    //

                    OatData = NtfsAllocatePool( PagedPool, sizeof( OPEN_ATTRIBUTE_DATA ) );
                    RtlZeroMemory( OatData, sizeof( OPEN_ATTRIBUTE_DATA ));

                    OatData->OnDiskAttributeIndex = LogRecord->TargetAttribute;

                    //
                    //  We extended the table above so allocating an oat index won't raise
                    //  any exceptions
                    //  

                    NtfsAcquireExclusiveRestartTable( Vcb->OnDiskOat, TRUE );

                    AttributeEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat, LogRecord->TargetAttribute );
                    if (IsRestartTableEntryAllocated( AttributeEntry )) {

                        //
                        //  For restart version 0 we need to look up the corresponding in memory 
                        //  entry to use for the free
                        // 

                        if (Vcb->RestartVersion == 0) {
                            
                            POPEN_ATTRIBUTE_ENTRY_V0 OldEntry = (POPEN_ATTRIBUTE_ENTRY_V0) AttributeEntry;

                            if (IsRestartIndexWithinTable( &Vcb->OpenAttributeTable, OldEntry->OatIndex )) {
                                AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, OldEntry->OatIndex );
                            } else {
                                
                                //
                                //  The on disk entry is invalid so just let NtfsAllocateRestarTableFromIndex
                                //  overwrite it.
                                //  
                                
                                AttributeEntry = NULL;
                            }
                        } 
                        if (AttributeEntry) {

                            NtfsFreeAttributeEntry( Vcb, AttributeEntry  );
                        }
                    }

                    AttributeEntry = NtfsAllocateRestartTableFromIndex( Vcb->OnDiskOat, LogRecord->TargetAttribute );
                    NtfsReleaseRestartTable( Vcb->OnDiskOat );

                    //
                    //  The attribute entry better either not be allocated or it must
                    //  be for the same file.
                    //

                    //  **** May eliminate this test.
                    //
                    //  ASSERT( !IsRestartTableEntryAllocated(AttributeEntry) ||
                    //          xxEql(AttributeEntry->FileReference,
                    //                ((POPEN_ATTRIBUTE_ENTRY)Add2Ptr(LogRecord,
                    //                                                LogRecord->RedoOffset))->FileReference));

                    //
                    //  Initialize this entry from the log record.
                    //

                    ASSERT( LogRecord->RedoLength == Vcb->OnDiskOat->Table->EntrySize );

                    RtlCopyMemory( AttributeEntry,
                                   (PCHAR)LogRecord + LogRecord->RedoOffset,
                                   LogRecord->RedoLength );

                    ASSERT( IsRestartTableEntryAllocated(AttributeEntry) );

                    //
                    //  Get a new entry for the in-memory copy if needed.
                    //

                    if (Vcb->RestartVersion == 0) {

                        POPEN_ATTRIBUTE_ENTRY_V0 OldEntry = (POPEN_ATTRIBUTE_ENTRY_V0) AttributeEntry;
                        ULONG NewIndex;

                        NewIndex = NtfsAllocateRestartTableIndex( &Vcb->OpenAttributeTable, TRUE );
                        AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, NewIndex );

                        AttributeEntry->BytesPerIndexBuffer = OldEntry->BytesPerIndexBuffer;

                        AttributeEntry->AttributeTypeCode = OldEntry->AttributeTypeCode;
                        AttributeEntry->FileReference = OldEntry->FileReference;
                        AttributeEntry->LsnOfOpenRecord.QuadPart = OldEntry->LsnOfOpenRecord.QuadPart;

                        OldEntry->OatIndex = NewIndex;

                    }

                    //
                    //  Finish initializing the AttributeData.
                    //

                    AttributeEntry->OatData = OatData;
                    InsertTailList( &Vcb->OpenAttributeData, &OatData->Links );
                    OatData = NULL;

                    //
                    //  If there is a name at the end, then allocate space to
                    //  copy it into, and do the copy.  We also set the buffer
                    //  pointer in the string descriptor, although note that the
                    //  lengths must be correct.
                    //

                    if (NameSize != 0) {

                        AttributeEntry->OatData->Overlay.AttributeName =
                          NtfsAllocatePool( NonPagedPool, NameSize );
                        RtlCopyMemory( AttributeEntry->OatData->Overlay.AttributeName,
                                       Add2Ptr(LogRecord, LogRecord->UndoOffset),
                                       NameSize );

                        AttributeEntry->OatData->AttributeName.Buffer = AttributeEntry->OatData->Overlay.AttributeName;

                        AttributeEntry->OatData->AttributeNamePresent = TRUE;

                    //
                    //  Otherwise, show there is no name.
                    //

                    } else {
                        AttributeEntry->OatData->Overlay.AttributeName = NULL;
                        AttributeEntry->OatData->AttributeName.Buffer = NULL;
                        AttributeEntry->OatData->AttributeNamePresent = FALSE;
                    }

                    AttributeEntry->OatData->AttributeName.MaximumLength =
                    AttributeEntry->OatData->AttributeName.Length = (USHORT) NameSize;
                }

                break;

            //
            //  For HotFix records, we need to update the Lcn in the Dirty Page
            //  Table.
            //

            case HotFix:

                {
                    PDIRTY_PAGE_ENTRY DirtyPage;

                    //
                    //  First see if the Vcn is currently in the Dirty Page
                    //  Table.  If not, there is nothing to do.
                    //

                    if (FindDirtyPage( DirtyPageTable,
                                       LogRecord->TargetAttribute,
                                       LogRecord->TargetVcn,
                                       &DirtyPage )) {

                        //
                        //  Index to the Lcn in question in the Dirty Page Entry
                        //  and rewrite it with the Hot Fixed Lcn from the log
                        //  record.  Note that it is ok to just use the LowPart
                        //  of the Vcns to calculate the array offset, because
                        //  any multiple of 2**32 is guaranteed to be on a page
                        //  boundary!
                        //

                        if (DirtyPage->LcnsForPage[((ULONG)LogRecord->TargetVcn) - ((ULONG)DirtyPage->Vcn)] != 0) {

                            DirtyPage->LcnsForPage[((ULONG)LogRecord->TargetVcn) - ((ULONG)DirtyPage->Vcn)] = LogRecord->LcnsForPage[0];
                        }
                    }
                }

                break;

            //
            //  For end top level action, we will just update the transaction
            //  table to skip the top level action on undo.
            //

            case EndTopLevelAction:

                {
                    //
                    //  Now update the Transaction Table for this transaction.
                    //

                    Transaction->PreviousLsn = LogRecordLsn;
                    Transaction->UndoNextLsn = UndoNextLsn;

                }

                break;

            //
            //  For Prepare Transaction, we just change the state of our entry.
            //

            case PrepareTransaction:

                ASSERT( !IsRestartTableEntryAllocated( Transaction ));

                Transaction->TransactionState = TransactionPrepared;

                break;

            //
            //  For Commit Transaction, we just change the state of our entry.
            //

            case CommitTransaction:

                ASSERT( !IsRestartTableEntryAllocated( Transaction ));

                Transaction->TransactionState = TransactionCommitted;

                break;

            //
            //  For forget, we can delete our transaction entry, since the transaction
            //  will not have to be aborted.
            //

            case ForgetTransaction:

                {
                    NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                               TransactionId );
                }

                break;

            //
            //  The following cases require no action in the Analysis Pass.
            //

            case Noop:
            case OpenAttributeTableDump:
            case AttributeNamesDump:
            case DirtyPageTableDump:
            case TransactionTableDump:

                break;

            //
            //  All codes will be explicitly handled.  If we see a code we
            //  do not expect, then we are in trouble.
            //

            default:

                DebugTrace( 0, Dbg, ("Unexpected Log Record Type: %04lx\n", LogRecord->RedoOperation) );
                DebugTrace( 0, Dbg, ("Record address: %08lx\n", LogRecord) );
                DebugTrace( 0, Dbg, ("Record length: %08lx\n", LogRecordLength) );

                ASSERTMSG( "Unknown Action!\n", FALSE );

                break;
            }
        }

    } finally {

        //
        //  Finally we can kill the log handle.
        //

        LfsTerminateLogQuery( LogHandle, LogContext );

        if (OatData != NULL) { NtfsFreePool( OatData ); }
    }

    //
    //  Now we just have to scan the Dirty Page Table and Transaction Table
    //  for the lowest Lsn, and return it as the Redo Lsn.
    //

    {
        PDIRTY_PAGE_ENTRY DirtyPage;

        //
        //  Point to first Dirty Page Entry.
        //

        DirtyPage = NtfsGetFirstRestartTable( DirtyPageTable );

        //
        //  Loop to end of table.
        //

        while (DirtyPage != NULL) {

            //
            //  Update the Redo Lsn if this page has an older one.
            //

            if ((DirtyPage->OldestLsn.QuadPart != 0) &&
                (DirtyPage->OldestLsn.QuadPart < RedoLsn->QuadPart)) {

                *RedoLsn = DirtyPage->OldestLsn;
            }

            //
            //  Point to next entry in table, or NULL.
            //

            DirtyPage = NtfsGetNextRestartTable( DirtyPageTable,
                                                 DirtyPage );
        }
    }

    //
    //  Point to first Transaction Entry.
    //

    Transaction = NtfsGetFirstRestartTable( &Vcb->TransactionTable );

    //
    //  Loop to end of table.
    //

    while (Transaction != NULL) {

        //
        //  Update the Redo Lsn if this transaction has an older one.
        //

        if ((Transaction->FirstLsn.QuadPart != 0) &&
            (Transaction->FirstLsn.QuadPart < RedoLsn->QuadPart)) {

            *RedoLsn = Transaction->FirstLsn;
        }

        //
        //  Point to next entry in table, or NULL.
        //

        Transaction = NtfsGetNextRestartTable( &Vcb->TransactionTable,
                                               Transaction );
    }

    DebugTrace( 0, Dbg, ("RedoLsn > %016I64x\n", *RedoLsn) );
    DebugTrace( 0, Dbg, ("AnalysisPass -> VOID\n") );

    return;
}


//
//  Internal support routine
//

VOID
RedoPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LSN RedoLsn,
    IN OUT PRESTART_POINTERS DirtyPageTable
    )

/*++

Routine Description:

    This routine performs the Redo Pass of Restart.  Beginning at the
    Redo Lsn established during the Analysis Pass, the redo operations
    of all log records are applied, until the end of file is encountered.

    Updates are only applied to clusters in the dirty page table.  If a
    cluster was deleted, then its entry will have been deleted during the
    Analysis Pass.

    The Redo actions are all performed in the common routine DoAction,
    which is also used by the Undo Pass.

Arguments:

    Vcb - Volume which is being restarted.

    RedoLsn - Lsn at which the Redo Pass is to begin.

    DirtyPageTable - Pointer to the Dirty Page Table, as reconstructed
                     from the Analysis Pass.

Return Value:

    None.

--*/

{
    LFS_LOG_CONTEXT LogContext;
    PNTFS_LOG_RECORD_HEADER LogRecord;
    ULONG LogRecordLength;
    PVOID Data;
    ULONG Length;
    LFS_RECORD_TYPE RecordType;
    TRANSACTION_ID TransactionId;
    LSN UndoNextLsn;
    LSN PreviousLsn;
    ULONG i, SavedLength;

    LSN LogRecordLsn = RedoLsn;
    LFS_LOG_HANDLE LogHandle = Vcb->LogHandle;
    PBCB PageBcb = NULL;
    BOOLEAN GeneratedUsnBias = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("RedoPass:\n") );
    DebugTrace( 0, Dbg, ("RedoLsn = %016I64x\n", RedoLsn) );
    DebugTrace( 0, Dbg, ("DirtyPageTable = %08lx\n", DirtyPageTable) );

    //
    //  If the dirty page table is empty, then we can skip the entire Redo Pass.
    //

    if (IsRestartTableEmpty( DirtyPageTable )) {
        return;
    }

    //
    //  Read the record at the Redo Lsn, before falling into common code
    //  to handle each record.
    //

    LfsReadLogRecord( LogHandle,
                      RedoLsn,
                      LfsContextForward,
                      &LogContext,
                      &RecordType,
                      &TransactionId,
                      &UndoNextLsn,
                      &PreviousLsn,
                      &LogRecordLength,
                      (PVOID *)&LogRecord );

    //
    //  Now loop to read all of our log records forwards, until we hit
    //  the end of the file, cleaning up at the end.
    //

    try {

        do {

            PDIRTY_PAGE_ENTRY DirtyPage;
            PLSN PageLsn;
            BOOLEAN FoundPage;

            if (RecordType != LfsClientRecord) {
                continue;
            }

            //
            //  Check that the log record is valid.
            //

            if (!NtfsCheckLogRecord( LogRecord,
                                     LogRecordLength,
                                     TransactionId,
                                     Vcb->OatEntrySize )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            DebugTrace( 0, Dbg, ("Redo of LogRecord at: %08lx\n", LogRecord) );
            DebugTrace( 0, Dbg, ("Log Record Lsn = %016I64x\n", LogRecordLsn) );

            //
            //  Ignore log records that do not update pages.
            //

            if (LogRecord->LcnsToFollow == 0) {

                DebugTrace( 0, Dbg, ("Skipping log record (no update)\n") );

                continue;
            }

            //
            //  Consult Dirty Page Table to see if we have to apply this update.
            //  If the page is not there, or if the Lsn of this Log Record is
            //  older than the Lsn in the Dirty Page Table, then we do not have
            //  to apply the update.
            //

            FoundPage = FindDirtyPage( DirtyPageTable,
                                       LogRecord->TargetAttribute,
                                       LogRecord->TargetVcn,
                                       &DirtyPage );

            if (!FoundPage ||

                (LogRecordLsn.QuadPart < DirtyPage->OldestLsn.QuadPart)) {

                DebugDoit(

                    DebugTrace( 0, Dbg, ("Skipping log record operation %08lx\n",
                                         LogRecord->RedoOperation ));

                    if (!FoundPage) {
                        DebugTrace( 0, Dbg, ("Page not in dirty page table\n") );
                    } else {
                        DebugTrace( 0, Dbg, ("Page Lsn more current: %016I64x\n",
                                              DirtyPage->OldestLsn) );
                    }
                );

                continue;

            //
            //  We also skip the update if the entry was never put in the Mcb for
            //  the file.

            } else {

                POPEN_ATTRIBUTE_ENTRY ThisEntry;
                PSCB TargetScb;
                LCN TargetLcn;

                //
                //  Check that the entry is within the table and is allocated.
                //

                if (!IsRestartIndexWithinTable( Vcb->OnDiskOat,
                                                LogRecord->TargetAttribute )) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                ThisEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat, LogRecord->TargetAttribute );

                if (!IsRestartTableEntryAllocated( ThisEntry )) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                //
                //  Check if we need to go to a different restart table.
                //

                if (Vcb->RestartVersion == 0) {

                    ThisEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                          ((POPEN_ATTRIBUTE_ENTRY_V0) ThisEntry)->OatIndex );
                }

                TargetScb = ThisEntry->OatData->Overlay.Scb;

                //
                //  If there is no Scb it means that we don't have an entry in Open
                //  Attribute Table for this attribute.
                //

                if (TargetScb == NULL) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                if (!NtfsLookupNtfsMcbEntry( &TargetScb->Mcb,
                                             LogRecord->TargetVcn,
                                             &TargetLcn,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL ) ||

                    (TargetLcn == UNUSED_LCN)) {

                    DebugTrace( 0, Dbg, ("Clusters removed from page entry\n") );
                    continue;
                }

                //
                //  Check if we need to generate the usncachebias.
                //  Since we read log records fwd the usn offsets are also going to be
                //  monotonic - the 1st one we see will be the farthest back
                //

                if (FlagOn( TargetScb->ScbPersist, SCB_PERSIST_USN_JOURNAL ) &&
                    !GeneratedUsnBias) {

                    LONGLONG ClusterOffset;
                    LONGLONG FileOffset;

                    if (LogRecord->RedoLength > 0) {

                        ClusterOffset = BytesFromLogBlocks( LogRecord->ClusterBlockOffset );
                        FileOffset = LlBytesFromClusters( Vcb, LogRecord->TargetVcn ) + ClusterOffset;

                        ASSERT( FileOffset >= Vcb->UsnCacheBias );

                        Vcb->UsnCacheBias = FileOffset & ~(USN_JOURNAL_CACHE_BIAS - 1);
                        if (Vcb->UsnCacheBias != 0) {
                            Vcb->UsnCacheBias -= USN_JOURNAL_CACHE_BIAS;
                        }

#ifdef BENL_DBG
                        if (Vcb->UsnCacheBias != 0) {
                            KdPrint(( "Ntfs: vcb:0x%x restart cache bias: 0x%x\n", Vcb, Vcb->UsnCacheBias ));
                        }
#endif
                    }
                    GeneratedUsnBias = TRUE;
                }
            }

            //
            //  Point to the Redo Data and get its length.
            //

            Data = (PVOID)((PCHAR)LogRecord + LogRecord->RedoOffset);
            Length = LogRecord->RedoLength;

            //
            //  Shorten length by any Lcns which were deleted.
            //

            SavedLength = Length;

            for (i = (ULONG)LogRecord->LcnsToFollow; i != 0; i--) {

                ULONG AllocatedLength;
                ULONG VcnOffset;

                VcnOffset = BytesFromLogBlocks( LogRecord->ClusterBlockOffset ) + LogRecord->RecordOffset + LogRecord->AttributeOffset;

                //
                //  If the Vcn in question is allocated, we can just get out.
                //

                if (DirtyPage->LcnsForPage[((ULONG)LogRecord->TargetVcn) - ((ULONG)DirtyPage->Vcn) + i - 1] != 0) {
                    break;
                }

                //
                //  The only log records that update pages but have a length of zero
                //  are deleting things from Usa-protected structures.  If we hit such
                //  a log record and any Vcn has been deleted within the Usa structure,
                //  let us assume that the entire Usa structure has been deleted.  Change
                //  the SavedLength to be nonzero to cause us to skip this log record
                //  at the end of this for loop!
                //

                if (SavedLength == 0) {
                    SavedLength = 1;
                }

                //
                //  Calculate the allocated space left relative to the log record Vcn,
                //  after removing this unallocated Vcn.
                //

                AllocatedLength = BytesFromClusters( Vcb, i - 1 );

                //
                //  If the update described in this log record goes beyond the allocated
                //  space, then we will have to reduce the length.
                //

                if ((VcnOffset + Length) > AllocatedLength) {

                    //
                    //  If the specified update starts at or beyond the allocated length, then
                    //  we must set length to zero.
                    //

                    if (VcnOffset >= AllocatedLength) {

                        Length = 0;

                    //
                    //  Otherwise set the length to end exactly at the end of the previous
                    //  cluster.
                    //

                    } else {

                        Length = AllocatedLength - VcnOffset;
                    }
                }
            }

            //
            //  If the resulting Length from above is now zero, we can skip this log record.
            //

            if ((Length == 0) && (SavedLength != 0)) {
                continue;
            }

#ifdef BENL_DBG

            {
                PRESTART_LOG RedoLog;

                RedoLog = (PRESTART_LOG) NtfsAllocatePoolNoRaise( NonPagedPool, sizeof( RESTART_LOG ) );
                if (RedoLog) {
                    RedoLog->Lsn = LogRecordLsn;
                    InsertTailList( &(Vcb->RestartRedoHead), &(RedoLog->Links) );
                } else {
                    KdPrint(( "NTFS: out of memory during restart redo\n" ));
                }
            }
#endif

            //
            //  Apply the Redo operation in a common routine.
            //

            DoAction( IrpContext,
                      Vcb,
                      LogRecord,
                      LogRecord->RedoOperation,
                      Data,
                      Length,
                      LogRecordLength,
                      &LogRecordLsn,
                      NULL,
                      &PageBcb,
                      &PageLsn );


            if (PageLsn != NULL) {
                *PageLsn = LogRecordLsn;
            }

            if (PageBcb != NULL) {

                CcSetDirtyPinnedData( PageBcb, &LogRecordLsn );

                NtfsUnpinBcb( IrpContext, &PageBcb );
            }

        //
        //  Keep reading and looping back until end of file.
        //

        } while (LfsReadNextLogRecord( LogHandle,
                                       LogContext,
                                       &RecordType,
                                       &TransactionId,
                                       &UndoNextLsn,
                                       &PreviousLsn,
                                       &LogRecordLsn,
                                       &LogRecordLength,
                                       (PVOID *)&LogRecord ));

    } finally {

        NtfsUnpinBcb( IrpContext, &PageBcb );

        //
        //  Finally we can kill the log handle.
        //

        LfsTerminateLogQuery( LogHandle, LogContext );
    }

    DebugTrace( -1, Dbg, ("RedoPass -> VOID\n") );
}


//
//  Internal support routine
//

VOID
UndoPass (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine performs the Undo Pass of Restart.  It does this by scanning
    the Transaction Table produced by the Analysis Pass.  For every transaction
    in this table which is in the active state, all of its Undo log records, as
    linked together by the UndoNextLsn, are applied to undo the logged operation.
    Note that all pages at this point should be uptodate with the contents they
    had at about the time of the crash.  The dirty page table is not consulted
    during the Undo Pass, all relevant Undo operations are unconditionally
    performed.

    The Undo actions are all performed in the common routine DoAction,
    which is also used by the Redo Pass.

Arguments:

    Vcb - Volume which is being restarted.

Return Value:

    None.

--*/

{
    PTRANSACTION_ENTRY Transaction;
    POPEN_ATTRIBUTE_ENTRY OpenEntry;
    PRESTART_POINTERS TransactionTable = &Vcb->TransactionTable;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("UndoPass:\n") );

    //
    //  Point to first Transaction Entry.
    //

    Transaction = NtfsGetFirstRestartTable( TransactionTable );

    //
    //  Loop to end of table.
    //

    while (Transaction != NULL) {

        if ((Transaction->TransactionState == TransactionActive)

                &&

            (Transaction->UndoNextLsn.QuadPart != 0)) {

                //
                //  Abort transaction if it is active and has undo work to do.
                //

                NtfsAbortTransaction( IrpContext, Vcb, Transaction );

#ifdef BENL_DBG
                {
                    PRESTART_LOG UndoLog;

                    UndoLog = (PRESTART_LOG) NtfsAllocatePoolNoRaise( NonPagedPool, sizeof( RESTART_LOG ) );
                    if (UndoLog) {
                        UndoLog->Lsn = Transaction->FirstLsn;
                        InsertTailList( &(Vcb->RestartUndoHead), &(UndoLog->Links) );
                    } else {
                        KdPrint(( "NTFS: out of memory during restart undo\n" ));
                    }
                }
#endif


        //
        //  Remove this entry from the transaction table.
        //

        } else {

            TRANSACTION_ID TransactionId = GetIndexFromRestartEntry( &Vcb->TransactionTable,
                                                                     Transaction );

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                              TRUE );

            NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                       TransactionId );

            NtfsReleaseRestartTable( &Vcb->TransactionTable );
        }

        //
        //  Point to next entry in table, or NULL.
        //

        Transaction = NtfsGetNextRestartTable( TransactionTable, Transaction );
    }

    //
    //  Now we will flush and purge all the streams to verify that the purges
    //  will work.
    //

    OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

    //
    //  Loop to end of table.
    //

    while (OpenEntry != NULL) {

        IO_STATUS_BLOCK IoStatus;
        PSCB Scb;

        Scb = OpenEntry->OatData->Overlay.Scb;

        //
        //  We clean up the Scb only if it exists and this is index in the
        //  OpenAttributeTable that this Scb actually refers to.
        //  If this Scb has several entries in the table, this check will insure
        //  that it only gets cleaned up once.
        //

        if ((Scb != NULL) &&
            (Scb->NonpagedScb->OpenAttributeTableIndex == GetIndexFromRestartEntry( &Vcb->OpenAttributeTable, OpenEntry))) {

            //
            //  Now flush the file.  It is important to call the
            //  same routine the Lazy Writer calls, so that write.c
            //  will not decide to update file size for the attribute,
            //  since we really are working here with the wrong size.
            //
            //  We also now purge all pages, in case we go to update
            //  half of a page that was clean and read in as zeros in
            //  the Redo Pass.
            //

            NtfsPurgeFileRecordCache( IrpContext );

            NtfsAcquireScbForLazyWrite( (PVOID)Scb, TRUE );
            CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );
            NtfsReleaseScbFromLazyWrite( (PVOID)Scb );

            NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                &IoStatus.Status,
                                                TRUE,
                                                STATUS_UNEXPECTED_IO_ERROR );

            if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject, NULL, 0, FALSE )) {

                KdPrint(("NtfsUndoPass:  Unable to purge volume\n"));

                NtfsRaiseStatus( IrpContext, STATUS_INTERNAL_ERROR, NULL, NULL );
            }
        }

        //
        //  Point to next entry in table, or NULL.
        //

        OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                             OpenEntry );
    }

    DebugTrace( -1, Dbg, ("UndoPass -> VOID\n") );
}


//
//  Internal support routine
//

//
//  First define some "local" macros for Lsn in page manipulation.
//

//
//  Macro to check the Lsn and break (out of the switch statement in DoAction)
//  if the respective redo record need not be applied.  Note that if the structure's
//  clusters were deleted, then it will read as all zero's so we also check a field
//  which must be nonzero.
//

#define CheckLsn(PAGE) {                                                            \
    if (*(PULONG)((PMULTI_SECTOR_HEADER)(PAGE))->Signature ==                       \
        *(PULONG)BaadSignature) {                                                   \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                     \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
                                                                                    \
    if (ARGUMENT_PRESENT(RedoLsn) &&                                                \
        ((*(PULONG)((PMULTI_SECTOR_HEADER)(PAGE))->Signature ==                     \
        *(PULONG)HoleSignature) ||                                                  \
        (RedoLsn->QuadPart <= ((PFILE_RECORD_SEGMENT_HEADER)(PAGE))->Lsn.QuadPart))) {  \
                 /**** xxLeq(*RedoLsn,((PFILE_RECORD_SEGMENT_HEADER)(PAGE))->Lsn) ****/ \
        DebugTrace( 0, Dbg, ("Skipping Page with Lsn: %016I64x\n",                    \
                             ((PFILE_RECORD_SEGMENT_HEADER)(PAGE))->Lsn) );         \
                                                                                    \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  Macros for checking File Records and Index Buffers before and after the action
//  routines.  The after checks are only for debug.  The before check is not
//  always possible.
//

#define CheckFileRecordBefore {                                        \
    if (!NtfsCheckFileRecord( Vcb, FileRecord, NULL, &CorruptHint )) { \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                        \
        NtfsUnpinBcb( IrpContext, Bcb );                               \
        break;                                                         \
    }                                                                  \
}

#define CheckFileRecordAfter {                                            \
    DbgDoit(NtfsCheckFileRecord( Vcb, FileRecord, NULL, &CorruptHint ));  \
}

#define CheckIndexBufferBefore {                                    \
    if (!NtfsCheckIndexBuffer( Scb, IndexBuffer )) {                \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                     \
        NtfsUnpinBcb( IrpContext, Bcb );                            \
        break;                                                      \
    }                                                               \
}

#define CheckIndexBufferAfter {                                     \
    DbgDoit(NtfsCheckIndexBuffer( Scb, IndexBuffer ));              \
}

//
//  Checks if the record offset + length will fit into a file record.
//

#define CheckWriteFileRecord {                                                  \
    if (LogRecord->RecordOffset + Length > Vcb->BytesPerFileRecordSegment) {    \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                 \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  Checks if the record offset in the log record points to an attribute.
//

#define CheckIfAttribute( ENDOK ) {                                             \
    _Length = FileRecord->FirstAttributeOffset;                                 \
    _AttrHeader = Add2Ptr( FileRecord, _Length );                               \
    while (_Length < LogRecord->RecordOffset) {                                 \
        if ((_AttrHeader->TypeCode == $END) ||                                  \
            (_AttrHeader->RecordLength == 0)) {                                 \
            break;                                                              \
        }                                                                       \
        _Length += _AttrHeader->RecordLength;                                   \
        _AttrHeader = NtfsGetNextRecord( _AttrHeader );                         \
    }                                                                           \
    if ((_Length != LogRecord->RecordOffset) ||                                 \
        (!(ENDOK) && (_AttrHeader->TypeCode == $END))) {                        \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                 \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  Checks if the attribute described by 'Data' fits within the log record
//  and will fit in the file record.
//

#define CheckInsertAttribute {                                                  \
    _AttrHeader = (PATTRIBUTE_RECORD_HEADER) Data;                              \
    if ((Length < (ULONG) SIZEOF_RESIDENT_ATTRIBUTE_HEADER) ||                  \
        (_AttrHeader->RecordLength & 7) ||                                      \
        ((ULONG_PTR) Add2Ptr( Data, _AttrHeader->RecordLength )                 \
           > (ULONG_PTR) Add2Ptr( LogRecord, LogRecordLength )) ||              \
        (Length > FileRecord->BytesAvailable - FileRecord->FirstFreeByte)) {    \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                 \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  This checks
//      - the attribute fits if we are growing the attribute
//

#define CheckResidentFits {                                                         \
    _AttrHeader = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord, LogRecord->RecordOffset ); \
    _Length = LogRecord->AttributeOffset + Length;                                  \
    if ((LogRecord->RedoLength == LogRecord->UndoLength) ?                          \
        (LogRecord->AttributeOffset + Length > _AttrHeader->RecordLength) :         \
        ((_Length > _AttrHeader->RecordLength) &&                                   \
         ((_Length - _AttrHeader->RecordLength) >                                   \
          (FileRecord->BytesAvailable - FileRecord->FirstFreeByte)))) {             \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                     \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks that the data in this log record will fit into the
//  allocation described in the log record.
//

#define CheckNonResidentFits {                                                  \
    if (BytesFromClusters( Vcb, LogRecord->LcnsToFollow )                       \
        < (BytesFromLogBlocks( LogRecord->ClusterBlockOffset ) + LogRecord->RecordOffset + Length)) { \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                 \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  This routine checks
//      - the attribute is non-resident.
//      - the data is beyond the mapping pairs offset.
//      - the new data begins within the current size of the attribute.
//      - the new data will fit in the file record.
//

#define CheckMappingFits {                                                      \
    _AttrHeader = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord, LogRecord->RecordOffset );\
    _Length = LogRecord->AttributeOffset + Length;                              \
    if ((_AttrHeader->TypeCode == $END) ||                                      \
        NtfsIsAttributeResident( _AttrHeader ) ||                               \
        (LogRecord->AttributeOffset < _AttrHeader->Form.Nonresident.MappingPairsOffset) ||  \
        (LogRecord->AttributeOffset > _AttrHeader->RecordLength) ||             \
        ((_Length > _AttrHeader->RecordLength) &&                               \
         ((_Length - _AttrHeader->RecordLength) >                               \
          (FileRecord->BytesAvailable - FileRecord->FirstFreeByte)))) {         \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                 \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  This routine simply checks that the attribute is non-resident.
//

#define CheckIfNonResident {                                                        \
    if (NtfsIsAttributeResident( (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord,    \
                                                                     LogRecord->RecordOffset ))) { \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                     \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks if the record offset points to an index_root attribute.
//

#define CheckIfIndexRoot {                                                          \
    _Length = FileRecord->FirstAttributeOffset;                                     \
    _AttrHeader = Add2Ptr( FileRecord, FileRecord->FirstAttributeOffset );          \
    while (_Length < LogRecord->RecordOffset) {                                     \
        if ((_AttrHeader->TypeCode == $END) ||                                      \
            (_AttrHeader->RecordLength == 0)) {                                     \
            break;                                                                  \
        }                                                                           \
        _Length += _AttrHeader->RecordLength;                                       \
        _AttrHeader = NtfsGetNextRecord( _AttrHeader );                             \
    }                                                                               \
    if ((_Length != LogRecord->RecordOffset) ||                                     \
        (_AttrHeader->TypeCode != $INDEX_ROOT)) {                                   \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                     \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks if the attribute offset points to a valid index entry.
//

#define CheckIfRootIndexEntry {                                                     \
    _Length = PtrOffset( Attribute, IndexHeader ) +                                 \
                     IndexHeader->FirstIndexEntry;                                  \
    _CurrentEntry = Add2Ptr( IndexHeader, IndexHeader->FirstIndexEntry );           \
    while (_Length < LogRecord->AttributeOffset) {                                  \
        if ((_Length >= Attribute->RecordLength) ||                                 \
            (_CurrentEntry->Length == 0)) {                                         \
            break;                                                                  \
        }                                                                           \
        _Length += _CurrentEntry->Length;                                           \
        _CurrentEntry = Add2Ptr( _CurrentEntry, _CurrentEntry->Length );            \
    }                                                                               \
    if (_Length != LogRecord->AttributeOffset) {                                    \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                     \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks if the attribute offset points to a valid index entry.
//

#define CheckIfAllocationIndexEntry {                                               \
    ULONG _AdjustedOffset;                                                          \
    _Length = IndexHeader->FirstIndexEntry;                                         \
    _AdjustedOffset = FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, IndexHeader )          \
                      + IndexHeader->FirstIndexEntry;                               \
    _CurrentEntry = Add2Ptr( IndexHeader, IndexHeader->FirstIndexEntry );           \
    while (_AdjustedOffset < LogRecord->AttributeOffset) {                          \
        if ((_Length >= IndexHeader->FirstFreeByte) ||                              \
            (_CurrentEntry->Length == 0)) {                                         \
            break;                                                                  \
        }                                                                           \
        _AdjustedOffset += _CurrentEntry->Length;                                   \
        _Length += _CurrentEntry->Length;                                           \
        _CurrentEntry = Add2Ptr( _CurrentEntry, _CurrentEntry->Length );            \
    }                                                                               \
    if (_AdjustedOffset != LogRecord->AttributeOffset) {                            \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                     \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks if we can safely add this index entry.
//      - The index entry must be within the log record
//      - There must be enough space in the attribute to insert this.
//

#define CheckIfRootEntryFits {                                                      \
    if (((ULONG_PTR) Add2Ptr( Data, IndexEntry->Length ) > (ULONG_PTR) Add2Ptr( LogRecord, LogRecordLength )) || \
        (IndexEntry->Length > FileRecord->BytesAvailable - FileRecord->FirstFreeByte)) {                 \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                     \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine checks that we can safely add this index entry.
//      - The entry must be contained in a log record.
//      - The entry must fit in the index buffer.
//

#define CheckIfAllocationEntryFits {                                                \
    if (((ULONG_PTR) Add2Ptr( Data, IndexEntry->Length ) >                              \
         (ULONG_PTR) Add2Ptr( LogRecord, LogRecordLength )) ||                          \
        (IndexEntry->Length > IndexHeader->BytesAvailable - IndexHeader->FirstFreeByte)) { \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                     \
        NtfsUnpinBcb( IrpContext, Bcb );                                            \
        break;                                                                      \
    }                                                                               \
}

//
//  This routine will check that the data will fit in the tail of an index buffer.
//

#define CheckWriteIndexBuffer {                                                 \
    if (LogRecord->AttributeOffset + Length >                                   \
        (FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, IndexHeader ) +                 \
         IndexHeader->BytesAvailable)) {                                        \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                 \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

//
//  This routine verifies that the bitmap bits are contained in the Lcns described.
//

#define CheckBitmapRange {                                                      \
    if ((BytesFromLogBlocks( LogRecord->ClusterBlockOffset ) +                  \
         ((BitMapRange->BitMapOffset + BitMapRange->NumberOfBits + 7) / 8)) >   \
        BytesFromClusters( Vcb, LogRecord->LcnsToFollow )) {                    \
        NtfsMarkVolumeDirty( IrpContext, Vcb );                                 \
        NtfsUnpinBcb( IrpContext, Bcb );                                        \
        break;                                                                  \
    }                                                                           \
}

VOID
DoAction (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN NTFS_LOG_OPERATION Operation,
    IN PVOID Data,
    IN ULONG Length,
    IN ULONG LogRecordLength,
    IN PLSN RedoLsn OPTIONAL,
    IN PSCB Scb OPTIONAL,
    OUT PBCB *Bcb,
    OUT PLSN *PageLsn
    )

/*++

Routine Description:

    This routine is a common routine for the Redo and Undo Passes, for performing
    the respective redo and undo operations.  All Redo- and Undo-specific
    processing is performed in RedoPass or UndoPass; in this routine all actions
    are treated identically, regardless of whether the action is undo or redo.
    Note that most actions are possible for both redo and undo, although some
    are only used for one or the other.


    Basically this routine is just a big switch statement dispatching on operation
    code.  The parameter descriptions provide some insight on how some of the
    parameters must be initialized differently for redo or undo.

Arguments:

    Vcb - Vcb for the volume being restarted.

    LogRecord - Pointer to the log record from which Redo or Undo is being executed.
                Only the common fields are accessed.

    Operation - The Redo or Undo operation to be performed.

    Data - Pointer to the Redo or Undo buffer, depending on the caller.

    Length - Length of the Redo or Undo buffer.

    LogRecordLength - Length of the entire log record.

    RedoLsn - For Redo this must be the Lsn of the Log Record for which the
              redo is being applied.  Must be NULL for transaction abort/undo.

    Scb - If specified this is the Scb for the stream to which this log record
        applies.  We have already looked this up (with proper synchronization) in
        the abort path.

    Bcb - Returns the Bcb of the page to which the action was performed, or NULL.

    PageLsn - Returns a pointer to where a new Lsn may be stored, or NULL.

Return Value:

    None.

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;

    PINDEX_HEADER IndexHeader;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    PINDEX_ENTRY IndexEntry;

    //
    //  The following are used in the Check macros
    //

    PATTRIBUTE_RECORD_HEADER _AttrHeader;
    PINDEX_ENTRY _CurrentEntry;
    ULONG _Length;
    ULONG CorruptHint;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("DoAction:\n") );
    DebugTrace( 0, Dbg, ("Operation = %08lx\n", Operation) );
    DebugTrace( 0, Dbg, ("Data = %08lx\n", Data) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );

    //
    //  Initially clear outputs.
    //

    *Bcb = NULL;
    *PageLsn = NULL;

    //
    //  Dispatch to handle log record depending on type.
    //

    switch (Operation) {

    //
    //  To initialize a file record segment, we simply do a prepare write and copy the
    //  file record in.
    //

    case InitializeFileRecordSegment:

        //
        //  Check the log record and that the data is a valid file record.
        //

        CheckWriteFileRecord;

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        *PageLsn = &FileRecord->Lsn;

        RtlCopyMemory( FileRecord, Data, Length );
        break;

    //
    //  To deallocate a file record segment, we do a prepare write (no need to read it
    //  to deallocate it), and clear FILE_RECORD_SEGMENT_IN_USE.
    //

    case DeallocateFileRecordSegment:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        *PageLsn = &FileRecord->Lsn;

        ASSERT( FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||
                FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) );

        ClearFlag(FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE);

        FileRecord->SequenceNumber += 1;

        break;

    //
    //  To write the end of a file record segment, we calculate a pointer to the
    //  destination position (OldAttribute), and then call the routine to take
    //  care of it.
    //

    case WriteEndOfFileRecordSegment:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( TRUE );
        CheckWriteFileRecord;

        *PageLsn = &FileRecord->Lsn;

        Attribute = Add2Ptr( FileRecord, LogRecord->RecordOffset );

        NtfsRestartWriteEndOfFileRecord( FileRecord,
                                         Attribute,
                                         (PATTRIBUTE_RECORD_HEADER)Data,
                                         Length );
        CheckFileRecordAfter;

        break;

    //
    //  For Create Attribute, we read in the designated Mft record, and
    //  insert the attribute record from the log record.
    //

    case CreateAttribute:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( TRUE );
        CheckInsertAttribute;

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartInsertAttribute( IrpContext,
                                    FileRecord,
                                    LogRecord->RecordOffset,
                                    (PATTRIBUTE_RECORD_HEADER)Data,
                                    NULL,
                                    NULL,
                                    0 );

        CheckFileRecordAfter;

        break;

    //
    //  To Delete an attribute, we read the designated Mft record and make
    //  a call to remove the attribute record.
    //

    case DeleteAttribute:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( FALSE );

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartRemoveAttribute( IrpContext,
                                    FileRecord,
                                    LogRecord->RecordOffset );

        CheckFileRecordAfter;

        break;

    //
    //  To update a resident attribute, we read the designated Mft record and
    //  call the routine to change its value.
    //

    case UpdateResidentValue:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( FALSE );
        CheckResidentFits;

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartChangeValue( IrpContext,
                                FileRecord,
                                LogRecord->RecordOffset,
                                LogRecord->AttributeOffset,
                                Data,
                                Length,
                                (BOOLEAN)((LogRecord->RedoLength !=
                                           LogRecord->UndoLength) ?
                                             TRUE : FALSE) );

        CheckFileRecordAfter;

        break;

    //
    //  To update a nonresident value, we simply pin the attribute and copy
    //  the data in.  Log record will limit us to a page at a time.
    //

    case UpdateNonresidentValue:

        {
            PVOID Buffer;

            //
            //  Pin the desired index buffer, and check the Lsn.
            //

            ASSERT( Length <= PAGE_SIZE );

            PinAttributeForRestart( IrpContext,
                                    Vcb,
                                    LogRecord,
                                    Length,
                                    Bcb,
                                    &Buffer,
                                    &Scb );

            CheckNonResidentFits;
            RtlCopyMemory( (PCHAR)Buffer + LogRecord->RecordOffset, Data, Length );

            break;
        }

    //
    //  To update the mapping pairs in a nonresident attribute, we read the
    //  designated Mft record and call the routine to change them.
    //

    case UpdateMappingPairs:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfAttribute( FALSE );
        CheckMappingFits;

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartChangeMapping( IrpContext,
                                  Vcb,
                                  FileRecord,
                                  LogRecord->RecordOffset,
                                  LogRecord->AttributeOffset,
                                  Data,
                                  Length );

        CheckFileRecordAfter;

        break;

    //
    //  To set new attribute sizes, we read the designated Mft record, point
    //  to the attribute, and copy in the new sizes.
    //

    case SetNewAttributeSizes:

        {
            PNEW_ATTRIBUTE_SIZES Sizes;

            //
            //  Pin the desired Mft record.
            //

            PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

            CheckLsn( FileRecord );
            CheckFileRecordBefore;
            CheckIfAttribute( FALSE );
            CheckIfNonResident;

            *PageLsn = &FileRecord->Lsn;

            Sizes = (PNEW_ATTRIBUTE_SIZES)Data;

            Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord +
                          LogRecord->RecordOffset);

            NtfsVerifySizesLongLong( Sizes );
            Attribute->Form.Nonresident.AllocatedLength = Sizes->AllocationSize;

            Attribute->Form.Nonresident.FileSize = Sizes->FileSize;

            Attribute->Form.Nonresident.ValidDataLength = Sizes->ValidDataLength;

            if (Length >= SIZEOF_FULL_ATTRIBUTE_SIZES) {

                Attribute->Form.Nonresident.TotalAllocated = Sizes->TotalAllocated;
            }

            CheckFileRecordAfter;

            break;
        }

    //
    //  To insert a new index entry in the root, we read the designated Mft
    //  record, point to the attribute and the insertion point, and call the
    //  same routine used in normal operation.
    //

    case AddIndexEntryRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord +
                      LogRecord->RecordOffset);

        IndexEntry = (PINDEX_ENTRY)Data;
        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;

        CheckIfRootIndexEntry;
        CheckIfRootEntryFits;

        *PageLsn = &FileRecord->Lsn;

        NtfsRestartInsertSimpleRoot( IrpContext,
                                     IndexEntry,
                                     FileRecord,
                                     Attribute,
                                     Add2Ptr( Attribute, LogRecord->AttributeOffset ));

        CheckFileRecordAfter;

        break;

    //
    //  To insert a new index entry in the root, we read the designated Mft
    //  record, point to the attribute and the insertion point, and call the
    //  same routine used in normal operation.
    //

    case DeleteIndexEntryRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord +
                      LogRecord->RecordOffset);

        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;
        CheckIfRootIndexEntry;

        *PageLsn = &FileRecord->Lsn;

        IndexEntry = (PINDEX_ENTRY) Add2Ptr( Attribute,
                                             LogRecord->AttributeOffset);

        NtfsRestartDeleteSimpleRoot( IrpContext,
                                     IndexEntry,
                                     FileRecord,
                                     Attribute );

        CheckFileRecordAfter;

        break;

    //
    //  To insert a new index entry in the allocation, we read the designated index
    //  buffer, point to the insertion point, and call the same routine used in
    //  normal operation.
    //

    case AddIndexEntryAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexEntry = (PINDEX_ENTRY)Data;
        IndexHeader = &IndexBuffer->IndexHeader;

        CheckIfAllocationIndexEntry;
        CheckIfAllocationEntryFits;

        *PageLsn = &IndexBuffer->Lsn;

        NtfsRestartInsertSimpleAllocation( IndexEntry,
                                           IndexBuffer,
                                           Add2Ptr( IndexBuffer, LogRecord->AttributeOffset ));

        CheckIndexBufferAfter;

        break;

    //
    //  To delete an index entry in the allocation, we read the designated index
    //  buffer, point to the deletion point, and call the same routine used in
    //  normal operation.
    //

    case DeleteIndexEntryAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)IndexBuffer + LogRecord->AttributeOffset);

        ASSERT( (0 == Length) || (Length == IndexEntry->Length) );
        ASSERT( (0 == Length) || (0 == RtlCompareMemory( IndexEntry, Data, Length)) );

        *PageLsn = &IndexBuffer->Lsn;

        NtfsRestartDeleteSimpleAllocation( IndexEntry, IndexBuffer );

        CheckIndexBufferAfter;

        break;

    case WriteEndOfIndexBuffer:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;
        CheckWriteIndexBuffer;

        *PageLsn = &IndexBuffer->Lsn;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)IndexBuffer + LogRecord->AttributeOffset);

        NtfsRestartWriteEndOfIndex( IndexHeader,
                                    IndexEntry,
                                    (PINDEX_ENTRY)Data,
                                    Length );
        CheckIndexBufferAfter;

        break;

    //
    //  To set a new index entry Vcn in the root, we read the designated Mft
    //  record, point to the attribute and the index entry, and call the
    //  same routine used in normal operation.
    //

    case SetIndexEntryVcnRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord, LogRecord->RecordOffset );

        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;

        CheckIfRootIndexEntry;

        *PageLsn = &FileRecord->Lsn;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)Attribute +
                       LogRecord->AttributeOffset);

        NtfsRestartSetIndexBlock( IndexEntry,
                                  *((PLONGLONG) Data) );
        CheckFileRecordAfter;

        break;

    //
    //  To set a new index entry Vcn in the allocation, we read the designated index
    //  buffer, point to the index entry, and call the same routine used in
    //  normal operation.
    //

    case SetIndexEntryVcnAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;

        *PageLsn = &IndexBuffer->Lsn;

        IndexEntry = (PINDEX_ENTRY) Add2Ptr( IndexBuffer, LogRecord->AttributeOffset );

        NtfsRestartSetIndexBlock( IndexEntry,
                                  *((PLONGLONG) Data) );
        CheckIndexBufferAfter;

        break;

    //
    //  To update a file name in the root, we read the designated Mft
    //  record, point to the attribute and the index entry, and call the
    //  same routine used in normal operation.
    //

    case UpdateFileNameRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord, LogRecord->RecordOffset );

        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;
        CheckIfRootIndexEntry;

        IndexEntry = (PINDEX_ENTRY) Add2Ptr( Attribute, LogRecord->AttributeOffset );

        NtfsRestartUpdateFileName( IndexEntry,
                                   (PDUPLICATED_INFORMATION) Data );

        CheckFileRecordAfter;

        break;

    //
    //  To update a file name in the allocation, we read the designated index
    //  buffer, point to the index entry, and call the same routine used in
    //  normal operation.
    //

    case UpdateFileNameAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;

        IndexEntry = (PINDEX_ENTRY) Add2Ptr( IndexBuffer, LogRecord->AttributeOffset );

        NtfsRestartUpdateFileName( IndexEntry,
                                   (PDUPLICATED_INFORMATION) Data );

        CheckIndexBufferAfter;

        break;

    //
    //  To set a range of bits in the volume bitmap, we just read in the a hunk
    //  of the bitmap as described by the log record, and then call the restart
    //  routine to do it.
    //

    case SetBitsInNonresidentBitMap:

        {
            PBITMAP_RANGE BitMapRange;
            PVOID BitMapBuffer;
            ULONG BitMapSize;
            RTL_BITMAP Bitmap;

            //
            //  Open the attribute first to get the Scb.
            //

            OpenAttributeForRestart( IrpContext, Vcb, LogRecord, &Scb );

            //
            //  Pin the desired bitmap buffer.
            //

            ASSERT( Length <= PAGE_SIZE );

            PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, &BitMapBuffer, &Scb );

            BitMapRange = (PBITMAP_RANGE)Data;

            CheckBitmapRange;

            //
            //  Initialize our bitmap description, and call the restart
            //  routine with the bitmap Scb exclusive (assuming it cannot
            //  raise).
            //

            BitMapSize = BytesFromClusters( Vcb, LogRecord->LcnsToFollow ) * 8;

            RtlInitializeBitMap( &Bitmap, BitMapBuffer, BitMapSize );

            NtfsRestartSetBitsInBitMap( IrpContext,
                                        &Bitmap,
                                        BitMapRange->BitMapOffset,
                                        BitMapRange->NumberOfBits );

            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                (Scb == Vcb->BitmapScb)) {

                ULONGLONG ThisLcn;
                LONGLONG FoundLcn;
                LONGLONG FoundClusters;
                BOOLEAN FoundMatch = FALSE;
                PDEALLOCATED_CLUSTERS Clusters;

                ThisLcn = (ULONGLONG) ((BytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset )) * 8);
                ThisLcn += BitMapRange->BitMapOffset;

                //
                //  Best odds are that these are in the active deallocated clusters.
                //

                Clusters = (PDEALLOCATED_CLUSTERS)Vcb->DeallocatedClusterListHead.Flink;

                do {

                    if (FsRtlLookupLargeMcbEntry( &Clusters->Mcb,
                                                  ThisLcn,
                                                  &FoundLcn,
                                                  &FoundClusters,
                                                  NULL,
                                                  NULL,
                                                  NULL ) &&
                        (FoundLcn != UNUSED_LCN)) {

                        ASSERT( FoundClusters >= BitMapRange->NumberOfBits );

                        FsRtlRemoveLargeMcbEntry( &Clusters->Mcb,
                                                  ThisLcn,
                                                  BitMapRange->NumberOfBits );

                        //
                        //  Assume again that we will always be able to remove
                        //  the entries.  Even if we don't it just means that it won't be
                        //  available to allocate this cluster.  The counts should be in-sync
                        //  since they are changed together.
                        //

                        Clusters->ClusterCount -= BitMapRange->NumberOfBits;
                        Vcb->DeallocatedClusters -= BitMapRange->NumberOfBits;
                        FoundMatch = TRUE;
                        break;
                    }

                    Clusters = (PDEALLOCATED_CLUSTERS)Clusters->Link.Flink;
                } while ( &Clusters->Link != &Vcb->DeallocatedClusterListHead );
            }

#ifdef NTFS_CHECK_BITMAP
            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                (Scb == Vcb->BitmapScb) &&
                (Vcb->BitmapCopy != NULL)) {

                ULONG BitmapOffset;
                ULONG BitmapPage;
                ULONG StartBit;

                BitmapOffset = (BytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset )) * 8;

                BitmapPage = (BitmapOffset + BitMapRange->BitMapOffset) / (PAGE_SIZE * 8);
                StartBit = (BitmapOffset + BitMapRange->BitMapOffset) & ((PAGE_SIZE * 8) - 1);

                RtlSetBits( Vcb->BitmapCopy + BitmapPage, StartBit, BitMapRange->NumberOfBits );
            }
#endif

            break;
        }

    //
    //  To clear a range of bits in the volume bitmap, we just read in the a hunk
    //  of the bitmap as described by the log record, and then call the restart
    //  routine to do it.
    //

    case ClearBitsInNonresidentBitMap:

        {
            PBITMAP_RANGE BitMapRange;
            PVOID BitMapBuffer;
            ULONG BitMapSize;
            RTL_BITMAP Bitmap;

            //
            //  Open the attribute first to get the Scb.
            //

            OpenAttributeForRestart( IrpContext, Vcb, LogRecord, &Scb );

            //
            //  Pin the desired bitmap buffer.
            //

            ASSERT( Length <= PAGE_SIZE );

            PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, &BitMapBuffer, &Scb );

            BitMapRange = (PBITMAP_RANGE)Data;

            CheckBitmapRange;

            BitMapSize = BytesFromClusters( Vcb, LogRecord->LcnsToFollow ) * 8;

            //
            //  Initialize our bitmap description, and call the restart
            //  routine with the bitmap Scb exclusive (assuming it cannot
            //  raise).
            //

            RtlInitializeBitMap( &Bitmap, BitMapBuffer, BitMapSize );

            NtfsRestartClearBitsInBitMap( IrpContext,
                                          &Bitmap,
                                          BitMapRange->BitMapOffset,
                                          BitMapRange->NumberOfBits );

            //
            //  Look and see if we can return these to the free cluster Mcb.
            //

            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                (Scb == Vcb->BitmapScb)) {

                ULONGLONG ThisLcn;

                ThisLcn = (ULONGLONG) ((BytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset )) * 8);
                ThisLcn += BitMapRange->BitMapOffset;

                //
                //  Use a try-finally to protect against failures.
                //

                try {

                    NtfsAddCachedRun( IrpContext,
                                      IrpContext->Vcb,
                                      ThisLcn,
                                      BitMapRange->NumberOfBits,
                                      RunStateFree );

                } except( (GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES) ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH ) {

                      NtfsMinimumExceptionProcessing( IrpContext );

                }
            }

#ifdef NTFS_CHECK_BITMAP
            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                (Scb == Vcb->BitmapScb) &&
                (Vcb->BitmapCopy != NULL)) {

                ULONG BitmapOffset;
                ULONG BitmapPage;
                ULONG StartBit;

                BitmapOffset = (BytesFromClusters( Vcb, LogRecord->TargetVcn ) + BytesFromLogBlocks( LogRecord->ClusterBlockOffset )) * 8;

                BitmapPage = (BitmapOffset + BitMapRange->BitMapOffset) / (PAGE_SIZE * 8);
                StartBit = (BitmapOffset + BitMapRange->BitMapOffset) & ((PAGE_SIZE * 8) - 1);

                RtlClearBits( Vcb->BitmapCopy + BitmapPage, StartBit, BitMapRange->NumberOfBits );
            }
#endif
            break;
        }

    //
    //  To update a file name in the root, we read the designated Mft
    //  record, point to the attribute and the index entry, and call the
    //  same routine used in normal operation.
    //

    case UpdateRecordDataRoot:

        //
        //  Pin the desired Mft record.
        //

        PinMftRecordForRestart( IrpContext, Vcb, LogRecord, Bcb, &FileRecord );

        CheckLsn( FileRecord );
        CheckFileRecordBefore;
        CheckIfIndexRoot;

        Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord +
                      LogRecord->RecordOffset);

        IndexHeader = &((PINDEX_ROOT) NtfsAttributeValue( Attribute ))->IndexHeader;
        CheckIfRootIndexEntry;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)Attribute +
                       LogRecord->AttributeOffset);

        NtOfsRestartUpdateDataInIndex( IndexEntry, Data, Length );

        CheckFileRecordAfter;

        break;

    //
    //  To update a file name in the allocation, we read the designated index
    //  buffer, point to the index entry, and call the same routine used in
    //  normal operation.
    //

    case UpdateRecordDataAllocation:

        //
        //  Pin the desired index buffer, and check the Lsn.
        //

        ASSERT( Length <= PAGE_SIZE );

        PinAttributeForRestart( IrpContext, Vcb, LogRecord, 0, Bcb, (PVOID *)&IndexBuffer, &Scb );

        CheckLsn( IndexBuffer );
        CheckIndexBufferBefore;

        IndexHeader = &IndexBuffer->IndexHeader;
        CheckIfAllocationIndexEntry;

        IndexEntry = (PINDEX_ENTRY)((PCHAR)IndexBuffer +
                       LogRecord->AttributeOffset);

        NtOfsRestartUpdateDataInIndex( IndexEntry, Data, Length );

        CheckIndexBufferAfter;

        break;

    //
    //  The following cases require no action during the Redo or Undo Pass.
    //

    case Noop:
    case DeleteDirtyClusters:
    case HotFix:
    case EndTopLevelAction:
    case PrepareTransaction:
    case CommitTransaction:
    case ForgetTransaction:
    case CompensationLogRecord:
    case OpenNonresidentAttribute:
    case OpenAttributeTableDump:
    case AttributeNamesDump:
    case DirtyPageTableDump:
    case TransactionTableDump:

        break;

    //
    //  All codes will be explicitly handled.  If we see a code we
    //  do not expect, then we are in trouble.
    //

    default:

        DebugTrace( 0, Dbg, ("Record address: %08lx\n", LogRecord) );
        DebugTrace( 0, Dbg, ("Redo operation is: %04lx\n", LogRecord->RedoOperation) );
        DebugTrace( 0, Dbg, ("Undo operation is: %04lx\n", LogRecord->RedoOperation) );

        ASSERTMSG( "Unknown Action!\n", FALSE );

        break;
    }

    DebugDoit(
        if (*Bcb != NULL) {
            DebugTrace( 0, Dbg, ("**** Update applied\n") );
        }
    );

    DebugTrace( 0, Dbg, ("Bcb > %08lx\n", *Bcb) );
    DebugTrace( 0, Dbg, ("PageLsn > %08lx\n", *PageLsn) );
    DebugTrace( -1, Dbg, ("DoAction -> VOID\n") );
}


//
//  Internal support routine
//

VOID
PinMftRecordForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord
    )

/*++

Routine Description:

    This routine pins a record in the Mft for restart, as described
    by the current log record.

Arguments:

    Vcb - Supplies the Vcb pointer for the volume

    LogRecord - Supplies the pointer to the current log record.

    Bcb - Returns a pointer to the Bcb for the pinned record.

    FileRecord - Returns a pointer to the desired file record.

Return Value:

    None

--*/

{
    LONGLONG SegmentReference;

    PAGED_CODE();

    //
    //  Calculate the file number part of the segment reference.  Do this
    //  by obtaining the file offset of the file record and then convert to
    //  a file number.
    //

    SegmentReference = LlBytesFromClusters( Vcb, LogRecord->TargetVcn );
    SegmentReference += BytesFromLogBlocks( LogRecord->ClusterBlockOffset );
    SegmentReference = LlFileRecordsFromBytes( Vcb, SegmentReference );

    //
    //  Pin the Mft record.
    //

    NtfsPinMftRecord( IrpContext,
                      Vcb,
                      (PMFT_SEGMENT_REFERENCE)&SegmentReference,
                      TRUE,
                      Bcb,
                      FileRecord,
                      NULL );

    ASSERT( (*FileRecord)->MultiSectorHeader.Signature !=  BaadSignature );
}


//
//  Internal support routine
//

VOID
OpenAttributeForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN OUT PSCB *Scb
    )

/*++

Routine Description:

    This routine opens the desired attribute for restart, as described
    by the current log record.

Arguments:

    Vcb - Supplies the Vcb pointer for the volume

    LogRecord - Supplies the pointer to the current log record.

    Scb - On input points to an optional Scb.  On return it points to
        the Scb for the log record.  It is either the input Scb if specified
        or the Scb for the attribute entry.

Return Value:

    None

--*/

{
    POPEN_ATTRIBUTE_ENTRY AttributeEntry;

    PAGED_CODE();

    //
    //  Get a pointer to the attribute entry for the described attribute.
    //

    if (*Scb == NULL) {

        AttributeEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat, LogRecord->TargetAttribute );

        //
        //  Check if want to go to the other table.
        //

        if (Vcb->RestartVersion == 0) {

            AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                       ((POPEN_ATTRIBUTE_ENTRY_V0) AttributeEntry)->OatIndex );

        }

        *Scb = AttributeEntry->OatData->Overlay.Scb;
    }

    if ((*Scb)->FileObject == NULL) {
        NtfsCreateInternalAttributeStream( IrpContext, *Scb, TRUE, NULL );

        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )) {

            CcSetAdditionalCacheAttributes( (*Scb)->FileObject, TRUE, TRUE );
        }
    }

    return;
}


//
//  Internal support routine
//

VOID
PinAttributeForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN ULONG Length OPTIONAL,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN OUT PSCB *Scb
    )

/*++

Routine Description:

    This routine pins the desired buffer for restart, as described
    by the current log record.

Arguments:

    Vcb - Supplies the Vcb pointer for the volume

    LogRecord - Supplies the pointer to the current log record.

    Length - If specified we will use this to determine the length
        to pin.  This will handle the non-resident streams which may
        change size (ACL, attribute lists).  The log record may have
        more clusters than are currently in the stream.

    Bcb - Returns a pointer to the Bcb for the pinned record.

    Buffer - Returns a pointer to the desired buffer.

    Scb - Returns a pointer to the Scb for the attribute

Return Value:

    None

--*/

{
    LONGLONG FileOffset;
    ULONG ClusterOffset;
    ULONG PinLength;

    PAGED_CODE();

    //
    //  First open the described atttribute.
    //

    OpenAttributeForRestart( IrpContext, Vcb, LogRecord, Scb );

    //
    //  Calculate the desired file offset and pin the buffer.
    //

    ClusterOffset = BytesFromLogBlocks( LogRecord->ClusterBlockOffset );
    FileOffset = LlBytesFromClusters( Vcb, LogRecord->TargetVcn ) + ClusterOffset;

    ASSERT((!FlagOn( (*Scb)->ScbPersist, SCB_PERSIST_USN_JOURNAL )) || (FileOffset >= Vcb->UsnCacheBias));

    //
    //  We only want to pin the requested clusters or to the end of
    //  a page, whichever is smaller.
    //

    if (Vcb->BytesPerCluster > PAGE_SIZE) {

        PinLength = PAGE_SIZE - (((ULONG) FileOffset) & (PAGE_SIZE - 1));

    } else if (Length != 0) {

        PinLength = Length;

    } else {

        PinLength = BytesFromClusters( Vcb, LogRecord->LcnsToFollow ) - ClusterOffset;
    }

    //
    //  We don't want to pin more than a page
    //

    NtfsPinStream( IrpContext,
                   *Scb,
                   FileOffset,
                   PinLength,
                   Bcb,
                   Buffer );

#if DBG

    //
    //  Check index signature integrity
    //

    {
        PVOID AlignedBuffer;
        PINDEX_ALLOCATION_BUFFER AllocBuffer;

        AlignedBuffer = (PVOID) BlockAlignTruncate( (ULONG_PTR)(*Buffer),  0x1000 );
        AllocBuffer = (PINDEX_ALLOCATION_BUFFER) AlignedBuffer;

        if ((LogRecord->RedoOperation != UpdateNonresidentValue) &&
            (LogRecord->UndoOperation != UpdateNonresidentValue) &&
            ((*Scb)->AttributeTypeCode == $INDEX_ALLOCATION) &&
            ((*Scb)->AttributeName.Length == 8) &&
            (wcsncmp( (*Scb)->AttributeName.Buffer, L"$I30", 4 ) == 0)) {

            if (*(PULONG)AllocBuffer->MultiSectorHeader.Signature != *(PULONG)IndexSignature) {
                KdPrint(( "Ntfs: index signature is: %d %c%c%c%c for LCN: 0x%I64x\n",
                          *(PULONG)AllocBuffer->MultiSectorHeader.Signature,
                          AllocBuffer->MultiSectorHeader.Signature[0],
                          AllocBuffer->MultiSectorHeader.Signature[1],
                          AllocBuffer->MultiSectorHeader.Signature[2],
                          AllocBuffer->MultiSectorHeader.Signature[3],
                          LogRecord->LcnsForPage[0] ));

                if (*(PULONG)AllocBuffer->MultiSectorHeader.Signature != 0 &&
                    *(PULONG)AllocBuffer->MultiSectorHeader.Signature != *(PULONG)BaadSignature &&
                    *(PULONG)AllocBuffer->MultiSectorHeader.Signature != *(PULONG)HoleSignature) {

                    DbgBreakPoint();
                }
            } //endif signature fork
        } //endif index scb fork
    }
#endif

}


//
//  Internal support routine
//

BOOLEAN
FindDirtyPage (
    IN PRESTART_POINTERS DirtyPageTable,
    IN ULONG TargetAttribute,
    IN VCN Vcn,
    OUT PDIRTY_PAGE_ENTRY *DirtyPageEntry
    )

/*++

Routine Description:

    This routine searches for a Vcn to see if it is already in the Dirty Page
    Table, returning the Dirty Page Entry if it is.

Arguments:

    DirtyPageTable - pointer to the Dirty Page Table to search.

    TargetAttribute - Attribute for which the dirty Vcn is to be searched.

    Vcn - Vcn to search for.

    DirtyPageEntry - returns a pointer to the Dirty Page Entry if returning TRUE.

Return Value:

    TRUE if the page was found and is being returned, else FALSE.

--*/

{
    PDIRTY_PAGE_ENTRY DirtyPage;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("FindDirtyPage:\n") );
    DebugTrace( 0, Dbg, ("TargetAttribute = %08lx\n", TargetAttribute) );
    DebugTrace( 0, Dbg, ("Vcn = %016I64x\n", Vcn) );

    //
    //  If table has not yet been initialized, return.
    //

    if (DirtyPageTable->Table == NULL) {
        return FALSE;
    }

    //
    //  Loop through all of the dirty pages to look for a match.
    //

    DirtyPage = NtfsGetFirstRestartTable( DirtyPageTable );

    //
    //  Loop to end of table.
    //

    while (DirtyPage != NULL) {

        if ((DirtyPage->TargetAttribute == TargetAttribute)

                &&

            (Vcn >= DirtyPage->Vcn)) {

            //
            //  Compute the Last Vcn outside of the comparison or the xxAdd and
            //  xxFromUlong will be called three times.
            //

            LONGLONG BeyondLastVcn;

            BeyondLastVcn = DirtyPage->Vcn + DirtyPage->LcnsToFollow;

            if (Vcn < BeyondLastVcn) {

                *DirtyPageEntry = DirtyPage;

                DebugTrace( 0, Dbg, ("DirtyPageEntry %08lx\n", *DirtyPageEntry) );
                DebugTrace( -1, Dbg, ("FindDirtypage -> TRUE\n") );

                return TRUE;
            }
        }

        //
        //  Point to next entry in table, or NULL.
        //

        DirtyPage = NtfsGetNextRestartTable( DirtyPageTable,
                                             DirtyPage );
    }
    *DirtyPageEntry = NULL;

    DebugTrace( -1, Dbg, ("FindDirtypage -> FALSE\n") );

    return FALSE;
}



//
//  Internal support routine
//

VOID
PageUpdateAnalysis (
    IN PVCB Vcb,
    IN LSN Lsn,
    IN OUT PRESTART_POINTERS DirtyPageTable,
    IN PNTFS_LOG_RECORD_HEADER LogRecord
    )

/*++

Routine Description:

    This routine updates the Dirty Pages Table during the analysis phase
    for all log records which update a page.

Arguments:

    Vcb - Pointer to the Vcb for the volume.

    Lsn - The Lsn of the log record.

    DirtyPageTable - A pointer to the Dirty Page Table pointer, to be
                     updated and potentially expanded.

    LogRecord - Pointer to the Log Record being analyzed.

Return Value:

    None.

--*/

{
    PDIRTY_PAGE_ENTRY DirtyPage;
    ULONG i;
    RESTART_POINTERS NewDirtyPageTable;
    ULONG ClustersPerPage;
    ULONG PageIndex;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("PageUpdateAnalysis:\n") );

    //
    //  Calculate the number of clusters per page in the system which wrote
    //  the checkpoint, possibly creating the table.
    //

    if (DirtyPageTable->Table != NULL) {
        ClustersPerPage = ((DirtyPageTable->Table->EntrySize -
                            sizeof(DIRTY_PAGE_ENTRY)) / sizeof(LCN)) + 1;
    } else {
        ClustersPerPage = Vcb->ClustersPerPage;
        NtfsInitializeRestartTable( sizeof(DIRTY_PAGE_ENTRY) +
                                      (ClustersPerPage - 1) * sizeof(LCN),
                                    INITIAL_NUMBER_DIRTY_PAGES,
                                    DirtyPageTable );
    }

    //
    //  If the on disk number of lcns doesn't match our curent page size
    //  we need to reallocate the entire table to accomodate this
    //

    if((ULONG)LogRecord->LcnsToFollow > ClustersPerPage) {

        PDIRTY_PAGE_ENTRY OldDirtyPage;

        DebugTrace( +1, Dbg, ("Ntfs: resizing table in pageupdateanalysis\n") );

        //
        //  Adjust clusters per page up to the number of clusters in this record
        //

        ClustersPerPage = (ULONG)LogRecord->LcnsToFollow;

        ASSERT( DirtyPageTable->Table->NumberEntries >= INITIAL_NUMBER_DIRTY_PAGES );

        NtfsInitializeRestartTable( sizeof(DIRTY_PAGE_ENTRY) +
                                      (ClustersPerPage - 1) * sizeof(LCN),
                                    DirtyPageTable->Table->NumberEntries,
                                    &NewDirtyPageTable );

        OldDirtyPage = (PDIRTY_PAGE_ENTRY) NtfsGetFirstRestartTable( DirtyPageTable );

        //
        //  Loop to copy table entries
        //

        while (OldDirtyPage) {

            //
            //  Allocate a new dirty page entry.
            //

            PageIndex = NtfsAllocateRestartTableIndex( &NewDirtyPageTable, TRUE );

            //
            //  Get a pointer to the entry we just allocated.
            //

            DirtyPage = GetRestartEntryFromIndex( &NewDirtyPageTable, PageIndex );

            DirtyPage->TargetAttribute = OldDirtyPage->TargetAttribute;
            DirtyPage->LengthOfTransfer = BytesFromClusters( Vcb, ClustersPerPage );
            DirtyPage->LcnsToFollow = ClustersPerPage;
            
            DirtyPage->Vcn = BlockAlignTruncate( OldDirtyPage->Vcn, (LONG)ClustersPerPage );
            DirtyPage->OldestLsn = OldDirtyPage->OldestLsn;

            for (i = 0; i < OldDirtyPage->LcnsToFollow; i++) {
                DirtyPage->LcnsForPage[i] = OldDirtyPage->LcnsForPage[i];
            }

            OldDirtyPage = (PDIRTY_PAGE_ENTRY) NtfsGetNextRestartTable( DirtyPageTable, OldDirtyPage );
        }

        //
        //  OldTable is really on the stack so swap the new restart table into it
        //  and free up the old one and the rest of the new restart pointers
        //

        NtfsFreePool( DirtyPageTable->Table );
        DirtyPageTable->Table = NewDirtyPageTable.Table;
        NewDirtyPageTable.Table = NULL;
        NtfsFreeRestartTable( &NewDirtyPageTable );
    }  //  endif table needed to be resized

    //
    //  Update the dirty page entry or create a new one
    //

    if (!FindDirtyPage( DirtyPageTable,
                        LogRecord->TargetAttribute,
                        LogRecord->TargetVcn,
                        &DirtyPage )) {

        //
        //  Allocate a dirty page entry.
        //

        PageIndex = NtfsAllocateRestartTableIndex( DirtyPageTable, TRUE );

        //
        //  Get a pointer to the entry we just allocated.
        //

        DirtyPage = GetRestartEntryFromIndex( DirtyPageTable, PageIndex );

        //
        //  Initialize the dirty page entry.
        //

        DirtyPage->TargetAttribute = LogRecord->TargetAttribute;
        DirtyPage->LengthOfTransfer = BytesFromClusters( Vcb, ClustersPerPage );
        DirtyPage->LcnsToFollow = ClustersPerPage;
        DirtyPage->Vcn = BlockAlignTruncate( LogRecord->TargetVcn, (LONG)ClustersPerPage );
        DirtyPage->OldestLsn = Lsn;
    }

    //
    //  Copy the Lcns from the log record into the Dirty Page Entry.
    //
    //  *** for different page size support, must somehow make whole routine a loop,
    //  in case Lcns do not fit below.
    //

    for (i = 0; i < (ULONG)LogRecord->LcnsToFollow; i++) {

        DirtyPage->LcnsForPage[((ULONG)LogRecord->TargetVcn) - ((ULONG)DirtyPage->Vcn) + i] =
          LogRecord->LcnsForPage[i];
    }

    DebugTrace( -1, Dbg, ("PageUpdateAnalysis -> VOID\n") );
}


//
//  Internal support routine
//

VOID
OpenAttributesForRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PRESTART_POINTERS DirtyPageTable
    )

/*++

Routine Description:

    This routine is called immediately after the Analysis Pass to open all of
    the attributes in the Open Attribute Table, and preload their Mcbs with
    any run information required to apply updates in the Dirty Page Table.
    With this trick we are effectively doing physical I/O directly to Lbns on
    the disk without relying on any of the file structure to be correct.

Arguments:

    Vcb - Vcb for the volume, for which the Open Attribute Table has been
          initialized.

    DirtyPageTable - Dirty Page table reconstructed from the Analysis Pass.

Return Value:

    None.

--*/

{
    POPEN_ATTRIBUTE_ENTRY OpenEntry;
    POPEN_ATTRIBUTE_ENTRY OldOpenEntry;
    PDIRTY_PAGE_ENTRY DirtyPage;
    ULONG i;
    PSCB TempScb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("OpenAttributesForRestart:\n") );

    //
    //  First we scan the Open Attribute Table to open all of the attributes.
    //

    OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

    //
    //  Loop to end of table.
    //

    while (OpenEntry != NULL) {

        //
        //  Create the Scb from the data in the Open Attribute Entry.
        //

        TempScb = NtfsCreatePrerestartScb( IrpContext,
                                           Vcb,
                                           &OpenEntry->FileReference,
                                           OpenEntry->AttributeTypeCode,
                                           &OpenEntry->OatData->AttributeName,
                                           OpenEntry->BytesPerIndexBuffer );

        //
        //  If we dynamically allocated a name for this guy, then delete
        //  it here.
        //

        if (OpenEntry->OatData->Overlay.AttributeName != NULL) {

            ASSERT( OpenEntry->OatData->AttributeNamePresent );

            NtfsFreePool( OpenEntry->OatData->Overlay.AttributeName );
            OpenEntry->OatData->AttributeNamePresent = FALSE;
        }

        OpenEntry->OatData->AttributeName = TempScb->AttributeName;

        //
        //  Now we can lay in the Scb.  We must say the header is initialized
        //  to keep anyone from going to disk yet.
        //

        SetFlag( TempScb->ScbState, SCB_STATE_HEADER_INITIALIZED );

        //
        //  Now store the index in the newly created Scb if its newer.
        //  precalc oldopenentry buts its only good if the scb's attributeindex is nonzero
        //

        OldOpenEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable, TempScb->NonpagedScb->OpenAttributeTableIndex );

        if ((TempScb->NonpagedScb->OpenAttributeTableIndex == 0) ||
            (OldOpenEntry->LsnOfOpenRecord.QuadPart < OpenEntry->LsnOfOpenRecord.QuadPart)) {

            TempScb->NonpagedScb->OpenAttributeTableIndex = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable, OpenEntry );
            TempScb->NonpagedScb->OnDiskOatIndex = OpenEntry->OatData->OnDiskAttributeIndex;

        }

        OpenEntry->OatData->Overlay.Scb = TempScb;

        //
        //  Point to next entry in table, or NULL.
        //

        OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                             OpenEntry );
    }

    //
    //  Now loop through the dirty page table to extract all of the Vcn/Lcn
    //  Mapping that we have, and insert it into the appropriate Scb.
    //

    DirtyPage = NtfsGetFirstRestartTable( DirtyPageTable );

    //
    //  Loop to end of table.
    //

    while (DirtyPage != NULL) {

        PSCB Scb;

        //
        //  Safety check
        //

        if (!IsRestartIndexWithinTable( Vcb->OnDiskOat, DirtyPage->TargetAttribute )) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        OpenEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat,
                                              DirtyPage->TargetAttribute );

        if (IsRestartTableEntryAllocated( OpenEntry )) {

            //
            //  Get the entry from the other table if necessary.
            //

            if (Vcb->RestartVersion == 0) {

                //
                //  Safety check
                //

                if (!IsRestartIndexWithinTable( &Vcb->OpenAttributeTable, ((POPEN_ATTRIBUTE_ENTRY_V0) OpenEntry)->OatIndex )) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                OpenEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                      ((POPEN_ATTRIBUTE_ENTRY_V0) OpenEntry)->OatIndex );
            }

            Scb = OpenEntry->OatData->Overlay.Scb;

            //
            //  Loop to add the allocated Vcns.
            //

            for (i = 0; i < DirtyPage->LcnsToFollow; i++) {

                VCN Vcn;
                LONGLONG Size;

                Vcn = DirtyPage->Vcn + i;
                Size = LlBytesFromClusters( Vcb, Vcn + 1);

                //
                //  Add this run to the Mcb if the Vcn has not been deleted,
                //  and it is not for the fixed part of the Mft.
                //

                if ((DirtyPage->LcnsForPage[i] != 0)

                        &&

                    (NtfsSegmentNumber( &OpenEntry->FileReference ) > MASTER_FILE_TABLE2_NUMBER ||
                     (Size >= ((VOLUME_DASD_NUMBER + 1) * Vcb->BytesPerFileRecordSegment)) ||
                     (OpenEntry->AttributeTypeCode != $DATA))) {


                    if (!NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                         Vcn,
                                         DirtyPage->LcnsForPage[i],
                                         (LONGLONG)1,
                                         FALSE )) {

                        //
                        //  Replace with new entry if collision comes from
                        //  the newest attribute
                        //

                        if (DirtyPage->TargetAttribute == Scb->NonpagedScb->OnDiskOatIndex) {
#if DBG
                            BOOLEAN Result;
#endif
                            NtfsRemoveNtfsMcbEntry( &Scb->Mcb,
                                                    Vcn,
                                                    1 );
#if DBG
                            Result =
#endif
                            NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                                 Vcn,
                                                 DirtyPage->LcnsForPage[i],
                                                 (LONGLONG)1,
                                                 FALSE );
#if DBG
                            ASSERT( Result );
#endif
                        }
                    }

                    if (Size > Scb->Header.AllocationSize.QuadPart) {

                        Scb->Header.AllocationSize.QuadPart =
                        Scb->Header.FileSize.QuadPart =
                        Scb->Header.ValidDataLength.QuadPart = Size;
                    }
                }
            }
        }

        //
        //  Point to next entry in table, or NULL.
        //

        DirtyPage = NtfsGetNextRestartTable( DirtyPageTable,
                                             DirtyPage );
    }

    //
    //  Now we know how big all of the files have to be, and recorded that in the
    //  Scb.  We have not created streams for any of these Scbs yet, except for
    //  the Mft, Mft2 and LogFile.  The size should be correct for Mft2 and LogFile,
    //  but we have to inform the Cache Manager here of the final size of the Mft.
    //

    TempScb = Vcb->MftScb;

    ASSERT( !FlagOn( TempScb->ScbPersist, SCB_PERSIST_USN_JOURNAL ) );
    CcSetFileSizes( TempScb->FileObject,
                    (PCC_FILE_SIZES)&TempScb->Header.AllocationSize );

    DebugTrace( -1, Dbg, ("OpenAttributesForRestart -> VOID\n") );
}


NTSTATUS
NtfsCloseAttributesFromRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called at the end of a Restart to close any attributes
    that had to be opened for Restart purposes.  Actually what this does is
    delete all of the internal streams so that the attributes will eventually
    go away.  This routine cannot raise because it is called in the finally of
    MountVolume.  Raising in the main line path will leave the global resource
    acquired.

Arguments:

    Vcb - Vcb for the volume, for which the Open Attribute Table has been
          initialized.

Return Value:

    NTSTATUS - STATUS_SUCCESS if all of the I/O completed successfully.  Otherwise
        the error in the IrpContext or the first I/O error.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    POPEN_ATTRIBUTE_ENTRY OpenEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("CloseAttributesForRestart:\n") );

    //
    //  Set this flag again now, so we do not try to flush out the holes!
    //

    SetFlag(Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS);

    //
    //  Remove duplicate Scbs - in rare case no dirty pages the scb's were never
    //  opened at all
    //

   OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );
   while (OpenEntry != NULL) {
       if ((OpenEntry->OatData->Overlay.Scb != NULL) &&
           (!(OpenEntry->OatData->AttributeNamePresent)) &&
           (OpenEntry->OatData->Overlay.Scb->NonpagedScb->OpenAttributeTableIndex !=
            GetIndexFromRestartEntry( &Vcb->OpenAttributeTable, OpenEntry ))) {

           OpenEntry->OatData->Overlay.Scb = NULL;
       }

       //
       //  Point to next entry in table, or NULL.
       //

       OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                            OpenEntry );
   }

    //
    //  Scan the Open Attribute Table to close all of the open attributes.
    //

    OpenEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

    //
    //  Loop to end of table.
    //

    while (OpenEntry != NULL) {

        IO_STATUS_BLOCK IoStatus;
        PSCB Scb;

        if (OpenEntry->OatData->AttributeNamePresent) {

            NtfsFreeScbAttributeName( OpenEntry->OatData->AttributeName.Buffer );
            OpenEntry->OatData->Overlay.AttributeName = NULL;
            OpenEntry->OatData->AttributeName.Buffer = NULL;
        }

        Scb = OpenEntry->OatData->Overlay.Scb;

        //
        //  We clean up the Scb only if it exists and this is index in the
        //  OpenAttributeTable that this Scb actually refers to.
        //  If this Scb has several entries in the table, we nulled out older
        //  duplicates in the loop above
        //

        if (Scb != NULL) {

            FILE_REFERENCE FileReference;

            //
            //  Only shut it down if it is not the Mft or its mirror.
            //

            FileReference = Scb->Fcb->FileReference;
            if (NtfsSegmentNumber( &FileReference ) > LOG_FILE_NUMBER ||
                (Scb->AttributeTypeCode != $DATA)) {

                //
                //  Now flush the file.  It is important to call the
                //  same routine the Lazy Writer calls, so that write.c
                //  will not decide to update file size for the attribute,
                //  since we really are working here with the wrong size.
                //

                NtfsAcquireScbForLazyWrite( (PVOID)Scb, TRUE );
                CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );
                NtfsReleaseScbFromLazyWrite( (PVOID)Scb );

                if (NT_SUCCESS( Status )) {

                    if (!NT_SUCCESS( IrpContext->ExceptionStatus )) {

                        Status = IrpContext->ExceptionStatus;

                    } else if (!NT_SUCCESS( IoStatus.Status )) {

                        Status = FsRtlNormalizeNtstatus( IoStatus.Status,
                                                         STATUS_UNEXPECTED_IO_ERROR );
                    }
                }

                //
                //  If there is an Scb and it is not for a system file, then delete
                //  the stream file so it can eventually go away.
                //

                NtfsUninitializeNtfsMcb( &Scb->Mcb );
                NtfsInitializeNtfsMcb( &Scb->Mcb,
                                       &Scb->Header,
                                       &Scb->McbStructs,
                                       FlagOn( Scb->Fcb->FcbState,
                                               FCB_STATE_PAGING_FILE ) ? NonPagedPool :
                                                                         PagedPool );

                //
                //  Now that we are restarted, we must clear the header state
                //  so that we will go look up the sizes and load the Scb
                //  from disk.
                //

                ClearFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED |
                                          SCB_STATE_FILE_SIZE_LOADED );

                //
                //  Show the indexed portions are "uninitialized".
                //

                if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

                    Scb->ScbType.Index.BytesPerIndexBuffer = 0;
                }

                //
                //  If this Fcb is past the log file then remove it from the
                //  Fcb table.
                //

                if ((NtfsSegmentNumber( &FileReference ) > LOG_FILE_NUMBER) &&
                    FlagOn( Scb->Fcb->FcbState, FCB_STATE_IN_FCB_TABLE )) {

                    NtfsDeleteFcbTableEntry( Scb->Fcb->Vcb, FileReference );
                    ClearFlag( Scb->Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );
                }

                //
                //  If the Scb is a root index scb then change the type to INDEX_SCB.
                //  Otherwise the teardown routines will skip it.
                //

                if (SafeNodeType( Scb ) == NTFS_NTC_SCB_ROOT_INDEX) {

                    SafeNodeType( Scb ) = NTFS_NTC_SCB_INDEX;
                }

                if (Scb->FileObject != NULL) {

                    NtfsDeleteInternalAttributeStream( Scb, TRUE, FALSE );
                } else {

                    //
                    //  Make sure the Scb is acquired exclusively.
                    //

                    NtfsAcquireExclusiveFcb( IrpContext, Scb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    NtfsTeardownStructures( IrpContext,
                                            Scb,
                                            NULL,
                                            FALSE,
                                            0,
                                            NULL );
                }
            }

        } else {

            //
            //  We want to check whether there is also an entry in the other table.
            //

            if (Vcb->RestartVersion == 0) {

                NtfsFreeRestartTableIndex( Vcb->OnDiskOat, OpenEntry->OatData->OnDiskAttributeIndex );
            }

            NtfsFreeOpenAttributeData( OpenEntry->OatData );

            NtfsFreeRestartTableIndex( &Vcb->OpenAttributeTable,
                                       GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                                                                 OpenEntry ));
        }

        //
        //  Point to next entry in table, or NULL.
        //

        OpenEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                             OpenEntry );
    }

    //
    //  Resume normal operation.
    //

    ClearFlag(Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS);

    DebugTrace( -1, Dbg, ("CloseAttributesForRestart -> %08lx\n", Status) );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\rwcmpsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RwCmpSup.c

Abstract:

    This module implements the fast I/O routines for read/write compressed.

Author:

    Tom Miller      [TomM]          14-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"

VOID
NtfsAddToCompressedMdlChain (
    IN OUT PMDL *MdlChain,
    IN PVOID MdlBuffer,
    IN ULONG MdlLength,
    IN PERESOURCE ResourceToRelease OPTIONAL,
    IN PBCB Bcb,
    IN LOCK_OPERATION Operation,
    IN ULONG IsCompressed
    );

VOID
NtfsSetMdlBcbOwners (
    IN PMDL MdlChain
    );

VOID
NtfsCleanupCompressedMdlChain (
    IN PMDL MdlChain,
    IN ULONG Error
    );

#ifdef NTFS_RWC_DEBUG

PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsGetHistoryEntry)
#endif

#define CACHE_NTC_BCB                    (0x2FD)
#define CACHE_NTC_OBCB                   (0x2FA)

typedef struct _OBCB {

    //
    //  Type and size of this record
    //

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    //  Byte FileOffset and and length of entire buffer
    //

    ULONG ByteLength;
    LARGE_INTEGER FileOffset;

    //
    //  Vector of Bcb pointers.
    //

    PPUBLIC_BCB Bcbs[ANYSIZE_ARRAY];

} OBCB;
typedef OBCB *POBCB;

PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    )
{
    ULONG NextIndex;

    PAGED_CODE();

    //
    //  Store and entry in the history buffer.
    //

    if (Scb->ScbType.Data.HistoryBuffer == NULL) {

        PVOID NewBuffer;

        NewBuffer = NtfsAllocatePool( PagedPool,
                                      sizeof( RWC_HISTORY_ENTRY ) * MAX_RWC_HISTORY_INDEX );

        RtlZeroMemory( NewBuffer, sizeof( RWC_HISTORY_ENTRY ) * MAX_RWC_HISTORY_INDEX );
        NtfsAcquireFsrtlHeader( Scb );

        if (Scb->ScbType.Data.HistoryBuffer == NULL) {

            Scb->ScbType.Data.HistoryBuffer = NewBuffer;

        } else {

            NtfsFreePool( NewBuffer );
        }

        NtfsReleaseFsrtlHeader( Scb );
    }

    NextIndex = InterlockedIncrement( &Scb->ScbType.Data.RwcIndex );
    if (NextIndex >= MAX_RWC_HISTORY_INDEX) {

        NextIndex = 0;
        InterlockedExchange( &Scb->ScbType.Data.RwcIndex, 0);
    }

    return Scb->ScbType.Data.HistoryBuffer + NextIndex;
}
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCopyReadC)
#pragma alloc_text(PAGE, NtfsCompressedCopyRead)
#pragma alloc_text(PAGE, NtfsCopyWriteC)
#pragma alloc_text(PAGE, NtfsCompressedCopyWrite)
#pragma alloc_text(PAGE, NtfsAddToCompressedMdlChain)
#pragma alloc_text(PAGE, NtfsSetMdlBcbOwners)
#pragma alloc_text(PAGE, NtfsSynchronizeCompressedIo)
#pragma alloc_text(PAGE, NtfsSynchronizeUncompressedIo)
#pragma alloc_text(PAGE, NtfsAcquireCompressionSync)
#pragma alloc_text(PAGE, NtfsReleaseCompressionSync)
#endif

#ifdef NTFS_RWCMP_TRACE
ULONG NtfsCompressionTrace = 0;
#endif


BOOLEAN
NtfsCopyReadC (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Buffer - Pointer to output buffer to which data should be copied.

    MdlChain - Pointer to an MdlChain pointer to receive an Mdl to describe
               the data in the cache.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

    CompressedDataInfo - Returns compressed data info with compressed chunk
                         sizes

    CompressedDataInfoLength - Supplies the size of the info buffer in bytes.

    DeviceObject - Standard Fast I/O Device object input.

Return Value:

    FALSE - if the data was not delivered for any reason

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    LONGLONG LocalOffset;
    PFAST_IO_DISPATCH FastIoDispatch;
    FILE_COMPRESSION_INFORMATION CompressionInformation;
    ULONG CompressionUnitSize, ChunkSize;
    BOOLEAN Status = TRUE;
    BOOLEAN DoingIoAtEof = FALSE;

    PAGED_CODE();

    //
    //  You cannot have both a buffer to copy into and an MdlChain.
    //

    ASSERT((Buffer == NULL) || (MdlChain == NULL));

    //
    //  Get out immediately if COW is not supported.
    //

    if (!NtfsEnableCompressedIO) { return FALSE; }

    //
    //  Assume success.
    //

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = Length;
    CompressedDataInfo->NumberOfChunks = 0;

    //
    //  Special case a read of zero length
    //

    if (Length != 0) {

        //
        //  Get a real pointer to the common fcb header
        //

        Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

#ifdef NTFS_RWCMP_TRACE
        if (NtfsCompressionTrace && IsSyscache(Header)) {
            DbgPrint("NtfsCopyReadC: FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
        }
#endif

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

        //
        //  Make our best guess on whether we need the file exclusive
        //  or shared.  Note that we do not check FileOffset->HighPart
        //  until below.
        //

        Status = ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

        //
        //  Now that the File is acquired shared, we can safely test if it
        //  is really cached and if we can do fast i/o and if not, then
        //  release the fcb and return.
        //

        if ((Header->FileObjectC == NULL) ||
            (Header->FileObjectC->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            Status = FALSE;
            goto Done;
        }

        //
        //  Get the address of the driver object's Fast I/O dispatch structure.
        //

        FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

        //
        //  Get the compression information for this file and return those fields.
        //

        NtfsFastIoQueryCompressionInfo( FileObject, &CompressionInformation, IoStatus );
        CompressedDataInfo->CompressionFormatAndEngine = CompressionInformation.CompressionFormat;
        CompressedDataInfo->CompressionUnitShift = CompressionInformation.CompressionUnitShift;
        CompressionUnitSize = 1 << CompressionInformation.CompressionUnitShift;
        CompressedDataInfo->ChunkShift = CompressionInformation.ChunkShift;
        CompressedDataInfo->ClusterShift = CompressionInformation.ClusterShift;
        CompressedDataInfo->Reserved = 0;
        ChunkSize = 1 << CompressionInformation.ChunkShift;

        //
        //  If we either got an error in the call above, or the file size is less than
        //  one chunk, then return an error.  (Could be an Ntfs resident attribute.)

        if (!NT_SUCCESS(IoStatus->Status) || (Header->FileSize.QuadPart < ChunkSize)) {
            Status = FALSE;
            goto Done;
        }

        ASSERT((FileOffset->LowPart & (ChunkSize - 1)) == 0);

        //
        //  If there is a normal cache section, flush that first, flushing integral
        //  compression units so we don't write them twice.
        //

        if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {

            LocalOffset = FileOffset->QuadPart & ~(LONGLONG)(CompressionUnitSize - 1);

            CcFlushCache( FileObject->SectionObjectPointer,
                          (PLARGE_INTEGER)&LocalOffset,
                          (Length + (ULONG)(FileOffset->QuadPart - LocalOffset) + ChunkSize - 1) & ~(ChunkSize - 1),
                          NULL );
        }

        //
        //  Now synchronize with the FsRtl Header
        //

        ExAcquireFastMutex( Header->FastMutex );

        //
        //  Now see if we are reading beyond ValidDataLength.  We have to
        //  do it now so that our reads are not nooped.
        //

        LocalOffset = FileOffset->QuadPart + (LONGLONG)Length;
        if (LocalOffset > Header->ValidDataLength.QuadPart) {

            //
            //  We must serialize with anyone else doing I/O at beyond
            //  ValidDataLength, and then remember if we need to declare
            //  when we are done.
            //

            DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                           NtfsWaitForIoAtEof( Header, FileOffset, Length );

            //
            //  Set the Flag if we are in fact beyond ValidDataLength.
            //

            if (DoingIoAtEof) {
                SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();

            } else {

                ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
            }
        }

        ExReleaseFastMutex( Header->FastMutex );

        //
        //  Check if fast I/O is questionable and if so then go ask the
        //  file system the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            //
            //  All file systems that set "Is Questionable" had better support
            // fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is
            //  anything other than GoForIt then we cannot take the fast I/O
            //  path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        TRUE,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        DeviceObject )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                Status = FALSE;
                goto Done;
            }
        }

        //
        //  Check for read past file size.
        //

        IoStatus->Information = Length;
        if ( LocalOffset > Header->FileSize.QuadPart ) {

            if (FileOffset->QuadPart >= Header->FileSize.QuadPart) {
                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;
                goto Done;
            }

            IoStatus->Information =
            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  copy read fails, then return FALSE to our caller.
        //
        //  Also mark this as the top level "Irp" so that lower file system
        //  levels will not attempt a pop-up
        //

        IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );

        if (NT_SUCCESS(IoStatus->Status)) {

            //
            //  Don't do the sychronize flush if we currently own Eof.  The recursive
            //  flush may try to reacquire.
            //

            if (DoingIoAtEof &&
                (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                IoStatus->Status = STATUS_FILE_LOCK_CONFLICT;

            } else {

                IoStatus->Status = NtfsCompressedCopyRead( FileObject,
                                                           FileOffset,
                                                           Length,
                                                           Buffer,
                                                           MdlChain,
                                                           CompressedDataInfo,
                                                           CompressedDataInfoLength,
                                                           DeviceObject,
                                                           Header,
                                                           CompressionUnitSize,
                                                           ChunkSize );
            }
        }

        Status = (BOOLEAN)NT_SUCCESS(IoStatus->Status);


        IoSetTopLevelIrp( NULL );
        
        Done: NOTHING;

        if (DoingIoAtEof) {
            ExAcquireFastMutex( Header->FastMutex );
            NtfsFinishIoAtEof( Header );
            ExReleaseFastMutex( Header->FastMutex );
        }

        //
        //  For the Mdl case, we must keep the resource unless
        //  we are past the end of the file or had nothing to write.
        //

        if ((MdlChain == NULL) || !Status || (*MdlChain == NULL)) {
            ExReleaseResourceLite( Header->PagingIoResource );
        }

        FsRtlExitFileSystem();
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("Return Status = %08lx\n", Status);
    }
#endif

    return Status;
}


NTSTATUS
NtfsCompressedCopyRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject,
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN ULONG CompressionUnitSize,
    IN ULONG ChunkSize
    )

/*++

Routine Description:

    This is a common routine for doing compressed copy or Mdl reads in
    the compressed stream.  It is called both by the FastIo entry for
    this function, as well as by read.c if a compressed read Irp is received.
    The caller must be correctly synchronized for the stream.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Buffer - Pointer to output buffer to which data should be copied.

    MdlChain - Pointer to an MdlChain pointer to receive an Mdl to describe
               the data in the cache.

    CompressedDataInfo - Returns compressed data info with compressed chunk
                         sizes

    CompressedDataInfoLength - Supplies the size of the info buffer in bytes.

    DeviceObject - Standard Fast I/O Device object input.

    Header - Pointer to FsRtl header for file (also is our Scb)

    CompressionUnitSize - Size of Compression Unit in bytes.

    ChunkSize - ChunkSize in bytes.

Return Value:

    NTSTATUS for operation.  If STATUS_NOT_MAPPED_USER_DATA, then the caller
    should map the normal uncompressed data stream and call back.

--*/

{
    PFILE_OBJECT LocalFileObject;
    PULONG NextReturnChunkSize;
    PUCHAR CompressedBuffer, EndOfCompressedBuffer, ChunkBuffer, StartOfCompressionUnit;
    LONGLONG LocalOffset;
    ULONG CuCompressedSize;
    PVOID MdlBuffer;
    ULONG MdlLength;
    ULONG PinFlags;
    BOOLEAN IsCompressed;
    BOOLEAN LastCompressionUnit;
    NTSTATUS Status = STATUS_SUCCESS;
    PCOMPRESSION_SYNC CompressionSync = NULL;
    PBCB Bcb = NULL;
    PBCB UncompressedBcb = NULL;

    ULONG ClusterSize = ((PSCB)Header)->Vcb->BytesPerCluster;

#ifdef NTFS_RWC_DEBUG
    PRWC_HISTORY_ENTRY ReadHistoryBuffer;
#endif
    
    UNREFERENCED_PARAMETER( CompressedDataInfoLength );
    UNREFERENCED_PARAMETER( DeviceObject );

    ASSERT(CompressedDataInfoLength >= (sizeof(COMPRESSED_DATA_INFO) +
                                        (((Length >> CompressedDataInfo->ChunkShift) - 1) *
                                          sizeof(ULONG))));
    ASSERT((FileOffset->QuadPart & (ChunkSize - 1)) == 0);
    ASSERT((((FileOffset->QuadPart + Length) & (ChunkSize - 1)) == 0) ||
           ((FileOffset->QuadPart + Length) == Header->FileSize.QuadPart));
    ASSERT((MdlChain == NULL) || (*MdlChain == NULL));

    // 
    //  if we start after vdl we will never pin the compressed buffer 
    // 

    ASSERT( FileOffset->QuadPart < Header->ValidDataLength.QuadPart );

    //
    //  Return an error if the file is not compressed.
    //

    if (((PSCB)Header)->CompressionUnit == 0) {
        return STATUS_UNSUPPORTED_COMPRESSION;
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("  CompressedCopyRead: FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
    }
#endif

#ifdef NTFS_RWC_DEBUG
    if ((FileOffset->QuadPart < NtfsRWCHighThreshold) &&
        (FileOffset->QuadPart + Length > NtfsRWCLowThreshold)) {

        PRWC_HISTORY_ENTRY NextBuffer;

        ReadHistoryBuffer = 
        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

        NextBuffer->Operation = StartOfRead;
        NextBuffer->Information = Header->ValidDataLength.LowPart;
        NextBuffer->FileOffset = (ULONG) FileOffset->QuadPart;
        NextBuffer->Length = (ULONG) Length;
    }
#endif

    try {

        //
        //  Get ready to loop through all of the compression units.
        //

        LocalOffset = FileOffset->QuadPart & ~(LONGLONG)(CompressionUnitSize - 1);
        Length = (Length + (ULONG)(FileOffset->QuadPart - LocalOffset) + ChunkSize - 1) & ~(ChunkSize - 1);

        NextReturnChunkSize = &CompressedDataInfo->CompressedChunkSizes[0];

        //
        //  Loop through desired compression units
        //

        while (TRUE) {

            //
            //  Free any Bcb from previous loop.
            //

            if (Bcb != NULL) {

                ASSERT( (UncompressedBcb == NULL) ||
                        (UncompressedBcb == Bcb ) );

                CcUnpinData( Bcb );
                UncompressedBcb = Bcb = NULL;

            } else if (UncompressedBcb != NULL) {

                CcUnpinData( UncompressedBcb );
                UncompressedBcb = NULL;
            }

            //
            //  If there is an uncompressed stream, then we have to synchronize with that.
            //

            if (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL) {

                Status = NtfsSynchronizeCompressedIo( (PSCB)Header,
                                                      &LocalOffset,
                                                      Length,
                                                      FALSE,
                                                      &CompressionSync );

                if (!NT_SUCCESS(Status)) {
                    ASSERT( Status == STATUS_USER_MAPPED_FILE );
                    leave;
                }
            }

            //
            //  Loop to get the correct data pinned.
            //
            //  The synchronize call above has guaranteed that no data can written through
            //  the uncompressed section (barring the loop back below), and it has also flushed
            //  any dirty data that may have already been in the uncompressed section.  Here we
            //  are basically trying to figure out how much data we should pin and then get it
            //  pinned.
            //
            //  We use the following steps:
            //
            //      1.  Query the current compressed size (derived from the allocation state).
            //          If the size is neither 0-allocated nor fully allocated, then we will
            //          simply pin the data in the compressed section - this is the normal case.
            //      2.  However, the first time we see one of these special sizes, we do not
            //          know if could be the case that there is dirty data sitting in the compressed
            //          cache.  Therefore, we set up to pin just one page with PIN_IF_BCB.  This
            //          will only pin something if there is aleady a Bcb for it.
            //      3.  Now we determine if we think the data is compressed or not, counting the
            //          special cases from the previous point as compressed.  This determines
            //          which section to read from.
            //      4.  Now, if we think there is/may be data to pin, we call Cc.  If he comes
            //          back with no data (only possible if we set PIN_IF_BCB), then we know we
            //          can loop back to the top and trust the allocation state on disk now.
            //          (That is because we flushed the uncompressed stream and found no Bcb in
            //          the compressed stream.)  On the second time through we should correctly
            //          handle the 0-allocated or fully-allocated cases.  (The careful reader
            //          will note that if there is no uncompressed section, then indeed writers
            //          to the compressed section could be going on in parallel with this read,
            //          and we could handle the 0- or fully-allocated case while there is
            //          new compressed data in the cache.  However on the second loop we know
            //          there really was all 0's in the file at one point which it is correct
            //          to return, and it is always correct to go to the uncompressed cache
            //          if we still see fully-allocated.  More importantly, we have an
            //          unsynchronized reader and writer, and the reader's result is therefore
            //          nondeterministic anyway.
            //

            PinFlags = PIN_WAIT;

            do {

                //
                //  If we are beyond ValidDataLength, then the CompressedSize is 0!
                //

                if (LocalOffset >= Header->ValidDataLength.QuadPart) {

                    CuCompressedSize = 0;
                    ClearFlag( PinFlags, PIN_IF_BCB );

                //
                //  Otherwise query the compressed size.
                //

                } else {

                    NtfsFastIoQueryCompressedSize( FileObject,
                                                   (PLARGE_INTEGER)&LocalOffset,
                                                   &CuCompressedSize );

                    //
                    //  If it looks uncompressed, we are probably trying to read data
                    //  that has not been written out yet.  Also if the space is not yet
                    //  allocated, then we also need to try to hit the data in the compressed
                    //  cache.
                    //

                    if (((CuCompressedSize == CompressionUnitSize) || (CuCompressedSize == 0)) &&
                        !FlagOn(PinFlags, PIN_IF_BCB)) {

                        CuCompressedSize = 0x1000;
                        SetFlag( PinFlags, PIN_IF_BCB );

                    //
                    //  Make sure we really read the data if this is the second time through.
                    //

                    } else {

                        //
                        //  If the range is dirty and there is no Bcb in the compressed stream
                        //  then always go to the uncompressed stream.
                        //

                        if (FlagOn( PinFlags, PIN_IF_BCB ) &&
                            (CuCompressedSize != CompressionUnitSize)) {

                            LONGLONG ClusterCount = 1 << ((PSCB) Header)->CompressionUnitShift;

                            if (NtfsCheckForReservedClusters( (PSCB) Header,
                                                              LlClustersFromBytesTruncate( ((PSCB) Header)->Vcb, LocalOffset ),
                                                              &ClusterCount )) {

                                CuCompressedSize = CompressionUnitSize;
                            }
                        }

                        ClearFlag( PinFlags, PIN_IF_BCB );
                    }
                }

                ASSERT( CuCompressedSize <= CompressionUnitSize );
                IsCompressed = (BOOLEAN)((CuCompressedSize != CompressionUnitSize) &&
                                         (CompressedDataInfo->CompressionFormatAndEngine != 0));

                //
                //  Figure out which FileObject to use.
                //

                LocalFileObject = Header->FileObjectC;
                if (!IsCompressed) {
                    LocalFileObject = ((PSCB)Header)->FileObject;
                    if (LocalFileObject == NULL) {
                        Status = STATUS_NOT_MAPPED_DATA;
                        goto Done;
                    }
                }

                //
                //  If the compression unit is not (yet) allocated, then there is
                //  no need to synchronize - we will return 0-lengths for chunk sizes.
                //

                if (CuCompressedSize != 0) {

                    //
                    //  Map the compression unit in the compressed or uncompressed
                    //  stream.
                    //

                    CcPinRead( LocalFileObject,
                               (PLARGE_INTEGER)&LocalOffset,
                               CuCompressedSize,
                               PinFlags,
                               &Bcb,
                               &CompressedBuffer );

                    //
                     //  If there is no Bcb it means we were assuming the data was in
                    //  the compressed buffer and only wanted to wait if it was
                    //  present.  Well it isn't there so force ourselved to go
                    //  back and look in the uncompressed section.
                    //

                    if (Bcb == NULL) {

                        ASSERT( FlagOn( PinFlags, PIN_IF_BCB ));
                        continue;
                    }

                    //
                    //  Now that the data is pinned (we are synchronized with the
                    //  CompressionUnit), we have to get the size again since it could
                    //  have changed.
                    //

                    if (IsCompressed) {

                        //
                        //  Now, we know the data where we are about to read is compressed,
                        //  but we cannot really tell for sure how big it is since there may
                        //  be dirty data in the cache.
                        //
                        //  We will say the size is (CompressionUnitSize - ClusterSize)
                        //  which is the largest possible compressed size, and we will normally
                        //  just hit on the existing dirty Bcb and/or resident pages anyway.
                        //  (If we do not, then we will just fault those pages in one at a
                        //  time anyway.  This looks bad having to do this twice, but it
                        //  is only until the dirty data finally gets flushed out.)  This also
                        //  means we may walk off the range we pinned in a read-only mode, but
                        //  that should be benign.
                        //
                        //  Of course in the main line case, we figured out exactly how much
                        //  data to read in and we did so when we pinned it above.
                        //

                        CuCompressedSize = CompressionUnitSize - ClusterSize;

                    //
                    //  Otherwise remember to release this Bcb.
                    //

                    } else {

                        UncompressedBcb = Bcb;
                    }
                }

            } while ((Bcb == NULL) && (CuCompressedSize != 0));

            //
            //  Now that we are synchronized with the buffer, see if someone snuck
            //  in behind us and created the noncached stream since we last checked
            //  for that stream.  If so we have to loop back to synchronize with the
            //  compressed stream again.
            //

            if ((CompressionSync == NULL) &&
                (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                continue;
            }

            EndOfCompressedBuffer = Add2Ptr( CompressedBuffer, CuCompressedSize );
            StartOfCompressionUnit = CompressedBuffer;

            //
            //  Remember if we may go past the end of the file.
            //

            LastCompressionUnit = FALSE;

            if (LocalOffset + CuCompressedSize > Header->FileSize.QuadPart) {

                LastCompressionUnit = TRUE;
            }

            //
            //  Now loop through desired chunks
            //

            MdlLength = 0;

            do {

                //
                //  Assume current chunk does not compress, else get current
                //  chunk size.
                //

                if (IsCompressed) {

                    if (CuCompressedSize != 0) {

                        PUCHAR PrevCompressedBuffer;

                        //
                        //  We have to do a careful check to see if the return value is
                        //  greater than or equal to the chunk size AND the data is in fact
                        //  compressed.  We don't have anyway to pass this data back to
                        //  the server so he can interpret it correctly.
                        //

                        PrevCompressedBuffer = CompressedBuffer;

                        Status = RtlDescribeChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                   &CompressedBuffer,
                                                   EndOfCompressedBuffer,
                                                   &ChunkBuffer,
                                                   NextReturnChunkSize );

                        if (!NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES)) {
                            ExRaiseStatus(Status);
                        }

                        //
                        //  If the size is greater or equal to the chunk size AND the data is compressed
                        //  then force this to the uncompressed path.  Note that the Rtl package has
                        //  been changed so that this case shouldn't happen on new disks but it is
                        //  possible that it could exist on exiting disks.
                        //

                        if ((*NextReturnChunkSize >= ChunkSize) &&
                            (PrevCompressedBuffer == ChunkBuffer)) {

                            //
                            //  Raise an error code that causes the server to reissue in
                            //  the uncompressed path.
                            //

                            ExRaiseStatus( STATUS_UNSUPPORTED_COMPRESSION );
                        }

                        //
                        //  Another unusual case is where the compressed data extends past the containing
                        //  file size.  We don't have anyway to prevent the next page from being zeroed.
                        //  Ask the server to go the uncompressed path.
                        //

                        if (LastCompressionUnit) {

                            LONGLONG EndOfPage;

                            EndOfPage = LocalOffset + PtrOffset( StartOfCompressionUnit, CompressedBuffer ) + PAGE_SIZE - 1;
                            ((PLARGE_INTEGER) &EndOfPage)->LowPart &= ~(PAGE_SIZE - 1);
                            
                            if (EndOfPage > Header->FileSize.QuadPart) {

                                //
                                //  Raise an error code that causes the server to reissue in
                                //  the uncompressed path.
                                //
    
                                ExRaiseStatus( STATUS_UNSUPPORTED_COMPRESSION );
                            }
                        }

                        ASSERT( *NextReturnChunkSize <= ChunkSize );

                    //
                    //  If the entire CompressionUnit is empty, do this.
                    //

                    } else {
                        *NextReturnChunkSize = 0;
#ifdef NTFS_RWC_DEBUG
                        if ((LocalOffset < NtfsRWCHighThreshold) &&
                            (LocalOffset + CompressionUnitSize > NtfsRWCLowThreshold)) {

                            PRWC_HISTORY_ENTRY NextBuffer;

                            NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                            NextBuffer->Operation = ReadZeroes;
                            NextBuffer->Information = 0;
                            NextBuffer->FileOffset = (ULONG) LocalOffset;
                            NextBuffer->Length = 0;
                        }
#endif
                    }

                //
                //  If the file is not compressed, we have to fill in
                //  the appropriate chunk size and buffer, and advance
                //  CompressedBuffer.
                //

                } else {
#ifdef NTFS_RWC_DEBUG
                    if ((LocalOffset < NtfsRWCHighThreshold) &&
                        (LocalOffset + ChunkSize > NtfsRWCLowThreshold)) {

                        PRWC_HISTORY_ENTRY NextBuffer;

                        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                        NextBuffer->Operation = ReadUncompressed;
                        NextBuffer->Information = (LocalFileObject == ((PSCB)Header)->FileObject);
                        NextBuffer->FileOffset = (ULONG) LocalOffset;
                        NextBuffer->Length = 0;
                    }
#endif
                    *NextReturnChunkSize = ChunkSize;
                    ChunkBuffer = CompressedBuffer;
                    CompressedBuffer = Add2Ptr( CompressedBuffer, ChunkSize );
                }
                Status = STATUS_SUCCESS;

                //
                //  We may not have reached the first chunk yet.
                //

                if (LocalOffset >= FileOffset->QuadPart) {

                    if (MdlChain != NULL) {

                        //
                        //  If we have not started remembering an Mdl buffer,
                        //  then do so now.
                        //

                        if (MdlLength == 0) {

                            MdlBuffer = ChunkBuffer;

                        //
                        //  Otherwise we just have to increase the length
                        //  and check for an uncompressed chunk, because that
                        //  forces us to emit the previous Mdl since we do
                        //  not transmit the chunk header in this case.
                        //

                        } else {

                            //
                            //  In the rare case that we hit an individual chunk
                            //  that did not compress or is all zeros, we have to
                            //  emit what we had (which captures the Bcb pointer),
                            //  and start a new Mdl buffer.
                            //

                            if ((*NextReturnChunkSize == ChunkSize) || (*NextReturnChunkSize == 0)) {

                                NtfsAddToCompressedMdlChain( MdlChain,
                                                             MdlBuffer,
                                                             MdlLength,
                                                             Header->PagingIoResource,
                                                             Bcb,
                                                             IoReadAccess,
                                                             IsCompressed );
                                Bcb = NULL;
                                MdlBuffer = ChunkBuffer;
                                MdlLength = 0;
                            }
                        }

                        MdlLength += *NextReturnChunkSize;

                    //
                    //  Else copy next chunk (compressed or not).
                    //

                    } else {

                        //
                        //  Copy next chunk (compressed or not).
                        //

                        RtlCopyBytes( Buffer,
                                      ChunkBuffer,
                                      (IsCompressed || (Length >= *NextReturnChunkSize)) ?
                                        *NextReturnChunkSize : Length );

                        //
                        //  Advance output buffer by bytes copied.
                        //

                        Buffer = (PCHAR)Buffer + *NextReturnChunkSize;
                    }

                    NextReturnChunkSize += 1;
                    CompressedDataInfo->NumberOfChunks += 1;
                }

                //
                //  Reduce length by chunk copied, and check if we are done.
                //

                if (Length > ChunkSize) {
                    Length -= ChunkSize;
                } else {
                    goto Done;
                }

                LocalOffset += ChunkSize;

            } while ((LocalOffset & (CompressionUnitSize - 1)) != 0);


            //
            //  If this is an Mdl call, then it is time to add to the MdlChain
            //  before moving to the next compression unit.
            //

            if (MdlLength != 0) {

                NtfsAddToCompressedMdlChain( MdlChain,
                                             MdlBuffer,
                                             MdlLength,
                                             Header->PagingIoResource,
                                             Bcb,
                                             IoReadAccess,
                                             IsCompressed );
                Bcb = NULL;
                MdlLength = 0;
            }
        }

    Done:

        FileObject->Flags |= FO_FILE_FAST_IO_READ;

        if (NT_SUCCESS(Status) && (MdlLength != 0)) {
            NtfsAddToCompressedMdlChain( MdlChain,
                                         MdlBuffer,
                                         MdlLength,
                                         Header->PagingIoResource,
                                         Bcb,
                                         IoReadAccess,
                                         IsCompressed );
            Bcb = NULL;
        }

    } except( FsRtlIsNtstatusExpected(Status = GetExceptionCode())
                                    ? EXCEPTION_EXECUTE_HANDLER
                                    : EXCEPTION_CONTINUE_SEARCH ) {

        NOTHING;
    }

    //
    //  Unpin any Bcbs we still have.
    //

    if (Bcb != NULL) {
        CcUnpinData( Bcb );

    } else if (UncompressedBcb != NULL) {
        CcUnpinData( UncompressedBcb );
    }

    if (CompressionSync != NULL) {
        NtfsReleaseCompressionSync( CompressionSync );
    }

    //
    //  Perform Mdl-specific processing.
    //

    if (MdlChain != NULL) {

        //
        //  On error, cleanup any MdlChain we built up
        //

        if (!NT_SUCCESS(Status)) {

            NtfsCleanupCompressedMdlChain( *MdlChain, TRUE );
            *MdlChain = NULL;

        //
        //  Change owner Id for the Scb and Bcbs we are holding.
        //

        } else if (*MdlChain != NULL) {

            NtfsSetMdlBcbOwners( *MdlChain );
            ExSetResourceOwnerPointer( Header->PagingIoResource, (PVOID)((PCHAR)*MdlChain + 3) );
        }
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {

        ULONG ci;

        if (NT_SUCCESS(Status)) {
            DbgPrint("  Chunks:");
            for (ci = 0; ci < CompressedDataInfo->NumberOfChunks; ci++) {
                DbgPrint("  %lx", CompressedDataInfo->CompressedChunkSizes[ci]);
            }
            DbgPrint("\n");
        }
        DbgPrint("  Return Status = %08lx\n", Status);
    }
#endif

#ifdef NTFS_RWC_DEBUG
    if ((Status == STATUS_SUCCESS) &&
        (FileOffset->QuadPart < NtfsRWCHighThreshold) &&
        (FileOffset->QuadPart + Length > NtfsRWCLowThreshold)) {

        PRWC_HISTORY_ENTRY NextBuffer;

        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

        NextBuffer->Operation = EndOfRead;
        NextBuffer->Information = (ULONG) ReadHistoryBuffer;
        NextBuffer->FileOffset = 0;
        NextBuffer->Length = 0;

        if (ReadHistoryBuffer != NULL) {
            SetFlag( ReadHistoryBuffer->Operation, 0x80000000 );
        }
    }
#endif

    return Status;
}


BOOLEAN
NtfsMdlReadCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine frees resources and the Mdl Chain after a compressed read.

Arguments:

    FileObject - pointer to the file object for the request.

    MdlChain - as returned from compressed copy read.

    DeviceObject - As required for a fast I/O routine.

Return Value:

    TRUE - if fast path succeeded

    FALSE -  if an Irp is required

--*/

{
    PERESOURCE ResourceToRelease;

    if (MdlChain != NULL) {

        ResourceToRelease = *(PERESOURCE *)Add2Ptr( MdlChain, MdlChain->Size + sizeof( PBCB ));
    }

    NtfsCleanupCompressedMdlChain( MdlChain, FALSE );

    //
    //  If the server tried to read past the end of the file in the
    //  fast path then he calls us with NULL for the MDL.  We already
    //  released the thread in that case.
    //

    if (MdlChain != NULL) {

        ExReleaseResourceForThread( ResourceToRelease, (ERESOURCE_THREAD)((PCHAR)MdlChain + 3) );
    }

    return TRUE;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( FileObject );
}


BOOLEAN
NtfsCopyWriteC (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Buffer - Pointer to output buffer to which data should be copied.

    MdlChain - Pointer to an MdlChain pointer to receive an Mdl to describe
               where the data may be written in the cache.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

    CompressedDataInfo - Returns compressed data info with compressed chunk
                         sizes

    CompressedDataInfoLength - Supplies the size of the info buffer in bytes.

Return Value:

    FALSE - if there is an error.

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    FILE_COMPRESSION_INFORMATION CompressionInformation;
    ULONG CompressionUnitSize, ChunkSize;
    ULONG EngineMatches;
    LARGE_INTEGER NewFileSize;
    LARGE_INTEGER OldFileSize;
    LONGLONG LocalOffset;
    PFAST_IO_DISPATCH FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;
    ULONG DoingIoAtEof = FALSE;
    BOOLEAN Status = TRUE;

    UNREFERENCED_PARAMETER( CompressedDataInfoLength );

    PAGED_CODE();

    //
    //  You cannot have both a buffer to copy into and an MdlChain.
    //

    ASSERT((Buffer == NULL) || (MdlChain == NULL));

    //
    //  Get out immediately if COW is not supported.
    //

    if (!NtfsEnableCompressedIO) { return FALSE; }

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("NtfsCopyWriteC: FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
    }
#endif

    //
    //  See if it is ok to handle this in the fast path.
    //

    if (CcCanIWrite( FileObject, Length, TRUE, FALSE ) &&
        !FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcCopyWriteWontFlush(FileObject, FileOffset, Length)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Calculate the compression unit and chunk sizes.
            //

            CompressionUnitSize = 1 << CompressedDataInfo->CompressionUnitShift;
            ChunkSize = 1 << CompressedDataInfo->ChunkShift;

            //
            //  If there is a normal cache section, flush that first, flushing integral
            //  compression units so we don't write them twice.
            //
            //

            if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {

                ULONG FlushLength;

                ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                CompressionUnitSize = ((PSCB) Header)->CompressionUnit;

                LocalOffset = FileOffset->QuadPart & ~(LONGLONG)(CompressionUnitSize - 1);

                FlushLength = (Length + (ULONG)(FileOffset->QuadPart - LocalOffset) + CompressionUnitSize - 1) &
                                                ~(CompressionUnitSize - 1);

                CcFlushCache( FileObject->SectionObjectPointer,
                              (PLARGE_INTEGER)&LocalOffset,
                              FlushLength,
                              NULL );
                CcPurgeCacheSection( FileObject->SectionObjectPointer,
                                     (PLARGE_INTEGER)&LocalOffset,
                                     FlushLength,
                                     FALSE );
                ExReleaseResourceLite( Header->PagingIoResource );
            }

            NewFileSize.QuadPart = FileOffset->QuadPart + Length;

            //
            //  Prevent truncates by acquiring paging I/O
            //

            ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

            //
            //  Get the compression information for this file and return those fields.
            //

            NtfsFastIoQueryCompressionInfo( FileObject, &CompressionInformation, IoStatus );
            CompressionUnitSize = ((PSCB) Header)->CompressionUnit;

            //
            //  See if the engine matches, so we can pass that on to the
            //  compressed write routine.
            //

            EngineMatches =
              ((CompressedDataInfo->CompressionFormatAndEngine == CompressionInformation.CompressionFormat) &&
               (CompressedDataInfo->ChunkShift == CompressionInformation.ChunkShift));

            //
            //  If we either got an error in the call above, or the file size is less than
            //  one chunk, then return an error.  (Could be an Ntfs resident attribute.)
            //

            if (!NT_SUCCESS(IoStatus->Status) || (Header->FileSize.QuadPart < ChunkSize)) {
                goto ErrOut;
            }

            //
            //  Now synchronize with the FsRtl Header
            //

            ExAcquireFastMutex( Header->FastMutex );

            //
            //  Now see if we will change FileSize.  We have to do it now
            //  so that our reads are not nooped.  Note we do not allow
            //  FileOffset to be WRITE_TO_EOF.
            //

            ASSERT((FileOffset->LowPart & (ChunkSize - 1)) == 0);

            if (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart) {

                //
                //  We can change FileSize and ValidDataLength if either, no one
                //  else is now, or we are still extending after waiting.
                //

                DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                               NtfsWaitForIoAtEof( Header, FileOffset, Length );

                //
                //  Set the Flag if we are changing FileSize or ValidDataLength,
                //  and save current values.
                //

                if (DoingIoAtEof) {

                    SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

                    //
                    //  Now calculate the new FileSize and see if we wrapped the
                    //  32-bit boundary.
                    //

                    NewFileSize.QuadPart = FileOffset->QuadPart + Length;

                    //
                    //  Update Filesize now so that we do not truncate reads.
                    //

                    OldFileSize.QuadPart = Header->FileSize.QuadPart;
                    if (NewFileSize.QuadPart > Header->FileSize.QuadPart) {

                        //
                        //  If we are beyond AllocationSize, go to ErrOut
                        //

                        if (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) {
                            ExReleaseFastMutex( Header->FastMutex );
                            goto ErrOut;
                        } else {
                            Header->FileSize.QuadPart = NewFileSize.QuadPart;
                        }
                    }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                } else {

                    ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                }
            }

            ExReleaseFastMutex( Header->FastMutex );

            //
            //  Now that the File is acquired shared, we can safely test if it
            //  is really cached and if we can do fast i/o and if not, then
            //  release the fcb and return.
            //
            //  Note, we do not want to call CcZeroData here,
            //  but rather defer zeroing to the file system, due to
            //  the need for exclusive resource acquisition.  Therefore
            //  we get out if we are beyond ValidDataLength.
            //

            if ((Header->FileObjectC == NULL) ||
                (Header->FileObjectC->PrivateCacheMap == NULL) ||
                (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                (FileOffset->QuadPart > Header->ValidDataLength.QuadPart)) {

                goto ErrOut;
            }

            //
            //  Check if fast I/O is questionable and if so then go ask
            //  the file system the answer
            //

            if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

                //
                //  All file system then set "Is Questionable" had better
                //  support fast I/O
                //

                ASSERT(FastIoDispatch != NULL);
                ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                //
                //  Call the file system to check for fast I/O.  If the
                //  answer is anything other than GoForIt then we cannot
                //  take the fast I/O path.
                //


                if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                            FileOffset,
                                                            Length,
                                                            TRUE,
                                                            LockKey,
                                                            FALSE, // write operation
                                                            IoStatus,
                                                            DeviceObject )) {

                    //
                    //  Fast I/O is not possible so cleanup and return.
                    //

                    goto ErrOut;
                }
            }

            //
            //  Update both caches with EOF.
            //

            if (DoingIoAtEof) {
                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Header->AllocationSize,
                                       (PSCB)Header );
            }

            //
            //  We can do fast i/o so call the cc routine to do the work
            //  and then release the fcb when we've done.  If for whatever
            //  reason the copy write fails, then return FALSE to our
            //  caller.
            //
            //  Also mark this as the top level "Irp" so that lower file
            //  system levels will not attempt a pop-up
            //

            IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );

            ASSERT(CompressedDataInfoLength >= (sizeof(COMPRESSED_DATA_INFO) +
                                                (((Length >> CompressedDataInfo->ChunkShift) - 1) *
                                                  sizeof(ULONG))));

            if (NT_SUCCESS(IoStatus->Status)) {

                if (DoingIoAtEof &&
                    (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                    IoStatus->Status = STATUS_FILE_LOCK_CONFLICT;

                } else {

                    IoStatus->Status = NtfsCompressedCopyWrite( FileObject,
                                                                FileOffset,
                                                                Length,
                                                                Buffer,
                                                                MdlChain,
                                                                CompressedDataInfo,
                                                                DeviceObject,
                                                                Header,
                                                                CompressionUnitSize,
                                                                ChunkSize,
                                                                EngineMatches );
                }
            }

            IoSetTopLevelIrp( NULL );
            
            Status = (BOOLEAN)NT_SUCCESS(IoStatus->Status);

            //
            //  If we succeeded, see if we have to update FileSize ValidDataLength.
            //

            if (Status) {

                //
                //  Set this handle as having modified the file.
                //

                FileObject->Flags |= FO_FILE_MODIFIED;

                if (DoingIoAtEof) {

                    CC_FILE_SIZES CcFileSizes;

                    ExAcquireFastMutex( Header->FastMutex );
                    FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    Header->ValidDataLength = NewFileSize;
                    CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
                    NtfsVerifySizes( Header );
                    NtfsFinishIoAtEof( Header );

                    //
                    //  Update the normal cache with ValidDataLength.
                    //

                    if (((PSCB)Header)->FileObject != NULL) {
                        CcSetFileSizes( ((PSCB)Header)->FileObject, &CcFileSizes );
                    }
                    ExReleaseFastMutex( Header->FastMutex );
                }

                goto Done1;
            }

        ErrOut: NOTHING;

            Status = FALSE;
            if (DoingIoAtEof) {
                ExAcquireFastMutex( Header->FastMutex );
                if (CcIsFileCached(FileObject)) {
                    *CcGetFileSizePointer(FileObject) = OldFileSize;
                }
                if (Header->FileObjectC != NULL) {
                    *CcGetFileSizePointer(Header->FileObjectC) = OldFileSize;
                }
                Header->FileSize = OldFileSize;
                NtfsFinishIoAtEof( Header );
                ExReleaseFastMutex( Header->FastMutex );
            }

        Done1: NOTHING;

            //
            //  For the Mdl case, we must keep the resource.
            //

            if ((MdlChain == NULL) || !Status || (*MdlChain == NULL)) {
                ExReleaseResourceLite( Header->PagingIoResource );
            }

            FsRtlExitFileSystem();
        }

    } else {

        //
        // We could not do the I/O now.
        //

        Status = FALSE;
    }


#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("Return Status = %08lx\n", Status);
    }
#endif
    return Status;
}


NTSTATUS
NtfsCompressedCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN ULONG CompressionUnitSize,
    IN ULONG ChunkSize,
    IN ULONG EngineMatches
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Buffer - Pointer to output buffer to which data should be copied.

    MdlChain - Pointer to an MdlChain pointer to receive an Mdl to describe
               where the data may be written in the cache.

    CompressedDataInfo - Returns compressed data info with compressed chunk
                         sizes

    DeviceObject - Standard Fast I/O Device object input.

    Header - Pointer to FsRtl header for file (also is our Scb)

    CompressionUnitSize - Size of Compression Unit in bytes.

    ChunkSize - ChunkSize in bytes.

    EngineMatches - TRUE if the caller has determined that the compressed
                    data format matches the compression engine for the file.

Return Value:

    NTSTATUS for operation.  If STATUS_NOT_MAPPED_USER_DATA, then the caller
    should map the normal uncompressed data stream and call back.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PUCHAR StartOfPin;
    ULONG SizeToPin;

    LONGLONG LocalOffset;
    PULONG NextChunkSize, TempChunkSize;
    PUCHAR ChunkBuffer;
    PUCHAR CacheBuffer;
    PUCHAR EndOfCacheBuffer;

    ULONG SavedLength;
    PUCHAR SavedBuffer;

    ULONG ChunkOfZeros;
    ULONG UncompressedChunkHeader;

    ULONG ChunkSizes[17];
    ULONG i, ChunksSeen;

    ULONG TempUlong;

    PVOID MdlBuffer;
    ULONG MdlLength = 0;

    ULONG ClusterSize = ((PSCB)Header)->Vcb->BytesPerCluster;

    PBCB Bcb = NULL;
    PBCB TempBcb = NULL;
    PCOMPRESSION_SYNC CompressionSync = NULL;

    BOOLEAN FullOverwrite = FALSE;
    BOOLEAN IsCompressed;

    ASSERT((FileOffset->QuadPart & (ChunkSize - 1)) == 0);
    ASSERT((((FileOffset->QuadPart + Length) & (ChunkSize - 1)) == 0) ||
           ((FileOffset->QuadPart + Length) == Header->FileSize.QuadPart));
    ASSERT((MdlChain == NULL) || (*MdlChain == NULL));

    //
    //  Return an error if the file is not compressed.
    //

    if (!EngineMatches || ((PSCB)Header)->CompressionUnit == 0) {
        return STATUS_UNSUPPORTED_COMPRESSION;
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {

        ULONG ci;

        DbgPrint("  CompressedWrite: FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
        DbgPrint("  Chunks:");
        for (ci = 0; ci < CompressedDataInfo->NumberOfChunks; ci++) {
            DbgPrint("  %lx", CompressedDataInfo->CompressedChunkSizes[ci]);
        }
        DbgPrint("\n");
    }
#endif

#ifdef NTFS_RWC_DEBUG
    if ((FileOffset->QuadPart < NtfsRWCHighThreshold) &&
        (FileOffset->QuadPart + Length > NtfsRWCLowThreshold)) {

        PRWC_HISTORY_ENTRY NextBuffer;

        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

        NextBuffer->Operation = StartOfWrite;
        NextBuffer->Information = CompressedDataInfo->NumberOfChunks;
        NextBuffer->FileOffset = (ULONG) FileOffset->QuadPart;
        NextBuffer->Length = (ULONG) Length;
    }
#endif
    try {

        //
        //  Get ready to loop through all of the compression units.
        //

        LocalOffset = FileOffset->QuadPart & ~(LONGLONG)(CompressionUnitSize - 1);
        Length = (Length + (ULONG)(FileOffset->QuadPart - LocalOffset) + ChunkSize - 1) & ~(ChunkSize - 1);

        NextChunkSize = &CompressedDataInfo->CompressedChunkSizes[0];

        //
        //  Get the overhead for zero chunks and uncompressed chunks.
        //
        //  ****    temporary solution awaits Rtl routine.
        //

        ASSERT(CompressedDataInfo->CompressionFormatAndEngine == COMPRESSION_FORMAT_LZNT1);
        ChunkOfZeros = 6;
        UncompressedChunkHeader = 2;
        //  Status = RtlGetSpecialChunkSizes( CompressedDataInfo->CompressionFormatAndEngine,
        //                                    &ChunkOfZeros,
        //                                    &UncompressedChunkHeader );
        //
        //  ASSERT(NT_SUCCESS(Status));
        //

        //
        //  Loop through desired compression units
        //

        while (TRUE) {

            //
            //  Free any Bcb from previous pass
            //

            if (Bcb != NULL) {
                CcUnpinData( Bcb );
                Bcb = NULL;
            }

            //
            //  If there is an uncompressed stream, then we have to synchronize with that.
            //

            if (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL) {
                Status = NtfsSynchronizeCompressedIo( (PSCB)Header,
                                                      &LocalOffset,
                                                      Length,
                                                      TRUE,
                                                      &CompressionSync );

                if (!NT_SUCCESS(Status)) {
                    ASSERT( Status == STATUS_USER_MAPPED_FILE );
                    leave;
                }
            }

            //
            //  Determine whether or not this is a full overwrite of a
            //  compression unit.
            //

            FullOverwrite = (LocalOffset >= Header->ValidDataLength.QuadPart)

                                ||

                            ((LocalOffset >= FileOffset->QuadPart) &&
                             (Length >= CompressionUnitSize));


            //
            //  Calculate how much of current compression unit is being
            //  written, uncompressed.
            //

            SavedLength = Length;
            if (SavedLength > CompressionUnitSize) {
                SavedLength = CompressionUnitSize;
            }

            //
            //  If we are not at the start of a compression unit, calculate the
            //  index of the chunk we will be working on, and reduce SavedLength
            //  accordingly.
            //

            i = 0;
            if (LocalOffset < FileOffset->QuadPart) {
                i = (ULONG)(FileOffset->QuadPart - LocalOffset);
                SavedLength -= i;
                i >>= CompressedDataInfo->ChunkShift;
            }

            //
            //  Loop to calculate sum of chunk sizes being written, handling both empty
            //  and uncompressed chunk cases.  We will remember the nonzero size of each
            //  chunk being written so we can merge this info with the sizes of any chunks
            //  not being overwritten below.
            //  Reserve space for a chunk of zeroes for each chunk ahead of the first one
            //  being written.
            //

            SizeToPin = ChunkOfZeros * i;
            TempUlong = SavedLength >> CompressedDataInfo->ChunkShift;
            TempChunkSize = NextChunkSize;
            RtlZeroMemory( ChunkSizes, sizeof( ChunkSizes ));

            while (TempUlong--) {

                ChunkSizes[i] = *TempChunkSize;
                if (*TempChunkSize == 0) {
                    ChunkSizes[i] += ChunkOfZeros;
                    ASSERT(ChunkOfZeros != 0);
                } else if (*TempChunkSize == ChunkSize) {
                    ChunkSizes[i] += UncompressedChunkHeader;
                }
                SizeToPin += ChunkSizes[i];
                TempChunkSize++;
                i += 1;
            }

            //
            //  If this is not a full overwrite, get the current compression unit
            //  size and make sure we pin at least that much.  Don't bother to check
            //  the allocation if this range of the file has not been written yet.
            //

            if (!FullOverwrite && (LocalOffset < ((PSCB)Header)->ValidDataToDisk)) {

                NtfsFastIoQueryCompressedSize( FileObject,
                                               (PLARGE_INTEGER)&LocalOffset,
                                               &TempUlong );

                ASSERT( TempUlong <= CompressionUnitSize );

                if (TempUlong > SizeToPin) {
                    SizeToPin = TempUlong;
                }
            }

            //
            //  At this point we are ready to overwrite data in the compression
            //  unit.  See if the data is really compressed.
            //
            //  If it looks like we are beyond ValidDataToDisk, then assume it is compressed
            //  for now, and we will see for sure later when we get the data pinned.  This
            //  is actually an unsafe test that will occassionally send us down the "wrong"
            //  path.  However, it is always safe to take the uncompressed path, and if we
            //  think the data is compressed, we always check again below.
            //

            IsCompressed = (BOOLEAN)(((SizeToPin <= (CompressionUnitSize - ClusterSize)) ||
                                      (LocalOffset >= ((PSCB)Header)->ValidDataToDisk)) &&
                                     EngineMatches);

            //
            //  Possibly neither the new nor old data for this CompressionUnit is
            //  nonzero, so we must pin something so that we can cause any old allocation
            //  to get deleted.  This code relies on any compression algorithm being
            //  able to express an entire compression unit of 0's in one page or less.
            //

            if (SizeToPin == 0) {
                SizeToPin = PAGE_SIZE;

            } else {

                //
                //  Add a ulong for the null terminator.
                //

                SizeToPin += sizeof( ULONG );
            }

            Status = STATUS_SUCCESS;

            //
            //  Round the pin size to a page boundary.  Then we can tell when we need to pin a larger range.
            //

            SizeToPin = (SizeToPin + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

            //
            //  Save current length in case we have to restart our work in
            //  the uncompressed stream.
            //

            TempChunkSize = NextChunkSize;
            SavedLength = Length;
            SavedBuffer = Buffer;

            if (IsCompressed) {

                //
                //  Map the compression unit in the compressed stream.
                //

                if (FullOverwrite) {

                    //
                    //  If we are overwriting the entire compression unit, then
                    //  call CcPreparePinWrite so that empty pages may be used
                    //  instead of reading the file.  Also force the byte count
                    //  to integral pages, so no one thinks we need to read the
                    //  last page.
                    //

                    CcPreparePinWrite( Header->FileObjectC,
                                       (PLARGE_INTEGER)&LocalOffset,
                                       SizeToPin,
                                       FALSE,
                                       PIN_WAIT | PIN_EXCLUSIVE,
                                       &Bcb,
                                       &CacheBuffer );

                    //
                    //  Now that we are synchronized with the buffer, see if someone snuck
                    //  in behind us and created the noncached stream since we last checked
                    //  for that stream.  If so we have to go back and get correctly synchronized.
                    //

                    if ((CompressionSync == NULL) &&
                        (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                        continue;
                    }

                    //
                    //  If it is a full overwrite, we need to initialize an empty
                    //  buffer.  ****  This is not completely correct, we otherwise
                    //  need a routine to initialize an empty compressed data buffer.
                    //

                    *(PULONG)CacheBuffer = 0;

#ifdef NTFS_RWC_DEBUG
                    if ((LocalOffset < NtfsRWCHighThreshold) &&
                        (LocalOffset + SizeToPin > NtfsRWCLowThreshold)) {

                        PRWC_HISTORY_ENTRY NextBuffer;

                        //
                        //  Check for the case where we don't have a full Bcb.
                        //

                        if (SafeNodeType( Bcb ) == CACHE_NTC_OBCB) {

                            PPUBLIC_BCB NextBcb;

                            NextBcb = ((POBCB) Bcb)->Bcbs[0];

                            NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                            NextBuffer->Operation = PartialBcb;
                            NextBuffer->Information = 0;
                            NextBuffer->FileOffset = (ULONG) NextBcb->MappedFileOffset.QuadPart;
                            NextBuffer->Length = NextBcb->MappedLength;

                            ASSERT( NextBuffer->Length <= SizeToPin );

                        } else {

                            PPUBLIC_BCB NextBcb;
                            ASSERT( SafeNodeType( Bcb ) == CACHE_NTC_BCB );

                            NextBcb = (PPUBLIC_BCB) Bcb;

                            ASSERT( LocalOffset + SizeToPin <= NextBcb->MappedFileOffset.QuadPart + NextBcb->MappedLength );
                        }

                        NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                        NextBuffer->Operation = FullOverwrite;
                        NextBuffer->Information = 0;
                        NextBuffer->FileOffset = (ULONG) LocalOffset;
                        NextBuffer->Length = (ULONG) SizeToPin;

                    }
#endif

                } else {

                    //
                    //  Read the data from the compressed stream that we will combine
                    //  with the chunks being written.
                    //

                    CcPinRead( Header->FileObjectC,
                               (PLARGE_INTEGER)&LocalOffset,
                               SizeToPin,
                               PIN_WAIT | PIN_EXCLUSIVE,
                               &Bcb,
                               &CacheBuffer );

                    //
                    //  Now that we are synchronized with the buffer, see if someone snuck
                    //  in behind us and created the noncached stream since we last checked
                    //  for that stream.  If so we have to go back and get correctly synchronized.
                    //

                    if ((CompressionSync == NULL) &&
                        (((PSCB)Header)->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                        continue;
                    }

                    //
                    //  Now that the data is pinned (we are synchronized with the
                    //  CompressionUnit), we need to recalculate how much should be
                    //  pinned.  We do this by summing up all the sizes of the chunks
                    //  that are being written with the sizes of the existing chunks
                    //  that will remain.
                    //

                    StartOfPin = CacheBuffer;
                    EndOfCacheBuffer = Add2Ptr( CacheBuffer, CompressionUnitSize - ClusterSize );

                    i = 0;

                    //
                    //  Loop through to find all the existing chunks, and remember their
                    //  sizes if they are not being overwritten.  (Remember if we overwrite
                    //  with a chunk of all zeros, it takes nonzero bytes to do it!)
                    //
                    //  This loop completes the formation of an array of chunksizes.  The
                    //  start of the array is guaranteed to be nonzero, and it terminates
                    //  with a chunk size of 0.  Note if fewer chunks are filled in than
                    //  exist in the compression unit, that is ok - we do not need to write
                    //  trailing chunks of 0's.
                    //

                    ChunksSeen = FALSE;
                    while (i < 16) {

                        Status = RtlDescribeChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                   &StartOfPin,
                                                   EndOfCacheBuffer,
                                                   &ChunkBuffer,
                                                   &TempUlong );

                        //
                        //  If there are no more entries, see if we are done, else treat
                        //  it as a chunk of 0's.
                        //

                        if (!NT_SUCCESS(Status)) {

                            ASSERT(Status == STATUS_NO_MORE_ENTRIES);

                            if (ChunksSeen) {
                                break;
                            }

                            TempUlong = ChunkOfZeros;

                        //
                        //  Make sure we enter the length for a chunk of zeroes.
                        //

                        } else if (TempUlong == 0) {

                            TempUlong = ChunkOfZeros;
                        }

                        if (ChunkSizes[i] == 0) {
                            ChunkSizes[i] = TempUlong;
                        } else {
                            ChunksSeen = TRUE;
                        }

                        i += 1;
                    }

                    //
                    //  Now sum up the sizes of the chunks we will write.
                    //

                    i = 0;
                    TempUlong = 0;
                    while (ChunkSizes[i] != 0) {
                        TempUlong += ChunkSizes[i];
                        i += 1;
                    }

                    //
                    //  If the existing data is larger, pin that range.
                    //

                    if (TempUlong < PtrOffset(CacheBuffer, StartOfPin)) {
                        TempUlong = PtrOffset(CacheBuffer, StartOfPin);
                    }

                    IsCompressed = (TempUlong <= (CompressionUnitSize - ClusterSize));

                    //
                    //  We now know if we will really end up with compressed data, so
                    //  get out now stop processing if the data is not compressed.
                    //

                    if (IsCompressed) {

                        TempUlong += sizeof(ULONG);

                        //
                        //  Now we have to repin if we actually need more space.
                        //

                        if (TempUlong > SizeToPin) {

                            SizeToPin = (TempUlong + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

                            TempBcb = Bcb;
                            Bcb = NULL;

                            //
                            //  Read the data from the compressed stream that we will combine
                            //  with the chunks being written.
                            //

                            CcPinRead( Header->FileObjectC,
                                       (PLARGE_INTEGER)&LocalOffset,
                                       SizeToPin,
                                       PIN_WAIT | PIN_EXCLUSIVE,
                                       &Bcb,
                                       &CacheBuffer );

                            CcUnpinData( TempBcb );
                            TempBcb = NULL;
                        }

                        ASSERT( TempUlong <= CompressionUnitSize );

                        //
                        //  Really make the data dirty by physically modifying a byte
                        //  in each page.
                        //

                        TempUlong = 0;

                        while (TempUlong < SizeToPin) {

                            volatile PULONG NextBuffer;

                            NextBuffer = Add2Ptr( CacheBuffer, TempUlong );

                            *NextBuffer = *NextBuffer;
                            TempUlong += PAGE_SIZE;
                        }

#ifdef NTFS_RWC_DEBUG
                        if ((LocalOffset < NtfsRWCHighThreshold) &&
                            (LocalOffset + SizeToPin > NtfsRWCLowThreshold)) {

                            PRWC_HISTORY_ENTRY NextBuffer;

                            NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                            NextBuffer->Operation = SetDirty;
                            NextBuffer->Information = 0;
                            NextBuffer->FileOffset = (ULONG) LocalOffset;
                            NextBuffer->Length = (ULONG) SizeToPin;
                        }
#endif

                        CcSetDirtyPinnedData( Bcb, NULL );
                    }
                }

                EndOfCacheBuffer = Add2Ptr( CacheBuffer, CompressionUnitSize - ClusterSize );

                //
                //  Now loop through desired chunks (if it is still compressed)
                //

                if (IsCompressed) {

                    do {

                        //
                        //  We may not have reached the first chunk yet.
                        //

                        if (LocalOffset >= FileOffset->QuadPart) {

                            //
                            //  Reserve space for the current chunk.
                            //

                            Status = RtlReserveChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                      &CacheBuffer,
                                                      EndOfCacheBuffer,
                                                      &ChunkBuffer,
                                                      *TempChunkSize );

                            if (!NT_SUCCESS(Status)) {
                                break;
                            }

                            //
                            //  If the caller wants an MdlChain, then handle the Mdl
                            //  processing here.
                            //

                            if (MdlChain != NULL) {

                                //
                                //  If we have not started remembering an Mdl buffer,
                                //  then do so now.
                                //

                                if (MdlLength == 0) {

                                    MdlBuffer = ChunkBuffer;

                                //
                                //  Otherwise we just have to increase the length
                                //  and check for an uncompressed chunk, because that
                                //  forces us to emit the previous Mdl since we do
                                //  not transmit the chunk header in this case.
                                //

                                } else {

                                    //
                                    //  In the rare case that we hit an individual chunk
                                    //  that did not compress or is all 0's, we have to
                                    //  emit what we had (which captures the Bcb pointer),
                                    //  and start a new Mdl buffer.
                                    //

                                    if ((*TempChunkSize == ChunkSize) || (*TempChunkSize == 0)) {

                                        NtfsAddToCompressedMdlChain( MdlChain,
                                                                     MdlBuffer,
                                                                     MdlLength,
                                                                     Header->PagingIoResource,
                                                                     Bcb,
                                                                     IoWriteAccess,
                                                                     TRUE );
                                        Bcb = NULL;
                                        MdlBuffer = ChunkBuffer;
                                        MdlLength = 0;
                                    }
                                }

                                MdlLength += *TempChunkSize;

                            //
                            //  Else copy next chunk (compressed or not).
                            //

                            } else {

                                RtlCopyBytes( ChunkBuffer, Buffer, *TempChunkSize );

                                //
                                //  Advance input buffer by bytes copied.
                                //

                                Buffer = (PCHAR)Buffer + *TempChunkSize;
                            }

                            TempChunkSize += 1;

                        //
                        //  If we are skipping over a nonexistant chunk, then we have
                        //  to reserve a chunk of zeros.
                        //

                        } else {

                            //
                            //  If we have not reached our chunk, then describe the current
                            //  chunk in order to skip over it.
                            //

                            Status = RtlDescribeChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                       &CacheBuffer,
                                                       EndOfCacheBuffer,
                                                       &ChunkBuffer,
                                                       &TempUlong );

                            //
                            //  If there is not current chunk, we must insert a chunk of zeros.
                            //

                            if (Status == STATUS_NO_MORE_ENTRIES) {

                                Status = RtlReserveChunk( CompressedDataInfo->CompressionFormatAndEngine,
                                                          &CacheBuffer,
                                                          EndOfCacheBuffer,
                                                          &ChunkBuffer,
                                                          0 );

                                if (!NT_SUCCESS(Status)) {
                                    ASSERT(NT_SUCCESS(Status));
                                    break;
                                }

                            //
                            //  Get out if we got some other kind of unexpected error.
                            //

                            } else if (!NT_SUCCESS(Status)) {
                                ASSERT(NT_SUCCESS(Status));
                                break;
                            }
                        }

                        //
                        //  Reduce length by chunk copied, and check if we are done.
                        //

                        if (Length > ChunkSize) {
                            Length -= ChunkSize;
                        } else {
                            goto Done;
                        }

                        LocalOffset += ChunkSize;

                    } while ((LocalOffset & (CompressionUnitSize - 1)) != 0);

                    //
                    //  If this is an Mdl call, then it is time to add to the MdlChain
                    //  before moving to the next compression unit.
                    //

                    if (MdlLength != 0) {
                        NtfsAddToCompressedMdlChain( MdlChain,
                                                     MdlBuffer,
                                                     MdlLength,
                                                     Header->PagingIoResource,
                                                     Bcb,
                                                     IoWriteAccess,
                                                     TRUE );
                        Bcb = NULL;
                        MdlLength = 0;
                    }
                }
            }

            //
            //  Uncompressed loop.
            //

            if (!IsCompressed || !NT_SUCCESS(Status)) {

                //
                //  If we get here for an Mdl request, just tell him to send
                //  it uncompressed!
                //

                if (MdlChain != NULL) {
                    if (NT_SUCCESS(Status)) {
                        Status = STATUS_BUFFER_OVERFLOW;
                    }
                    goto Done;

                //
                //  If we are going to write the uncompressed stream,
                //  we have to make sure it is there.
                //

                } else if (((PSCB)Header)->FileObject == NULL) {
                    Status = STATUS_NOT_MAPPED_DATA;
                    goto Done;
                }

                //
                //  Restore sizes and pointers to the beginning of the
                //  current compression unit, and we will handle the
                //  data uncompressed.
                //

                LocalOffset -= SavedLength - Length;
                Length = SavedLength;
                Buffer = SavedBuffer;
                TempChunkSize = NextChunkSize;

                //
                //  We may have a Bcb from the above loop to unpin.
                //  Then we must flush and purge the compressed
                //  stream before proceding.
                //

                if (Bcb != NULL) {
                    CcUnpinData(Bcb);
                    Bcb = NULL;
                }

                //
                //  We must first flush and purge the compressed stream
                //  since we will be writing into the uncompressed stream.
                //  The flush is actually only necessary if we are not doing
                //  a full overwrite anyway.
                //

                if (!FullOverwrite) {
                    CcFlushCache( Header->FileObjectC->SectionObjectPointer,
                                  (PLARGE_INTEGER)&LocalOffset,
                                  CompressionUnitSize,
                                  NULL );
                }

                CcPurgeCacheSection( Header->FileObjectC->SectionObjectPointer,
                                     (PLARGE_INTEGER)&LocalOffset,
                                     CompressionUnitSize,
                                     FALSE );

                //
                //  If LocalOffset was rounded down to a compression
                //  unit boundary (must have failed in the first
                //  compression unit), then start from the actual
                //  starting FileOffset.
                //

                if (LocalOffset < FileOffset->QuadPart) {
                    Length -= (ULONG)(FileOffset->QuadPart - LocalOffset);
                    LocalOffset = FileOffset->QuadPart;
                }

                //
                //  Map the compression unit in the uncompressed
                //  stream.
                //

                SizeToPin = (((Length < CompressionUnitSize) ? Length : CompressionUnitSize) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

                CcPinRead( ((PSCB)Header)->FileObject,
                           (PLARGE_INTEGER)&LocalOffset,
                           SizeToPin,
                           TRUE,
                           &Bcb,
                           &CacheBuffer );

                CcSetDirtyPinnedData( Bcb, NULL );

                //
                //  Now loop through desired chunks
                //

                do {

                    //
                    //  If this chunk is compressed, then decompress it
                    //  into the cache.
                    //

                    if (*TempChunkSize != ChunkSize) {

                        Status = RtlDecompressBuffer( CompressedDataInfo->CompressionFormatAndEngine,
                                                      CacheBuffer,
                                                      ChunkSize,
                                                      Buffer,
                                                      *TempChunkSize,
                                                      &SavedLength );

                        //
                        //  See if the data is ok.
                        //

                        if (!NT_SUCCESS(Status)) {
                            ASSERT(NT_SUCCESS(Status));
                            goto Done;
                        }

                        //
                        //  Zero to the end of the chunk if it was not all there.
                        //

                        if (SavedLength != ChunkSize) {
                            RtlZeroMemory( Add2Ptr(CacheBuffer, SavedLength),
                                           ChunkSize - SavedLength );
                        }

                    } else {

                        //
                        //  Copy next chunk (it's not compressed).
                        //

                        RtlCopyBytes( CacheBuffer, Buffer, ChunkSize );
                    }

                    //
                    //  Advance input buffer by bytes copied.
                    //

                    Buffer = (PCHAR)Buffer + *TempChunkSize;
                    CacheBuffer = (PCHAR)CacheBuffer + ChunkSize;
                    TempChunkSize += 1;

                    //
                    //  Reduce length by chunk copied, and check if we are done.
                    //

                    if (Length > ChunkSize) {
                        Length -= ChunkSize;
                    } else {
                        goto Done;
                    }

                    LocalOffset += ChunkSize;

                } while ((LocalOffset & (CompressionUnitSize - 1)) != 0);
            }

            //
            //  Now we can finally advance our pointer into the chunk sizes.
            //

            NextChunkSize = TempChunkSize;
        }

    Done: NOTHING;

        if ((MdlLength != 0) && NT_SUCCESS(Status)) {
            NtfsAddToCompressedMdlChain( MdlChain,
                                         MdlBuffer,
                                         MdlLength,
                                         Header->PagingIoResource,
                                         Bcb,
                                         IoWriteAccess,
                                         TRUE );
            Bcb = NULL;
        }

    } except( FsRtlIsNtstatusExpected((Status = GetExceptionCode()))
                                    ? EXCEPTION_EXECUTE_HANDLER
                                    : EXCEPTION_CONTINUE_SEARCH ) {

        NOTHING;
    }

    //
    //  Unpin the Bcbs we still have.
    //

    if (TempBcb != NULL) {
        CcUnpinData( TempBcb );
    }
    if (Bcb != NULL) {
        CcUnpinData( Bcb );
    }
    if (CompressionSync != NULL) {
        NtfsReleaseCompressionSync( CompressionSync );
    }

    //
    //  Perform Mdl-specific processing.
    //

    if (MdlChain != NULL) {

        //
        //  On error, cleanup any MdlChain we built up
        //

        if (!NT_SUCCESS(Status)) {

            NtfsCleanupCompressedMdlChain( *MdlChain, TRUE );
            *MdlChain = NULL;

        //
        //  Change owner Id for the Scb and Bcbs we are holding.
        //

        } else if (*MdlChain != NULL) {

            NtfsSetMdlBcbOwners( *MdlChain );
            ExSetResourceOwnerPointer( Header->PagingIoResource, (PVOID)((PCHAR)*MdlChain + 3) );
        }
    }

#ifdef NTFS_RWCMP_TRACE
    if (NtfsCompressionTrace && IsSyscache(Header)) {
        DbgPrint("  Return Status = %08lx\n", Status);
    }
#endif
    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}


BOOLEAN
NtfsMdlWriteCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine frees resources and the Mdl Chain after a compressed write.

Arguments:

    FileObject - pointer to the file object for the request.

    MdlChain - as returned from compressed write.

    DeviceObject - As required for a fast I/O routine.

Return Value:

    TRUE - if fast path succeeded

    FALSE -  if an Irp is required

--*/

{
    PERESOURCE ResourceToRelease;

    if (MdlChain != NULL) {

        ResourceToRelease = *(PERESOURCE *)Add2Ptr( MdlChain, MdlChain->Size + sizeof( PBCB ));

        NtfsCleanupCompressedMdlChain( MdlChain, FALSE );

        //
        //  Release the held resource.
        //

        ExReleaseResourceForThread( ResourceToRelease, (ERESOURCE_THREAD)((PCHAR)MdlChain + 3) );
    }
    return TRUE;

    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( FileOffset );
}


VOID
NtfsAddToCompressedMdlChain (
    IN OUT PMDL *MdlChain,
    IN PVOID MdlBuffer,
    IN ULONG MdlLength,
    IN PERESOURCE ResourceToRelease OPTIONAL,
    IN PBCB Bcb,
    IN LOCK_OPERATION Operation,
    IN ULONG IsCompressed
    )

/*++


Routine Description:

    This routine creates and Mdl for the described buffer and adds it to
    the chain.

Arguments:

    MdlChain - MdlChain pointer to append the first/new Mdl to.

    MdlBuffer - Buffer address for this Mdl.

    MdlLength - Length of buffer in bytes.

    ResourceToRelease - Indicates which resource to release, only specified for compressed IO.

    Bcb - Bcb to remember with this Mdl, to be freed when Mdl completed

    Operation - IoReadAccess or IoWriteAccess

    IsCompressed - Supplies TRUE if the Bcb is in the compressed stream

Return Value:

    None.

--*/

{
    PMDL Mdl, MdlTemp;

    ASSERT(sizeof(ULONG) == sizeof(PBCB));

    //
    //  Now attempt to allocate an Mdl to describe the mapped data.
    //  We "lie" about the length of the buffer by one page, in order
    //  to get an extra field to store a pointer to the Bcb in.
    //

    Mdl = IoAllocateMdl( MdlBuffer,
                         (MdlLength + (2 * PAGE_SIZE)),
                         FALSE,
                         FALSE,
                         NULL );

    if (Mdl == NULL) {
        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Now subtract out the space we reserved for our Bcb pointer
    //  and then store it.
    //

    Mdl->Size -= 2 * sizeof(ULONG);
    Mdl->ByteCount -= 2 * PAGE_SIZE;

    //
    //  Note that this probe should never fail, because we can
    //  trust the address returned from CcPinFileData.  Therefore,
    //  if we succeed in allocating the Mdl above, we should
    //  manage to elude any expected exceptions through the end
    //  of this loop.
    //

    if (Mdl->ByteCount != 0) {
        MmProbeAndLockPages( Mdl, KernelMode, Operation );
    }

    //
    //  Only store the Bcb if this is the compressed stream.
    //

    if (!IsCompressed && (Bcb != NULL)) {
        Bcb = NULL;
    }
    *(PBCB *)Add2Ptr( Mdl, Mdl->Size ) = Bcb;
    *(PERESOURCE *)Add2Ptr( Mdl, Mdl->Size + sizeof( PBCB )) = ResourceToRelease;

    //
    //  Now link the Mdl into the caller's chain
    //

    if ( *MdlChain == NULL ) {
        *MdlChain = Mdl;
    } else {
        MdlTemp = CONTAINING_RECORD( *MdlChain, MDL, Next );
        while (MdlTemp->Next != NULL) {
            MdlTemp = MdlTemp->Next;
        }
        MdlTemp->Next = Mdl;
    }
}

VOID
NtfsSetMdlBcbOwners (
    IN PMDL MdlChain
    )

/*++

Routine Description:

    This routine may be called to set all of the Bcb resource owners in an Mdl
    to be equal to the address of the first element in the MdlChain, so that they
    can be freed in the context of a different thread.

Arguments:

    MdlChain - Supplies the MdlChain to process

Return Value:

    None.

--*/

{
    PBCB Bcb;

    while (MdlChain != NULL) {

        //
        //  Unpin the Bcb we saved away, and restore the Mdl counts
        //  we altered.
        //

        Bcb = *(PBCB *)Add2Ptr(MdlChain, MdlChain->Size);
        if (Bcb != NULL) {
            CcSetBcbOwnerPointer( Bcb, (PVOID)((PCHAR)MdlChain + 3) );
        }

        MdlChain = MdlChain->Next;
    }
}

VOID
NtfsCleanupCompressedMdlChain (
    IN PMDL MdlChain,
    IN ULONG Error
    )

/*++

Routine Description:

    This routine is called to free all of the resources associated with a
    compressed Mdl chain.  It may be called for an error in the processing
    of a request or when a request completes.

Arguments:

    MdlChain - Supplies the address of the first element in the chain to clean up.

    Error - Supplies TRUE on error (resources are still owned by current thread) or
            FALSE on a normal completion (resources owned by MdlChain).

Return Value:

    None.

--*/

{
    PMDL MdlTemp;
    PBCB Bcb;

    while (MdlChain != NULL) {

        //
        //  Save a pointer to the next guy in the chain.
        //

        MdlTemp = MdlChain->Next;

        //
        //  Unlock the pages.
        //

        if (MdlChain->ByteCount != 0) {
            MmUnlockPages( MdlChain );
        }

        //
        //  Unpin the Bcb we saved away, and restore the Mdl counts
        //  we altered.
        //

        Bcb = *(PBCB *)Add2Ptr(MdlChain, MdlChain->Size);
        if (Bcb != NULL) {
            if (Error) {
                CcUnpinData( Bcb );
            } else {

                CcUnpinDataForThread( Bcb, (ERESOURCE_THREAD)((PCHAR)MdlChain + 3) );
            }
        }

        MdlChain->Size += 2 * sizeof(ULONG);
        MdlChain->ByteCount += 2 * PAGE_SIZE;

        IoFreeMdl( MdlChain );

        MdlChain = MdlTemp;
    }
}


NTSTATUS
NtfsSynchronizeUncompressedIo (
    IN PSCB Scb,
    IN PLONGLONG FileOffset OPTIONAL,
    IN ULONG Length,
    IN ULONG WriteAccess,
    IN OUT PCOMPRESSION_SYNC *CompressionSync
    )

/*++

Routine Description:

    This routine attempts to synchronize with the compressed data cache,
    for an I/O in the uncompressed cache.  The view in the compressed cache
    is locked shared or exclusive without reading.  Then the compressed cache
    is flushed and purged as appropriate.

    We will allocate a COMPRESSION_SYNC structure to serialize each cache
    manager view and use that for the locking granularity.

Arguments:

    Scb - Supplies the Scb for the stream.

    FileOffset - Byte offset in file for desired data.  NULL if we are to
        flush and purge the entire file.

    Length - Length of desired data in bytes.

    WriteAccess - Supplies TRUE if the caller plans to do a write, or FALSE
                  for a read.

    CompressionSync - Synchronization object to serialize access to the view.
        The caller's routine is responsible for releasing this.

Return Value:

    Status of the flush operation, or STATUS_UNSUCCESSFUL for a WriteAccess
    where the purge failed.

--*/

{
    ULONG Change = 0;
    IO_STATUS_BLOCK IoStatus;
    PSECTION_OBJECT_POINTERS SectionObjectPointers = &Scb->NonpagedScb->SegmentObjectC;
    LONGLONG LocalFileOffset;
    PLONGLONG LocalOffsetPtr;

    if (ARGUMENT_PRESENT( FileOffset )) {

        LocalFileOffset = *FileOffset & ~(VACB_MAPPING_GRANULARITY - 1);
        LocalOffsetPtr = &LocalFileOffset;
        ASSERT( ((*FileOffset & (VACB_MAPPING_GRANULARITY - 1)) + Length) <= VACB_MAPPING_GRANULARITY );

    } else {

        LocalFileOffset = 0;
        LocalOffsetPtr = NULL;
        Length = 0;
    }

    IoStatus.Status = STATUS_SUCCESS;
    if ((*CompressionSync == NULL) || ((*CompressionSync)->FileOffset != LocalFileOffset)) {

        if (*CompressionSync != NULL) {

            NtfsReleaseCompressionSync( *CompressionSync );
            *CompressionSync = NULL;
        }

        *CompressionSync = NtfsAcquireCompressionSync( LocalFileOffset, Scb, WriteAccess );

        //
        //  Always flush the remainder of the Vacb.  This is to prevent a problem if MM reads additional
        //  pages into section because of the page fault clustering.
        //

        if (ARGUMENT_PRESENT( FileOffset )) {

            LocalFileOffset = *FileOffset & ~((ULONG_PTR)Scb->CompressionUnit - 1);
            Length = VACB_MAPPING_GRANULARITY - (((ULONG) LocalFileOffset) & (VACB_MAPPING_GRANULARITY - 1));
        }

        //
        //  We must always flush the other cache.
        //

        CcFlushCache( SectionObjectPointers,
                      (PLARGE_INTEGER) LocalOffsetPtr,
                      Length,
                      &IoStatus );

#ifdef NTFS_RWCMP_TRACE
        if (NtfsCompressionTrace && IsSyscache(Scb)) {
            DbgPrint("  CcFlushCache: FO = %08lx, Len = %08lx, IoStatus = %08lx, Scb = %08lx\n",
                     (ULONG)LocalFileOffset,
                     Length,
                     IoStatus.Status,
                     Scb );
        }
#endif

        //
        //  On writes, we purge the other cache after a successful flush.
        //

        if (WriteAccess && NT_SUCCESS(IoStatus.Status)) {

            if (!CcPurgeCacheSection( SectionObjectPointers,
                                      (PLARGE_INTEGER) LocalOffsetPtr,
                                      Length,
                                      FALSE )) {

                return STATUS_UNSUCCESSFUL;
            }
        }
    }

    return IoStatus.Status;
}


NTSTATUS
NtfsSynchronizeCompressedIo (
    IN PSCB Scb,
    IN PLONGLONG FileOffset,
    IN ULONG Length,
    IN ULONG WriteAccess,
    IN OUT PCOMPRESSION_SYNC *CompressionSync
    )

/*++

Routine Description:

    This routine attempts to synchronize with the uncompressed data cache,
    for an I/O in the compressed cache.  The range in the compressed cache
    is assumed to already be locked by the caller.  Then the uncompressed cache
    is flushed and purged as appropriate.

    We will allocate a COMPRESSION_SYNC structure to serialize each cache
    manager view and use that for the locking granularity.

Arguments:

    Scb - Supplies the Scb for the stream.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    WriteAccess - Supplies TRUE if the caller plans to do a write, or FALSE
                  for a read.

    CompressionSync - Synchronization object to serialize access to the view.
        The caller's routine is responsible for releasing this.

Return Value:

    Status of the flush operation, or STATUS_USER_MAPPED_FILE for a WriteAccess
    where the purge failed.  (This is the only expected case where a purge would
    fail.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    PSECTION_OBJECT_POINTERS SectionObjectPointers = &Scb->NonpagedScb->SegmentObject;
    LONGLONG LocalFileOffset = *FileOffset & ~(VACB_MAPPING_GRANULARITY - 1);

    IoStatus.Status = STATUS_SUCCESS;
    if ((*CompressionSync == NULL) || ((*CompressionSync)->FileOffset != LocalFileOffset)) {

        //
        //  Release any previous view and Lock the current view.
        //

        if (*CompressionSync != NULL) {

            NtfsReleaseCompressionSync( *CompressionSync );
            *CompressionSync = NULL;
        }

        *CompressionSync = NtfsAcquireCompressionSync( LocalFileOffset, Scb, WriteAccess );

        //
        //  Now that we are synchronized on a view, test for a write to a user-mapped file.
        //  In case we keep hitting this path, this is better than waiting for a purge to
        //  fail.
        //

        if (WriteAccess && 
            (FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE ) ||
             FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE ))) {
            return  STATUS_USER_MAPPED_FILE;
        }

        //
        //  Always flush the remainder of the Vacb.  This is to prevent a problem if MM reads additional
        //  pages into section because of the page fault clustering.
        //

        LocalFileOffset = *FileOffset & ~((ULONG_PTR)Scb->CompressionUnit - 1);
        Length = VACB_MAPPING_GRANULARITY - (((ULONG) LocalFileOffset) & (VACB_MAPPING_GRANULARITY - 1));

        //
        //  We must always flush the other cache.
        //

        CcFlushCache( SectionObjectPointers,
                      (PLARGE_INTEGER)&LocalFileOffset,
                      Length,
                      &IoStatus );

        //
        //  On writes, we purge the other cache after a successful flush.
        //

        if (WriteAccess && NT_SUCCESS(IoStatus.Status)) {

            if (!CcPurgeCacheSection( SectionObjectPointers,
                                      (PLARGE_INTEGER)&LocalFileOffset,
                                      Length,
                                      FALSE )) {

                return  STATUS_USER_MAPPED_FILE;
            }
        }
    }

    return IoStatus.Status;
}


PCOMPRESSION_SYNC
NtfsAcquireCompressionSync (
    IN LONGLONG FileOffset,
    IN PSCB Scb,
    IN ULONG WriteAccess
    )

/*++

Routine Description:

    This routine is called to lock a range of a stream to serialize the compressed and
    uncompressed IO.

Arguments:

    FileOffset - File offset to lock.  This will be rounded to a cache view boundary.

    Scb - Supplies the Scb for the stream.

    WriteAccess - Indicates if the user wants write access.  We will acquire the range
        exclusively in that case.

Return Value:

    PCOMPRESSION_SYNC - A pointer to the synchronization object for the range.  This routine may
        raise, typically if the structure can't be allocated.

--*/

{
    PCOMPRESSION_SYNC CompressionSync = NULL;
    PCOMPRESSION_SYNC NewCompressionSync;
    BOOLEAN FoundSync = FALSE;

    PAGED_CODE();

    //
    //  Round the file offset down to a view boundary.
    //

    ((PLARGE_INTEGER) &FileOffset)->LowPart &= ~(VACB_MAPPING_GRANULARITY - 1);

    //
    //  Acquire the mutex for the stream.  Then walk and look for a matching resource.
    //

    NtfsAcquireFsrtlHeader( Scb );

    CompressionSync = (PCOMPRESSION_SYNC) Scb->ScbType.Data.CompressionSyncList.Flink;

    while (CompressionSync != (PCOMPRESSION_SYNC) &Scb->ScbType.Data.CompressionSyncList) {

        //
        //  Continue if we haven't found our entry.
        //

        if (CompressionSync->FileOffset < FileOffset) {

            //
            //  Go to the next entry.
            //

            CompressionSync = (PCOMPRESSION_SYNC) CompressionSync->CompressionLinks.Flink;
            continue;
        }

        if (CompressionSync->FileOffset == FileOffset) {

            FoundSync = TRUE;
        }

        //
        //  Exit in any case.
        //

        break;
    }

    //
    //  If we didn't find the entry then attempt to allocate a new one.
    //

    if (!FoundSync) {

        NewCompressionSync = (PCOMPRESSION_SYNC) ExAllocateFromNPagedLookasideList( &NtfsCompressSyncLookasideList );

        //
        //  Release the mutex and raise an error if we couldn't allocate.
        //

        if (NewCompressionSync == NULL) {

            NtfsReleaseFsrtlHeader( Scb );
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  We have the new entry and know where it belongs in the list.  Do the final initialization
        //  and add it to the list.
        //

        NewCompressionSync->FileOffset = FileOffset;
        NewCompressionSync->Scb = Scb;

        //
        //  Add it just ahead of the entry we stopped at.
        //

        InsertTailList( &CompressionSync->CompressionLinks, &NewCompressionSync->CompressionLinks );
        CompressionSync = NewCompressionSync;
    }

    //
    //  We know have the structure.  Reference it so it can't go away.  Then drop the
    //  mutex and wait for it.
    //

    CompressionSync->ReferenceCount += 1;

    NtfsReleaseFsrtlHeader( Scb );

    if (WriteAccess) {

        ExAcquireResourceExclusiveLite( &CompressionSync->Resource, TRUE );

    } else {

        ExAcquireResourceSharedLite( &CompressionSync->Resource, TRUE );
    }

    return CompressionSync;
}


VOID
NtfsReleaseCompressionSync (
    IN PCOMPRESSION_SYNC CompressionSync
    )

/*++

Routine Description:

    This routine is called to release a range in a stream which was locked serial compressed and
    uncompressed IO.

Arguments:

    CompressionSync - Pointer to the synchronization object.

Return Value:

    None.

--*/

{
    PSCB Scb = CompressionSync->Scb;
    PAGED_CODE();

    //
    //  Release the resource and then acquire the mutext for the stream.  If we are the last
    //  reference then free the structure.
    //

    ExReleaseResourceLite( &CompressionSync->Resource );

    NtfsAcquireFsrtlHeader( Scb );

    CompressionSync->ReferenceCount -= 1;
    if (CompressionSync->ReferenceCount == 0) {

        RemoveEntryList( &CompressionSync->CompressionLinks );
        ExFreeToNPagedLookasideList( &NtfsCompressSyncLookasideList, CompressionSync );
    }

    NtfsReleaseFsrtlHeader( Scb );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\resrcsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Ntfs Resource acquisition routines

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

#undef _NTFSLOCKORDER_
#define _NTFS_NTFSDBG_DEFINITIONS_
#include "lockorder.h"

#ifdef NTFSDBG
ULONG NtfsAssertOnLockProb = TRUE;
ULONG NtfsPrintOnLockProb = FALSE;
LONG  NtfsBreakOnState = -1;
PIRP_CONTEXT NtfsBreakOnIrpContext = NULL;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAcquireAllFiles)
#pragma alloc_text(PAGE, NtfsAcquireCheckpointSynchronization)
#pragma alloc_text(PAGE, NtfsAcquireIndexCcb)
#pragma alloc_text(PAGE, NtfsReleaseIndexCcb)
#pragma alloc_text(PAGE, NtfsAcquireExclusiveFcb)
#pragma alloc_text(PAGE, NtfsAcquireSharedFcbCheckWait)
#pragma alloc_text(PAGE, NtfsAcquireExclusiveScb)
#pragma alloc_text(PAGE, NtfsAcquireSharedScbForTransaction)
#pragma alloc_text(PAGE, NtfsAcquireExclusiveVcb)
#pragma alloc_text(PAGE, NtfsAcquireFcbWithPaging)
#pragma alloc_text(PAGE, NtfsAcquireForCreateSection)
#pragma alloc_text(PAGE, NtfsAcquireScbForLazyWrite)
#pragma alloc_text(PAGE, NtfsAcquireFileForCcFlush)
#pragma alloc_text(PAGE, NtfsAcquireFileForModWrite)
#pragma alloc_text(PAGE, NtfsAcquireSharedVcb)
#pragma alloc_text(PAGE, NtfsAcquireVolumeFileForLazyWrite)
#pragma alloc_text(PAGE, NtfsReleaseAllFiles)
#pragma alloc_text(PAGE, NtfsReleaseCheckpointSynchronization)
#pragma alloc_text(PAGE, NtfsReleaseFcbWithPaging)
#pragma alloc_text(PAGE, NtfsReleaseFileForCcFlush)
#pragma alloc_text(PAGE, NtfsReleaseForCreateSection)
#pragma alloc_text(PAGE, NtfsReleaseScbFromLazyWrite)
#pragma alloc_text(PAGE, NtfsReleaseScbWithPaging)
#pragma alloc_text(PAGE, NtfsReleaseSharedResources)
#pragma alloc_text(PAGE, NtfsReleaseVolumeFileFromLazyWrite)
#endif


VOID
NtfsAcquireAllFiles (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Exclusive,
    IN ULONG AcquirePagingIo,
    IN ULONG AcquireAndDrop
    )

/*++

Routine Description:

    This routine non-recursively requires all files on a volume.

Arguments:

    Vcb - Supplies the volume

    Exclusive - Indicates if we should be acquiring all the files exclusively.
        If FALSE then we acquire all the files shared except for files with
        streams which could be part of transactions.

    AcquirePagingIo - Indicates if we need to acquire the paging io resource
        exclusively.  Only needed if a future call will flush the volume
        (i.e. shutdown)

    AcquireAndDrop - Indicates that we only want to acquire and drop each resource.
        Used in cases where we just want to set some state in the Vcb and then
        know that everyone has seen it before proceeding (i.e. Clearing the journal active
        flag).  Should only be TRUE if we want to get the resources exclusive.

Return Value:

    None

--*/

{
    PFCB Fcb;
    PSCB *Scb;
    PSCB NextScb;
    PVOID RestartKey;

    PAGED_CODE();

    //
    //  Check for the correct combination of flags.
    //

    ASSERT( !AcquireAndDrop || Exclusive );

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

    RestartKey = NULL;
    while (TRUE) {

        NtfsAcquireFcbTable( IrpContext, Vcb );
        Fcb = NtfsGetNextFcbTableEntry(Vcb, &RestartKey);
        NtfsReleaseFcbTable( IrpContext, Vcb );

        if (Fcb == NULL) {

            break;
        }

        ASSERT_FCB( Fcb );

        //
        //  We can skip over the Fcb's for any of the Scb's in the Vcb.
        //  We delay acquiring those to avoid deadlocks.
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

            //
            //  If there is a paging Io resource then acquire this if required.
            //

            if (AcquirePagingIo && (Fcb->PagingIoResource != NULL)) {

                NtfsAcquirePagingResourceExclusive( IrpContext, Fcb, TRUE );

                if (AcquireAndDrop) {

                    NtfsReleasePagingResource( IrpContext, Fcb );
                }
            }

            //
            //  Acquire this Fcb whether or not the underlying file has been deleted.
            //

            if (Exclusive ||
                IsDirectory( &Fcb->Info )) {

                if (AcquireAndDrop) {

                    NtfsAcquireResourceExclusive( IrpContext, Fcb, TRUE );
                    NtfsReleaseResource( IrpContext, Fcb );

                } else {

                    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                }

            } else {

                //
                //  Assume that we only need this file shared.  We will then
                //  look for Lsn related streams.
                //

                NtfsAcquireSharedFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );

                //
                //  Walk through all of the Scb's for the file and look for
                //  an Lsn protected stream.
                //

                NtfsLockFcb( IrpContext, Fcb );

                NextScb = NULL;

                while (NextScb = NtfsGetNextChildScb( Fcb, NextScb )) {

                    if (NextScb->AttributeTypeCode != $DATA) {
                        break;
                    }
                }

                NtfsUnlockFcb( IrpContext, Fcb );

                //
                //  If we found a protected Scb then release and reacquire the Fcb
                //  exclusively.
                //

                if (NextScb != NULL) {

                    NtfsReleaseFcb( IrpContext, Fcb );
                    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                }
            }
        }
    }

    //
    //  Now acquire the Fcb's in the Vcb.
    //

    Scb = &Vcb->MftBitmapScb;

    //
    //  Ordering dependent on the fact we acquired root up above because its not a system file
    //

    ASSERT( (NULL == Vcb->RootIndexScb) || !FlagOn( Vcb->RootIndexScb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE  ) );

    while (TRUE) {

        if (Scb == &Vcb->UsnJournal) {

            break;
        }

        Scb -= 1;

        if ((*Scb != NULL)
            && (*Scb != Vcb->BitmapScb)) {

            if (AcquireAndDrop) {

                if (AcquirePagingIo && ((*Scb)->Fcb->PagingIoResource != NULL)) {

                    NtfsAcquirePagingResourceExclusive( IrpContext, (*Scb)->Fcb, TRUE );
                    NtfsReleasePagingResource( IrpContext, (*Scb)->Fcb );

                }

                NtfsAcquireResourceExclusive( IrpContext, (*Scb), TRUE );
                NtfsReleaseResource( IrpContext, (*Scb) );

            } else {

                if (AcquirePagingIo && ((*Scb)->Fcb->PagingIoResource != NULL)) {

                    NtfsAcquirePagingResourceExclusive( IrpContext, (*Scb)->Fcb, TRUE );
                }

                NtfsAcquireExclusiveFcb( IrpContext, (*Scb)->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
            }
        }
    }

    //
    //  Treat the bitmap as an end resource and acquire it last.
    //

    if (Vcb->BitmapScb != NULL) {

        ULONG AcquireFlags = ACQUIRE_NO_DELETE_CHECK;

        if (AcquireAndDrop) {

            if (AcquirePagingIo && (Vcb->BitmapScb->Fcb->PagingIoResource != NULL)) {

                NtfsAcquirePagingResourceExclusive( IrpContext, Vcb->BitmapScb->Fcb, TRUE );
                NtfsReleasePagingResource( IrpContext, Vcb->BitmapScb->Fcb );
            }

            NtfsAcquireResourceExclusive( IrpContext, Vcb->BitmapScb, TRUE );
            NtfsReleaseResource( IrpContext, Vcb->BitmapScb );

        } else {

            if (AcquirePagingIo && (Vcb->BitmapScb->Fcb->PagingIoResource != NULL)) {
                NtfsAcquirePagingResourceExclusive( IrpContext, Vcb->BitmapScb->Fcb, TRUE );
            }

            NtfsAcquireExclusiveFcb( IrpContext, Vcb->BitmapScb->Fcb, NULL, AcquireFlags );
        }
    }

    //
    //  If we don't have to release the files then don't bump this number.
    //

    if (!AcquireAndDrop) {

        Vcb->AcquireFilesCount += 1;

    } else {

        NtfsReleaseVcb( IrpContext, Vcb );
    }
    return;
}


VOID
NtfsReleaseAllFiles (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN ReleasePagingIo
    )

/*++

Routine Description:

    This routine non-recursively requires all files on a volume.

Arguments:

    Vcb - Supplies the volume

    ReleasePagingIo - Indicates whether we should release the paging io resources
        as well.

Return Value:

    None

--*/

{
    PFCB Fcb;
    PSCB *Scb;
    PVOID RestartKey;

    PAGED_CODE();

    ASSERT( Vcb->AcquireFilesCount != 0 );
    Vcb->AcquireFilesCount -= 1;

    //
    //  Loop to flush all of the prerestart streams, to do the loop
    //  we cycle through the Fcb Table and for each fcb we acquire it.
    //

    RestartKey = NULL;
    while (TRUE) {

        NtfsAcquireFcbTable( IrpContext, Vcb );
        Fcb = NtfsGetNextFcbTableEntry(Vcb, &RestartKey);
        NtfsReleaseFcbTable( IrpContext, Vcb );

        if (Fcb == NULL) {

            break;
        }

        ASSERT_FCB( Fcb );

        if (!FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

            //
            //  Release the file.
            //

            if (ReleasePagingIo && (Fcb->PagingIoResource != NULL)) {
                NtfsReleasePagingResource( IrpContext, Fcb );
            }

            NtfsReleaseFcb( IrpContext, Fcb );
        }
    }

    //
    //  Now release the Fcb's in the Vcb.
    //

    Scb = &Vcb->RootIndexScb;

    while (TRUE) {

        if (Scb == &Vcb->VolumeDasdScb) {

            break;
        }

        Scb += 1;

        if (*Scb != NULL) {

            if (ReleasePagingIo && ((*Scb)->Fcb->PagingIoResource != NULL)) {
                NtfsReleasePagingResource( NULL, (*Scb)->Fcb );
            }

            NtfsReleaseFcb( IrpContext, (*Scb)->Fcb );
        }
    }

    NtfsReleaseVcb( IrpContext, Vcb );

    return;
}


VOID
NtfsAcquireCheckpointSynchronization (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    Synchronize with checkpointing - this blocks out all fuzzy / clean checkpoints

Arguments:

    Vcb - Supplies the Vcb to synchronize with

Return Value:

--*/

{
    PAGED_CODE();

    NtfsAcquireCheckpoint( IrpContext, Vcb );

    while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS )) {

        //
        //  Release the checkpoint event because we cannot checkpoint now.
        //

        NtfsReleaseCheckpoint( IrpContext, Vcb );
        NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
        NtfsAcquireCheckpoint( IrpContext, Vcb );
    }

    SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
    NtfsResetCheckpointNotify( IrpContext, Vcb );
    NtfsReleaseCheckpoint( IrpContext, Vcb );
}



VOID
NtfsReleaseCheckpointSynchronization (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    Synchronize with checkpointing - this blocks out all fuzzy / clean checkpoints

Arguments:

    Vcb - Supplies the Vcb to synchronize with

Return Value:

--*/

{
    PAGED_CODE();

    NtfsAcquireCheckpoint( IrpContext, Vcb );
    ClearFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
    NtfsSetCheckpointNotify( IrpContext, Vcb );
    NtfsReleaseCheckpoint( IrpContext, Vcb );

    UNREFERENCED_PARAMETER( IrpContext );
}


BOOLEAN
NtfsAcquireExclusiveVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN RaiseOnCantWait
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Vcb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Vcb - Supplies the Vcb to acquire

    RaiseOnCantWait - Indicates if we should raise on an acquisition error
        or simply return a BOOLEAN indicating that we couldn't get the
        resource.

Return Value:

    BOOLEAN - Indicates if we were able to acquire the resource.  This is really
        only meaningful if the RaiseOnCantWait value is FALSE.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    if (ExAcquireResourceExclusiveLite( &Vcb->Resource, (BOOLEAN) FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT))) {

#ifdef NTFSDBG
        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
            if (1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource )) {
                NtfsChangeResourceOrderState( IrpContext, NtfsResourceExVcb, FALSE, (BOOLEAN) !FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT) );
            }
        }
#endif

        return TRUE;
    }

    if (RaiseOnCantWait) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    return FALSE;
}


BOOLEAN
NtfsAcquireSharedVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN RaiseOnCantWait
    )

/*++

Routine Description:

    This routine acquires shared access to the Vcb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Vcb - Supplies the Vcb to acquire

    RaiseOnCantWait - Indicates if we should raise on an acquisition error
        or simply return a BOOLEAN indicating that we couldn't get the
        resource.

        N.B. -- If you pass FALSE for this parameter you ABSOLUTELY MUST
                test the return value.  Otherwise you aren't certain that
                you hold the Vcb, and you don't know if it's safe to free it.

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    if (ExAcquireResourceSharedLite( &Vcb->Resource, (BOOLEAN) FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT))) {

#ifdef NTFSDBG
        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
            if (1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource )) {
                NtfsChangeResourceOrderState( IrpContext, NtfsResourceSharedVcb, FALSE, (BOOLEAN) !FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT) );
            }
        }
#endif

        return TRUE;
    }

    if (RaiseOnCantWait) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

    } else {

        return FALSE;
    }
}

#ifdef NTFSDBG


VOID
NtfsReleaseVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )
/*++

Routine Description:

    This routine will release the Vcb. Normally its a define for lock_order testing
    we use a function so we can easily change the owernship state

Arguments:

    Vcb - Supplies the Vcb to release


Return Value:

    None.
--*/

{
    if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
        if ((ExIsResourceAcquiredExclusiveLite( &Vcb->Resource)) &&
            (1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource ))) {
            NtfsChangeResourceOrderState( IrpContext, NtfsResourceExVcb, TRUE, FALSE );
        } else if (1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource )) {
            NtfsChangeResourceOrderState( IrpContext, NtfsResourceSharedVcb, TRUE, FALSE );
        }
    } else {
        IrpContext->OwnershipState = None;
    }
    ExReleaseResourceLite( &Vcb->Resource );
}
#endif


VOID
NtfsReleaseVcbCheckDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR MajorCode,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine will release the Vcb.  We will also test here whether we should
    teardown the Vcb at this point.  If this is the last open queued to a dismounted
    volume or the last close from a failed mount or the failed mount then we will
    want to test the Vcb for a teardown.

Arguments:

    Vcb - Supplies the Vcb to release

    MajorCode - Indicates what type of operation we were called from.

    FileObject - Optionally supplies the file object whose VPB pointer we need to
        zero out

Return Value:

    None.

--*/

{
    BOOLEAN ReleaseVcb = TRUE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    if (FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT ) &&
        (Vcb->CloseCount == 0)) {

        ULONG ReferenceCount;
        ULONG ResidualCount;

        KIRQL SavedIrql;
        BOOLEAN DeleteVcb = FALSE;

        ASSERT_EXCLUSIVE_RESOURCE( &Vcb->Resource );

        //
        //  The volume has gone through dismount.  Now we need to decide if this
        //  release of the Vcb is the last reference for this volume.  If so we
        //  can tear the volume down.
        //
        //  We compare the reference count in the Vpb with the state of the volume
        //  and the type of operation.  We also need to check if there is a
        //  referenced log file object.
        //
        //  If the temp vpb flag isn't set then we already let the iosubsys
        //  delete it during dismount
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_TEMP_VPB )) {

            IoAcquireVpbSpinLock( &SavedIrql );
            ReferenceCount = Vcb->Vpb->ReferenceCount;
            IoReleaseVpbSpinLock( SavedIrql );

        } else {

            ReferenceCount = 0;
        }


        ResidualCount = 0;

        if ((Vcb->LogFileObject != NULL) &&
            !FlagOn( Vcb->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE )) {

            ResidualCount = 1;
        }

        if (MajorCode == IRP_MJ_CREATE) {

            ResidualCount += 1;
        }

        //
        //  If the residual count is the same as the count in the Vpb then we
        //  can delete the Vpb.
        //

        if ((ResidualCount == ReferenceCount) &&
            !FlagOn( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY )) {

            SetFlag( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY );

            //
            //  Release the vcb before we grab the global
            //

            NtfsReleaseVcb( IrpContext, Vcb );
            ReleaseVcb = FALSE;

            //
            //  Never delete the Vcb unless this is the last release of
            //  this Vcb.
            //

            if (ExIsResourceAcquiredSharedLite( &Vcb->Resource ) ==  0) {

                if (ARGUMENT_PRESENT(FileObject)) { FileObject->Vpb = NULL; }

                //
                //  If this is a create then the IO system will handle the
                //  Vpb.
                //

                if (MajorCode == IRP_MJ_CREATE) {

                    ClearFlag( Vcb->VcbState, VCB_STATE_TEMP_VPB );
                }

                //
                //  Use the global resource to synchronize the DeleteVcb process.
                //

                NtfsAcquireExclusiveGlobal( IrpContext, TRUE );
                RemoveEntryList( &Vcb->VcbLinks );
                NtfsReleaseGlobal( IrpContext );

                //
                //  Try to delete the Vcb, reinsert into the queue if
                //  the delete is blocked.
                //

                if (!NtfsDeleteVcb( IrpContext, &Vcb )) {

                    ClearFlag( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY );

                    NtfsAcquireExclusiveGlobal( IrpContext, TRUE );
                    InsertHeadList( &NtfsData.VcbQueue, &Vcb->VcbLinks );
                    NtfsReleaseGlobal( IrpContext );
                }
            } else {

                //
                //  From test above we must still own the vcb so its safe to change the flag
                //

                ClearFlag( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY );
            }
        }
    }

    if (ReleaseVcb) {
        NtfsReleaseVcb( IrpContext, Vcb );
    }
}


BOOLEAN
NtfsAcquireFcbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG AcquireFlags
    )

/*++

Routine Description:

    This routine is used in the create path, fsctl path and close path .  It acquires the Fcb
    and also the paging IO resource if it exists but only if the irpcontext flag is set.
    i.e during a create  supersede/overwrite operation.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Fcb - Supplies the Fcb to acquire

    AcquireFlags - ACQUIRE_DONT_WAIT overrides the wait value in the IrpContext.
        We won't wait for the resource and return whether the resource
        was acquired.

Return Value:

    BOOLEAN - TRUE if acquired.  FALSE otherwise.

--*/

{
    BOOLEAN Status = FALSE;
    BOOLEAN Wait = FALSE;
    BOOLEAN PagingIoAcquired = FALSE;

    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_FCB(Fcb);

    PAGED_CODE();

    //
    //  Sanity check that this is create.  The supersede flag is only
    //  set in the create path and only tested here.
    //

    ASSERT( IrpContext->MajorFunction == IRP_MJ_CREATE ||
            IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL ||
            IrpContext->MajorFunction == IRP_MJ_CLOSE ||
            IrpContext->MajorFunction == IRP_MJ_SET_INFORMATION ||
            IrpContext->MajorFunction == IRP_MJ_SET_VOLUME_INFORMATION ||
            IrpContext->MajorFunction == IRP_MJ_SET_EA );

    if (!FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT ) && FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Wait = TRUE;
    }

    //
    //  Free any exclusive paging I/O resource, we currently have, which
    //  must presumably be from a directory with a paging I/O resource.
    //
    //  We defer releasing the paging io resource when we have logged
    //  changes against a stream.  The only transaction that should be
    //  underway at this point is the create file case where we allocated
    //  a file record.  In this case it is OK to release the paging io
    //  resource for the parent.
    //

    if (IrpContext->CleanupStructure != NULL) {

        ASSERT( IrpContext->CleanupStructure != Fcb );

        //  ASSERT(IrpContext->TransactionId == 0);
        NtfsReleasePagingIo( IrpContext, IrpContext->CleanupStructure );
    }

    //
    //  Loop until we get it right - worst case is twice through loop.
    //

    while (TRUE) {

        //
        //  Acquire Paging I/O first.  Testing for the PagingIoResource
        //  is not really safe without holding the main resource, so we
        //  correct for that below.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) &&
            (Fcb->PagingIoResource != NULL)) {
            
            if (!NtfsAcquirePagingResourceExclusive( IrpContext, Fcb, Wait )) {
                break;
            }
            IrpContext->CleanupStructure = Fcb;
            PagingIoAcquired = TRUE;
        }

        //
        //  Let's acquire this Fcb exclusively.
        //

        if (!NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK | AcquireFlags )) {

            if (PagingIoAcquired) {
                ASSERT(IrpContext->TransactionId == 0);
                NtfsReleasePagingIo( IrpContext, Fcb );
            }
            break;
        }

        //
        //  If we now do not see a paging I/O resource we are golden,
        //  othewise we can absolutely release and acquire the resources
        //  safely in the right order, since a resource in the Fcb is
        //  not going to go away.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) ||
            PagingIoAcquired ||
            (Fcb->PagingIoResource == NULL)) {

            Status = TRUE;
            break;
        }

        NtfsReleaseFcb( IrpContext, Fcb );
    }

    return Status;
}


VOID
NtfsReleaseFcbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine releases access to the Fcb, including its
    paging I/O resource if it exists.

Arguments:

    Fcb - Supplies the Fcb to acquire

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_FCB(Fcb);

    PAGED_CODE();

    //
    //  We test that we currently hold the paging Io exclusive before releasing
    //  it. Checking the ExclusivePagingFcb in the IrpContext tells us if
    //  it is ours.
    //

    if ((IrpContext->TransactionId == 0) &&
        (IrpContext->CleanupStructure == Fcb)) {
        NtfsReleasePagingIo( IrpContext, Fcb );
    }

    NtfsReleaseFcb( IrpContext, Fcb );
}


VOID
NtfsReleaseScbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine releases access to the Scb, including its
    paging I/O resource if it exists.

Arguments:

    Scb - Supplies the Fcb to acquire

Return Value:

    None.

--*/

{
    PFCB Fcb = Scb->Fcb;

    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_SCB(Scb);

    PAGED_CODE();

    //
    //  Release the paging Io resource in the Scb under the following
    //  conditions.
    //
    //      - No transaction underway
    //      - This paging Io resource is in the IrpContext
    //          (This last test insures there is a paging IO resource
    //           and we own it).
    //

    if ((IrpContext->TransactionId == 0) &&
        (IrpContext->CleanupStructure == Fcb)) {
        NtfsReleasePagingIo( IrpContext, Fcb );
    }

    NtfsReleaseScb( IrpContext, Scb );
}


BOOLEAN
NtfsAcquireExclusiveFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN ULONG AcquireFlags
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Fcb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Fcb - Supplies the Fcb to acquire

    Scb - This is the Scb for which we are acquiring the Fcb

    AcquireFlags - Indicating whether to override the wait value in the IrpContext.  Also whether
        to noop the check for a deleted file.

Return Value:

    BOOLEAN - TRUE if acquired.  FALSE otherwise.

--*/

{
    NTSTATUS Status;
    BOOLEAN Wait;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    Status = STATUS_CANT_WAIT;

    if (FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT )) {
        Wait = FALSE;
    } else if (FlagOn( AcquireFlags, ACQUIRE_WAIT )) {
        Wait = TRUE;
    } else {
        Wait = BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    }

    if (NtfsAcquireResourceExclusive( IrpContext, Fcb, Wait )) {

        //
        //  The link count should be non-zero or the file has been
        //  deleted.  We allow deleted files to be acquired for close and
        //  also allow them to be acquired recursively in case we
        //  acquire them a second time after marking them deleted (i.e. rename)
        //

        if (FlagOn( AcquireFlags, ACQUIRE_NO_DELETE_CHECK ) ||

            (!FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) && 
             (!ARGUMENT_PRESENT( Scb ) || !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ))) ||

            (IrpContext->MajorFunction == IRP_MJ_CLOSE) ||

            (IrpContext->MajorFunction == IRP_MJ_CREATE) ||

            (IrpContext->MajorFunction == IRP_MJ_CLEANUP)) {

            //
            //  Put Fcb in the exclusive Fcb list for this IrpContext,
            //  excluding the bitmap for the volume, since we do not need
            //  to modify its file record and do not want unnecessary
            //  serialization/deadlock problems.
            //
            //  If we are growing the volume bitmap then we do want to put
            //  it on the list and maintain the BaseExclusiveCount.  Also
            //  need to do this in the case where we see the volume bitmap
            //  during close (it can happen during restart if we have log
            //  records for the volume bitmap).
            //

            //
            //  If Fcb already acquired then bump the count.
            //

            if (Fcb->ExclusiveFcbLinks.Flink != NULL) {

                Fcb->BaseExclusiveCount += 1;

            //
            //  The fcb is not currently on an exclusive list.
            //  Put it on a list if this is not the volume
            //  bitmap or we explicitly want to put the volume
            //  bitmap on the list.
            //

            } else if (FlagOn( AcquireFlags, ACQUIRE_HOLD_BITMAP ) ||
                       (ARGUMENT_PRESENT( Scb ) &&
                        FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) ||
                       (Fcb->Vcb->BitmapScb == NULL) ||
                       (Fcb->Vcb->BitmapScb->Fcb != Fcb)) {

                ASSERT( Fcb->BaseExclusiveCount == 0 );

                InsertHeadList( &IrpContext->ExclusiveFcbList,
                                &Fcb->ExclusiveFcbLinks );

                Fcb->BaseExclusiveCount += 1;
            }

            return TRUE;
        }

        //
        //  We need to release the Fcb and remember the status code.
        //

        NtfsReleaseResource( IrpContext, Fcb );
        Status = STATUS_FILE_DELETED;

    } else if (FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT )) {

        return FALSE;
    }

    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
}


VOID
NtfsAcquireSharedFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN ULONG AcquireFlags
    )

/*++

Routine Description:

    This routine acquires shared access to the Fcb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Fcb - Supplies the Fcb to acquire

    Scb - This is the Scb for which we are acquiring the Fcb

    AcquireFlags - Indicates if we should acquire the file even if it has been
        deleted.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ASSERT_IRP_CONTEXT(IrpContext);
    ASSERT_FCB(Fcb);

    Status = STATUS_CANT_WAIT;

    if (NtfsAcquireResourceShared( IrpContext, Fcb, (BOOLEAN) FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT))) {

        //
        //  The link count should be non-zero or the file has been
        //  deleted.
        //

        if (FlagOn( AcquireFlags, ACQUIRE_NO_DELETE_CHECK ) ||
            (!FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) &&
             (!ARGUMENT_PRESENT( Scb ) ||
              !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )))) {

            //
            //  It's possible that this is a recursive shared aquisition of an
            //  Fcb we own exclusively at the top level.  In that case we
            //  need to bump the acquisition count.
            //

            if (Fcb->ExclusiveFcbLinks.Flink != NULL) {

                Fcb->BaseExclusiveCount += 1;
            }

            return;
        }

        //
        //  We need to release the Fcb and remember the status code.
        //

        NtfsReleaseResource( IrpContext, Fcb );
        Status = STATUS_FILE_DELETED;
    }

    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
}


BOOLEAN
NtfsAcquireSharedFcbCheckWait (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG AcquireFlags
    )

/*++

Routine Description:

    This routine acquires shared access to the Fcb but checks whether to wait.

Arguments:

    Fcb - Supplies the Fcb to acquire

    AcquireFlags - Indicates if we should override the wait value in the IrpContext.
        We won't wait for the resource and return whether the resource
        was acquired.

Return Value:

    BOOLEAN - TRUE if acquired.  FALSE otherwise.

--*/

{
    BOOLEAN Wait;
    PAGED_CODE();

    if (FlagOn( AcquireFlags, ACQUIRE_DONT_WAIT )) {
        Wait = FALSE;
    } else if (FlagOn( AcquireFlags, ACQUIRE_WAIT )) {
        Wait = TRUE;
    } else {
        Wait = BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    }

    if (NtfsAcquireResourceShared( IrpContext, Fcb, Wait )) {

        //
        //  It's possible that this is a recursive shared aquisition of an
        //  Fcb we own exclusively at the top level.  In that case we
        //  need to bump the acquisition count.
        //

        if (Fcb->ExclusiveFcbLinks.Flink != NULL) {

            Fcb->BaseExclusiveCount += 1;
        }

        return TRUE;

    } else {

        return FALSE;
    }
}


VOID
NtfsReleaseFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine releases the specified Fcb resource.  If the Fcb is acquired
    exclusive, and a transaction is still active, then the release is nooped
    in order to preserve two-phase locking.  If there is no longer an active
    transaction, then we remove the Fcb from the Exclusive Fcb List off the
    IrpContext, and clear the Flink as a sign.  Fcbs are released when the
    transaction is commited.

Arguments:

    Fcb - Fcb to release

Return Value:

    None.

--*/

{
    //
    //  Check if this resource is owned exclusively and we are at the last
    //  release for this transaction.
    //

    if (Fcb->ExclusiveFcbLinks.Flink != NULL) {

        if (Fcb->BaseExclusiveCount == 1) {

            //
            //  If there is a transaction then noop this request.
            //

            if (IrpContext->TransactionId != 0) {

                return;
            }

            RemoveEntryList( &Fcb->ExclusiveFcbLinks );
            Fcb->ExclusiveFcbLinks.Flink = NULL;

            //
            //  This is a good time to free any Scb snapshots for this Fcb.
            //

            NtfsFreeSnapshotsForFcb( IrpContext, Fcb );
        }

        Fcb->BaseExclusiveCount -= 1;
    }

    ASSERT((Fcb->ExclusiveFcbLinks.Flink == NULL && Fcb->BaseExclusiveCount == 0) ||
           (Fcb->ExclusiveFcbLinks.Flink != NULL && Fcb->BaseExclusiveCount != 0));

    NtfsReleaseResource( IrpContext, Fcb );
}


VOID
NtfsAcquireExclusiveScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Scb.

    This routine will raise if it cannot acquire the resource and wait
    in the IrpContext is false.

Arguments:

    Scb - Scb to acquire

Return Value:

    None.

--*/

{
    PAGED_CODE();

    NtfsAcquireExclusiveFcb( IrpContext, Scb->Fcb, Scb, 0 );

    ASSERT( (Scb->Fcb->ExclusiveFcbLinks.Flink != NULL) || 
            ((Scb->Vcb->BitmapScb != NULL) && (Scb->Vcb->BitmapScb == Scb)) );

    if (FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

        NtfsSnapshotScb( IrpContext, Scb );
    }
}


VOID
NtfsAcquireSharedScbForTransaction (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called to acquire an Scb shared in order to perform updates to
    the an Scb stream.  This is used if the transaction writes to a range of the
    stream without changing the size or position of the data.  The caller must
    already provide synchronization to the data itself.

    There is no corresponding Scb release.  It will be released when the transaction commits.
    We will acquire the Scb exclusive if it is not yet in the open attribute table.

Arguments:

    Scb - Scb to acquire

Return Value:

    None.

--*/

{
    PSCB *Position;
    PSCB *ScbArray;
    ULONG Count;

    PAGED_CODE();

    //
    //  Make sure we have a free spot in the Scb array in the IrpContext.
    //

    if (IrpContext->SharedScb == NULL) {

        Position = (PSCB *) &IrpContext->SharedScb;
        IrpContext->SharedScbSize = 1;

    //
    //  Too bad the first one is not available.  If the current size is one then allocate a
    //  new block and copy the existing value to it.
    //

    } else if (IrpContext->SharedScbSize == 1) {

        ScbArray = NtfsAllocatePool( PagedPool, sizeof( PSCB ) * 4 );
        RtlZeroMemory( ScbArray, sizeof( PSCB ) * 4 );
        *ScbArray = IrpContext->SharedScb;
        IrpContext->SharedScb = ScbArray;
        IrpContext->SharedScbSize = 4;
        Position = ScbArray + 1;

    //
    //  Otherwise look through the existing array and look for a free spot.  Allocate a larger
    //  array if we need to grow it.
    //

    } else {

        Position = IrpContext->SharedScb;
        Count = IrpContext->SharedScbSize;

        do {

            if (*Position == NULL) {

                break;
            }

            Count -= 1;
            Position += 1;

        } while (Count != 0);

        //
        //  If we didn't find one then allocate a new structure.
        //

        if (Count == 0) {

            ScbArray = NtfsAllocatePool( PagedPool, sizeof( PSCB ) * IrpContext->SharedScbSize * 2 );
            RtlZeroMemory( ScbArray, sizeof( PSCB ) * IrpContext->SharedScbSize * 2 );
            RtlCopyMemory( ScbArray,
                           IrpContext->SharedScb,
                           sizeof( PSCB ) * IrpContext->SharedScbSize );

            NtfsFreePool( IrpContext->SharedScb );
            IrpContext->SharedScb = ScbArray;
            Position = ScbArray + IrpContext->SharedScbSize;
            IrpContext->SharedScbSize *= 2;
        }
    }

    NtfsAcquireResourceShared( IrpContext, Scb, TRUE );

    if (Scb->NonpagedScb->OpenAttributeTableIndex == 0) {

        NtfsReleaseResource( IrpContext, Scb );
        NtfsAcquireResourceExclusive( IrpContext, Scb, TRUE );
    }

    *Position = Scb;

    return;
}


VOID
NtfsReleaseSharedResources (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    The routine releases all of the resources acquired shared for
    transaction.  The SharedScb structure is freed if necessary and
    the Irp Context field is cleared.

Arguments:


Return Value:

    None.

--*/
{

    PAGED_CODE();

    //
    //  If only one then free the Scb main resource.
    //

    if (IrpContext->SharedScbSize == 1) {

        if (SafeNodeType(IrpContext->SharedScb) == NTFS_NTC_QUOTA_CONTROL) {
            NtfsReleaseQuotaControl( IrpContext,
                              (PQUOTA_CONTROL_BLOCK) IrpContext->SharedScb );
        } else {

            PSCB Scb = (PSCB)IrpContext->SharedScb;

            //
            //  If we acquired the resource exclusive - also cleanup any snapshots
            //  

            if (NtfsIsExclusiveScb( Scb ) && 
                (NtfsIsSharedScb( Scb ) == 1)) {
                
                NtfsFreeSnapshotsForFcb( IrpContext, Scb->Fcb );
            }

            NtfsReleaseResource( IrpContext, ((PSCB) IrpContext->SharedScb) );
        }

    //
    //  Otherwise traverse the array and look for Scb's to release.
    //

    } else {

        PSCB *NextScb;
        ULONG Count;

        NextScb = IrpContext->SharedScb;
        Count = IrpContext->SharedScbSize;

        do {

            if (*NextScb != NULL) {

                if (SafeNodeType(*NextScb) == NTFS_NTC_QUOTA_CONTROL) {

                    NtfsReleaseQuotaControl( IrpContext,
                                      (PQUOTA_CONTROL_BLOCK) *NextScb );
                } else {

                    if (NtfsIsExclusiveScb( (*NextScb) ) && 
                        (NtfsIsSharedScb( (*NextScb ) ) == 1)) {

                        NtfsFreeSnapshotsForFcb( IrpContext, (*NextScb)->Fcb );
                    }
                    NtfsReleaseResource( IrpContext, (*NextScb) );
                }
                *NextScb = NULL;
            }

            Count -= 1;
            NextScb += 1;

        } while (Count != 0);

        NtfsFreePool( IrpContext->SharedScb );
    }

    IrpContext->SharedScb = NULL;
    IrpContext->SharedScbSize = 0;

}


VOID
NtfsReleaseAllResources (
    IN PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    This routine release all resources tracked in the irpcontext including
    exclusive fcb, paging / locked headers in the cleanup structure / cached file records
    shared resources / quota blocks acquired for transactions

    Does not release the vcb since this is hand-tracked.
    Not paged since called by NtfsCleanupIrpContext which is not paged


Arguments:


Return Value:

    None

--*/

{
    PFCB Fcb;

    //
    //  Release the cached file record map
    //

    NtfsPurgeFileRecordCache( IrpContext );


#ifdef MAPCOUNT_DBG
    //
    //  Check all mapping are gone now that we cleaned out cache
    //

    ASSERT( IrpContext->MapCount == 0 );

#endif

    //
    //  Go through and free any Scb's in the queue of shared Scb's for transactions.
    //

    if (IrpContext->SharedScb != NULL) {

        NtfsReleaseSharedResources( IrpContext );
    }

    //
    //  Free any exclusive paging I/O resource, or IoAtEof condition,
    //  this field is overlayed, minimally in write.c.
    //

    Fcb = IrpContext->CleanupStructure;
    if (Fcb != NULL) {

        if (Fcb->NodeTypeCode == NTFS_NTC_FCB) {

            NtfsReleasePagingIo( IrpContext, Fcb );

        } else {

            FsRtlUnlockFsRtlHeader( (PNTFS_ADVANCED_FCB_HEADER) Fcb );
            IrpContext->CleanupStructure = NULL;
        }
    }

    //
    //  Finally, now that we have written the forget record, we can free
    //  any exclusive Scbs that we have been holding.
    //

    ASSERT( IrpContext->TransactionId == 0 );

    while (!IsListEmpty( &IrpContext->ExclusiveFcbList )) {

        Fcb = (PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                       FCB,
                                       ExclusiveFcbLinks );

        NtfsReleaseFcb( IrpContext, Fcb );
    }

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                  IRP_CONTEXT_FLAG_RELEASE_MFT );
}


VOID
NtfsAcquireIndexCcb (
    IN PSCB Scb,
    IN PCCB Ccb,
    IN PEOF_WAIT_BLOCK EofWaitBlock
    )

/*++

Routine Description:

    This routine is called to serialize access to a Ccb for a directory.
    We must serialize access to the index context or we will corrupt
    the data structure.

Arguments:

    Scb - Scb for the directory to enumerate.

    Ccb - Pointer to the Ccb for the handle.

    EofWaitBlock - Uninitialized structure used only to serialize Eof updates.  Our
        caller will put this on the stack.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Acquire the mutex for serialization.
    //

    NtfsAcquireFsrtlHeader( Scb );

    //
    //  Typical case is that we are the only active handle.
    //

    if (Ccb->EnumQueue.Flink == NULL) {

        InitializeListHead( &Ccb->EnumQueue );
        NtfsReleaseFsrtlHeader( Scb );

    } else {

        //
        //  Initialize our event an put ourselves on the stack.
        //

        KeInitializeEvent( &EofWaitBlock->Event, NotificationEvent, FALSE );
        InsertTailList( &Ccb->EnumQueue, &EofWaitBlock->EofWaitLinks );

        //
        //  Free the mutex and wait.  When the wait is satisfied then we are
        //  the active handle.
        //

        NtfsReleaseFsrtlHeader( Scb );

        KeWaitForSingleObject( &EofWaitBlock->Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER)NULL);
    }

    return;
}


VOID
NtfsReleaseIndexCcb (
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine is called to release a Ccb for other people to access.

Arguments:

    Scb - Scb for the directory to enumerate.
    Ccb - Pointer to the Ccb for the handle.

Return Value:

    None

--*/

{
    PEOF_WAIT_BLOCK EofWaitBlock;
    PAGED_CODE();

    //
    //  Acquire the header and wake the next waiter or clear the list if it
    //  is now empty.
    //

    NtfsAcquireFsrtlHeader( Scb );

    ASSERT( Ccb->EnumQueue.Flink != NULL );
    if (IsListEmpty( &Ccb->EnumQueue )) {

        Ccb->EnumQueue.Flink = NULL;

    } else {

        EofWaitBlock = (PEOF_WAIT_BLOCK) RemoveHeadList( &Ccb->EnumQueue );
        KeSetEvent( &EofWaitBlock->Event, 0, FALSE );
    }

    NtfsReleaseFsrtlHeader( Scb );
    return;
}


BOOLEAN
NtfsAcquireScbForLazyWrite (
    IN PVOID OpaqueScb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing lazy writes to the file.  This callback is necessary to
    avoid deadlocks with the Lazy Writer.  (Note that normal writes
    acquire the Fcb, and then call the Cache Manager, who must acquire
    some of his internal structures.  If the Lazy Writer could not call
    this routine first, and were to issue a write after locking Caching
    data structures, then a deadlock could occur.)

Arguments:

    OpaqueScb - The Scb which was specified as a context parameter for this
                routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Scb has been acquired

--*/

{
    BOOLEAN AcquiredFile = FALSE;

#ifdef COMPRESS_ON_WIRE
    ULONG CompressedStream = (ULONG)((ULONG_PTR)OpaqueScb & 1);
#endif
    PSCB Scb = (PSCB)((ULONG_PTR)OpaqueScb & ~1);
    PFCB Fcb = Scb->Fcb;

    ASSERT_SCB(Scb);

    PAGED_CODE();

    //
    //  Acquire the Scb only for those files that the write will
    //  acquire it for, i.e., not the first set of system files.
    //  Otherwise we can deadlock, for example with someone needing
    //  a new Mft record.
    //

    if (NtfsSegmentNumber( &Fcb->FileReference ) <= MASTER_FILE_TABLE2_NUMBER) {

        //
        //  We need to synchronize the lazy writer with the clean volume
        //  checkpoint.  We do this by acquiring and immediately releasing this
        //  Scb.  This is to prevent the lazy writer from flushing the log file
        //  when the space may be at a premium.
        //

        if (NtfsAcquireResourceShared( NULL, Scb, Wait )) {

            if (ExAcquireResourceSharedLite( &Scb->Vcb->MftFlushResource, Wait )) {
                //
                //  The mft bitmap will reacquire the mft resource in LookupAllocation
                //  if its not loaded during a write - this would deadlock with allocating
                //  a mft record.  bcb exclusive - mft main vs mft main - bcb shared
                //

                ASSERT( (Scb != Scb->Vcb->MftBitmapScb) ||

                        ((Scb->Mcb.NtfsMcbArraySizeInUse > 0) &&
                         ((Scb->Mcb.NtfsMcbArray[ Scb->Mcb.NtfsMcbArraySizeInUse - 1].EndingVcn + 1) ==
                          LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ))) );

                AcquiredFile = TRUE;
            }
            NtfsReleaseResource( NULL, Scb );
        }
    //
    //  Now acquire either the main or paging io resource depending on the
    //  state of the file.
    //

    } else if (Scb->Header.PagingIoResource != NULL) {
        AcquiredFile = NtfsAcquirePagingResourceShared( NULL, Scb, Wait );
    } else {

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT | SCB_STATE_CONVERT_UNDERWAY )) {

            AcquiredFile = NtfsAcquireResourceExclusive( NULL, Scb, Wait );

        } else {

            AcquiredFile = NtfsAcquireResourceShared( NULL, Scb, Wait );
        }
    }

    if (AcquiredFile) {

        //
        // We assume the Lazy Writer only acquires this Scb once.  When he
        // has acquired it, then he has eliminated anyone who would extend
        // valid data, since they must take out the resource exclusive.
        // Therefore, it should be guaranteed that this flag is currently
        // clear (the ASSERT), and then we will set this flag, to insure
        // that the Lazy Writer will never try to advance Valid Data, and
        // also not deadlock by trying to get the Fcb exclusive.
        //

#ifdef COMPRESS_ON_WIRE
        ASSERT( Scb->LazyWriteThread[CompressedStream] == NULL );

        Scb->LazyWriteThread[CompressedStream] = PsGetCurrentThread();
#endif

        //
        //  Make Cc top level, so that we will not post or retry on errors.
        //  (If it is not NULL, it must be one of our internal calls to this
        //  routine, such as from Restart or Hot Fix.)
        //

        if (IoGetTopLevelIrp() == NULL) {
            IoSetTopLevelIrp( (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP );
        }
    }

    return AcquiredFile;
}


VOID
NtfsReleaseScbFromLazyWrite (
    IN PVOID OpaqueScb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    performing lazy writes to the file.

Arguments:

    Scb - The Scb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
#ifdef COMPRESS_ON_WIRE
    ULONG CompressedStream = (ULONG)((ULONG_PTR)OpaqueScb & 1);
#endif    
    PSCB Scb = (PSCB)((ULONG_PTR)OpaqueScb & ~1);
    PFCB Fcb = Scb->Fcb;
    ULONG CleanCheckpoint = 0;

    ASSERT_SCB(Scb);

    PAGED_CODE();

    //
    //  Clear the toplevel at this point, if we set it above.
    //

    if ((((ULONG_PTR) IoGetTopLevelIrp()) & ~0x80000000) == FSRTL_CACHE_TOP_LEVEL_IRP) {

        //
        //  We use the upper bit of this field to indicate that we need to
        //  do a clean checkpoint.
        //

        CleanCheckpoint = (ULONG)FlagOn( (ULONG_PTR) IoGetTopLevelIrp(), 0x80000000 );
        IoSetTopLevelIrp( NULL );
    }

#ifdef COMPRESS_ON_WIRE
    Scb->LazyWriteThread[CompressedStream] = NULL;
#endif

    if (NtfsSegmentNumber( &Fcb->FileReference ) <= MASTER_FILE_TABLE2_NUMBER) {

        ExReleaseResourceLite( &Scb->Vcb->MftFlushResource );

    } else if (Scb->Header.PagingIoResource != NULL) {

        NtfsReleasePagingResource( NULL, Scb );
    } else {
        NtfsReleaseResource( NULL, Scb );
    }

    //
    //  Do a clean checkpoint if necessary.
    //

    if (CleanCheckpoint) {

        NtfsCleanCheckpoint( Scb->Vcb );
    }

    return;
}


NTSTATUS
NtfsAcquireFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease,
    IN PDEVICE_OBJECT DeviceObject
    )

{
    BOOLEAN AcquiredFile = FALSE;

    PSCB Scb = (PSCB) (FileObject->FsContext);
    PFCB Fcb = Scb->Fcb;

    ASSERT_SCB( Scb );

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    //  All files should not be mod-no-write and have paging resource
    //

    ASSERT( NtfsSegmentNumber( &Fcb->FileReference ) >= MASTER_FILE_TABLE2_NUMBER );
    ASSERT( Scb->Header.PagingIoResource != NULL );

    AcquiredFile = NtfsAcquirePagingResourceSharedWaitForExclusive( NULL, Scb, FALSE );

    //
    //  If we got the resource, check if he is possibly trying to extend
    //  ValidDataLength.  If so that will cause us to go into useless mode
    //  possibly doing actual I/O writing zeros out to the file past actual
    //  valid data in the cache.  This is so inefficient that it is better
    //  to tell MM not to do this write.
    //

    if (AcquiredFile) {
        *ResourceToRelease = Scb->Fcb->PagingIoResource;
        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
            NtfsAcquireFsrtlHeader( Scb );
            if ((EndingOffset->QuadPart > Scb->ValidDataToDisk) &&
                (EndingOffset->QuadPart < Scb->Header.FileSize.QuadPart) &&
                !FlagOn(Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE)) {
                
                ExReleaseResourceLite( *ResourceToRelease );
                AcquiredFile = FALSE;
                *ResourceToRelease = NULL;
            }
            NtfsReleaseFsrtlHeader( Scb );
        }
    } else {
        *ResourceToRelease = NULL;
    }

    return (AcquiredFile ? STATUS_SUCCESS : STATUS_CANT_WAIT);

}


NTSTATUS
NtfsAcquireFileForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFSRTL_COMMON_FCB_HEADER Header = FileObject->FsContext;

    PAGED_CODE();

    if (Header->PagingIoResource != NULL) {
        NtfsAcquirePagingResourceShared( NULL, Header, TRUE );
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}


NTSTATUS
NtfsReleaseFileForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PSCB Scb = (PSCB) FileObject->FsContext;
    BOOLEAN CleanCheckpoint = FALSE;

    PAGED_CODE();

    if (Scb->Header.PagingIoResource != NULL) {

        //
        //  If we are getting repeated log file fulls then we want to process that before retrying
        //  this request.  This will prevent a section flush from failing and returning
        //  STATUS_FILE_LOCK_CONFLICT to the user.
        //

        if (Scb->Vcb->UnhandledLogFileFullCount > 3) {
            CleanCheckpoint = TRUE;
        }

        NtfsReleasePagingResource( NULL, Scb );

        //
        //  We may be be in a recursive acquisition callback in that case even
        //  after releasing the resource we may still own it and be unable to
        //  checkpoint
        //

        if (CleanCheckpoint &&
            (IoGetTopLevelIrp() == NULL) &&
            !NtfsIsExclusiveScbPagingIo( Scb )) {

            NtfsCleanCheckpoint( Scb->Vcb );
        }
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}

VOID
NtfsAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    )

{
    PSCB Scb = (PSCB)FileObject->FsContext;

    PAGED_CODE();

    if (Scb->Header.PagingIoResource != NULL) {

        //
        //  Use an unsafe test to see if a dummy checkpoint has been posted.
        //  We can use an unsafe test, since the top level caller must retry
        //  if a STATUS_FILE_LOCK_CONFLICT is returned.
        //

        if (!NtfsIsExclusiveScbPagingIo( Scb ) &&
            FlagOn( Scb->Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED )) {

            NtfsCleanCheckpoint( Scb->Vcb );
        }

        NtfsAcquirePagingResourceExclusive( NULL, Scb, TRUE );
    }
}

VOID
NtfsReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    )

{
    PSCB Scb = (PSCB)FileObject->FsContext;

    PAGED_CODE();

    if (Scb->Header.PagingIoResource != NULL) {
        NtfsReleasePagingResource( NULL, Scb );
    }
}


BOOLEAN
NtfsAcquireScbForReadAhead (
    IN PVOID OpaqueScb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing read ahead to the file.

Arguments:

    Scb - The Scb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Scb has been acquired

--*/

{
    PREAD_AHEAD_THREAD ReadAheadThread;
    PVOID CurrentThread;
    KIRQL OldIrql;
    PSCB Scb = (PSCB)OpaqueScb;
    PFCB Fcb = Scb->Fcb;
    BOOLEAN AcquiredFile = FALSE;

    ASSERT_SCB(Scb);

    //
    //  Acquire the Scb only for those files that the read wil
    //  acquire it for, i.e., not the first set of system files.
    //  Otherwise we can deadlock, for example with someone needing
    //  a new Mft record.
    //

    if ((Scb->Header.PagingIoResource == NULL) ||
        NtfsAcquirePagingResourceShared( NULL, Scb, Wait )) {

        AcquiredFile = TRUE;

        //
        //  Add our thread to the read ahead list.
        //

        OldIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

        CurrentThread = (PVOID)PsGetCurrentThread();
        ReadAheadThread = (PREAD_AHEAD_THREAD)NtfsData.ReadAheadThreads.Flink;

        while ((ReadAheadThread != (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads) &&
               (ReadAheadThread->Thread != NULL)) {

            //
            //  We better not already see ourselves.
            //

            ASSERT( ReadAheadThread->Thread != CurrentThread );

            ReadAheadThread = (PREAD_AHEAD_THREAD)ReadAheadThread->Links.Flink;
        }

        //
        //  If we hit the end of the list, then allocate a new one.  Note we
        //  should have at most one entry per critical worker thread in the
        //  system.
        //

        if (ReadAheadThread == (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads) {

            ReadAheadThread = NtfsAllocatePoolWithTagNoRaise( NonPagedPool, sizeof(READ_AHEAD_THREAD), 'RftN' );

            //
            //  If we failed to allocate an entry, clean up and raise.
            //

            if (ReadAheadThread == NULL) {

                KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );

                if (NtfsSegmentNumber( &Fcb->FileReference ) > VOLUME_DASD_NUMBER) {

                    if (Scb->Header.PagingIoResource != NULL) {
                        NtfsReleasePagingResource( NULL, Scb );
                    }
                }

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }
            InsertTailList( &NtfsData.ReadAheadThreads, &ReadAheadThread->Links );
        }

        ReadAheadThread->Thread = CurrentThread;

        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );
    }

    return AcquiredFile;
}


VOID
NtfsReleaseScbFromReadAhead (
    IN PVOID OpaqueScb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    read ahead.

Arguments:

    Scb - The Scb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    PREAD_AHEAD_THREAD ReadAheadThread;
    PVOID CurrentThread;
    KIRQL OldIrql;
    PSCB Scb = (PSCB)OpaqueScb;
    PFCB Fcb = Scb->Fcb;

    ASSERT_SCB(Scb);

    //
    //  Free our read ahead entry.
    //

    OldIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

    CurrentThread = (PVOID)PsGetCurrentThread();
    ReadAheadThread = (PREAD_AHEAD_THREAD)NtfsData.ReadAheadThreads.Flink;

    while ((ReadAheadThread != (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads) &&
           (ReadAheadThread->Thread != CurrentThread)) {

        ReadAheadThread = (PREAD_AHEAD_THREAD)ReadAheadThread->Links.Flink;
    }

    ASSERT(ReadAheadThread != (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads);

    ReadAheadThread->Thread = NULL;

    //
    //  Move him to the end of the list so all the allocated entries are at
    //  the front, and we simplify our scans.
    //

    RemoveEntryList( &ReadAheadThread->Links );
    InsertTailList( &NtfsData.ReadAheadThreads, &ReadAheadThread->Links );

    KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );

    if (Scb->Header.PagingIoResource != NULL) {
        NtfsReleasePagingResource( NULL, Scb );
    }

    return;
}


BOOLEAN
NtfsAcquireVolumeFileForLazyWrite (
    IN PVOID Vcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    the volume file.  It is subsequently called by the Lazy Writer prior to its
    performing lazy writes to the volume file.  This callback may one day be
    necessary to avoid deadlocks with the Lazy Writer, however, now
    NtfsCommonWrite does not need to acquire any resource for the volume file,
    so this routine is simply a noop.

Arguments:

    Vcb - The Vcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER( Vcb );
    UNREFERENCED_PARAMETER( Wait );

    PAGED_CODE();

    return TRUE;
}


VOID
NtfsReleaseVolumeFileFromLazyWrite (
    IN PVOID Vcb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    performing lazy writes to the file.

Arguments:

    Vcb - The Vcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( Vcb );

    PAGED_CODE();

    return;
}


NTFS_RESOURCE_NAME
NtfsIdentifyFcb (
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    Identifies the resource type of a given FCB. I.e is it the mft. Used for
    lock order identification.

Arguments:

    Vcb - The vcb for the volume

    Fcb - The fcb to identify

Return Value:

    TRUE

--*/

{

    if ((NtfsSegmentNumber( &Fcb->FileReference ) == MASTER_FILE_TABLE_NUMBER)) {
        return NtfsResourceMft;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == MASTER_FILE_TABLE2_NUMBER)) {
        return NtfsResourceMft2;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == VOLUME_DASD_NUMBER)) {
        return NtfsResourceVolume;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == LOG_FILE_NUMBER)) {
        return NtfsResourceLogFile;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == BAD_CLUSTER_FILE_NUMBER)) {
        return NtfsResourceBadClust;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == SECURITY_FILE_NUMBER)) {
        return NtfsResourceSecure;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER)) {
        return NtfsResourceRootDir;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == BIT_MAP_FILE_NUMBER)) {
        return NtfsResourceBitmap;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == BOOT_FILE_NUMBER)) {
        return NtfsResourceBoot;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == EXTEND_NUMBER)) {
        return NtfsResourceExtendDir;
    } else if ((Vcb->UsnJournal && (Fcb == Vcb->UsnJournal->Fcb)) ||
               (FlagOn( Fcb->FcbState, FCB_STATE_USN_JOURNAL) &&
                !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ))) {
        return NtfsResourceUsnJournal;
    } else if (Vcb->QuotaTableScb && (Fcb == Vcb->QuotaTableScb->Fcb)) {
        return NtfsResourceQuotaTable;
    } else if (Vcb->ObjectIdTableScb && (Fcb == Vcb->ObjectIdTableScb->Fcb)) {
        return NtfsResourceObjectIdTable;
    } else if (Vcb->ReparsePointTableScb && (Fcb == Vcb->ReparsePointTableScb->Fcb)) {
        return NtfsResourceReparseTable;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == UPCASE_TABLE_NUMBER)) {
        return NtfsResourceUpCase;
    } else if ((NtfsSegmentNumber( &Fcb->FileReference ) == ATTRIBUTE_DEF_TABLE_NUMBER)) {
        return NtfsResourceAttrDefTable;
    } else {
        return NtfsResourceFile;
    }
}

#ifdef NTFSDBG

BOOLEAN
NtfsChangeResourceOrderState(
    IN PIRP_CONTEXT IrpContext,
    IN NTFS_RESOURCE_NAME NewResource,
    IN BOOLEAN Release,
    IN ULONG UnsafeTransition
    )

/*++

Routine Description:

    Update the state table because of the new acquired resource

Arguments:

    IrpContext -- contains the state table

    NewResource -- The new resource acquired

Return Value:

    TRUE if this is a valid transition

--*/

{
    PTOP_LEVEL_CONTEXT TopLevelContext;
    PIRP_CONTEXT TopIrpContext = IrpContext;
    ULONG_PTR StackBottom;
    ULONG_PTR StackTop;
    LONG Index;
    LONG NumTransitions =  sizeof( OwnershipTransitionTable ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    LONG NumRules =  sizeof( OwnershipTransitionRuleTable ) / sizeof( NTFS_OWNERSHIP_TRANSITION_RULE );
    BOOLEAN Result = FALSE;

    //
    //  Work around the forced top level context of reads to find the real top level
    //

    IoGetStackLimits( &StackTop, &StackBottom );

    TopLevelContext = NtfsGetTopLevelContext();
    if ((TopLevelContext != NULL)) {

        if (((ULONG_PTR) TopLevelContext <= StackBottom - sizeof( TOP_LEVEL_CONTEXT )) &&
            ((ULONG_PTR) TopLevelContext >= StackTop) &&
            !FlagOn( (ULONG_PTR) TopLevelContext, 0x3 ) &&
            (TopLevelContext->Ntfs == 0x5346544e)) {

            TopLevelContext = (PTOP_LEVEL_CONTEXT)TopLevelContext->SavedTopLevelIrp;
            if (((ULONG_PTR) TopLevelContext <= StackBottom - sizeof( TOP_LEVEL_CONTEXT )) &&
                ((ULONG_PTR) TopLevelContext >= StackTop) &&
                !FlagOn( (ULONG_PTR) TopLevelContext, 0x3 ) &&
                (TopLevelContext->Ntfs == 0x5346544e)) {

                TopIrpContext = TopLevelContext->ThreadIrpContext;
            }
        }
    }

    TopIrpContext = TopIrpContext->TopLevelIrpContext;

    //
    //  Skip verification on mounts
    //

    if ((TopIrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
         (TopIrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME)) {

        return TRUE;
    }

    //
    //  Keep track of how many normal files we own
    //

    if (NtfsResourceFile == NewResource) {

        if (Release) {

            TopIrpContext->FilesOwnedCount -= 1;

            //
            //  Only change state if back to 0 for files
            //

            if (TopIrpContext->FilesOwnedCount) {
                return TRUE;
            }

        } else {

            TopIrpContext->FilesOwnedCount += 1;

            //
            //  Only change state if fwd to 0 for files
            //

            if (TopIrpContext->FilesOwnedCount > 1) {
                return TRUE;
            }
        }
    }

    try {

        //
        //  All unsafe transitions (non blocking acquires) are legal
        // 

        if (UnsafeTransition) {

            ASSERT( !Release );

            SetFlag( TopIrpContext->OwnershipState, NewResource );
            Result = TRUE;
            leave;
        }


        if (!Release) {

            //
            //  Check the rule table for regular new resource acquires
            //

            for (Index=0; Index < NumRules; Index += 1) {

                if ((OwnershipTransitionRuleTable[Index].NewResource == NewResource) &&
                    ((OwnershipTransitionRuleTable[Index].RequiredResourcesMask == 0) ||
                     (FlagOn( TopIrpContext->OwnershipState, OwnershipTransitionRuleTable[Index].RequiredResourcesMask ))) &&
                    (!FlagOn( TopIrpContext->OwnershipState, OwnershipTransitionRuleTable[Index].DisallowedResourcesMask ))) {

                    SetFlag( TopIrpContext->OwnershipState, NewResource );
                    Result = TRUE;
                    leave;
                }
            }

            //
            //  special transition table check
            //  

            for (Index=0; Index < NumTransitions; Index += 1) {

                if ((OwnershipTransitionTable[Index].Begin == TopIrpContext->OwnershipState) &&
                     ((OwnershipTransitionTable[Index].Acquired == NewResource) ||
                      (OwnershipTransitionTable[Index].Acquired == NtfsResourceAny))) {

                    TopIrpContext->OwnershipState = OwnershipTransitionTable[Index].End;
                    Result = TRUE;
                    leave;
                }
            }


        } else {

        //
        //  All release are good as long as you own the the resource
        //  

            if ((NewResource == None) || FlagOn( TopIrpContext->OwnershipState, NewResource )) {

                ClearFlag( TopIrpContext->OwnershipState, NewResource );
                Result = TRUE;
                leave;
            }
        }

    } finally {
        NOTHING;
    }

    if (TopIrpContext->OwnershipState == NtfsBreakOnState) {
        if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
            KdPrint(( "NTFS: Breaking for matched state\n" ));
            DbgBreakPoint();
        }
    }

    if (NtfsPrintOnLockProb) {
        if ((NULL == NtfsBreakOnIrpContext) || (TopIrpContext == NtfsBreakOnIrpContext) ) {
            KdPrint(( "NTFS: change context: 0x%x to 0x%x for 0x%x release: %d unsafe: %d\n", TopIrpContext, TopIrpContext->OwnershipState, NewResource, Release, UnsafeTransition ));
        }
    }

    if (!Result && NtfsAssertOnLockProb) {
        KdPrint(( "NTFS: unknown transition from state: 0x%x resource: 0x%x release: %d unsafe: %d\n", TopIrpContext->OwnershipState, NewResource, Release, UnsafeTransition ));
        ASSERT( FALSE );
    }
    
    return Result;
}

typedef BOOLEAN (*PRESOURCE_FUNCTION) (
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );


BOOLEAN
NtfsBasicAcquire (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN PERESOURCE * ResourcePtr,
    IN PRESOURCE_FUNCTION AcquireFunction,
    IN BOOLEAN Wait,
    IN ULONG Type
    )

/*++

Routine Description:

    
Arguments:

    Fcb -  Fcb to acquire hte resource in
    
    ResourcePtr - Pointer to the resource location
    
    AcquireFunction - function to use during the acquire
    
    Wait - Indicates if we can wait for the resource.
    
    Type - debug info

Return Value:

    BOOLEAN - TRUE if the resource was acquired, FALSE otherwise.

--*/

{
    BOOLEAN Result;

    Result = AcquireFunction( *ResourcePtr, Wait );         

    return Result;
    
    UNREFERENCED_PARAMETER( Type );
    UNREFERENCED_PARAMETER( Fcb );
    UNREFERENCED_PARAMETER( IrpContext );
}


BOOLEAN
NtfsAcquireResourceExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine acquires the main resource of the specified structure useing the specified wait
    flag.  It will update the resource state in the IrpContext if present.

Arguments:

    FcbOrScb - Data structure on which we are synchronizing.

    Wait - Indicates if we can wait for the resource.

Return Value:

    BOOLEAN - TRUE if the resource was acquired, FALSE otherwise.

--*/

{
    BOOLEAN Result;
    NTFS_RESOURCE_NAME ResourceName;
    PFCB Fcb;

    //
    //  Find the Fcb for either input structure.
    //

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Fcb = (PFCB)FcbOrScb;

    } else {
        Fcb = ((PSCB)FcbOrScb)->Fcb;
    }   

    //
    //  For blocking calls check 1st
    //

    if (Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (0 == NtfsIsSharedFcb( Fcb ))) {

        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );
        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, FALSE );
    }
    
    Result = NtfsBasicAcquire( IrpContext, 
                               Fcb, 
                               &Fcb->Resource, 
                               ExAcquireResourceExclusive, 
                               Wait, 
                               1 );

    //
    //  For nonblocking calls afterwards when own the resource
    //

    if (Result &&
        !Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&

        (1 == NtfsIsSharedFcb( Fcb ))) {
        
        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );
        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, TRUE );
    }

    return Result;

    UNREFERENCED_PARAMETER( IrpContext );
}


BOOLEAN
NtfsAcquireResourceShared (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   )

/*++

Routine Description:

    This routine is called to acquire the main resource of the specified structure shared using the
    specified wait flag.  It will also update the resource state in the IrpContext if present.

Arguments:

    FcbOrScb - Data structure on which we are synchronizing.

    Wait - Indicates if we can wait for the resource.

Return Value:

    BOOLEAN - TRUE if the resource was acquired, FALSE otherwise.

--*/

{
    BOOLEAN Result;
    PFCB Fcb;
    NTFS_RESOURCE_NAME ResourceName;

    //
    //  Find the Fcb for either input structure.
    //

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Fcb = (PFCB)FcbOrScb;

    } else {
        Fcb = ((PSCB)FcbOrScb)->Fcb;
    }   


    //
    //  For blocking calls check 1st
    //

    if (Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (0 == NtfsIsSharedFcb( Fcb ))) {
        
        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );

        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, FALSE );
    }
    Result = NtfsBasicAcquire( IrpContext, 
                               Fcb, 
                               &Fcb->Resource, 
                               ExAcquireResourceShared, 
                               Wait, 
                               2 );

    //
    //  For nonblocking calls afterwards when own the resource
    //

    if (Result &&
        !Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (1 == NtfsIsSharedFcb( Fcb ))) {
        
        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );
        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, TRUE );
    }

    return Result;

    UNREFERENCED_PARAMETER( IrpContext );
}



BOOLEAN
NtfsAcquireResourceSharedWaitForEx (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   )

/*++

Routine Description:

    This routine is called to acquire the main resource of the specified structure shared using the
    specified wait flag.  It will also update the resource state in the IrpContext if present.
    Unlike the regular acquire shared. We wait here if there are any other exclusive waiters
    even if we already own the resource. This is useful in the async i/o cases.
    
Arguments:

    FcbOrScb - Data structure on which we are synchronizing.

    Wait - Indicates if we can wait for the resource.

Return Value:

    BOOLEAN - TRUE if the resource was acquired, FALSE otherwise.

--*/

{
    BOOLEAN Result;
    PFCB Fcb;
    NTFS_RESOURCE_NAME ResourceName;

    //
    //  Find the Fcb for either input structure.
    //

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Fcb = (PFCB)FcbOrScb;

    } else {
        Fcb = ((PSCB)FcbOrScb)->Fcb;
    }   

    //
    //  For blocking calls check 1st
    //

    if (Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (0 == NtfsIsSharedFcb( Fcb ))) {
        
        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );

        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, FALSE );
    }
    Result = NtfsBasicAcquire( IrpContext, 
                               Fcb, 
                               &Fcb->Resource, 
                               ExAcquireSharedWaitForExclusive, 
                               Wait, 
                               3 );

    //
    //  For nonblocking calls afterwards when own the resource
    //

    if (Result &&
        !Wait &&
        ARGUMENT_PRESENT( IrpContext ) &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
        (1 == NtfsIsSharedFcb( Fcb ))) {
        
        ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );
        NtfsChangeResourceOrderState( IrpContext, ResourceName, FALSE, TRUE );
    }

    return Result;

    UNREFERENCED_PARAMETER( IrpContext );
}




VOID
NtfsReleaseResource (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb
    )

/*++

Routine Description:

    This routine is called to release the main resource of the specified structure and update the
    resource state in the IrpContext if present.

Arguments:

    FcbOrScb - Data structure on which we are synchronizing.

Return Value:

    None

--*/

{

    PFCB Fcb;
    ULONG Count = 0;
    PERESOURCE Resource;
    NTFS_RESOURCE_NAME ResourceName;
    
    //
    //  Find the Fcb for either input structure.
    //

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Fcb = (PFCB)FcbOrScb;

    } else {
        Fcb = ((PSCB)FcbOrScb)->Fcb;
    }          

    if (ARGUMENT_PRESENT( IrpContext ) && (IrpContext->Vcb != NULL)) {
        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            ResourceName = NtfsIdentifyFcb( IrpContext->Vcb, Fcb );

            //
            //  Only change ownership state if we are really releasing the resource
            //  
    
            if (1 == NtfsIsSharedFcb( Fcb )) {
                NtfsChangeResourceOrderState( IrpContext, ResourceName, TRUE, FALSE );
            }

        } else {

            IrpContext->OwnershipState = None;
        }
    }

    Resource = Fcb->Resource;
    ExReleaseResource( Resource );         

    UNREFERENCED_PARAMETER( IrpContext );
}
#endif  // NTFSDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\reparsup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    MountSup.c

Abstract:

    This module implements the support routines in Ntfs for reparse points.

Author:

    Felipe Cabrera     [cabrera]        30-Jun-1997

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg DEBUG_TRACE_FSCTRL

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('PFtN')



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsInitializeReparsePointIndex)
#pragma alloc_text(PAGE, NtfsValidateReparsePointBuffer)
#endif



VOID
NtfsInitializeReparsePointIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the mount points index for the volume.  If the index does not
    exist it is created and initialized.

Arguments:

    Fcb - Pointer to Fcb for the object id file.

    Vcb - Volume control block for volume being mounted.

Return Value:

    None

--*/

{
    UNICODE_STRING IndexName = CONSTANT_UNICODE_STRING( L"$R" );

    PAGED_CODE();

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        NtOfsCreateIndex( IrpContext,
                          Fcb,
                          IndexName,
                          CREATE_OR_OPEN,
                          0,
                          COLLATION_NTOFS_ULONGS,
                          NtOfsCollateUlongs,
                          NULL,
                          &Vcb->ReparsePointTableScb );
    } finally {

        NtfsReleaseFcb( IrpContext, Fcb );
    }
}


NTSTATUS
NtfsValidateReparsePointBuffer (
    IN ULONG BufferLength,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
)
/*++

Routine Description:

    This routine verifies that the reparse point buffer is valid.

Arguments:

    BufferLength - Length of the reparse point buffer.

    ReparseBuffer - The reparse point buffer to be validated.

Return Value:

    NTSTATUS - The return status for the operation.
               If successful, STATUS_SUCCESS will be returned.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ReparseTag;
    USHORT ReparseDataLength;
    PREPARSE_GUID_DATA_BUFFER ReparseGuidBuffer;

    PAGED_CODE();

    //
    //  Be defensive about the length of the buffer before re-referencing it.
    //

    ASSERT( REPARSE_DATA_BUFFER_HEADER_SIZE < REPARSE_GUID_DATA_BUFFER_HEADER_SIZE );

    if (BufferLength < REPARSE_DATA_BUFFER_HEADER_SIZE) {

        //
        //  Return invalid buffer parameter error.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        DebugTrace( 0, Dbg, ("Data in buffer is too short.\n") );

        return Status;
    }

    //
    //  Return if the buffer is too long.
    //

    if (BufferLength > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

        //
        //  Return invalid buffer parameter error.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        DebugTrace( 0, Dbg, ("Data in buffer is too long.\n") );

        return Status;
    }

    //
    //  Get the header information brought in the buffer.
    //  While all the headers coincide in the layout of the first three fields we are home free.
    //

    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseTag) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseTag) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseDataLength) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseDataLength) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, Reserved) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, Reserved) );

    ReparseTag = ReparseBuffer->ReparseTag;
    ReparseDataLength = ReparseBuffer->ReparseDataLength;
    ReparseGuidBuffer = (PREPARSE_GUID_DATA_BUFFER)ReparseBuffer;

    DebugTrace( 0, Dbg, ("ReparseTag = %08lx, ReparseDataLength = [x]%08lx [d]%08ld\n", ReparseTag, ReparseDataLength, ReparseDataLength) );

    //
    //  Verify that the buffer and the data length in its header are
    //  internally consistent. We need to have a REPARSE_DATA_BUFFER or a
    //  REPARSE_GUID_DATA_BUFFER.
    //

    if (((ULONG)(ReparseDataLength + REPARSE_DATA_BUFFER_HEADER_SIZE) != BufferLength) &&
        ((ULONG)(ReparseDataLength + REPARSE_GUID_DATA_BUFFER_HEADER_SIZE) != BufferLength)) {

        //
        //  Return invalid buffer parameter error.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        DebugTrace( 0, Dbg, ("Buffer is not self-consistent.\n") );

        return Status;
    }

    //
    //  Sanity check the buffer size combination reserved for Microsoft tags.
    //

    if ((ULONG)(ReparseDataLength + REPARSE_DATA_BUFFER_HEADER_SIZE) == BufferLength) {

        //
        //  This buffer length can only be used with Microsoft tags.
        //

        if (!IsReparseTagMicrosoft( ReparseTag )) {

            //
            //  Return buffer parameter error.
            //

            Status = STATUS_IO_REPARSE_DATA_INVALID;

            DebugTrace( 0, Dbg, ("Wrong reparse tag in Microsoft buffer.\n") );

            return Status;
        }
    }

    //
    //  Sanity check the buffer size combination that has a GUID.
    //

    if ((ULONG)(ReparseDataLength + REPARSE_GUID_DATA_BUFFER_HEADER_SIZE) == BufferLength) {

        //
        //  If the tag is a non-Microsoft tag, then the GUID cannot be NULL
        //

        if (!IsReparseTagMicrosoft( ReparseTag )) {

            if ((ReparseGuidBuffer->ReparseGuid.Data1 == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data2 == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data3 == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[0] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[1] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[2] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[3] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[4] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[5] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[6] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[7] == 0)) {

                //
                //  Return invalid buffer parameter error.
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;

                DebugTrace( 0, Dbg, ("The GUID is null for a non-Microsoft reparse tag.\n") );

                return Status;
            }
        }

        //
        //  This kind of buffer cannot be used for name grafting operations.
        //

        if (ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {

            //
            //  Return invalid buffer parameter error.
            //

            Status = STATUS_IO_REPARSE_DATA_INVALID;

            DebugTrace( 0, Dbg, ("Attempt to use the GUID buffer for name grafting.\n") );

            return Status;
        }
    }

    //
    //  We verify that the caller has zeroes in all the reserved bits and that she
    //  sets one of the non-reserved tags.  Also fail if the tag is the retired NSS
    //  flag.
    //

    if ((ReparseTag & ~IO_REPARSE_TAG_VALID_VALUES)  ||
        (ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO) ||
        (ReparseTag == IO_REPARSE_TAG_RESERVED_ONE)) {

        Status = STATUS_IO_REPARSE_TAG_INVALID;

        DebugTrace( 0, Dbg, ("Reparse tag is an reserved one.\n") );

        return Status;
    }

    //
    //  NTFS directory junctions are only to be set at directories and have a valid buffer.
    //

    if (ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {

        //
        //  Valid ReparseBuffer must have
        //
        //  1)  Enough space for the length fields
        //  2)  A correct substitute name offset
        //  3)  A print name offset following the substitute name
        //  4)  enough space for the path name and substitute name
        //

        if ((ReparseBuffer->ReparseDataLength <
             (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE)) ||

            (ReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset != 0) ||

            (ReparseBuffer->MountPointReparseBuffer.PrintNameOffset !=
             (ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength + sizeof( UNICODE_NULL ))) ||

            (ReparseBuffer->ReparseDataLength !=
             (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE) +
              ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength +
              ReparseBuffer->MountPointReparseBuffer.PrintNameLength +
              2 * sizeof( UNICODE_NULL ))) {

            Status = STATUS_IO_REPARSE_DATA_INVALID;

            DebugTrace( 0, Dbg, ("Invalid mount point reparse buffer.\n") );

            return Status;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\seinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SeInfo.c

Abstract:

    This module implements the Security Info routines for NTFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    26-Dec-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SEINFO)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonQuerySecurityInfo)
#pragma alloc_text(PAGE, NtfsCommonSetSecurityInfo)
#endif


NTSTATUS
NtfsCommonQuerySecurityInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying security information called by
    both the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN AcquiredFcb = TRUE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQuerySecurityInfo") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  The only type of opens we accept are user file and directory opens
    //

    if ((TypeOfOpen != UserFileOpen)
        && (TypeOfOpen != UserDirectoryOpen)
        && (TypeOfOpen != UserViewIndexOpen)) {

        Status = STATUS_INVALID_PARAMETER;

    } else {

        //
        //  Our operation is to acquire the fcb, do the operation and then
        //  release the fcb.  If the security descriptor for this file is
        //  not already loaded we will release the Fcb and then acquire both
        //  the Vcb and Fcb.  We must have the Vcb to examine our parent's
        //  security descriptor.
        //

        NtfsAcquireSharedFcb( IrpContext, Fcb, NULL, 0 );

        try {

            if (Fcb->SharedSecurity == NULL) {

                NtfsReleaseFcb( IrpContext, Fcb );
                AcquiredFcb = FALSE;

                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
                AcquiredFcb = TRUE;
            }

            //
            //  Make sure the volume is still mounted.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            Status = NtfsQuerySecurity( IrpContext,
                                        Fcb,
                                        &IrpSp->Parameters.QuerySecurity.SecurityInformation,
                                        (PSECURITY_DESCRIPTOR)Irp->UserBuffer,
                                        &IrpSp->Parameters.QuerySecurity.Length );

            if (NT_SUCCESS( Status )) {

                Irp->IoStatus.Information = IrpSp->Parameters.QuerySecurity.Length;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {

                Irp->IoStatus.Information = IrpSp->Parameters.QuerySecurity.Length;

                Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            //  Abort transaction on error by raising.
            //

            NtfsCleanupTransaction( IrpContext, Status, FALSE );

        } finally {

            DebugUnwind( NtfsCommonQuerySecurityInfo );

            if (AcquiredFcb) {

                NtfsReleaseFcb( IrpContext, Fcb );
            }
        }
    }

    //
    //  Now complete the request and return to our caller
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsCommonQuerySecurityInfo -> %08lx", Status) );

    return Status;
}


NTSTATUS
NtfsCommonSetSecurityInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Setting security information called by
    both the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PQUOTA_CONTROL_BLOCK OldQuotaControl = NULL;
    ULONG OldOwnerId = 0;
    ULONG LargeStdInfo = 0;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetSecurityInfo") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  The only type of opens we accept are user file and directory opens
    //

    if ((TypeOfOpen != UserFileOpen)
        && (TypeOfOpen != UserDirectoryOpen)
        && (TypeOfOpen != UserViewIndexOpen)) {

        Status = STATUS_INVALID_PARAMETER;

    } else if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        
    } else {
    
        //
        //  Capture the source information.
        //

        IrpContext->SourceInfo = Ccb->UsnSourceInfo;

        //
        //  Our operation is to acquire the fcb, do the operation and then
        //  release the fcb
        //

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

        try {

            //
            //  Make sure the volume is still mounted.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            //
            //  Post the change to the Usn Journal.
            //

            NtfsPostUsnChange( IrpContext, Scb, USN_REASON_SECURITY_CHANGE );

            //
            //  Capture the current OwnerId, Qutoa Control Block and
            //  size of standard information.
            //

            OldQuotaControl = Fcb->QuotaControl;
            OldOwnerId = Fcb->OwnerId;
            LargeStdInfo = Fcb->FcbState & FCB_STATE_LARGE_STD_INFO;

            Status = NtfsModifySecurity( IrpContext,
                                         Fcb,
                                         &IrpSp->Parameters.SetSecurity.SecurityInformation,
                                         IrpSp->Parameters.SetSecurity.SecurityDescriptor );

            if (NT_SUCCESS( Status )) {

                //
                //  Make sure the new security descriptor Id is written out.
                //

                NtfsUpdateStandardInformation( IrpContext, Fcb );
            }

            //
            //  Abort transaction on error by raising.
            //

            NtfsCleanupTransaction( IrpContext, Status, FALSE );

            //
            //  Set the flag in the Ccb to indicate this change occurred.
            //

            if (!IsDirectory( &Fcb->Info )) {
                SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );
            }

        } finally {

            DebugUnwind( NtfsCommonSetSecurityInfo );

            if (AbnormalTermination()) {

                //
                //  The request failed.  Restore the owner and
                //  QuotaControl are restored.
                //

                if ((Fcb->QuotaControl != OldQuotaControl) &&
                    (Fcb->QuotaControl != NULL)) {

                    //
                    //  A new quota control block was assigned.
                    //  Dereference it.
                    //

                    NtfsDereferenceQuotaControlBlock( Fcb->Vcb,
                                                      &Fcb->QuotaControl );
                }

                Fcb->QuotaControl = OldQuotaControl;
                Fcb->OwnerId = OldOwnerId;

                if (LargeStdInfo == 0) {

                    //
                    //  The standard information has be returned to
                    //  its orginal size.
                    //

                    ClearFlag( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO );
                }

            } else {

                //
                //  The request succeed.  If the quota control block was
                //  changed then derefence the old block.
                //

                if ((Fcb->QuotaControl != OldQuotaControl) &&
                    (OldQuotaControl != NULL)) {

                    NtfsDereferenceQuotaControlBlock( Fcb->Vcb,
                                                      &OldQuotaControl);
                }
            }

        }
    }

    //
    //  Now complete the request and return to our caller
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsCommonSetSecurityInfo -> %08lx", Status) );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\shutdown.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Shutdown.c

Abstract:

    This module implements the file system shutdown routine for Ntfs

Author:

    Gary Kimura     [GaryKi]    19-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  Interal support routine
//

VOID
NtfsCheckpointVolumeUntilDone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_SHUTDOWN)


NTSTATUS
NtfsFsdShutdown (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of shutdown.  Note that Shutdown will
    never be done asynchronously so we will never need the Fsp counterpart
    to shutdown.

    This is the shutdown routine for the Ntfs file system device driver.
    This routine locks the global file system lock and then syncs all the
    mounted volumes.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - Always STATUS_SUCCESS

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;

    PLIST_ENTRY Links;
    PVCB Vcb;
    PIRP NewIrp;
    KEVENT Event;

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    DebugTrace( +1, Dbg, ("NtfsFsdShutdown\n") );

    FsRtlEnterFileSystem();

    //
    //  Allocate an Irp Context that we can use in our procedure calls
    //  and we know that shutdown will always be synchronous
    //

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );

    NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

    //
    //  Get everyone else out of the way
    //

    if (!NtfsAcquireExclusiveGlobal( IrpContext, BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ))) {
        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    try {

        BOOLEAN AcquiredFiles;
        BOOLEAN AcquiredCheckpoint;

        //
        //  Initialize an event for doing calls down to
        //  our target device objects
        //

        KeInitializeEvent( &Event, NotificationEvent, FALSE );

        //
        //  For every volume that is mounted we will flush the
        //  volume and then shutdown the target device objects.
        //

        for (Links = NtfsData.VcbQueue.Flink;
             Links != &NtfsData.VcbQueue;
             Links = Links->Flink) {

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

            //
            //  Get the Vcb and put it in the IrpContext.
            //

            Vcb = CONTAINING_RECORD(Links, VCB, VcbLinks);
            IrpContext->Vcb = Vcb;

            //
            //  If we have already been called before for this volume
            //  (and yes this does happen), skip this volume as no writes
            //  have been allowed since the first shutdown.
            //

            if ( FlagOn( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN ) ) {

                continue;
            }

            //
            //  Clear the Mft defrag flag to stop any actions behind our backs.
            //

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );

            AcquiredFiles = FALSE;
            AcquiredCheckpoint = FALSE;

            try {

                if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                    //
                    //  Start by locking out all other checkpoint
                    //  operations.
                    //

                    NtfsAcquireCheckpoint( IrpContext, Vcb );

                    while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS )) {

                        //
                        //  Release the checkpoint event because we cannot checkpoint now.
                        //

                        NtfsReleaseCheckpoint( IrpContext, Vcb );

                        NtfsWaitOnCheckpointNotify( IrpContext, Vcb );

                        NtfsAcquireCheckpoint( IrpContext, Vcb );
                    }

                    SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
                    NtfsResetCheckpointNotify( IrpContext, Vcb );
                    NtfsReleaseCheckpoint( IrpContext, Vcb );
                    AcquiredCheckpoint = TRUE;

                    NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, TRUE, FALSE );
                    AcquiredFiles = TRUE;

                    SetFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );

                    if (!FlagOn( Vcb->VcbState, VCB_STATE_LOCKED)) {
                        NtfsCheckpointVolumeUntilDone( IrpContext, Vcb );
                    }
                    NtfsCommitCurrentTransaction( IrpContext );

                    //
                    //  Bug 308819. We find that transactions continue to happen at times even after shutdown
                    //  has been flagged. If we stop the log file, then currently we don't check for
                    //  NULL LSNs getting returned by NtfsWriteLog. As a result our metadata can get
                    //  corrupted. Until we rectify this, let's just not stop the log file in shutdown.
                    //
                    //  NtfsStopLogFile( Vcb );
                    //

                    NtfsAcquireCheckpoint( IrpContext, Vcb );
                    ClearFlag( Vcb->CheckpointFlags,
                               VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);
                    NtfsSetCheckpointNotify( IrpContext, Vcb );
                    NtfsReleaseCheckpoint( IrpContext, Vcb );
                    AcquiredCheckpoint = FALSE;

                    NewIrp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                           Vcb->TargetDeviceObject,
                                                           NULL,
                                                           0,
                                                           NULL,
                                                           &Event,
                                                           NULL );

                    if (NewIrp == NULL) {

                        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
                    }

                    if (NT_SUCCESS(IoCallDriver( Vcb->TargetDeviceObject, NewIrp ))) {

                        (VOID) KeWaitForSingleObject( &Event,
                                                      Executive,
                                                      KernelMode,
                                                      FALSE,
                                                      NULL );

                        KeClearEvent( &Event );
                    }
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                NtfsMinimumExceptionProcessing( IrpContext );
            }

            if (AcquiredCheckpoint) {

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                ClearFlag( Vcb->CheckpointFlags,
                           VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);
                NtfsSetCheckpointNotify( IrpContext, Vcb );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
            }

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN );
            ClearFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );

            if (AcquiredFiles) {

                NtfsReleaseAllFiles( IrpContext, Vcb, TRUE );
            }
        }

    } finally {

        NtfsReleaseGlobal( IrpContext );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    }

    DebugTrace( -1, Dbg, ("NtfsFsdShutdown -> STATUS_SUCCESS\n") );

    FsRtlExitFileSystem();

    return STATUS_SUCCESS;
}


VOID
NtfsCheckpointVolumeUntilDone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine keeps trying to checkpoint/flush a volume until it
    works.  Doing clean checkpoints and looping back to retry on log file full.

Arguments:

    Vcb - Vcb to checkpoint til done

Return Value:

    None

--*/

{
    NTSTATUS Status;

    do {

        Status = STATUS_SUCCESS;

        try {

#ifdef PERF_STATS
            IrpContext->LogFullReason = LF_DISMOUNT;
#endif
            NtfsCheckpointVolume( IrpContext,
                                  Vcb,
                                  TRUE,
                                  TRUE,
                                  TRUE,
                                  0,
                                  Vcb->LastRestartArea );
        } except( (Status = GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER ) {

            NtfsMinimumExceptionProcessing( IrpContext );
        }

        if (!NT_SUCCESS(Status)) {

            //
            //  To make sure that we can access all of our streams correctly,
            //  we first restore all of the higher sizes before aborting the
            //  transaction.  Then we restore all of the lower sizes after
            //  the abort, so that all Scbs are finally restored.
            //

            NtfsRestoreScbSnapshots( IrpContext, TRUE );
            NtfsAbortTransaction( IrpContext, IrpContext->Vcb, NULL );
            NtfsRestoreScbSnapshots( IrpContext, FALSE );

            //
            //  A clean volume checkpoint should never get log file full
            //

            if (Status == STATUS_LOG_FILE_FULL) {

                //
                //  Make sure we don't leave the error code in the top-level
                //  IrpContext field.
                //

                ASSERT( IrpContext->TransactionId == 0 );
                IrpContext->ExceptionStatus = STATUS_SUCCESS;

#ifdef PERF_STATS
                IrpContext->LogFullReason = LF_DISMOUNT;
#endif

                NtfsCheckpointVolume( IrpContext,
                                      Vcb,
                                      TRUE,
                                      TRUE,
                                      FALSE,
                                      0,
                                      Vcb->LastRestartArea );
            }
        }

    } while (Status == STATUS_LOG_FILE_FULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=ntfs
TARGETTYPE=DRIVER
DRIVERTYPE=FS

INCLUDES=..;$(PROJECT_ROOT)\ntos\inc;$(DRIVERS_INC_PATH)

NTPROFILEINPUT=yes

C_DEFINES=$(C_DEFINES) -D_NTDRIVER_

!IFDEF BUILD_FOR_3_51
C_DEFINES= $(C_DEFINES) -D_NTIFS_
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\AllocSup.c \
        ..\AttrData.c \
        ..\AttrSup.c  \
        ..\BitmpSup.c \
        ..\CacheSup.c \
        ..\CheckSup.c \
        ..\Cleanup.c  \
        ..\Close.c    \
        ..\ColatSup.c \
        ..\Create.c   \
        ..\DevCtrl.c  \
        ..\DevIoSup.c \
        ..\DirCtrl.c  \
        ..\Ea.c       \
        ..\FileInfo.c \
        ..\FilObSup.c \
        ..\Flush.c    \
        ..\FsCtrl.c   \
        ..\FspDisp.c  \
        ..\FstIoSup.c \
        ..\HashSup.c  \
        ..\IndexSup.c \
        ..\LockCtrl.c \
        ..\LogSup.c   \
        ..\McbSup.c   \
        ..\MftSup.c   \
        ..\NameSup.c  \
        ..\Ntfs.rc    \
        ..\NtfsData.c \
        ..\NtfsExp.c  \
        ..\NtfsInit.c \
        ..\ObjIdSup.c \
        ..\Pnp.c      \
        ..\PrefxSup.c \
        ..\Quota.c    \
        ..\QuotaSup.c \
        ..\Read.c     \
        ..\ReparSup.c \
        ..\ResrcSup.c \
        ..\RestrSup.c \
        ..\SecurSup.c \
        ..\SeInfo.c   \
        ..\Shutdown.c \
        ..\StrucSup.c \
        ..\UsnSup.c   \
        ..\VattrSup.c \
        ..\VerfySup.c \
        ..\ViewSup.c  \
        ..\VolInfo.c  \
        ..\WorkQue.c  \
        ..\Write.c

PRECOMPILED_INCLUDE=..\ntfsproc.h
PRECOMPILED_PCH=ntfsproc.pch
PRECOMPILED_OBJ=ntfsproc.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\vattrsup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    VAttrSup.c

Abstract:

    This module implements the attribute routines for NtOfs

Author:

    Tom Miller      [TomM]          10-Apr-1996

Revision History:

--*/

#include "NtfsProc.h"

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('vFtN')

#undef NtOfsMapAttribute
NTFSAPI
VOID
NtOfsMapAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    );

#undef NtOfsPreparePinWrite
NTFSAPI
VOID
NtOfsPreparePinWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    );

#undef NtOfsPinRead
NTFSAPI
VOID
NtOfsPinRead(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PMAP_HANDLE MapHandle
    );

#undef NtOfsReleaseMap
NTFSAPI
VOID
NtOfsReleaseMap (
    IN PIRP_CONTEXT IrpContext,
    IN PMAP_HANDLE MapHandle
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtOfsCreateAttribute)
#pragma alloc_text(PAGE, NtOfsCreateAttributeEx)
#pragma alloc_text(PAGE, NtOfsCloseAttribute)
#pragma alloc_text(PAGE, NtOfsDeleteAttribute)
#pragma alloc_text(PAGE, NtOfsQueryLength)
#pragma alloc_text(PAGE, NtOfsSetLength)
#pragma alloc_text(PAGE, NtfsHoldIrpForNewLength)
#pragma alloc_text(PAGE, NtOfsPostNewLength)
#pragma alloc_text(PAGE, NtOfsFlushAttribute)
#pragma alloc_text(PAGE, NtOfsPutData)
#pragma alloc_text(PAGE, NtOfsMapAttribute)
#pragma alloc_text(PAGE, NtOfsReleaseMap)
#endif


NTFSAPI
NTSTATUS
NtOfsCreateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN UNICODE_STRING Name,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG LogNonresidentToo,
    OUT PSCB *ReturnScb
    )

/*++

Routine Description:

    This routine may be called to create / open a named data attribute
    within a given file, which may or may not be recoverable.

Arguments:

    Fcb - File in which the attribute is to be created.  It is acquired exclusive

    Name - Name of the attribute for all related Scbs and attributes on disk.

    CreateOptions - Standard create flags.

    LogNonresidentToo - Supplies nonzero if updates to the attribute should
                        be logged.

    ReturnScb - Returns an Scb as handle for the attribute.

Return Value:

    STATUS_OBJECT_NAME_COLLISION -- if CreateNew and attribute already exists
    STATUS_OBJECT_NAME_NOT_FOUND -- if OpenExisting and attribute does not exist

--*/

{
    return NtOfsCreateAttributeEx( IrpContext,
                                   Fcb,
                                   Name,
                                   $DATA,
                                   CreateOptions,
                                   LogNonresidentToo,
                                   ReturnScb );
}


NTFSAPI
NTSTATUS
NtOfsCreateAttributeEx (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN UNICODE_STRING Name,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG LogNonresidentToo,
    OUT PSCB *ReturnScb
    )

/*++

Routine Description:

    This routine may be called to create / open a named data attribute
    within a given file, which may or may not be recoverable.

Arguments:

    Fcb - File in which the attribute is to be created.  It is acquired exclusive

    Name - Name of the attribute for all related Scbs and attributes on disk.

    CreateOptions - Standard create flags.

    LogNonresidentToo - Supplies nonzero if updates to the attribute should
                        be logged.

    ReturnScb - Returns an Scb as handle for the attribute.

Return Value:

    STATUS_OBJECT_NAME_COLLISION -- if CreateNew and attribute already exists
    STATUS_OBJECT_NAME_NOT_FOUND -- if OpenExisting and attribute does not exist

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    BOOLEAN FoundAttribute;
    NTSTATUS Status = STATUS_SUCCESS;
    PSCB Scb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( NtfsIsExclusiveFcb( Fcb ));

    PAGED_CODE();

    if (AttributeTypeCode != $DATA &&
        AttributeTypeCode != $LOGGED_UTILITY_STREAM) {

        ASSERTMSG( "Invalid attribute type code in NtOfsCreateAttributeEx", FALSE );

        *ReturnScb = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Now, just create the Data Attribute.
    //

    NtfsInitializeAttributeContext( &LocalContext );

    try {

        //
        //  First see if the attribute already exists, by searching for the root
        //  attribute.
        //

        FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                    Fcb,
                                                    &Fcb->FileReference,
                                                    AttributeTypeCode,
                                                    &Name,
                                                    NULL,
                                                    TRUE,
                                                    &LocalContext );

        //
        //  If it is not there, and the CreateOptions allow, then let's create
        //  the attribute root now.  (First cleaning up the attribute context from
        //  the lookup).
        //

        if (!FoundAttribute && (CreateOptions <= CREATE_OR_OPEN)) {

            //
            //  Make sure we acquire the quota resource before creating the stream.  Just
            //  in case we need the Mft during the create.
            //

            if (NtfsIsTypeCodeSubjectToQuota( AttributeTypeCode ) &&
                NtfsPerformQuotaOperation( Fcb )) {

                //
                //  The quota index must be acquired before the mft scb is acquired.
                //

                ASSERT( !NtfsIsExclusiveScb( Fcb->Vcb->MftScb ) ||
                        NtfsIsSharedScb( Fcb->Vcb->QuotaTableScb ) );

                NtfsAcquireQuotaControl( IrpContext, Fcb->QuotaControl );
            }

            NtfsCleanupAttributeContext( IrpContext, &LocalContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          AttributeTypeCode,
                                          &Name,
                                          NULL,
                                          0,
                                          0,
                                          NULL,
                                          TRUE,
                                          &LocalContext );

        //
        //  If the attribute is already there, and we were asked to create it, then
        //  return an error.
        //

        } else if (FoundAttribute && (CreateOptions == CREATE_NEW)) {

            Status = STATUS_OBJECT_NAME_COLLISION;
            leave;

        //
        //  If the attribute is not there, and we  were supposed to open existing, then
        //  return an error.
        //

        } else if (!FoundAttribute) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            leave;
        }

        //
        //  Otherwise create/find the Scb and reference it.
        //

        Scb = NtfsCreateScb( IrpContext, Fcb, AttributeTypeCode, &Name, FALSE, &FoundAttribute );

        //
        //  Make sure things are correctly reference counted
        //

        NtfsIncrementCloseCounts( Scb, TRUE, FALSE );

        //
        //  If we created the Scb, then get the no modified write set correctly.
        //

        ASSERT( !FoundAttribute ||
                (LogNonresidentToo == BooleanFlagOn(Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE)) );

        if (!FoundAttribute && LogNonresidentToo) {
            SetFlag( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );
            Scb->Header.ValidDataLength.QuadPart = MAXLONGLONG;
        }

        //
        //  Make sure the stream can be mapped internally.  Defer this for the Usn journal
        //  until we set up the journal bias.
        //

        if ((Scb->FileObject == NULL) && !FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {
            NtfsCreateInternalAttributeStream( IrpContext, Scb, TRUE, NULL );
        }

        NtfsUpdateScbFromAttribute( IrpContext, Scb, NtfsFoundAttribute(&LocalContext) );

    } finally {

        if (AbnormalTermination( )) {
            if (Scb != NULL) {
                NtOfsCloseAttribute( IrpContext, Scb );
            }
        }

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );
    }

    *ReturnScb = Scb;

    return Status;
}


NTFSAPI
VOID
NtOfsCloseAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to close a previously returned handle on an attribute.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this attribute.

Return Value:

    None.

--*/

{
    ASSERT( NtfsIsExclusiveFcb( Scb->Fcb ));

    PAGED_CODE();

    //
    //  We either need the caller to empty this list before closing (as assumed here),
    //  or possibly empty it here.  At this point it seems better to assume that the
    //  caller must take action to insure any waiting threads will shutdown and not
    //  touch the stream anymore, then call NtOfsPostNewLength to flush the queue.
    //  If the queue is nonempty here, maybe the caller didn't think this through!
    //

    ASSERT( IsListEmpty( &Scb->ScbType.Data.WaitForNewLength ) ||
            (Scb->CloseCount > 1) );

    NtfsDecrementCloseCounts( IrpContext, Scb, NULL, TRUE, FALSE, TRUE, NULL );
}


NTFSAPI
VOID
NtOfsDeleteAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to delete an attribute with type code
    $LOGGED_UTILITY_STREAM.

Arguments:

    Fcb - Supplies an Fcb as the previously returned object handle for the file

    Scb - Supplies an Scb as the previously returned handle for this attribute.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    BOOLEAN FoundAttribute;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        //
        //  Make sure we aren't deleting a data stream.  We do this after
        //  initializing the attribute context to make the finally clause simpler.
        //  This test can be removed if some trusted component using the NtOfs
        //  API has a legitimate need to delete other types of attributes.
        //

        NtfsInitializeAttributeContext( &LocalContext );

        if (Scb->AttributeTypeCode != $LOGGED_UTILITY_STREAM) {

            leave;
        }

        //
        //  First see if there is some attribute allocation, and if so truncate it
        //  away allowing this operation to be broken up.
        //

        if (NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       Scb->AttributeTypeCode,
                                       &Scb->AttributeName,
                                       NULL,
                                       FALSE,
                                       &LocalContext )

                &&

            !NtfsIsAttributeResident( NtfsFoundAttribute( &LocalContext ))) {

            ASSERT( Scb->FileObject != NULL );

            NtfsDeleteAllocation( IrpContext, NULL, Scb, 0, MAXLONGLONG, TRUE, TRUE );
        }

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );

        //
        //  Initialize the attribute context on each trip through the loop.
        //

        NtfsInitializeAttributeContext( &LocalContext );

        //
        //  Now there should be a single attribute record, so look it up and delete it.
        //

        FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                    Fcb,
                                                    &Fcb->FileReference,
                                                    Scb->AttributeTypeCode,
                                                    &Scb->AttributeName,
                                                    NULL,
                                                    TRUE,
                                                    &LocalContext );

        //
        //  If this stream is subject to quota, make sure the quota has been enlarged.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   (DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION),
                                   &LocalContext );

        SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

    } finally {

        NtfsReleaseFcb( IrpContext, Fcb );

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );
    }

    return;
}


NTFSAPI
LONGLONG
NtOfsQueryLength (
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to query the Length (FileSize) of an attribute.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this attribute.

    Length - Returns the current Length of the attribute.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    LONGLONG Length;

    PAGED_CODE();

    NtfsAcquireFsrtlHeader( Scb );
    Length = Scb->Header.FileSize.QuadPart;
    NtfsReleaseFsrtlHeader( Scb );
    return Length;
}


NTFSAPI
VOID
NtOfsSetLength (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Length
    )

/*++

Routine Description:

    This routine may be called to set the Length (FileSize) of an attribute.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this attribute.

    Length - Supplies the new Length for the attribute.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PFILE_OBJECT FileObject = Scb->FileObject;
    PFCB Fcb = Scb->Fcb;
    PVCB Vcb = Scb->Vcb;
    BOOLEAN DoingIoAtEof = FALSE;
    BOOLEAN Truncating = FALSE;
    BOOLEAN CleanupAttrContext = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT( NtfsIsExclusiveScb( Scb ));

    ASSERT(FileObject != NULL);

    PAGED_CODE();

    try {

        //
        //  If this is a resident attribute we will try to keep it resident.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            //
            //  If the new file size is larger than a file record then convert
            //  to non-resident and use the non-resident code below.  Otherwise
            //  call ChangeAttributeValue which may also convert to nonresident.
            //

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            NtfsLookupAttributeForScb( IrpContext,
                                       Scb,
                                       NULL,
                                       &AttrContext );

            //
            //  Either convert or change the attribute value.
            //

            if (Length >= Scb->Vcb->BytesPerFileRecordSegment) {

                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          NtfsFoundAttribute( &AttrContext ),
                                          FALSE,
                                          &AttrContext );

            } else {

                ULONG AttributeOffset;

                //
                //  We are sometimes called by MM during a create section, so
                //  for right now the best way we have of detecting a create
                //  section is whether or not the requestor mode is kernel.
                //

                if ((ULONG)Length > Scb->Header.FileSize.LowPart) {

                    AttributeOffset = Scb->Header.FileSize.LowPart;

                } else {

                    AttributeOffset = (ULONG) Length;
                }

                //
                //  ****TEMP  Ideally we would do this simple case by hand.
                //

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          AttributeOffset,
                                          NULL,
                                          (ULONG)Length - AttributeOffset,
                                          TRUE,
                                          FALSE,
                                          FALSE,
                                          FALSE,
                                          &AttrContext );

                NtfsAcquireFsrtlHeader( Scb );

                Scb->Header.FileSize.QuadPart = Length;

                //
                //  If the file went non-resident, then the allocation size in
                //  the Scb is correct.  Otherwise we quad-align the new file size.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                    Scb->Header.AllocationSize.LowPart = QuadAlign( Scb->Header.FileSize.LowPart );
                    if (Scb->Header.ValidDataLength.QuadPart != MAXLONGLONG) {
                        Scb->Header.ValidDataLength.QuadPart = Length;
                    }

                    Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

                } else {

                    SetFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
                }

                NtfsReleaseFsrtlHeader( Scb );

                //
                //  Now update Cc.
                //

                CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Scb->Header.AllocationSize );

                //
                //  ****TEMP****  This hack is awaiting our actually doing this change
                //                in CcSetFileSizes.
                //

                *((PLONGLONG)(Scb->NonpagedScb->SegmentObject.SharedCacheMap) + 5) = Length;

                leave;
            }
        }

        //
        //  Nonresident path
        //
        //  Now determine where the new file size lines up with the
        //  current file layout.  The two cases we need to consider are
        //  where the new file size is less than the current file size and
        //  valid data length, in which case we need to shrink them.
        //  Or we new file size is greater than the current allocation,
        //  in which case we need to extend the allocation to match the
        //  new file size.
        //

        if (Length > Scb->Header.AllocationSize.QuadPart) {

            LONGLONG NewAllocationSize = Length;
            BOOLEAN AskForMore = TRUE;

            //
            //  See if this is the Usn Journal to enforce allocation granularity.
            //
            //  ****    Temporary - this support should be generalized with an Scb field
            //                      settable by all callers.
            //

            if (Scb == Vcb->UsnJournal) {

                LONGLONG MaxAllocation;

                //
                //  Limit ourselves to 128 runs.  We don't want to commit in the
                //  middle of the allocation.
                //

                NewAllocationSize = MAXIMUM_RUNS_AT_ONCE * Vcb->BytesPerCluster;

                //
                //  Don't use more than 1/4 of the free space on the volume.
                //

                MaxAllocation = Int64ShllMod32( Vcb->FreeClusters, Vcb->ClusterShift - 2 );

                if (NewAllocationSize > MaxAllocation) {

                    //
                    //  Round down to the Max.  Don't worry if there is nothing, our code
                    //  below will catch this case and the allocation package always rounds
                    //  to a compression unit boundary.
                    //

                    NewAllocationSize = MaxAllocation;
                }

                //
                //  Don't grow by more than the Usn delta.
                //

                if (NewAllocationSize > (LONGLONG) Vcb->UsnJournalInstance.AllocationDelta) {

                    NewAllocationSize = (LONGLONG) Vcb->UsnJournalInstance.AllocationDelta;
                }

                NewAllocationSize += (LONGLONG) Scb->Header.AllocationSize.QuadPart;

                //
                //  Handle possible weird case.
                //

                if (NewAllocationSize < Length) {
                    NewAllocationSize = Length;
                }

                //
                //  Always pad the allocation to a compression unit boundary.
                //

                ASSERT( Scb->CompressionUnit != 0 );
                NewAllocationSize = BlockAlign( NewAllocationSize, (LONG)Scb->CompressionUnit );

                AskForMore = FALSE;

            } else if (Scb->Header.PagingIoResource == NULL) {

                //
                //  If the file is sparse then make sure we allocate a full compression unit.
                //  Otherwise we can end up with a partially allocated chunk in the Usn
                //  Journal.
                //

                if (Scb->CompressionUnit != 0) {

                    NewAllocationSize = BlockAlign( NewAllocationSize, (LONG)Scb->CompressionUnit );
                }

                AskForMore = FALSE;
            }

            //
            //  Add the allocation.  Never ask for extra for logged streams.
            //

            NtfsAddAllocation( IrpContext,
                               FileObject,
                               Scb,
                               LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ),
                               LlClustersFromBytes(Scb->Vcb, (NewAllocationSize - Scb->Header.AllocationSize.QuadPart)),
                               AskForMore,
                               NULL );


            NtfsAcquireFsrtlHeader( Scb );

        //
        //  Otherwise see if we have to knock these numbers down...
        //

        } else {

            NtfsAcquireFsrtlHeader( Scb );
            if ((Length < Scb->Header.ValidDataLength.QuadPart) &&
                (Scb->Header.ValidDataLength.QuadPart != MAXLONGLONG)) {

                Scb->Header.ValidDataLength.QuadPart = Length;
            }

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                (Length < Scb->ValidDataToDisk)) {

                Scb->ValidDataToDisk = Length;
            }
        }

        //
        //  Now put the new size in the Scb.
        //

        Scb->Header.FileSize.QuadPart = Length;
        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Call our common routine to modify the file sizes.  We are now
        //  done with Length and NewValidDataLength, and we have
        //  PagingIo + main exclusive (so no one can be working on this Scb).
        //  NtfsWriteFileSizes uses the sizes in the Scb, and this is the
        //  one place where in Ntfs where we wish to use a different value
        //  for ValidDataLength.  Therefore, we save the current ValidData
        //  and plug it with our desired value and restore on return.
        //

        NtfsWriteFileSizes( IrpContext,
                            Scb,
                            &Scb->Header.ValidDataLength.QuadPart,
                            FALSE,
                            TRUE,
                            TRUE );

        //
        //  Now update Cc.
        //

        NtfsSetCcFileSizes( FileObject, Scb, (PCC_FILE_SIZES)&Scb->Header.AllocationSize );

    } finally {

        if (CleanupAttrContext) {
            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

    }
}


NTFSAPI
NTSTATUS
NtfsHoldIrpForNewLength (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PIRP Irp,
    IN LONGLONG Length,
    IN PDRIVER_CANCEL CancelRoutine,
    IN PVOID CapturedData OPTIONAL,
    OUT PVOID *CopyCapturedData OPTIONAL,
    IN ULONG CapturedDataLength
    )

/*++

RoutineDescription:

    This routine may be called to wait until the designated stream exceeds the specified
    length.

Arguments:

    Scb - Supplies the stream to wait on.

    Irp - Supplies the address of the Irp to hold

    Length - Supplies the length to be exceeded.  To wait for any file extend, supply the last seen
             FileSize.  To wait for N new bytes wait for last seen FileSize + N.

    CancelRoutine - Routine to register as the cancel routine.

    CapturedData - Specified if caller wishes to have auxillary data captured to pool.

    CopyCapturedData - Address to store copy of the captured data.

    CapturedDataLength - Length of the auxillary data to capture.  Must be 0 if CapturedData not
                         specified.

Return value:

    NTSTATUS - Status of posting this request.  STATUS_CANCELLED if the irp has been cancelled
        before we could register a callback, STATUS_PENDING if the request was posted without
        problem.  Any other error indicates the irp wasn't posted and our caller needs to
        clean it up.

--*/

{
    PWAIT_FOR_NEW_LENGTH WaitForNewLength;
    NTSTATUS Status = STATUS_PENDING;

    PAGED_CODE();

    //
    //  Allocate and initialize a wait block.
    //

    WaitForNewLength = NtfsAllocatePool( NonPagedPool, QuadAlign(sizeof(WAIT_FOR_NEW_LENGTH)) + CapturedDataLength );
    RtlZeroMemory( WaitForNewLength, sizeof(WAIT_FOR_NEW_LENGTH) );
    if (ARGUMENT_PRESENT(CapturedData)) {
        RtlCopyMemory( Add2Ptr(WaitForNewLength, QuadAlign(sizeof(WAIT_FOR_NEW_LENGTH))),
                       CapturedData,
                       CapturedDataLength );
        CapturedData = Add2Ptr(WaitForNewLength, QuadAlign(sizeof(WAIT_FOR_NEW_LENGTH)));

        *CopyCapturedData = CapturedData;
    }

    WaitForNewLength->Irp = Irp;
    WaitForNewLength->Length = Length;
    WaitForNewLength->Stream = Scb;
    WaitForNewLength->Status = STATUS_SUCCESS;
    WaitForNewLength->Flags = NTFS_WAIT_FLAG_ASYNC;

    //
    //  Prepare the Irp for hanging around.  Only make this call once per Irp.  We occasionally
    //  wake up a waiting Irp and then find we don't have enough data to return.  In that
    //  case we don't want to clean up the 'borrowed' IrpContext and the Irp has already
    //  been prepared.  Note: we don't mark the irp pending in prepostinternal and wait until
    //  we've set the cancel routine to do so
    //

    if (IrpContext->OriginatingIrp == Irp) {

        NtfsPrePostIrpInternal( IrpContext, Irp, FALSE, FALSE );
    }

    //
    //  Synchronize to queue and set cancel routine and initialize the wait block.
    //

    NtfsAcquireFsrtlHeader( Scb );
    if (NtfsSetCancelRoutine( Irp, CancelRoutine, (ULONG_PTR) WaitForNewLength, TRUE )) {

        InsertTailList( &Scb->ScbType.Data.WaitForNewLength, &WaitForNewLength->WaitList );        

    } else {

        //
        //  The irp has already been marked for cancel.
        //

        Status = STATUS_CANCELLED;
        NtfsFreePool( WaitForNewLength );
    }
    NtfsReleaseFsrtlHeader( Scb );

    return Status;
}


NTFSAPI
NTSTATUS
NtOfsWaitForNewLength (
    IN PSCB Scb,
    IN LONGLONG Length,
    IN ULONG Async,
    IN PIRP Irp,
    IN PDRIVER_CANCEL CancelRoutine,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

RoutineDescription:

    This routine may be called to wait until the designated stream exceeds the specified
    length.

Arguments:

    Scb - Supplies the stream to wait on.

    Length - Supplies the length to be exceeded.  To wait for any file extend, supply the last seen
             FileSize.  To wait for N new bytes wait for last seen FileSize + N.

    Async - Indicates if we want to complete this request in another thread in
        the case of cancel.

    Irp - Supplies Irp of current request, so that wait can be skipped if Irp has been cancelled.

    CancelRoutine - This is the cancel routine to store in the Irp.

    TimeOut - Supplies an standard optional timeout spec, in case the caller wants to set
              a max time to wait.

Return value:

    NTSTATUS - Status to proceed with the request.  It may be STATUS_SUCCESS, STATUS_TIMEOUT or
        STATUS_CANCELLED.  It may also be some other error specific to this type of request.
        In general the caller may wish to ignore the status code since they own the Irp now
        and are responsible for completing it.

--*/

{
    PWAIT_FOR_NEW_LENGTH WaitForNewLength;
    LONGLONG OriginalLength = Scb->Header.FileSize.QuadPart;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Allocate and initialize a wait block.
    //

    WaitForNewLength = NtfsAllocatePool( NonPagedPool, sizeof( WAIT_FOR_NEW_LENGTH ));
    WaitForNewLength->Irp = Irp;
    WaitForNewLength->Length = Length;
    WaitForNewLength->Stream = Scb;
    WaitForNewLength->Status = STATUS_SUCCESS;

    //
    //  Take different action if this is async or sync.
    //

    if (Async) {

        WaitForNewLength->Flags = NTFS_WAIT_FLAG_ASYNC;

    } else {

        WaitForNewLength->Flags = 0;
        KeInitializeEvent( &WaitForNewLength->Event, NotificationEvent, FALSE );
    }

    //
    //  Test if we need to wait at all.
    //

    NtfsAcquireFsrtlHeader( Scb );

    //
    //  Has the length already changed?  If not we must wait.
    //

    if (Scb->Header.FileSize.QuadPart <= Length) {

        //
        //  Now set up the cancel routine.  Return cancel if the user has
        //  already cancelled this.  Otherwise set up to wait.
        //

        if (NtfsSetCancelRoutine( Irp, CancelRoutine, (ULONG_PTR) WaitForNewLength, Async )) {

            InsertTailList( &Scb->ScbType.Data.WaitForNewLength, &WaitForNewLength->WaitList );
            NtfsReleaseFsrtlHeader( Scb );

            //
            //  Now wait for someone to signal the length change.
            //

            if (!Async) {

                do {
                    Status = KeWaitForSingleObject( &WaitForNewLength->Event,
                                                    Executive,
                                                    (KPROCESSOR_MODE)(ARGUMENT_PRESENT(Irp) ?
                                                                        Irp->RequestorMode :
                                                                        KernelMode),
                                                    TRUE,
                                                    Timeout );

                    //
                    //  If the system timed out but there was no change in the file length then
                    //  we want to wait for the first change of the file.  Wait again but without
                    //  a timeout and a length of the current size + 1.  This satisfies the timeout
                    //  semantics which are don't wait for the full user length request to be satisfied
                    //  if it doesn't occur within the timeout period.  Return either what has changed
                    //  in that time or the first change which occurs if nothing changed within the
                    //  timeout period.
                    //

                    if ((Status == STATUS_TIMEOUT) &&
                        ARGUMENT_PRESENT( Timeout ) &&
                        (Scb->Header.FileSize.QuadPart == OriginalLength)) {

                        Timeout = NULL;
                        WaitForNewLength->Length = OriginalLength + 1;

                        //
                        //  Set the status to STATUS_KERNEL_APC so we will retry.
                        //

                        Status = STATUS_KERNEL_APC;
                        continue;
                    }

                } while (Status == STATUS_KERNEL_APC);

                //
                //  Make sure to clear the cancel routine.  We don't care if
                //  a cancel is underway here.
                //

                NtfsAcquireFsrtlHeader( Scb );

                //
                //  Make a timeout look like STATUS_SUCCESS.  Otherwise return the error.
                //

                if (Status == STATUS_TIMEOUT) {

                    Status = STATUS_SUCCESS;

                    //
                    //  Clear the cancel routine.
                    //

                    NtfsClearCancelRoutine( WaitForNewLength->Irp );

                } else {

                    //
                    //  If the wait completed with success then check for the error
                    //  in the wait block.
                    //

                    if (Status == STATUS_SUCCESS) {

                        Status = WaitForNewLength->Status;

                    //
                    //  Clear the cancel routine.
                    //

                    } else {

                        NtfsClearCancelRoutine( WaitForNewLength->Irp );
                    }
                }

                RemoveEntryList( &WaitForNewLength->WaitList );
                NtfsReleaseFsrtlHeader( Scb );
                NtfsFreePool( WaitForNewLength );

            //
            //  The current thread is finished with the Irp.
            //

            } else {

                Status = STATUS_PENDING;
            }

        //
        //  The irp has already been marked for cancel.
        //

        } else {

            NtfsReleaseFsrtlHeader( Scb );
            NtfsFreePool( WaitForNewLength );
            Status = STATUS_CANCELLED;
        }

    } else {

        NtfsReleaseFsrtlHeader( Scb );
        NtfsFreePool( WaitForNewLength );
    }


    return Status;
}


VOID
NtOfsPostNewLength (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PSCB Scb,
    IN BOOLEAN WakeAll
    )

/*++

RoutineDescription:

    This routine may be called to wake one or more waiters based on the desired FileSize change,
    or to unconditionally wake all waiters (such as for a shutdown condition).

    NOTE:  The caller must have the FsRtl header mutex acquired when calling this routine.

Arguments:

    Scb - Supplies the stream to act on.

    WakeAll - Supplies TRUE if all waiters should be unconditionally woken.

Return value:

    None.

--*/

{
    PWAIT_FOR_NEW_LENGTH WaitForNewLength, WaiterToWake;

    ASSERT(FIELD_OFFSET(WAIT_FOR_NEW_LENGTH, WaitList) == 0);

    PAGED_CODE();

    NtfsAcquireFsrtlHeader( Scb );
    WaitForNewLength = (PWAIT_FOR_NEW_LENGTH)Scb->ScbType.Data.WaitForNewLength.Flink;

    while (WaitForNewLength != (PWAIT_FOR_NEW_LENGTH)&Scb->ScbType.Data.WaitForNewLength) {

        //
        //  If we are supposed to wake this guy, then move our pointer to the next guy
        //  first, then wake him, setting his event after removing him from the list,
        //  since setting the event will cause him to eventually reuse the stack space
        //  containing the wait block.
        //

        if ((Scb->Header.FileSize.QuadPart > WaitForNewLength->Length) || WakeAll) {
            WaiterToWake = WaitForNewLength;
            WaitForNewLength = (PWAIT_FOR_NEW_LENGTH)WaitForNewLength->WaitList.Flink;

            //
            //  If this is for an asynchronous Irp, then remove him from the list and
            //  drop the mutex to do further processing.  We only do further processing
            //  if there is not currently a cancel thread active for this Irp.
            //
            //  NOTE:   This code currently relies on the fact that there is just one
            //          caller to the routine to hold an Irp.  If more such caller's
            //          surface, then the routine address would have to be stored in
            //          the wait context.
            //
            //  If cancel is active then we will skip over this Irp.
            //

            if (NtfsClearCancelRoutine( WaiterToWake->Irp )) {

                if (FlagOn( WaiterToWake->Flags, NTFS_WAIT_FLAG_ASYNC )) {

                    //
                    //  Make sure we decrement the reference count in the Scb.
                    //

                    InterlockedDecrement( &Scb->CloseCount );
                    RemoveEntryList( &WaiterToWake->WaitList );
                    NtfsReleaseFsrtlHeader( Scb );

                    //
                    //  Nothing really should go wrong, unless we get an I/O error,
                    //  none the less, we want to stop any exceptions and complete
                    //  the request ourselves rather than impact our caller.
                    //

                    if (ARGUMENT_PRESENT( IrpContext )) {

                        try {
                            NtfsReadUsnJournal( IrpContext,
                                                WaiterToWake->Irp,
                                                FALSE );
                        } except(NtfsExceptionFilter( NULL, GetExceptionInformation())) {
                            NtfsCompleteRequest( NULL, WaiterToWake->Irp, GetExceptionCode() );
                        }

                    //
                    //  Assume the only caller with no IrpContext is cancelling the request.
                    //

                    } else {

                        NtfsCompleteRequest( NULL, WaiterToWake->Irp, STATUS_CANCELLED );
                    }

                    //
                    //  Free the wait block and go back to the beginning of the list.
                    //  Is it possible that we can into a continuous loop here?  We may
                    //  need a strategy to recognize which entries we have visited
                    //  in this loop.
                    //

                    NtfsFreePool( WaiterToWake );
                    NtfsAcquireFsrtlHeader( Scb );
                    WaitForNewLength = (PWAIT_FOR_NEW_LENGTH)Scb->ScbType.Data.WaitForNewLength.Flink;

                } else {

                    KeSetEvent( &WaiterToWake->Event, 0, FALSE );
                }
            }

        } else {

            WaitForNewLength = (PWAIT_FOR_NEW_LENGTH)WaitForNewLength->WaitList.Flink;
        }
    }
    NtfsReleaseFsrtlHeader( Scb );
}

NTFSAPI
VOID
NtOfsFlushAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ULONG Purge
    )

/*++

Routine Description:

    This routine flushes the specified attribute, and optionally purges it from the cache.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this attribute.

    Purge - Supplies TRUE if the attribute is to be purged.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    PAGED_CODE();

    if (Purge) {
        NtfsFlushAndPurgeScb( IrpContext, Scb, NULL );
    } else {
        NtfsFlushUserStream( IrpContext, Scb, NULL, 0 );
    }
}


NTFSAPI
VOID
NtOfsPutData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    IN PVOID Data OPTIONAL
    )

/*++

Routine Description:

    This routine is called to update a range of a recoverable stream. Note this
    update cannot extend the filesize unless its a write to eof put (Offset = -1)

Arguments:

    Scb - Scb for the stream to zero.

    Offset - Offset in stream to update.

    Length - Length of stream to update in bytes.

    Data - Data to update stream with if specified, else range should be zeroed.

Return Value:

    None.

--*/

{
    ULONG OriginalLength = Length;
    BOOLEAN WriteToEof = FALSE;
    BOOLEAN MovingBackwards = TRUE;

    PAGED_CODE();

    ASSERT( FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE ) );

    //
    //  Handle Put to end of file.
    //

    if (Offset < 0) {
        WriteToEof = TRUE;
        Offset = Scb->Header.FileSize.QuadPart;
        NtOfsSetLength( IrpContext, Scb, Offset + Length );
    }

    ASSERT((Offset + Length) <= Scb->Header.FileSize.QuadPart);

    //
    //  First handle the resident case.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

        ATTRIBUTE_ENUMERATION_CONTEXT Context;
        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        PATTRIBUTE_RECORD_HEADER Attribute;
        ULONG RecordOffset, AttributeOffset;
        PVCB Vcb = Scb->Vcb;

        NtfsInitializeAttributeContext( &Context );

        try {

            //
            //  Lookup and pin the attribute.
            //

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );
            NtfsPinMappedAttribute( IrpContext, Vcb, &Context );

            //
            //  Extract the relevant pointers and calculate offsets.
            //

            FileRecord = NtfsContainingFileRecord(&Context);
            Attribute = NtfsFoundAttribute(&Context);
            RecordOffset = PtrOffset(FileRecord, Attribute);
            AttributeOffset = Attribute->Form.Resident.ValueOffset + (ULONG)Offset;

            //
            //  Log the change while we still have the old data.
            //

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb( &Context ),
                          UpdateResidentValue,
                          Data,
                          Length,
                          UpdateResidentValue,
                          Add2Ptr(Attribute, Attribute->Form.Resident.ValueOffset + (ULONG)Offset),
                          Length,
                          NtfsMftOffset(&Context),
                          RecordOffset,
                          AttributeOffset,
                          Vcb->BytesPerFileRecordSegment );

            //
            //  Now update this data by calling the same routine as restart.
            //

            NtfsRestartChangeValue( IrpContext,
                                    FileRecord,
                                    RecordOffset,
                                    AttributeOffset,
                                    Data,
                                    Length,
                                    FALSE );

            //
            //  If there is a stream for this attribute, then we must update it in the
            //  cache, copying from the attribute itself in order to handle the zeroing
            //  (Data == NULL) case.
            //

            if (Scb->FileObject != NULL) {
                CcCopyWrite( Scb->FileObject,
                             (PLARGE_INTEGER)&Offset,
                             Length,
                             TRUE,
                             Add2Ptr(Attribute, AttributeOffset) );
            }

            //
            //  Optionally update ValidDataLength
            //

            Offset += Length;
            if (Offset > Scb->Header.ValidDataLength.QuadPart) {
                Scb->Header.ValidDataLength.QuadPart = Offset;
            }

        } finally {
            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

    //
    //  Now handle the nonresident case.
    //

    } else {

        PVOID Buffer;
        PVOID SubData = NULL;
        LONGLONG NewValidDataLength = Offset + Length;
        PBCB Bcb = NULL;
        ULONG PageOffset = (ULONG)Offset & (PAGE_SIZE - 1);
        ULONGLONG SubOffset;
        ULONG SubLength;
        
        ASSERT(Scb->FileObject != NULL);

        //
        //  If we are starting beyond ValidDataLength, then recurse to
        //  zero what we need.
        //

        if (Offset > Scb->Header.FileSize.QuadPart) {

            ASSERT((Offset - Scb->Header.FileSize.QuadPart) <= MAXULONG);

            NtOfsPutData( IrpContext,
                          Scb,
                          Scb->Header.FileSize.QuadPart,
                          (ULONG)(Offset - Scb->Header.FileSize.QuadPart),
                          NULL );
        }

        try {

            //
            //  Now loop until there are no more pages with new data
            //  to log.  We'll start assuming a backwards copy 
            //

            while (Length != 0) {

                if (MovingBackwards) {

                    //
                    //  Calculate the last page of the transfer - if its the 1st page start at offset
                    //  

                    SubOffset = max( Offset, BlockAlignTruncate( Offset + Length - 1, PAGE_SIZE ) );
                    SubLength = (ULONG)(Offset + Length - SubOffset); 

                    //
                    //  This guarantees we can truncate to a 32 bit value
                    // 

                    ASSERT( Offset + Length - SubOffset <= PAGE_SIZE );
                
                } else {

                    SubOffset = Offset + OriginalLength - Length;
                    SubLength = min( PAGE_SIZE - ((ULONG)SubOffset & (PAGE_SIZE - 1)), Length );
                }

                if (Data != NULL) {
                    SubData = Add2Ptr( Data, SubOffset - Offset );
                }

                //
                //  Pin the page
                //  

                NtfsPinStream( IrpContext,
                               Scb,
                               SubOffset,
                               SubLength,
                               &Bcb,
                               &Buffer );

                //
                //  Doublecheck the direction of copy based on the relative position of the 
                //  source (data) and destination (buffer).  We don't care if the source is null
                //  We'll only switch once from backwards to forwards
                //  

                if (MovingBackwards &&
                    ((PCHAR)Buffer < (PCHAR)SubData) &&
                    (Data != NULL)) {

                    //
                    //  Start over with the opposite direction
                    //  

                    MovingBackwards = FALSE;
                    NtfsUnpinBcb( IrpContext, &Bcb );
                    continue;
                }

                //
                //  Now log the changes to this page.
                //

                (VOID)
                NtfsWriteLog( IrpContext,
                              Scb,
                              Bcb,
                              UpdateNonresidentValue,
                              SubData,
                              SubLength,
                              WriteToEof ? Noop : UpdateNonresidentValue,
                              WriteToEof ? NULL : Buffer,
                              WriteToEof ? 0 : SubLength,
                              BlockAlignTruncate( SubOffset, PAGE_SIZE ),
                              (ULONG)(SubOffset & (PAGE_SIZE - 1)),
                              0,
                              (ULONG)(SubOffset & (PAGE_SIZE - 1)) + SubLength );

                //
                //  Move the data into place.
                //

                if (Data != NULL) {
                    RtlMoveMemory( Buffer, SubData, SubLength );
                } else {
                    RtlZeroMemory( Buffer, SubLength );
                }

                //
                //  Unpin the page and decrement the length
                //

                NtfsUnpinBcb( IrpContext, &Bcb );

                Length -= SubLength;
            }

            //
            //  Optionally update ValidDataLength
            //

            if (NewValidDataLength > Scb->Header.ValidDataLength.QuadPart) {

                Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;
                NtfsWriteFileSizes( IrpContext, Scb, &NewValidDataLength, TRUE, TRUE, TRUE );

                //
                //  See if we have to wake anyone.
                //

                if (!IsListEmpty( &Scb->ScbType.Data.WaitForNewLength )) {
                    NtfsPostToNewLengthQueue( IrpContext, Scb );
                }
            }

        } finally {
            NtfsUnpinBcb( IrpContext, &Bcb );
        }
    }
}


//
//  The following prototypes are here only for someone external to Ntfs (such as EFS)
//  trying to link to Ntfs using ntfsexp.h.
//

NTFSAPI
VOID
NtOfsMapAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    NtOfsMapAttribute maps the given region of an Scb. Its a thin wrapper
    around CcMapData.

Arguments:

    IrpContext - Supplies the irpcontext associated with the current operation

    Scb - Scb to map data from

    Offset - offset into data

    Length - length of region to be pinned

    Buffer - returned buffer with pinned data virtual address

    MapHandle - returned map handle used to manage the pinned region.

Return Value:

    None

--*/

{
    PAGED_CODE( );
    UNREFERENCED_PARAMETER( IrpContext );
    CcMapData( Scb->FileObject, (PLARGE_INTEGER)&Offset, Length, TRUE, &MapHandle->Bcb, Buffer );
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    MapHandle->Buffer = *(PVOID *)Buffer;
}


NTFSAPI
VOID
NtOfsPreparePinWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PVOID *Buffer,
    OUT PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    NtOfsPreparePinWrite maps and pins a portion of the specified attribute and
    returns a pointer to the memory.  This is equivalent to doing a NtOfsMapAttribute
    followed by NtOfsPinRead and NtOfsDirty but is more efficient.

Arguments:

    IrpContext - Supplies the irpcontext associated with the current operation

    Scb - Scb to pin in preparation for a write

    Offset - offset into data

    Length - length of region to be pinned

    Buffer - returned buffer with pinned data virtual address

    MapHandle - returned map handle used to manage the pinned region.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );
    if ((Offset + Length) > Scb->Header.AllocationSize.QuadPart) {
        ExRaiseStatus(STATUS_END_OF_FILE);
    }
    CcPreparePinWrite( Scb->FileObject, (PLARGE_INTEGER)&Offset, Length, FALSE, TRUE, &MapHandle->Bcb, Buffer );
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    MapHandle->Buffer = Buffer;
}


NTFSAPI
VOID
NtOfsPinRead(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length,
    OUT PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    NtOfsPinRead pins a section of a map and read in all pages from the mapped
    attribute.  Offset and Length must describe a byte range which is equal to
    or included by the original mapped range.

Arguments:

    IrpContext - Supplies the irpcontext associated with the current operation

    Scb - Scb to pin data for reads in

    Offset - offset into data

    Length - length of region to be pinned

    MapHandle - returned map handle used to manage the pinned region.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );
    ASSERT( MapHandle->Bcb != NULL );
    CcPinMappedData( Scb->FileObject, (PLARGE_INTEGER)&Offset, Length, TRUE, &MapHandle->Bcb );
}


NTFSAPI
VOID
NtOfsReleaseMap (
    IN PIRP_CONTEXT IrpContext,
    IN PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    This routine unmaps/unpins a mapped portion of an attribute.

Arguments:

    IrpContext - Supplies the irpcontext associated with the current operation

    MapHandle - Supplies map handle containing the bcb to be released.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    if (MapHandle->Bcb != NULL) {
        CcUnpinData( MapHandle->Bcb );
#ifdef MAPCOUNT_DBG
        IrpContext->MapCount--;
#endif
        MapHandle->Bcb = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\verfysup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements the Ntfs Verify volume and fcb support
    routines

Author:

    Gary Kimura         [GaryKi]            30-Jan-1992

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_VERFYSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('VFtN')

#if DBG
extern BOOLEAN NtfsCheckQuota;
#endif

BOOLEAN NtfsSuppressPopup = FALSE;

//
//  Local procedure prototypes
//

VOID
NtfsPerformVerifyDiskRead (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID Buffer,
    IN LONGLONG Offset,
    IN ULONG NumberOfBytesToRead
    );

NTSTATUS
NtfsVerifyReadCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

VOID
NtOfsCloseIndexSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB *Scb
    );


typedef struct _EVENTLOG_ERROR_PACKET {
    PVCB Vcb;
    UCHAR MajorFunction;
    ULONG TransactionId;
    PQUOTA_USER_DATA UserData;
    ULONG LogCode;
    NTSTATUS FinalStatus;
} EVENTLOG_ERROR_PACKET, *PEVENTLOG_ERROR_PACKET;


VOID
NtfsResolveVolumeAndLogEventSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID Context
    );

BOOLEAN
NtfsLogEventInternal (
    IN PVCB Vcb,
    IN UCHAR MajorFunction,
    IN ULONG TransactionId,
    IN PUNICODE_STRING String OPTIONAL,
    IN PQUOTA_USER_DATA UserData OPTIONAL,
    IN NTSTATUS LogCode,
    IN NTSTATUS FinalStatus
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCheckpointAllVolumes)
#pragma alloc_text(PAGE, NtfsCheckUsnTimeOut)
#pragma alloc_text(PAGE, NtfsMarkVolumeDirty)
#pragma alloc_text(PAGE, NtfsPerformVerifyOperation)
#pragma alloc_text(PAGE, NtfsPingVolume)
#pragma alloc_text(PAGE, NtfsUpdateVolumeInfo)
#pragma alloc_text(PAGE, NtOfsCloseAttributeSafe)
#pragma alloc_text(PAGE, NtOfsCloseIndexSafe)
#pragma alloc_text(PAGE, NtfsResolveVolumeAndLogEventSpecial)
#pragma alloc_text(PAGE, NtfsLogEventInternal)
#endif



BOOLEAN
NtfsPerformVerifyOperation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is used to force a verification of the volume.  It assumes
    that everything might be resource/mutex locked so it cannot take out
    any resources.  It will read in the boot sector and the dasd file record
    and from those determine if the volume is okay.  This routine is called
    whenever the real device has started rejecting I/O requests with
    VERIFY_REQUIRED.

    If the volume verifies okay then we will return TRUE otherwise we will
    return FALSE.

    It does not alter the Vcb state.

Arguments:

    Vcb - Supplies the Vcb being queried.

Return Value:

    BOOLEAN - TRUE if the volume verified okay, and FALSE otherwise.

--*/

{
    BOOLEAN Results = FALSE;

    PPACKED_BOOT_SECTOR BootSector;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    VCN LogFileVcn;
    LCN LogFileLcn;
    LONGLONG ClusterCount;
    ULONG RemainingLogBytes;
    LONGLONG CurrentLogBytes;
    PVOID CurrentLogBuffer;
    PVOID LogFileHeader = NULL;

    LONGLONG Offset;

    PSTANDARD_INFORMATION StandardInformation;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPerformVerifyOperation, Vcb = %08lx\n", Vcb) );

    BootSector = NULL;
    FileRecord = NULL;

    try {

        //
        //  Forget this volume if we have already failed the remount once.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            leave;
        }

        //
        //  Allocate a buffer for the boot sector, read it in, and then check if
        //  it some of the fields still match.  The starting lcn is zero and the
        //  size is the size of a disk sector.
        //

        BootSector = NtfsAllocatePool( NonPagedPool,
                                        (ULONG) ROUND_TO_PAGES( Vcb->BytesPerSector ));

        NtfsPerformVerifyDiskRead( IrpContext, Vcb, BootSector, (LONGLONG)0, Vcb->BytesPerSector );

        //
        //  For now we will only check that the serial numbers, mft lcn's and
        //  number of sectors match up with what they use to be.
        //

        if ((BootSector->SerialNumber !=  Vcb->VolumeSerialNumber) ||
            (BootSector->MftStartLcn !=   Vcb->MftStartLcn) ||
            (BootSector->Mft2StartLcn !=  Vcb->Mft2StartLcn) ||
            (BootSector->NumberSectors != Vcb->NumberSectors)) {

            leave;
        }

        //
        //  Allocate a buffer for the dasd file record, read it in, and then check
        //  if some of the fields still match.  The size of the record is the number
        //  of bytes in a file record segment, and because the dasd file record is
        //  known to be contiguous with the start of the mft we can compute the starting
        //  lcn as the base of the mft plus the dasd number mulitplied by the clusters
        //  per file record segment.
        //

        FileRecord = NtfsAllocatePool( NonPagedPoolCacheAligned,
                                        (ULONG) ROUND_TO_PAGES( Vcb->BytesPerFileRecordSegment ));

        Offset = LlBytesFromClusters(Vcb, Vcb->MftStartLcn) +
                 (VOLUME_DASD_NUMBER * Vcb->BytesPerFileRecordSegment);

        NtfsPerformVerifyDiskRead( IrpContext, Vcb, FileRecord, Offset, Vcb->BytesPerFileRecordSegment );

        //
        //  Given a pointer to a file record we want the value of the first attribute which
        //  will be the standard information attribute.  Then we will check the
        //  times stored in the standard information attribute against the times we
        //  have saved in the vcb.  Note that last access time will be modified if
        //  the disk was moved and mounted on a different system without doing a dismount
        //  on this system.
        //

        StandardInformation = NtfsGetValue(((PATTRIBUTE_RECORD_HEADER)Add2Ptr( FileRecord,
                                                                               FileRecord->FirstAttributeOffset )));

        if ((StandardInformation->CreationTime !=         Vcb->VolumeCreationTime) ||
            (StandardInformation->LastModificationTime != Vcb->VolumeLastModificationTime) ||
            (StandardInformation->LastChangeTime !=       Vcb->VolumeLastChangeTime) ||
            (StandardInformation->LastAccessTime !=       Vcb->VolumeLastAccessTime)) {

            leave;
        }

        //
        //  If the device is not writable we won't remount it.
        //

        if (NtfsDeviceIoControlAsync( IrpContext,
                                      Vcb->TargetDeviceObject,
                                      IOCTL_DISK_IS_WRITABLE,
                                      NULL,
                                      0 ) == STATUS_MEDIA_WRITE_PROTECTED) {

            leave;
        }

        //
        //  We need to read the start of the log file for Lfs to verify the log file.
        //

        LogFileHeader = NtfsAllocatePool( NonPagedPoolCacheAligned, PAGE_SIZE * 2 );

        //
        //  Now read in the first two pages.  We may have to perform multiple reads to
        //  get the whole thing.
        //

        RemainingLogBytes = PAGE_SIZE * 2;
        CurrentLogBuffer = LogFileHeader;
        LogFileVcn = 0;

        do {

            //
            //  Find the location of the log file start.
            //

            NtfsLookupAllocation( IrpContext,
                                  Vcb->LogFileScb,
                                  LogFileVcn,
                                  &LogFileLcn,
                                  &ClusterCount,
                                  NULL,
                                  NULL );


            CurrentLogBytes = LlBytesFromClusters( Vcb, ClusterCount );

            if (CurrentLogBytes > RemainingLogBytes) {

                CurrentLogBytes = RemainingLogBytes;
            }

            NtfsPerformVerifyDiskRead( IrpContext,
                                       Vcb,
                                       CurrentLogBuffer,
                                       LlBytesFromClusters( Vcb, LogFileLcn ),
                                       (ULONG) CurrentLogBytes );

            //
            //  Move through the log file.
            //

            RemainingLogBytes -= (ULONG) CurrentLogBytes;
            CurrentLogBuffer = Add2Ptr( CurrentLogBuffer, (ULONG) CurrentLogBytes );
            LogFileVcn += ClusterCount;

        } while (RemainingLogBytes);

        //
        //  We need to perform the revert operation on this buffer.
        //

        if (NtfsVerifyAndRevertUsaBlock( IrpContext,
                                         Vcb->LogFileScb,
                                         NULL,
                                         LogFileHeader,
                                         0,
                                         PAGE_SIZE * 2,
                                         0 )) {

            //
            //  Now call Lfs to verify the header.
            //

            Results = LfsVerifyLogFile( Vcb->LogHandle, LogFileHeader, PAGE_SIZE * 2 );
        }

    } finally {

        if (BootSector != NULL) { NtfsFreePool( BootSector ); }
        if (FileRecord != NULL) { NtfsFreePool( FileRecord ); }
        if (LogFileHeader != NULL) { NtfsFreePool( LogFileHeader ); }
    }

    DebugTrace( -1, Dbg, ("NtfsPerformVerifyOperation -> %08lx\n", Results) );

    return Results;
}


VOID
NtOfsCloseIndexSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB *Scb
    )

/*++

Routine Description:

    This routine checks whether the given Scb is NULL, and if not,
    calls NtOfsCloseIndex to close the index.

Arguments:

    Scb - Supplies the Scb of the index to close safely.

Return Value:

    None.

--*/

{
    if (*Scb != NULL) {

        //
        //  Notice that we don't release the Scbs, since
        //  NtOfsCloseIndex might tear the Scbs down and make
        //  trying to release them unsafe.  When this request is
        //  completed, the Scbs will be released anyway.
        //

        NtfsAcquireExclusiveScb( IrpContext, *Scb );
        NtOfsCloseIndex( IrpContext, *Scb );
        *Scb = NULL;
    }
}


VOID
NtOfsCloseAttributeSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine checks whether the given Scb is NULL, and if not,
    calls NtOfsCloseAttribute to close the attribute.

Arguments:

    Scb - Supplies the Scb of the attribute to close safely.

Return Value:

    None.

--*/

{
    if (Scb != NULL) {

        NtOfsCloseAttribute( IrpContext, Scb );
    }
}


VOID
NtfsPerformDismountOnVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DoCompleteDismount,
    OUT PVPB *NewVpbReturn OPTIONAL
    )

/*++

Routine Description:

    This routine is called to start the dismount process on a vcb.
    It marks the Vcb as not mounted and dereferences all opened stream
    file objects, and gets the Vcb out of the Vpb's mounted volume
    structures.

Arguments:

    Vcb - Supplies the Vcb being dismounted

    DoCompleteDismount - Indicates if we are to actually mark the volume
        as dismounted or if we are simply to stop the logfile and close
        the internal attribute streams.

    NewVpbReturn - If supplied, provides a way to return to the caller
                   the new Vpb created in here.  If we do not need to
                   create a new Vpb in this function, we store NULL in
                   NewVpbReturn.

Return Value:

    None.

--*/

{
    PFCB Fcb;
    PFCB NextFcb = NULL;
    PSCB Scb;
    PVOID RestartKey;
    PLIST_ENTRY Links;
    PIRP UsnNotifyIrp;

    BOOLEAN CheckSystemScb;

    PVPB NewVpb;

    DebugTrace( +1, Dbg, ("NtfsPerformDismountOnVcb, Vcb = %08lx\n", Vcb) );

#ifdef DISMOUNT_DBG
    NtfsData.DismountCount += 1;
#endif

    //
    //  We should always be syncrhonized with checkpoints when dismounting initially
    //

    ASSERT( !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) ||
            (Vcb->CheckpointOwnerThread == PsGetCurrentThread()) ||
            ((IrpContext->TopLevelIrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
             (IrpContext->TopLevelIrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME)) );

    //
    //  Blow away our delayed close file object.
    //

    if (!IsListEmpty( &NtfsData.AsyncCloseList ) ||
        !IsListEmpty( &NtfsData.DelayedCloseList )) {

        NtfsFspClose( Vcb );
    }

    //
    //  Commit any current transaction before we start tearing down the volume.
    //

    NtfsCommitCurrentTransaction( IrpContext );

    //
    //  Add one more checkpoint at the front of the logfile if we haven't hit any errors yet
    //  and the device is still present
    //

    if ((IrpContext->ExceptionStatus == STATUS_SUCCESS) &&
        FlagOn( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE ) &&
        FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_COMPLETED ) &&
        !FlagOn( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED)) {

        try {
            NtfsCheckpointVolume( IrpContext, Vcb, TRUE, TRUE, FALSE, LFS_WRITE_FLAG_WRITE_AT_FRONT, Li0 );
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  Swallow any errors while checkpointing
            //

#ifdef BENL_DBG
            KdPrint(( "NTFS: exception in dismount checkpoint 0x%x\n", GetExceptionCode() ));
#endif

            NtfsMinimumExceptionProcessing( IrpContext );
            IrpContext->ExceptionStatus = STATUS_SUCCESS;
        }
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Get rid of all the Ofs indices for Security, Quota, and Object Ids, etc.
        //

        NtOfsCloseIndexSafe( IrpContext, &Vcb->ObjectIdTableScb );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->ReparsePointTableScb );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->OwnerIdTableScb );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->QuotaTableScb );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->SecurityIdIndex );
        NtOfsCloseIndexSafe( IrpContext, &Vcb->SecurityDescriptorHashIndex );
        NtOfsCloseAttributeSafe( IrpContext, Vcb->SecurityDescriptorStream );

        //
        //  Walk through and complete any Irps in the ReadUsn queue.
        //

        if (Vcb->UsnJournal != NULL) {

            PWAIT_FOR_NEW_LENGTH Waiter, NextWaiter;
            PSCB UsnJournal = Vcb->UsnJournal;

            NtfsAcquireExclusiveScb( IrpContext, UsnJournal );

            NtfsAcquireFsrtlHeader( UsnJournal );

            Waiter = (PWAIT_FOR_NEW_LENGTH) UsnJournal->ScbType.Data.WaitForNewLength.Flink;

            while (Waiter != (PWAIT_FOR_NEW_LENGTH) &UsnJournal->ScbType.Data.WaitForNewLength) {

                NextWaiter = (PWAIT_FOR_NEW_LENGTH) Waiter->WaitList.Flink;

                //
                //  Make sure we own the Irp and there is not an active cancel
                //  on this Irp.
                //

                if (NtfsClearCancelRoutine( Waiter->Irp )) {

                    //
                    //  If this is an async request then simply complete the request.
                    //

                    if (FlagOn( Waiter->Flags, NTFS_WAIT_FLAG_ASYNC )) {

                        //
                        //  Make sure we decrement the reference count in the Scb.
                        //  Then remove the waiter from the queue and complete the Irp.
                        //

                        InterlockedDecrement( &UsnJournal->CloseCount );
                        RemoveEntryList( &Waiter->WaitList );

                        NtfsCompleteRequest( NULL, Waiter->Irp, STATUS_VOLUME_DISMOUNTED );
                        NtfsFreePool( Waiter );

                    //
                    //  This is a synch Irp.  All we can do is set the event and note the status
                    //  code.
                    //

                    } else {

                        Waiter->Status = STATUS_VOLUME_DISMOUNTED;
                        KeSetEvent( &Waiter->Event, 0, FALSE );
                    }
                }

                //
                //  Move to the next waiter.
                //

                Waiter = NextWaiter;
            }

            NtfsReleaseFsrtlHeader( UsnJournal );
        }

        //
        //  Walk through and remove all of the entries on the UsnDeleteNotify queue.
        //

        NtfsAcquireUsnNotify( Vcb );

        Links = Vcb->NotifyUsnDeleteIrps.Flink;

        while (Links != &Vcb->NotifyUsnDeleteIrps) {

            UsnNotifyIrp = CONTAINING_RECORD( Links,
                                              IRP,
                                              Tail.Overlay.ListEntry );

            //
            //  Remember to move forward in any case.
            //

            Links = Links->Flink;

            //
            //  Clear the notify routine and detect if cancel has
            //  already been called.
            //

            if (NtfsClearCancelRoutine( UsnNotifyIrp )) {

                RemoveEntryList( &UsnNotifyIrp->Tail.Overlay.ListEntry );
                NtfsCompleteRequest( NULL, UsnNotifyIrp, STATUS_VOLUME_DISMOUNTED );
            }
        }

        ClearFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE );
        NtfsReleaseUsnNotify( Vcb );

        NtOfsCloseAttributeSafe( IrpContext, Vcb->UsnJournal );

#ifdef SYSCACHE_DEBUG
        if (Vcb->SyscacheScb) {
            CACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent;
            NTSTATUS WaitStatus;

            NtfsAcquireExclusiveScb( IrpContext, Vcb->SyscacheScb );

            KeInitializeEvent( &UninitializeCompleteEvent.Event,
                               SynchronizationEvent,
                               FALSE);

            CcUninitializeCacheMap( Vcb->SyscacheScb->FileObject,
                                    &Li0,
                                    &UninitializeCompleteEvent );

            //
            //  Now wait for the cache manager to finish purging the file.
            //  This will guarantee that Mm gets the purge before we
            //  delete the Vcb.
            //

            WaitStatus = KeWaitForSingleObject( &UninitializeCompleteEvent.Event,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

            ASSERT( NT_SUCCESS( WaitStatus ) );

            ObDereferenceObject( Vcb->SyscacheScb->FileObject );
            Vcb->SyscacheScb->FileObject = NULL;

            NtfsDecrementCleanupCounts( Vcb->SyscacheScb, NULL, FALSE );
            NtOfsCloseAttributeSafe( IrpContext, Vcb->SyscacheScb );
            NtfsReleaseScb( IrpContext, Vcb->SyscacheScb );
            Vcb->SyscacheScb = NULL;
        }
#endif

        //
        //  Free the quota control template if necessary.
        //

        if (Vcb->QuotaControlTemplate != NULL) {

            NtfsFreePool( Vcb->QuotaControlTemplate );
            Vcb->QuotaControlTemplate = NULL;
        }

        //
        //  Stop the log file.
        //

        NtfsStopLogFile( Vcb );

        //
        //  Mark the volume as not mounted.
        //

        ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

        //
        //  Now for every file Scb with an opened stream file we will delete
        //  the internal attribute stream.  Before the days of forced dismount
        //  we were basically looking at system files.  Restarting the enumeration
        //  when we found an internal stream wasn't very expensive.  Now that there
        //  may be hundreds or even thousands of Fcbs we really don't want to resume
        //  from the beginning.  Instead we will reference the following entry
        //  while removing the fileobject from the current Fcb.  Then we know
        //  the next entry will remain.
        //

        RestartKey = NULL;
        do {

            Fcb = NextFcb;
            NtfsAcquireFcbTable( IrpContext, Vcb );
            NextFcb = NtfsGetNextFcbTableEntry( Vcb, &RestartKey );

            //
            //  We always want to reference the next entry if present to keep our order correct in the
            //  list.
            //

            if (NextFcb != NULL) {

                //
                //  We'll use this Fcb next time through the loop.
                //

                NextFcb->ReferenceCount += 1;
            }

            //
            //  If our starting Fcb is NULL then we are at the first entry in the list or
            //  we have exhausted the list.  In either case our exist test in the loop
            //  will handle it.
            //

            if (Fcb == NULL) {

                NtfsReleaseFcbTable( IrpContext, Vcb );
                continue;
            }

            //
            //  Remove the extra reference on this Fcb.
            //

            ASSERT_FCB( Fcb );

            Fcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            Scb = NULL;
            while ((Fcb != NULL) && ((Scb = NtfsGetNextChildScb( Fcb, Scb )) != NULL)) {

                FCB_CONTEXT FcbContext;

                ASSERT_SCB( Scb );

                if (Scb->FileObject != NULL) {

                    //
                    //  Assume we want to see if we should check whether to clear a system Scb field.
                    //

                    CheckSystemScb = TRUE;

                    //
                    //  For the VolumeDasdScb and bad cluster file, we simply decrement
                    //  the counts that we incremented.
                    //

                    if ((Scb == Vcb->VolumeDasdScb) ||
                        (Scb == Vcb->BadClusterFileScb)) {

                        Scb->FileObject = NULL;

                        //
                        //  We need to know if the Fcb gets deleted.
                        //

                        Fcb->FcbContext = &FcbContext;
                        FcbContext.FcbDeleted = FALSE;

                        NtfsDecrementCloseCounts( IrpContext,
                                                  Scb,
                                                  NULL,
                                                  TRUE,
                                                  FALSE,
                                                  FALSE,
                                                  NULL );

                        if (FcbContext.FcbDeleted) {
                            Fcb = NULL;
                        } else {
                            Fcb->FcbContext = NULL;
                        }

                    //
                    //  Dereference the file object in the Scb unless it is the one in
                    //  the Vcb for the Log File.  This routine may not be able to
                    //  dereference file object because of synchronization problems (there
                    //  can be a lazy writer callback in process which owns the paging
                    //  io resource).  In that case we don't want to go back to the beginning
                    //  of Fcb table or we will loop indefinitely.
                    //

                    } else if (Scb->FileObject != Vcb->LogFileObject) {

                        //
                        //  If this is the Usn journal then make sure to empty
                        //  the queue of modified Fcb's.
                        //

                        if (Scb == Vcb->UsnJournal) {

                            //
                            //  Before we remove the journal we want to remove all
                            //  of the entries in the modified list.
                            //

                            NtfsLockFcb( IrpContext, Scb->Fcb );

                            Links = Vcb->ModifiedOpenFiles.Flink;

                            while (Vcb->ModifiedOpenFiles.Flink != &Vcb->ModifiedOpenFiles) {

                                RemoveEntryList( Links );
                                Links->Flink = NULL;

                                //
                                //  Look to see if we need to remove the TimeOut link as well.
                                //

                                Links = &(CONTAINING_RECORD( Links, FCB_USN_RECORD, ModifiedOpenFilesLinks ))->TimeOutLinks;

                                if (Links->Flink != NULL) {

                                    RemoveEntryList( Links );
                                }
                                Links = Vcb->ModifiedOpenFiles.Flink;
                            }
                            NtfsUnlockFcb( IrpContext, Scb->Fcb );
                        }

                        //
                        //  Acquire the fcb rather than the scb since the scb may go away
                        //

                        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, ACQUIRE_NO_DELETE_CHECK );

                        //
                        //  We need to know if the Fcb gets deleted.
                        //

                        Fcb->FcbContext = &FcbContext;
                        FcbContext.FcbDeleted = FALSE;

                        try {
                            CheckSystemScb = NtfsDeleteInternalAttributeStream( Scb, TRUE, FALSE );
                        } finally {

                            if (FcbContext.FcbDeleted) {
                                Fcb = NULL;
                            } else {

                                NtfsReleaseFcb( IrpContext, Fcb );
                                Fcb->FcbContext = NULL;
                            }
                        }

                    //
                    //  This is the file object for the Log file.  Remove our
                    //  extra reference on the logfile Scb.
                    //

                    } else if (Scb->FileObject != NULL) {

                        //
                        //  Remember the log file object so we can defer the dereference.
                        //

                        NtfsDecrementCloseCounts( IrpContext,
                                                  Vcb->LogFileScb,
                                                  NULL,
                                                  TRUE,
                                                  FALSE,
                                                  TRUE,
                                                  NULL );

                        Scb->FileObject = NULL;
                    }

                    if (CheckSystemScb) {

                        if (Scb == Vcb->MftScb)                     { Vcb->MftScb = NULL; }
                        else if (Scb == Vcb->Mft2Scb)               { Vcb->Mft2Scb = NULL; }
                        else if (Scb == Vcb->LogFileScb)            { Vcb->LogFileScb = NULL; }
                        else if (Scb == Vcb->VolumeDasdScb)         { Vcb->VolumeDasdScb = NULL; }
                        else if (Scb == Vcb->AttributeDefTableScb)  { Vcb->AttributeDefTableScb = NULL; }
                        else if (Scb == Vcb->UpcaseTableScb)        { Vcb->UpcaseTableScb = NULL; }
                        else if (Scb == Vcb->RootIndexScb)          { Vcb->RootIndexScb = NULL; }
                        else if (Scb == Vcb->BitmapScb)             { Vcb->BitmapScb = NULL; }
                        else if (Scb == Vcb->BadClusterFileScb)     { Vcb->BadClusterFileScb = NULL; }
                        else if (Scb == Vcb->QuotaTableScb)         { Vcb->QuotaTableScb = NULL; }
                        else if (Scb == Vcb->MftBitmapScb)          { Vcb->MftBitmapScb = NULL; }
                        else if (Scb == Vcb->SecurityIdIndex)       { Vcb->SecurityIdIndex = NULL; }
                        else if (Scb == Vcb->SecurityDescriptorHashIndex)
                                                                    { Vcb->SecurityDescriptorHashIndex = NULL; }
                        else if (Scb == Vcb->SecurityDescriptorStream)
                                                                    { Vcb->SecurityDescriptorStream = NULL; }
                        else if (Scb == Vcb->ExtendDirectory)       { Vcb->ExtendDirectory = NULL; }
                        else if (Scb == Vcb->UsnJournal)            { Vcb->UsnJournal = NULL; }

                        //
                        //  Restart the Scb scan for this Fcb.
                        //  our call to Delete Internal Attribute Stream just messed up our
                        //  enumeration.
                        //

                        Scb = NULL;
                    }
                }
            }
        } while (NextFcb != NULL);

        DebugTrace( 0, Dbg, ("Vcb->CloseCount = %08lx\n", Vcb->CloseCount) );

        //
        //  Do any deleayed closes now so we can get the Vcb->CloseCount as
        //  low as we possibly can so we have a good chance of being able to
        //  close the logfile now.
        //

        if (!IsListEmpty( &NtfsData.AsyncCloseList ) ||
            !IsListEmpty( &NtfsData.DelayedCloseList )) {

            NtfsFspClose( Vcb );
        }

        //
        //  The code above may have dropped the CloseCount to 0 even though
        //  there's still a file object for the log file.  If the count
        //  isn't 0 yet, there's a chance that a lazy write could still
        //  happen, in which case we need to keep the logfile around.
        //  Often we can close the logfile now, so the Vpb refcount can go
        //  to zero and show the PnP code that we're ready to be removed.
        //  Any queued closes (async or delayed) don't matter either, since
        //  we know no more writes will be coming in for those file objects.
        //  The FspClose call above may not have caught all the outstanding
        //  closes, since another thread may have just pulled a file from
        //  one of the queues, but not yet processed the actual close.
        //

        if (((Vcb->CloseCount - Vcb->QueuedCloseCount) == 0) &&
            (Vcb->LogFileObject != NULL) &&
            !FlagOn( Vcb->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE )) {

            CACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent;
            NTSTATUS WaitStatus;

            KeInitializeEvent( &UninitializeCompleteEvent.Event,
                               SynchronizationEvent,
                               FALSE);

            CcUninitializeCacheMap( Vcb->LogFileObject,
                                    &Li0,
                                    &UninitializeCompleteEvent );

            //
            //  Now wait for the cache manager to finish purging the file.
            //  This will guarantee that Mm gets the purge before we
            //  delete the Vcb.
            //

            WaitStatus = KeWaitForSingleObject( &UninitializeCompleteEvent.Event,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

            ASSERT( NT_SUCCESS( WaitStatus ) );

            //
            //  Set a flag indicating that we are dereferencing the LogFileObject.
            //

            SetFlag( Vcb->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE );
            ObDereferenceObject( Vcb->LogFileObject );
        }

        //
        //  Now only really dismount the volume if that's what our caller wants.
        //

        if (DoCompleteDismount && !FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT )) {

            PREVENT_MEDIA_REMOVAL Prevent;
            KIRQL SavedIrql;

            //
            //  Attempt to unlock any removable media, ignoring status.  We can't
            //  do this if some previous PnP operation has stopped the device below
            //  us.  Remember that we may be dismounting now after the last async
            //  close has been processed, so we can't just test whether the current
            //  operation is a PnP remove.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED )) {

                Prevent.PreventMediaRemoval = FALSE;
                (VOID)NtfsDeviceIoControl( IrpContext,
                                           Vcb->TargetDeviceObject,
                                           IOCTL_DISK_MEDIA_REMOVAL,
                                           &Prevent,
                                           sizeof(PREVENT_MEDIA_REMOVAL),
                                           NULL,
                                           0,
                                           NULL );
            }

            //
            //  Remove this voldo from the mounted disk structures
            //
            IoAcquireVpbSpinLock( &SavedIrql );

            //
            //  If there are no file objects and no reference counts in the
            //  Vpb then we can use the existing Vpb. Or if we're cleaning
            //  up a vcb where allocation for the spare vpb failed also use it.
            //

            if (((Vcb->CloseCount == 0) &&
                 (Vcb->Vpb->ReferenceCount == 0)) ||

                (Vcb->SpareVpb == NULL)) {

                //
                //  Make a new vpb the io subsys can delete
                //

                Vcb->Vpb->DeviceObject = NULL;
                ClearFlag( Vcb->Vpb->Flags, VPB_MOUNTED );

                if (ARGUMENT_PRESENT( NewVpbReturn )) {

                    //
                    //  Let our caller know we did not end up needing the new vpb.
                    //

                    *NewVpbReturn = NULL;
                }

            //
            //  Otherwise we will swap out the Vpb.
            //

            } else {

                //
                //  Use the spare Vpb in the Vcb.
                //

                NewVpb = Vcb->SpareVpb;
                Vcb->SpareVpb = NULL;

                //
                //  It better be there.
                //

                ASSERT( NewVpb != NULL );

                RtlZeroMemory( NewVpb, sizeof( VPB ) );

                //
                //  Set a few important fields in the Vpb.
                //

                NewVpb->Type = IO_TYPE_VPB;
                NewVpb->Size = sizeof( VPB );
                NewVpb->RealDevice = Vcb->Vpb->RealDevice;
                NewVpb->DeviceObject = NULL;
                NewVpb->Flags = FlagOn( Vcb->Vpb->Flags, VPB_REMOVE_PENDING );

                if (ARGUMENT_PRESENT( NewVpbReturn )) {

                    //
                    //  Let our caller know we will indeed need the new vpb.
                    //

                    *NewVpbReturn = NewVpb;
                }

                Vcb->Vpb->RealDevice->Vpb = NewVpb;

                SetFlag( Vcb->VcbState, VCB_STATE_TEMP_VPB );
                SetFlag( Vcb->Vpb->Flags, VPB_PERSISTENT );
            }

            IoReleaseVpbSpinLock( SavedIrql );

            SetFlag( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT );
        }

    } finally {

        //
        //  We should never be leaking a reference count on an Fcb.
        //

        ASSERT( NextFcb == NULL );

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsPerformDismountOnVcb -> VOID\n") );
    }

    return;
}


BOOLEAN
NtfsPingVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PBOOLEAN OwnsVcb OPTIONAL
    )

/*++

Routine Description:

    This routine will ping the volume to see if the device needs to
    be verified.  It is used for create operations to see if the
    create should proceed or if we should complete the create Irp
    with a remount status.

Arguments:

    Vcb - Supplies the Vcb being pinged

    OwnsVcb - Indicates if this thread already owns the Vcb.  Updated here if we
        need serialization on the Vcb and it isn't already acquired.  If not
        specified then we assume the Vcb is held.

Return Value:

    BOOLEAN - TRUE if the volume is fine and the operation should
        proceed and FALSE if the volume needs to be verified

--*/

{
    BOOLEAN Results;
    ULONG ChangeCount = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPingVolume, Vcb = %08lx\n", Vcb) );

    //
    //  If the media is removable and the verify volume flag in the
    //  device object is not set then we want to ping the device
    //  to see if it needs to be verified.
    //
    //  For other cases we proceed as if the media is present.
    //  The device driver will let us know if it is no longer
    //  present when we have to physically access the disk.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA ) &&
        !FlagOn( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME )) {

        PDEVICE_OBJECT TargetDevice;
        NTSTATUS Status;

        if (ARGUMENT_PRESENT( OwnsVcb ) && !(*OwnsVcb)) {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            *OwnsVcb = TRUE;

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
            }
        }

        TargetDevice = Vcb->TargetDeviceObject;

        Status = NtfsDeviceIoControlAsync( IrpContext,
                                           TargetDevice,
                                           IOCTL_DISK_CHECK_VERIFY,
                                           (PVOID) &ChangeCount,
                                           sizeof( ChangeCount ));

        if (!NT_SUCCESS( Status )) {

            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        if (ChangeCount != Vcb->DeviceChangeCount) {

            //
            //  The disk driver lost a media change event, possibly
            //  because it was eaten by a user request before the
            //  volume was mounted.  We set things up as they would
            //  be if the driver had returned VERIFY_REQUIRED.
            //

            Vcb->DeviceChangeCount = ChangeCount;
            IoSetDeviceToVerify( PsGetCurrentThread(), TargetDevice );
            SetFlag( TargetDevice->Flags, DO_VERIFY_VOLUME );

            NtfsRaiseStatus( IrpContext, STATUS_VERIFY_REQUIRED, NULL, NULL );
        }
    }

    if (FlagOn( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME )) {

        Results = FALSE;

    } else {

        Results = TRUE;
    }

    DebugTrace( -1, Dbg, ("NtfsPingVolume -> %08lx\n", Results) );

    return Results;
}


VOID
NtfsVolumeCheckpointDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is dispatched every 5 seconds when disk structure is being
    modified.  It had the ExWorker thread to volume checkpoints.

Arguments:

    DeferredContext - Not Used

Return Value:

    None.

--*/

{
    TIMER_STATUS TimerStatus;
    ULONG VolumeCheckpointStatus;

    //
    //  Atomic reset of status indicating the timer is currently fired.  This
    //  synchronizes with NtfsSetDirtyBcb.  After NtfsSetDirtyBcb dirties
    //  a Bcb, it sees if it should enable this timer routine.
    //
    //  If the status indicates that a timer is active, it does nothing.  In this
    //  case it is guaranteed that when the timer fires, it causes a checkpoint (to
    //  force out the dirty Bcb data).
    //
    //  If there is no timer active, it enables it, thus queueing a checkpoint later.
    //
    //  If the timer routine actually fires between the dirtying of the Bcb and the
    //  testing of the status then a single extra checkpoint is generated.  This
    //  extra checkpoint is not considered harmful.
    //

    //
    //  Atomically reset status and get previous value
    //

    TimerStatus = InterlockedExchange( (PLONG)&NtfsData.TimerStatus, TIMER_NOT_SET );

    //
    //  We have only one instance of the work queue item.  It can only be
    //  queued once.  In a slow system, this checkpoint item may not be processed
    //  by the time this timer routine fires again.
    //

    VolumeCheckpointStatus = InterlockedExchange( &NtfsData.VolumeCheckpointStatus,
                                                  CHECKPOINT_POSTED | CHECKPOINT_PENDING );

    if (!FlagOn( VolumeCheckpointStatus, CHECKPOINT_POSTED )) {

        ASSERT( NtfsData.VolumeCheckpointItem.List.Flink == NULL );
        ExQueueWorkItem( &NtfsData.VolumeCheckpointItem, CriticalWorkQueue );
    }

    return;

    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );
    UNREFERENCED_PARAMETER( DeferredContext );
    UNREFERENCED_PARAMETER( Dpc );
}


VOID
NtfsCheckpointAllVolumes (
    PVOID Parameter
    )

/*++

Routine Description:

    This routine searches all of the vcbs for Ntfs and tries to clean
    them.  If the vcb is good and dirty but not almost clean then
    we set it almost clean.  If the Vcb is good and dirty and almost clean
    then we clean it.

Arguments:

    Parameter - Not Used.

Return Value:

    None.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;

    PLIST_ENTRY Links;
    PVCB Vcb;

    BOOLEAN AcquiredGlobal = FALSE;
    BOOLEAN StartTimer = FALSE;

    TIMER_STATUS TimerStatus;
    ULONG VolumeCheckpointStatus;

    PAGED_CODE();

    //
    //  Note that an exception like log file terminates the Vcb scan until the next
    //  interval.  It would be possible to restructure this routine to work on the other
    //  volumes first, however for deadlock prevention it is also nice to free up this
    //  thread to handle the checkpoint.
    //

    try {

        //
        //  Clear the flag that indicates someone is waiting for a checkpoint.  That way
        //  we can tell if the checkpoint timer fires while we are checkpointing.
        //

        InterlockedExchange( &NtfsData.VolumeCheckpointStatus, CHECKPOINT_POSTED );

        //
        //  Create an IrpContext and make sure it doesn't go away until we are ready.
        //

        NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

        //
        //  Make sure we don't get any pop-ups
        //

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
        ASSERT( ThreadTopLevelContext == &TopLevelContext );

        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );


        NtfsAcquireSharedGlobal( IrpContext, TRUE );
        AcquiredGlobal = TRUE;

        for (Links = NtfsData.VcbQueue.Flink;
             Links != &NtfsData.VcbQueue;
             Links = Links->Flink) {

            ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

            Vcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

            IrpContext->Vcb = Vcb;

             if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
                 (!NtfsIsVolumeReadOnly( Vcb ))) {

                NtfsCheckpointVolume( IrpContext, Vcb, FALSE, FALSE, TRUE, 0, Li0 );

                //
                //  Check to see whether this was not a clean checkpoint.
                //

                if (!FlagOn( Vcb->CheckpointFlags,
                             VCB_LAST_CHECKPOINT_CLEAN | VCB_LAST_CHECKPOINT_PSEUDO_CLEAN )) {

                    StartTimer = TRUE;
                }

                NtfsCommitCurrentTransaction( IrpContext );

#if DBG
                if (NtfsCheckQuota && Vcb->QuotaTableScb != NULL) {
                    NtfsPostRepairQuotaIndex( IrpContext, Vcb );
                }
#endif
            }

            //
            //  Clean up this IrpContext.
            //

            NtfsCleanupIrpContext( IrpContext, TRUE );
        }

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  Process the exception.  We know the IrpContext won't go away here.
        //

        NtfsProcessException( IrpContext, NULL, GetExceptionCode() );
    }

    if (AcquiredGlobal) {
        NtfsReleaseGlobal( IrpContext );
    }

    VolumeCheckpointStatus = InterlockedExchange( &NtfsData.VolumeCheckpointStatus, 0 );

    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );
    NtfsCleanupIrpContext( IrpContext, TRUE );
    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    //
    //  Synchronize with the checkpoint timer and other instances of this routine.
    //
    //  Perform an interlocked exchange to indicate that a timer is being set.
    //
    //  If the previous value indicates that no timer was set, then we
    //  enable the volume checkpoint timer.  This will guarantee that a checkpoint
    //  will occur to flush out the dirty Bcb data.
    //
    //  If the timer was set previously, then it is guaranteed that a checkpoint
    //  will occur without this routine having to reenable the timer.
    //
    //  If the timer and checkpoint occurred between the dirtying of the Bcb and
    //  the setting of the timer status, then we will be queueing a single extra
    //  checkpoint on a clean volume.  This is not considered harmful.
    //

    //
    //  Atomically set the timer status to indicate a timer is being set and
    //  retrieve the previous value.
    //

    if (StartTimer || FlagOn( VolumeCheckpointStatus, CHECKPOINT_PENDING )) {

        TimerStatus = InterlockedExchange( (PLONG)&NtfsData.TimerStatus, TIMER_SET );

        //
        //  If the timer is not currently set then we must start the checkpoint timer
        //  to make sure the above dirtying is flushed out.
        //

        if (TimerStatus == TIMER_NOT_SET) {

            LONGLONG NewTimerValue;

            //
            //  If the timer timed out because the checkpoint took so long then
            //  only wait two seconds.  Otherwise use our normal time of five seconds.
            //

            if (FlagOn( VolumeCheckpointStatus, CHECKPOINT_PENDING )) {

                NewTimerValue = -2*1000*1000*10;

            } else {

                NewTimerValue = -5*1000*1000*10;
            }

            KeSetTimer( &NtfsData.VolumeCheckpointTimer,
                        *(PLARGE_INTEGER) &NewTimerValue,
                        &NtfsData.VolumeCheckpointDpc );
        }
    }

    //
    //  Pulse the NtfsEncryptionPendingEvent so there's no chance of a waiter waiting forever.
    //

    KeSetEvent( &NtfsEncryptionPendingEvent, 0, FALSE );

    //
    //  And return to our caller
    //

    return;

    UNREFERENCED_PARAMETER( Parameter );
}


VOID
NtfsUsnTimeOutDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is dispatched every 5 minutes to look for Usn records waiting
    for a close to be issued.  It posts a work item to the ExWorker thread.

Arguments:

    DeferredContext - Not Used

Return Value:

    None.

--*/

{
    ASSERT( NtfsData.UsnTimeOutItem.List.Flink == NULL );
    ExQueueWorkItem( &NtfsData.UsnTimeOutItem, CriticalWorkQueue );

    return;

    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );
    UNREFERENCED_PARAMETER( DeferredContext );
    UNREFERENCED_PARAMETER( Dpc );
}


VOID
NtfsCheckUsnTimeOut (
    PVOID Parameter
    )

/*++

Routine Description:

    This is the worker routine which walks the queue of UsnRecords waiting for close records.  It either
    issues the close record and/or removes it from the queue of TimeOut records.  It also toggles the
    two TimeOut queues and restarts the timer for the next break.

Arguments:

Return Value:

    None.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;

    PFCB_USN_RECORD FcbUsnRecord;
    PLIST_ENTRY Links;
    PVCB Vcb;
    PFCB Fcb;

    BOOLEAN AcquiredGlobal = FALSE;
    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;

    PLIST_ENTRY Temp;

    PAGED_CODE();
    FsRtlEnterFileSystem();

    //
    //  Note that an exception like log file terminates the Vcb scan until the next
    //  interval.  It would be possible to restructure this routine to work on the other
    //  volumes first, however for deadlock prevention it is also nice to free up this
    //  thread to handle the checkpoint.
    //

    try {

        //
        //  Create an IrpContext and make sure it doesn't go away until we are ready.
        //

        NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

        //
        //  Make sure we don't get any pop-ups
        //

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
        ASSERT( ThreadTopLevelContext == &TopLevelContext );

        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );


        NtfsAcquireSharedGlobal( IrpContext, TRUE );
        AcquiredGlobal = TRUE;

        for (Links = NtfsData.VcbQueue.Flink;
             Links != &NtfsData.VcbQueue;
             Links = Links->Flink) {

            ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

            Vcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

            IrpContext->Vcb = Vcb;

            if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                AcquiredVcb = TRUE;

                if (Vcb->UsnJournal != NULL) {

                    do {

                        Fcb = NULL;

                        //
                        //  Synchronize with the Fcb table and Usn Journal so that we can
                        //  see if the next Fcb has to have a close record generated.
                        //

                        NtfsAcquireFcbTable( IrpContext, Vcb );
                        NtfsAcquireFsrtlHeader( Vcb->UsnJournal );

                        if (!IsListEmpty( Vcb->AgedTimeOutFiles )) {

                            FcbUsnRecord = (PFCB_USN_RECORD)CONTAINING_RECORD( Vcb->AgedTimeOutFiles->Flink,
                                                                               FCB_USN_RECORD,
                                                                               TimeOutLinks );

                            //
                            //  Since we have a UsnRecord and Fcb we want to reference the Fcb so
                            //  it won't go away.
                            //

                            Fcb = FcbUsnRecord->Fcb;
                            Fcb->ReferenceCount += 1;
                        }

                        NtfsReleaseFsrtlHeader( Vcb->UsnJournal );
                        NtfsReleaseFcbTable( IrpContext, Vcb );

                        //
                        //  Do we have to generate another close record?
                        //

                        if (Fcb != NULL) {

                            //
                            //  We must lock out other activity on this file since we are about
                            //  to reset the Usn reasons.
                            //

                            if (Fcb->PagingIoResource != NULL) {
                                NtfsAcquirePagingResourceExclusive( IrpContext, Fcb, TRUE );
                                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );

                            } else {

                                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );

                                //
                                //  If we now do not see a paging I/O resource we are golden,
                                //  othewise we can absolutely release and acquire the resources
                                //  safely in the right order, since a resource in the Fcb is
                                //  not going to go away.
                                //

                                if (Fcb->PagingIoResource != NULL) {

                                    NtfsReleaseFcb( IrpContext, Fcb );
                                    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                                    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                                }
                            }
                            AcquiredFcb = TRUE;


                            //
                            //  Skip over system files, files which now have a handle count, deleted
                            //  files or files which are no longer on the aged list.
                            //

                            if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE | FCB_STATE_FILE_DELETED ) &&
                                (Fcb->CleanupCount == 0) &&
                                (Fcb->FcbUsnRecord != NULL) &&
                                (Fcb->FcbUsnRecord->TimeOutLinks.Flink != NULL)) {

                                //
                                //  Post the close to our IrpContext.
                                //

                                NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

                                //
                                //  If we did not actually post a change, something is wrong,
                                //  because when a close change is written, the Fcb is removed from
                                //  the list.
                                //

                                ASSERT( IrpContext->Usn.CurrentUsnFcb != NULL );

                                //
                                //  Now generate the close record and checkpoint the transaction.
                                //

                                NtfsWriteUsnJournalChanges( IrpContext );
                                NtfsCheckpointCurrentTransaction( IrpContext );

                            //
                            //  Remove this entry from the time out list if still present.
                            //

                            } else if ((Fcb->FcbUsnRecord != NULL) &&
                                       (Fcb->FcbUsnRecord->TimeOutLinks.Flink != NULL)) {

                                NtfsAcquireFsrtlHeader( Vcb->UsnJournal );
                                RemoveEntryList( &Fcb->FcbUsnRecord->TimeOutLinks );
                                Fcb->FcbUsnRecord->TimeOutLinks.Flink = NULL;
                                NtfsReleaseFsrtlHeader( Vcb->UsnJournal );
                            }

                            //
                            //  Now we will dereference the Fcb.
                            //

                            NtfsAcquireFcbTable( IrpContext, Vcb );
                            Fcb->ReferenceCount -= 1;

                            //
                            //  We may be required to delete this guy.  This frees the Fcb Table.
                            //

                            if (IsListEmpty( &Fcb->ScbQueue ) && (Fcb->ReferenceCount == 0) && (Fcb->CloseCount == 0)) {


                                BOOLEAN AcquiredFcbTable = TRUE;

                                NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

                                ASSERT( !AcquiredFcbTable );

                            //
                            //  Otherwise free the table and Fcb resources.
                            //

                            } else {

                                NtfsReleaseFcbTable( IrpContext, Vcb );

                                //
                                //  Release in inverse order because only main holds down
                                //  the fcb
                                //

                                if (Fcb->PagingIoResource != NULL) {

                                    NtfsReleasePagingResource( IrpContext, Fcb );
                                }
                                NtfsReleaseFcb( IrpContext, Fcb );
                            }

                            AcquiredFcb = FALSE;
                        }

                    } while (Fcb != NULL);

                    //
                    //  Now swap the aged lists.
                    //

                    ASSERT( IsListEmpty( Vcb->AgedTimeOutFiles ));

                    NtfsLockFcb( IrpContext, Vcb->UsnJournal->Fcb );
                    Temp = Vcb->AgedTimeOutFiles;
                    Vcb->AgedTimeOutFiles = Vcb->CurrentTimeOutFiles;
                    Vcb->CurrentTimeOutFiles = Temp;
                    NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );
                }

                //
                //  Now we can drop the Vcb before looping back.
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                AcquiredVcb = FALSE;

                //
                //  Clean up this IrpContext.
                //

                NtfsCleanupIrpContext( IrpContext, TRUE );
            }
        }

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        if (AcquiredFcb) {

            NtfsAcquireFcbTable( IrpContext, Vcb );
            Fcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            //
            //  Only main protects the fcb from being deleted so release in inverse order
            //

            if (Fcb->PagingIoResource != NULL) {
                NtfsReleasePagingResource( IrpContext, Fcb );
            }

            NtfsReleaseFcb( IrpContext, Fcb );
        }

        AcquiredFcb = FALSE;

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredVcb = FALSE;
        }

        //
        //  Process the exception.  We know the IrpContext won't go away here.
        //

        NtfsProcessException( IrpContext, NULL, GetExceptionCode() );
    }

    if (AcquiredFcb) {

        //
        //  Release the paging resource first before the corresponding Fcb
        //  otherwise someone can free up or reuse both before we actually
        //  free the paging resource
        //

        if (Fcb->PagingIoResource != NULL) {
            NtfsReleasePagingResource( IrpContext, Fcb );
        }
        NtfsReleaseFcb( IrpContext, Fcb );
    }

    if (AcquiredVcb) {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    if (AcquiredGlobal) {

        NtfsReleaseGlobal( IrpContext );
    }

    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );
    NtfsCleanupIrpContext( IrpContext, TRUE );
    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

    //
    //  Now start the timer again.
    //

    {
        LONGLONG FiveMinutesFromNow = -5*1000*1000*10;

        FiveMinutesFromNow *= 60;

        KeSetTimer( &NtfsData.UsnTimeOutTimer,
                    *(PLARGE_INTEGER)&FiveMinutesFromNow,
                    &NtfsData.UsnTimeOutDpc );
    }

    FsRtlExitFileSystem();
    return;

    UNREFERENCED_PARAMETER( Parameter );
}


NTSTATUS
NtfsDeviceIoControlAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoCtl,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine is used to perform an IoCtl when we may be at the APC level
    and calling NtfsDeviceIoControl could be unsafe.

Arguments:

    DeviceObject - Supplies the device object to which to send the ioctl.

    IoCtl - Supplies the I/O control code.

    Buffer - Points to a buffer for any extra input/output for the given ioctl.

    BufferLength - The size, in bytes, of the above buffer.

Return Value:

    Status.

--*/

{
    KEVENT Event;
    PIRP Irp;
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Initialize the event we're going to use
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Build the irp for the operation and also set the overrride flag
    //
    //  Note that we may be at APC level, so do this asyncrhonously and
    //  use an event for synchronization normal request completion
    //  cannot occur at APC level.
    //
    //  We use IRP_MJ_FLUSH_BUFFERS since it (ironically) doesn't require
    //  a buffer.
    //

    Irp = IoBuildAsynchronousFsdRequest( IRP_MJ_FLUSH_BUFFERS,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         NULL );

    if ( Irp == NULL ) {

        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    IrpSp = IoGetNextIrpStackLocation( Irp );
    SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    IrpSp->Parameters.DeviceIoControl.IoControlCode = IoCtl;
    Irp->AssociatedIrp.SystemBuffer = Buffer;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = BufferLength;

    //
    //  Reset the major code to the correct value.
    //

    IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    //
    //  Set up the completion routine.
    //

    IoSetCompletionRoutine( Irp,
                            NtfsVerifyReadCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Call the device to do the io and wait for it to finish.
    //

    (VOID)IoCallDriver( DeviceObject, Irp );
    (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );

    //
    //  Grab the Status.
    //

    Status = Irp->IoStatus.Status;

    IoFreeIrp( Irp );

    //
    //  And return to our caller.
    //

    return Status;
}


//
//  Local Support routine
//

VOID
NtfsPerformVerifyDiskRead (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID Buffer,
    IN LONGLONG Offset,
    IN ULONG NumberOfBytesToRead
    )

/*++

Routine Description:

    This routine is used to read in a range of bytes from the disk.  It
    bypasses all of the caching and regular I/O logic, and builds and issues
    the requests itself.  It does this operation overriding the verify
    volume flag in the device object.

Arguments:

    Vcb - Supplies the Vcb denoting the device for this operation

    Buffer - Supplies the buffer that will recieve the results of this operation

    Offset - Supplies the offset of where to start reading

    NumberOfBytesToRead - Supplies the number of bytes to read, this must
        be in multiple of bytes units acceptable to the disk driver.

Return Value:

    None.

--*/

{
    KEVENT Event;
    PIRP Irp;
    NTSTATUS Status;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    //
    //  Initialize the event we're going to use
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Build the irp for the operation and also set the overrride flag
    //
    //  Note that we may be at APC level, so do this asyncrhonously and
    //  use an event for synchronization normal request completion
    //  cannot occur at APC level.
    //

    Irp = IoBuildAsynchronousFsdRequest( IRP_MJ_READ,
                                         Vcb->TargetDeviceObject,
                                         Buffer,
                                         NumberOfBytesToRead,
                                         (PLARGE_INTEGER)&Offset,
                                         NULL );

    if ( Irp == NULL ) {

        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    //
    //  Set up the completion routine
    //

    IoSetCompletionRoutine( Irp,
                            NtfsVerifyReadCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Call the device to do the write and wait for it to finish.
    //

    try {

        (VOID)IoCallDriver( Vcb->TargetDeviceObject, Irp );
        (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );

        //
        //  Grab the Status.
        //

        Status = Irp->IoStatus.Status;

    } finally {

        //
        //  If there is an MDL (or MDLs) associated with this I/O
        //  request, Free it (them) here.  This is accomplished by
        //  walking the MDL list hanging off of the IRP and deallocating
        //  each MDL encountered.
        //

        while (Irp->MdlAddress != NULL) {

            PMDL NextMdl;

            NextMdl = Irp->MdlAddress->Next;

            MmUnlockPages( Irp->MdlAddress );

            IoFreeMdl( Irp->MdlAddress );

            Irp->MdlAddress = NextMdl;
        }

        IoFreeIrp( Irp );
    }

    //
    //  If it doesn't succeed then raise the error
    //

    if (!NT_SUCCESS(Status)) {

        NtfsNormalizeAndRaiseStatus( IrpContext,
                                     Status,
                                     STATUS_UNEXPECTED_IO_ERROR );
    }

    //
    //  And return to our caller
    //

    return;
}


NTSTATUS
NtfsIoCallSelf (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN UCHAR MajorFunction
    )

/*++

Routine Description:

    This routine is used to call ourselves for a simple function.  Note that
    if more use is found for this routine than the few current uses, its interface
    may be easily expanded.

Arguments:

    FileObject - FileObject for request.

    MajorFunction - function to be performed.

Return Value:

    Status code resulting from the driver call

--*/

{
    KEVENT Event;
    PIRP Irp;
    PDEVICE_OBJECT DeviceObject;
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    //
    //  Initialize the event we're going to use
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    DeviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    //  Build the irp for the operation and also set the overrride flag
    //
    //  Note that we may be at APC level, so do this asyncrhonously and
    //  use an event for synchronization normal request completion
    //  cannot occur at APC level.
    //


    Irp = IoBuildAsynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         NULL );

    if (Irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Fill in a few remaining items
    //

    Irp->Tail.Overlay.OriginalFileObject = FileObject;

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = MajorFunction;
    IrpSp->FileObject = FileObject;

    //
    //  Set up the completion routine
    //

    IoSetCompletionRoutine( Irp,
                            NtfsVerifyReadCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    NtfsPurgeFileRecordCache( IrpContext );
    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );

    //
    //  Call the device to do the write and wait for it to finish.
    //

    try {

        (VOID)IoCallDriver( DeviceObject, Irp );
        (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );

        //
        //  Grab the Status.
        //

        Status = Irp->IoStatus.Status;

    } finally {

        //
        //  There should never be an MDL here.
        //

        ASSERT(Irp->MdlAddress == NULL);

        IoFreeIrp( Irp );

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );
    }

    //
    //  If it doesn't succeed then raise the error
    //
    //  And return to our caller
    //

    return Status;
}


BOOLEAN
NtfsLogEventInternal (
    IN PVCB Vcb,
    IN UCHAR MajorFunction,
    IN ULONG TransactionId,
    IN PUNICODE_STRING String OPTIONAL,
    IN PQUOTA_USER_DATA UserData OPTIONAL,
    IN NTSTATUS LogCode,
    IN NTSTATUS FinalStatus
    )

/*++

Routine Description:

    Create an eventlogentry. This version is given all the strings and user data
    it needs.

Arguments:

    Vcb - the vcb
    MajorFunction - irp majorfunction when log was generated

    TransactionId -  transaction id for transaction if any

    String - Any string needed in the message

    UserData - Any userdata

    LogCode - IO_ type code (NOT an NTSTATUS)  see ntiologc.h

    FinalStatus - NTSTATUS of error


Return Value:

    TRUE if successful

--*/
{
    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    PFILE_QUOTA_INFORMATION FileQuotaInfo;
    ULONG SidLength;
    ULONG DumpDataLength = 0;
    ULONG StringLength = 0;
    ULONG LogSize = sizeof( IO_ERROR_LOG_PACKET );
    PWCHAR RecordString;

    if (Vcb == NULL) {
        return FALSE;
    }

    if (ARGUMENT_PRESENT( String )) {
        StringLength = String->Length + sizeof(WCHAR);
        LogSize += StringLength;
    }

    if (ARGUMENT_PRESENT( UserData )) {

        //
        //  Calculate the required length of the Sid.
        //

        SidLength = RtlLengthSid( &UserData->QuotaSid );
        DumpDataLength = SidLength +
                         FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid );

        //
        //  The error packet already has 1 ulong for dump data in it
        //

        LogSize += DumpDataLength - sizeof( ULONG );

    }

    if (LogSize > ERROR_LOG_MAXIMUM_SIZE) {
        LogSize = ERROR_LOG_MAXIMUM_SIZE;
    }

    //
    //  We don't deal with the user dump data not fitting in the record
    //

    ASSERT( DumpDataLength - sizeof( ULONG ) + sizeof( IO_ERROR_LOG_PACKET ) <= LogSize );

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET)
                    IoAllocateErrorLogEntry( (CONTAINING_RECORD( Vcb, VOLUME_DEVICE_OBJECT, Vcb ))->DeviceObject.DriverObject,
                                             (UCHAR) (LogSize) );

    if (ErrorLogEntry == NULL) {
        return FALSE;
    }

    ErrorLogEntry->EventCategory = ELF_CATEGORY_DISK;
    ErrorLogEntry->ErrorCode = LogCode;
    ErrorLogEntry->FinalStatus = FinalStatus;

    ErrorLogEntry->SequenceNumber = TransactionId;
    ErrorLogEntry->MajorFunctionCode = MajorFunction;
    ErrorLogEntry->RetryCount = 0;
    ErrorLogEntry->DumpDataSize = (USHORT) DumpDataLength;

    //
    //  The label string at the end of the error log entry.
    //

    ErrorLogEntry->NumberOfStrings = 1;
    ErrorLogEntry->StringOffset = (USHORT) (sizeof( IO_ERROR_LOG_PACKET ) + DumpDataLength - sizeof( ULONG ));
    RecordString = (PWCHAR) Add2Ptr( ErrorLogEntry, ErrorLogEntry->StringOffset );

    if (LogSize - ErrorLogEntry->StringOffset < StringLength) {
        RtlCopyMemory( RecordString,
                       String->Buffer,
                       LogSize - ErrorLogEntry->StringOffset - sizeof( WCHAR ) * 4 );
        RecordString += (LogSize - ErrorLogEntry->StringOffset - sizeof( WCHAR ) * 4) / sizeof(WCHAR);
        RtlCopyMemory( RecordString, L"...", sizeof( WCHAR ) * 4 );

    } else {
        RtlCopyMemory( RecordString,
                       String->Buffer,
                       String->Length );
        //
        //  Make sure the string is null terminated.
        //

        RecordString += String->Length / sizeof( WCHAR );
        *RecordString = L'\0';
    }

    if (ARGUMENT_PRESENT( UserData )) {

        FileQuotaInfo = (PFILE_QUOTA_INFORMATION) ErrorLogEntry->DumpData;

        FileQuotaInfo->NextEntryOffset = 0;
        FileQuotaInfo->SidLength = SidLength;
        FileQuotaInfo->ChangeTime.QuadPart = UserData->QuotaChangeTime;
        FileQuotaInfo->QuotaUsed.QuadPart = UserData->QuotaUsed;
        FileQuotaInfo->QuotaThreshold.QuadPart = UserData->QuotaThreshold;
        FileQuotaInfo->QuotaLimit.QuadPart = UserData->QuotaLimit;
        RtlCopyMemory( &FileQuotaInfo->Sid,
                       &UserData->QuotaSid,
                       SidLength );
    }

    IoWriteErrorLogEntry( ErrorLogEntry );
    return TRUE;
}



BOOLEAN
NtfsLogEvent (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_USER_DATA UserData OPTIONAL,
    IN NTSTATUS LogCode,
    IN NTSTATUS FinalStatus
    )

/*++

Routine Description:

    This routine logs an io event. If UserData is supplied then the
    data logged is a FILE_QUOTA_INFORMATION structure

Arguments:

    UserData - Supplies the optional quota user data index entry.

    LogCode - Supplies the Io Log code to use for the ErrorCode field.

    FinalStauts - Supplies the final status of the operation.

Return Value:

    True - if the event was successfully logged.

--*/

{
    PEVENTLOG_ERROR_PACKET Packet;
    ULONG OldCount;
    UNICODE_STRING Label;

    if (IrpContext->Vcb == NULL) {
        return FALSE;
    }

    OldCount = InterlockedCompareExchange( &(NtfsData.VolumeNameLookupsInProgress), 1, 0 );
    if (OldCount == 0) {

        Packet = NtfsAllocatePoolWithTagNoRaise( PagedPool, sizeof( EVENTLOG_ERROR_PACKET ), MODULE_POOL_TAG );
        if (Packet) {

            RtlZeroMemory( Packet, sizeof( EVENTLOG_ERROR_PACKET ) );

            //
            //  Copy UserData if necc. since the resolution is asynch
            //

            if (ARGUMENT_PRESENT( UserData )) {

                ULONG SidLength;
                ULONG UserDataLength;

                SidLength = RtlLengthSid( &UserData->QuotaSid );
                UserDataLength = SidLength +
                                SIZEOF_QUOTA_USER_DATA;

                Packet->UserData = NtfsAllocatePoolWithTagNoRaise( PagedPool, UserDataLength, MODULE_POOL_TAG );
                if (!Packet->UserData) {
                    NtfsFreePool( Packet );
                    return NtfsLogEventInternal( IrpContext->Vcb, IrpContext->MajorFunction, IrpContext->TransactionId, NULL, UserData, LogCode, FinalStatus );
                }
                RtlCopyMemory( Packet->UserData, UserData, UserDataLength );
            }

            Packet->FinalStatus = FinalStatus;
            Packet->LogCode = LogCode;
            Packet->MajorFunction = IrpContext->MajorFunction;
            Packet->TransactionId = IrpContext->TransactionId;
            Packet->Vcb = IrpContext->Vcb;

            NtfsPostSpecial( IrpContext, IrpContext->Vcb, NtfsResolveVolumeAndLogEventSpecial, Packet );
            return TRUE;

        } else {

            Label.Length = Label.MaximumLength = IrpContext->Vcb->Vpb->VolumeLabelLength;
            Label.Buffer = &(IrpContext->Vcb->Vpb->VolumeLabel[0]);
            return NtfsLogEventInternal( IrpContext->Vcb, IrpContext->MajorFunction, IrpContext->TransactionId, &Label, NULL, LogCode, FinalStatus );
        }

    } else {

        Label.Length = Label.MaximumLength = IrpContext->Vcb->Vpb->VolumeLabelLength;
        Label.Buffer = &(IrpContext->Vcb->Vpb->VolumeLabel[0]);
        return NtfsLogEventInternal( IrpContext->Vcb, IrpContext->MajorFunction, IrpContext->TransactionId, &Label, NULL, LogCode, FinalStatus );
    }
}



VOID
NtfsResolveVolumeAndLogEventSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    Resolve Vcb's win32 devicename and raise an io hard error. This is done in
    a separate thread in order to have enough stack to re-enter the filesys if necc.
    Also because we may reenter. Starting from here means we own no resources other than
    having inc'ed the close count on the underlying vcb to prevent its going away

Arguments:

    IrpContext -  IrpContext containing vcb we're interested in
    Context    -  String to append to volume win32 name


Return Value:

    none

--*/
{
    PEVENTLOG_ERROR_PACKET EventCtx = 0;
    UNICODE_STRING VolumeName;
    NTSTATUS Status;
    WCHAR *NewBuffer = NULL;
    ULONG DumpDataLength = 0;
    ULONG LabelLength = 0;
    BOOLEAN AllocatedVolName = FALSE;


    UNREFERENCED_PARAMETER( IrpContext );

    ASSERT( Context != NULL );

    EventCtx = (PEVENTLOG_ERROR_PACKET) Context;

    VolumeName.Length = 0;
    VolumeName.Buffer = NULL;

    try {

        Status = IoVolumeDeviceToDosName( EventCtx->Vcb->TargetDeviceObject, &VolumeName );
        ASSERT( (STATUS_SUCCESS == Status) || (VolumeName.Length == 0) );

        //
        //  We're stuck using the label
        //

        if (VolumeName.Length == 0) {
            VolumeName.Length = EventCtx->Vcb->Vpb->VolumeLabelLength;
            VolumeName.Buffer = &(EventCtx->Vcb->Vpb->VolumeLabel[0]);
        } else if (STATUS_SUCCESS == Status) {
            AllocatedVolName = TRUE;
        }

        //
        //  Ignore status from LogEventInternal at this point if we fail
        //

        NtfsLogEventInternal( EventCtx->Vcb, EventCtx->MajorFunction, EventCtx->TransactionId, &VolumeName, EventCtx->UserData, EventCtx->LogCode, EventCtx->FinalStatus );

    } finally {

        //
        //  Indicate we're done and other lookups can occur
        //

        InterlockedDecrement( &(NtfsData.VolumeNameLookupsInProgress) );

        if (EventCtx) {
            if (EventCtx->UserData) {
                NtfsFreePool( EventCtx->UserData );
            }
            NtfsFreePool( EventCtx );
        }

        if (AllocatedVolName) {
            NtfsFreePool( VolumeName.Buffer );
        }
    }
}



VOID
NtfsPostVcbIsCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status OPTIONAL,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to mark the volume dirty and possibly raise a hard error.

Arguments:

    Status - If not zero, then this is the error code for the popup.

    FileReference - If specified, then this is the file reference for the corrupt file.

    Fcb - If specified, then this is the Fcb for the corrupt file.

Return Value:

    None

--*/

{
    PVCB Vcb = IrpContext->Vcb;

    if (Vcb != NULL) {

        NtfsMarkVolumeDirty( IrpContext, Vcb );

        //
        //  This would be the appropriate place to raise a hard error popup,
        //  ala the code in FastFat.  We should do it after marking the volume
        //  dirty so that if anything goes wrong with the popup, the volume is
        //  already marked anyway.
        //

        if ((Status != 0) &&
            !NtfsSuppressPopup &&
            ((IrpContext->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL) ||
             (IrpContext->MinorFunction != IRP_MN_MOUNT_VOLUME))) {

            NtfsRaiseInformationHardError( IrpContext,
                                           Status,
                                           FileReference,
                                           Fcb );
        }
    }

    return;
}


VOID
NtfsMarkVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine may be called any time the Mft is open to mark the volume
    dirty.

Arguments:

    Vcb - Vcb for volume to mark dirty

    UpdateWithinTransaction - Use TRUE if it is safe to log this operation.

Return Value:

    None

--*/

{
    PAGED_CODE();

#if ((DBG || defined( NTFS_FREE_ASSERTS )) && !defined( LFS_CLUSTER_CHECK ))
    KdPrint(("NTFS: Marking volume dirty, Vcb: %08lx\n", Vcb));
    if (NtfsBreakOnCorrupt) {
        KdPrint(("NTFS: Marking volume dirty\n", 0));
        DbgBreakPoint();
    }
#endif

    //
    //  Return if the volume is already marked dirty.  This also prevents
    //  endless recursion if the volume file itself is corrupt.
    //  Noop if the volume was mounted read only.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY ) ||
        (FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY ))) {

        return;
    }

    SetFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY );

    NtfsSetVolumeInfoFlagState( IrpContext,
                                Vcb,
                                VOLUME_DIRTY,
                                TRUE,
                                FALSE );

    //
    //  If this is chkdsk marking the volume dirty, let's not scare
    //  the user by putting a 'volume corrupt' message in the log.
    //  If an exception has occured, we want to log the event regardless.
    //

    if ((IrpContext->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL) ||
        (IrpContext->MinorFunction != IRP_MN_USER_FS_REQUEST) ||
        (IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->Parameters.FileSystemControl.FsControlCode
                                   != FSCTL_MARK_VOLUME_DIRTY) ||
        (IrpContext->ExceptionStatus != 0)) {

        NtfsLogEvent( IrpContext,
                      NULL,
                      IO_FILE_SYSTEM_CORRUPT_WITH_NAME,
                      STATUS_DISK_CORRUPT_ERROR );
    }
}


VOID
NtfsSetVolumeInfoFlagState (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FlagsToSet,
    IN BOOLEAN NewState,
    IN BOOLEAN UpdateWithinTransaction
    )

/*++

Routine Description:

    This routine sets or clears one or more bits in the given vcb's
    volume information.

Arguments:

    Vcb - Vcb for volume.

    FlagsToSet - The bit(s) to set or clear.

    NewState - Use TRUE to set the given bit(s), or FALSE to clear them.

    UpdateWithinTransaction - Use TRUE if this flag change should be done
                              inside a transaction.

Return Value:

    None

--*/

{
    LONGLONG Offset;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PVOLUME_INFORMATION VolumeInformation;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ULONG RecordOffset;
    ULONG AttributeOffset;
    BOOLEAN CleanupAttributeContext = TRUE;
    ULONG VolumeFlags;

    //
    //  If we don't have the VolumeDasdScb open yet, we can't do anything,
    //  so we need to exit gracefully now.
    //

    if ((Vcb == NULL) ||
        (Vcb->VolumeDasdScb == NULL)) {

        ASSERTMSG( "Attempting to set volume info flag state for a non-mounted volume", FALSE );
        return;
    }

    NtfsInitializeAttributeContext( &AttributeContext );

    try {

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Vcb->VolumeDasdScb->Fcb,
                                       &Vcb->VolumeDasdScb->Fcb->FileReference,
                                       $VOLUME_INFORMATION,
                                       &AttributeContext )) {

            VolumeInformation = (PVOLUME_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

            NtfsPinMappedAttribute( IrpContext, Vcb, &AttributeContext );

            //
            //  Extract the relevant pointers and calculate offsets.
            //

            FileRecord = NtfsContainingFileRecord( &AttributeContext );
            Attribute = NtfsFoundAttribute( &AttributeContext );
            Offset = PtrOffset( VolumeInformation, &VolumeInformation->VolumeFlags );
            RecordOffset = PtrOffset( FileRecord, Attribute );
            AttributeOffset = Attribute->Form.Resident.ValueOffset + (ULONG)Offset;

            VolumeFlags = VolumeInformation->VolumeFlags;

            if (NewState) {

                SetFlag( VolumeFlags, FlagsToSet );

            } else {

                ClearFlag( VolumeFlags, FlagsToSet );
            }

            if (UpdateWithinTransaction) {

                //
                //  Log the change while we still have the old data.
                //

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NtfsFoundBcb( &AttributeContext ),
                              UpdateResidentValue,
                              &VolumeFlags,
                              sizeof( VolumeFlags ),
                              UpdateResidentValue,
                              Add2Ptr(Attribute, Attribute->Form.Resident.ValueOffset + (ULONG)Offset),
                              sizeof( VolumeInformation->VolumeFlags),
                              NtfsMftOffset(&AttributeContext),
                              RecordOffset,
                              AttributeOffset,
                              Vcb->BytesPerFileRecordSegment );
            }

            //
            //  Now update this data by calling the same routine as restart.
            //

            NtfsRestartChangeValue( IrpContext,
                                    FileRecord,
                                    RecordOffset,
                                    AttributeOffset,
                                    &VolumeFlags,
                                    sizeof( VolumeFlags ),
                                    FALSE );

            //
            //  If this is not a transaction then mark the page dirty and flush
            //  this to disk.
            //

            if (!UpdateWithinTransaction) {

                LONGLONG MftOffset = NtfsMftOffset( &AttributeContext );

                CcSetDirtyPinnedData( NtfsFoundBcb( &AttributeContext ), NULL );
                NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
                CleanupAttributeContext = FALSE;
                CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                              (PLARGE_INTEGER) &MftOffset,
                              Vcb->BytesPerFileRecordSegment,
                              NULL );
            }
        }

    } finally {

        if (CleanupAttributeContext) {
            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }
    }

    return;
}



BOOLEAN
NtfsUpdateVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR DiskMajorVersion,
    IN UCHAR DiskMinorVersion
    )
/*++

Routine Description:

    This routine is called to update the volume information on disk. This includes
    version numbers, and last mounted version   Disk versions are only updated if they
    are greater than the on disk ones.

Arguments:

    Vcb - Vcb for volume.

    DiskMajorVersion - This is the Major Version number for the on disk format.

    DiskMinorVersion - This is the Minor Version number for the on disk format.

Return Value:

    TRUE if disk version was updated

--*/
{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PVOLUME_INFORMATION VolumeInformation;
    PATTRIBUTE_RECORD_HEADER Attribute;
    VOLUME_INFORMATION NewVolumeInformation;
    BOOLEAN UpdatedVersion = TRUE;
    ULONG VolInfoSize;

    PAGED_CODE();

    NtfsInitializeAttributeContext( &AttributeContext );

    try {

        //
        //  Lookup the volume information attribute.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Vcb->VolumeDasdScb->Fcb,
                                       &Vcb->VolumeDasdScb->Fcb->FileReference,
                                       $VOLUME_INFORMATION,
                                       &AttributeContext )) {

            Attribute = NtfsFoundAttribute(&AttributeContext);

            ASSERT( Attribute->FormCode == RESIDENT_FORM );

            VolumeInformation =
              (PVOLUME_INFORMATION)NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

            NtfsPinMappedAttribute( IrpContext, Vcb, &AttributeContext );

            RtlCopyMemory( &NewVolumeInformation, VolumeInformation, Attribute->Form.Resident.ValueLength );

            if (NewVolumeInformation.MajorVersion < DiskMajorVersion) {
                NewVolumeInformation.MajorVersion = DiskMajorVersion;
                NewVolumeInformation.MinorVersion = DiskMinorVersion;
                Vcb->MajorVersion = DiskMajorVersion;
                Vcb->MinorVersion = DiskMinorVersion;
            } else if (NewVolumeInformation.MinorVersion < DiskMinorVersion) {
                NewVolumeInformation.MinorVersion = DiskMinorVersion;
                Vcb->MinorVersion = DiskMinorVersion;
            } else {
                UpdatedVersion = FALSE;
            }

            //
            //  We can use the new volinfo for version 4 and greater
            //

            if (DiskMajorVersion > 3) {

#ifdef BENL_DBG
                KdPrint(( "NTFS: new volinfo for version 4+\n" ));
#endif

                NewVolumeInformation.LastMountedMajorVersion = DiskMajorVersion;
                NewVolumeInformation.LastMountedMinorVersion = DiskMinorVersion;

                VolInfoSize = sizeof( VOLUME_INFORMATION );
                UpdatedVersion = TRUE;
            } else {
                VolInfoSize = FIELD_OFFSET( VOLUME_INFORMATION, LastMountedMajorVersion );
            }

            if (UpdatedVersion) {
                NtfsChangeAttributeValue( IrpContext, Vcb->VolumeDasdScb->Fcb, 0, &NewVolumeInformation, VolInfoSize, TRUE, FALSE, FALSE, TRUE, &AttributeContext );
            }
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
    }

    return UpdatedVersion;
}


//
//  Local support routine
//

NTSTATUS
NtfsVerifyReadCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Set the event so that our call will wake up.
    //

    KeSetEvent( (PKEVENT)Contxt, 0, FALSE );

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    //
    //  If we change this return value then NtfsIoCallSelf needs to reference the
    //  file object.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\usnsup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    UsnSup.c

Abstract:

    This module implements the Usn Journal support routines for NtOfs

Author:

    Tom Miller      [TomM]          1-Dec-1996

Revision History:

--*/

#include "NtfsProc.h"
#include "lockorder.h"

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('UFtN')

#define GENERATE_CLOSE_RECORD_LIMIT     (200)

UNICODE_STRING $Max = CONSTANT_UNICODE_STRING( L"$Max" );

RTL_GENERIC_COMPARE_RESULTS
NtfsUsnTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

PVOID
NtfsUsnTableAllocate (
    IN PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    );

VOID
NtfsUsnTableFree (
    IN PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

VOID
NtfsCancelReadUsnJournal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NtfsCancelDeleteUsnJournal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsDeleteUsnWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

BOOLEAN
NtfsValidateUsnPage (
    IN PUSN_RECORD UsnRecord,
    IN USN PageUsn,
    IN USN *UserStartUsn OPTIONAL,
    IN LONGLONG UsnFileSize,
    OUT PBOOLEAN ValidUserStartUsn OPTIONAL,
    OUT USN *NextUsn
    );

//
//  VOID
//  NtfsAdvanceUsnJournal (
//  PVCB Vcb,
//  PUSN_JOURNAL_INSTANCE UsnJournalInstance,
//  LONGLONG OldSize,
//  PBOOLEAN NewMax
//  );
//

#define NtfsAdvanceUsnJournal(V,I,SZ,M)   {                                 \
    LONG _Templong;                                                         \
    _Templong = USN_PAGE_BOUNDARY;                                          \
    if (USN_PAGE_BOUNDARY < (V)->BytesPerCluster) {                         \
        _Templong = (LONG)(V)->BytesPerCluster;                             \
    }                                                                       \
    (I)->LowestValidUsn = BlockAlign( SZ, _Templong );                      \
    KeQuerySystemTime( (PLARGE_INTEGER) &(I)->JournalId );                  \
    *(M) = TRUE;                                                            \
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsDeleteUsnJournal)
#pragma alloc_text(PAGE, NtfsDeleteUsnSpecial)
#pragma alloc_text(PAGE, NtfsDeleteUsnWorker)
#pragma alloc_text(PAGE, NtfsPostUsnChange)
#pragma alloc_text(PAGE, NtfsQueryUsnJournal)
#pragma alloc_text(PAGE, NtfsReadUsnJournal)
#pragma alloc_text(PAGE, NtfsSetupUsnJournal)
#pragma alloc_text(PAGE, NtfsTrimUsnJournal)
#pragma alloc_text(PAGE, NtfsUsnTableCompare)
#pragma alloc_text(PAGE, NtfsUsnTableAllocate)
#pragma alloc_text(PAGE, NtfsUsnTableFree)
#pragma alloc_text(PAGE, NtfsValidateUsnPage)
#pragma alloc_text(PAGE, NtfsWriteUsnJournalChanges)
#endif


NTSTATUS
NtfsReadUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN BOOLEAN ProbeInput
    )

/*++

Routine Description:

    This routine reads records filtered from the Usn journal.

Arguments:

    IrpContext - Only optional if we are being called to cancel an async
                 request.

    Irp - request being serviced

    ProbeInput - Indicates if we should probe the user input buffer.  We also
        call this routine internally and don't want to probe in that case.

Return Value:

    NTSTATUS - The return status for the operation.
    STATUS_PENDING - if asynch Irp queued for later completion.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUSN_RECORD UsnRecord;
    USN_RECORD UNALIGNED *OutputUsnRecord;
    PVOID UserBuffer;
    LONGLONG ViewLength;
    ULONG RemainingUserBuffer, BytesUsed;
    MAP_HANDLE MapHandle;

    READ_USN_JOURNAL_DATA CapturedData;
    PSCB UsnJournal;
    ULONG JournalAcquired = FALSE;
    ULONG AccessingUserBuffer = FALSE;
    ULONG DecrementReferenceCount = FALSE;
    ULONG VcbAcquired = FALSE;
    ULONG Wait;
    ULONG OriginalWait;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS)) {

        ASSERT( ProbeInput );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  This request must be able to wait for resources.  Set WAIT to TRUE.
    //

    Wait = TRUE;
    if (ProbeInput && !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Wait = FALSE;
    }

    NtOfsInitializeMapHandle( &MapHandle );
    UserBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

    try {

        //
        //  We always want to be able to wait for resources in this routine but need to be able
        //  to restore the original wait value in the Irp.  After this the original wait will
        //  have only the wait flag set and then only if it originally wasn't set.  In clean
        //  up we just need to clear the irp context flags using this mask.
        //

        OriginalWait = (IrpContext->State ^ IRP_CONTEXT_STATE_WAIT) & IRP_CONTEXT_STATE_WAIT;

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

        //
        //  Detect if we fail while accessing the input buffer.
        //

        try {

            AccessingUserBuffer = TRUE;

            //
            //  Probe the input buffer if not in kernel mode and we haven't already done so.
            //

            if (Irp->RequestorMode != KernelMode) {

                if (ProbeInput) {

                    ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                  IrpSp->Parameters.FileSystemControl.InputBufferLength,
                                  sizeof( ULONG ));
                }

                //
                //  Probe the output buffer if we haven't locked it down yet.
                //  Capture the JournalData from the unsafe user buffer.
                //

                if (Irp->MdlAddress == NULL) {

                    ProbeForWrite( UserBuffer, IrpSp->Parameters.FileSystemControl.OutputBufferLength, sizeof( ULONG ));
                }
            } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer, ULONG ) ||
                       ((Irp->MdlAddress == NULL) && !IsTypeAligned( UserBuffer, ULONG ))) { 

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            //
            //  Acquire the Vcb to serialize journal operations with delete journal and dismount.
            //  Only do this if are being called directly by the user.
            //

            if (ProbeInput) {

                VcbAcquired = NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

                if (!FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                    UsnJournal = NULL;

                } else {

                    UsnJournal = Vcb->UsnJournal;
                }

            } else {

                UsnJournal = Vcb->UsnJournal;
            }

            //
            //  Make sure no one is deleting the journal.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

                Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
                leave;
            }

            //
            //  Also check that the version is still active.
            //

            if (UsnJournal == NULL) {

                Status = STATUS_JOURNAL_NOT_ACTIVE;
                leave;
            }

            //
            //  Check that the buffer sizes meet our minimum needs.
            //

            if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( READ_USN_JOURNAL_DATA )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;

            } else {

                RtlCopyMemory( &CapturedData,
                               IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                               sizeof( READ_USN_JOURNAL_DATA ));

                //
                //  Check that the user is querying with the correct journal ID.
                //

                if (CapturedData.UsnJournalID != Vcb->UsnJournalInstance.JournalId) {

                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }
            }

            //
            //  Check that the output buffer can hold at least one USN.
            //

            if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( USN )) {

                Status = STATUS_BUFFER_TOO_SMALL;
                leave;
            }

            AccessingUserBuffer = FALSE;

            //
            //  Set up for filling output records
            //

            RemainingUserBuffer = IrpSp->Parameters.FileSystemControl.OutputBufferLength - sizeof(USN);
            OutputUsnRecord = (PUSN_RECORD) Add2Ptr( UserBuffer, sizeof(USN) );
            BytesUsed = sizeof(USN);

            NtfsAcquireResourceShared( IrpContext, UsnJournal, TRUE );
            JournalAcquired = TRUE;

            if (VcbAcquired) {

                NtfsReleaseVcb( IrpContext, Vcb );
                VcbAcquired = FALSE;
            }

            //
            //  Verify the volume is mounted.
            //

            if (FlagOn( UsnJournal->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            //
            //  If 0 was specified as the Usn, then translate that to the first record
            //  in the Usn journal.
            //

            if (CapturedData.StartUsn == 0) {
                CapturedData.StartUsn = Vcb->FirstValidUsn;
            }

            //
            //  Loop here until he gets some data, if that is what the caller wants.
            //

            do {

                //
                //  Make sure he is within the stream.
                //

                if (CapturedData.StartUsn < Vcb->FirstValidUsn) {
                    CapturedData.StartUsn = Vcb->FirstValidUsn;
                    Status = STATUS_JOURNAL_ENTRY_DELETED;
                    break;
                }

                //
                //  Make sure he is within the stream.
                //

                if (CapturedData.StartUsn >= UsnJournal->Header.FileSize.QuadPart) {

                    //
                    //  If he wants to wait for data, then wait here.
                    //
                    //  If an asynchronous request has
                    //  met its wakeup condition, then this Irp will not be the same as the
                    //  Originating Irp, and we do not want to give him a second chance since
                    //  this could cause us to loop in NtOfsPostNewLength.  (Basically the only
                    //  case where this could happen anyway is if he gave us a bogus StartUsn
                    //  which is too high.)
                    //

                    if (CapturedData.BytesToWaitFor != 0) {

                        //
                        //  Make sure the journal doesn't get deleted while
                        //  this Irp is outstanding.
                        //

                        InterlockedIncrement( &UsnJournal->CloseCount );
                        DecrementReferenceCount = TRUE;

                        //
                        //  If the caller does not want to wait, then just queue his
                        //  Irp to be completed when sufficient bytes come in.  If we were
                        //  called for another Irp, then do the same, since we know that
                        //  was another async Irp.
                        //

                        if (!Wait || (Irp != IrpContext->OriginatingIrp)) {

                            //
                            //  Now set up our wait block, capturing the user's parameters.
                            //  Update the Irp to say where the input parameters are now.
                            //

                            Status = NtfsHoldIrpForNewLength( IrpContext,
                                                              UsnJournal,
                                                              Irp,
                                                              CapturedData.StartUsn + CapturedData.BytesToWaitFor,
                                                              NtfsCancelReadUsnJournal,
                                                              &CapturedData,
                                                              &IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                                              sizeof( READ_USN_JOURNAL_DATA ));

                            //
                            //  If pending then someone else will decrement the reference count.
                            //

                            if (Status == STATUS_PENDING) {

                                DecrementReferenceCount = FALSE;
                            }

                            leave;
                        }

                        //
                        //  We can safely release the resource.  Our reference on the Scb above
                        //  will keep it from being deleted.
                        //

                        NtfsReleaseResource( IrpContext, UsnJournal );
                        JournalAcquired = FALSE;

                        FsRtlExitFileSystem();

                        Status = NtOfsWaitForNewLength( UsnJournal,
                                                        CapturedData.StartUsn + CapturedData.BytesToWaitFor,
                                                        FALSE,
                                                        Irp,
                                                        NtfsCancelReadUsnJournal,
                                                        ((CapturedData.Timeout != 0) ?
                                                         (PLARGE_INTEGER) &CapturedData.Timeout :
                                                         NULL) );

                        FsRtlEnterFileSystem();

                        //
                        //  Get out in the error case.
                        //

                        if (Status != STATUS_SUCCESS) {

                            leave;
                        }

                        //
                        //  Acquire the resource to proceed with the request.
                        //

                        NtfsAcquireResourceShared( IrpContext, UsnJournal, TRUE );
                        JournalAcquired = TRUE;

                        //
                        //  Decrement our reference on the Scb.
                        //

                        InterlockedDecrement( &UsnJournal->CloseCount );
                        DecrementReferenceCount = FALSE;

                        //
                        //  The journal may have been deleted while we weren't holding
                        //  anything.
                        //

                        if (UsnJournal != UsnJournal->Vcb->UsnJournal) {

                            if (FlagOn( UsnJournal->Vcb->VcbState, VCB_STATE_USN_DELETE )) {
                                Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
                            } else {
                                Status = STATUS_JOURNAL_NOT_ACTIVE;
                            }
                            leave;
                        }

                        ASSERT( Status == STATUS_SUCCESS );

                        //
                        //  **** Get out if we are shutting down the volume.
                        //

                        //  if (ShuttingDown) {
                        //      Status = STATUS_TOO_LATE;
                        //      leave;
                        //  }

                    //
                    //  Otherwise, get out.  Note, we may have processed a number of records
                    //  that did not match his filter criteria, so we will return success, so
                    //  we can at least give him an updated Usn so we do not have to skip over
                    //  all those records again.
                    //

                    } else {

                        break;
                    }
                }

                //
                //  Loop through as many views as required to fill the output buffer.
                //

                while ((RemainingUserBuffer != 0) && (CapturedData.StartUsn < UsnJournal->Header.FileSize.QuadPart)) {

                    LONGLONG BiasedStartUsn;
                    BOOLEAN ValidUserStartUsn;
                    USN NextUsn;
                    ULONG RecordSize;

                    //
                    //  Calculate length to process in this view.
                    //

                    ViewLength = UsnJournal->Header.FileSize.QuadPart - CapturedData.StartUsn;
                    if (ViewLength > (VACB_MAPPING_GRANULARITY - (ULONG)(CapturedData.StartUsn & (VACB_MAPPING_GRANULARITY - 1)))) {
                        ViewLength = VACB_MAPPING_GRANULARITY - (ULONG)(CapturedData.StartUsn & (VACB_MAPPING_GRANULARITY - 1));
                    }

                    //
                    //  Map the view containing the desired Usn.
                    //

                    BiasedStartUsn = CapturedData.StartUsn - Vcb->UsnCacheBias;
                    NtOfsMapAttribute( IrpContext, UsnJournal, BiasedStartUsn, (ULONG)ViewLength, (PVOID *)&UsnRecord, &MapHandle );

                    //
                    //  For each page in the view we want to validate the page and return the records
                    //  within the page starting at the user's current usn.
                    //

                    do {

                        //
                        //  Validate the records on the entire page are valid.
                        //

                        if (!NtfsValidateUsnPage( (PUSN_RECORD) BlockAlignTruncate( ((ULONG_PTR) UsnRecord), USN_PAGE_SIZE ),
                                                  BlockAlignTruncate( CapturedData.StartUsn, USN_PAGE_SIZE ),
                                                  &CapturedData.StartUsn,
                                                  UsnJournal->Header.FileSize.QuadPart,
                                                  &ValidUserStartUsn,
                                                  &NextUsn )) {

                            //
                            //  Simply fail the request with bad data.
                            //

                            Status = STATUS_DATA_ERROR;
                            leave;
                        }

                        //
                        //  If the user gave us an incorrect Usn then fail the request.
                        //

                        if (!ValidUserStartUsn) {

                            Status = STATUS_INVALID_PARAMETER;
                            leave;
                        }

                        //
                        //  Now loop to process this page.  We know the Usn values which exist on the page and
                        //  there are no checks for valid data needed.
                        //

                        while (CapturedData.StartUsn < NextUsn) {

                            RecordSize = UsnRecord->RecordLength;

                            //
                            //  Only recognize version 2 records.
                            //

                            if (FlagOn( UsnRecord->Reason, CapturedData.ReasonMask ) &&
                                (!CapturedData.ReturnOnlyOnClose || FlagOn( UsnRecord->Reason, USN_REASON_CLOSE )) &&
                                (UsnRecord->MajorVersion == 2)) {

                                if (RecordSize > RemainingUserBuffer) {
                                    RemainingUserBuffer = 0;
                                    break;
                                }

                                //
                                //  Copy the data back to the unsafe user buffer.
                                //

                                AccessingUserBuffer = TRUE;

                                //
                                //  Copy directly if the version numbers match.
                                //

                                RtlCopyMemory( OutputUsnRecord, UsnRecord, RecordSize );

                                AccessingUserBuffer = FALSE;

                                RemainingUserBuffer -= RecordSize;
                                BytesUsed += RecordSize;
                                OutputUsnRecord = Add2Ptr( OutputUsnRecord, RecordSize );
                            }

                            CapturedData.StartUsn += RecordSize;
                            UsnRecord = Add2Ptr( UsnRecord, RecordSize );

                            //
                            //  The view length should already account for record size.
                            //

                            ASSERT( ViewLength >= RecordSize );
                            ViewLength -= RecordSize;
                        }

                        //
                        //  Break out if the users buffer is empty.
                        //

                        if (RemainingUserBuffer == 0) {

                            break;
                        }

                        //
                        //  We finished the current page.  Now move to the next page.
                        //  Figure out how many bytes remain on this page.
                        //  If the next offset is the start of the next page then make sure
                        //  to mask off the page size bits again.
                        //

                        RecordSize = BlockOffset( USN_PAGE_SIZE - BlockOffset( (ULONG) NextUsn, USN_PAGE_SIZE ),
                                                  USN_PAGE_SIZE );

                        if (RecordSize > ViewLength) {

                            RecordSize = (ULONG) ViewLength;
                        }

                        UsnRecord = Add2Ptr( UsnRecord, RecordSize );
                        CapturedData.StartUsn += RecordSize;
                        ViewLength -= RecordSize;

                    } while (ViewLength != 0);

                    NtOfsReleaseMap( IrpContext, &MapHandle );
                }

            } while ((RemainingUserBuffer != 0) && (BytesUsed == sizeof(USN)));

            Irp->IoStatus.Information = BytesUsed;

            //
            //  Set the returned Usn.  Move to the start of the next page if
            //  the next record won't fit on this page.
            //

            AccessingUserBuffer = TRUE;
            *(USN *)UserBuffer = CapturedData.StartUsn;
            AccessingUserBuffer = FALSE;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            //
            //  Restore the original wait state back into the IrpContext.
            //

            ClearFlag( IrpContext->State, OriginalWait );

            if (FsRtlIsNtstatusExpected( Status )) {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

            } else {

                ExRaiseStatus( AccessingUserBuffer ? STATUS_INVALID_USER_BUFFER : Status );
            }
        }

    } finally {

        NtOfsReleaseMap( IrpContext, &MapHandle );

        if (JournalAcquired) {
            NtfsReleaseResource( IrpContext, UsnJournal );
        }

        if (DecrementReferenceCount) {

            InterlockedDecrement( &UsnJournal->CloseCount );
        }

        if (VcbAcquired) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  Complete the request, unless we've marked this Irp as pending and we plan to complete
    //  it later.  If the Irp is not the originating Irp then it belongs to another request
    //  and we don't want to complete it.
    //

    //
    //  Restore the original wait flag back into the IrpContext.
    //

    ClearFlag( IrpContext->State, OriginalWait );

    ASSERT( (Status == STATUS_PENDING) || (Irp->CancelRoutine == NULL) );

    NtfsCompleteRequest( (Irp == IrpContext->OriginatingIrp) ? IrpContext : NULL,
                         (Status != STATUS_PENDING) ? Irp : NULL,
                         Status );

    return Status;
}


ULONG
NtfsPostUsnChange (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID ScbOrFcb,
    IN ULONG Reason
    )

/*++

Routine Description:

    This routine is called to post a set of changes to a file.  A change is
    only posted if at least one reason in the Reason mask is not already set
    in either the Fcb or the IrpContext or if we are changing the source info
    reasons in the Fcb.

Arguments:

    ScbOrFcb - Supplies the file for which a change is being posted.  If reason contains
               USN_REASON_DATA_xxx reasons, then it must be an Scb, because we transform
               the code for named streams and do other special handling.

    Reason - Supplies a mask of reasons for which a change is being posted.

Return Value:

    Nonzero if changes are actually posted from this or a previous call

--*/

{
    PLCB Lcb;
    PFCB_USN_RECORD FcbUsnRecord;
    BOOLEAN Found;
    PFCB Fcb;
    PSCB Scb = NULL;
    ULONG NewReasons;
    ULONG RemovedSourceInfo;
    PUSN_FCB ThisUsn;
    BOOLEAN LockedFcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;

    //
    //  Assume we got an Fcb.
    //

    Fcb = (PFCB)ScbOrFcb;

    ASSERT( !(Reason & (USN_REASON_DATA_OVERWRITE | USN_REASON_DATA_EXTEND | USN_REASON_DATA_TRUNCATION)) ||
            (NTFS_NTC_FCB != Fcb->NodeTypeCode) );

    //
    //  Switch if we got an Scb
    //

    if (Fcb->NodeTypeCode != NTFS_NTC_FCB) {

        ASSERT_SCB(Fcb);

        Scb = (PSCB)ScbOrFcb;
        Fcb = Scb->Fcb;
    }

    //
    //  We better be holding some resource.
    //

    ASSERT( !IsListEmpty( &IrpContext->ExclusiveFcbList ) ||
            ((Fcb->PagingIoResource != NULL) && NtfsIsSharedFcbPagingIo( Fcb )) ||
            NtfsIsSharedFcb( Fcb ) );

    //
    //  If there is a Usn Journal and its not a system file setup the memory structures
    //  to hold the usn reasons
    //

    ThisUsn = &IrpContext->Usn;

    if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE ) &&
        !FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

        //
        //  First see if we have a Usn record structure already for this file.  We might need
        //  the whole usn record or simply the name.  If this is the RENAME_NEW_NAME record
        //  then find then name again as well.
        //

        if ((Fcb->FcbUsnRecord == NULL) ||
            !FlagOn( Fcb->FcbState, FCB_STATE_VALID_USN_NAME ) ||
            FlagOn( Reason, USN_REASON_RENAME_NEW_NAME )) {

            ULONG SizeToAllocate;
            ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
            PFILE_NAME FileName = NULL;

            NtfsInitializeAttributeContext( &AttributeContext );

            try {

                //
                //  First we have to find the designated file name.  If we are lucky
                //  it is in an Lcb.  We cannot do this in the case of rename, because
                //  the in-memory stuff is not fixed up yet.
                //

                if (!FlagOn( Reason, USN_REASON_RENAME_NEW_NAME )) {

                    Lcb = (PLCB)CONTAINING_RECORD( Fcb->LcbQueue.Flink, LCB, FcbLinks );
                    while (&Lcb->FcbLinks.Flink != &Fcb->LcbQueue.Flink) {

                        //
                        //  If this is the designated file name, then we can get out pointing
                        //  to the FILE_NAME in the Lcb.
                        //

                        if (FlagOn( Lcb->LcbState, LCB_STATE_DESIGNATED_LINK )) {
                            FileName = (PFILE_NAME)&Lcb->ParentDirectory;
                            break;
                        }

                        //
                        //  Advance to next Lcb.
                        //

                        Lcb = (PLCB)CONTAINING_RECORD( Lcb->FcbLinks.Flink, LCB, FcbLinks );
                    }
                }

                //
                //  If we did not find the file name the easy way, then we have to go
                //  get it.
                //

                if (FileName == NULL) {

                    //
                    //  Acquire some synchronization against the filerecord
                    //

                    NtfsAcquireResourceShared( IrpContext, Fcb, TRUE );
                    AcquiredFcb = TRUE;

                    //
                    //  Now scan for the filename attribute we need.
                    //

                    Found = NtfsLookupAttributeByCode( IrpContext,
                                                       Fcb,
                                                       &Fcb->FileReference,
                                                       $FILE_NAME,
                                                       &AttributeContext );

                    while (Found) {

                        FileName = (PFILE_NAME)NtfsAttributeValue( NtfsFoundAttribute(&AttributeContext) );

                        if (!FlagOn(FileName->Flags, FILE_NAME_DOS) || FlagOn(FileName->Flags, FILE_NAME_NTFS)) {
                            break;
                        }

                        Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                               Fcb,
                                                               $FILE_NAME,
                                                               &AttributeContext );
                    }

                    //
                    //  If there is no file name, raise corrupt!
                    //

                    if (FileName == NULL) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }
                }

                //
                //  Lock the Fcb so the record can't go away.
                //

                NtfsLockFcb( IrpContext, Fcb );
                LockedFcb = TRUE;

                //
                //  Now test for the need for a new record and construct one
                //  if necc. Prev. test was unsafe for checking the Fcb->FcbUsnRecord
                //

                if ((Fcb->FcbUsnRecord == NULL) ||
                    !FlagOn( Fcb->FcbState, FCB_STATE_VALID_USN_NAME ) ||
                    FlagOn( Reason, USN_REASON_RENAME_NEW_NAME )) {

                    //
                    //  Calculate the size required for the record and allocate a new record.
                    //

                    SizeToAllocate = sizeof( FCB_USN_RECORD ) + (FileName->FileNameLength * sizeof(WCHAR));
                    FcbUsnRecord = NtfsAllocatePool( PagedPool, SizeToAllocate );

                    //
                    //  Zero and initialize the new usn record.
                    //

                    RtlZeroMemory( FcbUsnRecord, SizeToAllocate );

                    FcbUsnRecord->NodeTypeCode = NTFS_NTC_USN_RECORD;
                    FcbUsnRecord->NodeByteSize = (USHORT)QuadAlign(FIELD_OFFSET( FCB_USN_RECORD, UsnRecord.FileName ) +
                                                                   (FileName->FileNameLength * sizeof(WCHAR)));
                    FcbUsnRecord->Fcb = Fcb;

                    FcbUsnRecord->UsnRecord.RecordLength = FcbUsnRecord->NodeByteSize -
                                                           FIELD_OFFSET( FCB_USN_RECORD, UsnRecord );

                    FcbUsnRecord->UsnRecord.MajorVersion = 2;
                    FcbUsnRecord->UsnRecord.FileReferenceNumber = *(PULONGLONG)&Fcb->FileReference;
                    FcbUsnRecord->UsnRecord.ParentFileReferenceNumber = *(PULONGLONG)&FileName->ParentDirectory;
                    FcbUsnRecord->UsnRecord.SecurityId = Fcb->SecurityId;
                    FcbUsnRecord->UsnRecord.FileNameLength = FileName->FileNameLength * 2;
                    FcbUsnRecord->UsnRecord.FileNameOffset = FIELD_OFFSET( USN_RECORD, FileName );

                    RtlCopyMemory( FcbUsnRecord->UsnRecord.FileName,
                                   FileName->FileName,
                                   FileName->FileNameLength * 2 );

                    //
                    //  If the record is there then copy the existing reasons and source info.
                    //

                    if (Fcb->FcbUsnRecord != NULL) {

                        FcbUsnRecord->UsnRecord.Reason = Fcb->FcbUsnRecord->UsnRecord.Reason;
                        FcbUsnRecord->UsnRecord.SourceInfo = Fcb->FcbUsnRecord->UsnRecord.SourceInfo;

                        //
                        //  Deallocate the existing block if still there.
                        //

                        NtfsLockFcb( IrpContext, Fcb->Vcb->UsnJournal->Fcb );

                        //
                        //  Put the new block into the modified list if the current one is
                        //  already there.
                        //

                        if (Fcb->FcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL) {

                            InsertTailList( &Fcb->FcbUsnRecord->ModifiedOpenFilesLinks,
                                            &FcbUsnRecord->ModifiedOpenFilesLinks );
                            RemoveEntryList( &Fcb->FcbUsnRecord->ModifiedOpenFilesLinks );

                            if (Fcb->FcbUsnRecord->TimeOutLinks.Flink != NULL) {

                                InsertTailList( &Fcb->FcbUsnRecord->TimeOutLinks,
                                                &FcbUsnRecord->TimeOutLinks );
                                RemoveEntryList( &Fcb->FcbUsnRecord->TimeOutLinks );
                            }
                        }

                        NtfsFreePool( Fcb->FcbUsnRecord );
                        Fcb->FcbUsnRecord = FcbUsnRecord;
                        NtfsUnlockFcb( IrpContext, Fcb->Vcb->UsnJournal->Fcb );

                    //
                    //  Otherwise this is a new usn structure.
                    //

                    } else {

                        Fcb->FcbUsnRecord = FcbUsnRecord;

                    }
                } else {

                    //
                    //  We are going to reuse the current fcb record in this path.
                    //  This can happen in races between the write path which has only paged sharing
                    //  and the close record path which has only main exclusive. In this
                    //  case the only synchronization we have is the fcb->mutex
                    //  The old usnrecord should be identical to the current one we would have constructed
                    //

                    ASSERT( FileName->FileNameLength * 2 == Fcb->FcbUsnRecord->UsnRecord.FileNameLength );
                    ASSERT( RtlEqualMemory( FileName->FileName, Fcb->FcbUsnRecord->UsnRecord.FileName,  Fcb->FcbUsnRecord->UsnRecord.FileNameLength ) );
                }

                //
                //  Set the flag indicating that the Usn name is valid.
                //

                SetFlag( Fcb->FcbState, FCB_STATE_VALID_USN_NAME );


            } finally {

                if (LockedFcb) {
                    NtfsUnlockFcb( IrpContext, Fcb );
                }
                if (AcquiredFcb) {
                    NtfsReleaseResource( IrpContext, Fcb );
                }
                NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            }
        }
    }

    //
    //  If we have memory structures for the usn reasons fill in the new reasons
    //  Note: this means that journal may not be active at this point. We will always
    //  accumulate reasons once we have started
    //

    if (Fcb->FcbUsnRecord != NULL) {

        //
        //  Scan the list to see if we already have an entry for this Fcb.  If there are
        //  no entries then use the position in the IrpContext, otherwise allocate a USN_FCB
        //  and chain this into the IrpContext.  Typical case for this is rename.
        //

        do {

            if (ThisUsn->CurrentUsnFcb == Fcb) { break; }

            //
            //  Check if we are at the last entry then we want to use the entry in the
            //  IrpContext.
            //

            if (ThisUsn->CurrentUsnFcb == NULL) {

                RtlZeroMemory( &ThisUsn->CurrentUsnFcb,
                               sizeof( USN_FCB ) - FIELD_OFFSET( USN_FCB, CurrentUsnFcb ));
                ThisUsn->CurrentUsnFcb = Fcb;
                break;
            }

            if (ThisUsn->NextUsnFcb == NULL) {

                //
                //  Allocate a new entry.
                //

                ThisUsn->NextUsnFcb = NtfsAllocatePool( PagedPool, sizeof( USN_FCB ));
                ThisUsn = ThisUsn->NextUsnFcb;

                RtlZeroMemory( ThisUsn, sizeof( USN_FCB ));
                ThisUsn->CurrentUsnFcb = Fcb;
                break;
            }

            ThisUsn = ThisUsn->NextUsnFcb;

        } while (TRUE);

        //
        //  If the Reason is one of the data stream reasons, and this is the named data
        //  steam, then change the code.
        //

        ASSERT(USN_REASON_NAMED_DATA_OVERWRITE == (USN_REASON_DATA_OVERWRITE << 4));
        ASSERT(USN_REASON_NAMED_DATA_EXTEND == (USN_REASON_DATA_EXTEND << 4));
        ASSERT(USN_REASON_NAMED_DATA_TRUNCATION == (USN_REASON_DATA_TRUNCATION << 4));

        if ((Reason & (USN_REASON_DATA_OVERWRITE | USN_REASON_DATA_EXTEND | USN_REASON_DATA_TRUNCATION)) &&
            (Scb->AttributeName.Length != 0)) {

            //
            //  If any flag other than these three are set already, the shift will make
            //  them look like other flags.  For instance, USN_REASON_NAMED_DATA_EXTEND
            //  will become USN_REASON_FILE_DELETE, which will cause a number of problems.
            //

            ASSERT(!FlagOn( Reason, ~(USN_REASON_DATA_OVERWRITE | USN_REASON_DATA_EXTEND | USN_REASON_DATA_TRUNCATION) ));

            Reason <<= 4;
        }

        //
        //  If there are no new reasons, then we can ignore this change.
        //
        //  We will generate a new record if the SourceInfo indicates some
        //  change to the source info in the record.
        //

        NtfsLockFcb( IrpContext, Fcb );

        //
        //  The rename flags are the only ones that do not accumulate until final close, since
        //  we write records designating old and new names.  So if we are writing one flag
        //  we must clear the other.
        //

        if (FlagOn(Reason, USN_REASON_RENAME_OLD_NAME | USN_REASON_RENAME_NEW_NAME)) {

            ClearFlag( ThisUsn->NewReasons,
                       (Reason ^ (USN_REASON_RENAME_OLD_NAME | USN_REASON_RENAME_NEW_NAME)) );
            ClearFlag( Fcb->FcbUsnRecord->UsnRecord.Reason,
                       (Reason ^ (USN_REASON_RENAME_OLD_NAME | USN_REASON_RENAME_NEW_NAME)) );
        }

        //
        //  Check if the reason is a new reason.
        //

        NewReasons = FlagOn( ~(Fcb->FcbUsnRecord->UsnRecord.Reason | ThisUsn->NewReasons), Reason );
        if (NewReasons != 0) {

            //
            //  Check if we will remove a bit from the source info.
            //

            if ((Fcb->FcbUsnRecord->UsnRecord.SourceInfo != 0) &&
                (Fcb->FcbUsnRecord->UsnRecord.Reason != 0) &&
                (Reason != USN_REASON_CLOSE)) {

                RemovedSourceInfo = FlagOn( Fcb->FcbUsnRecord->UsnRecord.SourceInfo,
                                            ~(IrpContext->SourceInfo | ThisUsn->RemovedSourceInfo) );

                if (RemovedSourceInfo != 0) {

                    SetFlag( ThisUsn->RemovedSourceInfo, RemovedSourceInfo );
                }
            }

            //
            //  Post the new reasons to the IrpContext.
            //

            ThisUsn->CurrentUsnFcb = Fcb;
            SetFlag( ThisUsn->NewReasons, NewReasons );
            SetFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON );

        //
        //  Check if there is a change only to the source info.
        //  We look to see if we would remove a bit from the
        //  source info only if there has been at least one
        //  usn record already.
        //

        } else if ((Fcb->FcbUsnRecord->UsnRecord.SourceInfo != 0) &&
                   (Fcb->FcbUsnRecord->UsnRecord.Reason != 0) &&
                   (Reason != USN_REASON_CLOSE)) {

            //
            //  Remember the bit being removed.
            //

            RemovedSourceInfo = FlagOn( Fcb->FcbUsnRecord->UsnRecord.SourceInfo,
                                        ~(IrpContext->SourceInfo | ThisUsn->RemovedSourceInfo) );

            if (RemovedSourceInfo != 0) {

                SetFlag( ThisUsn->RemovedSourceInfo, RemovedSourceInfo );
                ThisUsn->CurrentUsnFcb = Fcb;
                SetFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON );

            } else {

                Reason = 0;
            }

        //
        //  If we did not apply the changes, then make sure we do no more special processing
        //  below.
        //

        } else {

            Reason = 0;
        }

        NtfsUnlockFcb( IrpContext, Fcb );

        //
        //  For data overwrites it is necessary to actually write the Usn journal now, in
        //  case we crash before the request is completed, yet the data makes it out.  Also
        //  we need to capture the Lsn to flush to if the data is getting flushed.
        //
        //  We don't need to make this call if we are doing a rename.  Rename will rewrite previous
        //  records.
        //

        if ((IrpContext->MajorFunction != IRP_MJ_SET_INFORMATION) &&
            FlagOn( Reason, USN_REASON_DATA_OVERWRITE | USN_REASON_NAMED_DATA_OVERWRITE )) {

            LSN UpdateLsn;

            //
            //  For now assume we are not already a transaction, since we will be doing a
            //  checkpoint.  (If this ASSERT ever fires, verify that it is ok to checkpoint
            //  the transaction in that case and fix the ASSERT!)
            //

            ASSERT(IrpContext->TransactionId == 0);

            //
            //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
            //  reduce contention. Get rid of any pinned Mft records, because WriteUsnJournal is going
            //  to acquire the Scb resource.
            //

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsWriteUsnJournalChanges( IrpContext );
            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Capture the Lsn to flush to *in the first thread to set one of the above bits*,
            //  before letting any data hit the disk.  Synchronize it with the Fcb lock.
            //

            UpdateLsn = LfsQueryLastLsn( Fcb->Vcb->LogHandle );
            NtfsLockFcb( IrpContext, Fcb );
            Fcb->UpdateLsn = UpdateLsn;
            NtfsUnlockFcb( IrpContext, Fcb );
        }
    }

    return ThisUsn->NewReasons;
}


VOID
NtfsWriteUsnJournalChanges (
    PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to write a set of posted changes from the IrpContext
    to the UsnJournal, if they have not already been posted.

Arguments:

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PFCB Fcb;
    PVCB Vcb;
    PSCB UsnJournal;
    PUSN_FCB ThisUsn;
    ULONG PreserveWaitState;
    BOOLEAN WroteUsnRecord = FALSE;
    BOOLEAN ReleaseFcbs = FALSE;
    BOOLEAN CleanupContext = FALSE;

    ThisUsn = &IrpContext->Usn;

    do {

        //
        //  Is there an Fcb with usn reasons in the current irpcontext usn_fcb structures ?
        //  Also are there any new reasons to report for this fcb.
        //

        if ((ThisUsn->CurrentUsnFcb != NULL) &&
            FlagOn( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON )) {

            Fcb = ThisUsn->CurrentUsnFcb;
            Vcb = Fcb->Vcb;
            UsnJournal = Vcb->UsnJournal;

            //
            //  Remember that we wrote a record.
            //

            WroteUsnRecord = TRUE;

            //
            //  We better be waitable.
            //

            PreserveWaitState = (IrpContext->State ^ IRP_CONTEXT_STATE_WAIT) & IRP_CONTEXT_STATE_WAIT;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                //
                //  Acquire the Usn journal and lock the Fcb fields.
                //

                NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
                NtfsAcquireExclusiveScb( IrpContext, UsnJournal );
                ReleaseFcbs = TRUE;
            }

            try {

                USN Usn;
                ULONG BytesLeftInPage;

                //
                //  Make sure the changes have not already been logged.  We're
                //  looking for new reasons or a change to the source info.
                //

                NtfsLockFcb( IrpContext, Fcb );

                //
                //  This is the tricky synchronization case. Assumption is
                //  that if name goes invalid we have both resources exclusive and any writes will
                //  be preceded by a post which will remove the invalid record
                //  This occurs when we remove a link and generate one record under the old name
                //  with the flag set as invalid
                //

                ASSERT( !FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE ) ||
                        FlagOn( Fcb->FcbState, FCB_STATE_VALID_USN_NAME ) ||
                        (NtfsIsExclusiveFcb( Fcb ) &&
                         ((Fcb->PagingIoResource == NULL) || (NtfsIsExclusiveFcbPagingIo( Fcb )))) );

                //
                //  Initialize the Fcb source info if this is our first record.
                //

                if (Fcb->FcbUsnRecord->UsnRecord.Reason == 0) {

                    Fcb->FcbUsnRecord->UsnRecord.SourceInfo = IrpContext->SourceInfo;
                }

                //
                //  Accumulate all reasons and store in the Fcb before unlocking the Fcb.
                //

                SetFlag( Fcb->FcbUsnRecord->UsnRecord.Reason, ThisUsn->NewReasons );

                //
                //  Now clear the source info flags not supported by this
                //  caller.
                //

                ClearFlag( Fcb->FcbUsnRecord->UsnRecord.SourceInfo, ThisUsn->RemovedSourceInfo );

                //
                //  Unlock Fcb now so we do not deadlock if we do a checkpoint.
                //

                NtfsUnlockFcb( IrpContext, Fcb );

                //
                //  Only actually persist to disk if the journal is active
                //

                if (FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                    ASSERT( UsnJournal != NULL );

                    //
                    //  Initialize the context structure if we are doing a close.
                    //

                    if (FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason, USN_REASON_CLOSE )) {
                        NtfsInitializeAttributeContext( &AttributeContext );
                        CleanupContext = TRUE;
                    }

                    Usn = UsnJournal->Header.FileSize.QuadPart;
                    BytesLeftInPage = USN_PAGE_SIZE - ((ULONG)Usn & (USN_PAGE_SIZE - 1));

                    //
                    //  If there is not enough room left in this page for the
                    //  current Usn Record, then advance to the next page boundary
                    //  by writing 0's (these pages not zero-initialized( and update  the Usn.
                    //

                    if (BytesLeftInPage < Fcb->FcbUsnRecord->UsnRecord.RecordLength) {

                        ASSERT( Fcb->FcbUsnRecord->UsnRecord.RecordLength <= USN_PAGE_SIZE );

                        NtOfsPutData( IrpContext, UsnJournal, -1, BytesLeftInPage, NULL );
                        Usn += BytesLeftInPage;
                    }

                    Fcb->FcbUsnRecord->UsnRecord.Usn = Usn;

                    //
                    //  Build the FileAttributes from the Fcb.
                    //

                    Fcb->FcbUsnRecord->UsnRecord.FileAttributes = Fcb->Info.FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS;

                    //
                    //  We have to generate the DIRECTORY attribute.
                    //

                    if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {
                        SetFlag( Fcb->FcbUsnRecord->UsnRecord.FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
                    }

                    //
                    //  If there are no flags set then explicitly set the NORMAL flag.
                    //

                    if (Fcb->FcbUsnRecord->UsnRecord.FileAttributes == 0) {
                        Fcb->FcbUsnRecord->UsnRecord.FileAttributes = FILE_ATTRIBUTE_NORMAL;
                    }

                    KeQuerySystemTime( &Fcb->FcbUsnRecord->UsnRecord.TimeStamp );

                    //
                    //  Append the record to the UsnJournal.  We should never see a record with
                    //  both rename flags or the close flag with the old name flag.
                    //

                    ASSERT( !FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason, USN_REASON_RENAME_OLD_NAME ) ||
                            !FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason,
                                     USN_REASON_CLOSE | USN_REASON_RENAME_NEW_NAME ));

                    NtOfsPutData( IrpContext,
                                  UsnJournal,
                                  -1,
                                  Fcb->FcbUsnRecord->UsnRecord.RecordLength,
                                  &Fcb->FcbUsnRecord->UsnRecord );

#ifdef BRIANDBG
                    //
                    //  The Usn better be in an allocated piece.
                    //

                    {
                        LCN Lcn;
                        LONGLONG ClusterCount;

                        if (!NtfsLookupAllocation( IrpContext,
                                                   UsnJournal,
                                                   LlClustersFromBytesTruncate( Vcb, Usn ),
                                                   &Lcn,
                                                   &ClusterCount,
                                                   NULL,
                                                   NULL ) ||
                            (Lcn == UNUSED_LCN)) {
                            ASSERT( FALSE );
                        }
                    }
#endif
                    //
                    //  If this is the close record, then we must update the Usn in the file record.
                    //

                    if (!FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason, USN_REASON_FILE_DELETE ) &&
                        !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

                        //
                        //  See if we need to actually grow Standard Information first.
                        //  Do this even if we don't write the Usn record now.  We may
                        //  generate a close record for this file during mount and
                        //  we expect the STANDARD_INFORMATION to support Usns.
                        //

                        if (!FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {

                            ThisUsn->OldFcbState = Fcb->FcbState;
                            SetFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_FCB_STATE );

                            //
                            //  Grow the standard information.
                            //

                            NtfsGrowStandardInformation( IrpContext, Fcb );
                        }


                        if (FlagOn( Fcb->FcbUsnRecord->UsnRecord.Reason, USN_REASON_CLOSE )) {

                            //
                            //  Locate the standard information, it must be there.
                            //

                            if (!NtfsLookupAttributeByCode( IrpContext,
                                                            Fcb,
                                                            &Fcb->FileReference,
                                                            $STANDARD_INFORMATION,
                                                            &AttributeContext )) {

                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                            }

                            ASSERT(NtfsFoundAttribute( &AttributeContext )->Form.Resident.ValueLength ==
                                sizeof( STANDARD_INFORMATION ));

                            //
                            //  Call to change the attribute value.
                            //

                            NtfsChangeAttributeValue( IrpContext,
                                                      Fcb,
                                                      FIELD_OFFSET(STANDARD_INFORMATION, Usn),
                                                      &Usn,
                                                      sizeof(Usn),
                                                      FALSE,
                                                      FALSE,
                                                      FALSE,
                                                      FALSE,
                                                      &AttributeContext );
                        }
                    }

                    //
                    //  Remember to release these resources as soon as possible now.
                    //  Note, if we are not sure that we became a transaction (else
                    //  case below) then our finally clause will do the release.
                    //
                    //  If the system has already gone through shutdown we won't be
                    //  able to start a transaction.  Test that we have a transaction
                    //  before setting these flags.
                    //

                    if (IrpContext->TransactionId != 0) {

                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                                    IRP_CONTEXT_FLAG_RELEASE_MFT );
                    }
                }

                //
                //  Clear the flag indicating that there are new reasons to report.
                //

                ClearFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON );

                // 
                //  On abnormal termination we should hold onto the scb's so process
                //  exception can rollback the file sizes
                // 

                if (ReleaseFcbs) {

                    NtfsReleaseScb( IrpContext, UsnJournal );
                    ASSERT( NtfsIsExclusiveScb( Vcb->MftScb ) );
                    NtfsReleaseScb( IrpContext, Vcb->MftScb );
                }

            } finally {

                //
                //  Cleanup the context structure if we are doing a close.
                //

                if (CleanupContext) {
                    NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
                }
            }

            ClearFlag( IrpContext->State, PreserveWaitState );
        }

        //
        //  Go to the next entry if present.  If we are at the last entry then walk through all of the
        //  entries and clear the flag indicating we have new reasons.
        //

        if (ThisUsn->NextUsnFcb == NULL) {

            //
            //  Exit if we didn't write any records.
            //

            if (!WroteUsnRecord) { break; }

            ThisUsn = &IrpContext->Usn;

            do {

                ClearFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON );
                if (ThisUsn->NextUsnFcb == NULL) { break; }

                ThisUsn = ThisUsn->NextUsnFcb;

            } while (TRUE);

            break;
        }

        ThisUsn = ThisUsn->NextUsnFcb;

    } while (TRUE);

    return;
}


VOID
NtfsSetupUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG CreateIfNotExist,
    IN ULONG Restamp,
    IN PCREATE_USN_JOURNAL_DATA NewJournalData
    )

/*++

Routine Description:

    This routine is called to setup the Usn Journal - the stream may or may
    not yet exist.  This routine is responsible for cleaning up the disk and
    in-memory structures on failure.

Arguments:

    Vcb - Supplies the volume being initialized.

    Fcb - Supplies the file for the Usn Journal.

    CreateIfNotExist - Indicates that we should use the values in the Vcb instead of on-disk.

    Restamp - Indicates if we should restamp the journal with a new Id.

    NewJournalData - Allocation size and delta for Usn journal if we are not reading from disk.

Return Value:

    None.

--*/

{
    RTL_GENERIC_TABLE UsnControlTable;
    PSCB UsnJournal;
    PUSN_RECORD UsnRecord, UsnRecordInTable;
    BOOLEAN CleanupControlTable = FALSE;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    MAP_HANDLE MapHandle;
    USN StartUsn;
    LONGLONG ClusterCount;

    PUSN_JOURNAL_INSTANCE UsnJournalData;
    USN_JOURNAL_INSTANCE UsnJournalInstance, VcbUsnInstance;
    PUSN_JOURNAL_INSTANCE InstanceToRestore;

    PBCB Bcb = NULL;

    LONGLONG SavedReservedSpace;
    LONGLONG RequiredReserved;

    BOOLEAN FoundMax;
    BOOLEAN NewMax = FALSE;
    BOOLEAN InsufficientReserved = FALSE;

    BOOLEAN DecrementCloseCount = TRUE;
    BOOLEAN NewElement;

    LARGE_INTEGER LastTimeStamp;

    ULONG TempUlong;
    LONGLONG TempLonglong;

    PAGED_CODE( );

    //
    //  Make sure we don't move to a larger page size.
    //

    ASSERT( USN_PAGE_BOUNDARY >= PAGE_SIZE );

    //
    //  Open/Create the Usn Journal stream.  We should never have an Scb
    //  if we are mounting a new volume.
    //

    ASSERT( (((ULONG) USN_JOURNAL_CACHE_BIAS) & (VACB_MAPPING_GRANULARITY - 1)) == 0 );

    NtOfsCreateAttribute( IrpContext,
                          Fcb,
                          JournalStreamName,
                          CREATE_OR_OPEN,
                          TRUE,
                          &UsnJournal );

    ASSERT( NtfsIsExclusiveScb( UsnJournal ) && NtfsIsExclusiveScb( Vcb->MftScb ) );

    //
    //  Initialize the enumeration context and map handle.
    //

    NtfsInitializeAttributeContext( &AttributeContext );
    NtOfsInitializeMapHandle( &MapHandle );

    //
    //  Let's build the journal instance data.  Assume we have current valid
    //  values in the Vcb for the Id and lowest valid usn.
    //

    UsnJournalInstance.MaximumSize = NewJournalData->MaximumSize;
    UsnJournalInstance.AllocationDelta = NewJournalData->AllocationDelta;

    UsnJournalInstance.JournalId = Vcb->UsnJournalInstance.JournalId;
    UsnJournalInstance.LowestValidUsn = Vcb->UsnJournalInstance.LowestValidUsn;

    //
    //  Capture the current reservation in the Journal Scb and also the
    //  current JournalData in the Vcb to restore on error.
    //

    SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;

    RtlCopyMemory( &VcbUsnInstance,
                   &Vcb->UsnJournalInstance,
                   sizeof( USN_JOURNAL_INSTANCE ));

    InstanceToRestore = &VcbUsnInstance;

    try {

        //
        //  Make sure the Scb is initialized.
        //

        if (!FlagOn( UsnJournal->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, UsnJournal, NULL );
        }

        //
        //  Always create the journal non-resident.  Otherwise in
        //  ConvertToNonResident we always need to check for this case
        //  which only happens once per volume.
        //

        if (FlagOn( UsnJournal->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            NtfsLookupAttributeForScb( IrpContext, UsnJournal, NULL, &AttributeContext );
            ASSERT( NtfsIsAttributeResident( NtfsFoundAttribute( &AttributeContext )));
            NtfsConvertToNonresident( IrpContext,
                                      Fcb,
                                      NtfsFoundAttribute( &AttributeContext ),
                                      FALSE,
                                      &AttributeContext );

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Remember to restamp if an earlier delete operation failed.  This flag should
        //  never be set if there is a current UsnJournal Scb in the Vcb.
        //


        ASSERT( !FlagOn( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE ) ||
                (Vcb->UsnJournal == NULL) );

        if (FlagOn( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE )) {

            Restamp = TRUE;
        }

        //
        //  If the $Max doesn't exist or we want to restamp then generate the
        //  new ID and Lowest ID.
        //

        if (!(FoundMax = NtfsLookupAttributeByName( IrpContext,
                                                    Fcb,
                                                    &Fcb->FileReference,
                                                    $DATA,
                                                    &$Max,
                                                    NULL,
                                                    FALSE,
                                                    &AttributeContext )) ||
            Restamp ) {

            NtfsAdvanceUsnJournal( Vcb, &UsnJournalInstance, UsnJournal->Header.FileSize.QuadPart, &NewMax );

        //
        //  Examine the current $Max attribute for validity and either use the current values or
        //  generate new values.
        //

        } else {

            //
            //  Get the size of the $Max attribute.  It should always be resident but we will rewrite it in
            //  the case where it isn't.
            //

            if (NtfsIsAttributeResident( NtfsFoundAttribute( &AttributeContext ))) {

                TempUlong = (NtfsFoundAttribute( &AttributeContext))->Form.Resident.ValueLength;

            } else {

                TempUlong = (ULONG) (NtfsFoundAttribute( &AttributeContext))->Form.Nonresident.FileSize;
                NewMax = TRUE;
            }

            //
            //  Map the attribute and check it for consistency.
            //

            NtfsMapAttributeValue( IrpContext,
                                   Fcb,
                                   &UsnJournalData,
                                   &TempUlong,
                                   &Bcb,
                                   &AttributeContext );

            //
            //  Only copy over the range of values we would understand.  If the size is not one
            //  we recognize then restamp the journal.  We handle the V1 case as well as V2 case.
            //

            if (TempUlong == sizeof( CREATE_USN_JOURNAL_DATA )) {

                UsnJournalInstance.LowestValidUsn = 0;
                KeQuerySystemTime( (PLARGE_INTEGER) &UsnJournalInstance.JournalId );

                //
                //  Put version 2 on the disk.
                //

                NewMax = TRUE;

                //
                //  If this is not an overwrite then copy the size and delta from the attribute.
                //

                if (!CreateIfNotExist) {

                    //
                    //  Assume we will use the values from the disk.
                    //

                    RtlCopyMemory( &UsnJournalInstance,
                                   UsnJournalData,
                                   TempUlong );
                }

            } else if (TempUlong == sizeof( USN_JOURNAL_INSTANCE )) {

                //
                //  Assume we will use the values from the disk.
                //

                if (CreateIfNotExist) {

                    NewMax = TRUE;
                    UsnJournalInstance.LowestValidUsn = UsnJournalData->LowestValidUsn;
                    UsnJournalInstance.JournalId = UsnJournalData->JournalId;

                } else {

                    //
                    //  Get the data from the disk.
                    //

                    RtlCopyMemory( &UsnJournalInstance,
                                   UsnJournalData,
                                   TempUlong );
                }

            } else {

                //
                //  Restamp in this case.
                //  We move forward in the file to the next Usn boundary.
                //

                NtfsAdvanceUsnJournal( Vcb, &UsnJournalInstance, UsnJournal->Header.FileSize.QuadPart, &NewMax );
            }

            //
            //  Put the Bcb back into the context if we removed it.
            //

            if (NtfsFoundBcb( &AttributeContext ) == NULL) {

                NtfsFoundBcb( &AttributeContext ) = Bcb;
                Bcb = NULL;
            }
        }

        //
        //  Check that the file doesn't end on a sparse hole.
        //

        if (!NewMax &&
            (UsnJournal->Header.AllocationSize.QuadPart != 0) &&
            (UsnJournalInstance.LowestValidUsn != UsnJournal->Header.AllocationSize.QuadPart)) {

            LCN Lcn;

            if (!NtfsLookupAllocation( IrpContext,
                                       UsnJournal,
                                       LlClustersFromBytesTruncate( Vcb, UsnJournal->Header.AllocationSize.QuadPart - 1 ),
                                       &Lcn,
                                       &ClusterCount,
                                       NULL,
                                       NULL ) ||
                (Lcn == UNUSED_LCN)) {

                NtfsAdvanceUsnJournal( Vcb, &UsnJournalInstance, UsnJournal->Header.AllocationSize.QuadPart, &NewMax );
            }
        }

        //
        //  Enforce minimum sizes and allocation deltas, do not let them eat the whole volume,
        //  and round them to a Cache Manager View Size.  All of these decisions are arbitrary,
        //  but hopefully reasonable.  An option would be to take the cases other than those
        //  dealing with rounding, and return an error.
        //

        if ((ULONGLONG) UsnJournalInstance.MaximumSize < (ULONGLONG) VcbUsnInstance.MaximumSize) {

            UsnJournalInstance.MaximumSize = VcbUsnInstance.MaximumSize;
        }

        if (UsnJournalInstance.MaximumSize < MINIMUM_USN_JOURNAL_SIZE) {
            UsnJournalInstance.MaximumSize = MINIMUM_USN_JOURNAL_SIZE;
            NewMax = TRUE;
        } else {

            if ((ULONGLONG) UsnJournalInstance.MaximumSize > LlBytesFromClusters(Vcb, Vcb->TotalClusters) / 2) {
                UsnJournalInstance.MaximumSize = LlBytesFromClusters(Vcb, Vcb->TotalClusters) / 2;
                NewMax = TRUE;
            }

            if ((ULONGLONG) UsnJournalInstance.MaximumSize > USN_MAXIMUM_JOURNAL_SIZE) {
                UsnJournalInstance.MaximumSize = USN_MAXIMUM_JOURNAL_SIZE;
                NewMax = TRUE;
            }
        }

        //
        //  Round this value down to a cache view boundary.
        //

        UsnJournalInstance.MaximumSize = BlockAlignTruncate( UsnJournalInstance.MaximumSize, VACB_MAPPING_GRANULARITY );

        //
        //  Now do the allocation delta.
        //

        if ((ULONGLONG) UsnJournalInstance.AllocationDelta < (ULONGLONG) VcbUsnInstance.AllocationDelta) {

            UsnJournalInstance.AllocationDelta = VcbUsnInstance.AllocationDelta;
        }

        if (UsnJournalInstance.AllocationDelta < (MINIMUM_USN_JOURNAL_SIZE / 4)) {
            UsnJournalInstance.AllocationDelta = MINIMUM_USN_JOURNAL_SIZE / 4;
            NewMax = TRUE;
        } else if ((ULONGLONG) UsnJournalInstance.AllocationDelta > (UsnJournalInstance.MaximumSize / 4)) {
            UsnJournalInstance.AllocationDelta = (UsnJournalInstance.MaximumSize / 4);
            NewMax = TRUE;
        }

        //
        //  Round this down to a view boundary as well.
        //

        UsnJournalInstance.AllocationDelta = BlockAlignTruncate( UsnJournalInstance.AllocationDelta, VACB_MAPPING_GRANULARITY );

        //
        //  We now know the desired size of the journal (including allocation delta).  Next
        //  we need to check that this space is available on disk.  Otherwise we can get in
        //  a state where every operation on the volume will fail because we need to grow
        //  the journal and the space isn't available.  The strategy here will be to use
        //  the reserved clusters in the Vcb to make sure we have enough space.  If the
        //  journal already exists and we are simply opening it then the space should
        //  be available.  It is possible someone could move this volume to NT4 and fill
        //  up the disk however.  If we can't reserve the space in the current system then
        //  update the $Max attribute to indicate that we can't access the journal at this time.
        //

        //
        //  We need to be very precise about the initial reservation.  The total allocation we allow
        //  ourselves is (MaxSize + Delta * 2).  We will reserve the missing space now and adjust it
        //  during the TrimUsnJournal phase.
        //

        RequiredReserved = UsnJournalInstance.MaximumSize + (UsnJournalInstance.AllocationDelta * 2);

        if (RequiredReserved >= UsnJournal->TotalAllocated) {

            RequiredReserved -= UsnJournal->TotalAllocated;

        } else {

            RequiredReserved = UsnJournalInstance.AllocationDelta;
        }

        NtfsAcquireReservedClusters( Vcb );

        //
        //  Check if there is more to reserve and adjust the reservation if necessary.
        //

        if (RequiredReserved > SavedReservedSpace) {

            //
            //  Check that the reserved clusters are available.
            //

            if (LlClustersFromBytes( Vcb, (RequiredReserved - SavedReservedSpace) ) + Vcb->TotalReserved > Vcb->FreeClusters) {

                //
                //  We can't reserve the required space.  If someone is changing the journal then simply
                //  raise the error.
                //

                if (CreateIfNotExist) {

                    NtfsReleaseReservedClusters( Vcb );
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                }

                //
                //  We are trying to open the journal but can't get the space.  Update the
                //  $Max to indicate that the ID is changing.  We will bail later in this case.
                //
                //  We move forward in the file to the next Usn boundary.
                //

                TempUlong = USN_PAGE_BOUNDARY;
                if (USN_PAGE_BOUNDARY < Vcb->BytesPerCluster) {

                    TempUlong = Vcb->BytesPerCluster;
                }

                UsnJournalInstance.LowestValidUsn = BlockAlign( UsnJournal->Header.FileSize.QuadPart, (LONG)TempUlong );

                //
                //  Generate a new journal ID.
                //

                KeQuerySystemTime( (PLARGE_INTEGER) &UsnJournalInstance.JournalId );

                //
                //  Remember that we are restamping and need to rewrite the $Max attribute.
                //

                NewMax = TRUE;

                InsufficientReserved = TRUE;
            }
        }

        //
        //  Remove the current reservation and bias with the new reservation.
        //

        Vcb->TotalReserved -= LlClustersFromBytes( Vcb, SavedReservedSpace );
        Vcb->TotalReserved += LlClustersFromBytes( Vcb, RequiredReserved );
        UsnJournal->ScbType.Data.TotalReserved = RequiredReserved;
        SetFlag( UsnJournal->ScbState, SCB_STATE_WRITE_ACCESS_SEEN );
        NtfsReleaseReservedClusters( Vcb );

        //
        //  Check we need to write a new $Max attribute.
        //

        if (NewMax) {

            //
            //  Delete the existing $Max if present.
            //

            if (FoundMax) {

                if (NtfsIsAttributeResident( NtfsFoundAttribute( &AttributeContext ))) {

                    NtfsDeleteAttributeRecord( IrpContext,
                                               Fcb,
                                               (DELETE_LOG_OPERATION |
                                                DELETE_RELEASE_FILE_RECORD |
                                                DELETE_RELEASE_ALLOCATION),
                                               &AttributeContext );

                } else {

                    PSCB MaxScb;

                    MaxScb = NtfsCreateScb( IrpContext,
                                            Fcb,
                                            $DATA,
                                            &$Max,
                                            FALSE,
                                            NULL );

                    do {

                        NtfsDeleteAttributeRecord( IrpContext,
                                                   Fcb,
                                                   (DELETE_LOG_OPERATION |
                                                    DELETE_RELEASE_FILE_RECORD |
                                                    DELETE_RELEASE_ALLOCATION),
                                                   &AttributeContext );

                    } while (NtfsLookupNextAttributeForScb( IrpContext, MaxScb, &AttributeContext ));
                }
            }

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

            //
            //  Create the new $MAX attribute.
            //

            NtfsCreateAttributeWithValue( IrpContext,
                                          UsnJournal->Fcb,
                                          $DATA,
                                          &$Max,
                                          &UsnJournalInstance,
                                          sizeof( USN_JOURNAL_INSTANCE ),
                                          0,                             // attribute flags
                                          NULL,
                                          TRUE,
                                          &AttributeContext );
        }

        //
        //  Check if we are finished with the journal because of reservation problems.
        //

        if (InsufficientReserved) {

            //
            //  We want to checkpoint the request in order to leave the new $Max on disk.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );
            leave;
        }

        //
        //  Now update the Vcb with the new instance values.
        //

        RtlCopyMemory( &Vcb->UsnJournalInstance,
                       &UsnJournalInstance,
                       sizeof( USN_JOURNAL_INSTANCE ));

        //
        //  We now have the correct journal values in the Vcb and the reservation in the Scb.
        //  The next step is to make sure that the allocation in the journal data is consistent
        //  with the lowest Vcn value.
        //

        if (UsnJournalInstance.LowestValidUsn >= UsnJournal->Header.FileSize.QuadPart) {

            ASSERT( (Vcb->UsnJournal == NULL) ||
                    (Vcb->UsnJournal->Header.FileSize.QuadPart == 0) ||
                    (UsnJournalInstance.LowestValidUsn == UsnJournal->Header.FileSize.QuadPart) );

            //
            //  Add allocation if we need to.
            //

            if (UsnJournalInstance.LowestValidUsn > UsnJournal->Header.AllocationSize.QuadPart) {

                NtfsAddAllocation( IrpContext,
                                   NULL,
                                   UsnJournal,
                                   LlClustersFromBytesTruncate( Vcb, UsnJournal->Header.AllocationSize.QuadPart ),
                                   LlClustersFromBytes( Vcb,
                                                        UsnJournalInstance.LowestValidUsn - UsnJournal->Header.AllocationSize.QuadPart ),
                                   FALSE,
                                   NULL );
            }

            //
            //  Bump all of the sizes to this value.
            //

            UsnJournal->Header.ValidDataLength.QuadPart =
            UsnJournal->Header.FileSize.QuadPart =
            UsnJournal->ValidDataToDisk = UsnJournalInstance.LowestValidUsn;

            NtfsWriteFileSizes( IrpContext,
                                UsnJournal,
                                &UsnJournal->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                FALSE );

            //
            //  Throw away the allocation upto this value.
            //

            NtfsDeleteAllocation( IrpContext,
                                  NULL,
                                  UsnJournal,
                                  0,
                                  LlClustersFromBytesTruncate( Vcb, UsnJournalInstance.LowestValidUsn ) - 1,
                                  TRUE,
                                  FALSE );

            //
            //  Bias the Reserved space again.
            //

            RequiredReserved = UsnJournalInstance.MaximumSize + (UsnJournalInstance.AllocationDelta * 2);

            if (RequiredReserved >= UsnJournal->TotalAllocated) {

                RequiredReserved -= UsnJournal->TotalAllocated;

            } else {

                RequiredReserved = UsnJournalInstance.AllocationDelta;
            }

            NtfsAcquireReservedClusters( Vcb );
            Vcb->TotalReserved -= LlClustersFromBytes( Vcb, UsnJournal->ScbType.Data.TotalReserved );
            Vcb->TotalReserved += LlClustersFromBytes( Vcb, RequiredReserved );
            UsnJournal->ScbType.Data.TotalReserved = RequiredReserved;
            NtfsReleaseReservedClusters( Vcb );
        }

        //
        //  Make sure the stream is marked as sparse.
        //

        if (!FlagOn( UsnJournal->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            NtfsSetSparseStream( IrpContext, NULL, UsnJournal );
            NtfsUpdateDuplicateInfo( IrpContext, UsnJournal->Fcb, NULL, Vcb->ExtendDirectory );

            //
            //  No point in restoring the Vcb values now.
            //

            InstanceToRestore = NULL;
            SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;
        }

        //
        //  If this was just an overwrite of parameters (Journal already started), get out.
        //

        if (Vcb->UsnJournal != NULL) {

            ASSERT( FlagOn( Vcb->UsnJournal->Fcb->FcbState, FCB_STATE_USN_JOURNAL ));
            SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;
            InstanceToRestore = NULL;

            leave;
        }

        //
        //  Note in the Fcb that this is a journal file.
        //

        SetFlag( UsnJournal->Fcb->FcbState, FCB_STATE_USN_JOURNAL );

        //
        //  Initialize a generic table to scoreboard Fcb entries
        //

        RtlInitializeGenericTable( &UsnControlTable,
                                   NtfsUsnTableCompare,
                                   NtfsUsnTableAllocate,
                                   NtfsUsnTableFree,
                                   NULL );

        CleanupControlTable = TRUE;

        //
        //  Load the run information for the stream.  We are looking for the first position
        //  to read from the disk.
        //

        NtfsPreloadAllocation( IrpContext, UsnJournal, 0, MAXLONGLONG );

        if (UsnJournal->Header.AllocationSize.QuadPart != 0) {

            VCN CurrentVcn = 0;

            while (!NtfsLookupAllocation( IrpContext,
                                          UsnJournal,
                                          CurrentVcn,
                                          &TempLonglong,
                                          &ClusterCount,
                                          NULL,
                                          NULL )) {

                //
                //  Check the case where we returned the maximum LCN value.
                //

                if (CurrentVcn + ClusterCount == MAXLONGLONG) {

                    Vcb->FirstValidUsn = UsnJournal->Header.FileSize.QuadPart;
                    break;
                }

                //
                //  Find out the number of bytes in this block and check we don't
                //  go beyond file size.
                //

                Vcb->FirstValidUsn += LlBytesFromClusters( Vcb, ClusterCount );

                if (Vcb->FirstValidUsn >= UsnJournal->Header.FileSize.QuadPart) {

                    Vcb->FirstValidUsn = UsnJournal->Header.FileSize.QuadPart;
                    break;
                }

                CurrentVcn += ClusterCount;
            }
        }

        //
        //  Skip forward if we have restamped the file.
        //

        if (Vcb->FirstValidUsn < UsnJournalInstance.LowestValidUsn) {

            Vcb->FirstValidUsn = UsnJournalInstance.LowestValidUsn;
        }

        //
        //  Loop through as many views as required to fill the output buffer.
        //

        StartUsn = Vcb->LowestOpenUsn;
        if (StartUsn < Vcb->FirstValidUsn) {
            StartUsn = Vcb->FirstValidUsn;
        }

        //
        //  This is where we set up the bias for the Scb.  Only do this for cases where
        //  there already isn't a data section.
        //

        if (UsnJournal->NonpagedScb->SegmentObject.DataSectionObject == NULL) {

            Vcb->UsnCacheBias = Vcb->FirstValidUsn & ~(USN_JOURNAL_CACHE_BIAS - 1);

            if (Vcb->UsnCacheBias != 0) {

                Vcb->UsnCacheBias -= USN_JOURNAL_CACHE_BIAS;
            }

            NtfsCreateInternalAttributeStream( IrpContext, UsnJournal, TRUE, NULL );
        }

        while (StartUsn < UsnJournal->Header.FileSize.QuadPart) {

            LONGLONG BiasedStartUsn;

            //
            //  Calculate length to process in this view.
            //

            TempLonglong = UsnJournal->Header.FileSize.QuadPart - StartUsn;
            if (TempLonglong > (VACB_MAPPING_GRANULARITY - (ULONG)(StartUsn & (VACB_MAPPING_GRANULARITY - 1)))) {
                TempLonglong = VACB_MAPPING_GRANULARITY - (ULONG)(StartUsn & (VACB_MAPPING_GRANULARITY - 1));
            }

            //
            //  Map the view containing the desired Usn.
            //

            ASSERT( StartUsn >= Vcb->UsnCacheBias );
            BiasedStartUsn = StartUsn - Vcb->UsnCacheBias;
            NtOfsMapAttribute( IrpContext, UsnJournal, BiasedStartUsn, (ULONG)TempLonglong, &UsnRecord, &MapHandle );

            //
            //  Now loop to process this view.  TempLonglong is the space left in this view.  TempUlong is
            //  the space for the next record.
            //

            while (TempLonglong != 0) {

                //
                //  Calculate size left in current page, and see if we have to move to the
                //  next page.
                //
                //  Note in this loop we are not going to trust the the contents of the
                //  file, so if we see anything broken we raise an error.
                //

                TempUlong = USN_PAGE_SIZE - (ULONG)(StartUsn & (USN_PAGE_SIZE - 1));

                if ((TempUlong >= (FIELD_OFFSET(USN_RECORD, FileName) + sizeof(WCHAR))) && (UsnRecord->RecordLength != 0)) {

                    //
                    //  Get the size of the current record.
                    //

                    TempUlong = UsnRecord->RecordLength;

                    //
                    //  Since the Usn is embedded in the Usn record, we can do a fairly precise
                    //  test that we got a valid Usn.  Also make sure we got a valid RecordSize
                    //  that does not go beyond FileSize or the end of the page.  If we see a
                    //  bad record, then let's just skip to the end of the page rather than
                    //  tubing the mount process.
                    //

                    if ((TempUlong & (sizeof(ULONGLONG) - 1)) ||
                        (TempUlong > TempLonglong) ||
                        (TempUlong > (USN_PAGE_SIZE - ((ULONG)StartUsn & (USN_PAGE_SIZE - 1)))) ||
                        (StartUsn != UsnRecord->Usn)) {

                        TempUlong = (USN_PAGE_SIZE - ((ULONG)StartUsn & (USN_PAGE_SIZE - 1)));

                        //
                        //  FileSize may stop before the end of the page, so check for that so
                        //  we terminate correctly.
                        //

                        if (TempUlong > TempLonglong) {
                            TempUlong = (ULONG)TempLonglong;
                        }

                    //
                    //  We have to skip over any MajorVersion we do not understand.
                    //

                    } else if ((UsnRecord->MajorVersion == 1) ||
                               (UsnRecord->MajorVersion == 2)) {

                        //
                        //  Load up the info from this record.
                        //

                        if (!FlagOn(UsnRecord->Reason, USN_REASON_CLOSE)) {

                            UsnRecordInTable = RtlInsertElementGenericTable( &UsnControlTable,
                                                                             UsnRecord,
                                                                             UsnRecord->RecordLength,
                                                                             &NewElement );
                            if (!NewElement) {

                                //
                                //  We've previously seen a record for this file. If its
                                //  still the same size - just overwrite it otherwise delete
                                //  old one (RtlInsert doesn't update if an existing record
                                //  is found) and reinsert the new record - with the current
                                //  atributes and file name etc.
                                //  

                                if (UsnRecordInTable->RecordLength == UsnRecord->RecordLength) {
                                    RtlCopyMemory( UsnRecordInTable, UsnRecord, UsnRecord->RecordLength );
                                } else {

                                    (VOID)RtlDeleteElementGenericTable( &UsnControlTable, UsnRecord );
                                    UsnRecordInTable = RtlInsertElementGenericTable( &UsnControlTable,
                                                                                     UsnRecord,
                                                                                     UsnRecord->RecordLength,
                                                                                     &NewElement );
                                }
                            }

                        //
                        //  If this is a close record, then we can delete our element from the
                        //  generic table.  Note if the record is not there this function returns
                        //  FALSE, and the attempted delete is benign.
                        //

                        } else {

                            (VOID)RtlDeleteElementGenericTable( &UsnControlTable, UsnRecord );
                        }

                        //
                        //  Capture each time stamp so that we can stamp our close records
                        //  with the last one we see.
                        //

                        LastTimeStamp = UsnRecord->TimeStamp;
                    }

                //
                //  Check for a bogus Usn near the end of a page that would cause us to
                //  decrement through length, or a RecordSize of 0, and just skip to the
                //  end of the page.
                //

                } else if ((TempUlong > TempLonglong) || (TempUlong == 0)) {

                    TempUlong = (USN_PAGE_SIZE - ((ULONG)StartUsn & (USN_PAGE_SIZE - 1)));

                    if (TempUlong > TempLonglong) {

                        TempUlong = (ULONG) TempLonglong;
                    }
                }

                StartUsn += TempUlong;
                TempLonglong -= TempUlong;
                UsnRecord = Add2Ptr( UsnRecord, TempUlong );
            }

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }

        //
        //  Now write the close records for anyone who is left.  We store a counter
        //  in TempUlong to limit the number of records we do at a time.
        //

        for (TempUlong = 0, UsnRecord = RtlEnumerateGenericTable( &UsnControlTable, TRUE );
             UsnRecord != NULL;
             UsnRecord = RtlEnumerateGenericTable( &UsnControlTable, TRUE )) {

            ULONG UsnRecordReason;
            FILE_REFERENCE UsnRecordFileReferenceNumber;
            ULONG BytesLeftInPage;
            PFILE_RECORD_SEGMENT_HEADER FileRecord;
            NTSTATUS Status;

            StartUsn = NtOfsQueryLength( UsnJournal );
            StartUsn = UsnJournal->Header.FileSize.QuadPart;
            BytesLeftInPage = USN_PAGE_SIZE - ((ULONG)StartUsn & (USN_PAGE_SIZE - 1));

            //
            //  If there is not enough room left in this page for the
            //  current Usn Record, then advance to the next page boundary
            //  by writing 0's (these pages not zero-initialized( and update  the Usn.
            //

            if (BytesLeftInPage < UsnRecord->RecordLength) {

                NtOfsPutData( IrpContext, UsnJournal, -1, BytesLeftInPage, NULL );
                StartUsn += BytesLeftInPage;
            }

            //
            //  Append the record to the UsnJournal.  Note that the generic table is unaligned for
            //  64-bit values so we have to carefully copy the larger values.
            //

            *((ULONGLONG UNALIGNED *) &UsnRecord->Usn) = StartUsn;
            *((ULONGLONG UNALIGNED *) &UsnRecord->TimeStamp) = *((PULONGLONG) &LastTimeStamp);

            UsnRecord->Reason |= USN_REASON_CLOSE;
            NtOfsPutData( IrpContext,
                          UsnJournal,
                          -1,
                          UsnRecord->RecordLength,
                          UsnRecord );

            //
            //  Remember key fields of the Usn record.
            //

            UsnRecordReason = UsnRecord->Reason;
            *((PULONGLONG) &UsnRecordFileReferenceNumber) = *((ULONGLONG UNALIGNED *) &UsnRecord->FileReferenceNumber);

            RtlDeleteElementGenericTable( &UsnControlTable, UsnRecord );
            TempUlong += 1;

            //
            //  Now we have to update the Usn in the file record, if it is not deleted.
            //  Also, we use try-except to plow on in the event of any errors, so we
            //  do not make the volume unmountable.  (One legitimate concern would be
            //  a hot-fix in the Mft.)
            //

            if (!FlagOn(UsnRecordReason, USN_REASON_FILE_DELETE)) {

                //
                //  Start by reading the file record and performing some simple tests.
                //  We don't want to go down the path where we mark the volume dirty
                //  for a file that was already cleaned up by autochk.
                //

                NtfsUnpinBcb( IrpContext, &Bcb );

                try {

                    //
                    //  Capture the Segment Reference and make sure the Sequence Number is
                    //

                    LONGLONG FileOffset = NtfsFullSegmentNumber( &UsnRecordFileReferenceNumber );

                    //
                    //  Calculate the file offset in the Mft to the file record segment.
                    //

                    FileOffset = LlBytesFromFileRecords( Vcb, FileOffset );

                    //
                    //  Check to see if the record is within the MFT
                    //  If not, skip this record instead of raising corrupt
                    //  as there is no real fix to this situation other than
                    //  deleting the whole journal.
                    //

                    if ((FileOffset + Vcb->BytesPerFileRecordSegment) <=
                        Vcb->MftScb->Header.AllocationSize.QuadPart) {

                        NtfsReadMftRecord( IrpContext,
                                           Vcb,
                                           &UsnRecordFileReferenceNumber,
                                           FALSE,
                                           &Bcb,
                                           &FileRecord,
                                           NULL );

                        //
                        //  Proceed only if the file record passes the following tests.
                        //
                        //      - FileRecord is in-use
                        //      - Sequence numbers match
                        //      - Standard information is the correct size (we should have done
                        //          this when we wrote the changes)
                        //

                        if ((*(PULONG)(FileRecord)->MultiSectorHeader.Signature == *(PULONG)FileSignature) &&
                            FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) &&
                            (FileRecord->SequenceNumber == UsnRecordFileReferenceNumber.SequenceNumber)) {

                            //
                            //  Locate the standard information, it must be there.  This is the
                            //  Fcb for the Usn Journal, but the lookup routine only needs to get
                            //  the Vcb from it, and will special-case the return to us.
                            //

                            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

                            //
                            //  If we cannot find it for some reason, then leave.
                            //

                            if (!NtfsLookupAttributeByCode( IrpContext,
                                                            Fcb,
                                                            &UsnRecordFileReferenceNumber,
                                                            $STANDARD_INFORMATION,
                                                            &AttributeContext )) {
                                leave;
                            }

                            ASSERT( NtfsFoundAttribute( &AttributeContext )->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION ));

                            //
                            //  Call to change the attribute value.  Again, this is the wrong Fcb,
                            //  but it is ok since we are not changing the attribute size and will
                            //  only need to get the Vcb from it.
                            //

                            NtfsChangeAttributeValue( IrpContext,
                                                      Fcb,
                                                      FIELD_OFFSET(STANDARD_INFORMATION, Usn),
                                                      &StartUsn,
                                                      sizeof(StartUsn),
                                                      FALSE,
                                                      FALSE,
                                                      FALSE,
                                                      FALSE,
                                                      &AttributeContext );

                        }
                    }

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {


                    //
                    //  If we get a log file full then raise this status.  There
                    //  is no reason to continue if we get a log file full.
                    //

                    if (Status == STATUS_LOG_FILE_FULL) {

                        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
                    }

                    //
                    //  OK.  We are going to continue.  Make sure we clean up the IrpContext.
                    //

                    IrpContext->ExceptionStatus = STATUS_SUCCESS;
                }

                NtfsUnpinBcb( IrpContext, &Bcb );
            }

            //
            //  Checkpoint the transaction periodically so we don't spin on log file full.
            //

            if (TempUlong > GENERATE_CLOSE_RECORD_LIMIT) {

                NtfsCheckpointCurrentTransaction( IrpContext );
                SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;
                InstanceToRestore = NULL;
                TempUlong = 0;
            }
        }

        //
        //  Everything has succeeded to this point.  Now make sure the DELETE_USN flag is cleared on
        //  disk if present.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE )) {

            NtfsSetVolumeInfoFlagState( IrpContext,
                                        Vcb,
                                        VOLUME_DELETE_USN_UNDERWAY,
                                        FALSE,
                                        TRUE );
        }

        InstanceToRestore = NULL;
        SavedReservedSpace = UsnJournal->ScbType.Data.TotalReserved;

        Vcb->UsnJournal = UsnJournal;
        DecrementCloseCount = FALSE;

        NtfsLockVcb( IrpContext, Vcb );
        SetFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE );
        ClearFlag( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE );
        NtfsUnlockVcb( IrpContext, Vcb );

    } finally {

        //
        //  Clean up any remaining entries in the control table in case we failed
        //  while processing it.
        //

        if (CleanupControlTable) {

            while ((UsnRecord = RtlEnumerateGenericTable( &UsnControlTable, TRUE )) != NULL) {

                RtlDeleteElementGenericTable( &UsnControlTable, UsnRecord );
            }
        }

        //
        //  Restore any changes we might have made to the Vcb.
        //

        if (InstanceToRestore) {

            RtlCopyMemory( &Vcb->UsnJournalInstance,
                           InstanceToRestore,
                           sizeof( USN_JOURNAL_INSTANCE ));
        }

        //
        //  Back out the reservation change if necessary.
        //

        if (UsnJournal->ScbType.Data.TotalReserved != SavedReservedSpace) {

            NtfsAcquireReservedClusters( Vcb );
            Vcb->TotalReserved += LlClustersFromBytes( Vcb, SavedReservedSpace );
            Vcb->TotalReserved -= LlClustersFromBytes( Vcb, UsnJournal->ScbType.Data.TotalReserved );
            UsnJournal->ScbType.Data.TotalReserved = SavedReservedSpace;
            NtfsReleaseReservedClusters( Vcb );
        }

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        NtfsUnpinBcb( IrpContext, &Bcb );
        NtOfsReleaseMap( IrpContext, &MapHandle );

        //
        //  If we got an error and the Usn journal is not going to be created then fix up the
        //  new Scb so we won't access it during volume flush operations, etc.  Otherwise we
        //  will think the volume is corrupt because there is no attribute for the Scb.
        //

        if (DecrementCloseCount) {

            NtOfsCloseAttribute( IrpContext, UsnJournal );
        }

        if (Vcb->UsnJournal == NULL) {

#ifdef NTFSDBG

            //
            //  Compensate again for misclassification of usnjournal during delete
            //

            if (IrpContext->OwnershipState == NtfsOwns_ExVcb_Mft_Extend_Journal) {
                IrpContext->OwnershipState = NtfsOwns_ExVcb_Mft_Extend_File;
            }
#endif

            UsnJournal->Header.AllocationSize.QuadPart =
            UsnJournal->Header.FileSize.QuadPart =
            UsnJournal->ValidDataToDisk =
            UsnJournal->Header.ValidDataLength.QuadPart = 0;

            UsnJournal->AttributeTypeCode = $UNUSED;
            SetFlag( UsnJournal->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

            //
            //  Clear the system file flag out of the Fcb.
            //

            ClearFlag( UsnJournal->Fcb->FcbState, FCB_STATE_SYSTEM_FILE );

            ASSERT( ExIsResourceAcquiredSharedLite( &Vcb->Resource ));

            NtfsTeardownStructures( IrpContext,
                                    UsnJournal,
                                    NULL,
                                    TRUE,
                                    0,
                                    NULL );

        }
    }

    return;
}


VOID
NtfsTrimUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine may be called to check if the Usn Journal is beyond the designated
    size goal, and if so to delete the front of the file to bring it within the goal.
    This may require first generating a few close records for files that are still open
    and have their last record within this range.  Such files that are modified again
    will simply look like they were opened again.

    This routine is called with certain checkpoint flags for the volume set.  This is to
    serialize with the DeleteUsnJournal path.  We must clear them and signal other
    checkpointers to proceed.

Arguments:

    Vcb - Supplies the Vcb on which the Usn Journal is to be trimmed.

Return Value:

    None.

--*/

{
    PFCB Fcb;
    PFCB_USN_RECORD FcbUsnRecord;
    PSCB UsnJournal = Vcb->UsnJournal;
    USN FirstValidUsn = Vcb->FirstValidUsn;
    ULONG Done = FALSE;

    LONGLONG SavedReserved;
    LONGLONG RequiredReserved;
    LONGLONG SavedBias;
    BOOLEAN AcquiredMft = FALSE;
    BOOLEAN DerefFcb = FALSE;

    //
    //  Purge file record cache - may not be necc. here, examine this post nt5
    //

    NtfsPurgeFileRecordCache( IrpContext );

    //
    //  See if it is time to trim the UsnJournal.
    //

    NtfsAcquireResourceShared( IrpContext, UsnJournal, TRUE );
    while ((USN)(FirstValidUsn +
                 Vcb->UsnJournalInstance.MaximumSize +
                 Vcb->UsnJournalInstance.AllocationDelta) < (USN)UsnJournal->Header.FileSize.QuadPart) {

        FirstValidUsn += Vcb->UsnJournalInstance.AllocationDelta;
    }
    NtfsReleaseResource( IrpContext, UsnJournal );

    //
    //  Get to work if we have a new Usn to trim to.
    //

    if (FirstValidUsn != Vcb->FirstValidUsn) {

        //
        //  Use try-finally to catch any log file full condtions or allocation failures.
        //  Since these are the only possible error condition, we know what resources to
        //  free on exit.
        //

        try {

            do {

                Fcb = NULL;

                //
                //  Purge file record cache before acquiring vcb everytime
                //

                NtfsPurgeFileRecordCache( IrpContext );

                //
                //  Synchronize with the Fcb table and Usn Journal so that we can
                //  see if the next Fcb has to have a close record generated.
                //

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                NtfsAcquireFcbTable( IrpContext, Vcb );
                NtfsAcquireFsrtlHeader( UsnJournal );

                if (!IsListEmpty(&Vcb->ModifiedOpenFiles)) {
                    FcbUsnRecord = (PFCB_USN_RECORD)CONTAINING_RECORD( Vcb->ModifiedOpenFiles.Flink,
                                                                       FCB_USN_RECORD,
                                                                       ModifiedOpenFilesLinks );

                    //
                    //  If the Usn record for this Fcb is older than where we want to delete
                    //  to, then reference it.  Otherwise signal we are done by clearing
                    //  the Fcb pointer.
                    //

                    if (FcbUsnRecord->Fcb->Usn < FirstValidUsn) {
                        Fcb = FcbUsnRecord->Fcb;
                        Fcb->ReferenceCount += 1;
                        DerefFcb = TRUE;
                    } else {
                        Fcb = NULL;
                    }
                }

                NtfsReleaseFsrtlHeader( UsnJournal );
                NtfsReleaseFcbTable( IrpContext, Vcb );

                //
                //  Do we have to generate another close record?
                //

                if (Fcb != NULL) {

                    //
                    //  We must lock out other activity on this file since we are about
                    //  to reset the Usn reasons.
                    //

                    if (Fcb->PagingIoResource != NULL) {
                        NtfsAcquirePagingResourceExclusive( IrpContext, Fcb, TRUE );
                        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    
                    } else {

                        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                        
                        //
                        //  If we now do not see a paging I/O resource we are golden,
                        //  othewise we can absolutely release and acquire the resources
                        //  safely in the right order, since a resource in the Fcb is
                        //  not going to go away.
                        //
                        
                        if (Fcb->PagingIoResource != NULL) {
                    
                            NtfsReleaseFcb( IrpContext, Fcb );
                            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                            NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                        }
                    }

                    //
                    //  Skip over system files.
                    //

                    if (!FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

                        //
                        //  Post the close to our IrpContext.
                        //

                        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

                        //
                        //  If we did not actually post a change, something is wrong,
                        //  because when a close change is written, the Fcb is removed from
                        //  the list.
                        //

                        ASSERT(IrpContext->Usn.CurrentUsnFcb != NULL);

                        //
                        //  Now generate the close record and checkpoint the transaction.
                        //

                        NtfsWriteUsnJournalChanges( IrpContext );
                        NtfsCheckpointCurrentTransaction( IrpContext );
                    }

                    //
                    //  Now we will dereference the Fcb.
                    //

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    Fcb->ReferenceCount -= 1;
                    DerefFcb = FALSE;

                    //
                    //  We may be required to delete this guy.  This frees the Fcb Table.
                    //

                    if (IsListEmpty( &Fcb->ScbQueue ) && (Fcb->ReferenceCount == 0) && (Fcb->CloseCount == 0)) {

                        BOOLEAN AcquiredFcbTable = TRUE;

                        NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

                        ASSERT(!AcquiredFcbTable);
                        Fcb = (PFCB)1;

                    //
                    //  Otherwise free the table and Fcb resources. Release paging first since
                    //  the only thing protecting this file from teardown is the main at this point.
                    //

                    } else {

                        NtfsReleaseFcbTable( IrpContext, Vcb );

                        if (Fcb->PagingIoResource != NULL) {
                            ExReleaseResourceLite( Fcb->PagingIoResource );
                        }
                        NtfsReleaseFcb( IrpContext, Fcb );
                    }
                }

                //
                //  Now we can drop the Vcb before looping back.
                //

                NtfsReleaseVcb( IrpContext, Vcb );

            } while (Fcb != NULL);

        } finally {

            //
            //  We got an error if Fcb is not NULL
            //

            if (Fcb != NULL) {

                if (DerefFcb) {
                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    Fcb->ReferenceCount -= 1;
                    NtfsReleaseFcbTable( IrpContext, Vcb );
                }

                //
                //  Only main protects the fcb from being deleted so release in inverse order
                //

                if (Fcb->PagingIoResource != NULL) {
                    NtfsReleasePagingResource( IrpContext, Fcb );
                }
                NtfsReleaseFcb( IrpContext, Fcb );
                NtfsReleaseVcb( IrpContext, Vcb );
            }

            //
            //  If we raised then we need to clear the checkpoint flags.
            //

            if (AbnormalTermination()) {

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                ClearFlag( Vcb->CheckpointFlags,
                           VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);

                NtfsSetCheckpointNotify( IrpContext, Vcb );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
            }
        }

        //
        //  Now synchronize for deleting the allocation and purging pages from
        //  the cache.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
        NtfsAcquireExclusiveScb( IrpContext, UsnJournal );

        //
        //  Clear the checkpoint flags at this point.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->CheckpointFlags,
                   VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);

        NtfsSetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        try {

            LONGLONG BiasedFirstValidUsn;
            LONGLONG NewBias;

            SavedReserved = UsnJournal->ScbType.Data.TotalReserved;
            SavedBias = Vcb->UsnCacheBias;

            //
            //  Make sure to preserve our reservation.  We need to make sure anything we
            //  deallocate is available to us.
            //

            RequiredReserved = Vcb->UsnJournalInstance.AllocationDelta * 2 + Vcb->UsnJournalInstance.MaximumSize;

            if (SavedReserved < RequiredReserved) {

                //
                //  Bias the reservation with the maximum amount.
                //

                NtfsAcquireReservedClusters( Vcb );
                Vcb->TotalReserved -= LlClustersFromBytesTruncate( Vcb, SavedReserved );
                Vcb->TotalReserved += LlClustersFromBytesTruncate( Vcb, RequiredReserved );
                UsnJournal->ScbType.Data.TotalReserved = RequiredReserved;
                NtfsReleaseReservedClusters( Vcb );
            }

            NtfsDeleteAllocation( IrpContext,
                                  UsnJournal->FileObject,
                                  UsnJournal,
                                  0,
                                  LlClustersFromBytes(Vcb, FirstValidUsn) - 1,
                                  TRUE,
                                  TRUE );

            //
            //  Do a final checkpoint, especially since this IrpContext gets reused.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Adjust the current reserved amount more precisely.
            //

            NtfsAcquireReservedClusters( Vcb );

            if (UsnJournal->TotalAllocated > RequiredReserved) {

                SavedReserved = Vcb->UsnJournalInstance.AllocationDelta;

            } else {

                SavedReserved = RequiredReserved - UsnJournal->TotalAllocated;
            }

            //
            //  Remove the current reservation and bias with the new reservation.
            //

            Vcb->TotalReserved -= LlClustersFromBytesTruncate( Vcb, UsnJournal->ScbType.Data.TotalReserved );
            Vcb->TotalReserved += LlClustersFromBytesTruncate( Vcb, SavedReserved );
            UsnJournal->ScbType.Data.TotalReserved = SavedReserved;
            NtfsReleaseReservedClusters( Vcb );

            //
            //  If the nearly impossible case that the length wraps, then our
            //  purge will be too small, which simply means some unused pages
            //  will have to leave memory on their own!
            //

            BiasedFirstValidUsn = Vcb->FirstValidUsn - Vcb->UsnCacheBias;

            CcPurgeCacheSection( &UsnJournal->NonpagedScb->SegmentObject,
                                 (PLARGE_INTEGER)&BiasedFirstValidUsn,
                                 (ULONG)(FirstValidUsn - Vcb->FirstValidUsn) - 1,
                                 FALSE );


            //
            //  Adjust bias now if at threshold - the flush causes everything in
            //  cache and logfile to disk and we hold the journal exclusive. So
            //  all in memory stuff will now reflect the new bias
            //

            NewBias = FirstValidUsn & ~(USN_JOURNAL_CACHE_BIAS - 1);
            if (NewBias != 0) {
                NewBias -= USN_JOURNAL_CACHE_BIAS;
            }

            if (NewBias != Vcb->UsnCacheBias) {

                //
                //  Flush And Purge releases all resources in exclusive list so acquire
                //  the mft an extra time beforehand and restore back afterwards
                //

                NtfsAcquireResourceExclusive( IrpContext, Vcb->MftScb, TRUE );
                NtfsReleaseScb( IrpContext, Vcb->MftScb );
                AcquiredMft = TRUE;

                NtfsFlushAndPurgeScb( IrpContext, UsnJournal, NULL );
                Vcb->UsnCacheBias = NewBias;
                SavedBias = NewBias;
            }

            //
            //  If we reach here, then we can advance FirstValidUsn.  (Otherwise
            //  any retryable conditions will just resume work on this range.
            //

            Vcb->FirstValidUsn = FirstValidUsn;

        } finally {

            //
            //  Restore the error if we raised while deallocating.
            //

            if (SavedBias != Vcb->UsnCacheBias) {
                Vcb->UsnCacheBias = SavedBias;
            }

            if (SavedReserved != UsnJournal->ScbType.Data.TotalReserved) {

                NtfsAcquireReservedClusters( Vcb );
                Vcb->TotalReserved += LlClustersFromBytesTruncate( Vcb, SavedReserved );
                Vcb->TotalReserved -= LlClustersFromBytesTruncate( Vcb, RequiredReserved );
                UsnJournal->ScbType.Data.TotalReserved = SavedReserved;
                NtfsReleaseReservedClusters( Vcb );
            }

            NtfsReleaseScb( IrpContext, UsnJournal );

            if (AcquiredMft) {
                NtfsReleaseResource( IrpContext, Vcb->MftScb );
            } else {
                NtfsReleaseScb( IrpContext, Vcb->MftScb );
            }
        }

    } else {

        //
        //  Clear the checkpoint flags at this point.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->CheckpointFlags,
                   VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);

        NtfsSetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
    }
}


NTSTATUS
NtfsQueryUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the worker routine which returns the information about the current instance
    of the Usn journal.

Arguments:

    Irp - This is the Irp for the request.

Return Value:

    NTSTATUS - Result for this request.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PUSN_JOURNAL_DATA JournalData;

    PAGED_CODE();

    //
    //  Always make this request synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Get the current stack location and extract the output
    //  buffer information.  The output parameter will receive
    //  the compressed state of the file/directory.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in th
    //  irp first.  Then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        JournalData = (PUSN_JOURNAL_DATA) Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        JournalData = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (JournalData == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough for the journal data.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( USN_JOURNAL_DATA )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Decode the file object.  We only support this call for volume opens.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Acquire shared access to the Scb and check that the volume is still mounted.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    if (!FlagOn(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED)) {

        NtfsReleaseVcb( IrpContext, Vcb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Indicate if the journal is being deleted or has not started.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

        NtfsReleaseVcb( IrpContext, Vcb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_JOURNAL_DELETE_IN_PROGRESS );
        return STATUS_JOURNAL_DELETE_IN_PROGRESS;
    }

    if (!FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

        NtfsReleaseVcb( IrpContext, Vcb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_JOURNAL_NOT_ACTIVE );
        return STATUS_JOURNAL_NOT_ACTIVE;
    }

    //
    //  Otherwise serialize with the Usn journal and copy the data from the journal Scb
    //  and Vcb.
    //

    NtfsAcquireSharedScb( IrpContext, Vcb->UsnJournal );

    JournalData->UsnJournalID = Vcb->UsnJournalInstance.JournalId;
    JournalData->FirstUsn = Vcb->FirstValidUsn;
    JournalData->NextUsn = Vcb->UsnJournal->Header.FileSize.QuadPart;
    JournalData->LowestValidUsn = Vcb->UsnJournalInstance.LowestValidUsn;
    JournalData->MaxUsn = MAXFILESIZE;
    JournalData->MaximumSize = Vcb->UsnJournalInstance.MaximumSize;
    JournalData->AllocationDelta = Vcb->UsnJournalInstance.AllocationDelta;

    NtfsReleaseScb( IrpContext, Vcb->UsnJournal );

    ASSERT( JournalData->FirstUsn >= JournalData->LowestValidUsn );

    NtfsReleaseVcb( IrpContext, Vcb );
    Irp->IoStatus.Information = sizeof( USN_JOURNAL_DATA );

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


NTSTATUS
NtfsDeleteUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when the user want to delete the current usn journal.  This will
    initiate the work to scan the Mft and reset all usn values to zero and remove the
    UsnJournal file from the disk.

Arguments:

    Irp - This is the Irp for the request.

Return Value:

    NTSTATUS - Result for this request.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PDELETE_USN_JOURNAL_DATA DeleteData;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN CheckpointHeld = FALSE;
    BOOLEAN AcquiredNotify = FALSE;
    PSCB ReleaseUsnJournal = NULL;

    PLIST_ENTRY Links;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  We always wait in this path.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Perform a check on the input buffer.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        DeleteData = (PDELETE_USN_JOURNAL_DATA) Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        DeleteData = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (DeleteData == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( DELETE_USN_JOURNAL_DATA )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Decode the file object type
    //

    NtfsDecodeFileObject( IrpContext,
                          IrpSp->FileObject,
                          &Vcb,
                          &Fcb,
                          &Scb,
                          &Ccb,
                          TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS)) {


        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  We only support deleting and waiting for delete.
    //

    if (DeleteData->DeleteFlags == 0) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    if (FlagOn( DeleteData->DeleteFlags, ~USN_DELETE_VALID_FLAGS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Serialize with chkpoints and acquire the Vcb.  We need to carefully remove
        //  the journal from the Vcb.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS )) {

            //
            //  Release the checkpoint event because we cannot stop the log file now.
            //

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
            NtfsAcquireCheckpoint( IrpContext, Vcb );
        }

        SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS );
        NtfsResetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        CheckpointHeld = TRUE;

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;

        //
        //  Check that the volume is still mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  If the user wants to delete the journal then make sure the delete hasn't
        //  already started.
        //

        if (FlagOn( DeleteData->DeleteFlags, USN_DELETE_FLAG_DELETE )) {

            //
            //  If the journal is already being deleted and this caller wanted to
            //  do the delete then let him know it has already begun.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

                Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
                leave;
            }

            //
            //  Proceed with the delete if there is a Usn journal on disk.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_PRESENT ) ||
                (Vcb->UsnJournal != NULL)) {

                PSCB UsnJournal = Vcb->UsnJournal;

                //
                //  If the journal is running then the caller needs to match the journal ID.
                //

                if ((UsnJournal != NULL) &&
                    (DeleteData->UsnJournalID != Vcb->UsnJournalInstance.JournalId)) {

                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

                //
                //  Write the bit to disk to indicate that the journal is being deleted.
                //  Checkpoint the transaction.
                //

                NtfsSetVolumeInfoFlagState( IrpContext,
                                            Vcb,
                                            VOLUME_DELETE_USN_UNDERWAY,
                                            TRUE,
                                            TRUE );

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  We are going to proceed with the delete.  Clear the flag in the Vcb that
                //  indicates the journal is active.  Then acquire and drop all of the files in
                //  order to serialize with anyone using the journal.
                //

                ClearFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE );

                NtfsAcquireAllFiles( IrpContext,
                                     Vcb,
                                     TRUE,
                                     TRUE,
                                     TRUE );

                ReleaseUsnJournal = UsnJournal;
                if (UsnJournal != NULL) {

                    NtfsAcquireExclusiveScb( IrpContext, UsnJournal );
                }

                //
                //  Set the delete flag in the Vcb and remove the journal from the Vcb.
                //

                SetFlag( Vcb->VcbState, VCB_STATE_USN_DELETE );
                NtfsSetSegmentNumber( &Vcb->DeleteUsnData.DeleteUsnFileReference,
                                      0,
                                      MASTER_FILE_TABLE_NUMBER );

                Vcb->DeleteUsnData.DeleteUsnFileReference.SequenceNumber = 0;
                Vcb->DeleteUsnData.DeleteState = 0;
                Vcb->DeleteUsnData.PriorJournalScb = Vcb->UsnJournal;
                Vcb->UsnJournal = NULL;

                if (UsnJournal != NULL) {

                    //
                    //  Let's purge the data in the Usn journal and clear the bias
                    //  and file reference numbers in the Vcb.
                    //

                    CcPurgeCacheSection( &UsnJournal->NonpagedScb->SegmentObject,
                                         NULL,
                                         0,
                                         FALSE );

                    ClearFlag( UsnJournal->ScbPersist, SCB_PERSIST_USN_JOURNAL );
                }

                Vcb->UsnCacheBias = 0;
                *((PLONGLONG) &Vcb->UsnJournalReference) = 0;

                //
                //  Release the checkpoint if held.
                //

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                ClearFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS );
                NtfsSetCheckpointNotify( IrpContext, Vcb );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
                CheckpointHeld = FALSE;

                //
                //  Walk through the Irps waiting for new Usn data and cause them to be completed.
                //

                if (UsnJournal != NULL) {

                    PWAIT_FOR_NEW_LENGTH Waiter, NextWaiter;

                    NtfsAcquireFsrtlHeader( UsnJournal );
                    Waiter = (PWAIT_FOR_NEW_LENGTH) UsnJournal->ScbType.Data.WaitForNewLength.Flink;

                    while (Waiter != (PWAIT_FOR_NEW_LENGTH) &UsnJournal->ScbType.Data.WaitForNewLength) {

                        NextWaiter = (PWAIT_FOR_NEW_LENGTH) Waiter->WaitList.Flink;

                        //
                        //  We want to complete all of the Irps on the waiting list.  If cancel
                        //  has already been called on the Irp we don't have to do anything.
                        //  Otherwise complete the async Irps and signal the event on
                        //  the sync irps.
                        //

                        if (NtfsClearCancelRoutine( Waiter->Irp )) {

                            //
                            //  If this is an async request then complete the Irp.
                            //

                            if (FlagOn( Waiter->Flags, NTFS_WAIT_FLAG_ASYNC )) {

                                //
                                //  Make sure we decrement the reference count in the Scb.
                                //  Then remove the waiter from the queue and complete the Irp.
                                //

                                InterlockedDecrement( &UsnJournal->CloseCount );
                                RemoveEntryList( &Waiter->WaitList );

                                NtfsCompleteRequest( NULL, Waiter->Irp, STATUS_JOURNAL_DELETE_IN_PROGRESS );
                                NtfsFreePool( Waiter );

                            //
                            //  This is a synch Irp.  All we can do is set the event and note the status
                            //  code.
                            //

                            } else {

                                Waiter->Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
                                KeSetEvent( &Waiter->Event, 0, FALSE );
                            }
                        }

                        Waiter = NextWaiter;
                    }


                    //
                    //  Walk through all of the Fcb Usn records and deallocate them.
                    //

                    Links = Vcb->ModifiedOpenFiles.Flink;

                    while (Vcb->ModifiedOpenFiles.Flink != &Vcb->ModifiedOpenFiles) {

                        RemoveEntryList( Links );
                        Links->Flink = NULL;

                        //
                        //  Look to see if we need to remove the TimeOut link as well.
                        //

                        Links = &(CONTAINING_RECORD( Links, FCB_USN_RECORD, ModifiedOpenFilesLinks ))->TimeOutLinks;

                        if (Links->Flink != NULL) {

                            RemoveEntryList( Links );
                        }

                        Links = Vcb->ModifiedOpenFiles.Flink;
                    }

                    NtfsReleaseFsrtlHeader( UsnJournal );

                    //
                    //  Make sure remove our reference on the Usn journal.
                    //

                    NtOfsCloseAttributeSafe( IrpContext, UsnJournal );
                    ReleaseUsnJournal = NULL;
                }

                //
                //  If this caller wants to wait for this then acquire the notify
                //  mutex now.
                //

                if (FlagOn( DeleteData->DeleteFlags, USN_DELETE_FLAG_NOTIFY )) {

                    NtfsAcquireUsnNotify( Vcb );
                    AcquiredNotify = TRUE;
                }

                //
                //  Post the work item to do the rest of the delete.
                //

                NtfsPostSpecial( IrpContext, Vcb, NtfsDeleteUsnSpecial, &Vcb->DeleteUsnData );
            }
        }

        //
        //  Check if our caller wants to wait for the delete to complete.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE ) &&
            FlagOn( DeleteData->DeleteFlags, USN_DELETE_FLAG_NOTIFY )) {

            if (!AcquiredNotify) {

                NtfsAcquireUsnNotify( Vcb );
                AcquiredNotify = TRUE;
            }

            Status = STATUS_PENDING;
            if (!NtfsSetCancelRoutine( Irp,
                                       NtfsCancelDeleteUsnJournal,
                                       0,
                                       TRUE )) {

                Status = STATUS_CANCELLED;

            //
            //  Add it to the work queue if we were able to set the
            //  cancel routine.
            //

            } else {

                InsertTailList( &Vcb->NotifyUsnDeleteIrps,
                                &Irp->Tail.Overlay.ListEntry );
            }

            NtfsReleaseUsnNotify( Vcb );
            AcquiredNotify = FALSE;
        }

    } finally {

        if (AcquiredNotify) {

            NtfsReleaseUsnNotify( Vcb );
        }

        //
        //  Release the Usn journal if held.
        //

        if (ReleaseUsnJournal) {

            NtfsReleaseScb( IrpContext, ReleaseUsnJournal );
        }

        //
        //  Release the Vcb if held.
        //

        if (VcbAcquired) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  Release the checkpoint if held.
        //

        if (CheckpointHeld) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS );
            NtfsSetCheckpointNotify( IrpContext, Vcb );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }
    }

    //
    //  Complete the irp as appropriate.
    //

    NtfsCompleteRequest( IrpContext,
                         (Status == STATUS_PENDING) ? NULL : Irp,
                         Status );
    return Status;
}


VOID
NtfsDeleteUsnSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called to perform the work of deleting a Usn journal for a volume.
    It is called after the original entry point has done the preliminary work of stopping
    future journal activity and cleaning up active journal requests.  Once we reach this
    point then this routine will make sure the Mft values are reset, delete the journal
    file itself and wake up anyone waiting for the delete journal to complete.

Arguments:

    IrpContext - context of the call

    Context - DELETE_USN_CONTEXT structure used to manage the delete.

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTFS_DELETE_JOURNAL_DATA DeleteData = (PNTFS_DELETE_JOURNAL_DATA) Context;
    ULONG AcquiredVcb = FALSE;
    PVCB Vcb = IrpContext->Vcb;
    PFCB UsnFcb = NULL;
    BOOLEAN AcquiredExtendDirectory = FALSE;

    PIRP UsnNotifyIrp;

    PLIST_ENTRY Links;
    PSCB Scb;
    PFCB Fcb;

    PAGED_CODE();

    //
    //  Use a try-except to catch errors.
    //

    try {

        if (NtfsIsVolumeReadOnly( Vcb )) {

            Vcb->DeleteUsnData.FinalStatus = STATUS_MEDIA_WRITE_PROTECTED;
            NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
        }

        //
        //  Make sure to walk the Mft to set the Usn value back to zero.
        //

        if (!FlagOn( DeleteData->DeleteState, DELETE_USN_RESET_MFT )) {

            try {

                Status = NtfsIterateMft( IrpContext,
                                         IrpContext->Vcb,
                                         &DeleteData->DeleteUsnFileReference,
                                         NtfsDeleteUsnWorker,
                                         Context );

            } except (NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                NOTHING;
            }

            if (!NT_SUCCESS( Status ) && (Status != STATUS_END_OF_FILE)) {

                //
                //  If the operation is going to fail then decide if this is retryable.
                //

                if (Status == STATUS_VOLUME_DISMOUNTED) {

                    Vcb->DeleteUsnData.FinalStatus = STATUS_VOLUME_DISMOUNTED;

                } else if ((Status != STATUS_LOG_FILE_FULL) &&
                           (Status != STATUS_CANT_WAIT)) {

                    Vcb->DeleteUsnData.FinalStatus = Status;

                    //
                    //  Set all the flags for delete operations so we stop at this point.
                    //

                    SetFlag( DeleteData->DeleteState,
                             DELETE_USN_RESET_MFT | DELETE_USN_REMOVE_JOURNAL | DELETE_USN_FINAL_CLEANUP );

                    Status = STATUS_CANT_WAIT;
                }

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            Status = STATUS_SUCCESS;

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsCheckpointCurrentTransaction( IrpContext );
            SetFlag( DeleteData->DeleteState, DELETE_USN_RESET_MFT );
        }

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        AcquiredVcb = TRUE;

        //
        //  If the volume is no longer available then raise STATUS_VOLUME_DISMOUNTED.  Someone
        //  else will find all of the waiters.
        //

        if (!NtfsIsVcbAvailable( Vcb )) {

            Vcb->DeleteUsnData.FinalStatus = STATUS_VOLUME_DISMOUNTED;
            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  The next step is to remove the file if present.
        //

        if (!FlagOn( DeleteData->DeleteState, DELETE_USN_REMOVE_JOURNAL )) {

            try {

                if (Vcb->ExtendDirectory != NULL) {

                    NtfsAcquireExclusiveScb( IrpContext, Vcb->ExtendDirectory );
                    AcquiredExtendDirectory = TRUE;

                    //
                    //  preacquire the mft before we gain the usn journal
                    //  

                    NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );



                    UsnFcb = NtfsInitializeFileInExtendDirectory( IrpContext,
                                                                  Vcb,
                                                                  &NtfsUsnJrnlName,
                                                                  FALSE,
                                                                  FALSE );

#ifdef NTFSDBG

                    //
                    //  Compensate for misclassification of usnjournal during real create
                    //
            
                    if (IrpContext->OwnershipState == NtfsOwns_ExVcb_Mft_Extend_File) {
                        IrpContext->OwnershipState = NtfsOwns_ExVcb_Mft_Extend_Journal;
                    }
#endif

                    if (UsnFcb != NULL) {

                        //
                        //  For lock order acquire in canonical order after unsafe try
                        //

                        if (!NtfsAcquireExclusiveFcb( IrpContext, UsnFcb, NULL, ACQUIRE_NO_DELETE_CHECK  | ACQUIRE_DONT_WAIT)) {
                            NtfsReleaseScb( IrpContext, Vcb->ExtendDirectory );
                            NtfsAcquireExclusiveFcb( IrpContext, UsnFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                            NtfsAcquireExclusiveScb( IrpContext, Vcb->ExtendDirectory );
                        }

                        NtfsDeleteFile( IrpContext,
                                        UsnFcb,
                                        Vcb->ExtendDirectory,
                                        &AcquiredExtendDirectory,
                                        NULL,
                                        NULL );

                        ClearFlag( UsnFcb->FcbState, FCB_STATE_SYSTEM_FILE );
                        
#ifdef NTFSDBG
                        ASSERT( FlagOn( IrpContext->OwnershipState, NtfsResourceUsnJournal ) );
                        ASSERT( !FlagOn( IrpContext->OwnershipState, NtfsResourceFile ) );
                        
                        ClearFlag( IrpContext->OwnershipState, NtfsResourceUsnJournal );
                        SetFlag( IrpContext->OwnershipState, NtfsResourceFile );
                        IrpContext->FilesOwnedCount += 1;
#endif

                        //
                        //  Walk all of the Scbs for this file and recover
                        //  any reserve
                        //  flush them.
                        //

                        Links = UsnFcb->ScbQueue.Flink;

                        while (Links != &UsnFcb->ScbQueue) {

                            Scb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                            //
                            //  Recover the reservation for the Scb now instead of waiting for it
                            //  to go away.
                            //

                            if ((Scb->AttributeTypeCode == $DATA) &&
                                (Scb->ScbType.Data.TotalReserved != 0)) {

                                NtfsAcquireReservedClusters( Vcb );

                                Vcb->TotalReserved -= LlClustersFromBytes( Vcb,
                                                                           Scb->ScbType.Data.TotalReserved );
                                Scb->ScbType.Data.TotalReserved = 0;
                                NtfsReleaseReservedClusters( Vcb );
                            }

                            Links = Links->Flink;
                        }

                        //
                        //  Now teardown the Fcb.
                        //

                        NtfsTeardownStructures( IrpContext,
                                                UsnFcb,
                                                NULL,
                                                FALSE,
                                                ACQUIRE_NO_DELETE_CHECK,
                                                NULL );
                    }
                }

            } except (NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                //
                //    We hit some failure and can't complete the operation.
                //    Remember the error, set the flags in the delete Usn structure
                //    and raise CANT_WAIT so we can abort and then do the final cleanup.
                //

                Vcb->DeleteUsnData.FinalStatus = Status;

                //
                //  Set all the flags for delete operations so we stop at this point.
                //

                SetFlag( DeleteData->DeleteState,
                         DELETE_USN_RESET_MFT | DELETE_USN_REMOVE_JOURNAL | DELETE_USN_FINAL_CLEANUP );

                Status = STATUS_CANT_WAIT;
            }

            if (!NT_SUCCESS( Status )) {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            SetFlag( DeleteData->DeleteState, DELETE_USN_REMOVE_JOURNAL );
        }

        if (!FlagOn( DeleteData->DeleteState, DELETE_USN_FINAL_CLEANUP )) {

            //
            //  Clear the on-disk flag indicating the delete is in progress.
            //

            try {

                NtfsSetVolumeInfoFlagState( IrpContext,
                                            Vcb,
                                            VOLUME_DELETE_USN_UNDERWAY,
                                            FALSE,
                                            TRUE );

            } except (NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                //
                //    We hit some failure and can't complete the operation.
                //    Remember the error, set the flags in the delete Usn structure
                //    and raise CANT_WAIT so we can abort and then do the final cleanup.
                //

                Vcb->DeleteUsnData.FinalStatus = Status;

                //
                //  Set all the flags for delete operations so we stop at this point.
                //

                SetFlag( DeleteData->DeleteState,
                         DELETE_USN_RESET_MFT | DELETE_USN_REMOVE_JOURNAL | DELETE_USN_FINAL_CLEANUP );

                Status = STATUS_CANT_WAIT;
            }

            if (!NT_SUCCESS( Status )) {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }
        }

        //
        //  Make sure we don't own any resources at this point.
        //

        NtfsPurgeFileRecordCache( IrpContext );
        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Finally, now that we have written the forget record, we can free
        //  any exclusive Scbs that we have been holding.
        //

        while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

            Fcb = (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                          FCB,
                                          ExclusiveFcbLinks );

            NtfsReleaseFcb( IrpContext, Fcb );
        }

        //
        //  Remember any saved status code.
        //

        if (Vcb->DeleteUsnData.FinalStatus != STATUS_SUCCESS) {

            Status = Vcb->DeleteUsnData.FinalStatus;

            //
            //  Since we failed make sure to leave the flag set in the Vcb which indicates the
            //  incomplete delete.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_INCOMPLETE_USN_DELETE );
        }

        //
        //  Cleanup the context and flags in the Vcb.
        //

        RtlZeroMemory( &Vcb->DeleteUsnData, sizeof( NTFS_DELETE_JOURNAL_DATA ));
        RtlZeroMemory( &Vcb->UsnJournalInstance, sizeof( USN_JOURNAL_INSTANCE ));
        Vcb->FirstValidUsn = 0;
        Vcb->LowestOpenUsn = 0;

        ClearFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_PRESENT | VCB_STATE_USN_DELETE );

        //
        //  Finally complete all of the waiting Irps in the Usn notify queue.
        //

        NtfsAcquireUsnNotify( Vcb );

        Links = Vcb->NotifyUsnDeleteIrps.Flink;

        while (Links != &Vcb->NotifyUsnDeleteIrps) {

            UsnNotifyIrp = CONTAINING_RECORD( Links,
                                              IRP,
                                              Tail.Overlay.ListEntry );

            //
            //  Remember to move forward in any case.
            //

            Links = Links->Flink;

            //
            //  Clear the notify routine and detect if cancel has
            //  already been called.
            //

            if (NtfsClearCancelRoutine( UsnNotifyIrp )) {

                RemoveEntryList( &UsnNotifyIrp->Tail.Overlay.ListEntry );
                NtfsCompleteRequest( NULL, UsnNotifyIrp, Status );
            }
        }

        NtfsReleaseUsnNotify( Vcb );

    } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation())) {

        Status = IrpContext->TopLevelIrpContext->ExceptionStatus;
    }

    if (AcquiredVcb) {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    //
    //  If this is a fatal failure then do any final cleanup.
    //

    if (!NT_SUCCESS( Status )) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    return;

    UNREFERENCED_PARAMETER( Context );
}


//
//  Local support routine
//

RTL_GENERIC_COMPARE_RESULTS
NtfsUsnTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

    This is a generic table support routine to compare two File References
    in Usn Records.

Arguments:

    Table - Supplies the generic table being queried.  Not used.

    FirstStruct - Supplies the first Usn Record to compare

    SecondStruct - Supplies the second Usn Record to compare

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/

{
    PAGED_CODE();

    if (*((PLONGLONG) &((PUSN_RECORD) FirstStruct)->FileReferenceNumber) <
        *((PLONGLONG) &((PUSN_RECORD) SecondStruct)->FileReferenceNumber)) {

        return GenericLessThan;
    }

    if (*((PLONGLONG) &((PUSN_RECORD) FirstStruct)->FileReferenceNumber) >
        *((PLONGLONG) &((PUSN_RECORD) SecondStruct)->FileReferenceNumber)) {

        return GenericGreaterThan;
    }

    return GenericEqual;

    UNREFERENCED_PARAMETER( Table );
}


//
//  Local support routine
//

PVOID
NtfsUsnTableAllocate (
    IN PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    Table - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    UNREFERENCED_PARAMETER( Table );

    PAGED_CODE();

    return NtfsAllocatePool( PagedPool, ByteSize );
}


//
//  Local support routine
//

VOID
NtfsUsnTableFree (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine to free memory

Arguments:

    Table - Supplies the generic table being used

    Buffer - Supplies pointer to the buffer to be freed

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( Table );

    PAGED_CODE();

    NtfsFreePool( Buffer );
}


//
//  Local support routine
//

VOID
NtfsCancelReadUsnJournal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine may be called by the I/O system to cancel an outstanding
    Irp in NtfsReadUsnJournal.

Arguments:

    DeviceObject - DeviceObject from I/O system

    Irp - Supplies the pointer to the Irp being canceled.

Return Value:

    None

--*/

{
    PWAIT_FOR_NEW_LENGTH WaitForNewLength;

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Capture the Wait block out of the Status field.  We know the Irp can't
    //  go away at this point.
    //

    WaitForNewLength = (PWAIT_FOR_NEW_LENGTH) Irp->IoStatus.Information;
    Irp->IoStatus.Information = 0;

    //
    //  Take a different action depending on whether we are completing the irp
    //  or simply signaling the cancel.
    //


    //
    //  This is the async case.  We can simply complete this irp.
    //

    if (FlagOn( WaitForNewLength->Flags, NTFS_WAIT_FLAG_ASYNC )) {

        //
        //  Acquire the mutex in order to remove this from the list and complete
        //  the Irp.
        //

        NtfsAcquireFsrtlHeader( WaitForNewLength->Stream );

        if (WaitForNewLength->WaitList.Flink) {
            RemoveEntryList( &WaitForNewLength->WaitList );
        }
        NtfsReleaseFsrtlHeader( WaitForNewLength->Stream );

        InterlockedDecrement( &WaitForNewLength->Stream->CloseCount );

        NtfsCompleteRequest( NULL, Irp, STATUS_CANCELLED );
        NtfsFreePool( WaitForNewLength );

    //
    //  If there is not an Irp we simply signal the event and let someone else
    //  do the work.  This is the synchronous case.
    //

    } else {

        WaitForNewLength->Status = STATUS_CANCELLED;
        KeSetEvent( &WaitForNewLength->Event, 0, FALSE );
    }

    return;
    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

VOID
NtfsCancelDeleteUsnJournal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine may be called by the I/O system to cancel an outstanding
    Irp waiting for the usn journal to be deleted.

Arguments:

    DeviceObject - DeviceObject from I/O system

    Irp - Supplies the pointer to the Irp being canceled.

Return Value:

    None

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    PVCB Vcb;

    //
    //  Block out future cancels.
    //

    IoSetCancelRoutine( Irp, NULL );

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Capture the Vcb so we can do the necessary synchronization.
    //

    FileObject = IrpSp->FileObject;
    Vcb = ((PSCB)(FileObject->FsContext))->Vcb;

    //
    //  Acquire the list and remove the Irp.  Complete the Irp with
    //  STATUS_CANCELLED.
    //

    NtfsAcquireUsnNotify( Vcb );
    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    NtfsReleaseUsnNotify( Vcb );

    Irp->IoStatus.Information = 0;
    NtfsCompleteRequest( NULL, Irp, STATUS_CANCELLED );

    return;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

NTSTATUS
NtfsDeleteUsnWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routines resets the Usn in the file record for the Fcb to zero.

Arguments:

    IrpContext - context of the call

    Fcb - Fcb for the file record to clear

    Context - Unused

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID UsnRecord;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_RECORD_HEADER Attribute;
    STANDARD_INFORMATION NewStandardInformation;
    USN Usn = 0;

    PAGED_CODE();

    //
    //  Initialize the search context.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-except to catch all of the errors.
    //

    try {

        //
        //  Use a try-finally to facilitate cleanup.
        //

        try {

            //
            //  Look up the standard information attribute and modify the usn field if
            //  the attribute is found and it is a large standard attribute.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO ) &&
                NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $STANDARD_INFORMATION,
                                           &AttrContext )) {

                Attribute = NtfsFoundAttribute( &AttrContext );

                if (((PSTANDARD_INFORMATION) NtfsAttributeValue( Attribute ))->Usn != 0) {

                    RtlCopyMemory( &NewStandardInformation,
                                   NtfsAttributeValue( Attribute ),
                                   sizeof( STANDARD_INFORMATION ));

                    NewStandardInformation.Usn = 0;

                    NtfsChangeAttributeValue( IrpContext,
                                              Fcb,
                                              0,
                                              &NewStandardInformation,
                                              sizeof( STANDARD_INFORMATION ),
                                              FALSE,
                                              FALSE,
                                              FALSE,
                                              FALSE,
                                              &AttrContext );
                }
            }

            //
            //  Make sure the Fcb reflects this change.
            //

            NtfsLockFcb( IrpContext, Fcb );

            Fcb->Usn = 0;
            UsnRecord = Fcb->FcbUsnRecord;
            Fcb->FcbUsnRecord = NULL;

            NtfsUnlockFcb( IrpContext, Fcb );

            if (UsnRecord != NULL) {

                NtfsFreePool( UsnRecord );
            }

        } finally {

            //
            //  Be sure to clean up the context.
            //

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

    //
    //  We want to swallow any expected errors except LOG_FILE_FULL and CANT_WAIT.
    //

    } except ((FsRtlIsNtstatusExpected( Status = GetExceptionCode()) &&
               (Status != STATUS_LOG_FILE_FULL) &&
               (Status != STATUS_CANT_WAIT)) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Always return success from this routine.
    //

    IrpContext->ExceptionStatus = STATUS_SUCCESS;
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( Context );
}


//
//  Local support routine
//

BOOLEAN
NtfsValidateUsnPage (
    IN PUSN_RECORD UsnRecord,
    IN USN PageUsn,
    IN USN *UserStartUsn OPTIONAL,
    IN LONGLONG UsnFileSize,
    OUT PBOOLEAN ValidUserStartUsn OPTIONAL,
    OUT USN *NextUsn
    )

/*++

Routine Description:

    This routine checks the offsets within a single page of the usn journal.  This allows the caller to
    then walk safely through the page.

Arguments:

    UsnRecord - Pointer to the start of the Usn page.

    PageUsn - This is the Usn for the first record of the page.

    UserStartUsn - If specified then do an additional check that the user's specified usn in fact
        lies correctly on this page.  The output boolean must also be specified if this is.

    UsnFileSize - This is the current size of the usn journal.  If we are looking at the last page then
        we only check to this point.

    ValidUserStartUsn - Address to result of check on user specified start Usn.

    NextUsn - This is the Usn past the valid portion of the page.  It will point to a position on the
        current page unless the last record on the page completely fills the page.  If the page isn't valid
        then it points to the position where the invalid record was detected.

Return Value:

    BOOLEAN - TRUE if the page is valid until a legal terminating condition.  FALSE if there is internal
        corruption on the page.

--*/

{
    ULONG RemainingPageBytes;
    ULONG RecordLength;
    BOOLEAN ValidPage = TRUE;
    BOOLEAN FoundEntry = FALSE;

    PAGED_CODE();

    //
    //  Verify a few input values.
    //

    ASSERT( UsnFileSize > PageUsn );
    ASSERT( !FlagOn( *((PULONG) &UsnRecord), USN_PAGE_SIZE - 1 ));
    ASSERT( !ARGUMENT_PRESENT( UserStartUsn ) || ARGUMENT_PRESENT( ValidUserStartUsn ));
    ASSERT( !ARGUMENT_PRESENT( ValidUserStartUsn ) || ARGUMENT_PRESENT( UserStartUsn ));

    //
    //  Compute the Usn past the valid data on this page.  It is either the end of the journal or
    //  the next page of the journal.
    //

    RemainingPageBytes = USN_PAGE_SIZE;

    if (UsnFileSize < (PageUsn + USN_PAGE_SIZE)) {

        RemainingPageBytes = (ULONG) (UsnFileSize - PageUsn);
    }

    //
    //  Assume the user's Usn is invalid unless it wasn't specified.
    //

    if (!ARGUMENT_PRESENT( ValidUserStartUsn )) {

        //
        //  AllocateFromStack can raise.  Our FSD exception filter will catch it.
        //

        ValidUserStartUsn = (PBOOLEAN) NtfsAllocateFromStack( sizeof( BOOLEAN ));
        *ValidUserStartUsn = TRUE;

    } else {

        *ValidUserStartUsn = FALSE;
    }

    //
    //  Keep track of our current position in the page with the user's pointer.
    //

    *NextUsn = PageUsn;

    //
    //  Check each entry in the page for the following.
    //
    //      1 - Fixed portion of the header won't fit within the remaining bytes on the page.
    //      2 - Record header is zeroed.
    //      3 - Record length is not quad-aligned.
    //      4 - Record length is larger than the remaining bytes on the page.
    //      5 - Usn on the page doesn't match the computed value.
    //

    while (RemainingPageBytes != 0) {

        //
        //  Not enough bytes even for the full Usn header.
        //

        if (RemainingPageBytes < (FIELD_OFFSET( USN_RECORD, FileName ) + sizeof( WCHAR ))) {

            //
            //  If there is at least a ulong it better be zeroed.
            //

            if ((RemainingPageBytes >= sizeof( ULONG )) &&
                (UsnRecord->RecordLength != 0)) {

                ValidPage = FALSE;

            //
            //  If the user's Usn points to this offset then it is valid.
            //

            } else if (!(*ValidUserStartUsn) &&
                        (*NextUsn == *UserStartUsn)) {

                *ValidUserStartUsn = TRUE;
            }

            break;
        }

        //
        //  There should be at least one entry on the page.  We attempt to detect
        //  a local loss of data through zeroing but won't check to the end of
        //  the page.
        //

        RecordLength = UsnRecord->RecordLength;
        if (RecordLength == 0) {

            //
            //  Fail if we haven't found at least one entry.
            //

            if (!FoundEntry) {

                ValidPage = FALSE;

            //
            //  We know we should be dealing with the tail of the page.  It should
            //  be zeroed through the fixed portion of a Usn record.  Theoretically
            //  it should be zeroed to the end of the page but we will assume that we
            //  are only looking for local corruption.  If we lost data through the
            //  end of the page we can't detect it anyway.
            //

            } else {

                PCHAR CurrentByte = (PCHAR) UsnRecord;
                ULONG Count = FIELD_OFFSET( USN_RECORD, FileName ) + sizeof( WCHAR );

                while (Count != 0) {

                    if (*CurrentByte != 0) {

                        ValidPage = FALSE;
                        break;
                    }

                    Count -= 1;
                    CurrentByte += 1;
                }

                //
                //  If the page is valid then check if the user's Usn is at this point.  It is
                //  legal for him to specify the point where the zeroes begin.
                //

                if (ValidPage &&
                    !(*ValidUserStartUsn) &&
                    (*NextUsn == *UserStartUsn)) {

                    *ValidUserStartUsn = TRUE;
                }
            }

            break;
        }

        //
        //  Invalid if record length is not-quad aligned or is larger than
        //  remaining bytes on the page.
        //

        if (FlagOn( RecordLength, sizeof( ULONGLONG ) - 1 ) ||
            (RecordLength > RemainingPageBytes)) {

            ValidPage = FALSE;
            break;
        }

        //
        //  Now check that the Usn is the expected value.
        //

        if (UsnRecord->Usn != *NextUsn) {

            ValidPage = FALSE;
            break;
        }

        //
        //  Remember that we found a valid entry.
        //

        FoundEntry = TRUE;

        //
        //  If the user's Usn matches this one then remember his is valid.
        //

        if (!(*ValidUserStartUsn) &&
            (*NextUsn == *UserStartUsn)) {

            *ValidUserStartUsn = TRUE;
        }

        //
        //  Advance to the next record in the page.
        //

        UsnRecord = Add2Ptr( UsnRecord, RecordLength );

        RemainingPageBytes -= RecordLength;
        *NextUsn += RecordLength;
    }

    return ValidPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\viewsup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ViewSup.c

Abstract:

    This module implements the Index management routines for NtOfs

Author:

    Tom Miller      [TomM]          5-Jan-1996

Revision History:

--*/

#include "NtfsProc.h"
#include "Index.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VIEWSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('vFtN')

//
//  Temporary definitions for test
//

BOOLEAN NtOfsDoIndexTest = TRUE;
BOOLEAN NtOfsLeaveTestIndex = FALSE;
extern ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[];

//
//  Define a context for NtOfsReadRecords, which is primarily an IndexContext
//  and a copy of the last Key returned.
//

typedef struct _READ_CONTEXT {

    //
    //  IndexContext (cursor) for the enumeration.
    //

    INDEX_CONTEXT IndexContext;

    //
    //  The last key returned is allocated from paged pool.  We have to
    //  separately record how much is allocated, and how long the current
    //  key is using, the latter being in the KeyLength field of IndexKey.
    //  SmallKeyBuffer will store a small key in this structure without going
    //  to pool.
    //

    INDEX_KEY LastReturnedKey;
    ULONG AllocatedKeyLength;
    ULONG SmallKeyBuffer[3];

} READ_CONTEXT, *PREAD_CONTEXT;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsQueryViewIndex)
#pragma alloc_text(PAGE, NtOfsCreateIndex)
#pragma alloc_text(PAGE, NtOfsCloseIndex)
#pragma alloc_text(PAGE, NtOfsDeleteIndex)
#pragma alloc_text(PAGE, NtOfsFindRecord)
#pragma alloc_text(PAGE, NtOfsAddRecords)
#pragma alloc_text(PAGE, NtOfsDeleteRecords)
#pragma alloc_text(PAGE, NtOfsUpdateRecord)
#pragma alloc_text(PAGE, NtOfsReadRecords)
#pragma alloc_text(PAGE, NtOfsFreeReadContext)
#pragma alloc_text(PAGE, NtOfsFindLastRecord)
#pragma alloc_text(PAGE, NtOfsCollateUlong)
#pragma alloc_text(PAGE, NtOfsCollateUlongs)
#pragma alloc_text(PAGE, NtOfsCollateUnicode)
#pragma alloc_text(PAGE, NtOfsMatchAll)
#pragma alloc_text(PAGE, NtOfsMatchUlongExact)
#pragma alloc_text(PAGE, NtOfsMatchUlongsExact)
#pragma alloc_text(PAGE, NtOfsMatchUnicodeExpression)
#pragma alloc_text(PAGE, NtOfsMatchUnicodeString)
#pragma alloc_text(PAGE, NtOfsCollateSid)
#endif


NTFSAPI
NTSTATUS
NtOfsCreateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN UNICODE_STRING Name,
    IN CREATE_OPTIONS CreateOptions,
    IN ULONG DeleteCollationData,
    IN ULONG CollationRule,
    IN PCOLLATION_FUNCTION CollationFunction,
    IN PVOID CollationData OPTIONAL,
    OUT PSCB *Scb
    )

/*++

Routine Description:

    This routine may be called to create / open a view index
    within a given file for a given CollationRule.

Arguments:

    Fcb - File in which the index is to be created.

    Name - Name of the index for all related Scbs and attributes on disk.

    CreateOptions - Standard create flags.

    DeleteCollationData - Specifies 1 if the NtfsFreePool should be called
                          for CollationData when no longer required, or 0
                          if NtfsFreePool should never be called.

    CollationRule - A binary code to store in the index root to convey the
                    collation function to ChkDsk.  These rules are defined
                    in ntfs.h, and must have a one-to-one correspondence with
                    the CollationFunction below.

    CollationFunction - Function to be called to collate the index.

    CollationData - Data pointer to be passed to CollationFunction.

    Scb - Returns an Scb as handle for the index.

Return Value:

    STATUS_OBJECT_NAME_COLLISION -- if CreateNew and index already exists
    STATUS_OBJECT_NAME_NOT_FOUND -- if OpenExisting and index does not exist

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    BOOLEAN FoundAttribute;
    NTSTATUS Status = STATUS_SUCCESS;
    PBCB FileRecordBcb = NULL;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONGLONG FileRecordOffset;

    struct {
        INDEX_ROOT IndexRoot;
        INDEX_ENTRY EndEntry;
    } R;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    //
    //  First we will initialize the Index Root structure which is the value
    //  of the attribute we need to create.
    //

    RtlZeroMemory( &R, sizeof(R) );

    R.IndexRoot.CollationRule = CollationRule;
    R.IndexRoot.BytesPerIndexBuffer = NTOFS_VIEW_INDEX_BUFFER_SIZE;

    R.IndexRoot.BlocksPerIndexBuffer = (UCHAR)ClustersFromBytes( Fcb->Vcb,
                                                                   NTOFS_VIEW_INDEX_BUFFER_SIZE );

    if (NTOFS_VIEW_INDEX_BUFFER_SIZE < Fcb->Vcb->BytesPerCluster) {

        R.IndexRoot.BlocksPerIndexBuffer = NTOFS_VIEW_INDEX_BUFFER_SIZE / DEFAULT_INDEX_BLOCK_SIZE;
    }

    R.IndexRoot.IndexHeader.FirstIndexEntry = QuadAlign(sizeof(INDEX_HEADER));
    R.IndexRoot.IndexHeader.FirstFreeByte =
    R.IndexRoot.IndexHeader.BytesAvailable = QuadAlign(sizeof(INDEX_HEADER)) +
                                             QuadAlign(sizeof(INDEX_ENTRY));

    //
    //  Now we need to put in the special End entry.
    //

    R.EndEntry.Length = sizeof(INDEX_ENTRY);
    SetFlag( R.EndEntry.Flags, INDEX_ENTRY_END );


    //
    //  Now, just create the Index Root Attribute.
    //

    NtfsInitializeAttributeContext( &LocalContext );

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        //
        //  First see if the index already exists, by searching for the root
        //  attribute.
        //

        FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                    Fcb,
                                                    &Fcb->FileReference,
                                                    $INDEX_ROOT,
                                                    &Name,
                                                    NULL,
                                                    TRUE,
                                                    &LocalContext );

        //
        //  If it is not there, and the CreateOptions allow, then let's create
        //  the index root now.  (First cleaning up the attribute context from
        //  the lookup).
        //

        if (!FoundAttribute && (CreateOptions <= CREATE_OR_OPEN)) {

            NtfsCleanupAttributeContext( IrpContext, &LocalContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          $INDEX_ROOT,
                                          &Name,
                                          &R,
                                          sizeof(R),
                                          0,
                                          NULL,
                                          TRUE,
                                          &LocalContext );

        //
        //  If the index is already there, and we were asked to create it, then
        //  return an error.
        //

        } else if (FoundAttribute && (CreateOptions == CREATE_NEW)) {

            try_return( Status = STATUS_OBJECT_NAME_COLLISION );

        //
        //  If the index is not there, and we  were supposed to open existing, then
        //  return an error.
        //

        } else if (!FoundAttribute && (CreateOptions == OPEN_EXISTING)) {

            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        //
        //  Otherwise create/find the Scb and reference it.
        //

        *Scb = NtfsCreateScb( IrpContext, Fcb, $INDEX_ALLOCATION, &Name, FALSE, NULL );
        SetFlag( (*Scb)->ScbState, SCB_STATE_VIEW_INDEX );
        (*Scb)->ScbType.Index.CollationFunction = CollationFunction;

        //
        //  Handle the case where CollationData is to be deleted.
        //

        if (DeleteCollationData) {
            SetFlag((*Scb)->ScbState, SCB_STATE_DELETE_COLLATION_DATA);
            if ((*Scb)->ScbType.Index.CollationData != NULL) {
                NtfsFreePool(CollationData);
            } else {
                (*Scb)->ScbType.Index.CollationData = CollationData;
            }

        //
        //  Otherwise just jam the pointer the caller passed.
        //

        } else {
            (*Scb)->ScbType.Index.CollationData = CollationData;
        }

        NtfsIncrementCloseCounts( *Scb, TRUE, FALSE );

        //
        //  We have to set the view index present bit, so read it, save the
        //  old data and set the flag here.
        //

        NtfsPinMftRecord( IrpContext,
                          Fcb->Vcb,
                          &Fcb->FileReference,
                          FALSE,
                          &FileRecordBcb,
                          &FileRecord,
                          &FileRecordOffset );

        //
        //  If necessary, set the flag to indicate that this file will have
        //  no unnamed data stream and any attempt to open this file without
        //  specifying a named stream will fail, but without marking the
        //  volume corrupt.
        //

        if (!FlagOn( FileRecord->Flags, FILE_VIEW_INDEX_PRESENT )) {

            //
            //  We have to be very careful when using the InitialzeFileRecordSegment
            //  log record.  This action is applied unconditionally.  DoAction doesn't
            //  check the previous LSN in the page.  It may be garbage on a newly initialized
            //  file record.  We log the entire file record to avoid the case where we
            //  might overwrite a later Lsn with this earlier Lsn during restart.
            //

            //
            //  Log the existing file record as the undo action.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Fcb->Vcb->MftScb,
                                            FileRecordBcb,
                                            Noop,
                                            NULL,
                                            0,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Fcb->Vcb->BytesPerFileRecordSegment );

            SetFlag( FileRecord->Flags, FILE_VIEW_INDEX_PRESENT );

            //
            //  Log the new file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Fcb->Vcb->MftScb,
                                            FileRecordBcb,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Fcb->Vcb->BytesPerFileRecordSegment );
        }

    try_exit: NOTHING;

    } finally {
        NtfsCleanupAttributeContext( IrpContext, &LocalContext );

        NtfsUnpinBcb( IrpContext, &FileRecordBcb );

        NtfsReleaseFcb( IrpContext, Fcb );
    }

    return Status;
}


NTFSAPI
VOID
NtOfsCloseIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to close a previously returned handle on a view index.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

Return Value:

    None.

--*/

{
    ASSERT( NtfsIsExclusiveFcb( Scb->Fcb ));

    NtfsDecrementCloseCounts( IrpContext, Scb, NULL, TRUE, FALSE, FALSE, NULL );
}


NTFSAPI
VOID
NtOfsDeleteIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to delete an index.

Arguments:

    Fcb - Supplies an Fcb as the previously returned object handle for the file

    Scb - Supplies an Scb as the previously returned handle for this index.

Return Value:

    None (Deleting a nonexistant index is benign).

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    BOOLEAN FoundAttribute;

    ASSERT_IRP_CONTEXT( IrpContext );

    ASSERT(($BITMAP - $INDEX_ALLOCATION) == ($INDEX_ALLOCATION - $INDEX_ROOT));

    PAGED_CODE();

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  First see if there is some index allocation, and if so truncate it
        //  away allowing this operation to be broken up.
        //

        NtfsInitializeAttributeContext( &LocalContext );

        if (NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $INDEX_ALLOCATION,
                                       &Scb->AttributeName,
                                       NULL,
                                       FALSE,
                                       &LocalContext )) {

            NtfsCreateInternalAttributeStream( IrpContext, Scb, TRUE, NULL );

            NtfsDeleteAllocation( IrpContext, NULL, Scb, 0, MAXLONGLONG, TRUE, TRUE );
        }

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );

        for (AttributeTypeCode = $INDEX_ROOT;
             AttributeTypeCode <= $BITMAP;
             AttributeTypeCode += ($INDEX_ALLOCATION - $INDEX_ROOT)) {

            //
            //  Initialize the attribute context on each trip through the loop.
            //

            NtfsInitializeAttributeContext( &LocalContext );

            //
            //  First see if the index already exists, by searching for the root
            //  attribute.
            //

            FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                        Fcb,
                                                        &Fcb->FileReference,
                                                        AttributeTypeCode,
                                                        &Scb->AttributeName,
                                                        NULL,
                                                        TRUE,
                                                        &LocalContext );

            //
            //  Loop while we see the right records.
            //

            while (FoundAttribute) {

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &LocalContext );

                FoundAttribute = NtfsLookupNextAttributeByName( IrpContext,
                                                                Fcb,
                                                                AttributeTypeCode,
                                                                &Scb->AttributeName,
                                                                TRUE,
                                                                &LocalContext );
            }

            NtfsCleanupAttributeContext( IrpContext, &LocalContext );
        }

        SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &LocalContext );

        NtfsReleaseScb( IrpContext, Scb );
    }
}


NTFSAPI
NTSTATUS
NtOfsFindRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_KEY IndexKey,
    OUT PINDEX_ROW IndexRow,
    OUT PMAP_HANDLE MapHandle,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to find the first occurrence of a key in an index,
    and return cached information which may can accelerate the update on the data
    for that key if the index buffer is not changed.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    IndexKey - Supplies the key to find.

    IndexRow - Returns a description of the Key and Data *in place*, for read-only
               access, valid only until the Bcb is unpinned.  (Neither key nor
               data may be modified in place!)

    MapHandle - Returns a map handle for accessing the key and data directly.

    QuickIndexHint - Supplies a previously returned hint, or all zeros on first use.
                     Returns location information which may be held an arbitrary
                     amount of time, which can accelerate a subsequent call to
                     NtOfsUpdateRecord for the data in this key, iff changes to
                     the index do not prohibit use of this hint.

Return Value:

    STATUS_SUCCESS -- if operation was successful.
    STATUS_NO_MATCH -- if the specified key does not exist.

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_LOOKUP_STACK Sp;
    PINDEX_ENTRY IndexEntry;
    NTSTATUS Status;
    PQUICK_INDEX QuickIndex = (PQUICK_INDEX)QuickIndexHint;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    NtfsInitializeIndexContext( &IndexContext );

    ASSERT_SHARED_SCB( Scb );

    try {

        //
        //  Use the second location in the index context to perform the
        //  read.
        //

        Sp =
        IndexContext.Current = IndexContext.Base + 1;

        //
        //  If the index entry for this filename hasn't moved we can go
        //  directly to the location in the buffer.  For this to be the case the
        //  following must be true.
        //
        //      - The entry must already be in an index buffer (BufferOffset test)
        //      - The index stream may not have been truncated (ChangeCount test)
        //      - The Lsn in the page can't have changed
        //

        if (ARGUMENT_PRESENT( QuickIndexHint ) &&
            (QuickIndex->BufferOffset != 0) &&
            (QuickIndex->ChangeCount == Scb->ScbType.Index.ChangeCount)) {

            ReadIndexBuffer( IrpContext,
                             Scb,
                             QuickIndex->IndexBlock,
                             FALSE,
                             Sp );

            //
            //  If the Lsn matches then we can use this buffer directly.
            //

            if (QuickIndex->CapturedLsn.QuadPart == Sp->CapturedLsn.QuadPart) {

                Sp->IndexEntry = (PINDEX_ENTRY) Add2Ptr( Sp->StartOfBuffer,
                                                         QuickIndex->BufferOffset );

            //
            //  Otherwise we need to reinitialize the index context and take
            //  the long path below.
            //

            } else {

                NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            }
        }

        //
        //  If we did not get the index entry via the hint, get it now.
        //

        if (Sp->Bcb == NULL) {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 IndexKey,
                                 &IndexContext );

            //
            //  See if there is an actual match.
            //

            if (!FindNextIndexEntry( IrpContext,
                                     Scb,
                                     IndexKey,
                                     FALSE,
                                     FALSE,
                                     &IndexContext,
                                     FALSE,
                                     NULL )) {

                try_return( Status = STATUS_NO_MATCH );
            }
        }

        //
        //  Basic consistency check
        //

        IndexEntry = IndexContext.Current->IndexEntry;
        if ((IndexEntry->DataOffset + IndexEntry->DataLength > IndexEntry->Length) ||
            (IndexEntry->AttributeLength + sizeof( INDEX_ENTRY ) > IndexEntry->Length)) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }


        //
        //  If we found the key in the base, then return the Bcb from the
        //  attribute context and return no hint (BufferOffset = 0).
        //

        if (IndexContext.Current == IndexContext.Base) {

            MapHandle->Buffer = NULL;
            MapHandle->Bcb = NtfsFoundBcb(&IndexContext.AttributeContext);
            NtfsFoundBcb(&IndexContext.AttributeContext) = NULL;

            if (ARGUMENT_PRESENT( QuickIndexHint )) {
                QuickIndex->BufferOffset = 0;
            }

        //
        //  If we found the key in an index buffer, then return the Bcb from
        //  the lookup stack, and record the hint for the caller.
        //

        } else {

            Sp = IndexContext.Current;

            MapHandle->Buffer = Sp->StartOfBuffer;
            MapHandle->Bcb = Sp->Bcb;
            Sp->Bcb = NULL;

            if (ARGUMENT_PRESENT( QuickIndexHint )) {
                QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
                QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
                QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
                QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
            }
        }

        //
        //  Return the IndexRow described directly in the buffer.
        //

        IndexRow->KeyPart.Key = (IndexEntry + 1);
        IndexRow->KeyPart.KeyLength = IndexEntry->AttributeLength;
        IndexRow->DataPart.Data = Add2Ptr( IndexEntry, IndexEntry->DataOffset );
        IndexRow->DataPart.DataLength = IndexEntry->DataLength;

    try_exit: NOTHING;

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

    }

    return Status;
}


NTFSAPI
NTSTATUS
NtOfsFindLastRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_KEY MaxIndexKey,
    OUT PINDEX_ROW IndexRow,
    OUT PMAP_HANDLE MapHandle
    )

/*++

Routine Description:

    This routine may be called to find the highest key in an index.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    MaxIndexKey - Supplies the maximum possible key value (such as MAXULONG, etc.),
                  and this key must not actually be in use!

    IndexRow - Returns a description of the Key and Data *in place*, for read-only
               access, valid only until the Bcb is unpinned.  (Neither key nor
               data may be modified in place!)

    MapHandle - Returns a map handle for accessing the key and data directly.

Return Value:

    STATUS_SUCCESS -- if operation was successful.
    STATUS_NO_MATCH -- if the specified key does not exist (index is empty).

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_LOOKUP_STACK Sp;
    PINDEX_ENTRY IndexEntry, NextIndexEntry;
    NTSTATUS Status;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    NtfsInitializeIndexContext( &IndexContext );

    NtfsAcquireSharedScb( IrpContext, Scb );

    try {

        //
        //  Slide down the "right" side of the tree.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             MaxIndexKey,
                             &IndexContext );

        //
        //  If this happens, the index must be empty.
        //

        Sp = IndexContext.Current;
        IndexEntry = NtfsFirstIndexEntry(Sp->IndexHeader);
        if (FlagOn(IndexEntry->Flags, INDEX_ENTRY_END)) {
            try_return( Status = STATUS_NO_MATCH );
        }

        //
        //  If we found the key in the base, then return the Bcb from the
        //  attribute context and return no hint (BufferOffset = 0).
        //

        if (IndexContext.Current == IndexContext.Base) {

            MapHandle->Bcb = NtfsFoundBcb(&IndexContext.AttributeContext);
            NtfsFoundBcb(&IndexContext.AttributeContext) = NULL;

        //
        //  If we found the key in an index buffer, then return the Bcb from
        //  the lookup stack, and record the hint for the caller.
        //

        } else {


            MapHandle->Bcb = Sp->Bcb;
            Sp->Bcb = NULL;
        }

        //
        //  Complete the MapHandle to disallow pinning.
        //

        MapHandle->Buffer = NULL;

        //
        //  Now rescan the last buffer to return the second to last index entry,
        //  if there is one.
        //

        NextIndexEntry = IndexEntry;
        do {
            IndexEntry = NextIndexEntry;

            if (IndexEntry->Length == 0) {
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
            NextIndexEntry = NtfsNextIndexEntry(IndexEntry);
            NtfsCheckIndexBound( NextIndexEntry, Sp->IndexHeader );

        } while (!FlagOn(NextIndexEntry->Flags, INDEX_ENTRY_END));

        //
        //  Return the IndexRow described directly in the buffer.
        //

        IndexRow->KeyPart.Key = (IndexEntry + 1);
        IndexRow->KeyPart.KeyLength = IndexEntry->AttributeLength;
        IndexRow->DataPart.Data = Add2Ptr( IndexEntry, IndexEntry->DataOffset );
        IndexRow->DataPart.DataLength = IndexEntry->DataLength;

    try_exit: NOTHING;

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

        NtfsReleaseScb( IrpContext, Scb );
    }

    return Status;
}


NTFSAPI
VOID
NtOfsAddRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ULONG Count,
    IN PINDEX_ROW IndexRow,
    IN ULONG SequentialInsertMode
    )

/*++

Routine Description:

    This routine may be called to add one or more records to an index.

    If SequentialInsertMode is nonzero, this is a hint to the index package
    to keep all BTree buffers as full as possible, by splitting as close to
    the end of the buffer as possible.  If specified as zero, random inserts
    are assumed, and buffers are always split in the middle for better balance.


Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    Count - Supplies the number of records being added.

    IndexRow - Supplies an array of Count entries, containing the Keys and Data to add.

    SequentialInsertMode - If specified as nozero, the implementation may choose to
                           split all index buffers at the end for maximum fill.

Return Value:

    None.

Raises:

    STATUS_DUPLICATE_NAME -- if the specified key already exists.

--*/

{
    INDEX_CONTEXT IndexContext;
    struct {
        INDEX_ENTRY IndexEntry;
        PVOID Key;
        PVOID Data;
    } IE;
    ULONG i;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    UNREFERENCED_PARAMETER(SequentialInsertMode);

    PAGED_CODE();

    NtfsInitializeIndexContext( &IndexContext );

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  Loop to add all entries
        //

        for (i = 0; i < Count; i++) {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 &IndexRow->KeyPart,
                                 &IndexContext );

            //
            //  See if there is an actual match.
            //

            if (FindNextIndexEntry( IrpContext,
                                    Scb,
                                    &IndexRow->KeyPart,
                                    FALSE,
                                    FALSE,
                                    &IndexContext,
                                    FALSE,
                                    NULL )) {

                NtfsRaiseStatus( IrpContext, STATUS_DUPLICATE_NAME, NULL, NULL );
            }

            //
            //  Initialize the Index Entry in pointer form.
            //
            //  Note that the final index entry ends up looking like this:
            //
            //      (IndexEntry)(Key)(Data)
            //
            //  where all fields are long-aligned and:
            //
            //      Key is at IndexEntry + sizeof(INDEX_ENTRY), and of length AttributeLength
            //      Data is at IndexEntry + DataOffset and of length DataLength
            //

            IE.IndexEntry.AttributeLength = (USHORT)IndexRow->KeyPart.KeyLength;

            IE.IndexEntry.DataOffset = (USHORT)(sizeof(INDEX_ENTRY) + LongAlign( IndexRow->KeyPart.KeyLength ));

            IE.IndexEntry.DataLength = (USHORT)IndexRow->DataPart.DataLength;
            IE.IndexEntry.ReservedForZero = 0;

            IE.IndexEntry.Length = (USHORT)(QuadAlign(IE.IndexEntry.DataOffset + IndexRow->DataPart.DataLength));

            IE.IndexEntry.Flags = INDEX_ENTRY_POINTER_FORM;
            IE.IndexEntry.Reserved = 0;
            IE.Key = IndexRow->KeyPart.Key;
            IE.Data = IndexRow->DataPart.Data;

            //
            //  Now add it to the index.  We can only add to a leaf, so force our
            //  position back to the correct spot in a leaf first.
            //

            IndexContext.Current = IndexContext.Top;
            AddToIndex( IrpContext, Scb, (PINDEX_ENTRY)&IE, &IndexContext, NULL, FALSE );
            NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            IndexRow += 1;
        }

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

        NtfsReleaseScb( IrpContext, Scb );
    }
}


NTFSAPI
VOID
NtOfsDeleteRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ULONG Count,
    IN PINDEX_KEY IndexKey
    )

/*++

Routine Description:

    This routine may be called to delete one or more records from an index.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    Count - Supplies the number of records being deleted.

    IndexKey - Supplies an array of Count entries, containing the Keys to be deleted.

Return Value:

    None. (This call is benign if any records do not exist.)

--*/

{
    INDEX_CONTEXT IndexContext;
    ULONG i;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    NtfsInitializeIndexContext( &IndexContext );

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  Loop to add all entries
        //

        for (i = 0; i < Count; i++) {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 IndexKey,
                                 &IndexContext );

            //
            //  See if there is an actual match.
            //

            if (FindNextIndexEntry( IrpContext,
                                    Scb,
                                    IndexKey,
                                    FALSE,
                                    FALSE,
                                    &IndexContext,
                                    FALSE,
                                    NULL )) {

                //
                //  Delete it.
                //

                DeleteFromIndex( IrpContext, Scb, &IndexContext );
            }

            NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            IndexKey += 1;
        }

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

        NtfsReleaseScb( IrpContext, Scb );
    }
}


NTFSAPI
VOID
NtOfsUpdateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ULONG Count,
    IN PINDEX_ROW IndexRow,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL,
    IN OUT PMAP_HANDLE MapHandle OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to update the data portion of a record in an index.

    If QuickIndexHint is specified, then the update may occur by directly accessing
    the buffer containing the specified key, iff other changes to the index do not
    prevent that.  If changes prevent the quick update, then the record is looked
    up by key in order to perform the data update.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    Count - Supplies the count of updates described in IndexRow.  For counts
            greater than 1, QuickIndexHint and MapHandle must not be supplied.

    IndexRow - Supplies the key to be updated and the new data for that key.

    QuickIndexHint - Supplies a optional quick index for this row returned from a previous
                     call to NtOfsFindRecord, updated on return.

    MapHandle - Supplies an optional MapHandle to accompany the QuickIndex.  If MapHandle
                is supplied, then the QuickIndexHint must be guaranteed valid.  MapHandle
                is updated (pinned) on return.

                MapHandle is ignored if QuickIndexHint is not specified.

Return Value:

    None.

Raises:

    STATUS_INFO_LENGTH_MISMATCH -- if the specified data is a different length from the
                                   data in the key.
    STATUS_NO_MATCH -- if the specified key does not exist.

--*/

{
    INDEX_CONTEXT IndexContext;
    PQUICK_INDEX QuickIndex = (PQUICK_INDEX)QuickIndexHint;
    PVOID DataInIndex;
    PINDEX_ENTRY IndexEntry;
    PVCB Vcb = Scb->Vcb;
    PINDEX_LOOKUP_STACK Sp;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );

    ASSERT(Count != 0);

    PAGED_CODE();

    NtfsInitializeIndexContext( &IndexContext );

    try {

        //
        //  If the index entry for this filename hasn't moved we can go
        //  directly to the location in the buffer.  For this to be the case the
        //  following must be true.
        //
        //      - The entry must already be in an index buffer (BufferOffset test)
        //      - The index stream may not have been truncated (ChangeCount test)
        //      - The Lsn in the page can't have changed
        //

        if (ARGUMENT_PRESENT( QuickIndexHint ) &&
            (QuickIndex->BufferOffset != 0) &&
            (QuickIndex->ChangeCount == Scb->ScbType.Index.ChangeCount)) {

            ASSERT(Count == 1);

            //
            //  Use the top location in the index context to perform the
            //  read.
            //

            Sp = IndexContext.Base;

            //
            //  If we have a MapHandle already, we do not need to read the
            //  IndexBuffer.
            //

            if (ARGUMENT_PRESENT(MapHandle)) {

                IndexBuffer = MapHandle->Buffer;
                Sp->Bcb = MapHandle->Bcb;
                MapHandle->Bcb = NULL;
                Sp->CapturedLsn.QuadPart = QuickIndex->CapturedLsn.QuadPart;

            } else {

                ReadIndexBuffer( IrpContext,
                                 Scb,
                                 QuickIndex->IndexBlock,
                                 FALSE,
                                 Sp );

                IndexBuffer = Sp->StartOfBuffer;
            }

            //
            //  If the Lsn matches then we can use this buffer directly.
            //

            if (QuickIndex->CapturedLsn.QuadPart == Sp->CapturedLsn.QuadPart) {

                IndexEntry = (PINDEX_ENTRY) Add2Ptr( IndexBuffer, QuickIndex->BufferOffset );

                if (IndexEntry->DataLength < IndexRow->DataPart.DataLength) {
                    NtfsRaiseStatus( IrpContext, STATUS_INFO_LENGTH_MISMATCH, NULL, NULL );
                }

                DataInIndex = Add2Ptr( IndexEntry, IndexEntry->DataOffset );

                //
                //  Pin the index buffer
                //

                NtfsPinMappedData( IrpContext,
                                   Scb,
                                   LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   &Sp->Bcb );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                //
                //  Write the log record, but do not update the IndexBuffer Lsn,
                //  since nothing moved and we don't want to force index contexts
                //  to have to rescan.
                //
                //  Indexbuffer->Lsn =
                //

                //  ASSERT(Scb->ScbType.Index.ClustersPerIndexBuffer != 0);

                NtfsWriteLog( IrpContext,
                              Scb,
                              Sp->Bcb,
                              UpdateRecordDataAllocation,
                              IndexRow->DataPart.Data,
                              IndexRow->DataPart.DataLength,
                              UpdateRecordDataAllocation,
                              DataInIndex,
                              IndexRow->DataPart.DataLength,
                              LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                              0,
                              QuickIndex->BufferOffset,
                              Scb->ScbType.Index.BytesPerIndexBuffer );

                //
                //  Now call the Restart routine to do it.
                //

                NtOfsRestartUpdateDataInIndex( IndexEntry,
                                               IndexRow->DataPart.Data,
                                               IndexRow->DataPart.DataLength );

                //
                //  If there is a MapHandle, we must update the Bcb pointer.
                //

                if (ARGUMENT_PRESENT(MapHandle)) {

                    MapHandle->Bcb = Sp->Bcb;
                    Sp->Bcb = NULL;
                }

                leave;

            //
            //  Otherwise we need to unpin the Bcb and take
            //  the long path below.
            //

            } else {

                ASSERT(!ARGUMENT_PRESENT(MapHandle));
                NtfsUnpinBcb( IrpContext, &Sp->Bcb );
            }
        }

        //
        //  Loop to apply all updates.
        //

        do {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 &IndexRow->KeyPart,
                                 &IndexContext );

            //
            //  See if there is an actual match.
            //

            if (FindNextIndexEntry( IrpContext,
                                    Scb,
                                    &IndexRow->KeyPart,
                                    FALSE,
                                    FALSE,
                                    &IndexContext,
                                    FALSE,
                                    NULL )) {

                //
                //  Point to the index entry and the data within it.
                //

                IndexEntry = IndexContext.Current->IndexEntry;

                if (IndexEntry->DataLength < IndexRow->DataPart.DataLength) {
                    NtfsRaiseStatus( IrpContext, STATUS_INFO_LENGTH_MISMATCH, NULL, NULL );
                }

                DataInIndex = Add2Ptr( IndexEntry, IndexEntry->DataOffset );

                //
                //  Now pin the entry.
                //

                if (IndexContext.Current == IndexContext.Base) {

                    PFILE_RECORD_SEGMENT_HEADER FileRecord;
                    PATTRIBUTE_RECORD_HEADER Attribute;
                    PATTRIBUTE_ENUMERATION_CONTEXT Context = &IndexContext.AttributeContext;

                    //
                    //  Pin the root
                    //

                    NtfsPinMappedAttribute( IrpContext,
                                            Vcb,
                                            Context );

                    //
                    //  Write a log record to change our ParentIndexEntry.
                    //

                    FileRecord = NtfsContainingFileRecord(Context);
                    Attribute = NtfsFoundAttribute(Context);

                    //
                    //  Write the log record, but do not update the FileRecord Lsn,
                    //  since nothing moved and we don't want to force index contexts
                    //  to have to rescan.
                    //
                    //  FileRecord->Lsn =
                    //

                    NtfsWriteLog( IrpContext,
                                  Vcb->MftScb,
                                  NtfsFoundBcb(Context),
                                  UpdateRecordDataRoot,
                                  IndexRow->DataPart.Data,
                                  IndexRow->DataPart.DataLength,
                                  UpdateRecordDataRoot,
                                  DataInIndex,
                                  IndexRow->DataPart.DataLength,
                                  NtfsMftOffset( Context ),
                                  (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                                  (ULONG)((PCHAR)IndexEntry - (PCHAR)Attribute),
                                  Vcb->BytesPerFileRecordSegment );

                    if (ARGUMENT_PRESENT( QuickIndexHint )) {

                        ASSERT( Count == 1 );
                        QuickIndex->BufferOffset = 0;
                    }

                } else {

                    Sp = IndexContext.Current;
                    IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

                    //
                    //  Pin the index buffer
                    //

                    NtfsPinMappedData( IrpContext,
                                       Scb,
                                       LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                       Scb->ScbType.Index.BytesPerIndexBuffer,
                                       &Sp->Bcb );

                    //
                    //  Write a log record to change our ParentIndexEntry.
                    //

                    //
                    //  Write the log record, but do not update the IndexBuffer Lsn,
                    //  since nothing moved and we don't want to force index contexts
                    //  to have to rescan.
                    //
                    //  Indexbuffer->Lsn =
                    //

                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  Sp->Bcb,
                                  UpdateRecordDataAllocation,
                                  IndexRow->DataPart.Data,
                                  IndexRow->DataPart.DataLength,
                                  UpdateRecordDataAllocation,
                                  DataInIndex,
                                  IndexRow->DataPart.DataLength,
                                  LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                  0,
                                  (ULONG)((PCHAR)Sp->IndexEntry - (PCHAR)IndexBuffer),
                                  Scb->ScbType.Index.BytesPerIndexBuffer );

                    if (ARGUMENT_PRESENT( QuickIndexHint )) {

                        ASSERT( Count == 1 );
                        QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
                        QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
                        QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
                        QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
                    }
                }

                //
                //  Now call the Restart routine to do it.
                //

                NtOfsRestartUpdateDataInIndex( IndexEntry,
                                               IndexRow->DataPart.Data,
                                               IndexRow->DataPart.DataLength );

            //
            //  If the file name is not in the index, this is a bad file.
            //

            } else {

                NtfsRaiseStatus( IrpContext, STATUS_NO_MATCH, NULL, NULL );
            }

            //
            //  Get ready for the next pass through.
            //

            NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            IndexRow += 1;

        } while (--Count);

    } finally {

        NtfsCleanupIndexContext( IrpContext, &IndexContext );

    }

    return;
}


NTFSAPI
NTSTATUS
NtOfsReadRecords (
        IN PIRP_CONTEXT IrpContext,
        IN PSCB Scb,
        IN OUT PREAD_CONTEXT *ReadContext,
        IN PINDEX_KEY IndexKey OPTIONAL,
        IN PMATCH_FUNCTION MatchFunction,
        IN PVOID MatchData,
        IN OUT ULONG *Count,
        OUT PINDEX_ROW Rows,
        IN ULONG BufferLength,
        OUT PVOID Buffer
        )

/*++

Routine Description:

    This routine may be called to enumerate rows in an index, in collated
    order.  It only returns records accepted by the match function.

    IndexKey may be specified at any time to start a new search from IndexKey,
    and IndexKey must be specified on the first call for a given IrpContext
    (and *ReadContext must be NULL).

    The read terminates when either *Count records have been returned, or
    BufferLength has been exhausted, or there are no more matching records.

    NtOfsReadRecords will seek to the appropriate point in the BTree (as defined
    by the IndexKey or saved position and the CollateFunction) and begin calling
    MatchFunction for each record.  It continues doing this while MatchFunction
    returns STATUS_SUCCESS.  If MatchFunction returns STATUS_NO_MORE_MATCHES,
    NtOfsReadRecords will cache this result and not call MatchFunction again until
    called with a non-NULL IndexKey.

    Note that this call is self-synchronized, such that successive calls to
    the routine are guaranteed to make progress through the index and to return
    items in Collation order, in spite of Add and Delete record calls being
    interspersed with Read records calls.

Arguments:

    Scb - Supplies an Scb as the previously returned handle for this index.

    ReadContext - On the first call this must supply a pointer to NULL.  On
                  return a pointer to a private context structure is returned,
                  which must then be supplied on all subsequent calls.  This
                  structure must be eventually be freed via NtOfsFreeReadContext.

    IndexKey - If specified, supplies the key from which the enumeration is to
               start/resume.  It must be specified on the first call when *ReadContext
               is NULL.

    MatchFunction - Supplies the MatchFunction to be called to determine which
                    rows to return.

    MatchData - Supplies the MatchData to be specified on each call to the MatchFunction.

    Count - Supplies the count of how many rows may be received, and returns the
            number of rows actually being returned.

    Rows - Returns the Count row descriptions.

    BufferLength - Supplies the length of the buffer in bytes, into which the
                   row keys and data are copied upon return.

    Buffer - Supplies the buffer into which the rows may be copied.

Return Value:

    STATUS_SUCCESS -- if operation was successful.
    STATUS_NO_MATCH -- if there is no match for the specified IndexKey.
    STATUS_NO_MORE_MATCHES -- if a match is returned or previously returned,
                              but there are no more matches.

--*/

{
    PINDEX_CONTEXT IndexContext;
    PINDEX_ENTRY IndexEntry;
    ULONG LengthToCopy;
    BOOLEAN MustRestart;
    ULONG BytesRemaining = BufferLength;
    ULONG ReturnCount = 0;
    NTSTATUS Status;
    BOOLEAN NextFlag;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    //
    //  On the first lookup, their must be a key.
    //

    ASSERT((IndexKey != NULL) || (*ReadContext != NULL));

    //
    //  Everything must be Ulong aligned and sized.
    //

    ASSERT(IsLongAligned(Buffer));
    ASSERT(IsLongAligned(BufferLength));

    Status = STATUS_SUCCESS;
    NextFlag = FALSE;

    //
    //  Pick up the IndexContext, allocating one if we need to.
    //

    if (*ReadContext == NULL) {
        *ReadContext = NtfsAllocatePool(PagedPool, sizeof(READ_CONTEXT) );
        NtfsInitializeIndexContext( &(*ReadContext)->IndexContext );
        (*ReadContext)->LastReturnedKey.Key = &(*ReadContext)->SmallKeyBuffer[0];
        (*ReadContext)->LastReturnedKey.KeyLength = 0;
        (*ReadContext)->AllocatedKeyLength = sizeof(READ_CONTEXT) -
                                             FIELD_OFFSET(READ_CONTEXT, SmallKeyBuffer[0]);
    }

    IndexContext = &(*ReadContext)->IndexContext;

    //
    //  Store the MatchFunction and Data in the IndexContext, for the enumerations.
    //

    IndexContext->MatchFunction = MatchFunction;
    IndexContext->MatchData = MatchData;

    NtfsAcquireSharedScb( IrpContext, Scb );

    try {

        //
        //  If a Key was passed, position to the first possible match.
        //

        if (ARGUMENT_PRESENT(IndexKey)) {

             FindFirstIndexEntry( IrpContext,
                                  Scb,
                                  IndexKey,
                                  IndexContext );

        //
        //  Otherwise return here if we hit the end of the matches last time.
        //

        } else if ((*ReadContext)->LastReturnedKey.KeyLength == 0) {

            try_return( Status = STATUS_NO_MORE_MATCHES );
        }

        //
        //  Loop while we still have space to store rows.
        //

        while (ReturnCount <= *Count) {

            //
            //  If we're already at the end, don't call FindNextIndexEntry again.
            //

            ASSERT(ARGUMENT_PRESENT(IndexKey) ||
                   ((*ReadContext)->LastReturnedKey.KeyLength != 0));

            //
            //  See if there is an actual match.
            //

            if (!FindNextIndexEntry( IrpContext,
                                     Scb,
                                     NULL,      //  Not needed because of Match Function
                                     TRUE,
                                     FALSE,
                                     IndexContext,
                                     NextFlag,
                                     &MustRestart )) {

                //
                //  First handle the restart case by resuming from the last
                //  key returned, and skip that one.
                //

                if (MustRestart) {

                    ASSERT(!ARGUMENT_PRESENT(IndexKey));

                    NtfsReinitializeIndexContext( IrpContext, IndexContext );

                    FindFirstIndexEntry( IrpContext,
                                         Scb,
                                         &(*ReadContext)->LastReturnedKey,
                                         IndexContext );

                    //
                    //  Set NextFlag to TRUE, so we can go back and skip
                    //  the key we resumed on.
                    //

                    NextFlag = TRUE;
                    continue;
                }

                //
                //  No (more) entries - remember that the enumeration is done.
                //

                (*ReadContext)->LastReturnedKey.KeyLength = 0;

                //
                //  Return the appropriate code based on whether we have returned
                //  any matches yet or not.
                //

                if ((ReturnCount == 0) && ARGUMENT_PRESENT(IndexKey)) {
                    Status = STATUS_NO_MATCH;
                } else {
                    Status = STATUS_NO_MORE_MATCHES;
                }

                try_return(Status);
            }

            //
            //  We always need to go one beyond the one we can return to keep
            //  all resume cases the same, so now is the time to get out if the
            //  count is finished.
            //

            if (ReturnCount == *Count) {
                break;
            }

            //
            //  Now we must always move to the next.
            //

            NextFlag = TRUE;

            //
            //  First try to copy the key.
            //

            IndexEntry = IndexContext->Current->IndexEntry;

            LengthToCopy = IndexEntry->AttributeLength;
            if (LengthToCopy > BytesRemaining) {
                break;
            }

            RtlCopyMemory( Buffer, IndexEntry + 1, LengthToCopy );
            Rows->KeyPart.Key = Buffer;
            Rows->KeyPart.KeyLength = LengthToCopy;
            LengthToCopy = LongAlign(LengthToCopy);
            Buffer = Add2Ptr( Buffer, LengthToCopy );
            BytesRemaining -= LengthToCopy;

            //
            //  Now try to copy the data.
            //

            LengthToCopy = IndexEntry->DataLength;
            if (LengthToCopy > BytesRemaining) {
                break;
            }

            RtlCopyMemory( Buffer, Add2Ptr(IndexEntry, IndexEntry->DataOffset), LengthToCopy );
            Rows->DataPart.Data = Buffer;
            Rows->DataPart.DataLength = LengthToCopy;
            LengthToCopy = LongAlign(LengthToCopy);
            Buffer = Add2Ptr( Buffer, LengthToCopy );
            BytesRemaining -= LengthToCopy;

            //
            //  Capture this key before looping back.
            //
            //  First see if there is enough space.
            //

            if (Rows->KeyPart.KeyLength > (*ReadContext)->AllocatedKeyLength) {

                PVOID NewBuffer;

                //
                //  Allocate a new buffer.
                //

                LengthToCopy = LongAlign(Rows->KeyPart.KeyLength + 16);
                NewBuffer = NtfsAllocatePool(PagedPool, LengthToCopy );

                //
                //  Delete old key buffer?
                //

                if ((*ReadContext)->LastReturnedKey.Key != &(*ReadContext)->SmallKeyBuffer[0]) {
                    NtfsFreePool( (*ReadContext)->LastReturnedKey.Key );
                }

                (*ReadContext)->LastReturnedKey.Key = NewBuffer;
                (*ReadContext)->AllocatedKeyLength = LengthToCopy;
            }

            RtlCopyMemory( (*ReadContext)->LastReturnedKey.Key,
                           Rows->KeyPart.Key,
                           Rows->KeyPart.KeyLength );

            (*ReadContext)->LastReturnedKey.KeyLength = Rows->KeyPart.KeyLength;

            Rows += 1;
            ReturnCount += 1;
        }

    try_exit: NOTHING;

    } finally {

#ifdef BENL_DBG
        ASSERT( (*ReadContext)->AllocatedKeyLength >= (*ReadContext)->LastReturnedKey.KeyLength );
#endif

        NtfsReinitializeIndexContext( IrpContext, IndexContext );

        NtfsReleaseScb( IrpContext, Scb );
    }

    *Count = ReturnCount;

    //
    //  If we are already returning something, but we got an error, change it
    //  to success to return what we have.  Then we may or may not get this error
    //  again anyway when we are called back.  This loop is currently not designed
    //  to resume correctly in all cases if there are already items returned.
    //

    if (ReturnCount != 0) {
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTFSAPI
VOID
NtOfsFreeReadContext (
        IN PREAD_CONTEXT ReadContext
        )

/*++

Routine Description:

    This routine is called to free an ReadContext created by NtOfsReadRecords.

Arguments:

    ReadContext - Supplies the context to free.

Return Value:

    STATUS_SUCCESS -- if operation was successful.

--*/

{
    PAGED_CODE();

    if (ReadContext->LastReturnedKey.Key != NULL &&
        ReadContext->LastReturnedKey.Key != &ReadContext->SmallKeyBuffer[0]) {
        NtfsFreePool( ReadContext->LastReturnedKey.Key );
    }

    if (ReadContext->IndexContext.Base != ReadContext->IndexContext.LookupStack) {
        NtfsFreePool( ReadContext->IndexContext.Base );
    }

    NtfsFreePool( ReadContext );
}


NTSTATUS
NtfsQueryViewIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query view index operation.  It is responsible
    for either completing or enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

    Vcb - Supplies its Vcb

    Scb - Supplies its Scb

    Ccb - Supplies its Ccb

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    PUCHAR Buffer;
    CLONG UserBufferLength;

    ULONG BaseLength;
    ULONG SidLength;

    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN GotEntry;
    BOOLEAN LastPass;
    BOOLEAN FirstPass = TRUE;

    ULONG NextEntry;
    ULONG LastEntry;
    ULONG VariableLength;
    PVOID CurrentEntryBuffer = NULL;

    PINDEX_KEY IndexKey;
    ULONG IndexKeyLength = 0;

    PREAD_CONTEXT ReadContext = NULL;
    PFILE_OBJECTID_INFORMATION ObjIdInfoPtr;

    PFILE_QUOTA_INFORMATION QuotaInfoPtr = NULL;
    PQUOTA_USER_DATA QuotaUserData;

    PFILE_REPARSE_POINT_INFORMATION ReparsePointInfoPtr;

    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN CcbAcquired = FALSE;
    BOOLEAN FirstQueryForThisCcb = FALSE;
    BOOLEAN IndexKeyAllocated = FALSE;
    BOOLEAN IndexKeyKeyAllocated = FALSE;
    BOOLEAN AccessingUserBuffer = FALSE;

    ULONG ReadRecordBuffer[20];

    ULONG VariableBytesToCopy = 0;

    BOOLEAN AnotherEntryWillFit = TRUE;
    BOOLEAN AtEndOfIndex = FALSE;
    PUNICODE_STRING RestartKey = NULL;

    ULONG BytesRemainingInBuffer;

    NTSTATUS ReadRecordStatus;
    ULONG Count;
    INDEX_ROW IndexRow;

    //
    //  We need to be certain that the scratch buffer is big enough.
    //

    ASSERT( sizeof(ReadRecordBuffer) >= sizeof(FILE_OBJECTID_INFORMATION) );
    ASSERT( sizeof(ReadRecordBuffer) >= sizeof(FILE_QUOTA_INFORMATION) );
    ASSERT( sizeof(ReadRecordBuffer) >= sizeof(FILE_REPARSE_POINT_INFORMATION) );

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT_VCB( Vcb );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    //
    //  Get the current Stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsQueryViewIndex...\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, (" ->Length               = %08lx\n", IrpSp->Parameters.QueryDirectory.Length) );
    DebugTrace( 0, Dbg, (" ->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryDirectory.FileInformationClass) );
    DebugTrace( 0, Dbg, (" ->SystemBuffer         = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, (" ->RestartScan          = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN)) );
    DebugTrace( 0, Dbg, (" ->ReturnSingleEntry    = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY)) );
    DebugTrace( 0, Dbg, ("Vcb        = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Ccb        = %08lx\n", Ccb) );

    //
    //  Because we probably need to do the I/O anyway we'll reject any request
    //  right now that cannot wait for I/O.  We do not want to abort after
    //  processing a few index entries.
    //

    if (!FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT)) {

        DebugTrace( 0, Dbg, ("Automatically enqueue Irp to Fsp\n") );

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsQueryViewIndex -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength = IrpSp->Parameters.QueryDirectory.Length;

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;
    RestartKey = IrpSp->Parameters.QueryDirectory.FileName;

    //
    //  Look in the Ccb to see the type of search.
    //

    RestartScan = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);

    ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);

    //
    //  Determine the size of the constant part of the structure and make sure the Scb
    //  and info class are in agreement.  There may be some security implications in
    //  letting a user treat, say, the reparse index as the object id index.
    //

    switch (FileInformationClass) {

    case FileObjectIdInformation:

        BaseLength = sizeof( FILE_OBJECTID_INFORMATION );
        IndexKeyLength = OBJECT_ID_KEY_LENGTH;
        if (Scb != Vcb->ObjectIdTableScb) {
            Status = STATUS_INVALID_INFO_CLASS;
        }
        break;

    case FileQuotaInformation:

        BaseLength = sizeof( FILE_QUOTA_INFORMATION );
        IndexKeyLength = sizeof( ULONG );
        if (Scb != Vcb->QuotaTableScb) {
            Status = STATUS_INVALID_INFO_CLASS;
        }
        break;

    case FileReparsePointInformation:

        BaseLength = sizeof( FILE_REPARSE_POINT_INFORMATION );
        IndexKeyLength = sizeof( REPARSE_INDEX_KEY );
        if (Scb != Vcb->ReparsePointTableScb) {
            Status = STATUS_INVALID_INFO_CLASS;
        }
        break;

    default:

        Status = STATUS_INVALID_INFO_CLASS;
        break;
    }

    if (Status != STATUS_SUCCESS) {

        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsQueryViewIndex -> %08lx\n", Status) );
        return Status;
    }

    try {

        //
        //  We only allow one active request in this handle at a time.  If this is
        //  not a synchronous request then wait on the handle.
        //

        if (!FlagOn( IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO )) {

            EOF_WAIT_BLOCK WaitBlock;
            NtfsAcquireIndexCcb( Scb, Ccb, &WaitBlock );
            CcbAcquired = TRUE;
        }

        //
        //  Initialize the value we use to start the index enumeration.  Read carefully,
        //  we're working with both IndexKey and IndexKey->Key here.
        //

        IndexKey = NtfsAllocatePool( PagedPool, sizeof(INDEX_KEY) );
        IndexKeyAllocated = TRUE;

        IndexKey->KeyLength = IndexKeyLength;

        IndexKey->Key = NtfsAllocatePool( PagedPool, IndexKeyLength );
        IndexKeyKeyAllocated = TRUE;

        //
        //  When we first come into this function, there are a few interesting
        //  cases we need to consider to get everything initialized correctly.
        //
        //  1  We were called with some value from which to (re)start the enumeration,
        //     i.e. the caller wants to start somewhere in the middle of the index.
        //
        //  2  This is the first time we've been called to enumerate this index with
        //     this Ccb, in which case we want to start from the beginning.  This
        //     is substantially similar to the case where the caller has enumerated
        //     this index before, but wishes to restart the scan from the beginning of
        //     the index.
        //
        //  3  This is _not_ the first time we've been called to enumerate this index
        //     with this Ccb, and no restart key was specified, and the caller does
        //     not wish to restart the scan.  In this case, we need to pick up where
        //     the last call left off.
        //

        if (RestartKey != NULL) {

            DebugTrace( 0, Dbg, ("Restart key NOT null (case 1)\n") );

            //
            //  If we have a leftover query buffer from a previous call, free
            //  it, since we're no longer interested in where it left us.
            //

            if (Ccb->QueryBuffer != NULL) {

                ASSERT(FlagOn( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED ));

                NtOfsFreeReadContext( Ccb->QueryBuffer );

                Ccb->QueryBuffer = NULL;

                ClearFlag( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED | CCB_FLAG_LAST_INDEX_ROW_RETURNED );
            }

            //
            //  Store the initial value from which to start the enumeration,
            //  being careful not to write beyond the size of our allocated buffer.
            //

            if (RestartKey->Length > IndexKeyLength) {

                NtfsFreePool( IndexKey->Key );
                IndexKeyKeyAllocated = FALSE;

                IndexKey->Key = NtfsAllocatePool( PagedPool, RestartKey->Length );
                IndexKeyKeyAllocated = TRUE;
            }

            //
            //  Copy the key, and store the length.
            //

            RtlCopyMemory( IndexKey->Key,
                           RestartKey->Buffer,
                           RestartKey->Length );

            IndexKey->KeyLength = IndexKeyLength = RestartKey->Length;

        } else if (RestartScan || (Ccb->QueryBuffer == NULL)) {

            DebugTrace( 0, Dbg, ("RestartScan || Qb null (case 2)") );

            //
            //  The restart scan case is similar to the case where we're called with a
            //  RestartKey in that we want to deallocate any leftover info in the Ccb.
            //  The only difference is that we don't have a key from which to restart
            //  so we just set the key back to the appropriate starting value.  If
            //  the Ccb has no query buffer, then this is our first enumeration call
            //  since the handle was opened, and we need to start from scratch.
            //

            if (Ccb->QueryBuffer != NULL) {

                DebugTrace( 0, Dbg, ("Qb NOT null\n") );

                ASSERT(FlagOn( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED ));

                NtOfsFreeReadContext( Ccb->QueryBuffer );

                Ccb->QueryBuffer = NULL;

                ClearFlag( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED | CCB_FLAG_LAST_INDEX_ROW_RETURNED );

            } else {

                DebugTrace( 0, Dbg, ("Qb null\n") );

                FirstQueryForThisCcb = TRUE;
            }

            if (FileInformationClass == FileQuotaInformation) {

                //
                //  In the quota case, we have some special requirements for the fist key,
                //  so we want to init it to handle the case where we haven't been called
                //  with a restart key.
                //

                *((PULONG) IndexKey->Key) = QUOTA_FISRT_USER_ID;

            } else {

                RtlZeroMemory( IndexKey->Key,
                               IndexKeyLength );
            }

        } else {

            DebugTrace( 0, Dbg, ("Ccb->QueryBuffer NOT null (case 3)\n") );


            ASSERT(Ccb->QueryBuffer != NULL);
            ASSERT(FlagOn( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED ));

            //
            //  We have a leftover query buffer in the Ccb, and we were _not_
            //  called with a restart key, and we're not restarting the enumeration.
            //  Let's just pick up the enumeration where the Ccb's buffer tells us
            //  the last call left off.
            //

            ReadContext = Ccb->QueryBuffer;

            //
            //  If the previous pass set the keylength to 0, it must have hit the
            //  end of the index.  Check the CCB_FLAG_LAST_INDEX_ROW_RETURNED bit
            //  to see if we already made our special last pass through here to
            //  return the last row.
            //

            if (ReadContext->LastReturnedKey.KeyLength == 0) {

                DebugTrace( 0, Dbg, ("LastReturnedKey had 0 length\n") );

                if (FlagOn(Ccb->Flags, CCB_FLAG_LAST_INDEX_ROW_RETURNED)) {

                    //
                    //  We're at the end of the index, and the last entry has already
                    //  been returned to our caller.  We're all done now.
                    //

                    try_return( Status = STATUS_NO_MORE_FILES );

                } else {

                    //
                    //  We're at the end of the index, but we have not yet returned the
                    //  last entry to our caller.  We can't break out yet.
                    //

                    AtEndOfIndex = TRUE;

                    //
                    //  Remember that we are returning the last entry now.
                    //

                    SetFlag( Ccb->Flags, CCB_FLAG_LAST_INDEX_ROW_RETURNED );

                    //
                    //  We need to set this to a nonzero value so NtOfsReadRecords
                    //  will honor our request to read the last record.
                    //

                    if (IndexKeyLength > ReadContext->AllocatedKeyLength) {
                        ReadContext->LastReturnedKey.KeyLength = ReadContext->AllocatedKeyLength;
                    } else {
                        ReadContext->LastReturnedKey.KeyLength = IndexKeyLength;
                    }
                }

            } else if (ReadContext->LastReturnedKey.KeyLength > IndexKeyLength) {

                //
                //  There's not enough room to store the initial value from which to
                //  start the enumeration.  Free the buffer and get a bigger one.
                //

                NtfsFreePool( IndexKey->Key );
                IndexKeyKeyAllocated = FALSE;

                IndexKey->Key = NtfsAllocatePool( PagedPool, ReadContext->LastReturnedKey.KeyLength );
                IndexKeyKeyAllocated = TRUE;
            }

            //
            //  Make sure we're either using the small key buffer, or we've allocated
            //  a buffer that's big enough.
            //

            ASSERT( (ReadContext->LastReturnedKey.Key == &ReadContext->SmallKeyBuffer[0]) ||
                    (ReadContext->LastReturnedKey.KeyLength <= ReadContext->AllocatedKeyLength) );

            //
            //  Store the initial value from which to start the enumeration.
            //

            RtlCopyMemory( IndexKey->Key,
                           ReadContext->LastReturnedKey.Key,
                           ReadContext->LastReturnedKey.KeyLength );

            IndexKeyLength = ReadContext->LastReturnedKey.KeyLength;
        }

        Irp->IoStatus.Information = 0;

        //
        //  Acquire shared access to the Scb.
        //

        NtfsAcquireSharedScb( IrpContext, Scb );
        ScbAcquired = TRUE;

        //
        //  If the volume is no longer mounted, we should fail this
        //  request.  Since we have the Scb shared now, we know that
        //  a dismount request can't sneak in.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        try {

            //
            //  If we are in the Fsp now because we had to wait earlier,
            //  we must map the user buffer, otherwise we can use the
            //  user's buffer directly.
            //

            AccessingUserBuffer = TRUE;
            Buffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
            AccessingUserBuffer = FALSE;

            //
            //  At this point we are about to enter our query loop.  We have
            //  already decided if we need to call restart or continue when we
            //  go after an index entry.  The variables LastEntry and NextEntry are
            //  used to index into the user buffer.  LastEntry is the last entry
            //  we added to the user buffer, and NextEntry is the current
            //  one we're working on.
            //

            LastEntry = 0;
            NextEntry = 0;

            while (TRUE) {

                DebugTrace( 0, Dbg, ("Top of Loop\n") );
                DebugTrace( 0, Dbg, ("LastEntry = %08lx\n", LastEntry) );
                DebugTrace( 0, Dbg, ("NextEntry = %08lx\n", NextEntry) );

                //
                //  Check to see if we should quit the loop because we are only
                //  returning a single entry.  We actually want to spin around
                //  the loop top twice so that our enumeration has us left off
                //  at the last entry we didn't return.
                //

                LastPass = (ReturnSingleEntry && !FirstPass);

                //
                //  Be sure to pessimistically reinitialize these locals each
                //  time through the loop.
                //

                GotEntry = FALSE;
                IndexRow.KeyPart.KeyLength = 0;
                IndexRow.DataPart.DataLength = 0;
                Count = 1;

                //
                //  On the first pass for this IrpContext, we MUST take this code path
                //  with a null readcontext and a non-null IndexKey.  See the comment
                //  where NtOfsReadRecords is implemented.
                //

                if (FirstPass) {

                    DebugTrace( 0, Dbg, ("First pass\n") );

                    ReadContext = NULL;

                    ReadRecordStatus = NtOfsReadRecords( IrpContext,
                                                         Scb,
                                                         &ReadContext,
                                                         IndexKey,
                                                         NtOfsMatchAll,
                                                         IndexKey,
                                                         &Count,
                                                         &IndexRow,
                                                         sizeof( ReadRecordBuffer ),
                                                         ReadRecordBuffer );

                    //
                    //  We want to store the new ReadContext in the Ccb.  Free
                    //  anything leftover in the Ccb first.
                    //

                    if (Ccb->QueryBuffer != NULL) {

                        ASSERT(FlagOn( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED ));

                        NtOfsFreeReadContext( Ccb->QueryBuffer );
                    }

                    Ccb->QueryBuffer = ReadContext;
                    SetFlag( Ccb->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED );
                    GotEntry = (NT_SUCCESS( ReadRecordStatus ) &&
                                (IndexRow.KeyPart.KeyLength != 0));

                } else if ((!AtEndOfIndex)) {

                    DebugTrace( 0, Dbg, ("Nth pass\n") );

                    //
                    //  We don't want to do this if the previous trip through the loop
                    //  took us to the end of the index.
                    //

                    ReadContext = Ccb->QueryBuffer;

                    ASSERT(ReadContext != NULL);

                    //
                    //  Lookup the next index entry and set ourselves
                    //  up for subsequent iterations through the loop.
                    //

                    ReadRecordStatus = NtOfsReadRecords( IrpContext,
                                                         Scb,
                                                         &ReadContext,
                                                         NULL,
                                                         NtOfsMatchAll,
                                                         NULL,
                                                         &Count,
                                                         &IndexRow,
                                                         sizeof( ReadRecordBuffer ),
                                                         ReadRecordBuffer );

                    GotEntry = (NT_SUCCESS( ReadRecordStatus ) &&
                                (IndexRow.KeyPart.KeyLength != 0));
                }

                //
                //  If we only want to do the top part of the loop this time, get out here.
                //  For more info, see the comment above where we set LastPass.  Basically,
                //  if we're just advancing our index pointer in the return single case,
                //  if we don't have room to return another entry in the return multiple
                //  case, or if we came in pointing to the end of the index and we've
                //  already made one pass to return that entry to the caller, we should
                //  get out now.
                //

                if (LastPass ||
                    !AnotherEntryWillFit ||
                    (AtEndOfIndex && !FirstPass)) {

                    DebugTrace( 0, Dbg, ("LastPass = %08lx\n", LastPass) );
                    DebugTrace( 0, Dbg, ("AnotherEntryWillFit = %08lx\n", AnotherEntryWillFit) );
                    DebugTrace( 0, Dbg, ("...breaking out\n") );

                    if ((FileInformationClass == FileQuotaInformation) &&
                        (QuotaInfoPtr != NULL)) {

                        //
                        //  In the quota enumeration case, we need to zero this field
                        //  to indicate the end of the list.
                        //

                        QuotaInfoPtr->NextEntryOffset = 0;
                    }

                    break;
                }

                //
                //  Now check to see if we actually got another index entry.  If
                //  we didn't then we also need to check if we never got any
                //  or if we just ran out.  If we just ran out then we break out
                //  of the main loop and finish the Irp after the loop.
                //

                if (!GotEntry) {

                    DebugTrace( 0, Dbg, ("GotEntry is FALSE\n") );

                    if (!FirstPass) {

                        if (FirstQueryForThisCcb) {

                            try_return( Status = STATUS_NO_SUCH_FILE );
                        }

                        try_return( Status = STATUS_NO_MORE_FILES );
                    }

                    break;
                }

                //
                //  If the previous pass set the keylength to 0, it must have hit the
                //  end of the index.
                //

                if (ReadContext->LastReturnedKey.KeyLength == 0) {

                    DebugTrace( 0, Dbg, ("LastReturnedKey had 0 length (mid-loop)\n") );

                    //
                    //  We're at the end of the index, but we have not yet returned the
                    //  last entry to our caller.  We can't break out yet.
                    //

                    AtEndOfIndex = TRUE;

                    //
                    //  Remember that we are returning the last entry now.
                    //

                    SetFlag( Ccb->Flags, CCB_FLAG_LAST_INDEX_ROW_RETURNED );
                }

                //
                //  Here are the rules concerning filling up the buffer:
                //
                //  1.  The Io system guarantees that there will always be
                //      enough room for at least one base record.
                //
                //  2.  If the full first record (including variable length data)
                //      cannot fit, as much of the data as possible is copied
                //      and STATUS_BUFFER_OVERFLOW is returned.
                //
                //  3.  If a subsequent record cannot completely fit into the
                //      buffer, none of it (as in 0 bytes) is copied, and
                //      STATUS_SUCCESS is returned.  A subsequent query will
                //      pick up with this record.
                //

                BytesRemainingInBuffer = UserBufferLength - NextEntry;

                if ( (NextEntry != 0) &&
                     ( (BaseLength + VariableLength > BytesRemainingInBuffer) ||
                       (UserBufferLength < NextEntry) ) ) {

                    DebugTrace( 0, Dbg, ("Next entry won't fit\n") );

                    try_return( Status = STATUS_SUCCESS );
                }

                ASSERT( BytesRemainingInBuffer >= BaseLength );

                //
                //  Zero the base part of the structure.
                //

                AccessingUserBuffer = TRUE;
                RtlZeroMemory( &Buffer[NextEntry], BaseLength );

                //
                //  Now we have an entry to return to our caller.  We'll
                //  case on the type of information requested and fill up the
                //  user buffer if everything fits.
                //

                switch (FileInformationClass) {

                case FileObjectIdInformation:

                    ObjIdInfoPtr = (PFILE_OBJECTID_INFORMATION) (&Buffer[NextEntry]);

                    if (IndexRow.DataPart.DataLength == sizeof(NTFS_OBJECTID_INFORMATION)) {

                        RtlCopyMemory( &ObjIdInfoPtr->FileReference,
                                       &(((NTFS_OBJECTID_INFORMATION *) IndexRow.DataPart.Data)->FileSystemReference),
                                       sizeof( LONGLONG ) );

                        RtlCopyMemory( &ObjIdInfoPtr->ExtendedInfo,
                                       ((NTFS_OBJECTID_INFORMATION *) IndexRow.DataPart.Data)->ExtendedInfo,
                                       OBJECT_ID_EXT_INFO_LENGTH );

                    } else {

                        ASSERTMSG( "Bad objectid index datalength", FALSE );
                        SetFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_CORRUPT );
                        try_return( STATUS_NO_MORE_FILES );
                    }

                    if (IndexRow.KeyPart.KeyLength == IndexKeyLength) {

                        RtlCopyMemory( &ObjIdInfoPtr->ObjectId,
                                       IndexRow.KeyPart.Key,
                                       IndexRow.KeyPart.KeyLength );

                    } else {

                        ASSERTMSG( "Bad objectid index keylength", FALSE );
                        SetFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_CORRUPT );
                        try_return( STATUS_NO_MORE_FILES );
                    }

                    //
                    //  Object Ids have no variable length data, so we can skip
                    //  over some of the tricky code below.
                    //

                    VariableLength = 0;

                    break;

                case FileQuotaInformation:

                    QuotaInfoPtr = (PFILE_QUOTA_INFORMATION) (&Buffer[NextEntry]);
                    QuotaUserData = (PQUOTA_USER_DATA) IndexRow.DataPart.Data;

                    //
                    //  Skip this entry if it has been deleted.
                    //

                    if (FlagOn( QuotaUserData->QuotaFlags, QUOTA_FLAG_ID_DELETED )) {

                        continue;
                    }

                    SidLength = IndexRow.DataPart.DataLength - SIZEOF_QUOTA_USER_DATA;

                    QuotaInfoPtr->ChangeTime.QuadPart = QuotaUserData->QuotaChangeTime;
                    QuotaInfoPtr->QuotaUsed.QuadPart = QuotaUserData->QuotaUsed;
                    QuotaInfoPtr->QuotaThreshold.QuadPart = QuotaUserData->QuotaThreshold;
                    QuotaInfoPtr->QuotaLimit.QuadPart = QuotaUserData->QuotaLimit;

                    QuotaInfoPtr->SidLength = SidLength;

                    RtlCopyMemory( &QuotaInfoPtr->Sid,
                                   &QuotaUserData->QuotaSid,
                                   SidLength );

                    QuotaInfoPtr->NextEntryOffset = QuadAlign( SidLength + SIZEOF_QUOTA_USER_DATA );

                    VariableLength = QuotaInfoPtr->SidLength;

                    break;

                case FileReparsePointInformation:

                    ReparsePointInfoPtr = (PFILE_REPARSE_POINT_INFORMATION) (&Buffer[NextEntry]);

                    if (IndexRow.KeyPart.KeyLength == sizeof(REPARSE_INDEX_KEY)) {

                        ReparsePointInfoPtr->Tag = ((PREPARSE_INDEX_KEY) IndexRow.KeyPart.Key)->FileReparseTag;
                        ReparsePointInfoPtr->FileReference = ((PREPARSE_INDEX_KEY) IndexRow.KeyPart.Key)->FileId.QuadPart;

                    } else {

                        ASSERTMSG( "Bad reparse point index key length", FALSE );
                    }

                    //
                    //  Reparse points have no variable length data, so we can skip
                    //  over some of the tricky code below.
                    //

                    VariableLength = 0;

                    break;

                default:

                    try_return( Status = STATUS_INVALID_INFO_CLASS );
                }

                if (VariableLength != 0) {

                    //
                    //  Compute how many bytes we can copy.  This should only be less
                    //  than the variable length if we are only returning a single
                    //  entry.
                    //

                    if (BytesRemainingInBuffer >= BaseLength + VariableLength) {

                        VariableBytesToCopy = VariableLength;

                    } else {

                        VariableBytesToCopy = BytesRemainingInBuffer - BaseLength;

                        if (FileInformationClass == FileQuotaInformation) {

                            //
                            //  In the quota enumeration case, we need to zero this field
                            //  to indicate the end of the list.
                            //

                            QuotaInfoPtr->NextEntryOffset = 0;
                        }

                        Status = STATUS_BUFFER_OVERFLOW;
                    }

                } else {

                    VariableBytesToCopy = 0;
                }

                //
                //  Set up the previous next entry offset.
                //

                if (FileInformationClass == FileQuotaInformation) {

                    *((PULONG)(&Buffer[LastEntry])) = NextEntry - LastEntry;
                }

                AccessingUserBuffer = FALSE;

                //
                //  And indicate how much of the user buffer we have currently
                //  used up.  We must compute this value before we long align
                //  ourselves for the next entry.  This is the point where we
                //  quad-align the length of the previous entry.
                //

                Irp->IoStatus.Information = QuadAlign( Irp->IoStatus.Information) +
                                            BaseLength + VariableBytesToCopy;

                //
                //  If we weren't able to copy the whole index entry, then we bail here.
                //

                if ( !NT_SUCCESS( Status ) ) {

                    DebugTrace( 0, Dbg, ("Couldn't copy the whole index entry, exiting\n") );

                    try_return( Status );
                }

                //
                //  Set ourselves up for the next iteration.
                //

                LastEntry = NextEntry;
                NextEntry += (ULONG)QuadAlign( BaseLength + VariableBytesToCopy );
                FirstPass = FALSE;

                //
                //  Determine whether we should be able to fit another entry
                //  in the user's buffer after this one.
                //

                AnotherEntryWillFit = ((NextEntry + BaseLength) <= UserBufferLength);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            DebugTrace( -1, Dbg, ("NtfsQueryViewIndex raising %08lx\n", Status) );

            if (FsRtlIsNtstatusExpected( Status )) {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

            } else {

                ExRaiseStatus( AccessingUserBuffer ? STATUS_INVALID_USER_BUFFER : Status );
            }
        }

        //
        //  At this point we've successfully filled up some of the buffer so
        //  now is the time to set our status to success.
        //

        Status = STATUS_SUCCESS;

    try_exit:

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  Set the last access flag in the Fcb if the caller
        //  didn't set it explicitly.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME ) &&
            !FlagOn( NtfsData.Flags, NTFS_FLAGS_DISABLE_LAST_ACCESS )) {

            NtfsGetCurrentTime( IrpContext, Scb->Fcb->CurrentLastAccess );
            SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS );
        }

    } finally {

        DebugUnwind( NtfsQueryViewIndex );

        if (ScbAcquired) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        NtfsCleanupAfterEnumeration( IrpContext, Ccb );

        if (CcbAcquired) {

            NtfsReleaseIndexCcb( Scb, Ccb );
        }

        if (IndexKeyAllocated) {

            if (IndexKeyKeyAllocated) {

                NtfsFreePool( IndexKey->Key );
            }

            NtfsFreePool( IndexKey );
        }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsQueryViewIndex -> %08lx\n", Status) );

    return Status;
}

/*++

Routine Descriptions:

    Standard collation routines for creating simple indices.

Arguments:

    Key1 - First key to compare.

    Key2 - Second key to compare.

    CollationData - Optional data to support the collation.

Return Value:

    LessThan, EqualTo, or Greater than, for how Key1 compares
    with Key2.

--*/

FSRTL_COMPARISON_RESULT
NtOfsCollateUlong (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    ULONG u1, u2;

    UNREFERENCED_PARAMETER(CollationData);

    ASSERT( Key1->KeyLength == 4 );
    ASSERT( Key2->KeyLength == 4 );

    u1 = *(PULONG)Key1->Key;
    u2 = *(PULONG)Key2->Key;

    if (u1 > u2) {
        return GreaterThan;
    } else if (u1 < u2) {
        return LessThan;
    }
    return EqualTo;
}

FSRTL_COMPARISON_RESULT
NtOfsCollateUlongs (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    PULONG pu1, pu2;
    ULONG count;
    FSRTL_COMPARISON_RESULT result = EqualTo;

    UNREFERENCED_PARAMETER(CollationData);

    ASSERT( (Key1->KeyLength & 3) == 0 );
    ASSERT( (Key2->KeyLength & 3) == 0 );

    count = Key1->KeyLength;
    if (count != Key2->KeyLength) {
        result = LessThan;
        if (count > Key2->KeyLength) {
            count = Key2->KeyLength;
            result = GreaterThan;
        }
    }

    pu1 = (PULONG)Key1->Key;
    pu2 = (PULONG)Key2->Key;

    while (count > 0) {
       if (*pu1 > *pu2) {
           return GreaterThan;
       } else if (*(pu1++) < *(pu2++)) {
           return LessThan;
       }
       count -= 4;
    }
    return result;
}

FSRTL_COMPARISON_RESULT
NtOfsCollateSid (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    LONG Compare;

    PAGED_CODE( );

    UNREFERENCED_PARAMETER(CollationData);

    //
    //  The length of a valid SID is imbedded in the data
    //  so the function will mismatch be for the data runs out.
    //

    Compare = memcmp( Key1->Key, Key2->Key, Key1->KeyLength );

    if (Compare > 0) {
        return GreaterThan;
    } else if (Compare < 0) {
        return LessThan;
    }

    return EqualTo;
}

FSRTL_COMPARISON_RESULT
NtOfsCollateUnicode (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    )

{
    UNICODE_STRING String1, String2;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    String1.Length =
    String1.MaximumLength = (USHORT)Key1->KeyLength;
    String1.Buffer = Key1->Key;

    String2.Length =
    String2.MaximumLength = (USHORT)Key2->KeyLength;
    String2.Buffer = Key2->Key;

    return NtfsCollateNames( ((PUPCASE_TABLE_AND_KEY)CollationData)->UpcaseTable,
                             ((PUPCASE_TABLE_AND_KEY)CollationData)->UpcaseTableSize,
                             &String1,
                             &String2,
                             LessThan,
                             TRUE );
}


/*++

Routine Descriptions:

    Standard match routines for find / enumerate in simple indices.

Arguments:

    IndexRow - Row to check for a match.

    MatchData - Optional data for determining a match.

Return Value:

    STATUS_SUCCESS if the IndexRow matches
    STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should
        continue
    STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration
        should terminate

--*/

NTSTATUS
NtOfsMatchAll (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    UNREFERENCED_PARAMETER(IndexRow);
    UNREFERENCED_PARAMETER(MatchData);

    return STATUS_SUCCESS;
}

NTSTATUS
NtOfsMatchUlongExact (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    ULONG u1, u2;

    ASSERT( IndexRow->KeyPart.KeyLength == 4 );

    u1 = *(PULONG)IndexRow->KeyPart.Key;
    u2 = *(PULONG)((PINDEX_KEY)MatchData)->Key;

    if (u1 == u2) {
        return STATUS_SUCCESS;
    } else if (u1 < u2) {
        return STATUS_NO_MATCH;
    }
    return STATUS_NO_MORE_MATCHES;
}

NTSTATUS
NtOfsMatchUlongsExact (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    PULONG pu1, pu2;
    ULONG count;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT( (((PINDEX_KEY)MatchData)->KeyLength & 3) == 0 );
    ASSERT( (IndexRow->KeyPart.KeyLength & 3) == 0 );

    count = ((PINDEX_KEY)MatchData)->KeyLength;
    if (count != IndexRow->KeyPart.KeyLength) {
        status = STATUS_NO_MORE_MATCHES;
        if (count > IndexRow->KeyPart.KeyLength) {
            count = IndexRow->KeyPart.KeyLength;
            status = STATUS_NO_MATCH;
        }
    }

    pu1 = (PULONG)((PINDEX_KEY)MatchData)->Key;
    pu2 = (PULONG)IndexRow->KeyPart.Key;

    while (count > 0) {
       if (*pu1 > *pu2) {
           return STATUS_NO_MATCH;
       } else if (*(pu1++) < *(pu2++)) {
           return STATUS_NO_MORE_MATCHES;
       }
       count -= 4;
    }
    return status;
}

NTSTATUS
NtOfsMatchUnicodeExpression (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    UNICODE_STRING MatchString, IndexString;
    FSRTL_COMPARISON_RESULT BlindResult;
    PUPCASE_TABLE_AND_KEY UpcaseTableAndKey = (PUPCASE_TABLE_AND_KEY)MatchData;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    MatchString.Length =
    MatchString.MaximumLength = (USHORT)UpcaseTableAndKey->Key.KeyLength;
    MatchString.Buffer = UpcaseTableAndKey->Key.Key;

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexRow->KeyPart.KeyLength;
    IndexString.Buffer = IndexRow->KeyPart.Key;

    if (NtfsIsNameInExpression( UpcaseTableAndKey->UpcaseTable, &MatchString, &IndexString, TRUE )) {

        return STATUS_SUCCESS;

    } else if ((BlindResult = NtfsCollateNames(UpcaseTableAndKey->UpcaseTable,
                                               UpcaseTableAndKey->UpcaseTableSize,
                                               &MatchString,
                                               &IndexString,
                                               GreaterThan,
                                               TRUE)) != LessThan) {

        return STATUS_NO_MATCH;

    } else {

        return STATUS_NO_MORE_MATCHES;
    }
}

NTSTATUS
NtOfsMatchUnicodeString (
    IN PINDEX_ROW IndexRow,
    IN OUT PVOID MatchData
    )

{
    UNICODE_STRING MatchString, IndexString;
    FSRTL_COMPARISON_RESULT BlindResult;
    PUPCASE_TABLE_AND_KEY UpcaseTableAndKey = (PUPCASE_TABLE_AND_KEY)MatchData;

    PAGED_CODE();

    //
    //  Build the unicode strings and call namesup.
    //

    MatchString.Length =
    MatchString.MaximumLength = (USHORT)UpcaseTableAndKey->Key.KeyLength;
    MatchString.Buffer = UpcaseTableAndKey->Key.Key;

    IndexString.Length =
    IndexString.MaximumLength = (USHORT)IndexRow->KeyPart.KeyLength;
    IndexString.Buffer = IndexRow->KeyPart.Key;

    if (NtfsAreNamesEqual( UpcaseTableAndKey->UpcaseTable, &MatchString, &IndexString, TRUE )) {

        return STATUS_SUCCESS;

    } else if ((BlindResult = NtfsCollateNames(UpcaseTableAndKey->UpcaseTable,
                                               UpcaseTableAndKey->UpcaseTableSize,
                                               &MatchString,
                                               &IndexString,
                                               GreaterThan,
                                               TRUE)) != LessThan) {

        return STATUS_NO_MATCH;

    } else {

        return STATUS_NO_MORE_MATCHES;
    }
}


#ifdef TOMM
VOID
NtOfsIndexTest (
    PIRP_CONTEXT IrpContext,
    PFCB TestFcb
    )

{
    PSCB AdScb;
    NTSTATUS Status;
    ULONG i;
    MAP_HANDLE MapHandle;
    ULONG Count;
    UPCASE_TABLE_AND_KEY UpcaseTableAndKey;
    QUICK_INDEX_HINT QuickHint;
    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow[6];
    UCHAR Buffer[6*160];
    PREAD_CONTEXT ReadContext = NULL;
    UNICODE_STRING IndexName = CONSTANT_UNICODE_STRING( L"$Test" );
    USHORT MaxKey = MAXUSHORT;
    USHORT MinKey = 0;

    DbgPrint("NtOfs Make NtOfsDoIndexTest FALSE to suppress test\n");
    DbgPrint("NtOfs Make NtOfsLeaveTestIndex TRUE to leave test index\n");

    DbgBreakPoint();

    if (!NtOfsDoIndexTest) {
        return;
    }
    NtOfsDoIndexTest = FALSE;

    UpcaseTableAndKey.UpcaseTable = TestFcb->Vcb->UpcaseTable;
    UpcaseTableAndKey.UpcaseTableSize = TestFcb->Vcb->UpcaseTableSize;
    UpcaseTableAndKey.Key.Key = NULL;
    UpcaseTableAndKey.Key.KeyLength = 0;

    //
    //  Create Test Index
    //

    DbgPrint("NtOfs creating test index\n");
    NtOfsCreateIndex( IrpContext,
                      TestFcb,
                      IndexName,
                      CREATE_NEW,
                      0,
                      COLLATION_NTOFS_ULONG,
                      &NtOfsCollateUnicode,
                      &UpcaseTableAndKey,
                      &AdScb );

    DbgPrint("NtOfs created Test Index Scb %08lx\n", AdScb);

    //
    //  Access empty index
    //

    DbgPrint("NtOfs lookup last in empty index\n");
    IndexKey.Key = &MaxKey;
    IndexKey.KeyLength = sizeof(MaxKey);
    Status = NtOfsFindLastRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle );

    ASSERT(!NT_SUCCESS(Status));

    //
    //  Add some keys!
    //

    DbgPrint("NtOfs adding keys to index\n");
    for (i = 0; i < $EA/0x10; i++) {

        IndexRow[0].KeyPart.Key = &NtfsAttributeDefinitions[i].AttributeName;
        IndexRow[0].KeyPart.KeyLength = 0x80;
        IndexRow[0].DataPart.Data = (PCHAR)IndexRow[0].KeyPart.Key + 0x80;
        IndexRow[0].DataPart.DataLength = sizeof(ATTRIBUTE_DEFINITION_COLUMNS) - 0x84;

        NtOfsAddRecords( IrpContext, AdScb, 1, &IndexRow[0], 0 );
    }

    //
    //  Now find the last key
    //

    DbgPrint("NtOfs checkin last key in index\n");
    IndexKey.Key = &MaxKey;
    IndexKey.KeyLength = sizeof(MaxKey);
    Status = NtOfsFindLastRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle );

    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlCompareMemory(IndexRow[0].KeyPart.Key, L"$VOLUME_NAME", sizeof(L"$VOLUME_NAME") - sizeof( WCHAR )) ==
           (sizeof(L"$VOLUME_NAME") - sizeof( WCHAR )));

    NtOfsReleaseMap( IrpContext, &MapHandle );

    //
    //  See if they are all there.
    //

    DbgPrint("NtOfs looking up all keys in index\n");
    for (i = 0; i < $EA/0x10; i++) {

        IndexKey.Key = &NtfsAttributeDefinitions[i].AttributeName;
        IndexKey.KeyLength = 0x80;

        Status = NtOfsFindRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle, NULL );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("NtOfsIterationFailure with i = %08lx, Status = %08lx\n", i, Status);
        }

        NtOfsReleaseMap( IrpContext, &MapHandle );
    }

    //
    //  Now enumerate the entire index
    //

    IndexKey.Key = &MinKey;
    IndexKey.KeyLength = sizeof(MinKey);
    Count = 6;

    DbgPrint("NtOfs enumerating index:\n\n");
    while (NT_SUCCESS(Status = NtOfsReadRecords( IrpContext,
                                                 AdScb,
                                                 &ReadContext,
                                                 (ReadContext == NULL) ? &IndexKey : NULL,
                                                 &NtOfsMatchAll,
                                                 NULL,
                                                 &Count,
                                                 IndexRow,
                                                 sizeof(Buffer),
                                                 Buffer ))) {

        for (i = 0; i < Count; i++) {
            DbgPrint( "IndexKey = %ws, AttributeTypeCode = %lx\n",
                      IndexRow[i].KeyPart.Key,
                      *(PULONG)IndexRow[i].DataPart.Data );
        }
        DbgPrint( "\n" );
    }

    NtOfsFreeReadContext( ReadContext );
    ReadContext = NULL;

    //
    //  Loop to update all records.
    //

    DbgPrint("NtOfs updating up all keys in index\n");
    for (i = 0; i < $EA/0x10; i++) {

        IndexKey.Key = &NtfsAttributeDefinitions[i].AttributeName;
        IndexKey.KeyLength = 0x80;

        RtlZeroMemory( &QuickHint, sizeof(QUICK_INDEX_HINT) );

        NtOfsFindRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle, &QuickHint );

        //
        //  Copy and update the data.
        //

        RtlCopyMemory( Buffer, IndexRow[0].DataPart.Data, IndexRow[0].DataPart.DataLength );
        *(PULONG)Buffer += 0x100;
        IndexRow[0].DataPart.Data = Buffer;

        //
        //  Perform update with all valid combinations of hint and map handle.
        //

        NtOfsUpdateRecord( IrpContext,
                           AdScb,
                           1,
                           &IndexRow[0],
                           (i <= $FILE_NAME/0x10) ? NULL : &QuickHint,
                           (i < $INDEX_ROOT/0x10) ? NULL : &MapHandle );

        NtOfsReleaseMap( IrpContext, &MapHandle );
    }

    //
    //  Now enumerate the entire index again to see the updates.
    //

    IndexKey.Key = &MinKey;
    IndexKey.KeyLength = sizeof(MinKey);
    Count = 6;

    DbgPrint("NtOfs enumerating index after updates:\n\n");
    while (NT_SUCCESS(Status = NtOfsReadRecords( IrpContext,
                                                 AdScb,
                                                 &ReadContext,
                                                 (ReadContext == NULL) ? &IndexKey : NULL,
                                                 &NtOfsMatchAll,
                                                 NULL,
                                                 &Count,
                                                 IndexRow,
                                                 sizeof(Buffer),
                                                 Buffer ))) {

        for (i = 0; i < Count; i++) {
            DbgPrint( "IndexKey = %ws, AttributeTypeCode = %lx\n",
                      IndexRow[i].KeyPart.Key,
                      *(PULONG)IndexRow[i].DataPart.Data );
        }
        DbgPrint( "\n" );
    }

    NtOfsFreeReadContext( ReadContext );
    ReadContext = NULL;


    //
    //  Now delete the keys
    //

    if (!NtOfsLeaveTestIndex) {

        DbgPrint("NtOfs deleting all keys in index:\n\n");
        for (i = 0; i < $EA/0x10; i++) {

            IndexKey.Key = &NtfsAttributeDefinitions[i].AttributeName;
            IndexKey.KeyLength = 0x80;

            NtOfsDeleteRecords( IrpContext, AdScb, 1, &IndexKey );
        }

        //
        //  Access empty index
        //

        DbgPrint("NtOfs lookup last key in empty index:\n\n");
        IndexKey.Key = &MaxKey;
        IndexKey.KeyLength = sizeof(MaxKey);
        Status = NtOfsFindLastRecord( IrpContext, AdScb, &IndexKey, &IndexRow[0], &MapHandle );

        ASSERT(!NT_SUCCESS(Status));

        DbgPrint("NtOfs deleting index:\n");
        NtOfsDeleteIndex( IrpContext, TestFcb, AdScb );
    }

    DbgPrint("NtOfs closing index:\n");
    NtOfsCloseIndex( IrpContext, AdScb );

    DbgPrint("NtOfs test complete!\n\n");

    return;

    //
    //  Make sure these at least compile until we have some real callers.
    //

    {
        MAP_HANDLE M;
        PVOID B;
        LONGLONG O;
        ULONG L;
        LSN Lsn;

        NtOfsInitializeMapHandle( &M );
        NtOfsMapAttribute( IrpContext, AdScb, O, L, &B, &M );
        NtOfsPreparePinWrite( IrpContext, AdScb, O, L, &B, &M );
        NtOfsPinRead( IrpContext, AdScb, O, L, &M );
        NtOfsDirty( IrpContext, &M, &Lsn );
        NtOfsReleaseMap( IrpContext, &M );
        NtOfsPutData( IrpContext, AdScb, O, L, &B );

    }
}

#endif TOMM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\volinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the set and query volume information routines for
    Ntfs called by the dispatch driver.

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

//
//  Local procedure prototypes
//

NTSTATUS
NtfsQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsControlInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsFullSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryFsVolumeObjectIdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_OBJECTID_INFORMATION Buffer,
    IN OUT PULONG Length
    );
    
NTSTATUS
NtfsSetFsLabelInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_LABEL_INFORMATION Buffer
    );

NTSTATUS
NtfsSetFsControlInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION Buffer
    );

NTSTATUS
NtfsSetFsVolumeObjectIdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_OBJECTID_INFORMATION Buffer
    );
    
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonQueryVolumeInfo)
#pragma alloc_text(PAGE, NtfsCommonSetVolumeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsAttributeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsDeviceInfo)
#pragma alloc_text(PAGE, NtfsQueryFsSizeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsVolumeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsControlInfo)
#pragma alloc_text(PAGE, NtfsQueryFsFullSizeInfo)
#pragma alloc_text(PAGE, NtfsQueryFsVolumeObjectIdInfo)
#pragma alloc_text(PAGE, NtfsSetFsLabelInfo)
#pragma alloc_text(PAGE, NtfsSetFsControlInfo)
#pragma alloc_text(PAGE, NtfsSetFsVolumeObjectIdInfo)
#endif


NTSTATUS
NtfsCommonQueryVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query Volume Information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;
    BOOLEAN AcquiredVcb = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQueryVolumeInfo...\n") );
    DebugTrace( 0, Dbg, ("IrpContext         = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("Length             = %08lx\n", IrpSp->Parameters.QueryVolume.Length) );
    DebugTrace( 0, Dbg, ("FsInformationClass = %08lx\n", IrpSp->Parameters.QueryVolume.FsInformationClass) );
    DebugTrace( 0, Dbg, ("Buffer             = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Extract and decode the file object to get the Vcb, we don't really
    //  care what the type of open is.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Let's kill invalid vol. query requests.
    //

    if (UnopenedFileObject == TypeOfOpen) {

        DebugTrace( 0, Dbg, ("Invalid file object for write\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryVolume:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }


    //
    //  Get the Vcb shared and raise if we can't wait for the resource.
    //  We're only using $Volume Scb for the query size calls because the info
    //  it gets is static and we only need to protect against dismount
    //  Doing this prevents a deadlock with commit extensions from mm which use
    //  this call. However for system files like the mft we always need the vcb to avoid deadlock
    //
                         
    if ((FsInformationClass != FileFsSizeInformation) || 
        (FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) {
        
        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
        AcquiredVcb = TRUE;
    } else {
        
        NtfsAcquireSharedScb( IrpContext, Scb );
    }

    try {

        //
        //  Make sure the volume is mounted.
        //

        if ((AcquiredVcb && !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) ||
            (!AcquiredVcb && FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED))) {
            
            Irp->IoStatus.Information = 0;
            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling fills up the output buffer
        //  if possible and returns true if it successfully filled the buffer
        //  and false if it couldn't wait for any I/O to complete.
        //

        switch (FsInformationClass) {

        case FileFsVolumeInformation:

            Status = NtfsQueryFsVolumeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsSizeInformation:

            Status = NtfsQueryFsSizeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsDeviceInformation:

            Status = NtfsQueryFsDeviceInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsAttributeInformation:

            Status = NtfsQueryFsAttributeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsControlInformation:

            Status = NtfsQueryFsControlInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsFullSizeInformation:
        
            Status = NtfsQueryFsFullSizeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsObjectIdInformation:
        
            Status = NtfsQueryFsVolumeObjectIdInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        DebugUnwind( NtfsCommonQueryVolumeInfo );

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
        } else  {
            NtfsReleaseScb( IrpContext, Scb );
        }   

        DebugTrace( -1, Dbg, ("NtfsCommonQueryVolumeInfo -> %08lx\n", Status) );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


NTSTATUS
NtfsCommonSetVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set Volume Information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetVolumeInfo\n") );
    DebugTrace( 0, Dbg, ("IrpContext         = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("Length             = %08lx\n", IrpSp->Parameters.SetVolume.Length) );
    DebugTrace( 0, Dbg, ("FsInformationClass = %08lx\n", IrpSp->Parameters.SetVolume.FsInformationClass) );
    DebugTrace( 0, Dbg, ("Buffer             = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.SetVolume.Length;
    FsInformationClass = IrpSp->Parameters.SetVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Extract and decode the file object to get the Vcb, we don't really
    //  care what the type of open is.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (TypeOfOpen != UserVolumeOpen &&
        (TypeOfOpen != UserViewIndexOpen ||
         FsInformationClass != FileFsControlInformation ||
         Fcb != Vcb->QuotaTableScb->Fcb)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsCommonSetVolumeInfo -> STATUS_ACCESS_DENIED\n") );

        return STATUS_ACCESS_DENIED;
    }

    //
    //  The volume must be writable.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsCommonSetVolumeInfo -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Acquire exclusive access to the Vcb
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

    try {

        //
        //  Proceed only if the volume is mounted.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            //
            //  Based on the information class we'll do different actions.  Each
            //  of the procedures that we're calling performs the action if
            //  possible and returns true if it successful and false if it couldn't
            //  wait for any I/O to complete.
            //

            switch (FsInformationClass) {

            case FileFsLabelInformation:

                Status = NtfsSetFsLabelInfo( IrpContext, Vcb, Buffer );
                break;

            case FileFsControlInformation:

                Status = NtfsSetFsControlInfo( IrpContext, Vcb, Buffer );
                break;

            case FileFsObjectIdInformation:

                Status = NtfsSetFsVolumeObjectIdInfo( IrpContext, Vcb, Buffer );
                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

        } else {

            Status = STATUS_FILE_INVALID;
        }

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        DebugUnwind( NtfsCommonSetVolumeInfo );

        NtfsReleaseVcb( IrpContext, Vcb );

        DebugTrace( -1, Dbg, ("NtfsCommonSetVolumeInfo -> %08lx\n", Status) );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    NTSTATUS Status;

    ULONG BytesToCopy;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsVolumeInfo...\n") );

    //
    //  Get the volume creation time from the Vcb.
    //

    Buffer->VolumeCreationTime.QuadPart = Vcb->VolumeCreationTime;

    //
    //  Fill in the serial number and indicate that we support objects
    //

    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;
    Buffer->SupportsObjects = TRUE;

    Buffer->VolumeLabelLength = Vcb->Vpb->VolumeLabelLength;

    //
    //  Update the length field with how much we have filled in so far.
    //

    *Length -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel[0]);

    //
    //  See how many bytes of volume label we can copy
    //

    if (*Length >= (ULONG)Vcb->Vpb->VolumeLabelLength) {

        Status = STATUS_SUCCESS;

        BytesToCopy = Vcb->Vpb->VolumeLabelLength;

    } else {

        Status = STATUS_BUFFER_OVERFLOW;

        BytesToCopy = *Length;
    }

    //
    //  Copy over the volume label (if there is one).
    //

    RtlCopyMemory( &Buffer->VolumeLabel[0],
                   &Vcb->Vpb->VolumeLabel[0],
                   BytesToCopy);

    //
    //  Update the buffer length by the amount we copied.
    //

    *Length -= BytesToCopy;

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query size information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsSizeInfo...\n") );

    //
    //  Make sure the buffer is large enough and zero it out
    //

    if (*Length < sizeof(FILE_FS_SIZE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_SIZE_INFORMATION) );

    //
    //  Check if we need to rescan the bitmap.  Don't try this
    //  if we have started to teardown the volume.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS ) &&
        FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        //
        //  Acquire the volume bitmap shared to rescan the bitmap.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

        try {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );

        } finally {

            NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
        }
    }

    //
    //  Set the output buffer
    //

    Buffer->TotalAllocationUnits.QuadPart = Vcb->TotalClusters;
    Buffer->AvailableAllocationUnits.QuadPart = Vcb->FreeClusters - Vcb->TotalReserved;
    Buffer->SectorsPerAllocationUnit = Vcb->BytesPerCluster / Vcb->BytesPerSector;
    Buffer->BytesPerSector = Vcb->BytesPerSector;

    if (Buffer->AvailableAllocationUnits.QuadPart < 0) {
        Buffer->AvailableAllocationUnits.QuadPart = 0;
    }

    //
    //  If quota enforcement is enabled then the available allocation
    //  units. must be reduced by the available quota.
    //

    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED )) {

        PCCB Ccb;
        ULONGLONG Quota;
        ULONGLONG QuotaLimit;

        //
        //  Go grab the ccb out of the Irp.
        //

        Ccb = (PCCB) (IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->
                        FileObject->FsContext2);

        if (Ccb != NULL && Ccb->OwnerId != 0) {

            NtfsGetRemainingQuota( IrpContext, Ccb->OwnerId, &Quota, &QuotaLimit, NULL );

        } else {

            NtfsGetRemainingQuota( IrpContext,
                                   NtfsGetCallersUserId( IrpContext ),
                                   &Quota,
                                   &QuotaLimit,
                                   NULL );
        }

        //
        //  Do not use LlClustersFromBytesTruncate it is signed and this must be
        //  an unsigned operation.
        //
        
        Quota = Int64ShrlMod32( Quota, Vcb->ClusterShift );        
        QuotaLimit = Int64ShrlMod32( QuotaLimit, Vcb->ClusterShift );        

        if (Quota < (ULONGLONG) Buffer->AvailableAllocationUnits.QuadPart) {

            Buffer->AvailableAllocationUnits.QuadPart = Quota;
            DebugTrace( 0, Dbg, (" QQQQQ AvailableAllocation is quota limited to %I64x\n", Quota) );
        }

        if (QuotaLimit < (ULONGLONG) Vcb->TotalClusters) {
        
            Buffer->TotalAllocationUnits.QuadPart = QuotaLimit;
            DebugTrace( 0, Dbg, (" QQQQQ TotalAllocation is quota limited to %I64x\n", QuotaLimit) );
        }
    }

    //
    //  Adjust the length variable
    //

    DebugTrace( 0, Dbg, ("AvailableAllocation is %I64x\n", Buffer->AvailableAllocationUnits.QuadPart) );
    DebugTrace( 0, Dbg, ("TotalAllocation is %I64x\n", Buffer->TotalAllocationUnits.QuadPart) );
    
    *Length -= sizeof(FILE_FS_SIZE_INFORMATION);

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query device information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsDeviceInfo...\n") );

    //
    //  Make sure the buffer is large enough and zero it out
    //

    if (*Length < sizeof(FILE_FS_DEVICE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_DEVICE_INFORMATION) );

    //
    //  Set the output buffer
    //

    Buffer->DeviceType = FILE_DEVICE_DISK;
    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_DEVICE_INFORMATION);

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query attribute information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    NTSTATUS Status;
    ULONG BytesToCopy;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsAttributeInfo...\n") );

    //
    //  See how many bytes of the name we can copy.
    //

    *Length -= FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0]);

    if ( *Length >= 8 ) {

        Status = STATUS_SUCCESS;

        BytesToCopy = 8;

    } else {

        Status = STATUS_BUFFER_OVERFLOW;

        BytesToCopy = *Length;
    }

    //
    //  Set the output buffer
    //

    Buffer->FileSystemAttributes = FILE_CASE_SENSITIVE_SEARCH |
                                   FILE_CASE_PRESERVED_NAMES |
                                   FILE_UNICODE_ON_DISK |
                                   FILE_FILE_COMPRESSION |
                                   FILE_PERSISTENT_ACLS |
                                   FILE_NAMED_STREAMS;

    //
    //  This may be a version 1.x volume that has not been upgraded yet.
    //  It may also be an upgraded volume where we somehow failed to 
    //  open the quota index.  In either case, we should only tell the 
    //  quota ui that this volume supports quotas if it really does.
    //
    
    if (Vcb->QuotaTableScb != NULL) {

        SetFlag( Buffer->FileSystemAttributes, FILE_VOLUME_QUOTAS );
    }

    //
    //  Ditto for object ids.
    //

    if (Vcb->ObjectIdTableScb != NULL) {

        SetFlag( Buffer->FileSystemAttributes, FILE_SUPPORTS_OBJECT_IDS );
    }

    //
    //  Encryption is trickier than quotas and object ids.  It requires an
    //  upgraded volume as well as a registered encryption driver.
    //

    if (NtfsVolumeVersionCheck( Vcb, NTFS_ENCRYPTION_VERSION ) &&
        FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER )) {

        SetFlag( Buffer->FileSystemAttributes, FILE_SUPPORTS_ENCRYPTION );
    }

    //
    //  Reparse points and sparse files are supported in 5.0 volumes.
    //
    //  For reparse points we verify whether the Vcb->ReparsePointTableScb has
    //  been initialized or not.
    //

    if (Vcb->ReparsePointTableScb != NULL) {

        SetFlag( Buffer->FileSystemAttributes, FILE_SUPPORTS_REPARSE_POINTS );
    }
    
    if (NtfsVolumeVersionCheck( Vcb, NTFS_SPARSE_FILE_VERSION )) {

        SetFlag( Buffer->FileSystemAttributes, FILE_SUPPORTS_SPARSE_FILES );
    }

    //
    //  Clear the compression flag if we don't allow compression on this drive
    //  (i.e. large clusters)
    //

    if (!FlagOn( Vcb->AttributeFlagsMask, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

        ClearFlag( Buffer->FileSystemAttributes, FILE_FILE_COMPRESSION );
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        SetFlag( Buffer->FileSystemAttributes, FILE_READ_ONLY_VOLUME );
    }
    
    Buffer->MaximumComponentNameLength = 255;
    Buffer->FileSystemNameLength = BytesToCopy;;
    RtlCopyMemory( &Buffer->FileSystemName[0], L"NTFS", BytesToCopy );

    //
    //  Adjust the length variable
    //

    *Length -= BytesToCopy;

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsControlInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query control information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    QUOTA_USER_DATA QuotaBuffer;
    PQUOTA_USER_DATA UserData;
    ULONG OwnerId;
    ULONG Count = 1;
    PREAD_CONTEXT ReadContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsControlInfo...\n") );

    RtlZeroMemory( Buffer, sizeof( FILE_FS_CONTROL_INFORMATION ));

    PAGED_CODE();

    try {

        //
        //  Fill in the quota information if quotas are running.
        //

        if (Vcb->QuotaTableScb != NULL) {

            OwnerId = QUOTA_DEFAULTS_ID;
            IndexKey.KeyLength = sizeof( OwnerId );
            IndexKey.Key = &OwnerId;

            Status = NtOfsReadRecords( IrpContext,
                                       Vcb->QuotaTableScb,
                                       &ReadContext,
                                       &IndexKey,
                                       NtOfsMatchUlongExact,
                                       &IndexKey,
                                       &Count,
                                       &IndexRow,
                                       sizeof( QuotaBuffer ),
                                       &QuotaBuffer );


            if (NT_SUCCESS( Status )) {

                UserData = IndexRow.DataPart.Data;

                Buffer->DefaultQuotaThreshold.QuadPart =
                    UserData->QuotaThreshold;
                Buffer->DefaultQuotaLimit.QuadPart =
                    UserData->QuotaLimit;

                //
                //  If the quota info is corrupt or has not been rebuilt
                //  yet then indicate the information is incomplete.
                //

                if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE |
                                                 QUOTA_FLAG_CORRUPT )) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_QUOTAS_INCOMPLETE );
                }

                if ((Vcb->QuotaState & VCB_QUOTA_REPAIR_RUNNING) >
                     VCB_QUOTA_REPAIR_POSTED ) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_QUOTAS_REBUILDING );
                }

                //
                //  Set the quota information basied on where we want
                //  to be rather than where we are.
                //

                if (FlagOn( UserData->QuotaFlags,
                            QUOTA_FLAG_ENFORCEMENT_ENABLED )) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_QUOTA_ENFORCE );

                } else if (FlagOn( UserData->QuotaFlags,
                            QUOTA_FLAG_TRACKING_REQUESTED )) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_QUOTA_TRACK );
                }

                if (FlagOn( UserData->QuotaFlags, QUOTA_FLAG_LOG_LIMIT)) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_LOG_QUOTA_LIMIT );

                }

                if (FlagOn( UserData->QuotaFlags, QUOTA_FLAG_LOG_THRESHOLD)) {

                    SetFlag( Buffer->FileSystemControlFlags,
                             FILE_VC_LOG_QUOTA_THRESHOLD );

                }
            }
        }

    } finally {

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }

    }

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_CONTROL_INFORMATION );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsFullSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query full size information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsQueryFsFullSizeInfo...\n") );

    //
    //  Make sure the buffer is large enough and zero it out
    //

    if (*Length < sizeof(FILE_FS_FULL_SIZE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_FULL_SIZE_INFORMATION) );

    //
    //  Check if we need to rescan the bitmap.  Don't try this
    //  if we have started to teardown the volume.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS ) &&
        FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        //
        //  Acquire the volume bitmap shared to rescan the bitmap.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

        try {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );

        } finally {

            NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
        }
    }

    //
    //  Set the output buffer
    //

    Buffer->TotalAllocationUnits.QuadPart = Vcb->TotalClusters;
    Buffer->CallerAvailableAllocationUnits.QuadPart = Vcb->FreeClusters - Vcb->TotalReserved;
    Buffer->ActualAvailableAllocationUnits.QuadPart = Vcb->FreeClusters - Vcb->TotalReserved;
    Buffer->SectorsPerAllocationUnit = Vcb->BytesPerCluster / Vcb->BytesPerSector;
    Buffer->BytesPerSector = Vcb->BytesPerSector;

    if (Buffer->CallerAvailableAllocationUnits.QuadPart < 0) {
        Buffer->CallerAvailableAllocationUnits.QuadPart = 0;
    }
    if (Buffer->ActualAvailableAllocationUnits.QuadPart < 0) {
        Buffer->ActualAvailableAllocationUnits.QuadPart = 0;
    }

    //
    //  If quota enforcement is enabled then the available allocation
    //  units. must be reduced by the available quota.
    //

    if (FlagOn(Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED)) {
        
        ULONGLONG Quota;
        ULONGLONG QuotaLimit;
        PCCB Ccb;

        //
        //  Go grab the ccb out of the Irp.
        //

        Ccb = (PCCB) (IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->
                        FileObject->FsContext2);

        if (Ccb != NULL && Ccb->OwnerId != 0) {

            NtfsGetRemainingQuota( IrpContext, Ccb->OwnerId, &Quota, &QuotaLimit, NULL );

        } else {

            NtfsGetRemainingQuota( IrpContext,
                                   NtfsGetCallersUserId( IrpContext ),
                                   &Quota,
                                   &QuotaLimit,
                                   NULL );

        }

        //
        //  Do not use LlClustersFromBytesTruncate it is signed and this must be
        //  an unsigned operation.
        //
        
        Quota = Int64ShrlMod32( Quota, Vcb->ClusterShift );
        QuotaLimit = Int64ShrlMod32( QuotaLimit, Vcb->ClusterShift );        

        if (Quota < (ULONGLONG) Buffer->CallerAvailableAllocationUnits.QuadPart) {

            Buffer->CallerAvailableAllocationUnits.QuadPart = Quota;
        }
        
        if (QuotaLimit < (ULONGLONG) Vcb->TotalClusters) {
        
            Buffer->TotalAllocationUnits.QuadPart = QuotaLimit;
        }
    }

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_FULL_SIZE_INFORMATION);

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryFsVolumeObjectIdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_OBJECTID_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume object id information call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    NTSTATUS Status;
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    
    PAGED_CODE();

    //
    //  The Vcb should be held so a dismount can't sneak in.
    //
    
    ASSERT_SHARED_RESOURCE( &(Vcb->Resource) );

    //
    //  Fail for version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        return STATUS_VOLUME_NOT_UPGRADED;
    }

    if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        //
        //  Only try this if the volume has an object id.
        //
        
        if (!FlagOn( Vcb->VcbState, VCB_STATE_VALID_OBJECT_ID )) {

            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        //
        //  Get the object id extended info for the $Volume file.  We
        //  can cheat a little because we have the key part of the object
        //  id stored in the Vcb.
        //        
        
        Status = NtfsGetObjectIdExtendedInfo( IrpContext,
                                              Vcb,
                                              Vcb->VolumeObjectId,
                                              ObjectIdBuffer.ExtendedInfo );
                                              
        //
        //  Copy both the indexed part and the extended info part out to the
        //  user's buffer.
        //
        
        if (Status == STATUS_SUCCESS) {
        
            RtlCopyMemory( Buffer->ObjectId, 
                           Vcb->VolumeObjectId,
                           OBJECT_ID_KEY_LENGTH );

            RtlCopyMemory( Buffer->ExtendedInfo, 
                           ObjectIdBuffer.ExtendedInfo,
                           OBJECT_ID_EXT_INFO_LENGTH );

            *Length -= (OBJECT_ID_EXT_INFO_LENGTH + OBJECT_ID_KEY_LENGTH);
        }        
        
    } else {

        Status = STATUS_VOLUME_DISMOUNTED;
    }        
    
    return Status;                                      
}
    

//
//  Internal Support Routine
//

NTSTATUS
NtfsSetFsLabelInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_LABEL_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine implements the set label call

Arguments:

    Vcb - Supplies the Vcb being altered

    Buffer - Supplies a pointer to the input buffer containing the new label

Return Value:

    NTSTATUS - Returns the status for the operation

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsSetFsLabelInfo...\n") );

    //
    //  Check that the volume label length is supported by the system.
    //

    if (Buffer->VolumeLabelLength > MAXIMUM_VOLUME_LABEL_LENGTH) {

        return STATUS_INVALID_VOLUME_LABEL;
    }

    try {

        //
        //  Initialize the attribute context and then lookup the volume name
        //  attribute for on the volume dasd file
        //

        NtfsInitializeAttributeContext( &AttributeContext );

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Vcb->VolumeDasdScb->Fcb,
                                       &Vcb->VolumeDasdScb->Fcb->FileReference,
                                       $VOLUME_NAME,
                                       &AttributeContext )) {

            //
            //  We found the volume name so now simply update the label
            //

            NtfsChangeAttributeValue( IrpContext,
                                      Vcb->VolumeDasdScb->Fcb,
                                      0,
                                      &Buffer->VolumeLabel[0],
                                      Buffer->VolumeLabelLength,
                                      TRUE,
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      &AttributeContext );

        } else {

            //
            //  We didn't find the volume name so now create a new label
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            NtfsInitializeAttributeContext( &AttributeContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Vcb->VolumeDasdScb->Fcb,
                                          $VOLUME_NAME,
                                          NULL,
                                          &Buffer->VolumeLabel[0],
                                          Buffer->VolumeLabelLength,
                                          0, // Attributeflags
                                          NULL,
                                          TRUE,
                                          &AttributeContext );
        }

        Vcb->Vpb->VolumeLabelLength = (USHORT)Buffer->VolumeLabelLength;

        if ( Vcb->Vpb->VolumeLabelLength > MAXIMUM_VOLUME_LABEL_LENGTH) {

             Vcb->Vpb->VolumeLabelLength = MAXIMUM_VOLUME_LABEL_LENGTH;
        }

        RtlCopyMemory( &Vcb->Vpb->VolumeLabel[0],
                       &Buffer->VolumeLabel[0],
                       Vcb->Vpb->VolumeLabelLength );

    } finally {

        DebugUnwind( NtfsSetFsLabelInfo );

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetFsControlInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine implements the set volume quota control info call

Arguments:

    Vcb - Supplies the Vcb being altered

    Buffer - Supplies a pointer to the input buffer containing the new label

Return Value:

    NTSTATUS - Returns the status for the operation

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    if (Vcb->QuotaTableScb == NULL) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    //  Process the quota part of the control structure.
    //

    NtfsUpdateQuotaDefaults( IrpContext, Vcb, Buffer );

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetFsVolumeObjectIdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_OBJECTID_INFORMATION Buffer
    )
    
/*++

Routine Description:

    This routine implements the set volume object id call.

Arguments:

    Vcb - Supplies the Vcb being altered

    Buffer - Supplies a pointer to the input buffer containing the new label

Return Value:

    NTSTATUS - Returns the status for the operation

--*/

{
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    FILE_OBJECTID_BUFFER OldObjectIdBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    PFCB DasdFcb;
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    //
    //  The Vcb should be held so a dismount can't sneak in.
    //

    ASSERT_EXCLUSIVE_RESOURCE( &(Vcb->Resource) );
    ASSERT( FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ));
    
    //
    //  Every mounted volume should have the dasd scb open.            
    //

    ASSERT( Vcb->VolumeDasdScb != NULL );

    //
    //  Fail for version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        return STATUS_VOLUME_NOT_UPGRADED;
    }

    DasdFcb = Vcb->VolumeDasdScb->Fcb;

    //
    //  Make sure the volume doesn't already have an object id.
    //

    Status = NtfsGetObjectIdInternal( IrpContext, DasdFcb, FALSE, &OldObjectIdBuffer );

    if (NT_SUCCESS( Status )) {

        // 
        //  This volume apparently has an object id, so we need to delete it.
        // 

        Status = NtfsDeleteObjectIdInternal( IrpContext, DasdFcb, Vcb, TRUE );
        
        //
        //  The volume currently has no object id, so update the in-memory object id.
        //
        
        if (NT_SUCCESS( Status )) {
        
            RtlZeroMemory( Vcb->VolumeObjectId,
                           OBJECT_ID_KEY_LENGTH );

            ClearFlag( Vcb->VcbState, VCB_STATE_VALID_OBJECT_ID );                            
        }
        
    } else if ((Status == STATUS_OBJECTID_NOT_FOUND) || 
               (Status == STATUS_OBJECT_NAME_NOT_FOUND)) {    

        //
        //  This volume does not have an object id, but nothing else went wrong
        //  while we were checking, so let's proceed normally.
        //

        Status = STATUS_SUCCESS;
        
    } else {

        //
        //  The object id lookup failed for some unexpected reason.
        //  Let's get out of here and return that status to our caller.
        //
        
        return Status;
    }

    //
    //  If we either didn't find an object id, or successfully deleted one,
    //  let's set the new object id.
    //
    
    if (NT_SUCCESS( Status )) {
    
        //
        //  I'd rather do one copy for the entire structure than one for 
        //  the indexed part, and another for the extended info.  I'd 
        //  like to assert that the strucutres are still the same and I
        //  can safely do that.
        //
        
        ASSERT( sizeof( ObjectIdBuffer ) == sizeof( *Buffer ) );

        RtlCopyMemory( &ObjectIdBuffer, 
                       Buffer, 
                       sizeof( ObjectIdBuffer ) );
        
        //
        //  Set this object id for the $Volume file.
        //
        
        Status = NtfsSetObjectIdInternal( IrpContext,
                                          DasdFcb,
                                          Vcb,
                                          &ObjectIdBuffer );

        //
        //  If all went well, update the in-memory object id.
        //
        
        if (NT_SUCCESS( Status )) {
        
            RtlCopyMemory( Vcb->VolumeObjectId,
                           &ObjectIdBuffer.ObjectId,
                           OBJECT_ID_KEY_LENGTH );
                           
            SetFlag( Vcb->VcbState, VCB_STATE_VALID_OBJECT_ID );                            
        }
    }
    
    return Status;                                      
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\strucsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    StrucSup.c


Abstract:

    This module implements the Ntfs in-memory data structure manipulation
    routines

Author:

    Gary Kimura     [GaryKi]        21-May-1991
    Tom Miller      [TomM]          9-Sep-1991

Revision History:

--*/

#include "NtfsProc.h"
#include "lockorder.h"

//
//  Temporarily reference our local attribute definitions
//

extern ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[];

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_STRUCSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('sFtN')

//
//  Define a structure to use when renaming or moving Lcb's so that
//  all the allocation for new filenames will succeed before munging names.
//  This new allocation can be for the filename attribute in an Lcb or the
//  filename in a Ccb.
//

typedef struct _NEW_FILENAME {

    //
    //  Ntfs structure which needs the allocation.
    //

    PVOID Structure;
    PVOID NewAllocation;

} NEW_FILENAME;
typedef NEW_FILENAME *PNEW_FILENAME;


//
//  Local support routines
//

VOID
NtfsCheckScbForCache (
    IN OUT PSCB Scb
    );

BOOLEAN
NtfsRemoveScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN CheckForAttributeTable
    );

BOOLEAN
NtfsPrepareFcbForRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB StartingScb OPTIONAL,
    IN BOOLEAN CheckForAttributeTable
    );

VOID
NtfsTeardownFromLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB StartingFcb,
    IN PLCB StartingLcb,
    IN BOOLEAN CheckForAttributeTable,
    IN ULONG AcquireFlags,
    OUT PBOOLEAN RemovedStartingLcb,
    OUT PBOOLEAN RemovedStartingFcb
    );

VOID
NtfsReserveCcbNamesInLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PULONG ParentNameLength OPTIONAL,
    IN ULONG LastComponentNameLength
    );

VOID
NtfsClearRecursiveLcb (
    IN PLCB Lcb
    );


//
//  The following local routines are for manipulating the Fcb Table.
//  The first three are generic table calls backs.
//

RTL_GENERIC_COMPARE_RESULTS
NtfsFcbTableCompare (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    );

//
//  VOID
//  NtfsInsertFcbTableEntry (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN FILE_REFERENCE FileReference
//      );
//

#if (DBG || defined( NTFS_FREE_ASSERTS ))
#define NtfsInsertFcbTableEntry(IC,V,F,FR) {                            \
    FCB_TABLE_ELEMENT _Key;                                             \
    PFCB_TABLE_ELEMENT _NewKey;                                         \
    _Key.FileReference = (FR);                                          \
    _Key.Fcb = (F);                                                     \
    _NewKey = RtlInsertElementGenericTable( &(V)->FcbTable,             \
                                            &_Key,                      \
                                            sizeof(FCB_TABLE_ELEMENT),  \
                                            NULL );                     \
    ASSERT( _NewKey->Fcb == _Key.Fcb );                                 \
}
#else
#define NtfsInsertFcbTableEntry(IC,V,F,FR) {                        \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.FileReference = (FR);                                      \
    _Key.Fcb = (F);                                                 \
    (VOID) RtlInsertElementGenericTable( &(V)->FcbTable,            \
                                         &_Key,                     \
                                         sizeof(FCB_TABLE_ELEMENT), \
                                         NULL );                    \
}
#endif

//
//  VOID
//  NtfsInsertFcbTableEntryFull (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN FILE_REFERENCE FileReference,
//      IN PVOID NodeOrParent,
//      IN ULONG SearchResult
//      );
//

#if (DBG || defined( NTFS_FREE_ASSERTS ))
#define NtfsInsertFcbTableEntryFull(IC,V,F,FR,N,SR) {                       \
    FCB_TABLE_ELEMENT _Key;                                                 \
    PFCB_TABLE_ELEMENT _NewKey;                                             \
    _Key.FileReference = (FR);                                              \
    _Key.Fcb = (F);                                                         \
    _NewKey = RtlInsertElementGenericTableFull( &(V)->FcbTable,             \
                                                &_Key,                      \
                                                sizeof(FCB_TABLE_ELEMENT),  \
                                                NULL,                       \
                                                (N),                        \
                                                (SR)                        \
                                                );                          \
    ASSERT( _NewKey->Fcb == _Key.Fcb );                                     \
}
#else
#define NtfsInsertFcbTableEntryFull(IC,V,F,FR,N,SR) {                   \
    FCB_TABLE_ELEMENT _Key;                                             \
    _Key.FileReference = (FR);                                          \
    _Key.Fcb = (F);                                                     \
    (VOID) RtlInsertElementGenericTableFull( &(V)->FcbTable,            \
                                             &_Key,                     \
                                             sizeof(FCB_TABLE_ELEMENT), \
                                             NULL,                      \
                                             (N),                       \
                                             (SR)                       \
                                             );                         \
}
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAllocateCompressionSync)
#pragma alloc_text(PAGE, NtfsBuildNormalizedName)
#pragma alloc_text(PAGE, NtfsBuildRelativeName)
#pragma alloc_text(PAGE, NtfsCheckScbForCache)
#pragma alloc_text(PAGE, NtfsClearRecursiveLcb)
#pragma alloc_text(PAGE, NtfsCombineLcbs)
#pragma alloc_text(PAGE, NtfsCreateCcb)
#pragma alloc_text(PAGE, NtfsCreateFcb)
#pragma alloc_text(PAGE, NtfsCreateFileLock)
#pragma alloc_text(PAGE, NtfsCreateLcb)
#pragma alloc_text(PAGE, NtfsCreatePrerestartScb)
#pragma alloc_text(PAGE, NtfsCreateRootFcb)
#pragma alloc_text(PAGE, NtfsCreateScb)
#pragma alloc_text(PAGE, NtfsDeallocateCompressionSync)
#pragma alloc_text(PAGE, NtfsDeleteCcb)
#pragma alloc_text(PAGE, NtfsDeleteFcb)
#pragma alloc_text(PAGE, NtfsDeleteLcb)
#pragma alloc_text(PAGE, NtfsDeleteNormalizedName)
#pragma alloc_text(PAGE, NtfsDeleteScb)
#pragma alloc_text(PAGE, NtfsDeleteVcb)
#pragma alloc_text(PAGE, NtfsFcbTableCompare)
#pragma alloc_text(PAGE, NtfsGetDeallocatedClusters)
#pragma alloc_text(PAGE, NtfsGetNextFcbTableEntry)
#pragma alloc_text(PAGE, NtfsGetNextScb)
#pragma alloc_text(PAGE, NtfsInitializeVcb)
#pragma alloc_text(PAGE, NtfsLookupLcbByFlags)
#pragma alloc_text(PAGE, NtfsMoveLcb)
#pragma alloc_text(PAGE, NtfsPostToNewLengthQueue)
#pragma alloc_text(PAGE, NtfsProcessNewLengthQueue)
#pragma alloc_text(PAGE, NtfsRemoveScb)
#pragma alloc_text(PAGE, NtfsRenameLcb)
#pragma alloc_text(PAGE, NtfsReserveCcbNamesInLcb)
#pragma alloc_text(PAGE, NtfsTeardownStructures)
#pragma alloc_text(PAGE, NtfsTestStatusProc)
#pragma alloc_text(PAGE, NtfsUpdateNormalizedName)
#pragma alloc_text(PAGE, NtfsUpdateScbSnapshots)
#pragma alloc_text(PAGE, NtfsWalkUpTree)
#endif


VOID
NtfsInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG NumberProcessors;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeVcb, Vcb = %08lx\n", Vcb) );

    //
    //  First zero out the Vcb
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    //  Set the node type code and size
    //

    Vcb->NodeTypeCode = NTFS_NTC_VCB;
    Vcb->NodeByteSize = sizeof(VCB);

    //
    //  Set the following Vcb flags before putting the Vcb in the
    //  Vcb queue.  This will lock out checkpoints until the
    //  volume is mounted.
    //

    SetFlag( Vcb->CheckpointFlags,
             VCB_CHECKPOINT_IN_PROGRESS |
             VCB_LAST_CHECKPOINT_CLEAN |
             VCB_LAST_CHECKPOINT_PSEUDO_CLEAN);

    //
    //  Insert this vcb record into the vcb queue off of the global data
    //  record
    //

    InsertTailList( &NtfsData.VcbQueue, &Vcb->VcbLinks );

    //
    //  Set the target device object and vpb fields
    //

    ObReferenceObject( TargetDeviceObject );
    Vcb->TargetDeviceObject = TargetDeviceObject;
    Vcb->Vpb = Vpb;

    //
    //  Set the state and condition fields.  The removable media flag
    //  is set based on the real device's characteristics.
    //

    if (FlagOn(Vpb->RealDevice->Characteristics, FILE_REMOVABLE_MEDIA)) {

        SetFlag( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA );
    }

    SetFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

    //
    //  Initialized the ModifiedOpenFilesListhead and the delete notify queue.
    //

    InitializeListHead( &Vcb->NotifyUsnDeleteIrps );
    InitializeListHead( &Vcb->ModifiedOpenFiles );
    InitializeListHead( &Vcb->TimeOutListA );
    InitializeListHead( &Vcb->TimeOutListB );

    Vcb->CurrentTimeOutFiles = &Vcb->TimeOutListA;
    Vcb->AgedTimeOutFiles = &Vcb->TimeOutListB;

    //
    //  Initialize list of OpenAttribute structures.
    //

    InitializeListHead( &Vcb->OpenAttributeData );

    //
    //  Initialize list of deallocated clusters
    //

    InitializeListHead( &Vcb->DeallocatedClusterListHead );

    //
    //  Initialize the synchronization objects in the Vcb.
    //

    ExInitializeResourceLite( &Vcb->Resource );
    ExInitializeResourceLite( &Vcb->MftFlushResource );

    ExInitializeFastMutex( &Vcb->FcbTableMutex );
    ExInitializeFastMutex( &Vcb->FcbSecurityMutex );
    ExInitializeFastMutex( &Vcb->ReservedClustersMutex );
    ExInitializeFastMutex( &Vcb->HashTableMutex );
    ExInitializeFastMutex( &Vcb->CheckpointMutex );
    ExInitializeFastMutex( &Vcb->ReservedMappingMutex );

    KeInitializeEvent( &Vcb->CheckpointNotifyEvent, NotificationEvent, TRUE );

    //
    //  Initialize the Fcb Table
    //

    RtlInitializeGenericTable( &Vcb->FcbTable,
                               NtfsFcbTableCompare,
                               NtfsAllocateFcbTableEntry,
                               NtfsFreeFcbTableEntry,
                               NULL );

    //
    //  Initialize the property tunneling structure
    //

    FsRtlInitializeTunnelCache(&Vcb->Tunnel);


#ifdef BENL_DBG
    InitializeListHead( &(Vcb->RestartRedoHead) );
    InitializeListHead( &(Vcb->RestartUndoHead) );
#endif

    //
    //  Initialize the transactions done event
    //

    KeInitializeEvent( &Vcb->TransactionsDoneEvent, NotificationEvent, FALSE );

    //
    //  Possible calls that might fail begins here
    //

    //
    //  Initialize the list head and mutex for the dir notify Irps.
    //  Also the rename resource.
    //

    InitializeListHead( &Vcb->DirNotifyList );
    InitializeListHead( &Vcb->ViewIndexNotifyList );
    FsRtlNotifyInitializeSync( &Vcb->NotifySync );

    //
    //  Allocate and initialize struct array for performance data.  This
    //  attempt to allocate could raise STATUS_INSUFFICIENT_RESOURCES.
    //

    NumberProcessors = KeNumberProcessors;
    Vcb->Statistics = NtfsAllocatePool( NonPagedPool,
                                         sizeof(FILE_SYSTEM_STATISTICS) * NumberProcessors );

    RtlZeroMemory( Vcb->Statistics, sizeof(FILE_SYSTEM_STATISTICS) * NumberProcessors );

    for (i = 0; i < NumberProcessors; i += 1) {
        Vcb->Statistics[i].Common.FileSystemType = FILESYSTEM_STATISTICS_TYPE_NTFS;
        Vcb->Statistics[i].Common.Version = 1;
        Vcb->Statistics[i].Common.SizeOfCompleteStructure =
            sizeof(FILE_SYSTEM_STATISTICS);
    }

    //
    //  Initialize the cached runs.
    //

    NtfsInitializeCachedRuns( &Vcb->CachedRuns );

#ifdef NTFS_CHECK_CACHED_RUNS
    Vcb->CachedRuns.Vcb = Vcb;
#endif

    //
    //  Initialize the hash table.
    //

    NtfsInitializeHashTable( &Vcb->HashTable );

    //
    //  Allocate a spare Vpb for the dismount case.
    //

    Vcb->SpareVpb = NtfsAllocatePoolWithTag( NonPagedPool, sizeof( VPB ), 'VftN' );

    //
    //  Capture the current change count in the device we talk to.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA )) {

        ULONG ChangeCount = 0;

        NtfsDeviceIoControlAsync( IrpContext,
                                  Vcb->TargetDeviceObject,
                                  IOCTL_DISK_CHECK_VERIFY,
                                  (PVOID) &ChangeCount,
                                  sizeof( ChangeCount ));

        //
        //  Ignore any error for now.  We will see it later if there is
        //  one.
        //

        Vcb->DeviceChangeCount = ChangeCount;
    }

    //
    //  Set the dirty page table hint to its initial value
    //

    Vcb->DirtyPageTableSizeHint = INITIAL_DIRTY_TABLE_HINT;

    //
    //  Initialize the recently deallocated cluster mcbs and put the 1st one on the list.
    //

    FsRtlInitializeLargeMcb( &Vcb->DeallocatedClusters1.Mcb, PagedPool );
    FsRtlInitializeLargeMcb( &Vcb->DeallocatedClusters2.Mcb, PagedPool );

    Vcb->DeallocatedClusters1.Lsn.QuadPart = 0;
    InsertHeadList( &Vcb->DeallocatedClusterListHead, &Vcb->DeallocatedClusters1.Link );

    //
    //  Initialize a reserved mapping buffer for mapping user data under low memory
    //

    Vcb->ReservedMapping = MmAllocateMappingAddress( 2 * PAGE_SIZE, RESERVE_POOL_TAG );
    if (!Vcb->ReservedMapping) {
        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsInitializeVcb -> VOID\n") );

    return;
}


BOOLEAN
NtfsDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB *Vcb
    )

/*++

Routine Description:

    This routine removes the Vcb record from Ntfs's in-memory data
    structures.

Arguments:

    Vcb - Supplies the Vcb to be removed

Return Value:

    BOOLEAN - TRUE if the Vcb was deleted, FALSE otherwise.

--*/

{
    PVOLUME_DEVICE_OBJECT VolDo;
    BOOLEAN AcquiredFcbTable;
    PSCB Scb;
    PFCB Fcb;
    BOOLEAN VcbDeleted = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( *Vcb );

    ASSERTMSG("Cannot delete Vcb ", !FlagOn((*Vcb)->VcbState, VCB_STATE_VOLUME_MOUNTED));

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteVcb, *Vcb = %08lx\n", *Vcb) );

    //
    //  Remember the volume device object.
    //

    VolDo = CONTAINING_RECORD( *Vcb, VOLUME_DEVICE_OBJECT, Vcb );

    //
    //  Make sure that we can really delete the vcb
    //

    ASSERT( (*Vcb)->CloseCount == 0 );

    NtOfsPurgeSecurityCache( *Vcb );

    //
    //  If the Vcb log file object is present then we need to
    //  dereference it and uninitialize it through the cache.
    //

    if (((*Vcb)->LogFileObject != NULL) &&
        !FlagOn( (*Vcb)->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE )) {

        CcUninitializeCacheMap( (*Vcb)->LogFileObject,
                                &Li0,
                                NULL );

        //
        //  Set a flag indicating that we are dereferencing the LogFileObject.
        //

        SetFlag( (*Vcb)->CheckpointFlags, VCB_DEREFERENCED_LOG_FILE );
        ObDereferenceObject( (*Vcb)->LogFileObject );
    }

    //
    //  Only proceed if the log file object went away.  In the typical case the
    //  close will come in through a recursive call from the ObDereference call
    //  above.
    //

    if ((*Vcb)->LogFileObject == NULL) {

        //
        //  If the OnDiskOat is not the same as the embedded table then
        //  free the OnDisk table.
        //

        if (((*Vcb)->OnDiskOat != NULL) &&
            ((*Vcb)->OnDiskOat != &(*Vcb)->OpenAttributeTable)) {

            NtfsFreeRestartTable( (*Vcb)->OnDiskOat );
            NtfsFreePool( (*Vcb)->OnDiskOat );
            (*Vcb)->OnDiskOat = NULL;
        }

        //
        //  Uninitialize the Mcb's for the deallocated cluster Mcb's.
        //

        if ((*Vcb)->DeallocatedClusters1.Link.Flink == NULL) {
            FsRtlUninitializeLargeMcb( &(*Vcb)->DeallocatedClusters1.Mcb );
        }
        if ((*Vcb)->DeallocatedClusters2.Link.Flink == NULL) {
            FsRtlUninitializeLargeMcb( &(*Vcb)->DeallocatedClusters2.Mcb );
        }

        while (!IsListEmpty(&(*Vcb)->DeallocatedClusterListHead )) {

            PDEALLOCATED_CLUSTERS Clusters;

            Clusters = (PDEALLOCATED_CLUSTERS) RemoveHeadList( &(*Vcb)->DeallocatedClusterListHead );
            FsRtlUninitializeLargeMcb( &Clusters->Mcb );
            if ((Clusters != &((*Vcb)->DeallocatedClusters2)) &&
                (Clusters != &((*Vcb)->DeallocatedClusters1))) {

                NtfsFreePool( Clusters );
            }
        }

        //
        //  Clean up the Root Lcb if present.
        //

        if ((*Vcb)->RootLcb != NULL) {

            //
            //  Cleanup the Lcb so the DeleteLcb routine won't look at any
            //  other structures.
            //

            InitializeListHead( &(*Vcb)->RootLcb->ScbLinks );
            InitializeListHead( &(*Vcb)->RootLcb->FcbLinks );
            ClearFlag( (*Vcb)->RootLcb->LcbState,
                       LCB_STATE_EXACT_CASE_IN_TREE | LCB_STATE_IGNORE_CASE_IN_TREE );

            NtfsDeleteLcb( IrpContext, &(*Vcb)->RootLcb );
            (*Vcb)->RootLcb = NULL;
        }

        //
        //  Make sure the Fcb table is completely emptied.  It is possible that an occasional Fcb
        //  (along with its Scb) will not be deleted when the file object closes come in.
        //

        while (TRUE) {

            PVOID RestartKey;

            //
            //  Always reinitialize the search so we get the first element in the tree.
            //

            RestartKey = NULL;
            NtfsAcquireFcbTable( IrpContext, *Vcb );
            Fcb = NtfsGetNextFcbTableEntry( *Vcb, &RestartKey );
            NtfsReleaseFcbTable( IrpContext, *Vcb );

            if (Fcb == NULL) { break; }

            while ((Scb = NtfsGetNextChildScb( Fcb, NULL )) != NULL) {

                NtfsDeleteScb( IrpContext, &Scb );
            }

            NtfsAcquireFcbTable( IrpContext, *Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );
        }

        //
        //  Free the upcase table and attribute definitions.  The upcase
        //  table only gets freed if it is not the global table.
        //

        if (((*Vcb)->UpcaseTable != NULL) && ((*Vcb)->UpcaseTable != NtfsData.UpcaseTable)) {

            NtfsFreePool( (*Vcb)->UpcaseTable );
        }

        (*Vcb)->UpcaseTable = NULL;

        if (((*Vcb)->AttributeDefinitions != NULL) &&
            ((*Vcb)->AttributeDefinitions != NtfsAttributeDefinitions)) {

            NtfsFreePool( (*Vcb)->AttributeDefinitions );
            (*Vcb)->AttributeDefinitions = NULL;
        }

        //
        //  Free the device name string if present.
        //

        if ((*Vcb)->DeviceName.Buffer != NULL) {

            NtfsFreePool( (*Vcb)->DeviceName.Buffer );
            (*Vcb)->DeviceName.Buffer = NULL;
        }

        FsRtlNotifyUninitializeSync( &(*Vcb)->NotifySync );

        //
        //  We will free the structure allocated for the Lfs handle.
        //

        LfsDeleteLogHandle( (*Vcb)->LogHandle );
        (*Vcb)->LogHandle = NULL;

        //
        //  Delete the vcb resource and also free the restart tables
        //

        //
        //  Empty the list of OpenAttribute Data.
        //

        NtfsFreeAllOpenAttributeData( *Vcb );

        NtfsFreeRestartTable( &(*Vcb)->OpenAttributeTable );
        NtfsFreeRestartTable( &(*Vcb)->TransactionTable );

        //
        //  The Vpb in the Vcb may be a temporary Vpb and we should free it here.
        //

        if (FlagOn( (*Vcb)->VcbState, VCB_STATE_TEMP_VPB )) {

            NtfsFreePool( (*Vcb)->Vpb );
            (*Vcb)->Vpb = NULL;
        }

        //
        //  Uninitialize the hash table.
        //

        NtfsUninitializeHashTable( &(*Vcb)->HashTable );

        ExDeleteResourceLite( &(*Vcb)->Resource );
        ExDeleteResourceLite( &(*Vcb)->MftFlushResource );

        //
        //  Delete the space used to store performance counters.
        //

        if ((*Vcb)->Statistics != NULL) {
            NtfsFreePool( (*Vcb)->Statistics );
            (*Vcb)->Statistics = NULL;
        }

        //
        //  Tear down the file property tunneling structure
        //

        FsRtlDeleteTunnelCache(&(*Vcb)->Tunnel);

#ifdef NTFS_CHECK_BITMAP
        if ((*Vcb)->BitmapCopy != NULL) {

            ULONG Count = 0;

            while (Count < (*Vcb)->BitmapPages) {

                if (((*Vcb)->BitmapCopy + Count)->Buffer != NULL) {

                    NtfsFreePool( ((*Vcb)->BitmapCopy + Count)->Buffer );
                }

                Count += 1;
            }

            NtfsFreePool( (*Vcb)->BitmapCopy );
            (*Vcb)->BitmapCopy = NULL;
        }
#endif

        //
        //  Release the reserved mapping
        //

        if ((*Vcb)->ReservedMapping) {
            MmFreeMappingAddress( (*Vcb)->ReservedMapping, RESERVE_POOL_TAG );
        }

        //
        // Drop the reference on the target device object
        //

        ObDereferenceObject( (*Vcb)->TargetDeviceObject );

        //
        //  Check that the Usn queues are empty.
        //

        ASSERT( IsListEmpty( &(*Vcb)->NotifyUsnDeleteIrps ));
        ASSERT( IsListEmpty( &(*Vcb)->ModifiedOpenFiles ));
        ASSERT( IsListEmpty( &(*Vcb)->TimeOutListA ));
        ASSERT( IsListEmpty( &(*Vcb)->TimeOutListB ));

        //
        //  Unnitialize the cached runs.
        //

        NtfsUninitializeCachedRuns( &(*Vcb)->CachedRuns );

        //
        //  Free any spare Vpb we might have stored in the Vcb.
        //

        if ((*Vcb)->SpareVpb != NULL) {

            NtfsFreePool( (*Vcb)->SpareVpb );
            (*Vcb)->SpareVpb = NULL;
        }

        //
        //  Return the Vcb (i.e., the VolumeDeviceObject) to pool and null out
        //  the input pointer to be safe
        //

        IoDeleteDevice( (PDEVICE_OBJECT)VolDo );

        *Vcb = NULL;
        VcbDeleted = TRUE;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteVcb -> VOID\n") );

    return VcbDeleted;
}


PFCB
NtfsCreateRootFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new root FCB record
    into the in memory data structure.  It also creates the necessary Root LCB
    record and inserts the root name into the prefix table.

Arguments:

    Vcb - Supplies the Vcb to associate with the new root Fcb and Lcb

Return Value:

    PFCB - returns pointer to the newly allocated root FCB.

--*/

{
    PFCB RootFcb;
    PLCB RootLcb;

    //
    //  The following variables are only used for abnormal termination
    //

    PVOID UnwindStorage = NULL;
    PERESOURCE UnwindResource = NULL;
    PFAST_MUTEX UnwindFastMutex = NULL;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    DebugTrace( +1, Dbg, ("NtfsCreateRootFcb, Vcb = %08lx\n", Vcb) );

    try {

        //
        //  Allocate a new fcb and zero it out.  We use Fcb locally so we
        //  don't have to continually go through the Vcb
        //

        RootFcb =
        UnwindStorage = (PFCB)ExAllocateFromPagedLookasideList( &NtfsFcbIndexLookasideList );

        RtlZeroMemory( RootFcb, sizeof(FCB_INDEX) );

        //
        //  Set the proper node type code and byte size
        //

        RootFcb->NodeTypeCode = NTFS_NTC_FCB;
        RootFcb->NodeByteSize = sizeof(FCB);

        SetFlag( RootFcb->FcbState, FCB_STATE_COMPOUND_INDEX );

        //
        //  Initialize the Lcb queue and point back to our Vcb.
        //

        InitializeListHead( &RootFcb->LcbQueue );

        RootFcb->Vcb = Vcb;

        //
        //  File Reference
        //

        NtfsSetSegmentNumber( &RootFcb->FileReference,
                              0,
                              ROOT_FILE_NAME_INDEX_NUMBER );
        RootFcb->FileReference.SequenceNumber = ROOT_FILE_NAME_INDEX_NUMBER;

        //
        //  Initialize the Scb
        //

        InitializeListHead( &RootFcb->ScbQueue );

        //
        //  Allocate and initialize the resource variable
        //

        UnwindResource = RootFcb->Resource = NtfsAllocateEresource();

        //
        //  Allocate and initialize the Fcb fast mutex.
        //

        UnwindFastMutex =
        RootFcb->FcbMutex = NtfsAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));
        ExInitializeFastMutex( UnwindFastMutex );

        //
        //  Insert this new fcb into the fcb table
        //

        NtfsInsertFcbTableEntry( IrpContext, Vcb, RootFcb, RootFcb->FileReference );
        SetFlag( RootFcb->FcbState, FCB_STATE_IN_FCB_TABLE );

        //
        //  Now insert this new root fcb into it proper position in the graph with a
        //  root lcb.  First allocate an initialize the root lcb and then build the
        //  lcb/scb graph.
        //

        {
            //
            //  Use the root Lcb within the Fcb.
            //

            RootLcb = Vcb->RootLcb = (PLCB) &((PFCB_INDEX) RootFcb)->Lcb;

            RootLcb->NodeTypeCode = NTFS_NTC_LCB;
            RootLcb->NodeByteSize = sizeof(LCB);

            //
            //  Insert the root lcb into the Root Fcb's queue
            //

            InsertTailList( &RootFcb->LcbQueue, &RootLcb->FcbLinks );
            RootLcb->Fcb = RootFcb;

            //
            //  Use the embedded file name attribute.
            //

            RootLcb->FileNameAttr = (PFILE_NAME) &RootLcb->ParentDirectory;

            RootLcb->FileNameAttr->ParentDirectory = RootFcb->FileReference;
            RootLcb->FileNameAttr->FileNameLength = 1;
            RootLcb->FileNameAttr->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

            RootLcb->ExactCaseLink.LinkName.Buffer = (PWCHAR) &RootLcb->FileNameAttr->FileName;

            RootLcb->IgnoreCaseLink.LinkName.Buffer = Add2Ptr( RootLcb->FileNameAttr,
                                                               NtfsFileNameSizeFromLength( 2 ));

            RootLcb->ExactCaseLink.LinkName.MaximumLength =
            RootLcb->ExactCaseLink.LinkName.Length =
            RootLcb->IgnoreCaseLink.LinkName.MaximumLength =
            RootLcb->IgnoreCaseLink.LinkName.Length = 2;

            RootLcb->ExactCaseLink.LinkName.Buffer[0] =
            RootLcb->IgnoreCaseLink.LinkName.Buffer[0] = L'\\';

            SetFlag( RootLcb->FileNameAttr->Flags, FILE_NAME_NTFS | FILE_NAME_DOS );

            //
            //  Initialize both the ccb.
            //

            InitializeListHead( &RootLcb->CcbQueue );
        }

    } finally {

        DebugUnwind( NtfsCreateRootFcb );

        if (AbnormalTermination()) {

            if (UnwindResource)   { NtfsFreeEresource( UnwindResource ); }
            if (UnwindStorage) { NtfsFreePool( UnwindStorage ); }
            if (UnwindFastMutex) { NtfsFreePool( UnwindFastMutex ); }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateRootFcb -> %8lx\n", RootFcb) );

    return RootFcb;
}


PFCB
NtfsCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_REFERENCE FileReference,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN LargeFcb,
    OUT PBOOLEAN ReturnedExistingFcb OPTIONAL
    )

/*++

Routine Description:

    This routine allocates and initializes a new Fcb record. The record
    is not placed within the Fcb/Scb graph but is only inserted in the
    FcbTable.

Arguments:

    Vcb - Supplies the Vcb to associate the new FCB under.

    FileReference - Supplies the file reference to use to identify the
        Fcb with.  We will search the Fcb table for any preexisting
        Fcb's with the same file reference number.

    IsPagingFile - Indicates if we are creating an FCB for a paging file
        or some other type of file.

    LargeFcb - Indicates if we should use the larger of the compound Fcb's.

    ReturnedExistingFcb - Optionally indicates to the caller if the
        returned Fcb already existed

Return Value:

    PFCB - Returns a pointer to the newly allocated FCB

--*/

{
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Entry;

    PFCB Fcb;

    PVOID NodeOrParent;
    TABLE_SEARCH_RESULT SearchResult;

    BOOLEAN LocalReturnedExistingFcb;
    BOOLEAN DeletedOldFcb = FALSE;

    //
    //  The following variables are only used for abnormal termination
    //

    PVOID UnwindStorage = NULL;
    PERESOURCE UnwindResource = NULL;
    PFAST_MUTEX UnwindFastMutex = NULL;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT_SHARED_RESOURCE( &Vcb->Resource );

    DebugTrace( +1, Dbg, ("NtfsCreateFcb\n") );

    if (!ARGUMENT_PRESENT(ReturnedExistingFcb)) { ReturnedExistingFcb = &LocalReturnedExistingFcb; }

    //
    //  First search the FcbTable for a matching fcb
    //

    Key.FileReference = FileReference;
    Fcb = NULL;

    if ((Entry = RtlLookupElementGenericTableFull( &Vcb->FcbTable, &Key, &NodeOrParent, &SearchResult )) != NULL) {

        Fcb = Entry->Fcb;

        //
        //  It's possible that this Fcb has been deleted but in truncating and
        //  growing the Mft we are reusing some of the file references.
        //  If this file has been deleted but the Fcb is waiting around for
        //  closes, we will remove it from the Fcb table and create a new Fcb
        //  below.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

            //
            //  Remove it from the Fcb table and remember to create an
            //  Fcb below.
            //

            NtfsDeleteFcbTableEntry( Fcb->Vcb,
                                     Fcb->FileReference );

            ClearFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );
            DeletedOldFcb = TRUE;
            Fcb = NULL;

        } else {

            *ReturnedExistingFcb = TRUE;
        }
    }

    //
    //  Now check if we have an Fcb.
    //

    if (Fcb == NULL) {

        *ReturnedExistingFcb = FALSE;

        try {

            //
            //  Allocate a new FCB and zero it out.
            //

            if (IsPagingFile ||
                NtfsSegmentNumber( &FileReference ) <= MASTER_FILE_TABLE2_NUMBER ||
                NtfsSegmentNumber( &FileReference ) == BAD_CLUSTER_FILE_NUMBER ||
                NtfsSegmentNumber( &FileReference ) == BIT_MAP_FILE_NUMBER) {

                Fcb = UnwindStorage = NtfsAllocatePoolWithTag( NonPagedPool,
                                                               sizeof(FCB),
                                                               'fftN' );
                RtlZeroMemory( Fcb, sizeof(FCB) );

                if (IsPagingFile) {

                    //
                    //  We can't have the pagingfile on a readonly volume.
                    //

                    if (NtfsIsVolumeReadOnly( Vcb )) {
                        NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
                    }

                    SetFlag( Fcb->FcbState, FCB_STATE_PAGING_FILE );

                    //
                    //  We don't want to dismount this volume now that
                    //  we have a pagefile open on it.
                    //

                    SetFlag( Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT );
                }

                SetFlag( Fcb->FcbState, FCB_STATE_NONPAGED );

            } else {

                if (LargeFcb) {

                    Fcb = UnwindStorage =
                        (PFCB)ExAllocateFromPagedLookasideList( &NtfsFcbIndexLookasideList );

                    RtlZeroMemory( Fcb, sizeof( FCB_INDEX ));
                    SetFlag( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX );

                } else {

                    Fcb = UnwindStorage =
                        (PFCB)ExAllocateFromPagedLookasideList( &NtfsFcbDataLookasideList );

                    RtlZeroMemory( Fcb, sizeof( FCB_DATA ));
                    SetFlag( Fcb->FcbState, FCB_STATE_COMPOUND_DATA );
                }
            }

            //
            //  Set the proper node type code and byte size
            //

            Fcb->NodeTypeCode = NTFS_NTC_FCB;
            Fcb->NodeByteSize = sizeof(FCB);

            //
            //  Initialize the Lcb queue and point back to our Vcb, and indicate
            //  that we are a directory
            //

            InitializeListHead( &Fcb->LcbQueue );

            Fcb->Vcb = Vcb;

            //
            //  File Reference
            //

            Fcb->FileReference = FileReference;

            //
            //  Initialize the Scb
            //

            InitializeListHead( &Fcb->ScbQueue );

            //
            //  Allocate and initialize the resource variable
            //

            UnwindResource = Fcb->Resource = NtfsAllocateEresource();

            //
            //  Allocate and initialize fast mutex for the Fcb.
            //

            UnwindFastMutex = Fcb->FcbMutex = NtfsAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));
            ExInitializeFastMutex( UnwindFastMutex );

            //
            //  Insert this new fcb into the fcb table. We have to use the basic
            //  version of this function when we deleted an old fcb because the "smarter" one
            //  will just return back the old entry rather than researching
            //

            if (DeletedOldFcb) {
                NtfsInsertFcbTableEntry( IrpContext, Vcb, Fcb, FileReference );
            } else {
                NtfsInsertFcbTableEntryFull( IrpContext, Vcb, Fcb, FileReference, NodeOrParent, SearchResult );
            }


            SetFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );

            //
            //  Set the flag to indicate if this is a system file.
            //

            if (NtfsSegmentNumber( &FileReference ) < FIRST_USER_FILE_NUMBER) {

                SetFlag( Fcb->FcbState, FCB_STATE_SYSTEM_FILE );
            }

        } finally {

            DebugUnwind( NtfsCreateFcb );

            if (AbnormalTermination()) {

                if (UnwindFastMutex) { NtfsFreePool( UnwindFastMutex ); }
                if (UnwindResource)   { NtfsFreeEresource( UnwindResource ); }
                if (UnwindStorage) { NtfsFreePool( UnwindStorage ); }
            }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateFcb -> %08lx\n", Fcb) );

    return Fcb;
}


VOID
NtfsDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *Fcb,
    OUT PBOOLEAN AcquiredFcbTable
    )

/*++

Routine Description:

    This routine deallocates and removes an FCB record from all Ntfs's in-memory
    data structures.  It assumes that it does not have anything Scb children nor
    does it have any lcb edges going into it at the time of the call.

Arguments:

    Fcb - Supplies the FCB to be removed

    AcquiredFcbTable - Set to FALSE when this routine releases the
        FcbTable.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( *Fcb );
    ASSERT( IsListEmpty(&(*Fcb)->ScbQueue) );
    ASSERT( (NodeType(*Fcb) == NTFS_NTC_FCB) );

    DebugTrace( +1, Dbg, ("NtfsDeleteFcb, *Fcb = %08lx\n", *Fcb) );

    //
    //  First free any possible Scb snapshots.
    //

    NtfsFreeSnapshotsForFcb( IrpContext, *Fcb );

    //
    //  This Fcb may be in the ExclusiveFcb list of the IrpContext.
    //  If it is (The Flink is not NULL), we remove it.
    //  And release the global resource.
    //

    if ((*Fcb)->ExclusiveFcbLinks.Flink != NULL) {

        RemoveEntryList( &(*Fcb)->ExclusiveFcbLinks );
    }

    //
    //  Clear the IrpContext field for any request which may own the paging
    //  IO resource for this Fcb.
    //

    if (IrpContext->CleanupStructure == *Fcb) {

        IrpContext->CleanupStructure = NULL;

    } else if (IrpContext->TopLevelIrpContext->CleanupStructure == *Fcb) {

        IrpContext->TopLevelIrpContext->CleanupStructure = NULL;
    }

    //
    //  Either we own the FCB or nobody should own it.  The extra acquire
    //  here does not matter since we will free the resource below.
    //

    ASSERT( NtfsAcquireResourceExclusive( IrpContext, (*Fcb), FALSE ));
    ASSERT( ExGetSharedWaiterCount( (*Fcb)->Resource ) == 0 );
    ASSERT( ExGetExclusiveWaiterCount( (*Fcb)->Resource) == 0 );

#ifdef NTFSDBG

    //
    //  Lock order package needs to know this resource is gone
    //

    if (IrpContext->Vcb && FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
        NtfsChangeResourceOrderState( IrpContext, NtfsIdentifyFcb( IrpContext->Vcb, *Fcb ), TRUE, FALSE );
    }
#endif

    //
    //  Deallocate the resources protecting the Fcb
    //

    NtfsFreeEresource( (*Fcb)->Resource );

    if ( (*Fcb)->PagingIoResource != NULL ) {

        if (IrpContext->CleanupStructure == *Fcb) {
            IrpContext->CleanupStructure = NULL;
        }

        NtfsFreeEresource( (*Fcb)->PagingIoResource );
    }

    //
    //  Deallocate the fast mutex.
    //

    if ((*Fcb)->FcbMutex != NULL) {

        NtfsFreePool( (*Fcb)->FcbMutex );
    }

    //
    //  Remove the fcb from the fcb table if present.
    //

    if (FlagOn( (*Fcb)->FcbState, FCB_STATE_IN_FCB_TABLE )) {

        NtfsDeleteFcbTableEntry( (*Fcb)->Vcb, (*Fcb)->FileReference );
        ClearFlag( (*Fcb)->FcbState, FCB_STATE_IN_FCB_TABLE );
    }

    NtfsReleaseFcbTable( IrpContext, (*Fcb)->Vcb );
    *AcquiredFcbTable = FALSE;

    //
    //  Dereference and possibly deallocate the security descriptor if present.
    //

    if ((*Fcb)->SharedSecurity != NULL) {

        NtfsAcquireFcbSecurity( (*Fcb)->Vcb );
        RemoveReferenceSharedSecurityUnsafe( &(*Fcb)->SharedSecurity );
        NtfsReleaseFcbSecurity( (*Fcb)->Vcb );
    }

    //
    //  Release the quota control block.
    //

    if (NtfsPerformQuotaOperation( *Fcb )) {
        NtfsDereferenceQuotaControlBlock( (*Fcb)->Vcb, &(*Fcb)->QuotaControl );
    }

    //
    //  Delete the UsnRecord if one exists.
    //

    if ((*Fcb)->FcbUsnRecord != NULL) {

        PUSN_FCB ThisUsn, LastUsn;

        //
        //  See if the Fcb is in one of the Usn blocks.
        //

        ThisUsn = &IrpContext->Usn;

        do {

            if (ThisUsn->CurrentUsnFcb == (*Fcb)) {

                //
                //  Cleanup the UsnFcb in the IrpContext.  It's possible that
                //  we might want to reuse the UsnFcb later in this request.
                //

                if (ThisUsn != &IrpContext->Usn) {

                    LastUsn->NextUsnFcb = ThisUsn->NextUsnFcb;
                    NtfsFreePool( ThisUsn );

                } else {

                    ThisUsn->CurrentUsnFcb = NULL;
                    ThisUsn->NewReasons = 0;
                    ThisUsn->RemovedSourceInfo = 0;
                    ThisUsn->UsnFcbFlags = 0;
                }
                break;
            }

            if (ThisUsn->NextUsnFcb == NULL) { break; }

            LastUsn = ThisUsn;
            ThisUsn = ThisUsn->NextUsnFcb;

        } while (TRUE);

        //
        //  Remove the Fcb from the list in the Usn journal.
        //

        if ((*Fcb)->FcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL) {
            NtfsLockFcb( IrpContext, (*Fcb)->Vcb->UsnJournal->Fcb );
            RemoveEntryList( &(*Fcb)->FcbUsnRecord->ModifiedOpenFilesLinks );

            if ((*Fcb)->FcbUsnRecord->TimeOutLinks.Flink != NULL) {

                RemoveEntryList( &(*Fcb)->FcbUsnRecord->TimeOutLinks );
            }
            NtfsUnlockFcb( IrpContext, (*Fcb)->Vcb->UsnJournal->Fcb );
        }

        NtfsFreePool( (*Fcb)->FcbUsnRecord );
    }

    //
    //  Let our top-level caller know the Fcb was deleted.
    //

    if ((*Fcb)->FcbContext != NULL) {

        (*Fcb)->FcbContext->FcbDeleted = TRUE;
    }

    //
    //  Deallocate the Fcb itself
    //

    if (FlagOn( (*Fcb)->FcbState, FCB_STATE_NONPAGED )) {

        NtfsFreePool( *Fcb );

    } else {

        if (FlagOn( (*Fcb)->FcbState, FCB_STATE_COMPOUND_INDEX )) {

            ExFreeToPagedLookasideList( &NtfsFcbIndexLookasideList, *Fcb );

        } else {

            ExFreeToPagedLookasideList( &NtfsFcbDataLookasideList, *Fcb );
        }
    }

    //
    //  Zero out the input pointer
    //

    *Fcb = NULL;

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteFcb -> VOID\n") );

    return;
}


PFCB
NtfsGetNextFcbTableEntry (
    IN PVCB Vcb,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    This routine will enumerate through all of the fcb's for the given
    vcb

Arguments:

    Vcb - Supplies the Vcb used in this operation

    RestartKey - This value is used by the table package to maintain
        its position in the enumeration.  It is initialized to NULL
        for the first search.

Return Value:

    PFCB - A pointer to the next fcb or NULL if the enumeration is
        completed

--*/

{
    PFCB Fcb;

    PAGED_CODE();

    Fcb = (PFCB) RtlEnumerateGenericTableWithoutSplaying( &Vcb->FcbTable, RestartKey );

    if (Fcb != NULL) {

        Fcb = ((PFCB_TABLE_ELEMENT)(Fcb))->Fcb;
    }

    return Fcb;
}


PSCB
NtfsCreateScb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PCUNICODE_STRING AttributeName,
    IN BOOLEAN ReturnExistingOnly,
    OUT PBOOLEAN ReturnedExistingScb OPTIONAL
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Scb record into
    the in memory data structures, provided one does not already exist
    with the identical attribute record.

Arguments:

    Fcb - Supplies the Fcb to associate the new SCB under.

    AttributeTypeCode - Supplies the attribute type code for the new Scb

    AttributeName - Supplies the attribute name for the new Scb, with
        AttributeName->Length == 0 if there is no name.

    ReturnExistingOnly - If specified as TRUE then only an existing Scb
        will be returned.  If no matching Scb exists then NULL is returned.

    ReturnedExistingScb - Indicates if this procedure found an existing
        Scb with the identical attribute record (variable is set to TRUE)
        or if this procedure needed to create a new Scb (variable is set to
        FALSE).

Return Value:

    PSCB - Returns a pointer to the newly allocated SCB or NULL if there is
        no Scb and ReturnExistingOnly is TRUE.

--*/

{
    PSCB Scb;
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    BOOLEAN LocalReturnedExistingScb;
    BOOLEAN PagingIoResource;
    BOOLEAN ModifiedNoWrite;
#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG) || defined(SYSCACHE_DEBUG))
    BOOLEAN SyscacheFile = FALSE;
#endif

    //
    //  The following variables are only used for abnormal termination
    //

    PVOID UnwindStorage[4];
    POPLOCK UnwindOplock;
    PNTFS_MCB UnwindMcb;

    PLARGE_MCB UnwindAddedClustersMcb;
    PLARGE_MCB UnwindRemovedClustersMcb;

    BOOLEAN UnwindFromQueue;

    BOOLEAN Nonpaged;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    ASSERT( AttributeTypeCode >= $STANDARD_INFORMATION );

    DebugTrace( +1, Dbg, ("NtfsCreateScb\n") );

    if (!ARGUMENT_PRESENT(ReturnedExistingScb)) { ReturnedExistingScb = &LocalReturnedExistingScb; }

    //
    //  Search the scb queue of the fcb looking for a matching
    //  attribute type code and attribute name
    //

    NtfsLockFcb( IrpContext, Fcb );

    Scb = NULL;
    while ((Scb = NtfsGetNextChildScb( Fcb, Scb )) != NULL) {

        ASSERT_SCB( Scb );

        //
        //  For every scb already in the fcb's queue check for a matching
        //  type code and name.  If we find a match we return from this
        //  procedure right away.
        //

        if ((AttributeTypeCode == Scb->AttributeTypeCode) &&
            !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED) &&
            NtfsAreNamesEqual( IrpContext->Vcb->UpcaseTable,
                               &Scb->AttributeName,
                               (PUNICODE_STRING) AttributeName,
                               FALSE )) {

            NtfsUnlockFcb( IrpContext, Fcb );
            *ReturnedExistingScb = TRUE;

            if (NtfsIsExclusiveScb(Scb)) {

                NtfsSnapshotScb( IrpContext, Scb );
            }

            DebugTrace( -1, Dbg, ("NtfsCreateScb -> %08lx\n", Scb) );

            return Scb;
        }
    }

    //
    //  If the user only wanted an existing Scb then return NULL.
    //

    if (ReturnExistingOnly) {

        NtfsUnlockFcb( IrpContext, Fcb );
        DebugTrace( -1, Dbg, ("NtfsCreateScb -> %08lx\n", NULL) );
        return NULL;
    }

    //
    //  We didn't find it so we are not going to be returning an existing Scb
    //  Initialize local variables for later cleanup.
    //

    PagingIoResource = FALSE;
    ModifiedNoWrite = TRUE;
    UnwindOplock = NULL;
    UnwindMcb = NULL;
    UnwindAddedClustersMcb = NULL;
    UnwindRemovedClustersMcb = NULL;
    UnwindFromQueue = FALSE;
    Nonpaged = FALSE;
    UnwindStorage[0] = NULL;
    UnwindStorage[1] = NULL;
    UnwindStorage[2] = NULL;
    UnwindStorage[3] = NULL;

    *ReturnedExistingScb = FALSE;

    try {

        //
        //  Decide the node type and size of the Scb.  Also decide if it will be
        //  allocated from paged or non-paged pool.
        //

        if (AttributeTypeCode == $INDEX_ALLOCATION) {

            if (NtfsSegmentNumber( &Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER) {
                NodeTypeCode = NTFS_NTC_SCB_ROOT_INDEX;
            } else {
                NodeTypeCode = NTFS_NTC_SCB_INDEX;
            }

            NodeByteSize = SIZEOF_SCB_INDEX;

        } else if ((NtfsSegmentNumber( &Fcb->FileReference ) <= MASTER_FILE_TABLE2_NUMBER) &&
                   (AttributeTypeCode == $DATA)) {

            NodeTypeCode = NTFS_NTC_SCB_MFT;
            NodeByteSize = SIZEOF_SCB_MFT;

        } else {

            NodeTypeCode = NTFS_NTC_SCB_DATA;
            NodeByteSize = SIZEOF_SCB_DATA;

            //
            //  If this is a user data stream then remember that we need
            //  a paging IO resource.  Test for the cases where we DONT want
            //  to mark this stream as MODIFIED_NO_WRITE.
            //
            //  If we need a paging IO resource the file must be a data stream.
            //

            if ((AttributeTypeCode == $DATA) ||
                (AttributeTypeCode >= $FIRST_USER_DEFINED_ATTRIBUTE)) {

                //
                //  For Data streams in the Root File or non-system files we need
                //  a paging IO resource and don't want to mark the file as
                //  MODIFIED_NO_WRITE.
                //

                //
                //  We should never reach this point for either the volume bitmap or
                //  volume dasd files.
                //

                ASSERT( (NtfsSegmentNumber( &Fcb->FileReference ) != VOLUME_DASD_NUMBER) &&
                        (NtfsSegmentNumber( &Fcb->FileReference ) != BIT_MAP_FILE_NUMBER) );

                if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                    //
                    //  Make sure that all files in the reserved area are marked as system except
                    //  the root index.
                    //

                    ASSERT( (NtfsSegmentNumber( &Fcb->FileReference ) >= FIRST_USER_FILE_NUMBER) ||
                            (NtfsSegmentNumber( &Fcb->FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER) );

                    ModifiedNoWrite = FALSE;
                    PagingIoResource = TRUE;
                }

            }
        }

        //
        //  The scb will come from non-paged if the Fcb is non-paged or
        //  it is an attribute list.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_NONPAGED ) || (AttributeTypeCode == $ATTRIBUTE_LIST)) {

            Scb = UnwindStorage[0] = NtfsAllocatePoolWithTag( NonPagedPool, NodeByteSize, 'nftN' );
            Nonpaged = TRUE;

        } else if (AttributeTypeCode == $INDEX_ALLOCATION) {

            //
            //  If the Fcb is an INDEX Fcb and the Scb is unused, then
            //  use that.  Otherwise allocate from the lookaside list.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) &&
                (SafeNodeType( &((PFCB_INDEX) Fcb)->Scb ) == 0)) {

                Scb = (PSCB) &((PFCB_INDEX) Fcb)->Scb;

            } else {

                Scb = UnwindStorage[0] = (PSCB)NtfsAllocatePoolWithTag( PagedPool, SIZEOF_SCB_INDEX, 'SftN' );
            }

#ifdef SYSCACHE_DEBUG
            if (((IrpContext->OriginatingIrp != NULL) &&
                 (FsRtlIsSyscacheFile( IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject )))) {


                KdPrint( ("NTFS: Found syscache dir: fo:0x%x scb:0x%x filref: 0x%x\n",
                          IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject,
                          Scb,
                          NtfsUnsafeSegmentNumber( &Fcb->FileReference )) );
                SyscacheFile = TRUE;
            }
#endif

        } else {

            //
            //  We can use the Scb field in the Fcb in all cases if it is
            //  unused.  We will only use it for a data stream since
            //  it will have the longest life.
            //

            ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) ||
                    FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_DATA ));

            if ((AttributeTypeCode == $DATA) &&
                (SafeNodeType( &((PFCB_INDEX) Fcb)->Scb ) == 0)) {

                Scb = (PSCB) &((PFCB_INDEX) Fcb)->Scb;

            } else {

                Scb = UnwindStorage[0] = (PSCB)ExAllocateFromPagedLookasideList( &NtfsScbDataLookasideList );
            }

#ifdef SYSCACHE_DEBUG
            if (((IrpContext->OriginatingIrp != NULL) &&
                 (FsRtlIsSyscacheFile( IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject )))) {


                KdPrint( ("NTFS: Found syscache file: fo:0x%x scb:0x%x filref: 0x%x\n",
                          IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject,
                          Scb,
                          NtfsUnsafeSegmentNumber( &Fcb->FileReference )) );
                SyscacheFile = TRUE;
            }

            if (!IsListEmpty( &Fcb->LcbQueue )) {
                PLCB Lcb = (PLCB) CONTAINING_RECORD( Fcb->LcbQueue.Flink, LCB, FcbLinks.Flink  );

                while (TRUE) {

                    if ((Lcb->Scb != NULL) &&
                        (FlagOn( Lcb->Scb->ScbPersist, SCB_PERSIST_SYSCACHE_DIR ))) {

                        SyscacheFile = TRUE;
                        KdPrint( ("NTFS: Found syscache file in dir: fo:0x%x scb:0x%x filref: 0x%x\n",
                                  IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject,
                                  Scb,
                                  NtfsUnsafeSegmentNumber( &Fcb->FileReference )) );
                    }

                    if (Lcb->FcbLinks.Flink != &Fcb->LcbQueue) {
                        Lcb = (PLCB)CONTAINING_RECORD( Lcb->FcbLinks.Flink, LCB, FcbLinks.Flink );
                    } else {
                        break;
                    }
                }
            }
#endif

#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG))
            if (( IrpContext->OriginatingIrp != NULL)
                (FsRtlIsSyscacheFile(IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject))) {

                SyscacheFile = TRUE;
            }
#endif
        }

        //
        //  Store the Scb address and zero it out.
        //

        RtlZeroMemory( Scb, NodeByteSize );

#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG))
        if (SyscacheFile) {
            SetFlag( Scb->ScbState, SCB_STATE_SYSCACHE_FILE );
        }
#endif

        //
        //  Set the proper node type code and byte size
        //

        Scb->Header.NodeTypeCode = NodeTypeCode;
        Scb->Header.NodeByteSize = NodeByteSize;

        //
        //  Set a back pointer to the resource we will be using
        //

        Scb->Header.Resource = Fcb->Resource;

        //
        //  Decide if we will be using the PagingIoResource
        //

        if (PagingIoResource) {

            PERESOURCE NewResource;

            //
            //  Initialize it in the Fcb if it is not already there, and
            //  setup the pointer and flag in the Scb.
            //

            if (Fcb->PagingIoResource == NULL) {

                //
                //  If this is a superseding open and our caller wants
                //  to acquire the paging io resource, then do it now.
                //  We could be in a state where there was no paging
                //  IO resource when we acquired the Fcb but will need
                //  it if this transaction needs to be unwound.
                //

                NewResource = NtfsAllocateEresource();

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING ) &&
                    (IrpContext->MajorFunction == IRP_MJ_CREATE) &&
                    (IrpContext->OriginatingIrp != NULL) &&
                    (IrpContext->CleanupStructure == NULL)) {

                    ExAcquireResourceExclusiveLite( NewResource, TRUE );
                    IrpContext->CleanupStructure = Fcb;
                }

                Fcb->PagingIoResource = NewResource;
            }

            Scb->Header.PagingIoResource = Fcb->PagingIoResource;
        }

        //
        //  Insert this Scb into our parents scb queue, and point back to
        //  our parent fcb and vcb.  Put this entry at the head of the list.
        //  Any Scb on the delayed close queue goes to the end of the list.
        //

        InsertHeadList( &Fcb->ScbQueue, &Scb->FcbLinks );
        UnwindFromQueue = TRUE;

        Scb->Fcb = Fcb;
        Scb->Vcb = Fcb->Vcb;

        //
        //  If the attribute name exists then allocate a buffer for the
        //  attribute name and iniitalize it.
        //

        if (AttributeName->Length != 0) {

            //
            //  The typical case is the $I30 string.  If this matches then
            //  point to a common string.
            //

            if ((AttributeName->Length == NtfsFileNameIndex.Length) &&
                (RtlEqualMemory( AttributeName->Buffer,
                                 NtfsFileNameIndex.Buffer,
                                 AttributeName->Length ) )) {

                Scb->AttributeName = NtfsFileNameIndex;

            } else {

                Scb->AttributeName.Length = AttributeName->Length;
                Scb->AttributeName.MaximumLength = (USHORT)(AttributeName->Length + sizeof( WCHAR ));

                Scb->AttributeName.Buffer = UnwindStorage[1] =
                    NtfsAllocatePool(PagedPool, AttributeName->Length + sizeof( WCHAR ));

                RtlCopyMemory( Scb->AttributeName.Buffer, AttributeName->Buffer, AttributeName->Length );
                Scb->AttributeName.Buffer[AttributeName->Length / sizeof( WCHAR )] = L'\0';
            }
        }

        //
        //  Set the attribute Type Code
        //

        Scb->AttributeTypeCode = AttributeTypeCode;
        if (NtfsIsTypeCodeSubjectToQuota( AttributeTypeCode ) &&
            !FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

            SetFlag( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA );
        }

        //
        //  If this is an Mft Scb then initialize the cluster Mcb's.
        //

        if (NodeTypeCode == NTFS_NTC_SCB_MFT) {

            FsRtlInitializeLargeMcb( &Scb->ScbType.Mft.AddedClusters, NonPagedPool );
            UnwindAddedClustersMcb = &Scb->ScbType.Mft.AddedClusters;

            FsRtlInitializeLargeMcb( &Scb->ScbType.Mft.RemovedClusters, NonPagedPool );
            UnwindRemovedClustersMcb = &Scb->ScbType.Mft.RemovedClusters;
        }

        //
        //  Get the mutex for the Scb.  We may be able to use the one in the Fcb.
        //  We can if the Scb is paged.
        //

        if (Nonpaged) {

            SetFlag( Scb->ScbState, SCB_STATE_NONPAGED );
            UnwindStorage[3] =
            Scb->Header.FastMutex = NtfsAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));
            ExInitializeFastMutex( Scb->Header.FastMutex );

        } else {

            Scb->Header.FastMutex = Fcb->FcbMutex;
        }

        //
        //  Initialize the FCB advanced header.  Note that the mutex
        //  has already been setup (just above) so we don't re-setitup
        //  here. We will not support filter contexts for paging files
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {
            FsRtlSetupAdvancedHeader( &Scb->Header, NULL );
        } else {
            SetFlag( Scb->Header.Flags, FSRTL_FLAG_ADVANCED_HEADER );
        }

        //
        //  Allocate the Nonpaged portion of the Scb.
        //

        Scb->NonpagedScb =
        UnwindStorage[2] = (PSCB_NONPAGED)ExAllocateFromNPagedLookasideList( &NtfsScbNonpagedLookasideList );

        RtlZeroMemory( Scb->NonpagedScb, sizeof( SCB_NONPAGED ));

        Scb->NonpagedScb->NodeTypeCode = NTFS_NTC_SCB_NONPAGED;
        Scb->NonpagedScb->NodeByteSize = sizeof( SCB_NONPAGED );
        Scb->NonpagedScb->Vcb = Scb->Vcb;

        //
        //  Fill in the advanced fields
        //

        Scb->Header.PendingEofAdvances = &Scb->EofListHead;
        InitializeListHead( &Scb->EofListHead );

        NtfsInitializeNtfsMcb( &Scb->Mcb,
                               &Scb->Header,
                               &Scb->McbStructs,
                               FlagOn( Scb->ScbState, SCB_STATE_NONPAGED )
                               ? NonPagedPool : PagedPool);

        UnwindMcb = &Scb->Mcb;

        InitializeListHead( &Scb->CcbQueue );

        //
        //  Do that data stream specific initialization.
        //

        if (NodeTypeCode == NTFS_NTC_SCB_DATA) {

            FsRtlInitializeOplock( &Scb->ScbType.Data.Oplock );
            UnwindOplock = &Scb->ScbType.Data.Oplock;
            InitializeListHead( &Scb->ScbType.Data.WaitForNewLength );
#ifdef COMPRESS_ON_WIRE
            InitializeListHead( &Scb->ScbType.Data.CompressionSyncList );
#endif

            //
            //  Set a flag if this is the Usn Journal.
            //

            if (!PagingIoResource &&
                (*((PLONGLONG) &Fcb->Vcb->UsnJournalReference) == *((PLONGLONG) &Fcb->FileReference)) &&
                (AttributeName->Length == JournalStreamName.Length) &&
                RtlEqualMemory( AttributeName->Buffer,
                                JournalStreamName.Buffer,
                                JournalStreamName.Length )) {

                SetFlag( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL );
            }

#ifdef SYSCACHE_DEBUG
            if (SyscacheFile)
            {

                Scb->LogSetNumber = InterlockedIncrement( &NtfsCurrentSyscacheLogSet ) % NUM_SC_LOGSETS;
                NtfsSyscacheLogSet[Scb->LogSetNumber].Scb = Scb;
                NtfsSyscacheLogSet[Scb->LogSetNumber].SegmentNumberUnsafe =
                    NtfsUnsafeSegmentNumber( &Fcb->FileReference );

                if (NtfsSyscacheLogSet[Scb->LogSetNumber].SyscacheLog == NULL) {
                    NtfsSyscacheLogSet[Scb->LogSetNumber].SyscacheLog = NtfsAllocatePoolWithTagNoRaise( NonPagedPool, sizeof(SYSCACHE_LOG) * NUM_SC_EVENTS, ' neB' );
                }
                Scb->SyscacheLog = NtfsSyscacheLogSet[Scb->LogSetNumber].SyscacheLog;
                Scb->SyscacheLogEntryCount = NUM_SC_EVENTS;
                Scb->CurrentSyscacheLogEntry = -1;

                //
                //  Degrade gracefully if no memory
                //

                if (!Scb->SyscacheLog) {
                    Scb->SyscacheLogEntryCount = 0;
                } else {
                    memset( Scb->SyscacheLog, 0x61626162, sizeof( SYSCACHE_LOG ) * NUM_SC_EVENTS );
                }
            }
#endif

        } else {

            //
            //  There is a deallocated queue for indexes and the Mft.
            //

            InitializeListHead( &Scb->ScbType.Index.RecentlyDeallocatedQueue );

            //
            //  Initialize index-specific fields.
            //

            if (AttributeTypeCode == $INDEX_ALLOCATION) {

                InitializeListHead( &Scb->ScbType.Index.LcbQueue );
            }

#ifdef SYSCACHE_DEBUG
            if (SyscacheFile) {
                SetFlag( Scb->ScbPersist, SCB_PERSIST_SYSCACHE_DIR );
            }
#endif
        }

        //
        //  If this Scb should be marked as containing Lsn's or
        //  Update Sequence Arrays, do so now.
        //

        NtfsCheckScbForCache( Scb );

        //
        //  We shouldn't make this call during restart.
        //

        ASSERT( !FlagOn( Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ));

        //
        //  Set the flag indicating that we want the Mapped Page Writer out of this file.
        //

        if (ModifiedNoWrite) {

            SetFlag( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );
        }

        //
        //  Let's make sure we caught all of the interesting cases.
        //

        ASSERT( ModifiedNoWrite ?
                (((Scb->AttributeTypeCode != $DATA) ||
                  FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT ) ||
                  FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) :
                (((Scb->AttributeTypeCode == $DATA) &&
                   !FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT ) &&
                   !FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) );

        //
        //  Decide whether this is a view index and set
        //  the appropriate scb state bit accordingly.
        //

        if (FlagOn( Fcb->Info.FileAttributes, DUP_VIEW_INDEX_PRESENT ) &&
            (Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
            (Scb->AttributeName.Buffer != NtfsFileNameIndex.Buffer)) {

            SetFlag( Scb->ScbState, SCB_STATE_VIEW_INDEX );
        }

    } finally {

        DebugUnwind( NtfsCreateScb );

        NtfsUnlockFcb( IrpContext, Fcb );

        if (AbnormalTermination()) {

            if (UnwindFromQueue) { RemoveEntryList( &Scb->FcbLinks ); }
            if (UnwindMcb != NULL) { NtfsUninitializeNtfsMcb( UnwindMcb ); }

            if (UnwindAddedClustersMcb != NULL) { FsRtlUninitializeLargeMcb( UnwindAddedClustersMcb ); }
            if (UnwindRemovedClustersMcb != NULL) { FsRtlUninitializeLargeMcb( UnwindRemovedClustersMcb ); }
            if (UnwindOplock != NULL) { FsRtlUninitializeOplock( UnwindOplock ); }
            if (UnwindStorage[0]) { NtfsFreePool( UnwindStorage[0] );
            } else if (Scb != NULL) { Scb->Header.NodeTypeCode = 0; }
            if (UnwindStorage[1]) { NtfsFreePool( UnwindStorage[1] ); }
            if (UnwindStorage[2]) { NtfsFreePool( UnwindStorage[2] ); }
            if (UnwindStorage[3]) { NtfsFreePool( UnwindStorage[3] ); }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateScb -> %08lx\n", Scb) );

#ifdef SYSCACHE_DEBUG
    ASSERT( SyscacheFile || (Scb->SyscacheLogEntryCount == 0 && Scb->SyscacheLog == 0 ));
#endif

    return Scb;
}


PSCB
NtfsCreatePrerestartScb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_REFERENCE FileReference,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN ULONG BytesPerIndexBuffer
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Scb record into
    the in memory data structures, provided one does not already exist
    with the identical attribute record.  It does this on the FcbTable
    off of the Vcb.  If necessary this routine will also create the fcb
    if one does not already exist for the indicated file reference.

Arguments:

    Vcb - Supplies the Vcb to associate the new SCB under.

    FileReference - Supplies the file reference for the new SCB this is
        used to identify/create a new lookaside Fcb.

    AttributeTypeCode - Supplies the attribute type code for the new SCB

    AttributeName - Supplies the optional attribute name of the SCB

    BytesPerIndexBuffer - For index Scbs, this must specify the bytes per
                          index buffer.

Return Value:

    PSCB - Returns a pointer to the newly allocated SCB

--*/

{
    PSCB Scb;
    PFCB Fcb;

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT( AttributeTypeCode >= $STANDARD_INFORMATION );

    DebugTrace( +1, Dbg, ("NtfsCreatePrerestartScb\n") );

    //
    //  Use a try-finally to release the Fcb table.
    //

    NtfsAcquireFcbTable( IrpContext, Vcb );

    try {

        //
        //  First make sure we have an Fcb of the proper file reference
        //  and indicate that it is from prerestart
        //

        Fcb = NtfsCreateFcb( IrpContext,
                             Vcb,
                             *FileReference,
                             FALSE,
                             TRUE,
                             NULL );
    } finally {

        NtfsReleaseFcbTable( IrpContext, Vcb );
    }

    //
    //  Search the child scbs of this fcb for a matching Scb (based on
    //  attribute type code and attribute name) if one is not found then
    //  we'll create a new scb.  When we exit the following loop if the
    //  scb pointer to not null then we've found a preexisting scb.
    //

    Scb = NULL;
    while ((Scb = NtfsGetNextChildScb(Fcb, Scb)) != NULL) {

        ASSERT_SCB( Scb );

        //
        //  The the attribute type codes match and if supplied the name also
        //  matches then we got our scb
        //

        if (Scb->AttributeTypeCode == AttributeTypeCode) {

            if (!ARGUMENT_PRESENT( AttributeName )) {

                if (Scb->AttributeName.Length == 0) {

                    break;
                }

            } else if (AttributeName->Length == 0
                       && Scb->AttributeName.Length == 0) {

                break;

            } else if (NtfsAreNamesEqual( IrpContext->Vcb->UpcaseTable,
                                          AttributeName,
                                          &Scb->AttributeName,
                                          FALSE )) { // Ignore Case

                break;
            }
        }
    }

    //
    //  If scb now null then we need to create a minimal scb.  We always allocate
    //  these out of non-paged pool.
    //

    if (Scb == NULL) {

        BOOLEAN ShareScb = FALSE;

        //
        //  Allocate new scb and zero it out and set the node type code and byte size.
        //

        if (AttributeTypeCode == $INDEX_ALLOCATION) {

            if (NtfsSegmentNumber( FileReference ) == ROOT_FILE_NAME_INDEX_NUMBER) {

                NodeTypeCode = NTFS_NTC_SCB_ROOT_INDEX;
            } else {
                NodeTypeCode = NTFS_NTC_SCB_INDEX;
            }

            NodeByteSize = SIZEOF_SCB_INDEX;

        } else if (NtfsSegmentNumber( FileReference ) <= MASTER_FILE_TABLE2_NUMBER
                   && (AttributeTypeCode == $DATA)) {

            NodeTypeCode = NTFS_NTC_SCB_MFT;
            NodeByteSize = SIZEOF_SCB_MFT;

        } else {

            NodeTypeCode = NTFS_NTC_SCB_DATA;
            NodeByteSize = SIZEOF_SCB_DATA;
        }

        Scb = NtfsAllocatePoolWithTag( NonPagedPool, NodeByteSize, 'tftN' );

        RtlZeroMemory( Scb, NodeByteSize );

        //
        //  Fill in the node type code and size.
        //

        Scb->Header.NodeTypeCode = NodeTypeCode;
        Scb->Header.NodeByteSize = NodeByteSize;

        //
        //  Show that all of the Scb's are from nonpaged pool.
        //

        SetFlag( Scb->ScbState, SCB_STATE_NONPAGED );

        //
        //  Initialize all of the fields that don't require allocations
        //  first.  We want to make sure we don't leave the Scb in
        //  a state that could cause a crash during Scb teardown.
        //

        //
        //  Set a back pointer to the resource we will be using
        //

        Scb->Header.Resource = Fcb->Resource;

        //
        //  Insert this scb into our parents scb queue and point back to our
        //  parent fcb and vcb.  Put this entry at the head of the list.
        //  Any Scb on the delayed close queue goes to the end of the list.
        //

        InsertHeadList( &Fcb->ScbQueue, &Scb->FcbLinks );

        Scb->Fcb = Fcb;
        Scb->Vcb = Vcb;

        InitializeListHead( &Scb->CcbQueue );

        //
        //  Set the attribute type code recently deallocated information structures.
        //

        Scb->AttributeTypeCode = AttributeTypeCode;

        //
        //  Fill in the advanced fields
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {
            FsRtlSetupAdvancedHeader( &Scb->Header, NULL );
        } else {
            SetFlag( Scb->Header.Flags, FSRTL_FLAG_ADVANCED_HEADER );
        }

        Scb->Header.PendingEofAdvances = &Scb->EofListHead;
        InitializeListHead( &Scb->EofListHead );

        //
        //  Do that data stream specific initialization.
        //

        if (NodeTypeCode == NTFS_NTC_SCB_DATA) {

            FsRtlInitializeOplock( &Scb->ScbType.Data.Oplock );
            InitializeListHead( &Scb->ScbType.Data.WaitForNewLength );
#ifdef COMPRESS_ON_WIRE
            InitializeListHead( &Scb->ScbType.Data.CompressionSyncList );
#endif

            //
            //  Set a flag if this is the Usn Journal.
            //

            if (ARGUMENT_PRESENT( AttributeName ) &&
                (*((PLONGLONG) &Vcb->UsnJournalReference) == *((PLONGLONG) &Fcb->FileReference)) &&
                (AttributeName->Length == JournalStreamName.Length) &&
                RtlEqualMemory( AttributeName->Buffer,
                                JournalStreamName.Buffer,
                                JournalStreamName.Length )) {

                SetFlag( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL );
            }

#ifdef SYSCACHE
            InitializeListHead( &Scb->ScbType.Data.SyscacheEventList );
#endif
        } else {

            //
            //  There is a deallocated queue for indexes and the Mft.
            //

            InitializeListHead( &Scb->ScbType.Index.RecentlyDeallocatedQueue );

            //
            //  Initialize index-specific fields.
            //

            if (AttributeTypeCode == $INDEX_ALLOCATION) {

                Scb->ScbType.Index.BytesPerIndexBuffer = BytesPerIndexBuffer;

                InitializeListHead( &Scb->ScbType.Index.LcbQueue );
            }
        }

        //
        //  If this is an Mft Scb then initialize the cluster Mcb's.
        //

        if (NodeTypeCode == NTFS_NTC_SCB_MFT) {

            FsRtlInitializeLargeMcb( &Scb->ScbType.Mft.AddedClusters, NonPagedPool );

            FsRtlInitializeLargeMcb( &Scb->ScbType.Mft.RemovedClusters, NonPagedPool );
        }

        Scb->NonpagedScb = (PSCB_NONPAGED)ExAllocateFromNPagedLookasideList( &NtfsScbNonpagedLookasideList );

        RtlZeroMemory( Scb->NonpagedScb, sizeof( SCB_NONPAGED ));

        Scb->NonpagedScb->NodeTypeCode = NTFS_NTC_SCB_NONPAGED;
        Scb->NonpagedScb->NodeByteSize = sizeof( SCB_NONPAGED );
        Scb->NonpagedScb->Vcb = Vcb;

        //
        //  Allocate and insert the mutext into the advanced header.  This is
        //  done now (instead of up with the call to FsRtlSetupAdvancedHeader)
        //  to guarentee the existing order during initilization.
        //

        Scb->Header.FastMutex = NtfsAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));
        ExInitializeFastMutex( Scb->Header.FastMutex );

        NtfsInitializeNtfsMcb( &Scb->Mcb, &Scb->Header, &Scb->McbStructs, NonPagedPool );

        //
        //  If the attribute name is present and the name length is greater than 0
        //  then allocate a buffer for the attribute name and initialize it.
        //

        if (ARGUMENT_PRESENT( AttributeName ) && (AttributeName->Length != 0)) {

            //
            //  The typical case is the $I30 string.  If this matches then
            //  point to a common string.
            //

            if ((AttributeName->Length == NtfsFileNameIndex.Length) &&
                (RtlEqualMemory( AttributeName->Buffer,
                                 NtfsFileNameIndex.Buffer,
                                 AttributeName->Length ) )) {

                Scb->AttributeName = NtfsFileNameIndex;

            } else {

                Scb->AttributeName.Length = AttributeName->Length;
                Scb->AttributeName.MaximumLength = (USHORT)(AttributeName->Length + sizeof( WCHAR ));

                Scb->AttributeName.Buffer = NtfsAllocatePool(PagedPool, AttributeName->Length + sizeof( WCHAR ));

                RtlCopyMemory( Scb->AttributeName.Buffer, AttributeName->Buffer, AttributeName->Length );
                Scb->AttributeName.Buffer[AttributeName->Length / sizeof( WCHAR )] = L'\0';
            }
        }

        //
        //  If this Scb should be marked as containing Lsn's or
        //  Update Sequence Arrays, do so now.
        //

        NtfsCheckScbForCache( Scb );

        //
        //  Always mark the prerestart Scb's as MODIFIED_NO_WRITE.
        //

        SetFlag( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );
    }

    DebugTrace( -1, Dbg, ("NtfsCreatePrerestartScb -> %08lx\n", Scb) );

    return Scb;
}


VOID
NtfsFreeScbAttributeName (
    IN PWSTR AttributeNameBuffer
    )

/*++

Routine Description:

    This routine frees the pool used by an Scb attribute name iff it is
    not one of the default system attribute names.

Arguments:

    AttributeName - Supplies the attribute name buffer to free

Return Value:

    None.

--*/

{
    if ((AttributeNameBuffer != NULL) &&
        (AttributeNameBuffer != NtfsFileNameIndex.Buffer) &&
        (AttributeNameBuffer != NtfsObjId.Buffer) &&
        (AttributeNameBuffer != NtfsQuota.Buffer)) {

        NtfsFreePool( AttributeNameBuffer );
    }
}


VOID
NtfsDeleteScb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB *Scb
    )

/*++

Routine Description:

    This routine deallocates and removes an Scb record
    from Ntfs's in-memory data structures.  It assume that is does not have
    any children lcb emanating from it.

Arguments:

    Scb - Supplies the SCB to be removed

Return Value:

    None.

--*/

{
    PVCB Vcb;
    PFCB Fcb;
    POPEN_ATTRIBUTE_ENTRY AttributeEntry;
    USHORT ThisNodeType;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( *Scb );
    ASSERT( (*Scb)->CleanupCount == 0 );

    DebugTrace( +1, Dbg, ("NtfsDeleteScb, *Scb = %08lx\n", *Scb) );

    Fcb = (*Scb)->Fcb;
    Vcb = Fcb->Vcb;

    RemoveEntryList( &(*Scb)->FcbLinks );

    ThisNodeType = SafeNodeType( *Scb );

    //
    //  If this is a bitmap Scb for a directory then make sure the record
    //  allocation structure is uninitialized.  Otherwise we will leave a
    //  stale pointer for the record allocation package.
    //

    if (((*Scb)->AttributeTypeCode == $BITMAP) &&
        IsDirectory( &Fcb->Info)) {

        PLIST_ENTRY Links;
        PSCB IndexAllocationScb;

        Links = Fcb->ScbQueue.Flink;

        while (Links != &Fcb->ScbQueue) {

            IndexAllocationScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

            if (IndexAllocationScb->AttributeTypeCode == $INDEX_ALLOCATION) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  &IndexAllocationScb->ScbType.Index.RecordAllocationContext );

                IndexAllocationScb->ScbType.Index.AllocationInitialized = FALSE;

                break;
            }

            Links = Links->Flink;
        }
    }

    //
    //  Mark our entry in the Open Attribute Table as free,
    //  although it will not be deleted until some future
    //  checkpoint.  Log this change as well, as long as the
    //  log file is active.
    //

    if (((*Scb)->NonpagedScb != NULL) &&
        ((*Scb)->NonpagedScb->OpenAttributeTableIndex != 0)) {

        NtfsAcquireSharedRestartTable( &Vcb->OpenAttributeTable, TRUE );
        AttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                   (*Scb)->NonpagedScb->OpenAttributeTableIndex );
        AttributeEntry->OatData->Overlay.Scb = NULL;

        if ((*Scb)->AttributeName.Buffer != NULL) {

            AttributeEntry->OatData->AttributeNamePresent = TRUE;
        }
        NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );

        //
        //  "Steal" the name, and let it belong to the Open Attribute Table
        //  entry and deallocate it only during checkpoints.
        //

        (*Scb)->AttributeName.Buffer = NULL;
    }

    //
    //  Uninitialize the file lock and oplock variables if this
    //  a data Scb.  For the index case make sure that the lcb queue
    //  is empty.  If this is for an Mft Scb then uninitialize the
    //  allocation Mcb's.
    //

    NtfsUninitializeNtfsMcb( &(*Scb)->Mcb );

    if (ThisNodeType == NTFS_NTC_SCB_DATA ) {

        FsRtlUninitializeOplock( &(*Scb)->ScbType.Data.Oplock );

        if ((*Scb)->ScbType.Data.FileLock != NULL) {

            FsRtlFreeFileLock( (*Scb)->ScbType.Data.FileLock );
        }

#ifdef NTFS_RWC_DEBUG

        ASSERT( IsListEmpty( &(*Scb)->ScbType.Data.CompressionSyncList ));
        if ((*Scb)->ScbType.Data.HistoryBuffer != NULL) {

            NtfsFreePool( (*Scb)->ScbType.Data.HistoryBuffer );
            (*Scb)->ScbType.Data.HistoryBuffer = NULL;
        }
#endif
    } else if (ThisNodeType != NTFS_NTC_SCB_MFT) {

        //
        //  Walk through and remove any Lcb's from the queue.
        //

        while (!IsListEmpty( &(*Scb)->ScbType.Index.LcbQueue )) {

            PLCB NextLcb;

            NextLcb = CONTAINING_RECORD( (*Scb)->ScbType.Index.LcbQueue.Flink,
                                         LCB,
                                         ScbLinks );

            NtfsDeleteLcb( IrpContext, &NextLcb );
        }

        if ((*Scb)->ScbType.Index.NormalizedName.Buffer != NULL) {

            NtfsDeleteNormalizedName( *Scb );
        }

    } else {

        FsRtlUninitializeLargeMcb( &(*Scb)->ScbType.Mft.AddedClusters );
        FsRtlUninitializeLargeMcb( &(*Scb)->ScbType.Mft.RemovedClusters );
    }

    if ((*Scb)->EncryptionContext != NULL) {

        //
        //  Let the encryption driver do anything necessary to clean up
        //  its private data structures.
        //

        if (NtfsData.EncryptionCallBackTable.CleanUp != NULL) {

            NtfsData.EncryptionCallBackTable.CleanUp( &(*Scb)->EncryptionContext );
        }

        //
        //  If the encryption driver didn't clear this in its cleanup routine,
        //  or if there is no cleanup routine registered, we should free any
        //  for the encryption context ourselves.
        //

        if ((*Scb)->EncryptionContext != NULL) {

            NtfsFreePool( (*Scb)->EncryptionContext );
            (*Scb)->EncryptionContext = NULL;
        }
    }

    //
    //  Show there is no longer a snapshot Scb, if there is a snapshot.
    //  We rely on the snapshot package to correctly recognize the
    //  the case where the Scb field is gone.
    //

    if ((*Scb)->ScbSnapshot != NULL) {

        (*Scb)->ScbSnapshot->Scb = NULL;
    }

    //
    //  Cleanup Filesystem Filter contexts (this was moved to the point
    //  before the FastMutex is freed because this routine now uses it)
    //

    if (FlagOn( (*Scb)->Header.Flags2, FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS )) {

        FsRtlTeardownPerStreamContexts( (PFSRTL_ADVANCED_FCB_HEADER)&(*Scb)->Header );
    }

    //
    //  Deallocate the fast mutex if not in the Fcb.
    //

    if (((*Scb)->Header.FastMutex != (*Scb)->Fcb->FcbMutex) &&
        ((*Scb)->Header.FastMutex != NULL)) {

        NtfsFreePool( (*Scb)->Header.FastMutex );
    }

    //
    //  Deallocate the non-paged scb.
    //

    if ((*Scb)->NonpagedScb != NULL) {

        ExFreeToNPagedLookasideList( &NtfsScbNonpagedLookasideList, (*Scb)->NonpagedScb );
    }

    //
    //  Deallocate the attribute name.
    //

    NtfsFreeScbAttributeName( (*Scb)->AttributeName.Buffer );

    //
    //  See if CollationData is to be deleted.
    //

    if (FlagOn((*Scb)->ScbState, SCB_STATE_DELETE_COLLATION_DATA)) {
        NtfsFreePool((*Scb)->ScbType.Index.CollationData);
    }

    //
    //  Always directly free the Mft and non-paged Scb's.
    //

    if (FlagOn( (*Scb)->ScbState, SCB_STATE_NONPAGED ) ||
        (ThisNodeType == NTFS_NTC_SCB_MFT)) {

        NtfsFreePool( *Scb );

    } else {

        //
        //  Free any final reserved clusters for data Scb's.
        //


        if (ThisNodeType == NTFS_NTC_SCB_DATA) {

            //
            //  Free the reserved bitmap and reserved clusters if present.
            //

            if ((*Scb)->ScbType.Data.ReservedBitMap != NULL) {
                NtfsDeleteReservedBitmap( *Scb );
            }
        }

        //
        //  Now free the Scb itself.
        //
        //  Check if this is an embedded Scb.  This could be part of either an INDEX_FCB
        //  or a DATA_FCB.  We depend on the fact that the Scb would be in the same
        //  location in either case.
        //

        if ((*Scb) == (PSCB) &((PFCB_DATA) (*Scb)->Fcb)->Scb) {

            (*Scb)->Header.NodeTypeCode = 0;

        } else if (SafeNodeType( *Scb ) == NTFS_NTC_SCB_DATA) {

            ExFreeToPagedLookasideList( &NtfsScbDataLookasideList, *Scb );

        } else {

            NtfsFreePool( *Scb );
        }
    }

    //
    //  Zero out the input pointer
    //

    *Scb = NULL;

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteScb -> VOID\n") );

    return;
}


BOOLEAN
NtfsUpdateNormalizedName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PSCB Scb,
    IN PFILE_NAME FileName OPTIONAL,
    IN BOOLEAN CheckBufferSizeOnly,
    IN BOOLEAN NewDirectory
    )

/*++

Routine Description:

    This routine is called to update the normalized name in an IndexScb.
    This name will be the path from the root without any short name components.
    This routine will append the given name if present provided this is not a
    DOS only name.  In any other case this routine will go to the disk to
    find the name.  This routine will handle the case where there is an existing buffer
    and the data will fit, as well as the case where the buffer doesn't exist
    or is too small.

Arguments:

    ParentScb - Supplies the parent of the current Scb.  The name for the target
        scb is appended to the name in this Scb.

    Scb - Supplies the target Scb to add the name to.

    FileName - If present this is a filename attribute for this Scb.  We check
        that it is not a DOS-only name.

    CheckBufferSizeOnly - Indicates that we don't want to change the name yet.  Just
        verify that the buffer is the correct size.

    NewDirectory - Is this a new directory that isn't in the hash/prefix table yet?
        If so skip acquiring the hashtable


Return Value:

    BOOLEAN - TRUE if we updated the name in the Scb, FALSE otherwise.  We would return
        FALSE only if the parent becomes uninitialized on us.  Any callers who can't
        tolerate this must own the parent.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PFILE_NAME OriginalFileName;
    BOOLEAN CleanupContext = FALSE;
    ULONG Length;
    ULONG UnsafeLength;
    ULONG SeparatorLength;
    BOOLEAN UpdatedName = TRUE;

    PAGED_CODE();

    ASSERT( NodeType( Scb ) == NTFS_NTC_SCB_INDEX );
    ASSERT( NodeType( ParentScb ) == NTFS_NTC_SCB_INDEX ||
            NodeType( ParentScb ) == NTFS_NTC_SCB_ROOT_INDEX );

    //
    //  Use a try-finally to clean up the attribute context.
    //

    try {

        //
        //  If the parent is the root then we don't need an extra separator.
        //

        SeparatorLength = 1;
        if (ParentScb == ParentScb->Vcb->RootIndexScb) {

            SeparatorLength = 0;
        }

        //
        //  Remember if we got a file name from our caller.
        //

        OriginalFileName = FileName;

        //
        //  The only safe time to examine the normalized name structures are
        //  when holding the hash table mutex.  These values shouldn't change
        //  often but if they do (and we are doing unsynchronized tests) then
        //  we will simply restart the logic.
        //

        do {

            //
            //  If the filename isn't present or is a DOS-only name then go to
            //  disk to find another name for this Scb.
            //

            if (!ARGUMENT_PRESENT( FileName ) || (FileName->Flags == FILE_NAME_DOS)) {

                BOOLEAN Found;

                NtfsInitializeAttributeContext( &Context );
                CleanupContext = TRUE;

                //
                //  Walk through the names for this entry.  There better
                //  be one which is not a DOS-only name.
                //

                Found = NtfsLookupAttributeByCode( IrpContext,
                                                   Scb->Fcb,
                                                   &Scb->Fcb->FileReference,
                                                   $FILE_NAME,
                                                   &Context );

                while (Found) {

                    FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

                    if (FileName->Flags != FILE_NAME_DOS) { break; }

                    Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                           Scb->Fcb,
                                                           $FILE_NAME,
                                                           &Context );
                }

                //
                //  We should have found the entry.
                //

                if (!Found) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }
            }

            //
            //  Compute the length we need for the name.  This is unsynchronized so
            //  we will verify it later.

            UnsafeLength = ParentScb->ScbType.Index.NormalizedName.Length + (FileName->FileNameLength + SeparatorLength) * sizeof( WCHAR );

            //
            //  If the current buffer is insufficient then allocate a new one.
            //  Note that these are all unsafe tests.  We will have to
            //  verify the values after acquiring the hash table mutex.
            //

            if (Scb->ScbType.Index.NormalizedName.MaximumLength < UnsafeLength) {

                PVOID OldBuffer;
                PVOID NewBuffer;

                NewBuffer = NtfsAllocatePoolWithTag( PagedPool, UnsafeLength, 'oftN' );

                //
                //  Now acquire the Hash table mutex and verify the numbers.  If they
                //  are still valid then continue.
                //

                if (!NewDirectory) {
                    NtfsAcquireHashTable( Scb->Vcb );
                }

                //
                //  Check for unexpected changes.
                //

                Length = ParentScb->ScbType.Index.NormalizedName.Length + (FileName->FileNameLength + SeparatorLength) * sizeof( WCHAR );

                if ((ParentScb->ScbType.Index.NormalizedName.Length == 0) ||
                    (Length > UnsafeLength)) {

                    //
                    //  The following is an exit condition for us.
                    //

                    if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {
                        UpdatedName = FALSE;
                    }

                    if (!NewDirectory) {
                        NtfsReleaseHashTable( Scb->Vcb );
                    }

                    //
                    //  Free pool and clean up.
                    //

                    NtfsFreePool( NewBuffer );
                    if (CleanupContext) {
                        NtfsCleanupAttributeContext( IrpContext, &Context );
                        CleanupContext = FALSE;
                    }

                    FileName = OriginalFileName;

                    continue;
                }

                //
                //  Now copy over the existing data.
                //

                OldBuffer = Scb->ScbType.Index.NormalizedName.Buffer;

                if (OldBuffer != NULL) {

                    RtlCopyMemory( NewBuffer,
                                   OldBuffer,
                                   Scb->ScbType.Index.NormalizedName.MaximumLength );

                    NtfsFreePool( OldBuffer );
                }

                //
                //  Swap out the old buffer and max length.  No change to the hash value at
                //  this point.
                //

                Scb->ScbType.Index.NormalizedName.Buffer = NewBuffer;
                Scb->ScbType.Index.NormalizedName.MaximumLength = (USHORT) Length;

            //
            //  Acquire the hash table and verify that nothing has changed on us.
            //

            } else {

                if (!NewDirectory) {
                    NtfsAcquireHashTable( Scb->Vcb );
                }

                //
                //  Check for unexpected changes.
                //

                Length = ParentScb->ScbType.Index.NormalizedName.Length + (FileName->FileNameLength + SeparatorLength) * sizeof( WCHAR );

                if ((ParentScb->ScbType.Index.NormalizedName.Length == 0) ||
                    (Length > UnsafeLength)) {

                    //
                    //  The following is an exit condition for us.
                    //

                    if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {
                        UpdatedName = FALSE;
                    }

                    if (!NewDirectory) {
                        NtfsReleaseHashTable( Scb->Vcb );
                    }

                    //
                    //  Cleanup for retry.
                    //

                    if (CleanupContext) {
                        NtfsCleanupAttributeContext( IrpContext, &Context );
                        CleanupContext = FALSE;
                    }

                    FileName = OriginalFileName;
                    continue;
                }
            }

            //
            //  At this point we hold the hash table and know that the buffer is sufficient
            //  for the new data.  However it still contains the previous data.  If we aren't
            //  just updating the buffer lengths then store the new data.
            //

            if (!CheckBufferSizeOnly) {

                PCHAR NextChar;

                //
                //  Copy the new name into the buffer.
                //

                Scb->ScbType.Index.NormalizedName.Length = (USHORT) Length;
                NextChar = (PCHAR) Scb->ScbType.Index.NormalizedName.Buffer;

                //
                //  Now copy the name in.  Don't forget to add the separator if the parent isn't
                //  the root.
                //

                RtlCopyMemory( NextChar,
                               ParentScb->ScbType.Index.NormalizedName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Length );

                NextChar += ParentScb->ScbType.Index.NormalizedName.Length;

                if (SeparatorLength == 1) {

                    *((PWCHAR) NextChar) = L'\\';
                    NextChar += sizeof( WCHAR );
                }

                //
                //  Now append this name to the parent name.
                //

                RtlCopyMemory( NextChar,
                               FileName->FileName,
                               FileName->FileNameLength * sizeof( WCHAR ));

                Scb->ScbType.Index.HashValue = 0;
                NtfsConvertNameToHash( Scb->ScbType.Index.NormalizedName.Buffer,
                                       Scb->ScbType.Index.NormalizedName.Length,
                                       Scb->Vcb->UpcaseTable,
                                       &Scb->ScbType.Index.HashValue );
            }

            if (!NewDirectory) {
                NtfsReleaseHashTable( Scb->Vcb );
            }

            //
            //  Only one pass required in the typical case.
            //

            break;

        //
        //  We either break out specifically or set this to FALSE.
        //

        } while (UpdatedName);

    } finally {

        if (CleanupContext) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }
    }

    return UpdatedName;
}


VOID
NtfsDeleteNormalizedName (
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called to delete the normalized name from an Scb.
    We make this a function in order to serialize the normalized name
    deletion with the hash package.  The user has already done
    the check to see if this Scb has a normalized name.  Note that the
    name may not be valid (Length == 0) but it does have a buffer
    requiring cleanup.

Arguments:

    Scb - Index Scb with a normalized name.

Return Value:

    None

--*/

{
    PVOID OldBuffer;

    PAGED_CODE();

    ASSERT( (NodeType( Scb ) == NTFS_NTC_SCB_INDEX) ||
            (NodeType( Scb ) == NTFS_NTC_SCB_ROOT_INDEX) );
    ASSERT( Scb->ScbType.Index.NormalizedName.Buffer != NULL );

    //
    //  The hash table mutex is needed to synchronize with callers in the hash
    //  package who look at this Scb name without serializing with the Scb.
    //  They must hold the hash mutex for their entire operation.
    //

    NtfsAcquireHashTable( Scb->Vcb );
    OldBuffer = Scb->ScbType.Index.NormalizedName.Buffer;
    Scb->ScbType.Index.NormalizedName.Buffer = NULL;
    Scb->ScbType.Index.NormalizedName.MaximumLength = Scb->ScbType.Index.NormalizedName.Length = 0;

    NtfsReleaseHashTable( Scb->Vcb );

    NtfsFreePool( OldBuffer );

    return;
}



NTSTATUS
NtfsWalkUpTree (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN NTFSWALKUPFUNCTION WalkUpFunction,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine walks up the tree from child to parent, applying
    a function at each level.  Processing terminates when WalkUpFunction
    returns a failure status code.  The current convention is that
    WalkUpFunctions return STATUS_NO_MORE_FILES when a successful upward
    traversal occurs.  Other status codes are private to
    caller/WalkUpFunction.

Arguments:

    IrpContext - context of the call

    Fcb - beginning file

    WalkUpFunction - function that is applied to each level

    Context - Pointer to caller-private data passed to WalkUpFunction

Return Value:

    STATUS_SUCCESS - at end of complete walk

    Status code returned by WalkUpFunction otherwise

--*/

{
    PFCB ThisFcb = Fcb;
    PFCB NextFcb = NULL;
    PSCB NextScb = NULL;
    PLCB NextLcb;
    BOOLEAN AcquiredNextFcb = FALSE;
    BOOLEAN AcquiredThisFcb = FALSE;
    BOOLEAN AcquiredFcbTable = FALSE;

    BOOLEAN FoundEntry = TRUE;
    BOOLEAN CleanupAttrContext = FALSE;
    PFILE_NAME FileName;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_SHARED_RESOURCE( &Fcb->Vcb->Resource );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the starting Fcb is for a directory try to find the corresponding
        //  Scb with the normalized name in it
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_DUP_INITIALIZED ) &&
            IsDirectory( &ThisFcb->Info )) {

            do {
                NextScb = NtfsGetNextChildScb( Fcb, NextScb );
            } while ((NextScb != NULL) && (NextScb->AttributeTypeCode != $INDEX_ALLOCATION));
        }

        while (TRUE) {

            //
            //  If we reach the root then exit.
            //

            if (ThisFcb == ThisFcb->Vcb->RootIndexScb->Fcb) {

                //
                //  Special case root directory
                //

                Status = WalkUpFunction( IrpContext, ThisFcb, ThisFcb->Vcb->RootIndexScb, NULL, Context );
                break;
            }

            //
            //  Find a non-dos name for the current Scb.  There better be one.
            //

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            FoundEntry = NtfsLookupAttributeByCode( IrpContext,
                                                    ThisFcb,
                                                    &ThisFcb->FileReference,
                                                    $FILE_NAME,
                                                    &AttrContext );

            while (FoundEntry) {

                FileName = (PFILE_NAME)
                        NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                if (FileName->Flags != FILE_NAME_DOS ) {
                    break;
                }

                FoundEntry = NtfsLookupNextAttributeByCode( IrpContext,
                                                            ThisFcb,
                                                            $FILE_NAME,
                                                            &AttrContext );
            }

            if (!FoundEntry) {

                NtfsRaiseStatus( IrpContext,
                                 STATUS_FILE_CORRUPT_ERROR,
                                 NULL,
                                 NextFcb );
            }

            ASSERT( NextScb == NULL || NextScb->Fcb == ThisFcb );
            Status = WalkUpFunction( IrpContext, ThisFcb, NextScb, FileName, Context );

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            //  Now get the parent for the current component.  Acquire the Fcb for
            //  synchronization.  We can either walk up the Lcb chain or look it up
            //  in the Fcb table.  It must be for the same name as the file name
            //  since there is only one path up the tree for a directory.
            //

            if (!IsListEmpty( &ThisFcb->LcbQueue ) && IsDirectory( &ThisFcb->Info )) {

                NextLcb =
                    (PLCB) CONTAINING_RECORD( ThisFcb->LcbQueue.Flink, LCB, FcbLinks );
                NextScb = NextLcb->Scb;
                NextFcb = NextScb->Fcb;

                NtfsAcquireExclusiveFcb( IrpContext, NextFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                AcquiredNextFcb = TRUE;

                ASSERT( NtfsEqualMftRef( &FileName->ParentDirectory,
                                         &NextFcb->FileReference ));

            } else {
                UNICODE_STRING ComponentName;

                NtfsAcquireFcbTable( IrpContext, Fcb->Vcb );
                AcquiredFcbTable = TRUE;

                NextFcb = NtfsCreateFcb( IrpContext,
                                         Fcb->Vcb,
                                         FileName->ParentDirectory,
                                         FALSE,
                                         TRUE,
                                         NULL );

                NextFcb->ReferenceCount += 1;

                //
                //  Try to do an unsafe acquire.  Otherwise we must drop the Fcb table
                //  and acquire the Fcb and then reacquire the Fcb table.
                //

                if (!NtfsAcquireExclusiveFcb( IrpContext, NextFcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_DONT_WAIT )) {

                    NtfsReleaseFcbTable( IrpContext, Fcb->Vcb );
                    NtfsAcquireExclusiveFcb( IrpContext, NextFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    NtfsAcquireFcbTable( IrpContext, Fcb->Vcb );

                }

                NextFcb->ReferenceCount -= 1;
                NtfsReleaseFcbTable( IrpContext, Fcb->Vcb );
                AcquiredFcbTable = FALSE;
                AcquiredNextFcb = TRUE;

                NextScb = NtfsCreateScb( IrpContext,
                                         NextFcb,
                                         $INDEX_ALLOCATION,
                                         &NtfsFileNameIndex,
                                         FALSE,
                                         NULL );

                ComponentName.Buffer = FileName->FileName;
                ComponentName.MaximumLength =
                    ComponentName.Length = FileName->FileNameLength * sizeof( WCHAR );

                NextLcb = NtfsCreateLcb( IrpContext,
                                         NextScb,
                                         ThisFcb,
                                         ComponentName,
                                         FileName->Flags,
                                         NULL );
            }

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttrContext = FALSE;

            //
            //  Release the current Fcb and move up the tree.
            //

            if (AcquiredThisFcb) {
                NtfsReleaseFcb( IrpContext, ThisFcb );
            }

            ThisFcb = NextFcb;
            AcquiredThisFcb = TRUE;
            AcquiredNextFcb = FALSE;
        }

    } finally {

        if (AcquiredFcbTable) { NtfsReleaseFcbTable( IrpContext, Fcb->Vcb ); }
        if (AcquiredNextFcb) { NtfsReleaseFcb( IrpContext, NextFcb ); }
        if (AcquiredThisFcb) { NtfsReleaseFcb( IrpContext, ThisFcb ); }

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

    }

    return Status;
}


NTSTATUS
NtfsBuildRelativeName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PFILE_NAME FileName,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called for each parent directory up to the root.  We
    prepend the name of the current node to the ScopeContext as we walk
    up.  We terminate this walk when we hit the top of the scope or the
    root.

Arguments:

    IrpContext - context of the call

    Fcb - parent

    FileName - FILE_NAME of self relative to parent

    Context - Pointer to caller-private data passed to WalkUpFunction

Return Value:

    STATUS_SUCCESS - if we're still walking up the tree

    STATUS_NO_MORE_FILES - if we've found the specified scope

    STATUS_OBJECT_PATH_NOT_FOUND - if we've reached the root and did not
        hit the scope.

--*/
{
    PSCOPE_CONTEXT ScopeContext = (PSCOPE_CONTEXT) Context;
    ULONG SlashCount;
    WCHAR *Name;
    ULONG Count;
    USHORT NewLength;

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();


    //
    //  If we've reached the passed-in scope then we're done - except if we haven't
    //  generated any name yet in which case add the \ for the root (this is the case
    //  where we're normalizing the root itself)
    //

    if (ScopeContext->Name.Length > 0) {

        if (NtfsEqualMftRef( &ScopeContext->Scope, &Fcb->FileReference )) {
            return STATUS_NO_MORE_FILES;
        }

        //
        //  If we've reached the root then we're totally outside the scope
        //

        if (NtfsEqualMftRef( &RootIndexFileReference, &Fcb->FileReference )) {
            return STATUS_OBJECT_PATH_NOT_FOUND;
        }
    }

    //
    //  Set up Name from input.  We take the shortcut to building the name
    //  only if we're looking from the root.  Also, if we are starting at
    //  the root, then we should use the canned name as well.
    //

    if (

        //
        //  No file name (i.e., root)
        //

        FileName == NULL ||

        //
        //  We're searching to the root and
        //  we have an Scb and
        //  the Scb has a normalized name
        //

        (ScopeContext->IsRoot &&
         (Scb != NULL) &&
         (Scb->ScbType.Index.NormalizedName.Length != 0))) {

        Name = Scb->ScbType.Index.NormalizedName.Buffer;
        Count = Scb->ScbType.Index.NormalizedName.Length / sizeof( WCHAR );
        SlashCount = 0;

    } else {
        Name = FileName->FileName;
        Count = FileName->FileNameLength;
        SlashCount = 1;
    }

    //
    //  If there's not enough room in the string to allow for prepending
    //

    NewLength = (USHORT) ((SlashCount + Count) * sizeof( WCHAR ) + ScopeContext->Name.Length);
    if (NewLength > ScopeContext->Name.MaximumLength ) {

        WCHAR *NewBuffer;

        //
        //  Reallocate string.  Adjust size of string for pool boundaries.
        //

        NewLength = ((NewLength + 8 + 0x40 - 1) & ~(0x40 - 1)) - 8;
        NewBuffer = NtfsAllocatePool( PagedPool, NewLength );

        //
        //  Copy over previous contents into new buffer
        //

        if (ScopeContext->Name.Length != 0) {
            RtlCopyMemory( NewBuffer,
                           ScopeContext->Name.Buffer,
                           ScopeContext->Name.Length );
            NtfsFreePool( ScopeContext->Name.Buffer );
        }

        ScopeContext->Name.Buffer = NewBuffer;
        ScopeContext->Name.MaximumLength = NewLength;
    }

    //
    //  Shift string over to make new room
    //

    RtlMoveMemory( &ScopeContext->Name.Buffer[SlashCount + Count],
                   ScopeContext->Name.Buffer,
                   ScopeContext->Name.Length );

    //
    //  copy name
    //

    RtlCopyMemory( &ScopeContext->Name.Buffer[SlashCount],
                   Name,
                   Count * sizeof( WCHAR ) );

    //
    //  Stick in the slash
    //

    if (SlashCount != 0) {
        ScopeContext->Name.Buffer[0] = L'\\';
    }

    ScopeContext->Name.Length += (USHORT)((SlashCount + Count) * sizeof( WCHAR ));

    return SlashCount == 0 ? STATUS_NO_MORE_FILES : STATUS_SUCCESS;
}


VOID
NtfsBuildNormalizedName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB IndexScb OPTIONAL,
    OUT PUNICODE_STRING PathName
    )

/*++

Routine Description:

    This routine is called to build a normalized name for an Fcb by looking
    up the file name attributes up to the root directory.

Arguments:

    IrpContext - context of call

    Fcb - Supplies the starting point.

    IndexScb - Indicates that we are storing this name into an Scb so we
        we need to serialize with the hash package and also generate a
        hash for this.

    PathName - location where full name is stored

Return Value:

    None.  This routine either succeeds or raises.

--*/

{
    SCOPE_CONTEXT ScopeContext;

    PAGED_CODE();

    RtlZeroMemory( &ScopeContext, sizeof( ScopeContext ));
    ScopeContext.Scope = RootIndexFileReference;
    ScopeContext.IsRoot = TRUE;

    try {

        NtfsWalkUpTree( IrpContext, Fcb, NtfsBuildRelativeName, &ScopeContext );

        if (ARGUMENT_PRESENT( IndexScb )) {

            NtfsAcquireHashTable( Fcb->Vcb );
            *PathName = ScopeContext.Name;
            IndexScb->ScbType.Index.HashValue = 0;
            NtfsConvertNameToHash( PathName->Buffer,
                                   PathName->Length,
                                   IndexScb->Vcb->UpcaseTable,
                                   &IndexScb->ScbType.Index.HashValue );

            NtfsReleaseHashTable( Fcb->Vcb );

        } else {

            *PathName = ScopeContext.Name;
        }

        ScopeContext.Name.Buffer = NULL;

    } finally {
        if (ScopeContext.Name.Buffer != NULL) {
            NtfsFreePool( ScopeContext.Name.Buffer );
        }
    }
}


VOID
NtfsSnapshotScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine snapshots necessary Scb data, such as the Scb file sizes,
    so that they may be correctly restored if the caller's I/O request is
    aborted for any reason.  The restoring of these values and the freeing
    of any pool involved is automatic.

Arguments:

    Scb - Supplies the current Scb

Return Value:

    None

--*/

{
    PSCB_SNAPSHOT ScbSnapshot;

    ASSERT( NtfsIsExclusiveScb( Scb ) );

    ScbSnapshot = &IrpContext->ScbSnapshot;

    //
    //  Only do the snapshot if the Scb is initialized, we have not done
    //  so already, and it is worth special-casing the bitmap, as it never changes!
    //  We will snapshot the volume bitmap if it is on the exclusive Fcb list however.
    //  This should only happen if we are extending the volume bitmap through the
    //  ExtendVolume fsctl.
    //

    if (FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED) &&
        (Scb->ScbSnapshot == NULL) &&
        ((Scb != Scb->Vcb->BitmapScb) ||
         (Scb->Fcb->ExclusiveFcbLinks.Flink != NULL))) {

        //
        //  If the snapshot structure in the IrpContext is in use, then we have
        //  to allocate one and insert it in the list.
        //

        if (ScbSnapshot->Scb != NULL) {

            ScbSnapshot = (PSCB_SNAPSHOT)ExAllocateFromNPagedLookasideList( &NtfsScbSnapshotLookasideList );

            InsertTailList( &IrpContext->ScbSnapshot.SnapshotLinks,
                            &ScbSnapshot->SnapshotLinks );

        }

        //
        //  We should never be writing compressed if the file isn't compressed.
        //

        ASSERT( FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) ||
                !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) ||
                (Scb->CompressionUnit != 0) );

        //
        //  Snapshot the Scb values and point the Scb and snapshot structure
        //  at each other.
        //

        NtfsVerifySizes( &Scb->Header );
        ScbSnapshot->AllocationSize = Scb->Header.AllocationSize.QuadPart;

        ScbSnapshot->FileSize = Scb->Header.FileSize.QuadPart;
        ScbSnapshot->ValidDataLength = Scb->Header.ValidDataLength.QuadPart;
        ScbSnapshot->ValidDataToDisk = Scb->ValidDataToDisk;
        ScbSnapshot->Scb = Scb;
        ScbSnapshot->LowestModifiedVcn = MAXLONGLONG;
        ScbSnapshot->HighestModifiedVcn = 0;

        ScbSnapshot->TotalAllocated = Scb->TotalAllocated;

        ScbSnapshot->ScbState = FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

        Scb->ScbSnapshot = ScbSnapshot;
        NtfsVerifySizesLongLong( ScbSnapshot );

        //
        //  If this is the Mft Scb then initialize the cluster Mcb structures.
        //

        if (Scb == Scb->Vcb->MftScb) {

            FsRtlTruncateLargeMcb( &Scb->ScbType.Mft.AddedClusters, 0 );
            FsRtlTruncateLargeMcb( &Scb->ScbType.Mft.RemovedClusters, 0 );

            Scb->ScbType.Mft.FreeRecordChange = 0;
            Scb->ScbType.Mft.HoleRecordChange = 0;
        }

        //
        //  Determine if we can use the snapshot for rollback of file sizes
        //  The 4 cases are we own the pagingio, we own io at eof, its being converted to non-res
        //  or its a mod-no write stream  which we explicity control like the usn journal
        //

        if (NtfsSnapshotFileSizesTest( IrpContext, Scb )) {
            Scb->ScbSnapshot->OwnerIrpContext = IrpContext;
        } else {
            Scb->ScbSnapshot->OwnerIrpContext = NULL;
        }
    }
}


VOID
NtfsUpdateScbSnapshots (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine may be called to update the snapshot values for all Scbs,
    after completing a transaction checkpoint.

Arguments:

Return Value:

    None

--*/

{
    PSCB_SNAPSHOT ScbSnapshot;
    PSCB Scb;

    ASSERT(FIELD_OFFSET(SCB_SNAPSHOT, SnapshotLinks) == 0);

    PAGED_CODE();

    ScbSnapshot = &IrpContext->ScbSnapshot;

    //
    //  Loop to update first the Scb data from the snapshot in the
    //  IrpContext, and then 0 or more additional snapshots linked
    //  to the IrpContext.
    //

    do {

        Scb = ScbSnapshot->Scb;

        //
        //  Update the Scb values.
        //

        if (Scb != NULL) {

            ScbSnapshot->AllocationSize = Scb->Header.AllocationSize.QuadPart;

            //
            //  If this is the MftScb then clear out the added/removed
            //  cluster Mcbs.
            //

            if (Scb == Scb->Vcb->MftScb) {

                FsRtlTruncateLargeMcb( &Scb->ScbType.Mft.AddedClusters, (LONGLONG)0 );
                FsRtlTruncateLargeMcb( &Scb->ScbType.Mft.RemovedClusters, (LONGLONG)0 );

                Scb->ScbType.Mft.FreeRecordChange = 0;
                Scb->ScbType.Mft.HoleRecordChange = 0;
            }

            ScbSnapshot->FileSize = Scb->Header.FileSize.QuadPart;
            ScbSnapshot->ValidDataLength = Scb->Header.ValidDataLength.QuadPart;
            ScbSnapshot->ValidDataToDisk = Scb->ValidDataToDisk;
            ScbSnapshot->TotalAllocated = Scb->TotalAllocated;

            ScbSnapshot->ScbState = FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );
            NtfsVerifySizesLongLong( ScbSnapshot );
        }

        ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;

    } while (ScbSnapshot != &IrpContext->ScbSnapshot);
}


VOID
NtfsRestoreScbSnapshots (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Higher
    )

/*++

Routine Description:

    This routine restores snapshot Scb data in the event of an aborted request.

Arguments:

    Higher - Specified as TRUE to restore only those Scb values which are
             higher than current values.  Specified as FALSE to restore
             only those Scb values which are lower (or same!).

Return Value:

    None

--*/

{
    BOOLEAN UpdateCc;
    PSCB_SNAPSHOT ScbSnapshot;
    PSCB Scb;
    PVCB Vcb = IrpContext->Vcb;

    ASSERT(FIELD_OFFSET(SCB_SNAPSHOT, SnapshotLinks) == 0);

    ScbSnapshot = &IrpContext->ScbSnapshot;

    //
    //  Loop to retore first the Scb data from the snapshot in the
    //  IrpContext, and then 0 or more additional snapshots linked
    //  to the IrpContext.
    //

    do {

        PSECTION_OBJECT_POINTERS SectionObjectPointer;
        PFILE_OBJECT PseudoFileObject;

        Scb = ScbSnapshot->Scb;

        if (Scb == NULL) {

            ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;
            continue;
        }

        //
        //  Increment the cleanup count so the Scb won't go away.
        //

        InterlockedIncrement( &Scb->CleanupCount );

        //
        //  We update the Scb file size in the correct pass.  We always do
        //  the extend/truncate pair.
        //
        //  Only do sizes if our caller was changing these fields, which we marked
        //  by setting the irpcontext owner when we snapped
        //
        //  The one unusual case is where we are converting a stream to
        //  nonresident when this is not the stream for the request.  We
        //  must restore the Scb for this case as well.
        //

        UpdateCc = FALSE;
        if ((ScbSnapshot->OwnerIrpContext == IrpContext) || (ScbSnapshot->OwnerIrpContext == IrpContext->TopLevelIrpContext)) {

            //
            //  Proceed to restore all values which are in higher or not
            //  higher.
            //

            if (Higher == (ScbSnapshot->AllocationSize >= Scb->Header.AllocationSize.QuadPart)) {

                //
                //  If this is the maximize pass, we want to extend the cache section.
                //  In all cases we restore the allocation size in the Scb and
                //  recover the resident bit.
                //

                Scb->Header.AllocationSize.QuadPart = ScbSnapshot->AllocationSize;

                ClearFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );
                SetFlag( Scb->ScbState,
                         FlagOn( ScbSnapshot->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ));

                //
                //  Calculate FastIoPossible
                //

                if (Scb->CompressionUnit != 0) {
                    NtfsAcquireFsrtlHeader( Scb );
                    Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
                    NtfsReleaseFsrtlHeader( Scb );
                }
            }

            NtfsAcquireFsrtlHeader( Scb );
            if (Higher ?
                (ScbSnapshot->FileSize > Scb->Header.FileSize.QuadPart) :
                (ScbSnapshot->FileSize < Scb->Header.FileSize.QuadPart)) {

                Scb->Header.FileSize.QuadPart = ScbSnapshot->FileSize;

                //
                //  We really only need to update Cc if FileSize changes,
                //  since he does not look at ValidDataLength, and he
                //  only cares about successfully reached highwatermarks
                //  on AllocationSize (making section big enough).
                //
                //  Note that setting this flag TRUE also implies we
                //  are correctly synchronized with FileSize!
                //

                UpdateCc = TRUE;
            }

            if (Higher == (ScbSnapshot->ValidDataLength >
                           Scb->Header.ValidDataLength.QuadPart)) {

                Scb->Header.ValidDataLength.QuadPart = ScbSnapshot->ValidDataLength;
            }

            ASSERT( (Scb->Header.ValidDataLength.QuadPart <= Scb->Header.FileSize.QuadPart) ||
                    (Scb->Header.ValidDataLength.QuadPart == MAXLONGLONG) );

            //
            //  If this is the unnamed data attribute, we have to update
            //  some Fcb fields for standard information as well.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Scb->Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
            }

            NtfsReleaseFsrtlHeader( Scb );
        }

        if (!Higher) {

            Scb->ValidDataToDisk = ScbSnapshot->ValidDataToDisk;

            //
            //  We always truncate the Mcb to the original allocation size.
            //  If the Mcb has shrunk beyond this, this becomes a noop.
            //  If the file is resident, then we will uninitialize
            //  and reinitialize the Mcb.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  Remove all of the mappings in the Mcb.
                //

                NtfsUnloadNtfsMcbRange( &Scb->Mcb, (LONGLONG)0, MAXLONGLONG, FALSE, FALSE );

                //
                //  If we attempted a convert a data attribute to non-
                //  resident and failed then need to nuke the pages in the
                //  section if this is not a user file.  This is because for
                //  resident system attributes we always update the attribute
                //  directly and don't want to reference stale data in the
                //  section if we do a convert to non-resident later.
                //

                if (Scb->AttributeTypeCode != $DATA) {

                    if (Scb->NonpagedScb->SegmentObject.SharedCacheMap != NULL) {

                        //
                        //  If we're not synchronized with the lazy writer, we shouldn't
                        //  be attempting this purge.  Otherwise there's a potential for
                        //  deadlock when this thread waits on the active count, while the
                        //  thread trying to get rid of his reference is waiting for the
                        //  main resource on this scb.
                        //

                        ASSERT( (Scb->Header.PagingIoResource == NULL) ||
                                NtfsIsExclusiveScbPagingIo( Scb ) );

                        if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                  NULL,
                                                  0,
                                                  FALSE )) {

                            ASSERTMSG( "Failed to purge Scb during restore\n", FALSE );
                        }
                    }

                    //
                    //  If the attribute is for non-user data
                    //  (which is not opened explicitly by a user), then we
                    //  want to modify this Scb so it won't be used again.
                    //  Set the sizes to zero, mark it as being initialized
                    //  and deleted and then change the attribute type code
                    //  so we won't ever return it via NtfsCreateScb.
                    //

                    if (IsListEmpty( &Scb->CcbQueue )) {

                        NtfsAcquireFsrtlHeader( Scb );
                        Scb->Header.AllocationSize =
                        Scb->Header.FileSize =
                        Scb->Header.ValidDataLength = Li0;
                        NtfsReleaseFsrtlHeader( Scb );
                        Scb->ValidDataToDisk = 0;

                        SetFlag( Scb->ScbState,
                                 SCB_STATE_FILE_SIZE_LOADED |
                                 SCB_STATE_HEADER_INITIALIZED |
                                 SCB_STATE_ATTRIBUTE_DELETED );

                        Scb->AttributeTypeCode = $UNUSED;
                    }
                }

            //
            //  If we have modified this Mcb and want to back out any
            //  changes then truncate the Mcb.  Don't do the Mft, because
            //  that is handled elsewhere.
            //

            } else if ((ScbSnapshot->LowestModifiedVcn != MAXLONGLONG) &&
                       (Scb != Vcb->MftScb)) {

                //
                //  Truncate the Mcb.
                //

                NtfsUnloadNtfsMcbRange( &Scb->Mcb, ScbSnapshot->LowestModifiedVcn, ScbSnapshot->HighestModifiedVcn, FALSE, FALSE );
            }

            Scb->TotalAllocated = ScbSnapshot->TotalAllocated;

        } else {

            //
            //  Set the flag to indicate that we're performing a restore on this
            //  Scb.  We don't want to write any new log records as a result of
            //  this operation other than the abort records.
            //

            SetFlag( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY );
        }

        //
        //  Be sure to update Cache Manager.  The interface here uses a file
        //  object but the routine itself only uses the section object pointers.
        //  We put a pointer to the segment object pointers on the stack and
        //  cast some prior value as a file object pointer.
        //

        PseudoFileObject = (PFILE_OBJECT) CONTAINING_RECORD( &SectionObjectPointer,
                                                             FILE_OBJECT,
                                                             SectionObjectPointer );
        PseudoFileObject->SectionObjectPointer = &Scb->NonpagedScb->SegmentObject;

        //
        //  Now tell the cache manager the sizes.
        //
        //  If we fail in this call, we definitely want to charge on anyway.
        //  It should only fail if it tries to extend the section and cannot,
        //  in which case we do not care because we cannot need the extended
        //  part to the section anyway.  (This is probably the very error that
        //  is causing us to clean up in the first place!)
        //
        //  We don't need to make this call if the top level request is a
        //  paging Io write.
        //
        //  We only do this if there is a shared cache map for this stream.
        //  Otherwise CC will cause a flush to happen which could mess up
        //  the transaction and abort logic.
        //

        if (UpdateCc &&
            (IrpContext->OriginatingIrp == NULL ||
             IrpContext->OriginatingIrp->Type != IO_TYPE_IRP ||
             IrpContext->MajorFunction != IRP_MJ_WRITE ||
             !FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ))) {

            try {

                NtfsSetBothCacheSizes( PseudoFileObject,
                                       (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                       Scb );

            } except(FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                                EXCEPTION_EXECUTE_HANDLER :
                                EXCEPTION_CONTINUE_SEARCH) {

                NtfsMinimumExceptionProcessing( IrpContext );
            }
        }

        //
        //  If this is the unnamed data attribute, we have to update
        //  some Fcb fields for standard information as well.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

            Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
        }

        //
        //  We always clear the Scb deleted flag and the deleted flag in the Fcb
        //  unless this was a create new file operation which failed.  We recognize
        //  this by looking for the major Irp code in the IrpContext, and the
        //  deleted bit in the Fcb.
        //

        if (Scb->AttributeTypeCode != $UNUSED &&
            (IrpContext->MajorFunction != IRP_MJ_CREATE ||
             !FlagOn( Scb->Fcb->FcbState, FCB_STATE_FILE_DELETED ))) {

            ClearFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
            ClearFlag( Scb->Fcb->FcbState, FCB_STATE_FILE_DELETED );
        }

        //
        //  Clear the flags in the Scb if this Scb is from a create
        //  that failed.  We always clear our RESTORE_UNDERWAY flag.
        //
        //  If this is an Index allocation or Mft bitmap, then we
        //  store MAXULONG in the record allocation context to indicate
        //  that we should reinitialize it.
        //

        if (!Higher) {

            ClearFlag( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY );

            if (FlagOn( Scb->ScbState, SCB_STATE_UNINITIALIZE_ON_RESTORE )) {

                ClearFlag( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED |
                                          SCB_STATE_HEADER_INITIALIZED |
                                          SCB_STATE_UNINITIALIZE_ON_RESTORE );
            }

            //
            //  If this is the MftScb we have several jobs to do.
            //
            //      - Force the record allocation context to be reinitialized
            //      - Back out the changes to the Vcb->MftFreeRecords field
            //      - Back changes to the Vcb->MftHoleRecords field
            //      - Clear the flag indicating we allocated file record 15
            //      - Clear the flag indicating we reserved a record
            //      - Remove any clusters added to the Scb Mcb
            //      - Restore any clusters removed from the Scb Mcb
            //

            if (Scb == Vcb->MftScb) {

                ULONG RunIndex;
                VCN Vcn;
                LCN Lcn;
                LONGLONG Clusters;

                Scb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
                (LONG) Vcb->MftFreeRecords -= Scb->ScbType.Mft.FreeRecordChange;
                (LONG) Vcb->MftHoleRecords -= Scb->ScbType.Mft.HoleRecordChange;

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_15_USED )) {

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_15_USED );
                    ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_15_USED );
                }

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED )) {

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED );
                    ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );

                    Scb->ScbType.Mft.ReservedIndex = 0;
                }

                RunIndex = 0;

                while (FsRtlGetNextLargeMcbEntry( &Scb->ScbType.Mft.AddedClusters,
                                                  RunIndex,
                                                  &Vcn,
                                                  &Lcn,
                                                  &Clusters )) {

                    if (Lcn != UNUSED_LCN) {

                        NtfsRemoveNtfsMcbEntry( &Scb->Mcb, Vcn, Clusters );
                    }

                    RunIndex += 1;
                }

                RunIndex = 0;

                while (FsRtlGetNextLargeMcbEntry( &Scb->ScbType.Mft.RemovedClusters,
                                                  RunIndex,
                                                  &Vcn,
                                                  &Lcn,
                                                  &Clusters )) {

                    if (Lcn != UNUSED_LCN) {

                        NtfsAddNtfsMcbEntry( &Scb->Mcb, Vcn, Lcn, Clusters, FALSE );
                    }

                    RunIndex += 1;
                }

            } else if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

                Scb->ScbType.Index.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
            }
        }

        //
        //  Decrement the cleanup count to restore the previous value.
        //

        InterlockedDecrement( &Scb->CleanupCount );

        ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;

    } while (ScbSnapshot != &IrpContext->ScbSnapshot);
}


VOID
NtfsMungeScbSnapshot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileSize
    )

/*++

Routine Description:

    This routine is called to modify the Scb snapshot when we need the snapshot to
    have different values than the Scb when it was acquired.  One case is when NtfsCommonWrite
    updates the file size in the Scb for the duration of the transaction.

Arguments:

    Scb - Scb whose snapshot should be updated.  There should always be a snapshot here.

    FileSize - Value for file size to store in the snapshot.  Also check that valid data and
        ValidDataToDisk are not larger than this value.

Return Value:

    None

--*/

{
    //
    //  We should have a snapshot in most cases but if not build it now.
    //

    if (Scb->ScbSnapshot == NULL) {

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
        }

        NtfsSnapshotScb( IrpContext, Scb );

        ASSERT( Scb->ScbSnapshot != NULL );
    }

    NtfsAcquireFsrtlHeader( Scb );

    Scb->ScbSnapshot->FileSize = FileSize;

    if (Scb->ScbSnapshot->ValidDataLength > FileSize) {
        Scb->ScbSnapshot->ValidDataLength = FileSize;
    }

    if (Scb->ScbSnapshot->ValidDataToDisk > FileSize) {
        Scb->ScbSnapshot->ValidDataToDisk = FileSize;
    }

    NtfsVerifySizes( &Scb->Header );

    NtfsReleaseFsrtlHeader( Scb );

    return;
}


VOID
NtfsFreeSnapshotsForFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine restores snapshot Scb data in the event of an aborted request.

Arguments:

    Fcb - Fcb for which all snapshots are to be freed, or NULL to free all
          snapshots.

Return Value:

    None

--*/

{
    PSCB_SNAPSHOT ScbSnapshot;

    ASSERT(FIELD_OFFSET(SCB_SNAPSHOT, SnapshotLinks) == 0);

    ScbSnapshot = &IrpContext->ScbSnapshot;

    //
    //  Loop to free first the Scb data from the snapshot in the
    //  IrpContext, and then 0 or more additional snapshots linked
    //  to the IrpContext.
    //

    do {

        PSCB_SNAPSHOT NextScbSnapshot;

        //
        //  Move to next snapshot before we delete the current one.
        //

        NextScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;

        //
        //  We are now at a snapshot in the snapshot list.  We skip
        //  over this entry if it has an Scb and the Fcb for that
        //  Scb does not match the input Fcb.  If there is no
        //  input Fcb we always deal with this snapshot.
        //

        if ((ScbSnapshot->Scb != NULL) &&
            (Fcb != NULL) &&
            (ScbSnapshot->Scb->Fcb != Fcb)) {

            ScbSnapshot = NextScbSnapshot;
            continue;
        }

        //
        //  If there is an Scb, then clear its snapshot pointer.
        //  Always clear the UNINITIALIZE_ON_RESTORE flag, RESTORE_UNDERWAY, PROTECT_SPARSE_MCB and
        //  CONVERT_UNDERWAY flags.
        //

        if (ScbSnapshot->Scb != NULL) {

            //
            //  Check if there is any special processing we need to do for the Scb based on the state.
            //  Do a single test now and then retest below to reduce the work in the mainline path.
            //

            if (FlagOn( ScbSnapshot->Scb->ScbState,
                        (SCB_STATE_UNINITIALIZE_ON_RESTORE |
                         SCB_STATE_RESTORE_UNDERWAY |
                         SCB_STATE_PROTECT_SPARSE_MCB |
                         SCB_STATE_CONVERT_UNDERWAY |
                         SCB_STATE_ATTRIBUTE_DELETED))) {

                //
                //  If the attribute is deleted and the type is a user logged stream then
                //  mark the Scb as type $UNUSED to keep us from ever accessing it again.
                //

                if ((ScbSnapshot->Scb->AttributeTypeCode == $LOGGED_UTILITY_STREAM ) &&
                    FlagOn( ScbSnapshot->Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                    ScbSnapshot->Scb->AttributeTypeCode = $UNUSED;
                }

                //
                //  Clear the state flags which indicate whether there is a transitional change
                //  underway.
                //

                if (FlagOn( ScbSnapshot->Scb->ScbState,
                            (SCB_STATE_UNINITIALIZE_ON_RESTORE |
                             SCB_STATE_RESTORE_UNDERWAY |
                             SCB_STATE_PROTECT_SPARSE_MCB |
                             SCB_STATE_CONVERT_UNDERWAY ))) {

                    NtfsAcquireFsrtlHeader( ScbSnapshot->Scb );
                    ClearFlag( ScbSnapshot->Scb->ScbState,
                               SCB_STATE_UNINITIALIZE_ON_RESTORE | SCB_STATE_RESTORE_UNDERWAY | SCB_STATE_PROTECT_SPARSE_MCB | SCB_STATE_CONVERT_UNDERWAY );
                    NtfsReleaseFsrtlHeader( ScbSnapshot->Scb );
                }
            }

            ScbSnapshot->Scb->ScbSnapshot = NULL;
        }

        if (ScbSnapshot == &IrpContext->ScbSnapshot) {

            IrpContext->ScbSnapshot.Scb = NULL;

        //
        //  Else delete the snapshot structure
        //

        } else {

            RemoveEntryList(&ScbSnapshot->SnapshotLinks);
            ExFreeToNPagedLookasideList( &NtfsScbSnapshotLookasideList, ScbSnapshot );
        }

        ScbSnapshot = NextScbSnapshot;

    } while (ScbSnapshot != &IrpContext->ScbSnapshot);
}


BOOLEAN
NtfsCreateFileLock (
    IN PSCB Scb,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine is called to create and initialize a file lock structure.
    A try-except is used to catch allocation failures if the caller doesn't
    want the exception raised.

Arguments:

    Scb - Supplies the Scb to attach the file lock to.

    RaiseOnError - If TRUE then don't catch the allocation failure.

Return Value:

    TRUE if the lock is allocated and initialized.  FALSE if there is an
    error and the caller didn't specify RaiseOnError.

--*/

{
    PFILE_LOCK FileLock = NULL;
    BOOLEAN Success = TRUE;

    PAGED_CODE();

    FileLock = FsRtlAllocateFileLock( NULL, NULL );

    if (FileLock != NULL) {

        //
        //  Use the FsRtl header mutex to synchronize storing
        //  the lock structure, and only store it if no one
        //  else beat us.
        //

        NtfsAcquireFsrtlHeader(Scb);

        if (Scb->ScbType.Data.FileLock == NULL) {
            Scb->ScbType.Data.FileLock = FileLock;
            FileLock = NULL;
        }

        NtfsReleaseFsrtlHeader(Scb);

        if (FileLock != NULL) {
            FsRtlFreeFileLock( FileLock );
        }

    } else {

        //
        //  Fail appropriately.
        //

        if (RaiseOnError) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        Success = FALSE;
    }

    return Success;
}


PSCB
NtfsGetNextScb (
    IN PSCB Scb,
    IN PSCB TerminationScb
    )

/*++

Routine Description:

    This routine is used to iterate through Scbs in a tree.

    The rules are:

        . If you have a child, go to it, else
        . If you have a next sibling, go to it, else
        . Go to your parent's next sibling.

    If this routine is called with in invalid TerminationScb it will fail,
    badly.

Arguments:

    Scb - Supplies the current Scb

    TerminationScb - The Scb at which the enumeration should (non-inclusively)
        stop.  Assumed to be a directory.

Return Value:

    The next Scb in the enumeration, or NULL if Scb was the final one.

--*/

{
    PSCB Results;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetNextScb, Scb = %08lx, TerminationScb = %08lx\n", Scb, TerminationScb) );

    //
    //  If this is an index (i.e., not a file) and it has children then return
    //  the scb for the first child
    //
    //                  Scb
    //
    //                 /   \.
    //                /     \.
    //
    //           ChildLcb
    //
    //              |
    //              |
    //
    //           ChildFcb
    //
    //            /   \.
    //           /     \.
    //
    //       Results
    //

    if (((SafeNodeType(Scb) == NTFS_NTC_SCB_INDEX) || (SafeNodeType(Scb) == NTFS_NTC_SCB_ROOT_INDEX))

                &&

         !IsListEmpty(&Scb->ScbType.Index.LcbQueue)) {

        PLCB ChildLcb;
        PFCB ChildFcb;

        //
        //  locate the first lcb out of this scb and also the corresponding fcb
        //

        ChildLcb = NtfsGetNextChildLcb(Scb, NULL);
        ChildFcb = ChildLcb->Fcb;

        //
        //  Then as a bookkeeping means for ourselves we will move this
        //  lcb to the head of the fcb's lcb queue that way when we
        //  need to ask which link we went through to get here we will know
        //

        RemoveEntryList( &ChildLcb->FcbLinks );
        InsertHeadList( &ChildFcb->LcbQueue, &ChildLcb->FcbLinks );

        //
        //  And our return value is the first scb of this fcb
        //

        ASSERT( !IsListEmpty(&ChildFcb->ScbQueue) );

        //
        //  Acquire and drop the Fcb in order to look at the Scb list.
        //

        ExAcquireResourceExclusiveLite( ChildFcb->Resource, TRUE );
        Results = NtfsGetNextChildScb( ChildFcb, NULL );
        ExReleaseResourceLite( ChildFcb->Resource );

    //
    //  We could be processing an empty index
    //

    } else if ( Scb == TerminationScb ) {

        Results = NULL;

    } else {

        PSCB SiblingScb;
        PFCB ParentFcb;
        PLCB ParentLcb;
        PLCB SiblingLcb;
        PFCB SiblingFcb;

        //
        //  Acquire and drop the Fcb in order to look at the Scb list.
        //

        ExAcquireResourceExclusiveLite( Scb->Fcb->Resource, TRUE );
        SiblingScb = NtfsGetNextChildScb( Scb->Fcb, Scb );
        ExReleaseResourceLite( Scb->Fcb->Resource );

        while (TRUE) {

            //
            //  If there is a sibling scb to the input scb then return it
            //
            //                Fcb
            //
            //               /   \.
            //              /     \.
            //
            //            Scb   Sibling
            //                    Scb
            //

            if (SiblingScb != NULL) {

                Results = SiblingScb;
                break;
            }

            //
            //  The scb doesn't have any more siblings.  See if our fcb has a sibling
            //
            //                           S
            //
            //                         /   \.
            //                        /     \.
            //
            //               ParentLcb     SiblingLcb
            //
            //                   |             |
            //                   |             |
            //
            //               ParentFcb     SiblingFcb
            //
            //                /             /     \.
            //               /             /       \.
            //
            //             Scb         Results
            //
            //  It's possible that the SiblingFcb has already been traversed.
            //  Consider the case where there are multiple links between the
            //  same Scb and Fcb.  We want to ignore this case or else face
            //  an infinite loop by moving the Lcb to the beginning of the
            //  Fcb queue and then later finding an Lcb that we have already
            //  traverse.  We use the fact that we haven't modified the
            //  ordering of the Lcb off the parent Scb.  When we find a
            //  candidate for the next Fcb, we walk backwards through the
            //  list of Lcb's off the Scb to make sure this is not a
            //  duplicate Fcb.
            //

            ParentFcb = Scb->Fcb;

            ParentLcb = NtfsGetNextParentLcb(ParentFcb, NULL);

            //
            //  Try to find a sibling Lcb which does not point to an Fcb
            //  we've already visited.
            //

            SiblingLcb = ParentLcb;

            while ((SiblingLcb = NtfsGetNextChildLcb( ParentLcb->Scb, SiblingLcb)) != NULL) {

                PLCB PrevChildLcb;
                PFCB PotentialSiblingFcb;

                //
                //  Now walk through the child Lcb's of the Scb which we have
                //  already visited.
                //

                PrevChildLcb = SiblingLcb;
                PotentialSiblingFcb = SiblingLcb->Fcb;

                //
                //  Skip this Lcb if the Fcb has no children.
                //

                if (IsListEmpty( &PotentialSiblingFcb->ScbQueue )) {

                    continue;
                }

                while ((PrevChildLcb = NtfsGetPrevChildLcb( ParentLcb->Scb, PrevChildLcb )) != NULL) {

                    //
                    //  If the parent Fcb and the Fcb for this Lcb are the same,
                    //  then we have already returned the Scb's for this Fcb.
                    //

                    if (PrevChildLcb->Fcb == PotentialSiblingFcb) {

                        break;
                    }
                }

                //
                //  If we don't have a PrevChildLcb, that means that we have a valid
                //  sibling Lcb.  We will ignore any sibling Lcb's whose
                //  Fcb's don't have any Scb's.
                //

                if (PrevChildLcb == NULL) {

                    break;
                }
            }

            if (SiblingLcb != NULL) {

                SiblingFcb = SiblingLcb->Fcb;

                //
                //  Then as a bookkeeping means for ourselves we will move this
                //  lcb to the head of the fcb's lcb queue that way when we
                //  need to ask which link we went through to get here we will know
                //

                RemoveEntryList( &SiblingLcb->FcbLinks );
                InsertHeadList( &SiblingFcb->LcbQueue, &SiblingLcb->FcbLinks );

                //
                //  And our return value is the first scb of this fcb
                //

                ASSERT( !IsListEmpty(&SiblingFcb->ScbQueue) );

                //
                //  Acquire and drop the Fcb in order to look at the Scb list.
                //

                ExAcquireResourceExclusiveLite( SiblingFcb->Resource, TRUE );
                Results = NtfsGetNextChildScb( SiblingFcb, NULL );
                ExReleaseResourceLite( SiblingFcb->Resource );
                break;
            }

            //
            //  The Fcb has no sibling so bounce up one and see if we
            //  have reached our termination scb yet
            //
            //                          NewScb
            //
            //                         /
            //                        /
            //
            //               ParentLcb
            //
            //                   |
            //                   |
            //
            //               ParentFcb
            //
            //                /
            //               /
            //
            //             Scb
            //
            //

            Scb = ParentLcb->Scb;

            if (Scb == TerminationScb) {

                Results = NULL;
                break;
            }

            //
            //  Acquire and drop the Fcb in order to look at the Scb list.
            //

            ExAcquireResourceExclusiveLite( Scb->Fcb->Resource, TRUE );
            SiblingScb = NtfsGetNextChildScb( Scb->Fcb, Scb );
            ExReleaseResourceLite( Scb->Fcb->Resource );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsGetNextScb -> %08lx\n", Results) );

    return Results;
}


PLCB
NtfsCreateLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN UNICODE_STRING LastComponentFileName,
    IN UCHAR FileNameFlags,
    IN OUT PBOOLEAN ReturnedExistingLcb OPTIONAL
    )

/*++

Routine Description:

    This routine allocates and creates a new lcb between an
    existing scb and fcb.  If a component of the exact
    name already exists we return that one instead of creating
    a new lcb

Arguments:

    Scb - Supplies the parent scb to use

    Fcb - Supplies the child fcb to use

    LastComponentFileName - Supplies the last component of the
        path that this link represents

    FileNameFlags - Indicates if this is an NTFS, DOS or hard link

    ReturnedExistingLcb - Optionally tells the caller if the
        lcb returned already existed.  If specified and points to a
        FALSE value on entry then we won't create the new Lcb.

Return Value:

    LCB - returns a pointer the newly created lcb.  NULL if our caller doesn't
        want to create an Lcb and it didn't already exist.

--*/

{
    PLCB Lcb = NULL;
    BOOLEAN LocalReturnedExistingLcb = TRUE;

    //
    //  The following variables are only used for abnormal termination
    //

    PVOID UnwindStorage[2] = { NULL, NULL };

    PAGED_CODE();
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_FCB( Fcb );
    ASSERT(NodeType(Scb) != NTFS_NTC_SCB_DATA);

    DebugTrace( +1, Dbg, ("NtfsCreateLcb...\n") );

    if (!ARGUMENT_PRESENT(ReturnedExistingLcb)) { ReturnedExistingLcb = &LocalReturnedExistingLcb; }

    //
    //  Search the lcb children of the input Scb to see if we have an Lcb that matches
    //  this one.  We match if the Lcb points to the same fcb and the last component file name
    //  and flags match.  We ignore any Lcb's that indicate links that have been
    //  removed.
    //

    Lcb = NULL;

    while ((Lcb = NtfsGetNextParentLcb(Fcb, Lcb)) != NULL) {

        ASSERT_LCB( Lcb );

        if ((Scb == Lcb->Scb) &&

            (!FlagOn( Lcb->LcbState, LCB_STATE_LINK_IS_GONE )) &&

            (FileNameFlags == Lcb->FileNameAttr->Flags) &&

            (LastComponentFileName.Length == Lcb->ExactCaseLink.LinkName.Length) &&

            (RtlEqualMemory( LastComponentFileName.Buffer,
                             Lcb->ExactCaseLink.LinkName.Buffer,
                             LastComponentFileName.Length ) )) {

            *ReturnedExistingLcb = TRUE;

            DebugTrace( -1, Dbg, ("NtfsCreateLcb -> %08lx\n", Lcb) );

            return Lcb;
        }
    }

    //
    //  If our caller does not want us to create a new Lcb then return FALSE.
    //

    if (!(*ReturnedExistingLcb)) {

        DebugTrace( -1, Dbg, ("NtfsCreateLcb -> %08lx\n", NULL) );

        return NULL;
    }

    *ReturnedExistingLcb = FALSE;

    try {

        UCHAR MaxNameLength;

        //
        //  Allocate a new lcb, zero it out and set the node type information
        //  Check if we can allocate the Lcb out of a compound Fcb.  Check here if
        //  we can use the embedded name as well.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_DATA) &&
            (SafeNodeType( &((PFCB_DATA) Fcb)->Lcb ) == 0)) {

            Lcb = (PLCB) &((PFCB_DATA) Fcb)->Lcb;
            MaxNameLength = MAX_DATA_FILE_NAME;

        } else if (FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) &&
            (SafeNodeType( &((PFCB_INDEX) Fcb)->Lcb ) == 0)) {

            Lcb = (PLCB) &((PFCB_INDEX) Fcb)->Lcb;
            MaxNameLength = MAX_INDEX_FILE_NAME;

        } else {

            Lcb = UnwindStorage[0] = ExAllocateFromPagedLookasideList( &NtfsLcbLookasideList );
            MaxNameLength = 0;
        }

        RtlZeroMemory( Lcb, sizeof(LCB) );

        Lcb->NodeTypeCode = NTFS_NTC_LCB;
        Lcb->NodeByteSize = sizeof(LCB);

        //
        //  Check if we will have to allocate a separate filename attr.
        //

        if (MaxNameLength < (USHORT) (LastComponentFileName.Length / sizeof( WCHAR ))) {

            //
            //  Allocate the last component part of the lcb and copy over the data.
            //  Check if there is space in the Fcb for this.
            //

            Lcb->FileNameAttr =
            UnwindStorage[1] = NtfsAllocatePool(PagedPool, LastComponentFileName.Length +
                                                      NtfsFileNameSizeFromLength( LastComponentFileName.Length ));

            MaxNameLength = (UCHAR)(LastComponentFileName.Length / sizeof( WCHAR ));

        } else {

            Lcb->FileNameAttr = (PFILE_NAME) &Lcb->ParentDirectory;
        }

        Lcb->FileNameAttr->ParentDirectory = Scb->Fcb->FileReference;
        Lcb->FileNameAttr->FileNameLength = (UCHAR) (LastComponentFileName.Length / sizeof( WCHAR ));
        Lcb->FileNameAttr->Flags = FileNameFlags;

        Lcb->ExactCaseLink.LinkName.Buffer = (PWCHAR) &Lcb->FileNameAttr->FileName;

        Lcb->IgnoreCaseLink.LinkName.Buffer = Add2Ptr( Lcb->FileNameAttr,
                                                       NtfsFileNameSizeFromLength( MaxNameLength * sizeof( WCHAR )));

        Lcb->ExactCaseLink.LinkName.Length =
        Lcb->IgnoreCaseLink.LinkName.Length = LastComponentFileName.Length;

        Lcb->ExactCaseLink.LinkName.MaximumLength =
        Lcb->IgnoreCaseLink.LinkName.MaximumLength = MaxNameLength * sizeof( WCHAR );

        RtlCopyMemory( Lcb->ExactCaseLink.LinkName.Buffer,
                       LastComponentFileName.Buffer,
                       LastComponentFileName.Length );

        RtlCopyMemory( Lcb->IgnoreCaseLink.LinkName.Buffer,
                       LastComponentFileName.Buffer,
                       LastComponentFileName.Length );

        NtfsUpcaseName( IrpContext->Vcb->UpcaseTable,
                        IrpContext->Vcb->UpcaseTableSize,
                        &Lcb->IgnoreCaseLink.LinkName );

        //
        //  Now put this Lcb into the queues for the scb and the fcb
        //

        InsertTailList( &Scb->ScbType.Index.LcbQueue, &Lcb->ScbLinks );
        Lcb->Scb = Scb;

        InsertTailList( &Fcb->LcbQueue, &Lcb->FcbLinks );
        Lcb->Fcb = Fcb;

        //
        //  Now initialize the ccb queue.
        //

        InitializeListHead( &Lcb->CcbQueue );

    } finally {

        DebugUnwind( NtfsCreateLcb );

        if (AbnormalTermination()) {

            if (UnwindStorage[0]) { NtfsFreePool( UnwindStorage[0] );
            } else if (Lcb != NULL) { Lcb->NodeTypeCode = 0; }
            if (UnwindStorage[1]) { NtfsFreePool( UnwindStorage[1] ); }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateLcb -> %08lx\n", Lcb) );

    return Lcb;
}


VOID
NtfsDeleteLcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PLCB *Lcb
    )

/*++

Routine Description:

    This routine deallocated and removes the lcb record from Ntfs's in-memory
    data structures.  It assumes that the ccb queue is empty.  We also assume
    that this is not the root lcb that we are trying to delete.

Arguments:

    Lcb - Supplise the Lcb to be removed

Return Value:

    None.

--*/

{
    PCCB Ccb;
    PLIST_ENTRY Links;

    PAGED_CODE();
    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace( +1, Dbg, ("NtfsDeleteLcb, *Lcb = %08lx\n", *Lcb) );

    //
    //  Get rid of any prefixes that might still be attached to us
    //

    NtfsRemovePrefix( (*Lcb) );

    //
    //  Remove any hash table entries for this Lcb.
    //

    NtfsRemoveHashEntriesForLcb( *Lcb );

    //
    //  Walk through the Ccb's for this link and clear the Lcb
    //  pointer.  This can only be for Ccb's which there is no
    //  more user handle.
    //

    Links = (*Lcb)->CcbQueue.Flink;

    while (Links != &(*Lcb)->CcbQueue) {

        Ccb = CONTAINING_RECORD( Links,
                                 CCB,
                                 LcbLinks );

        Links = Links->Flink;
        NtfsUnlinkCcbFromLcb( IrpContext, (*Lcb)->Fcb, Ccb );
    }

    //
    //
    //  Now remove ourselves from our scb and fcb
    //

    RemoveEntryList( &(*Lcb)->ScbLinks );
    RemoveEntryList( &(*Lcb)->FcbLinks );

    //
    //  Free up the last component part and then free ourselves
    //

    if ((*Lcb)->FileNameAttr != (PFILE_NAME) &(*Lcb)->ParentDirectory) {

        NtfsFreePool( (*Lcb)->FileNameAttr );
        DebugDoit( (*Lcb)->FileNameAttr = NULL );
    }

    //
    //  Check if we are part of an embedded structure otherwise free back to the
    //  lookaside list
    //

    if (((*Lcb) == (PLCB) &((PFCB_DATA) (*Lcb)->Fcb)->Lcb) ||
        ((*Lcb) == (PLCB) &((PFCB_INDEX) (*Lcb)->Fcb)->Lcb)) {

#ifdef KEITHKADBG
        RtlZeroMemory( *Lcb, sizeof( LCB ) );
#endif

        (*Lcb)->NodeTypeCode = 0;

    } else {

#ifdef KEITHKADBG
        RtlZeroMemory( *Lcb, sizeof( LCB ) );
#endif

        ExFreeToPagedLookasideList( &NtfsLcbLookasideList, *Lcb );
    }

    //
    //  And for safety sake null out the pointer
    //

    *Lcb = NULL;

    DebugTrace( -1, Dbg, ("NtfsDeleteLcb -> VOID\n") );

    return;
}


VOID
NtfsMoveLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN PUNICODE_STRING TargetDirectoryName,
    IN PUNICODE_STRING LastComponentName,
    IN UCHAR FileNameFlags,
    IN BOOLEAN CheckBufferSizeOnly
    )

/*++

Routine Description:

    This routine completely moves the input lcb to join different fcbs and
    scbs.  It hasIt uses the target directory
    file object to supply the complete new name to use.

Arguments:

    Lcb - Supplies the Lcb being moved.

    Scb - Supplies the new parent scb

    Fcb - Supplies the new child fcb

    TargetDirectoryName - This is the path used to reach the new parent directory
        for this Lcb.  It will only be from the root.

    LastComponentName - This is the last component name to store in this relocated Lcb.

    FileNameFlags - Indicates if this is an NTFS, DOS or hard link

    CheckBufferSizeOnly - If TRUE we just want to pass through and verify that
        the buffer sizes of the various structures will be large enough for the
        new name.

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;
    ULONG BytesNeeded;
    PVOID NewAllocation;
    PCHAR NextChar;

    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( Lcb );
    ASSERT_SCB( Scb );
    ASSERT_FCB( Fcb );
    ASSERT( NodeType( Scb ) != NTFS_NTC_SCB_DATA );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMoveLcb, Lcb = %08lx\n", Lcb) );

    //
    //  If we're not just checking sizes then remove entries from the prefix table
    //  and the normalized name for descendents of the current scb.
    //

    if (!CheckBufferSizeOnly) {

        NtfsClearRecursiveLcb ( Lcb );
    }

    //
    //  Remember the number of bytes needed for the last component.
    //

    BytesNeeded = LastComponentName->Length;

    //
    //  Check if we need to allocate a new filename attribute.  If so allocate
    //  it and store it into the new allocation buffer.
    //

    if (Lcb->ExactCaseLink.LinkName.MaximumLength < BytesNeeded) {

        NewAllocation = NtfsAllocatePool( PagedPool,
                                          BytesNeeded + NtfsFileNameSizeFromLength( BytesNeeded ));

        //
        //  Set up the existing names into the new buffer.  That way if we have an allocation
        //  failure below with the Ccb's the Lcb is still in a valid state.
        //

        RtlCopyMemory( NewAllocation,
                       Lcb->FileNameAttr,
                       NtfsFileNameSizeFromLength( Lcb->ExactCaseLink.LinkName.MaximumLength ));

        RtlCopyMemory( Add2Ptr( NewAllocation, NtfsFileNameSizeFromLength( BytesNeeded )),
                       Lcb->IgnoreCaseLink.LinkName.Buffer,
                       Lcb->IgnoreCaseLink.LinkName.MaximumLength );

        if (Lcb->FileNameAttr != (PFILE_NAME) &Lcb->ParentDirectory) {

            NtfsFreePool( Lcb->FileNameAttr );
        }

        Lcb->FileNameAttr = NewAllocation;

        Lcb->ExactCaseLink.LinkName.MaximumLength =
        Lcb->IgnoreCaseLink.LinkName.MaximumLength = (USHORT) BytesNeeded;

        Lcb->ExactCaseLink.LinkName.Buffer = (PWCHAR) &Lcb->FileNameAttr->FileName;
        Lcb->IgnoreCaseLink.LinkName.Buffer = Add2Ptr( Lcb->FileNameAttr,
                                                       NtfsFileNameSizeFromLength( BytesNeeded ));
    }

    //
    //  Compute the full length of the name for the CCB, assume we will need a
    //  separator.
    //

    BytesNeeded = TargetDirectoryName->Length + sizeof( WCHAR );

    //
    //  Now for every ccb attached to us we need to check if we need a new
    //  filename buffer.
    //

    NtfsReserveCcbNamesInLcb( IrpContext, Lcb, &BytesNeeded, LastComponentName->Length );

    //
    //  Add back in the last component.
    //

    BytesNeeded += LastComponentName->Length;

    //
    //  Now update the Lcb with the new values if we are to rewrite the buffers.
    //

    if (!CheckBufferSizeOnly) {

        Lcb->FileNameAttr->ParentDirectory = Scb->Fcb->FileReference;
        Lcb->FileNameAttr->FileNameLength = (UCHAR) (LastComponentName->Length / sizeof( WCHAR ));
        Lcb->FileNameAttr->Flags = FileNameFlags;

        Lcb->ExactCaseLink.LinkName.Length =
        Lcb->IgnoreCaseLink.LinkName.Length = (USHORT) LastComponentName->Length;

        RtlCopyMemory( Lcb->ExactCaseLink.LinkName.Buffer,
                       LastComponentName->Buffer,
                       LastComponentName->Length );

        RtlCopyMemory( Lcb->IgnoreCaseLink.LinkName.Buffer,
                       LastComponentName->Buffer,
                       LastComponentName->Length );

        NtfsUpcaseName( IrpContext->Vcb->UpcaseTable,
                        IrpContext->Vcb->UpcaseTableSize,
                        &Lcb->IgnoreCaseLink.LinkName );

        //
        //  Now for every ccb attached to us we need to munge it file object name by
        //  copying over the entire new name
        //

        Ccb = NULL;
        while ((Ccb = NtfsGetNextCcb(Lcb, Ccb)) != NULL) {

            //
            //  We ignore any Ccb's which are associated with open by File Id
            //  file objects or their file objects have gone through cleanup.
            //  Lock and unlock the Fcb to serialize access to the close flag.
            //

            NtfsLockFcb( IrpContext, Ccb->Lcb->Fcb );
            if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID | CCB_FLAG_CLOSE )) {

                Ccb->FullFileName.Length = (USHORT) BytesNeeded;
                NextChar = (PCHAR) Ccb->FullFileName.Buffer;

                RtlCopyMemory( NextChar,
                               TargetDirectoryName->Buffer,
                               TargetDirectoryName->Length );

                NextChar += TargetDirectoryName->Length;

                if (TargetDirectoryName->Length != sizeof( WCHAR )) {

                    *((PWCHAR) NextChar) = L'\\';
                    NextChar += sizeof( WCHAR );

                } else {

                    Ccb->FullFileName.Length -= sizeof( WCHAR );
                }

                RtlCopyMemory( NextChar,
                               LastComponentName->Buffer,
                               LastComponentName->Length );

                Ccb->LastFileNameOffset = (USHORT) (Ccb->FullFileName.Length - LastComponentName->Length);
            }

            NtfsUnlockFcb( IrpContext, Ccb->Lcb->Fcb );
        }

        //
        //  Now dequeue ourselves from our old scb and fcb and put us in the
        //  new fcb and scb queues.
        //

        RemoveEntryList( &Lcb->ScbLinks );
        RemoveEntryList( &Lcb->FcbLinks );

        InsertTailList( &Scb->ScbType.Index.LcbQueue, &Lcb->ScbLinks );
        Lcb->Scb = Scb;

        InsertTailList( &Fcb->LcbQueue, &Lcb->FcbLinks );
        Lcb->Fcb = Fcb;
    }

    //
    //  And return to our caller
    //


    return;
}


VOID
NtfsRenameLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PUNICODE_STRING LastComponentFileName,
    IN UCHAR FileNameFlags,
    IN BOOLEAN CheckBufferSizeOnly
    )

/*++

Routine Description:

    This routine changes the last component name of the input lcb
    It also walks through the opened ccb and munges their names and
    also removes the lcb from the prefix table

Arguments:

    Lcb - Supplies the Lcb being renamed

    LastComponentFileName - Supplies the new last component to use
        for the lcb name

    FileNameFlags - Indicates if this is an NTFS, DOS or hard link

    CheckBufferSizeOnly - If TRUE we just want to pass through and verify that
        the buffer sizes of the various structures will be large enough for the
        new name.


Return Value:

    None.

--*/

{
    PVCB Vcb = Lcb->Fcb->Vcb;
    ULONG BytesNeeded;
    PVOID NewAllocation;

    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( Lcb );

    PAGED_CODE();

    //
    //  If we're not just checking sizes then remove entries from the prefix table
    //  and the normalized name for descendents of the current scb.
    //

    if (!CheckBufferSizeOnly) {

        NtfsClearRecursiveLcb ( Lcb );
    }

    //
    //  Remember the number of bytes needed for the last component.
    //

    BytesNeeded = LastComponentFileName->Length;

    //
    //  Check if we need to allocate a new filename attribute.  If so allocate
    //  it and store it into the new allocation buffer.
    //

    if (Lcb->ExactCaseLink.LinkName.MaximumLength < BytesNeeded) {

        NewAllocation = NtfsAllocatePool( PagedPool,
                                          BytesNeeded + NtfsFileNameSizeFromLength( BytesNeeded ));

        //
        //  Set up the existing names into the new buffer.  That way if we have an allocation
        //  failure below with the Ccb's the Lcb is still in a valid state.
        //

        RtlCopyMemory( NewAllocation,
                       Lcb->FileNameAttr,
                       NtfsFileNameSizeFromLength( Lcb->ExactCaseLink.LinkName.MaximumLength ));

        RtlCopyMemory( Add2Ptr( NewAllocation, NtfsFileNameSizeFromLength( BytesNeeded )),
                       Lcb->IgnoreCaseLink.LinkName.Buffer,
                       Lcb->IgnoreCaseLink.LinkName.MaximumLength );

        if (Lcb->FileNameAttr != (PFILE_NAME) &Lcb->ParentDirectory) {

            NtfsFreePool( Lcb->FileNameAttr );
        }

        Lcb->FileNameAttr = NewAllocation;

        Lcb->ExactCaseLink.LinkName.MaximumLength =
        Lcb->IgnoreCaseLink.LinkName.MaximumLength = (USHORT) BytesNeeded;

        Lcb->ExactCaseLink.LinkName.Buffer = (PWCHAR) &Lcb->FileNameAttr->FileName;
        Lcb->IgnoreCaseLink.LinkName.Buffer = Add2Ptr( Lcb->FileNameAttr,
                                                       NtfsFileNameSizeFromLength( BytesNeeded ));
    }

    //
    //  Now for every ccb attached to us we need to check if we need a new
    //  filename buffer.
    //

    NtfsReserveCcbNamesInLcb( IrpContext, Lcb, NULL, BytesNeeded );

    //
    //  Now update the Lcb and Ccb's with the new values if we are to rewrite the buffers.
    //

    if (!CheckBufferSizeOnly) {

        BytesNeeded = LastComponentFileName->Length;

        Lcb->FileNameAttr->FileNameLength = (UCHAR) (BytesNeeded / sizeof( WCHAR ));
        Lcb->FileNameAttr->Flags = FileNameFlags;

        Lcb->ExactCaseLink.LinkName.Length =
        Lcb->IgnoreCaseLink.LinkName.Length = (USHORT) LastComponentFileName->Length;

        RtlCopyMemory( Lcb->ExactCaseLink.LinkName.Buffer,
                       LastComponentFileName->Buffer,
                       BytesNeeded );

        RtlCopyMemory( Lcb->IgnoreCaseLink.LinkName.Buffer,
                       LastComponentFileName->Buffer,
                       BytesNeeded );

        NtfsUpcaseName( IrpContext->Vcb->UpcaseTable,
                        IrpContext->Vcb->UpcaseTableSize,
                        &Lcb->IgnoreCaseLink.LinkName );

        //
        //  Now for every ccb attached to us we need to munge it file object name by
        //  copying over the entire new name
        //

        Ccb = NULL;
        while ((Ccb = NtfsGetNextCcb(Lcb, Ccb)) != NULL) {

            //
            //  We ignore any Ccb's which are associated with open by File Id
            //  file objects.  We also ignore any Ccb's which don't have a file
            //  object pointer.  Lock and unlock the Fcb to serialize access
            //  to the close flag.
            //

            NtfsLockFcb( IrpContext, Ccb->Lcb->Fcb );
            if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID | CCB_FLAG_CLOSE )) {

                RtlCopyMemory( &Ccb->FullFileName.Buffer[ Ccb->LastFileNameOffset / sizeof( WCHAR ) ],
                               LastComponentFileName->Buffer,
                               BytesNeeded );

                Ccb->FullFileName.Length = Ccb->LastFileNameOffset + (USHORT) BytesNeeded;
            }
            NtfsUnlockFcb( IrpContext, Ccb->Lcb->Fcb );
        }
    }

    return;
}


VOID
NtfsCombineLcbs (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB PrimaryLcb,
    IN PLCB AuxLcb
    )

/*++

Routine Description:

    This routine is called for the case where we have multiple Lcb's for a
    file which connect to the same Scb.  We are performing a link rename
    operation which causes the links to be combined and we need to
    move all of the Ccb's to the same Lcb.  This routine will be called only
    after the names have been munged so that they are identical.
    (i.e. call NtfsRenameLcb first)

Arguments:

    PrimaryLcb - Supplies the Lcb to receive all the Ccb's and Pcb's.

    AuxLcb - Supplies the Lcb to strip.

Return Value:

    None.

--*/

{
    PLIST_ENTRY Links;
    PCCB NextCcb;

    DebugTrace( +1, Dbg, ("NtfsCombineLcbs:  Entered\n") );

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_LCB( PrimaryLcb );
    ASSERT_LCB( AuxLcb );

    PAGED_CODE();

    //
    //  Move all of the Ccb's first.
    //

    for (Links = AuxLcb->CcbQueue.Flink;
         Links != &AuxLcb->CcbQueue;
         Links = AuxLcb->CcbQueue.Flink) {

        NextCcb = CONTAINING_RECORD( Links, CCB, LcbLinks );
        NtfsUnlinkCcbFromLcb( IrpContext, AuxLcb->Fcb, NextCcb );
        NtfsLinkCcbToLcb( IrpContext, PrimaryLcb->Fcb, NextCcb, PrimaryLcb );
    }

    //
    //  Now do the prefix entries.
    //

    ASSERT( NtfsIsExclusiveScb( AuxLcb->Scb ) );
    NtfsRemovePrefix( AuxLcb );

    //
    //  Remove any hash table entries for this Lcb.
    //

    NtfsRemoveHashEntriesForLcb( AuxLcb );

    //
    //  Finally we need to transfer the unclean counts from the
    //  Lcb being merged to the primary Lcb.
    //

    PrimaryLcb->CleanupCount += AuxLcb->CleanupCount;

    DebugTrace( -1, Dbg, ("NtfsCombineLcbs:  Entered\n") );

    return;
}


PLCB
NtfsLookupLcbByFlags (
    IN PFCB Fcb,
    IN UCHAR FileNameFlags
    )

/*++

Routine Description:

    This routine is called to find a split primary link by the file flag
    only.

Arguments:

    Fcb - This is the Fcb for the file.

    FileNameFlags - This is the file flag to search for.  We will return
        a link which matches this exactly.

Return Value:

    PLCB - The Lcb which has the desired flag, NULL otherwise.

--*/

{
    PLCB Lcb;

    PLIST_ENTRY Links;
    PLCB ThisLcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupLcbByFlags:  Entered\n") );

    Lcb = NULL;

    //
    //  Walk through the Lcb's for the file, looking for an exact match.
    //

    for (Links = Fcb->LcbQueue.Flink; Links != &Fcb->LcbQueue; Links = Links->Flink) {

        ThisLcb = CONTAINING_RECORD( Links, LCB, FcbLinks );

        if (ThisLcb->FileNameAttr->Flags == FileNameFlags) {

            Lcb = ThisLcb;
            break;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsLookupLcbByFlags:  Exit\n") );

    return Lcb;
}



ULONG
NtfsLookupNameLengthViaLcb (
    IN PFCB Fcb,
    OUT PBOOLEAN LeadingBackslash
    )

/*++

Routine Description:

    This routine is called to find the length of the file name by walking
    backwards through the Lcb links.

Arguments:

    Fcb - This is the Fcb for the file.

    LeadingBackslash - On return, indicates whether this chain begins with a
        backslash.

Return Value:

    ULONG This is the length of the bytes found in the Lcb chain.

--*/

{
    ULONG NameLength;

    DebugTrace( +1, Dbg, ("NtfsLookupNameLengthViaLcb:  Entered\n") );

    //
    //  Initialize the return values.
    //

    NameLength = 0;
    *LeadingBackslash = FALSE;

    //
    //  If there is no Lcb we are done.
    //

    if (!IsListEmpty( &Fcb->LcbQueue )) {

        PLCB ThisLcb;
        BOOLEAN FirstComponent;

        //
        //  Walk up the list of Lcb's and count the name elements.
        //

        FirstComponent = TRUE;

        ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                     LCB,
                                     FcbLinks );

        //
        //  Loop until we have reached the root or there are no more Lcb's.
        //

        while (TRUE) {

            if (ThisLcb == Fcb->Vcb->RootLcb) {

                NameLength += sizeof( WCHAR );
                *LeadingBackslash = TRUE;
                break;
            }

            //
            //  If this is not the first component, we add room for a separating
            //  forward slash.
            //

            if (!FirstComponent) {

                NameLength += sizeof( WCHAR );

            } else {

                FirstComponent = FALSE;
            }

            NameLength += ThisLcb->ExactCaseLink.LinkName.Length;

            //
            //  If the next Fcb has no Lcb we exit.
            //

            Fcb = ((PSCB) ThisLcb->Scb)->Fcb;

            if (IsListEmpty( &Fcb->LcbQueue)) {

                break;
            }

            ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                         LCB,
                                         FcbLinks );
        }

    //
    //  If this is a system file we use the hard coded name.
    //

    } else if (NtfsSegmentNumber( &Fcb->FileReference ) <= UPCASE_TABLE_NUMBER) {

        NameLength = NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )].Length;
        *LeadingBackslash = TRUE;
    }

    DebugTrace( -1, Dbg, ("NtfsLookupNameLengthViaLcb:  Exit - %08lx\n", NameLength) );
    return NameLength;
}


VOID
NtfsFileNameViaLcb (
    IN PFCB Fcb,
    IN PWCHAR FileName,
    ULONG Length,
    ULONG BytesToCopy
    )

/*++

Routine Description:

    This routine is called to fill a buffer with the generated filename.  The name
    is constructed by walking backwards through the Lcb chain from the current Fcb.

Arguments:

    Fcb - This is the Fcb for the file.

    FileName - This is the buffer to fill with the name.

    Length - This is the length of the name.  Already calculated by calling
        NtfsLookupNameLengthViaLcb.

    BytesToCopy - This indicates the number of bytes we are to copy.  We drop
        any characters out of the trailing Lcb's to only insert the beginning
        of the path.

Return Value:

    None.

--*/

{
    ULONG BytesToDrop;

    PWCHAR ThisName;
    DebugTrace( +1, Dbg, ("NtfsFileNameViaLcb:  Entered\n") );

    //
    //  If there is no Lcb or there are no bytes to copy we are done.
    //

    if (BytesToCopy) {

        if (!IsListEmpty( &Fcb->LcbQueue )) {

            PLCB ThisLcb;
            BOOLEAN FirstComponent;

            //
            //  Walk up the list of Lcb's and count the name elements.
            //

            FirstComponent = TRUE;

            ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                         LCB,
                                         FcbLinks );

            //
            //  Loop until we have reached the root or there are no more Lcb's.
            //

            while (TRUE) {

                if (ThisLcb == Fcb->Vcb->RootLcb) {

                    *FileName = L'\\';
                    break;
                }

                //
                //  If this is not the first component, we add room for a separating
                //  forward slash.
                //

                if (!FirstComponent) {

                    Length -= sizeof( WCHAR );
                    ThisName = (PWCHAR) Add2Ptr( FileName,
                                                 Length );

                    if (Length < BytesToCopy) {

                        *ThisName = L'\\';
                    }

                } else {

                    FirstComponent = FALSE;
                }

                //
                //  Length is current pointing just beyond where the next
                //  copy will end.  If we are beyond the number of bytes to copy
                //  then we will truncate the copy.
                //

                if (Length > BytesToCopy) {

                    BytesToDrop = Length - BytesToCopy;

                } else {

                    BytesToDrop = 0;
                }

                Length -= ThisLcb->ExactCaseLink.LinkName.Length;

                ThisName = (PWCHAR) Add2Ptr( FileName,
                                             Length );

                //
                //  Only perform the copy if we are in the range of bytes to copy.
                //

                if (Length < BytesToCopy) {

                    RtlCopyMemory( ThisName,
                                   ThisLcb->ExactCaseLink.LinkName.Buffer,
                                   ThisLcb->ExactCaseLink.LinkName.Length - BytesToDrop );
                }

                //
                //  If the next Fcb has no Lcb we exit.
                //

                Fcb = ((PSCB) ThisLcb->Scb)->Fcb;

                if (IsListEmpty( &Fcb->LcbQueue)) {

                    break;
                }

                ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                             LCB,
                                             FcbLinks );
            }

        //
        //  If this is a system file, we use the hard coded name.
        //

        } else if (NtfsSegmentNumber(&Fcb->FileReference) <= UPCASE_TABLE_NUMBER) {

            if (BytesToCopy > NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )].Length) {

                BytesToCopy = NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )].Length;
            }

            RtlCopyMemory( FileName,
                           NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )].Buffer,
                           BytesToCopy );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsFileNameViaLcb:  Exit\n") );
    return;
}


PCCB
NtfsCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN BOOLEAN Indexed,
    IN USHORT EaModificationCount,
    IN ULONG Flags,
    IN PFILE_OBJECT FileObject,
    IN ULONG LastFileNameOffset
    )

/*++

Routine Description:

    This routine creates a new CCB record

Arguments:

    Fcb - This is the Fcb for the file.  We will check if we can allocate
        the Ccb from an embedded structure.

    Indexed - Indicates if we need an index Ccb.

    EaModificationCount - This is the current modification count in the
        Fcb for this file.

    Flags - Informational flags for this Ccb.

    FileObject - Object containing full path used to open this file.

    LastFileNameOffset - Supplies the offset (in bytes) of the last component
        for the name that the user is opening.  If this is the root
        directory it should denote "\" and all other ones should not
        start with a backslash.

Return Value:

    CCB - returns a pointer to the newly allocate CCB

--*/

{
    PCCB Ccb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace( +1, Dbg, ("NtfsCreateCcb\n") );

    //
    //  Allocate a new CCB Record.  If the Fcb is nonpaged then we must allocate
    //  a non-paged ccb.  Then test if we can allocate this out of the Fcb.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_NONPAGED )) {

        if (Indexed) {

            Ccb = NtfsAllocatePoolWithTag( NonPagedPool, sizeof(CCB), 'CftN' );

        } else {

            Ccb = NtfsAllocatePoolWithTag( NonPagedPool, sizeof(CCB_DATA), 'cftN' );
        }

    } else if (FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) &&
               (SafeNodeType( &((PFCB_INDEX) Fcb)->Ccb ) == 0)) {

        Ccb = (PCCB) &((PFCB_INDEX) Fcb)->Ccb;

    } else if (!Indexed &&
               FlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_DATA ) &&
               (SafeNodeType( &((PFCB_DATA) Fcb)->Ccb ) == 0)) {

        Ccb = (PCCB) &((PFCB_DATA) Fcb)->Ccb;

    } else {

        if (Indexed) {

            Ccb = (PCCB)ExAllocateFromPagedLookasideList( &NtfsCcbLookasideList );

        } else {

            Ccb = (PCCB)ExAllocateFromPagedLookasideList( &NtfsCcbDataLookasideList );
        }
    }

    //
    //  Zero and initialize the correct structure.
    //

    if (Indexed) {

        RtlZeroMemory( Ccb, sizeof(CCB) );

        //
        //  Set the proper node type code and node byte size
        //

        Ccb->NodeTypeCode = NTFS_NTC_CCB_INDEX;
        Ccb->NodeByteSize = sizeof(CCB);

    } else {

        RtlZeroMemory( Ccb, sizeof(CCB_DATA) );

        //
        //  Set the proper node type code and node byte size
        //

        Ccb->NodeTypeCode = NTFS_NTC_CCB_DATA;
        Ccb->NodeByteSize = sizeof(CCB_DATA);
    }

    //
    //  Copy the Ea modification count.
    //

    Ccb->EaModificationCount = EaModificationCount;

    //
    //  Copy the flags field
    //

    Ccb->Flags = Flags;

    //
    //  Set the file object and last file name offset fields
    //

    Ccb->FullFileName = FileObject->FileName;
    Ccb->LastFileNameOffset = (USHORT)LastFileNameOffset;

    //
    //  Initialize the Lcb queue.
    //

    InitializeListHead( &Ccb->LcbLinks );

    //
    //  Add the Ccb onto the Scb
    //

    InsertTailList( &Scb->CcbQueue, &Ccb->CcbLinks );

#ifdef CCB_FILE_OBJECT
    Ccb->FileObject = FileObject;
    Ccb->Process = PsGetCurrentProcess();
#endif

    DebugTrace( -1, Dbg, ("NtfsCreateCcb -> %08lx\n", Ccb) );

    return Ccb;
}


VOID
NtfsDeleteCcb (
    IN PFCB Fcb,
    IN OUT PCCB *Ccb
    )

/*++

Routine Description:

    This routine deallocates the specified CCB record.

Arguments:

    Fcb - This is the Fcb for the file.  We will check if we can allocate
        the Ccb from an embedded structure.

    Ccb - Supplies the CCB to remove

Return Value:

    None

--*/

{
    ASSERT_CCB( *Ccb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteCcb, Ccb = %08lx\n", Ccb) );

    //
    //  Deallocate any structures the Ccb is pointing to.  The following
    //  are only in index Ccb.
    //

    if (SafeNodeType( *Ccb ) == NTFS_NTC_CCB_INDEX) {

        //
        //  Make sure we aren't deleting this with any waiters.
        //

        ASSERT( (*Ccb)->EnumQueue.Flink == NULL );

        //
        //  If this Ccb was for a view index, we may need to
        //  free the read context used for directory enumeration.
        //

        if (FlagOn( (*Ccb)->Flags, CCB_FLAG_READ_CONTEXT_ALLOCATED )) {

            NtOfsFreeReadContext( (*Ccb)->QueryBuffer );

        } else if ((*Ccb)->QueryBuffer != NULL)  {

            NtfsFreePool( (*Ccb)->QueryBuffer );
        }

        if ((*Ccb)->IndexEntry != NULL)   { NtfsFreePool( (*Ccb)->IndexEntry ); }

        if ((*Ccb)->IndexContext != NULL) {

            PINDEX_CONTEXT IndexContext;

            if ((*Ccb)->IndexContext->Base != (*Ccb)->IndexContext->LookupStack) {
                NtfsFreePool( (*Ccb)->IndexContext->Base );
            }

            //
            //  Copy the IndexContext pointer into the stack so we don't dereference the
            //  paged Ccb while holding a spinlock.
            //

            IndexContext = (*Ccb)->IndexContext;
            ExFreeToPagedLookasideList( &NtfsIndexContextLookasideList, IndexContext );
        }
    }

    if (FlagOn( (*Ccb)->Flags, CCB_FLAG_ALLOCATED_FILE_NAME )) {

        NtfsFreePool( (*Ccb)->FullFileName.Buffer );
    }

    //
    //  Unhook Ccb from Scb list
    //

    RemoveEntryList( &(*Ccb)->CcbLinks );

    //
    //  Deallocate the Ccb simply clear the flag in the Ccb header.
    //

    if ((*Ccb == (PCCB) &((PFCB_DATA) Fcb)->Ccb) ||
        (*Ccb == (PCCB) &((PFCB_INDEX) Fcb)->Ccb)) {

        (*Ccb)->NodeTypeCode = 0;

    } else {

        if (SafeNodeType( *Ccb ) == NTFS_NTC_CCB_INDEX) {

            ExFreeToPagedLookasideList( &NtfsCcbLookasideList, *Ccb );

        } else {

            ExFreeToPagedLookasideList( &NtfsCcbDataLookasideList, *Ccb );
        }
    }

    //
    //  Zero out the input pointer
    //

    *Ccb = NULL;

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsDeleteCcb -> VOID\n") );

    return;

}


VOID
NtfsInitializeIrpContext (
    IN PIRP Irp OPTIONAL,
    IN BOOLEAN Wait,
    IN OUT PIRP_CONTEXT *IrpContext
    )

/*++

Routine Description:

    This routine creates and/or initializes a new IRP_CONTEXT record.  The context
    may be on the stack already or we might need to allocate it here.

Arguments:

    Irp - Supplies the originating Irp.  In many cases we won't be given an IrpContext for
        operations where we are doing work for Ntfs not for the user.
        operation.

    Wait - Supplies the wait value to store in the context.

    IrpContext - Address to store the IrpContext on return.  If this initially points to
        a non-NULL value then the IrpContext is on the stack.


Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PVCB Vcb;
    ULONG StateFlags = 0;
    UCHAR MajorFunction;
    UCHAR MinorFunction;

    ASSERT_OPTIONAL_IRP( Irp );

    //
    //  If the Irp is present then check that this is a legal operation for Ntfs.
    //
    //  Also capture the Vcb, function codes and write-through state if we have
    //  a legal Irp.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        ASSERT( (DWORD_PTR)(Irp->Tail.Overlay.AuxiliaryBuffer) != 0xFFFFFFFF );

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  If we were called with our file system device object instead of a
        //  volume device object and this is not a mount, the request is illegal.
        //

        if ((IrpSp->DeviceObject->Size == (USHORT)sizeof(DEVICE_OBJECT)) &&
            (IrpSp->FileObject != NULL)) {

            //
            //  Clear the IrpContext pointer so our caller knows the request failed.
            //

            *IrpContext = NULL;
            ExRaiseStatus( STATUS_INVALID_DEVICE_REQUEST );
        }

        //
        //  Copy RealDevice for workque algorithms, and also set WriteThrough
        //  if there is a file object.
        //

        if (IrpSp->FileObject != NULL) {

            //
            //  Locate the volume device object and Vcb that we are trying to access
            //  so we can see if the request is WriteThrough.  We ignore the
            //  write-through flag for close and cleanup.
            //

            Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;

            ASSERT( NodeType(Vcb) == NTFS_NTC_VCB );

            ASSERTMSG( "No correspondence btwn file and device in irp",
                      ((IrpSp->FileObject->Vpb == NULL) &&
                       ((IrpSp->FileObject->DeviceObject != NULL) &&
                       (IrpSp->FileObject->DeviceObject->Vpb != NULL) &&
                       (IrpSp->DeviceObject == IrpSp->FileObject->DeviceObject->Vpb->DeviceObject))) ||

                      ((IrpSp->FileObject->Vpb != NULL) &&
                       (IrpSp->DeviceObject == IrpSp->FileObject->Vpb->DeviceObject)) ||

                      (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) );

            if (IsFileWriteThrough( IrpSp->FileObject, Vcb )) {

                StateFlags = IRP_CONTEXT_STATE_WRITE_THROUGH;
            }

        //
        //  We would still like to find out the Vcb in all cases except for
        //  mount.
        //

        } else if (IrpSp->DeviceObject != NULL) {

            Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;

        } else {

            Vcb = NULL;
        }

        //
        //  Major/Minor Function codes
        //

        MajorFunction = IrpSp->MajorFunction;
        MinorFunction = IrpSp->MinorFunction;

    } else {

        Vcb = NULL;
        MajorFunction = 0;
        MinorFunction = 0;
    }

    //
    //  Allocate an IrpContext from zone if available, otherwise from
    //  non-paged pool.
    //

    if (*IrpContext == NULL) {

        *IrpContext = (PIRP_CONTEXT)ExAllocateFromNPagedLookasideList( &NtfsIrpContextLookasideList );
        SetFlag( StateFlags, IRP_CONTEXT_STATE_ALLOC_FROM_POOL );
    }

    DebugDoit( NtfsFsdEntryCount += 1);

    RtlZeroMemory( *IrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    (*IrpContext)->NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    (*IrpContext)->NodeByteSize = sizeof(IRP_CONTEXT);

    //
    //  Set the originating Irp field
    //

    (*IrpContext)->OriginatingIrp = Irp;

    //
    //  Set the Vcb and function codes we found (or NULL).
    //

    (*IrpContext)->Vcb = Vcb;
    (*IrpContext)->MajorFunction = MajorFunction;
    (*IrpContext)->MinorFunction = MinorFunction;

    //
    //  Set the wait and write through flags.
    //

    if (Wait) { SetFlag( (*IrpContext)->State, IRP_CONTEXT_STATE_WAIT ); }
    SetFlag( (*IrpContext)->State, StateFlags );

    //
    //  Initialize the recently deallocated record queue and exclusive Scb queue
    //

    InitializeListHead( &(*IrpContext)->RecentlyDeallocatedQueue );
    InitializeListHead( &(*IrpContext)->ExclusiveFcbList );

    //
    //  Always point to ourselves as the TopLevelIrpContext.
    //

    (*IrpContext)->TopLevelIrpContext = *IrpContext;

    //
    //  Initialize the embedded scb snapshot
    //

    InitializeListHead( &(*IrpContext)->ScbSnapshot.SnapshotLinks );

    //
    //  Set up LogFull testing
    //

#ifdef NTFS_LOG_FULL_TEST
    (*IrpContext)->CurrentFailCount = (*IrpContext)->NextFailCount = NtfsFailCheck;
#endif

    return;
}


VOID
NtfsCleanupIrpContext (
    IN OUT PIRP_CONTEXT IrpContext,
    IN ULONG Retry
    )

/*++

Routine Description:

    This routine performs cleanup on an IrpContext when we are finished using it in the current
    thread.  This can be because we are completing, retrying or posting a request.  It may be
    from the stack or allocated from pool.

    This request can also be called after a transaction has committed to cleanup all of
    the state information and resources held as part of the transaction.  The user can set
    the appropriate flags to prevent it from being deleted.

Arguments:

    IrpContext - Supplies the IRP_CONTEXT to cleanup.

    Retry - Indicates if we are retrying in the same thread or posting.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Start with the recently deallocated records.
    //

    if (!IsListEmpty( &IrpContext->RecentlyDeallocatedQueue )) {

        NtfsDeallocateRecordsComplete( IrpContext );
    }

    //
    //  Just in case we somehow get here with a transaction ID, clear
    //  it here so we do not loop forever.
    //

    ASSERT( IrpContext->TransactionId == 0 );
    IrpContext->TransactionId = 0;


    NtfsReleaseAllResources( IrpContext );

#ifdef MAPCOUNT_DBG

    //
    //  Check all mapping are gone now that we cleaned out cache
    //

    ASSERT( IrpContext->MapCount == 0 );

#endif

    //
    //  Make sure there are no Scb snapshots left.  Most are freed above when the fcb's are released
    //  but preacquires from mm - for example doing a flushuserstream or deleted scbs will need to be
    //  cleaned up here
    //

    NtfsFreeSnapshotsForFcb( IrpContext, NULL );

    //
    //  Make sure we don't need to deallocate a UsnFcb structure.
    //

    while (IrpContext->Usn.NextUsnFcb != NULL) {

        PUSN_FCB ThisUsn;

        ThisUsn = IrpContext->Usn.NextUsnFcb;
        IrpContext->Usn.NextUsnFcb = ThisUsn->NextUsnFcb;
        NtfsFreePool( ThisUsn );
    }

    //
    //  If we can delete this Irp Context do so now.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE ) &&
        !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT )) {

        if (IrpContext->Union.NtfsIoContext != NULL) {

            //
            //  If there is an Io context pointer in the irp context and it is not
            //  on the stack, then free it.
            //

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT )) {

                ExFreeToNPagedLookasideList( &NtfsIoContextLookasideList, IrpContext->Union.NtfsIoContext );

            //
            //  If we have captured the subject context then free it now.
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_SECURITY )) {

                SeReleaseSubjectContext( IrpContext->Union.SubjectContext );

                NtfsFreePool( IrpContext->Union.SubjectContext );

            //
            //  Else if we locked the user buffer in a sep. mdl in ReadUsnFile
            //

            } else if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_MDL )) {

                MmUnlockPages( IrpContext->Union.MdlToCleanup );
                IoFreeMdl( IrpContext->Union.MdlToCleanup );
            }

            IrpContext->Union.NtfsIoContext = NULL;
        }

        //
        //  Restore the thread context pointer if associated with this IrpContext.
        //

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

            NtfsRestoreTopLevelIrp();
            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
        }

        //
        //  Return the IRP context record to the lookaside or to pool depending
        //  how much is currently in the lookaside
        //

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL )) {

            ExFreeToNPagedLookasideList( &NtfsIrpContextLookasideList, IrpContext );
        }

    } else {

        //
        //  Do all any necessary to reinitialize IrpContext fields.  We avoid doing
        //  these if the IrpContext is going away.
        //

        RtlZeroMemory( &IrpContext->ScbSnapshot, sizeof( SCB_SNAPSHOT ));
        InitializeListHead( &IrpContext->ScbSnapshot.SnapshotLinks );

        //
        //  Clear the appropriate flags unless our caller wanted to preserve them.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_RETAIN_FLAGS )) {

            //
            //  Set up the Irp Context for retry or post.
            //

            if (Retry) {

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY );

            } else {

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_POST );
            }

        } else {

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RETAIN_FLAGS | IRP_CONTEXT_FLAG_DONT_DELETE );
        }

        //
        //  Always clear the counts of free records and clusters.
        //

        IrpContext->DeallocatedClusters = 0;
        IrpContext->FreeClusterChange = 0;
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
NtfsInitializeIoContext (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_IO_CONTEXT IoContext,
    IN BOOLEAN PagingIo
    )
/*++

Routine Description:

    Add a NTFS_IO_CONTEXT to the irpcontext and initializes it. If the request
    is synchronous we'll try to use the IoContext passed in. If its asynch then
    we'll allocate one from the lookaside list if its not already been done.  Note:
    we'll reuse a pool allocated io_context

    However for an asynch request one must call NtfsSetIoContext Async afterwards
    to fill in the additional parameters. Before that point its still marked synchronous
    even if we allocated it from pool and the synch event is initialized for use

Arguments:

    IrpContext - Supplies the IRP_CONTEXT

    IoContext - A local context to use if the the request is synchronous - can be
        on the stack

    PagingIo - Whether the operation is a paging operation

Return Value:

    None

--*/
{
    LOGICAL Wait = FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    if ((IrpContext->Union.NtfsIoContext == NULL) ||
        !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT )) {

        //
        //  If we can wait, use the context on the stack.  Otherwise
        //  we need to allocate one.
        //

        if (Wait) {

            IrpContext->Union.NtfsIoContext = IoContext;
            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

        } else {

            IrpContext->Union.NtfsIoContext = (PNTFS_IO_CONTEXT)ExAllocateFromNPagedLookasideList( &NtfsIoContextLookasideList );
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );
        }
    }

    RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

    //
    //  Store whether we allocated this context structure in the structure
    //  itself.
    //

    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT )) {
        SetFlag( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_ALLOCATED );
    }

    if (PagingIo) {
        SetFlag( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_PAGING_IO );
    }

    IrpContext->Union.NtfsIoContext->MasterIrp = IrpContext->OriginatingIrp;
    KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                       NotificationEvent,
                       FALSE );
}


VOID
NtfsSetIoContextAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE ResourceToRelease,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    Sets up the async field of an io context. Use this right before call
    NtfsnonCachedIo for async requests. Because these fields are overloaded with
    the event after calling this the syncrhonous event is not available

Arguments:

    IrpContext - Supplies the IRP_CONTEXT containing an io context

    ResourceToRelease - resource to be released at async operations completion

    ByteCount - Original requested bytecount of the transfer

Return Value:

    None

--*/

{

    IrpContext->Union.NtfsIoContext->Wait.Async.Resource = ResourceToRelease;
    IrpContext->Union.NtfsIoContext->Wait.Async.ResourceThreadId = ExGetCurrentResourceThread();
    IrpContext->Union.NtfsIoContext->Wait.Async.RequestedByteCount = ByteCount;

    SetFlag( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_ASYNC );
}



VOID
NtfsTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID FcbOrScb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN CheckForAttributeTable,
    IN ULONG AcquireFlags,
    OUT PBOOLEAN RemovedFcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to start the teardown process on a node in
    the Fcb/Scb tree.  We will attempt to remove this node and then
    move up the tree removing any nodes held by this node.

    This routine deals with the case where a single node may be holding
    multiple parents in memory.  If we are passed an input Lcb we will
    use that to walk up the tree.  If the Vcb is held exclusively we
    will try to trim any nodes that have no open files on them.

    This routine takes the following steps:

        Remove as many Scb's and file objects from the starting
            Fcb.

        If the Fcb can't go away but has multiple links then remove
            whatever links possible.  If we have the Vcb we can
            do all of them but we will leave a single link behind
            to optimize prefix lookups.  Otherwise we will traverse the
            single link we were given.

        If the Fcb can go away then we should have the Vcb if there are
            multiple links to remove.  Otherwise we only remove the link
            we were given if there are multiple links.  In the single link
            case just remove that link.

Arguments:

    FcbOrScb - Supplies either an Fcb or an Scb as the start of the
        teardown point.  The Fcb for this element must be held exclusively.

    Lcb - If specified, this is the path up the tree to perform the
        teardown.

    CheckForAttributeTable - Indicates that we should not teardown an
        Scb which is in the attribute table.  Instead we will attempt
        to put an entry on the async close queue.  This will be TRUE
        if we may need the Scb to abort the current transaction.

    AcquireFlags - Indicates whether we should abort the teardown when
        we can't acquire a parent.  When called from some path where we may
        hold the MftScb or another resource in another path up the tree.

            ACQUIRE_NO_DELETE_CHECK
            ACQUIRE_DONT_WAIT
            ACQUIRE_HOLD_BITMAP

    RemovedFcb - Address to store TRUE if we delete the starting Fcb.

Return Value:

    None

--*/

{
    PSCB StartingScb = NULL;
    PFCB Fcb;
    BOOLEAN FcbCanBeRemoved;
    BOOLEAN RemovedLcb;
    BOOLEAN LocalRemovedFcb = FALSE;
    PLIST_ENTRY Links;
    PLIST_ENTRY NextLink;

    PAGED_CODE();

    //
    //  If this is a recursive call to TearDownStructures we return immediately
    //  doing no operation.
    //

    if (FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_IN_TEARDOWN )) {

        DebugTrace( 0, Dbg, ("Recursive teardown call\n") );
        DebugTrace( -1, Dbg, ("NtfsTeardownStructures -> VOID\n") );

        return;
    }

    if (SafeNodeType(FcbOrScb) == NTFS_NTC_FCB) {

        Fcb = FcbOrScb;

    } else {

        StartingScb = FcbOrScb;
        FcbOrScb = Fcb = StartingScb->Fcb;
    }

    SetFlag( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_IN_TEARDOWN );

    //
    //  Use a try-finally to clear the top level irp field.
    //

    try {

        //
        //  Use our local boolean if the caller didn't supply one.
        //

        if (!ARGUMENT_PRESENT( RemovedFcb )) {

            RemovedFcb = &LocalRemovedFcb;
        }

        //
        //  Check this Fcb for removal.  Remember if all of the Scb's
        //  and file objects are gone.  We will try to remove the Fcb
        //  if the cleanup count is zero or if we are walking up
        //  one directory path of a mult-link file.  If the Fcb has
        //  a non-zero cleanup count but the current Scb has a zero
        //  cleanup count then try to delete the Scb at the very least.
        //

        FcbCanBeRemoved = FALSE;

        if (Fcb->CleanupCount == 0) {

            FcbCanBeRemoved = NtfsPrepareFcbForRemoval( IrpContext,
                                                        Fcb,
                                                        StartingScb,
                                                        CheckForAttributeTable );

        } else if (ARGUMENT_PRESENT( StartingScb ) &&
                   (StartingScb->CleanupCount == 0) &&
                   (StartingScb->AttributeTypeCode != $ATTRIBUTE_LIST)) {

            NtfsRemoveScb( IrpContext, StartingScb, CheckForAttributeTable );
        }

        //
        //  There is a single link (typical case) we either try to
        //  remove that link or we simply return.
        //

        if (Fcb->LcbQueue.Flink == Fcb->LcbQueue.Blink) {

            if (FcbCanBeRemoved) {

                NtfsTeardownFromLcb( IrpContext,
                                     Fcb->Vcb,
                                     Fcb,
                                     CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                                        LCB,
                                                        FcbLinks ),
                                     CheckForAttributeTable,
                                     AcquireFlags,
                                     &RemovedLcb,
                                     RemovedFcb );
            }

            leave;

        //
        //  If there are multiple links we will try to either remove
        //  them all or all but one (if the Fcb is not going away) if
        //  we own the Vcb.  We will try to delete the one we were
        //  given otherwise.
        //

        } else {

            //
            //  If we have the Vcb we will remove all if the Fcb can
            //  go away.  Otherwise we will leave one.
            //

            if (NtfsIsExclusiveVcb( Fcb->Vcb )) {

                Links = Fcb->LcbQueue.Flink;

                while (TRUE) {

                    //
                    //  Remember the next entry in case the current link
                    //  goes away.
                    //

                    NextLink = Links->Flink;

                    RemovedLcb = FALSE;

                    NtfsTeardownFromLcb( IrpContext,
                                         Fcb->Vcb,
                                         Fcb,
                                         CONTAINING_RECORD( Links, LCB, FcbLinks ),
                                         CheckForAttributeTable,
                                         0,
                                         &RemovedLcb,
                                         RemovedFcb );

                    //
                    //  If couldn't remove this link then munge the
                    //  boolean indicating if the Fcb can be removed
                    //  to make it appear we need to remove all of
                    //  the Lcb's.
                    //

                    if (!RemovedLcb) {

                        FcbCanBeRemoved = TRUE;
                    }

                    //
                    //  If the Fcb has been removed then we exit.
                    //  If the next link is the beginning of the
                    //  Lcb queue then we also exit.
                    //  If the next link is the last entry and
                    //  we want to leave a single entry then we
                    //  exit.
                    //

                    if (*RemovedFcb ||
                        (NextLink == &Fcb->LcbQueue) ||
                        (!FcbCanBeRemoved &&
                         (NextLink->Flink == &Fcb->LcbQueue))) {

                        leave;
                    }

                    //
                    //  Move to the next link.
                    //

                    Links = NextLink;
                }

            //
            //  If we have an Lcb just move up that path.
            //

            } else if (ARGUMENT_PRESENT( Lcb )) {

                NtfsTeardownFromLcb( IrpContext,
                                     Fcb->Vcb,
                                     Fcb,
                                     Lcb,
                                     CheckForAttributeTable,
                                     AcquireFlags,
                                     &RemovedLcb,
                                     RemovedFcb );
            }
        }

    } finally {

        DebugUnwind( NtfsTeardownStructures );

        ClearFlag( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_IN_TEARDOWN );
    }

    return;
}


//
//
//

PVOID
NtfsAllocateCompressionSync (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This routine is called by the lookaside package to allocation a new compression
    sync structure.  We have a dedicated routine in order to perform the resource
    initialization if necessary.  Otherwise the caller will need to defensively
    test and initialize the resource.

Arguments:

    PoolType - Type of pool associated with the lookaside list.

    NumberOfBytes - Size of pool block to allocate.

    Tag - Tag to associate with the block.

Return Value:

    NULL if we are unable to allocate the pool.  Otherwise a pointer to the block of
        of pool is returned.

--*/

{
    PCOMPRESSION_SYNC CompressionSync;

    PAGED_CODE();

    CompressionSync = NtfsAllocatePoolWithTagNoRaise( PoolType,
                                                      NumberOfBytes,
                                                      Tag );

    if (CompressionSync != NULL) {

        ExInitializeResourceLite( &CompressionSync->Resource );
        CompressionSync->ReferenceCount = 0;
    }

    return CompressionSync;
}


VOID
NtfsDeallocateCompressionSync (
    IN PVOID CompressionSync
    )

/*++

Routine Description:

    This routine is called to deallocate the pool for a single CompressionSync structure.
    We have our own routine in order to unitialize the embedded resource.

Arguments:

    CompressionSync - Structure to deallocate.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExDeleteResourceLite( &((PCOMPRESSION_SYNC) CompressionSync)->Resource );
    NtfsFreePool( CompressionSync );
    return;
}


VOID
NtfsIncrementCleanupCounts (
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN NonCachedHandle
    )

/*++

Routine Description:

    This routine increments the cleanup counts for the associated data structures

Arguments:

    Scb - Supplies the Scb used in this operation

    Lcb - Optionally supplies the Lcb used in this operation

    NonCachedHandle - Indicates this handle is for a user non-cached handle.

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;

    //
    //  This is really a pretty light weight procedure but having it be a procedure
    //  really helps in debugging the system and keeping track of who increments
    //  and decrements cleanup counts
    //

    if (ARGUMENT_PRESENT(Lcb)) { Lcb->CleanupCount += 1; }

    InterlockedIncrement( &Scb->CleanupCount );
    Scb->Fcb->CleanupCount += 1;

    if (NonCachedHandle) {

        Scb->NonCachedCleanupCount += 1;
    }

    InterlockedIncrement( &Vcb->CleanupCount );
    return;
}


VOID
NtfsIncrementCloseCounts (
    IN PSCB Scb,
    IN BOOLEAN SystemFile,
    IN BOOLEAN ReadOnly
    )

/*++

Routine Description:

    This routine increments the close counts for the associated data structures

Arguments:

    Scb - Supplies the Scb used in this operation

    SystemFile - Indicates if the Scb is for a system file  (if so then
        the Vcb system file close count in also incremented)

    ReadOnly - Indicates if the Scb is opened readonly.  (if so then the
        Vcb Read Only close count is also incremented)

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;

    //
    //  This is really a pretty light weight procedure but having it be a procedure
    //  really helps in debugging the system and keeping track of who increments
    //  and decrements close counts
    //

    //
    //  If this is someone other than the first open, remember that.
    //

    if (InterlockedIncrement( &Scb->CloseCount ) >= 2) {

        SetFlag( Scb->ScbState, SCB_STATE_MULTIPLE_OPENS );
    }

    InterlockedIncrement( &Scb->Fcb->CloseCount );

    InterlockedIncrement( &Vcb->CloseCount );

    if (SystemFile) {

        InterlockedIncrement( &Vcb->SystemFileCloseCount );
    }

    if (ReadOnly) {

        InterlockedIncrement( &Vcb->ReadOnlyCloseCount );
    }

    //
    //  We will always clear the delay close flag in this routine.
    //

    ClearFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );

    return;
}


VOID
NtfsDecrementCleanupCounts (
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN NonCachedHandle
    )

/*++

Routine Description:

    This procedure decrements the cleanup counts for the associated data structures
    and if necessary it also start to cleanup associated internal attribute streams

Arguments:

    Scb - Supplies the Scb used in this operation

    Lcb - Optionally supplies the Lcb used in this operation

    NonCachedHandle - Indicates this handle is for a user non-cached handle.

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;

    ASSERT_SCB( Scb );
    ASSERT_FCB( Scb->Fcb );
    ASSERT_VCB( Scb->Fcb->Vcb );
    ASSERT_OPTIONAL_LCB( Lcb );

    //
    //  First we decrement the appropriate cleanup counts
    //

    if (ARGUMENT_PRESENT(Lcb)) { Lcb->CleanupCount -= 1; }

    InterlockedDecrement( &Scb->CleanupCount );
    Scb->Fcb->CleanupCount -= 1;

    if (NonCachedHandle) {

        Scb->NonCachedCleanupCount -= 1;
    }

    InterlockedDecrement( &Vcb->CleanupCount );

    //
    //  Now if the Fcb's cleanup count is zero that indicates that we are
    //  done with this Fcb from a user handle standpoint and we should
    //  now scan through all of the Scb's that are opened under this
    //  Fcb and shutdown any internal attributes streams we have open.
    //  For example, EAs and ACLs.  We only need to do one.  The domino effect
    //  will take of the rest.
    //

    if (Scb->Fcb->CleanupCount == 0) {

        PSCB NextScb;

        //
        //  Remember if we are dealing with a system file and return immediately.
        //

        if (FlagOn(Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE) &&
            NtfsSegmentNumber( &Scb->Fcb->FileReference ) != ROOT_FILE_NAME_INDEX_NUMBER) {

            return;
        }

        for (NextScb = CONTAINING_RECORD(Scb->Fcb->ScbQueue.Flink, SCB, FcbLinks);
             &NextScb->FcbLinks != &Scb->Fcb->ScbQueue;
             NextScb = CONTAINING_RECORD( NextScb->FcbLinks.Flink, SCB, FcbLinks )) {

            //
            //  Skip the root index on the volume. Also don't remove internal file objects
            //  for attribute lists. Defer that until close. Currently create continues to use
            //  attribute list mappings after dropping the resource.
            //

            if ((SafeNodeType( NextScb ) == NTFS_NTC_SCB_ROOT_INDEX) ||
                (NextScb->AttributeTypeCode == $ATTRIBUTE_LIST)) {

                continue;
            }

            //
            //  It is possible that someone has referenced this Scb to keep it from going away.
            //  We can treat this the same as if there was a cleanup count in the Fcb.  Someone
            //  else is responsible for doing the cleanup.
            //
            //  We can also break out if we have an index with children.
            //

            if ((NextScb->CleanupCount != 0) ||
                ((SafeNodeType( NextScb ) == NTFS_NTC_SCB_INDEX) &&
                  !IsListEmpty( &NextScb->ScbType.Index.LcbQueue ))) {

                break;
            }

            //
            //  If there is an internal stream then dereference it and get out.
            //

            if (NextScb->FileObject != NULL) {

                NtfsDeleteInternalAttributeStream( NextScb,
                                                   (BOOLEAN) (Scb->Fcb->LinkCount == 0),
                                                   FALSE );
                break;
            }
        }
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
NtfsDecrementCloseCounts (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN SystemFile,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN DecrementCountsOnly,
    IN OUT PBOOLEAN RemovedFcb OPTIONAL
    )

/*++

Routine Description:

    This routine decrements the close counts for the associated data structures
    and if necessary it will teardown structures that are no longer in use

Arguments:

    Scb - Supplies the Scb used in this operation

    Lcb - Used if calling teardown to know which path to take.

    SystemFile - Indicates if the Scb is for a system file

    ReadOnly - Indicates if the Scb was opened readonly

    DecrementCountsOnly - Indicates if this operation should only modify the
        count fields.

    RemovedFcb - Optionally indicates to the caller if the Fcb has been
        deleted.

Return Value:

    TRUE if the fcb for the input scb was torndown

--*/

{
    PFCB Fcb = Scb->Fcb;
    PVCB Vcb = Scb->Vcb;
    BOOLEAN Dummy;

    ASSERT_SCB( Scb );
    ASSERT_FCB( Fcb );
    ASSERT_VCB( Fcb->Vcb );

    if (RemovedFcb == NULL) {

        RemovedFcb = &Dummy;
    }

    *RemovedFcb = FALSE;

    //
    //  Decrement the close counts
    //

    InterlockedDecrement( &Scb->CloseCount );
    InterlockedDecrement( &Fcb->CloseCount );

    InterlockedDecrement( &Vcb->CloseCount );

    if (SystemFile) {

        InterlockedDecrement( &Vcb->SystemFileCloseCount );
    }

    if (ReadOnly) {

        InterlockedDecrement( &Vcb->ReadOnlyCloseCount );
    }

    //
    //  Now if the scb's close count is zero then we are ready to tear
    //  it down
    //

    if (!DecrementCountsOnly) {

        //
        //  We want to try to start a teardown from this Scb if
        //
        //      - The close count is zero
        //
        //          or the following are all true
        //
        //      - The cleanup count is zero
        //      - There is a file object in the Scb
        //      - It is a data Scb or an empty index Scb
        //      - It is not an Ntfs system file
        //
        //  The teardown will be noopted if this is a recursive call.
        //

        if (Scb->CloseCount == 0

                ||

            (Scb->CleanupCount == 0
             && Scb->FileObject != NULL
             && !FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)
             && ((SafeNodeType( Scb ) == NTFS_NTC_SCB_DATA)
                 || (SafeNodeType( Scb ) == NTFS_NTC_SCB_MFT)
                 || IsListEmpty( &Scb->ScbType.Index.LcbQueue )))) {

            NtfsTeardownStructures( IrpContext,
                                    Scb,
                                    Lcb,
                                    FALSE,
                                    0,
                                    RemovedFcb );
        }
    }
}

PERESOURCE
NtfsAllocateEresource (
    )
{
    KIRQL _SavedIrql;
    PERESOURCE Eresource;

    _SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
    if (NtfsData.FreeEresourceSize > 0) {
        Eresource = NtfsData.FreeEresourceArray[--NtfsData.FreeEresourceSize];
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
        Eresource = NtfsAllocatePoolWithTag( NonPagedPool, sizeof(ERESOURCE), 'rftN' );
        ExInitializeResourceLite( Eresource );
        NtfsData.FreeEresourceMiss += 1;
    }

    return Eresource;
}

VOID
NtfsFreeEresource (
    IN PERESOURCE Eresource
    )
{
    KIRQL _SavedIrql;

    //
    //  Do an unsafe test to see if we should put this on our list.
    //  We want to reinitialize this before adding to the list so
    //  we don't have a bunch of resources which appear to be held.
    //

    if (NtfsData.FreeEresourceSize < NtfsData.FreeEresourceTotal) {

        ExReinitializeResourceLite( Eresource );

        //
        //  Now acquire the spinlock and do a real test.
        //

        _SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
        if (NtfsData.FreeEresourceSize < NtfsData.FreeEresourceTotal) {
            NtfsData.FreeEresourceArray[NtfsData.FreeEresourceSize++] = Eresource;
            KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
        } else {
            KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
            ExDeleteResourceLite( Eresource );
            NtfsFreePool( Eresource );
        }

    } else {

        ExDeleteResourceLite( Eresource );
        NtfsFreePool( Eresource );
    }

    return;
}


PVOID
NtfsAllocateFcbTableEntry (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    FcbTable - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    KIRQL _SavedIrql;
    PVOID FcbTableEntry;

    UNREFERENCED_PARAMETER( FcbTable );

    _SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
    if (NtfsData.FreeFcbTableSize > 0) {
        FcbTableEntry = NtfsData.FreeFcbTableArray[--NtfsData.FreeFcbTableSize];
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
        FcbTableEntry = NtfsAllocatePool( PagedPool, ByteSize );
    }

    return FcbTableEntry;
}


VOID
NtfsFreeFcbTableEntry (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine that deallocates memory

Arguments:

    FcbTable - Supplies the generic table being used

    Buffer - Supplies the buffer being deallocated

Return Value:

    None.

--*/

{
    KIRQL _SavedIrql;

    UNREFERENCED_PARAMETER( FcbTable );

    _SavedIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );
    if (NtfsData.FreeFcbTableSize < FREE_FCB_TABLE_SIZE) {
        NtfsData.FreeFcbTableArray[NtfsData.FreeFcbTableSize++] = Buffer;
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, _SavedIrql );
        NtfsFreePool( Buffer );
    }

    return;
}


VOID
NtfsPostToNewLengthQueue (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called to add an Scb to the queue of Scbs which have
    waiters on extends.  There is a single element embedded in the IrpContext.
    Otherwise this field in the IrpContext will point to an array of elements.

Arguments:

    Scb - This is the Scb to add to the queue.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Nothing to do if this Scb is in the IrpContext.
    //

    if (Scb != IrpContext->CheckNewLength) {

        //
        //  If the IrpContext field is unused then stuff this into it.
        //

        if (IrpContext->CheckNewLength == NULL) {

            IrpContext->CheckNewLength = Scb;

        } else {

            PULONG_PTR NewQueue;

            //
            //  First case - there is an Scb in the IrpContext.
            //  Allocate a larger structure and put our element in it.
            //

            if (SafeNodeType( IrpContext->CheckNewLength ) == NTFS_NTC_SCB_DATA ) {

                NewQueue = NtfsAllocatePool( PagedPool, sizeof( ULONG_PTR ) * 3 );
                *NewQueue = (ULONG_PTR) IrpContext->CheckNewLength;
                IrpContext->CheckNewLength = NewQueue;
                *(NewQueue + 1) = (ULONG_PTR) Scb;
                *(NewQueue + 2) = (ULONG_PTR) NULL;

            //
            //  Second case - walk existing queue and look for an unused element or
            //  the current scb.
            //

            } else {

                NewQueue = IrpContext->CheckNewLength;

                do {

                    //
                    //  Our scb is in the queue.
                    //

                    if (*NewQueue == (ULONG_PTR) Scb) { break; }

                    //
                    //  The current position is unused.
                    //

                    if (*NewQueue == (ULONG_PTR) -1) {

                        *NewQueue = (ULONG_PTR) Scb;
                        break;
                    }

                    //
                    //  We are at the end of the list.
                    //

                    if (*NewQueue == (ULONG_PTR) NULL) {

                        ULONG CurrentLength;

                        CurrentLength = PtrOffset( IrpContext->CheckNewLength, NewQueue );

                        NewQueue = NtfsAllocatePool( PagedPool,
                                                     CurrentLength + (4 * sizeof( ULONG_PTR )) );

                        RtlCopyMemory( NewQueue,
                                       IrpContext->CheckNewLength,
                                       CurrentLength );

                        NewQueue = Add2Ptr( NewQueue, CurrentLength );
                        *NewQueue = (ULONG_PTR) Scb;
                        *(NewQueue + 1) = -1;
                        *(NewQueue + 2) = -1;
                        *(NewQueue + 3) = (ULONG_PTR) NULL;

                        NtfsFreePool( IrpContext->CheckNewLength );
                        IrpContext->CheckNewLength = NewQueue;
                        break;
                    }

                    //
                    //  Go to the next element.
                    //

                    NewQueue += 1;

                } while (TRUE);
            }
        }
    }

    return;
}


VOID
NtfsProcessNewLengthQueue (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN CleanupOnly
    )

/*++

Routine Description:

    This routine is called when there is at least one Scb in the IrpContext
    queue of streams which have waiters on the new length.  We will call
    NtOfsPostNewLength for each element unless we are cleaning up only.

Arguments:

    IrpContext - Has a non-empty queue of Scbs for the current transaction.

    CleanupOnly - Indicates if we only want to clean up the queue, not
        alert any waiters (this is the error path).

Return Value:

    None.

--*/

{
    PULONG_PTR NextScb;
    PAGED_CODE();

    //
    //  Check if the only entry is resident in the IrpContext.
    //

    if (SafeNodeType( IrpContext->CheckNewLength ) == NTFS_NTC_SCB_DATA) {

        if (!CleanupOnly) {

            NtOfsPostNewLength( IrpContext, (PSCB) IrpContext->CheckNewLength, FALSE );
        }

    //
    //  Otherwise we want to walk through the external entries.
    //

    } else {

        if (!CleanupOnly) {

            NextScb = IrpContext->CheckNewLength;

            //
            //  Continue until we run out of entries.  The end of the block has a NULL, any unused entries
            //  will have a -1.
            //

            while ((*NextScb != (ULONG_PTR) -1) && (*NextScb != (ULONG_PTR) NULL)) {

                ASSERT( SafeNodeType( *NextScb ) == NTFS_NTC_SCB_DATA );
                NtOfsPostNewLength( IrpContext, (PSCB) *NextScb, FALSE );

                NextScb += 1;
            }
        }
        NtfsFreePool( IrpContext->CheckNewLength );
    }

    IrpContext->CheckNewLength = NULL;

    return;
}


VOID
NtfsTestStatusProc (
    )

/*++

Routine Description:

    This routine is to catch specific status codes in the running system.  It
    is called only when NtfsTestStatus is TRUE and the current request is completing
    with NtfsTestStatusCode.

Arguments:

    None

Return Value:

    None

--*/

{
    ASSERT( FALSE );
}


//
//  Local support routine
//

VOID
NtfsCheckScbForCache (
    IN OUT PSCB Scb
    )

/*++

Routine Description:

    This routine checks if the Scb has blocks contining
    Lsn's or Update sequence arrays and set the appropriate
    bit in the Scb state word.

    The Scb is Update sequence aware if it the Data Attribute for the
    Mft or the Data Attribute for the log file or any index allocation
    stream.

    The Lsn aware Scb's are the ones above without the Log file.

Arguments:

    Scb - Supplies the current Scb

Return Value:

    The next Scb in the enumeration, or NULL if Scb was the final one.

--*/

{
    //
    //  Temporarily either sequence 0 or 1 is ok.
    //

    FILE_REFERENCE MftTemp = {0,0,1};

    PAGED_CODE();

    //
    //  Check for Update Sequence Array files first.
    //

    if ((Scb->AttributeTypeCode == $INDEX_ALLOCATION)

          ||

        (Scb->AttributeTypeCode == $DATA
            && Scb->AttributeName.Length == 0
            && (NtfsEqualMftRef( &Scb->Fcb->FileReference, &MftFileReference )
                || NtfsEqualMftRef( &Scb->Fcb->FileReference, &MftTemp )
                || NtfsEqualMftRef( &Scb->Fcb->FileReference, &Mft2FileReference )
                || NtfsEqualMftRef( &Scb->Fcb->FileReference, &LogFileReference )))) {

        SetFlag( Scb->ScbState, SCB_STATE_USA_PRESENT );
    }

    return;
}


//
//  Local support routine.
//

BOOLEAN
NtfsRemoveScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN CheckForAttributeTable
    )

/*++

Routine Description:

    This routine will try to remove an Scb from the Fcb/Scb tree.
    It deals with the case where we can make no attempt to remove
    the Scb, the case where we start the process but can't complete
    it, and finally the case where we remove the Scb entirely.

    The following conditions prevent us from removing the Scb at all.

        The open count is greater than 1.
        It is the root directory.
        It is an index Scb with no stream file and an outstanding close.
        It is a data file with a non-zero close count.

    We start the teardown under the following conditions.

        It is an index with an open count of 1, and a stream file object.

    We totally remove the Scb when the open count is zero.

Arguments:

    Scb - Supplies the Scb to test

    CheckForAttributeTable - Indicates that we don't want to remove this
        Scb in this thread if it is in the open attribute table.  We will
        queue an async close in this case.  This is to prevent us from
        deleting an Scb which may be needed in the abort path.

Return Value:

    BOOLEAN - TRUE if the Scb was removed, FALSE otherwise.  We return FALSE for
        the case where we start the process but don't finish.

--*/

{
    BOOLEAN ScbRemoved;

    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRemoveScb:  Entered\n") );
    DebugTrace( 0, Dbg, ("Scb   ->  %08lx\n", Scb) );

    ScbRemoved = FALSE;

    //
    //  If the Scb is not the root Scb and the count is less than two,
    //  then this Scb is a candidate for removal.
    //

    if ((SafeNodeType( Scb ) != NTFS_NTC_SCB_ROOT_INDEX) && (Scb->CleanupCount == 0)) {

        //
        //
        //  If this is a data file or it is an index without children,
        //  we can get rid of the Scb if there are no children.  If
        //  there is one open count and it is the file object, we
        //  can start the cleanup on the file object.
        //

        if ((SafeNodeType( Scb ) == NTFS_NTC_SCB_DATA) ||
            (SafeNodeType( Scb ) == NTFS_NTC_SCB_MFT) ||
            IsListEmpty( &Scb->ScbType.Index.LcbQueue )) {

            //
            //  Check if we need to post a request to the async queue.
            //

            if (CheckForAttributeTable &&
                (Scb->NonpagedScb->OpenAttributeTableIndex != 0)) {

                NtfsAddScbToFspClose( IrpContext, Scb, FALSE );

            } else {

                if (Scb->CloseCount == 0) {

                    NtfsDeleteScb( IrpContext, &Scb );
                    ScbRemoved = TRUE;

                //
                //  Else we know the open count is 1 or 2.  If there is a stream
                //  file, we discard it (but not for the special system
                //  files) that get removed on dismount
                //

                } else if (((Scb->FileObject != NULL) ||
#ifdef  COMPRESS_ON_WIRE
                            (Scb->Header.FileObjectC != NULL)
#else
                            FALSE
#endif

                            ) &&

                           !FlagOn(Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

                    NtfsDeleteInternalAttributeStream( Scb, (BOOLEAN) (Scb->Fcb->LinkCount == 0), FALSE );

                    //
                    //  If the close count went to zero then remove the Scb.
                    //

                    if (Scb->CloseCount == 0) {

                        NtfsDeleteScb( IrpContext, &Scb );
                        ScbRemoved = TRUE;
                    }
                }
            }
        }
    }

    DebugTrace( -1, Dbg, ("NtfsRemoveScb:  Exit  ->  %04x\n", ScbRemoved) );

    return ScbRemoved;
}


//
//  Local support routine
//

BOOLEAN
NtfsPrepareFcbForRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB StartingScb OPTIONAL,
    IN BOOLEAN CheckForAttributeTable
    )

/*++

Routine Description:

    This routine will attempt to prepare the Fcb for removal from the Fcb/Scb
    tree.  It will try to remove all of the Scb's and test finally if
    all of the close count has gone to zero.  NOTE the close count is incremented
    by routines to reference this Fcb to keep it from being torn down.  An empty
    Scb list isn't enough to insure that the Fcb can be removed.

Arguments:

    Fcb - This is the Fcb to remove.

    StartingScb - This is the Scb to remove first.

    CheckForAttributeTable - Indicates that we should not teardown an
        Scb which is in the attribute table.  Instead we will attempt
        to put an entry on the async close queue.  This will be TRUE
        if we may need the Scb to abort the current transaction.

Return Value:

    BOOLEAN - TRUE if the Fcb can be removed, FALSE otherwise.

--*/

{
    PSCB Scb;

    PAGED_CODE();

    //
    //  Try to remove each Scb in the Fcb queue.
    //

    while (TRUE) {

        if (IsListEmpty( &Fcb->ScbQueue )) {

            if (Fcb->CloseCount == 0) {

                return TRUE;

            } else {

                return FALSE;
            }
        }

        if (ARGUMENT_PRESENT( StartingScb )) {

            Scb = StartingScb;
            StartingScb = NULL;

        } else {

            Scb = CONTAINING_RECORD( Fcb->ScbQueue.Flink,
                                     SCB,
                                     FcbLinks );
        }

        //
        //  Another thread along the create path could be active on
        //  one of these Scbs. If we try to remove the Attribute List Scb and
        //  somebody else has an index pinned, we'll wait on an VacbActiveCount
        //  forever. So, we want to skip the AttributeList Scb,
        //  unless it's the only Scb around. (This'll get cleaned up, eventually).
        //

        if ((Scb->AttributeTypeCode == $ATTRIBUTE_LIST) &&
            (Fcb->ScbQueue.Flink != Fcb->ScbQueue.Blink)) {

            RemoveEntryList( &Scb->FcbLinks );
            InsertTailList( &Fcb->ScbQueue, &Scb->FcbLinks );
            continue;
        }

        //
        //  Try to remove this Scb.  If the call to remove didn't succeed
        //  but the close count has gone to zero, it means that a recursive
        //  close was generated which removed a stream file.  In that
        //  case we can delete the Scb now.
        //

        if (!NtfsRemoveScb( IrpContext, Scb, CheckForAttributeTable )) {

            //
            //  Return FALSE to indicate the Fcb can't go away.
            //

            return FALSE;
        }
    }
}


//
//  Local support routine
//

VOID
NtfsTeardownFromLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB StartingFcb,
    IN PLCB StartingLcb,
    IN BOOLEAN CheckForAttributeTable,
    IN ULONG AcquireFlags,
    OUT PBOOLEAN RemovedStartingLcb,
    OUT PBOOLEAN RemovedStartingFcb
    )

/*++

Routine Description:

    This routine is called to remove a link and continue moving up the
    tree looking for more elements to remove.  We will check that the
    link is unreferenced.  NOTE this Lcb must point up to a directory
    so that other than our starting Lcb no Lcb we encounter will
    have multiple parents.

Arguments:

    Vcb - Vcb for this volume.

    StartingFcb - This is the Fcb whose link we are trying to remove.

    StartingLcb - This is the Lcb to walk up through.  Note that
        this may be a bogus pointer.  It is only valid if there
        is at least one Fcb in the queue.

    CheckForAttributeTable - Indicates that we should not teardown an
        Scb which is in the attribute table.  Instead we will attempt
        to put an entry on the async close queue.  This will be TRUE
        if we may need the Scb to abort the current transaction.

    AcquireFlags - Indicates whether we should abort the teardown when
        we can't acquire a parent.  When called from some path where we may
        hold the MftScb or another resource in another path up the tree.

    RemovedStartingLcb - Address to store TRUE if we remove the
        starting Lcb.

    RemovedStartingFcb - Address to store TRUE if we remove the
        starting Fcb.

Return Value:

    None

--*/

{
    PSCB ParentScb;
    BOOLEAN AcquiredParentScb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;
    BOOLEAN UpdateStandardInfo;
    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN StandardInfoUpdateAllowed = FALSE;
    BOOLEAN AcquiredParentExclusive;
    BOOLEAN EmptyParentQueue;

    PLCB Lcb;
    PFCB Fcb = StartingFcb;

    PAGED_CODE();

    //
    //  Use a try-finally to free any resources held.
    //

    try {

        if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
            (IrpContext->TopLevelIrpContext->ExceptionStatus == STATUS_SUCCESS)) {

            StandardInfoUpdateAllowed = TRUE;
        }

        while (TRUE) {

            ParentScb = NULL;
            EmptyParentQueue = FALSE;

            //
            //  Check if we need to update the standard information for this file.
            //

            if (StandardInfoUpdateAllowed &&
                !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED | FCB_STATE_SYSTEM_FILE )) {

                UpdateStandardInfo = TRUE;

            } else {

                UpdateStandardInfo = FALSE;
            }

            //
            //  Look through all of the Lcb's for this Fcb.
            //

            while (!IsListEmpty( &Fcb->LcbQueue )) {

                if (Fcb == StartingFcb) {

                    Lcb = StartingLcb;

                } else {

                    Lcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                             LCB,
                                             FcbLinks );
                }

                //
                //  Get out if not the last handle on this Lcb.
                //

                if (Lcb->CleanupCount != 0) {

                    leave;
                }

                //
                //  Acquire the parent if not already acquired.
                //

                if (ParentScb == NULL) {

                    ParentScb = Lcb->Scb;

                    //
                    //  Do an unsafe test to see if we want the parent
                    //  shared or exclusive.  We want it exclusive
                    //  if we will be walking up the tree because we are at the last Lcb.
                    //

                    if (ParentScb->ScbType.Index.LcbQueue.Flink == ParentScb->ScbType.Index.LcbQueue.Blink) {

                        if (!NtfsAcquireExclusiveFcb( IrpContext,
                                                      ParentScb->Fcb,
                                                      ParentScb,
                                                      ACQUIRE_NO_DELETE_CHECK | AcquireFlags )) {

                            leave;
                        }

                        if (FlagOn( ParentScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                            NtfsSnapshotScb( IrpContext, ParentScb );
                        }

                        AcquiredParentExclusive = TRUE;

                    } else {

                        //
                        //  Try to acquire the parent but check whether we
                        //  should wait.
                        //

                        if (!NtfsAcquireSharedFcbCheckWait( IrpContext,
                                                            ParentScb->Fcb,
                                                            AcquireFlags )) {

                            leave;
                        }

                        AcquiredParentExclusive = FALSE;
                    }

                    AcquiredParentScb = TRUE;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                } else {

                    //
                    //  We better be looking at another Lcb to the same parent.
                    //

                    ASSERT( ParentScb == Lcb->Scb );
#endif
                }

                //
                //  Check if we collide with a create moving down the tree.
                //

                if (Lcb->ReferenceCount != 0) {

                    leave;
                }

                //
                //  Now remove the Lcb.  Remember if this is our original
                //  Lcb.
                //

                if (Lcb == StartingLcb) {

                    *RemovedStartingLcb = TRUE;
                }

                //
                //  We may only have the parent shared at this point.  We need
                //  to serialize using the parent shared plus the fast
                //  mutex to remove the Lcb.  We could test whether we need
                //  to do this but hopefully the typical case is that we
                //  have it shared and it won't be very expensive to acquire
                //  it exclusively at this point.
                //

                NtfsAcquireFsrtlHeader( ParentScb );
                NtfsDeleteLcb( IrpContext, &Lcb );

                //
                //  Remember if the parent Lcb queue is now empty.
                //

                if (IsListEmpty( &ParentScb->ScbType.Index.LcbQueue )) {

                    EmptyParentQueue = TRUE;
                }

                NtfsReleaseFsrtlHeader( ParentScb );

                //
                //  If this is the first Fcb then exit the loop.
                //

                if (Fcb == StartingFcb) {

                    break;
                }
            }

            //
            //  If we get here it means we removed all of the Lcb's we
            //  could for the current Fcb.  If the list is empty we
            //  can remove the Fcb itself.
            //

            if (IsListEmpty( &Fcb->LcbQueue )) {

                //
                //  If this is a directory that was opened by Id it is
                //  possible that we still have an update to perform
                //  for the duplicate information and possibly for
                //  standard information.
                //

                if (UpdateStandardInfo &&
                    (FlagOn( Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS ) ||
                     FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO ))) {

                    //
                    //  Use a try-except, we ignore errors here.
                    //

                    try {

                        NtfsUpdateStandardInformation( IrpContext, Fcb );
                        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                        NtfsCheckpointCurrentTransaction( IrpContext );

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        NtfsMinimumExceptionProcessing( IrpContext );
                    }
                }

                //
                //  Our worst nightmare has come true.  We had to create an Scb
                //  and a stream in order to write out the duplicate information.
                //  This will happen if we have a non-resident attribute list.
                //

                if (!IsListEmpty( &Fcb->ScbQueue)) {

                    //
                    //  Dereference any file object and delete the Scb if possible.
                    //

                    NtfsRemoveScb( IrpContext,
                                    CONTAINING_RECORD( Fcb->ScbQueue.Flink,
                                                       SCB,
                                                       FcbLinks ),
                                   FALSE );
                }

                //
                //  If the list is now empty then check the reference count.
                //

                if (IsListEmpty( &Fcb->ScbQueue)) {

                    //
                    //  Now we are ready to remove the current Fcb.  We need to
                    //  do a final check of the reference count to make sure
                    //  it isn't being referenced in an open somewhere.
                    //

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;

                    if (Fcb->ReferenceCount == 0) {

                        if (Fcb == StartingFcb) {

                            *RemovedStartingFcb = TRUE;
                        }

                        NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );
                        AcquiredFcb = FALSE;

                    } else {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        AcquiredFcbTable = FALSE;
                    }
                }
            }

            //
            //  Move to the Fcb for the ParentScb.  Break out if no parent
            //  or there are no more entries on the parent.
            //

            if ((ParentScb == NULL) || !EmptyParentQueue) {

                leave;
            }

            //
            //  If we have a parent Scb then we might have it
            //  either shared or exclusive.  We can now do
            //  a thorough test to see if we need it exclusive.
            //

            if (!AcquiredParentExclusive) {

                //
                //  We need to acquire the Fcb table, reference the
                //  parent, drop the parent and reacquire exclusively.
                //

                NtfsAcquireFcbTable( IrpContext, Vcb );
                ParentScb->Fcb->ReferenceCount += 1;
                NtfsReleaseFcbTable( IrpContext, Vcb );
                NtfsReleaseFcb( IrpContext, ParentScb->Fcb );

                if (!NtfsAcquireExclusiveFcb( IrpContext,
                                              ParentScb->Fcb,
                                              ParentScb,
                                              ACQUIRE_NO_DELETE_CHECK | AcquireFlags )) {

                    //
                    //  We couldn't get the parent.  No problem, someone
                    //  else will do any necessary teardown.
                    //

                    AcquiredParentScb = FALSE;

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    ParentScb->Fcb->ReferenceCount -= 1;
                    NtfsReleaseFcbTable( IrpContext, Vcb );

                    leave;

                } else {

                    if (FlagOn( ParentScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                        NtfsSnapshotScb( IrpContext, ParentScb );
                    }

                    AcquiredParentExclusive = TRUE;
                }

                //
                //  Now decrement the parent reference.
                //

                NtfsAcquireFcbTable( IrpContext, Vcb );
                ParentScb->Fcb->ReferenceCount -= 1;
                NtfsReleaseFcbTable( IrpContext, Vcb );
            }

            Fcb = ParentScb->Fcb;
            AcquiredFcb = TRUE;
            AcquiredParentScb = FALSE;

            //
            //  Check if this Fcb can be removed.
            //

            if (!NtfsPrepareFcbForRemoval( IrpContext, Fcb, NULL, CheckForAttributeTable )) {

                leave;
            }
        }

    } finally {

        DebugUnwind( NtfsTeardownFromLcb );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        if (AcquiredFcb) {

            NtfsReleaseFcb( IrpContext, Fcb );
        }

        if (AcquiredParentScb) {

            NtfsReleaseScb( IrpContext, ParentScb );
        }
    }

    return;
}


//
//  Local support routine
//

RTL_GENERIC_COMPARE_RESULTS
NtfsFcbTableCompare (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )

/*++

Routine Description:

    This is a generic table support routine to compare two fcb table elements

Arguments:

    FcbTable - Supplies the generic table being queried

    FirstStruct - Supplies the first fcb table element to compare

    SecondStruct - Supplies the second fcb table element to compare

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/

{
    FILE_REFERENCE FirstRef = *((PFILE_REFERENCE) FirstStruct);
    FILE_REFERENCE SecondRef = *((PFILE_REFERENCE) SecondStruct);

    PAGED_CODE();

    //
    //  Use also the sequence number for all compares so file references in the
    //  fcb table are unique over time and space.  If we want to ignore sequence
    //  numbers we can zero out the sequence number field, but then we will also
    //  need to delete the Fcbs from the table during cleanup and not when the
    //  fcb really gets deleted.  Otherwise we cannot reuse file records.
    //

    if (NtfsFullSegmentNumber( &FirstRef ) < NtfsFullSegmentNumber( &SecondRef )) {

        return GenericLessThan;

    } else if (NtfsFullSegmentNumber( &FirstRef ) > NtfsFullSegmentNumber( &SecondRef )) {

        return GenericGreaterThan;

    } else {

        //
        //  SequenceNumber comparison now
        //

        if (FirstRef.SequenceNumber < SecondRef.SequenceNumber) {
            return GenericLessThan;
        } else if (FirstRef.SequenceNumber > SecondRef.SequenceNumber) {
            return GenericGreaterThan;
        } else {
            return GenericEqual;
        }

    }

    UNREFERENCED_PARAMETER( FcbTable );
}


//
//  Local support routine
//

VOID
NtfsReserveCcbNamesInLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PULONG ParentNameLength OPTIONAL,
    IN ULONG LastComponentNameLength
    )

/*++

Routine Description:

    This routine walks through a list of Ccbs and grows the name buffer as
    necessary.

Arguments:

    Lcb - Lcb with links of Ccbs to check.

    ParentNameLength - If specified then this is the full length of the new name
        to the parent directory.  Otherwise we use the existing parent name in
        each Ccb.  The separator is implied.

    LastComponentNameLength - Number of bytes needed for the last component of the name.

Return Value:

    None - This routine will raise on an allocation failure.

--*/

{
    PCCB Ccb;
    PVOID NewAllocation;
    ULONG BytesNeeded;

    PAGED_CODE();

    //
    //  Now for every ccb attached to us we need to check if we need a new
    //  filename buffer.  Protect the Ccb with the Fcb mutex to serialize access to
    //  the flags field with close.
    //

    Ccb = NULL;
    while ((Ccb = NtfsGetNextCcb( Lcb, Ccb )) != NULL) {

        //
        //  If the Ccb last component length is zero, this Ccb is for a
        //  file object that was opened by File Id.  We won't to  any
        //  work for the name in the fileobject for this.  Otherwise we
        //  compute the length of the new name and see if we have enough space
        //  The CLOSE flag indicates whether this had gone through the close path or not.
        //  We use the LockFcb command above to serialize with the setting of the close
        //  flag.
        //

        NtfsLockFcb( IrpContext, Ccb->Lcb->Fcb );

        if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID | CCB_FLAG_CLOSE )) {

            if (ARGUMENT_PRESENT( ParentNameLength )) {

                BytesNeeded = *ParentNameLength + LastComponentNameLength;

            } else {

                BytesNeeded = Ccb->LastFileNameOffset + LastComponentNameLength;
            }

            if (Ccb->FullFileName.MaximumLength < BytesNeeded) {

                //
                //  Allocate a new file name buffer and copy the existing data back into it.
                //

                NewAllocation = NtfsAllocatePoolNoRaise( PagedPool, BytesNeeded );

                if (NewAllocation == NULL) {

                    NtfsUnlockFcb( IrpContext, Ccb->Lcb->Fcb );
                    NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
                }

                RtlCopyMemory( NewAllocation,
                               Ccb->FullFileName.Buffer,
                               Ccb->FullFileName.Length );

                if (FlagOn( Ccb->Flags, CCB_FLAG_ALLOCATED_FILE_NAME )) {

                    NtfsFreePool( Ccb->FullFileName.Buffer );
                }

                Ccb->FullFileName.Buffer = NewAllocation;
                Ccb->FullFileName.MaximumLength = (USHORT) BytesNeeded;

                SetFlag( Ccb->Flags, CCB_FLAG_ALLOCATED_FILE_NAME );
            }
        }

        NtfsUnlockFcb( IrpContext, Ccb->Lcb->Fcb );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsClearRecursiveLcb (
    IN PLCB Lcb
    )

/*++

Routine Description:

    This routine is called to clear all of the normalized names, prefix entries and hash entries in
    a subtree starting from a given Lcb.  Typically this is used as part of a rename when a parent rename
    affects the full name of all of the children.

Arguments:

    Lcb - Lcb which is root of rename.

Return Value:

    None - This routine will raise on an allocation failure.

--*/

{
    PSCB ChildScb;
    PSCB NextScb;
    PLCB NextLcb;

    PAGED_CODE();

    //
    //  Clear the index offset pointer so we will look this up again.
    //

    Lcb->QuickIndex.BufferOffset = 0;

    //
    //  Get rid of any prefixes that might still be attached to us
    //

    ASSERT( NtfsIsExclusiveScb( Lcb->Scb ) );
    NtfsRemovePrefix( Lcb );

    //
    //  Remove any hash table entries for this Lcb.
    //

    NtfsRemoveHashEntriesForLcb( Lcb );

    //
    //  And then traverse the graph underneath our fcb and remove all prefixes
    //  also used there.  For each child scb under the fcb we will traverse all of
    //  its descendant Scb children and for each lcb we encounter we will remove its prefixes.
    //

    ChildScb = NULL;
    while ((ChildScb = NtfsGetNextChildScb( Lcb->Fcb, ChildScb )) != NULL) {

        //
        //  Now we have to descend into this Scb subtree, if it exists.
        //  Then remove the prefix entries on all of the links found.
        //  Do this as a do-while so we can use common code to handle the top-level
        //  Scb as well.
        //

        NextScb = ChildScb;
        do {

            //
            //  Walk through the Lcbs of any index Scb and remove the prefix and
            //  hash entries.
            //

            if (SafeNodeType( NextScb ) == NTFS_NTC_SCB_INDEX) {

                //
                //  We better have the Vcb exclusive to descend down the tree.
                //

                ASSERT( NtfsIsExclusiveVcb( Lcb->Fcb->Vcb ));

                NextLcb = NULL;
                while ((NextLcb = NtfsGetNextChildLcb( NextScb, NextLcb )) != NULL) {

                    //
                    //  Remove any hash table and prefix entries for this Lcb.
                    //  We can be unsynchronized here because we own the Vcb
                    //  exclusive and there are no open handles on either of these.
                    //

                    NtfsRemovePrefix( NextLcb );
                    NtfsRemoveHashEntriesForLcb( NextLcb );
                }

                //
                //  If this is an index Scb with a normalized name, then free
                //  the normalized name.
                //

                if ((NextScb != ChildScb) &&
                    (NextScb->ScbType.Index.NormalizedName.Buffer != NULL)) {

                    NtfsDeleteNormalizedName( NextScb );
                }
            }

        } while ((NextScb = NtfsGetNextScb( NextScb, ChildScb )) != NULL);
    }

    return;
}


PDEALLOCATED_CLUSTERS
NtfsGetDeallocatedClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )
/*++

Routine Description:

    Add an entry if possible and neccessary to recently deallocated list and return the head of the list.
    If there isn't enough memory this routine just returns the old head
    We determine whether to add the entry based on the threshold for the mapping size

Arguments:

    Vcb -  Vcb to add entry to

Return Value:

    The new head of the list

--*/

{
    PDEALLOCATED_CLUSTERS CurrentClusters;
    PDEALLOCATED_CLUSTERS NewClusters;

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    CurrentClusters = (PDEALLOCATED_CLUSTERS) Vcb->DeallocatedClusterListHead.Flink;

    if (FsRtlNumberOfRunsInLargeMcb( &CurrentClusters->Mcb ) > NTFS_DEALLOCATED_MCB_LIMIT) {

        //
        //  Find a new deallocated cluster. Use the preallocated ones if they
        //  are not in use. If we fail to allocate memory continue to use the old one
        //

        if (Vcb->DeallocatedClusters1.Link.Flink == NULL) {

            NewClusters = &Vcb->DeallocatedClusters1;
            NewClusters->Lsn.QuadPart = 0;

        } else  if (Vcb->DeallocatedClusters2.Link.Flink == NULL) {

            NewClusters = &Vcb->DeallocatedClusters2;
            NewClusters->Lsn.QuadPart = 0;

        } else {

            NewClusters = NtfsAllocatePoolNoRaise( PagedPool, sizeof( DEALLOCATED_CLUSTERS ) );
            if (NewClusters != NULL) {
                RtlZeroMemory( NewClusters, sizeof( DEALLOCATED_CLUSTERS ) );
                FsRtlInitializeLargeMcb( &NewClusters->Mcb, PagedPool );
            }
        }

        if (NewClusters != NULL) {
            ASSERT( NewClusters->ClusterCount == 0 );

            CurrentClusters->Lsn = LfsQueryLastLsn( Vcb->LogHandle );
            InsertHeadList( &Vcb->DeallocatedClusterListHead, &NewClusters->Link );
            CurrentClusters = NewClusters;
        }
    }

    return CurrentClusters;
}


#ifdef SYSCACHE_DEBUG

#define ENTRIES_PER_PAGE (PAGE_SIZE / sizeof( ON_DISK_SYSCACHE_LOG ))

ULONG
FsRtlLogSyscacheEvent (
    IN PSCB Scb,
    IN ULONG Event,
    IN ULONG Flags,
    IN LONGLONG Start,
    IN LONGLONG Range,
    IN LONGLONG Result
    )

/*++

Routine Description:

    Logging routine for syscache tracking

Arguments:

    Scb -  Scb being tracked

    Event - SCE Event being record

    Flags -Flag for the event

    Start - starting offset

    Range - range of the action

    Result - result

Return Value:

    Sequence number for this log entry

--*/

{
    LONG TempEntry;
#ifdef SYSCACHE_DEBUG_ON_DISK
    LONG TempDiskEntry;
    LONGLONG Offset;
    PON_DISK_SYSCACHE_LOG Entry;
    PBCB Bcb;
#endif

    TempEntry = InterlockedIncrement( &(Scb->CurrentSyscacheLogEntry) );
    TempEntry = TempEntry % Scb->SyscacheLogEntryCount;
    Scb->SyscacheLog[TempEntry].Event = Event;
    Scb->SyscacheLog[TempEntry].Flags = Flags;
    Scb->SyscacheLog[TempEntry].Start = Start;
    Scb->SyscacheLog[TempEntry].Range = Range;
    Scb->SyscacheLog[TempEntry].Result = Result;

#ifdef SYSCACHE_DEBUG_ON_DISK

    if ((Scb->Vcb->SyscacheScb != NULL) &&
        (Scb->Vcb->SyscacheScb->Header.FileSize.QuadPart > 0 )) {

        TempDiskEntry = InterlockedIncrement( &NtfsCurrentSyscacheOnDiskEntry );
        Offset = (((TempDiskEntry / ENTRIES_PER_PAGE) * PAGE_SIZE) +
                  ((TempDiskEntry % ENTRIES_PER_PAGE) * sizeof( ON_DISK_SYSCACHE_LOG )));

        Offset = Offset % Scb->Vcb->SyscacheScb->Header.FileSize.QuadPart;

        try {

            CcPreparePinWrite( Scb->Vcb->SyscacheScb->FileObject,
                               (PLARGE_INTEGER)&Offset,
                               sizeof( ON_DISK_SYSCACHE_LOG ),
                               FALSE,
                               TRUE,
                               &Bcb,
                               &Entry );

            Entry->SegmentNumberUnsafe = Scb->Fcb->FileReference.SegmentNumberLowPart;
            Entry->Event = Event;
            Entry->Flags = Flags;
            Entry->Start = Start;
            Entry->Range = Range;
            Entry->Result = Result;

            CcUnpinData( Bcb );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            ASSERT( FALSE );
        }
    }
#endif

    return TempEntry;
}


VOID
FsRtlUpdateSyscacheEvent (
    IN PSCB Scb,
    IN ULONG EntryNumber,
    IN LONGLONG Result,
    IN ULONG NewFlag
    )

/*++

Routine Description:

    Logging routine for syscache tracking - updates a prev. written record

Arguments:

    Scb -

    EntryNumber -

    Result -

    NewFlag -


Return Value:

    none

--*/

{
    Scb->SyscacheLog[EntryNumber].Flags |= NewFlag;
    Scb->SyscacheLog[EntryNumber].Result = Result;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\workque.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    WorkQue.c

Abstract:

    This module implements the Work queue routines for the Ntfs File
    system.

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (2)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsOplockComplete)
#endif

VOID
NtfsAddToWorkqueInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL,
    IN BOOLEAN CanBlock
    );


VOID
NtfsOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the oplock package when an oplock break has
    completed, allowing an Irp to resume execution.  If the status in
    the Irp is STATUS_SUCCESS, then we either queue the Irp to the Fsp queue or
    signal an event depending on whether the caller handles oplock completions synchronously.
    Otherwise we complete the Irp with the status in the Irp.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    NTSTATUS Status = Irp->IoStatus.Status;
    PIRP_CONTEXT IrpContext = (PIRP_CONTEXT) Context;
    PKEVENT Event = NULL;
    
    PAGED_CODE();

    //
    //  Check for an event that we should to signal synchronous completion
    //  This exists in 2 cases
    //  
    //  1) Non-fsp creates (fsp creates don't have a completion context which is
    //     how we distinguish them
    //  
    //  2) Successful Non fsp read/writes (These indicate the NTFS_IO_CONTEXT_INLINE_OPLOCK 
    //     flag in their NtfsIoContext
    // 
    
    if (IrpContext->MajorFunction == IRP_MJ_CREATE) {
     
        if ((IrpContext->Union.OplockCleanup != NULL) &&
            (IrpContext->Union.OplockCleanup->CompletionContext != NULL)) {

            Event = &IrpContext->Union.OplockCleanup->CompletionContext->Event;

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT ) );    
        }

    } else if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
               (IrpContext->Union.NtfsIoContext != NULL) &&
               FlagOn( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_INLINE_OPLOCK )) {

        Event = &IrpContext->Union.NtfsIoContext->Wait.SyncEvent;

        //
        //  Set the irp to not delete itself or the ntfsiocontext when we clean it up
        //  

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );

    }

    //
    //  If we have a completion event then we want to  clean up the IrpContext
    //  and then signal the event 
    //

    if (Event) {

        NtfsCompleteRequest( IrpContext, NULL, Status );
        KeSetEvent( Event, 0, FALSE );
        ASSERT( Status != STATUS_PENDING && Status != STATUS_REPARSE );


    } else if (Status == STATUS_SUCCESS) {

        //
        //  Insert the Irp context in the workqueue to retry on a regular
        //  successfull oplock break
        //

        NtfsAddToWorkqueInternal( IrpContext, Irp, FALSE );

    } else {

        //
        //  Otherwise complete the Irp and cleanup the IrpContext.
        //

        ASSERT( Status != STATUS_PENDING && Status != STATUS_REPARSE );
        NtfsCompleteRequest( IrpContext, Irp, Status );
    }

    return;
}



VOID
NtfsPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet (or FileObject in special close path)

Return Value:

    None.

--*/

{
    NtfsPrePostIrpInternal( Context, Irp, TRUE, FALSE );
}


VOID
NtfsWriteOplockPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called  by the oplock package
    for write irps. We will decide whether to save the toplevelcontext based
    on whether the oplock is being handled inline or not

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet (or FileObject in special close path)

Return Value:

    None.

--*/

{
    PIRP_CONTEXT IrpContext = (PIRP_CONTEXT)Context;
    BOOLEAN Inline = BooleanFlagOn( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_INLINE_OPLOCK );

    //
    //  Cleanup the iocontext before posting an oplock - so if its on the stack
    //  we don't attempt to reference it during oplock completion
    // 

    if (!Inline) {

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT )) {
            ExFreeToNPagedLookasideList( &NtfsIoContextLookasideList, IrpContext->Union.NtfsIoContext );
        }

        IrpContext->Union.NtfsIoContext = NULL;
    }

    NtfsPrePostIrpInternal( Context, Irp, TRUE, Inline );
}




VOID
NtfsPrePostIrpInternal (
    IN PVOID Context,
    IN PIRP Irp OPTIONAL,
    IN BOOLEAN PendIrp,
    IN BOOLEAN SaveContext
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet (or FileObject in special close path)
    
    PendIrp - if true mark the irp pending as well
    
    SaveContext - if true don't restore top level context even if its owned
        The caller will be waiting on the posted irp inline and continuing processing

Return Value:

    None.

--*/

{
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp = NULL;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    PUSN_FCB ThisUsn, LastUsn;
#endif

    IrpContext = (PIRP_CONTEXT) Context;

    //
    //  Make this is a valid allocated IrpContext. It's ok for
    //  this to be allocated on the caller's stack as long as the
    //  caller's not doing this operation asynchronously.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT((FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL )) ||
           (IrpContext->NodeTypeCode == NTFS_NTC_IRP_CONTEXT));

    //
    //  Make sure if we are posting the request, which may be
    //  because of log file full, that we free any Fcbs or PagingIo
    //  resources which were acquired.
    //

    //
    //  Just in case we somehow get here with a transaction ID, clear
    //  it here so we do not loop forever.
    //

    if (IrpContext->TransactionId != 0) {

        NtfsCleanupFailedTransaction( IrpContext );
    }

    //
    //  Cleanup all of the fields of the IrpContext.
    //  Restore the thread context pointer if associated with this IrpContext.
    //

    if (!SaveContext && FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL )) {

        NtfsRestoreTopLevelIrp();
        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );
    }

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
    NtfsCleanupIrpContext( IrpContext, FALSE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    //
    //  If we are aborting a transaction, then it is important to clear out the
    //  Usn reasons, so we do not try to write a Usn Journal record for
    //  somthing that did not happen!  Worse yet if we get a log file full
    //  we fail the abort, which is not allowed.
    //
    //  First, reset the bits in the Fcb, so we will not fail to allow posting
    //  and writing these bits later.  Note that all the reversible changes are
    //  done with the Fcb exclusive, and they are actually backed out anyway.
    //  All the nonreversible ones (only unnamed and named data overwrite) are
    //  forced out first anyway before the data is actually modified.
    //

    ThisUsn = &IrpContext->Usn;

    do {

        ASSERT( !FlagOn( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_REASON ));

        if (ThisUsn->NextUsnFcb == NULL) { break; }

        LastUsn = ThisUsn;
        ThisUsn = ThisUsn->NextUsnFcb;

    } while (TRUE);
#endif

    IrpContext->OriginatingIrp = Irp;

    //
    //  Note that close.c uses a trick where the "Irp" is really
    //  a file object.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        if (Irp->Type == IO_TYPE_IRP) {

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  We need to lock the user's buffer, unless this is an MDL-read,
            //  in which case there is no user buffer.
            //
            //  **** we need a better test than non-MDL (read or write)!

            if ((IrpContext->MajorFunction == IRP_MJ_READ) || 
                (IrpContext->MajorFunction == IRP_MJ_WRITE)) {

                ClearFlag( IrpContext->MinorFunction, IRP_MN_DPC );

                //
                //  Lock the user's buffer if this is not an Mdl request.
                //

                if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

                    NtfsLockUserBuffer( IrpContext,
                                        Irp,
                                        (IrpContext->MajorFunction == IRP_MJ_READ) ?
                                        IoWriteAccess : IoReadAccess,
                                        IrpSp->Parameters.Write.Length );
                }

            //
            //  We also need to check whether this is a query directory operation.
            //

            } else if (IrpContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL
                       && IrpContext->MinorFunction == IRP_MN_QUERY_DIRECTORY) {

                NtfsLockUserBuffer( IrpContext,
                                    Irp,
                                    IoWriteAccess,
                                    IrpSp->Parameters.QueryDirectory.Length );

            //
            //  These two FSCTLs use neither I/O, so check for them.
            //

            } else if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                       (IrpContext->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                       ((IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_READ_USN_JOURNAL) ||
                        (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_GET_RETRIEVAL_POINTERS))) {

                NtfsLockUserBuffer( IrpContext,
                                    Irp,
                                    IoWriteAccess,
                                    IrpSp->Parameters.FileSystemControl.OutputBufferLength );
            }

            //
            //  Mark that we've already returned pending to the user
            //

            if (PendIrp) {
                IoMarkIrpPending( Irp );
            }
            
        }
    }

    return;
}


NTSTATUS
NtfsPostRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine enqueues the request packet specified by IrpContext to the
    work queue associated with the FileSystemDeviceObject.  This is a FSD
    routine.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet (or FileObject in special close path)

Return Value:

    STATUS_PENDING


--*/

{
    //
    //  Before posting, free any Scb snapshots.  Note that if someone
    //  is calling this routine directly to post, then he better not
    //  have changed any disk structures, and thus we should have no
    //  work to do.  On the other hand, if someone raised a status
    //  (like STATUS_CANT_WAIT), then we do both a transaction abort
    //  and restore of these Scb values.
    //

    NtfsPrePostIrp( IrpContext, Irp );

    NtfsAddToWorkque( IrpContext, Irp );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}



VOID
NtfsCancelOverflowRequest (
    IN PDEVICE_OBJECT Device,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine may be called by the I/O system to cancel an outstanding
    Irp in the overflow queue. If its an irp that must be processed we  move the irp to the
    top of the queue o.w we cancel it direclty. The dequeuing code guarantees the cancel routine is removed before
    the irpcontext is dequeued.  It also won't dequeue an irp that is marked with a 1 in the info
    field. Note we are guarranteed by io subsys that
    the irp will remain for the lifetime of this call even after we drop the spinlock

Arguments:

    DeviceObject - DeviceObject from I/O system

    Irp - Supplies the pointer to the Irp being canceled.

Return Value:

    None

--*/

{
    PIRP_CONTEXT IrpContext;
    PVOLUME_DEVICE_OBJECT Vdo;
    KIRQL SavedIrql;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN Cancel;

    IrpContext = (PIRP_CONTEXT)Irp->IoStatus.Information;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    Cancel = (IrpContext->MajorFunction != IRP_MJ_CLEANUP) && 
             (IrpContext->MajorFunction != IRP_MJ_CLOSE);

    ASSERT( Cancel );
                         
    ASSERT( IrpContext->NodeTypeCode == NTFS_NTC_IRP_CONTEXT );

    Vdo = CONTAINING_RECORD( Device,
                             VOLUME_DEVICE_OBJECT,
                             DeviceObject );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Gain the critical workqueue spinlock and
    //  either cancel it or move it to the head of the list
    //  Note the workqueue code always tests the cancel first before working which
    //  is what synchronizes this
    //                        
    
    ExAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );
    RemoveEntryList( &IrpContext->WorkQueueItem.List );

    //
    //  Reset the shared fields
    //  

    InitializeListHead( &IrpContext->RecentlyDeallocatedQueue );
    InitializeListHead( &IrpContext->ExclusiveFcbList );

    if (!Cancel) {

        RtlZeroMemory( &IrpContext->WorkQueueItem, sizeof( WORK_QUEUE_ITEM ));

        InsertHeadList( &Vdo->OverflowQueue, &IrpContext->WorkQueueItem.List );
        Irp->Cancel = 0;
    } else {
        Vdo->OverflowQueueCount -= 1;
    }

    ExReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

    if (Cancel) {

        if (Vdo->OverflowQueueCount < OVERFLOW_QUEUE_LIMIT) {
            KeSetEvent( &Vdo->OverflowQueueEvent, IO_NO_INCREMENT, FALSE );
        }
        NtfsCompleteRequest( IrpContext, Irp, STATUS_CANCELLED );
    }
}


VOID
NtfsAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL
    )
{

    NtfsAddToWorkqueInternal( IrpContext, Irp, TRUE );
}



//
//  Local support routine.
//

VOID
NtfsAddToWorkqueInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL,
    IN BOOLEAN CanBlock
    )

/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL Irql;

    Irql = KeGetCurrentIrql();


    if (ARGUMENT_PRESENT( Irp )) {

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Check if this request has an associated file object, and thus volume
        //  device object.
        //

        if ( IrpSp->FileObject != NULL ) {

            KIRQL SavedIrql;
            PVOLUME_DEVICE_OBJECT Vdo;

            Vdo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                     VOLUME_DEVICE_OBJECT,
                                     DeviceObject );

            //
            //  Check to see if this request should be sent to the overflow
            //  queue.  If not, then send it off to an exworker thread. Block here
            //  for non deferred write threads when the overflow queue is full and
            //  we're not in a dpc (hotfix from async completion routine)
            //

            if ((Vdo->OverflowQueueCount >= OVERFLOW_QUEUE_LIMIT) &&
                CanBlock &&
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE ) &&
                (Irql < DISPATCH_LEVEL)) {
                
                KeWaitForSingleObject( &Vdo->OverflowQueueEvent, Executive, KernelMode, FALSE, NULL );                    
            }

            ExAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );

            if ( Vdo->PostedRequestCount > FSP_PER_DEVICE_THRESHOLD) {

                //
                //  We cannot currently respond to this IRP so we'll just enqueue it
                //  to the overflow queue on the volume.
                //

                
                if (NtfsSetCancelRoutine( Irp, NtfsCancelOverflowRequest, (ULONG_PTR)IrpContext, TRUE )) {

                    if (Status == STATUS_SUCCESS) {

                        ASSERT( IsListEmpty( &IrpContext->ExclusiveFcbList ) );
                        ASSERT( IsListEmpty( &IrpContext->RecentlyDeallocatedQueue ) );
                        RtlZeroMemory( &IrpContext->WorkQueueItem, sizeof( WORK_QUEUE_ITEM ));


                        InsertTailList( &Vdo->OverflowQueue, &IrpContext->WorkQueueItem.List );
                        Vdo->OverflowQueueCount += 1;
                    }
                     
                } else {
                    
                    Status = STATUS_CANCELLED;
                }
                
                ExReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

                if (Status != STATUS_SUCCESS) {

                    if (Vdo->OverflowQueueCount < OVERFLOW_QUEUE_LIMIT) {
                        KeSetEvent( &Vdo->OverflowQueueEvent, IO_NO_INCREMENT, FALSE );
                    }
                    NtfsCompleteRequest( IrpContext, Irp, Status );
                }

                return;

            } else {

                //
                //  We are going to send this Irp to an ex worker thread so up
                //  the count.
                //

                if (Vdo->OverflowQueueCount < OVERFLOW_QUEUE_LIMIT) {
                    KeSetEvent( &Vdo->OverflowQueueEvent, IO_NO_INCREMENT, FALSE );
                }
                Vdo->PostedRequestCount += 1;

                ExReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );
            }
        }
    }

    //
    //  Send it off.....
    //
    
    ASSERT( IsListEmpty( &IrpContext->ExclusiveFcbList ) );
    ASSERT( IsListEmpty( &IrpContext->RecentlyDeallocatedQueue ) );
    RtlZeroMemory( &IrpContext->WorkQueueItem, sizeof( WORK_QUEUE_ITEM ));


    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          NtfsFspDispatch,
                          (PVOID)IrpContext );
    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\write.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for Ntfs called by the
    dispatch driver.

Author:

    Brian Andrew    BrianAn         19-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//    The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#ifdef NTFS_RWC_DEBUG
PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    );
#endif

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('WFtN')

#define OVERFLOW_WRITE_THRESHHOLD        (0x1a00)

#define CollectWriteStats(VCB,OPEN_TYPE,SCB,FCB,BYTE_COUNT,IRP_CONTEXT,TLIC) {           \
    PFILE_SYSTEM_STATISTICS FsStats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()]; \
    if (!FlagOn( (FCB)->FcbState, FCB_STATE_SYSTEM_FILE )) {                             \
        if (NtfsIsTypeCodeUserData( (SCB)->AttributeTypeCode )) {                        \
            FsStats->Common.UserFileWrites += 1;                                         \
            FsStats->Common.UserFileWriteBytes += (ULONG)(BYTE_COUNT);                   \
        } else {                                                                         \
            FsStats->Ntfs.UserIndexWrites += 1;                                          \
            FsStats->Ntfs.UserIndexWriteBytes += (ULONG)(BYTE_COUNT);                    \
        }                                                                                \
    } else {                                                                             \
        if ((SCB) != (VCB)->LogFileScb) {                                                \
            FsStats->Common.MetaDataWrites += 1;                                         \
            FsStats->Common.MetaDataWriteBytes += (ULONG)(BYTE_COUNT);                   \
        } else {                                                                         \
            FsStats->Ntfs.LogFileWrites += 1;                                            \
            FsStats->Ntfs.LogFileWriteBytes += (ULONG)(BYTE_COUNT);                      \
        }                                                                                \
                                                                                         \
        if ((SCB) == (VCB)->MftScb) {                                                    \
            FsStats->Ntfs.MftWrites += 1;                                                \
            FsStats->Ntfs.MftWriteBytes += (ULONG)(BYTE_COUNT);                          \
                                                                                         \
            if ((IRP_CONTEXT) == (TLIC)) {                                               \
                FsStats->Ntfs.MftWritesLazyWriter += 1;                                  \
            } else if ((TLIC)->LastRestartArea.QuadPart != 0) {                          \
                FsStats->Ntfs.MftWritesFlushForLogFileFull += 1;                         \
            } else {                                                                     \
                FsStats->Ntfs.MftWritesUserRequest += 1;                                 \
                                                                                         \
                switch ((TLIC)->MajorFunction) {                                         \
                case IRP_MJ_WRITE:                                                       \
                    FsStats->Ntfs.MftWritesUserLevel.Write += 1;                         \
                    break;                                                               \
                case IRP_MJ_CREATE:                                                      \
                    FsStats->Ntfs.MftWritesUserLevel.Create += 1;                        \
                    break;                                                               \
                case IRP_MJ_SET_INFORMATION:                                             \
                    FsStats->Ntfs.MftWritesUserLevel.SetInfo += 1;                       \
                    break;                                                               \
                case IRP_MJ_FLUSH_BUFFERS:                                               \
                    FsStats->Ntfs.MftWritesUserLevel.Flush += 1;                         \
                    break;                                                               \
                default:                                                                 \
                    break;                                                               \
                }                                                                        \
            }                                                                            \
        } else if ((SCB) == (VCB)->Mft2Scb) {                                            \
            FsStats->Ntfs.Mft2Writes += 1;                                               \
            FsStats->Ntfs.Mft2WriteBytes += (ULONG)(BYTE_COUNT);                         \
                                                                                         \
            if ((IRP_CONTEXT) == (TLIC)) {                                               \
                FsStats->Ntfs.Mft2WritesLazyWriter += 1;                                 \
            } else if ((TLIC)->LastRestartArea.QuadPart != 0) {                          \
                FsStats->Ntfs.Mft2WritesFlushForLogFileFull += 1;                        \
            } else {                                                                     \
                FsStats->Ntfs.Mft2WritesUserRequest += 1;                                \
                                                                                         \
                switch ((TLIC)->MajorFunction) {                                         \
                case IRP_MJ_WRITE:                                                       \
                    FsStats->Ntfs.Mft2WritesUserLevel.Write += 1;                        \
                    break;                                                               \
                case IRP_MJ_CREATE:                                                      \
                    FsStats->Ntfs.Mft2WritesUserLevel.Create += 1;                       \
                    break;                                                               \
                case IRP_MJ_SET_INFORMATION:                                             \
                    FsStats->Ntfs.Mft2WritesUserLevel.SetInfo += 1;                      \
                    break;                                                               \
                case IRP_MJ_FLUSH_BUFFERS:                                               \
                    FsStats->Ntfs.Mft2WritesUserLevel.Flush += 1;                        \
                    break;                                                               \
                default:                                                                 \
                    break;                                                               \
                }                                                                        \
            }                                                                            \
        } else if ((SCB) == (VCB)->RootIndexScb) {                                       \
            FsStats->Ntfs.RootIndexWrites += 1;                                          \
            FsStats->Ntfs.RootIndexWriteBytes += (ULONG)(BYTE_COUNT);                    \
        } else if ((SCB) == (VCB)->BitmapScb) {                                          \
            FsStats->Ntfs.BitmapWrites += 1;                                             \
            FsStats->Ntfs.BitmapWriteBytes += (ULONG)(BYTE_COUNT);                       \
                                                                                         \
            if ((IRP_CONTEXT) == (TLIC)) {                                               \
                FsStats->Ntfs.BitmapWritesLazyWriter += 1;                               \
            } else if ((TLIC)->LastRestartArea.QuadPart != 0) {                          \
                FsStats->Ntfs.BitmapWritesFlushForLogFileFull += 1;                      \
            } else {                                                                     \
                FsStats->Ntfs.BitmapWritesUserRequest += 1;                              \
                                                                                         \
                switch ((TLIC)->MajorFunction) {                                         \
                case IRP_MJ_WRITE:                                                       \
                    FsStats->Ntfs.BitmapWritesUserLevel.Write += 1;                      \
                    break;                                                               \
                case IRP_MJ_CREATE:                                                      \
                    FsStats->Ntfs.BitmapWritesUserLevel.Create += 1;                     \
                    break;                                                               \
                case IRP_MJ_SET_INFORMATION:                                             \
                    FsStats->Ntfs.BitmapWritesUserLevel.SetInfo += 1;                    \
                    break;                                                               \
                default:                                                                 \
                    break;                                                               \
                }                                                                        \
            }                                                                            \
        } else if ((SCB) == (VCB)->MftBitmapScb) {                                       \
            FsStats->Ntfs.MftBitmapWrites += 1;                                          \
            FsStats->Ntfs.MftBitmapWriteBytes += (ULONG)(BYTE_COUNT);                    \
                                                                                         \
            if ((IRP_CONTEXT) == (TLIC)) {                                               \
                FsStats->Ntfs.MftBitmapWritesLazyWriter += 1;                            \
            } else if ((TLIC)->LastRestartArea.QuadPart != 0) {                          \
                FsStats->Ntfs.MftBitmapWritesFlushForLogFileFull += 1;                   \
            } else {                                                                     \
                FsStats->Ntfs.MftBitmapWritesUserRequest += 1;                           \
                                                                                         \
                switch ((TLIC)->MajorFunction) {                                         \
                case IRP_MJ_WRITE:                                                       \
                    FsStats->Ntfs.MftBitmapWritesUserLevel.Write += 1;                   \
                    break;                                                               \
                case IRP_MJ_CREATE:                                                      \
                    FsStats->Ntfs.MftBitmapWritesUserLevel.Create += 1;                  \
                    break;                                                               \
                case IRP_MJ_SET_INFORMATION:                                             \
                    FsStats->Ntfs.MftBitmapWritesUserLevel.SetInfo += 1;                 \
                    break;                                                               \
                default:                                                                 \
                    break;                                                               \
                }                                                                        \
            }                                                                            \
        }                                                                                \
    }                                                                                    \
}

#define WriteToEof (StartingVbo < 0)

#ifdef SYSCACHE_DEBUG

#define CalculateSyscacheFlags( IRPCONTEXT, FLAG, INITIAL_VALUE )           \
    FLAG = INITIAL_VALUE;                                                   \
    if (PagingIo) {                                                         \
        FLAG |= SCE_FLAG_PAGING;                                            \
    }                                                                       \
    if (!SynchronousIo) {                                                   \
        FLAG |= SCE_FLAG_ASYNC;                                             \
    }                                                                       \
    if (SynchPagingIo) {                                                    \
        FLAG |= SCE_FLAG_SYNC_PAGING;                                       \
    }                                                                       \
    if (FlagOn( (IRPCONTEXT)->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {      \
        FLAG |= SCE_FLAG_LAZY_WRITE;                                        \
    }                                                                       \
    if (RecursiveWriteThrough) {                                            \
        FLAG |= SCE_FLAG_RECURSIVE;                                         \
    }                                                                       \
    if (NonCachedIo) {                                                      \
        FLAG |= SCE_FLAG_NON_CACHED;                                        \
    }                                                                       \
    if (Scb->CompressionUnit) {                                             \
        FLAG |= SCE_FLAG_COMPRESSED;                                        \
    }


#endif


NTSTATUS
NtfsFsdWrite (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD entry part of Write.

Arguments:

    IrpContext - If present, a pointer to an IrpContext
        on the caller's stack.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;
    ULONG Retries = 0;

    ASSERT_IRP( Irp );

    DebugTrace( +1, Dbg, ("NtfsFsdWrite\n") );

    //
    //  Call the common Write routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {


            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                PSCB Scb = IoGetCurrentIrpStackLocation( Irp )->FileObject->FsContext;
                PFCB Fcb;
                BOOLEAN PagingFileIo = FALSE;

                if (Scb != NULL) {
                    Fcb = Scb->Fcb;
                    PagingFileIo = FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA );
                }

                //
                //  Allocate synchronous paging io on the stack to avoid allocation
                //  failures. All paging file i/o can also be on the stack even async
                //

                if (PagingFileIo || (CanFsdWait( Irp ) && FlagOn( Irp->Flags, IRP_PAGING_IO ))) {

                    //
                    //  AllocateFromStack is only called in the first pass of the
                    //  loop.  Once the IrpContext exists we don't call this again.
                    //

                    IrpContext = (PIRP_CONTEXT) NtfsAllocateFromStack( sizeof( IRP_CONTEXT ));
                }

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                if (ThreadTopLevelContext->ScbBeingHotFixed != NULL) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY );
                }

                //
                //  If this is an MDL_WRITE then the Mdl in the Irp should
                //  be NULL.
                //

                if (FlagOn( IrpContext->MinorFunction, IRP_MN_MDL ) &&
                    !FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                    Irp->MdlAddress = NULL;
                }

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            
            } else if (Status == STATUS_WAIT_FOR_OPLOCK) {
                
                Status = KeWaitForSingleObject( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL );

                ASSERT( Status == STATUS_SUCCESS );

                //
                //  Cleanup the iocontext directly
                //  

                if (FlagOn( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_ALLOCATED )) {
                    ExFreeToNPagedLookasideList( &NtfsIoContextLookasideList, IrpContext->Union.NtfsIoContext );
                }
                IrpContext->Union.NtfsIoContext = NULL;

                //
                //  If we had any failures i.e the irp was cancelled - leave
                //  

                Status = Irp->IoStatus.Status;
                if (!NT_SUCCESS( Status )) {
                    NtfsCompleteRequest( IrpContext, Irp, Status );
                    break;
                }
            }

            //
            //  If this is an Mdl complete request, don't go through
            //  common write.
            //

            ASSERT( !FlagOn( IrpContext->MinorFunction, IRP_MN_DPC ) );

            if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                DebugTrace( 0, Dbg, ("Calling NtfsCompleteMdl\n") );
                Status = NtfsCompleteMdl( IrpContext, Irp );

            //
            //  Identify write requests which can't wait and post them to the
            //  Fsp.
            //

            } else {


#ifdef COMPRESS_ON_WRITE
                //
                //  Capture the auxiliary buffer and clear its address if it
                //  is not supposed to be deleted by the I/O system on I/O completion.
                //

                if (Irp->Tail.Overlay.AuxiliaryBuffer != NULL) {

                    IrpContext->Union.AuxiliaryBuffer =
                      (PFSRTL_AUXILIARY_BUFFER)Irp->Tail.Overlay.AuxiliaryBuffer;

                    if (!FlagOn(IrpContext->Union.AuxiliaryBuffer->Flags,
                                FSRTL_AUXILIARY_FLAG_DEALLOCATE)) {

                        Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
                    }
                }
#endif

                Status = NtfsCommonWrite( IrpContext, Irp );
            }

        } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NTSTATUS ExceptionCode;

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            ExceptionCode = GetExceptionCode();

            if (ExceptionCode == STATUS_FILE_DELETED) {

                if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL ) ||
                    FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                    IrpContext->ExceptionStatus = ExceptionCode = STATUS_SUCCESS;
                }

            } else if ((ExceptionCode == STATUS_VOLUME_DISMOUNTED) &&
                       FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                IrpContext->ExceptionStatus = ExceptionCode = STATUS_SUCCESS;
            }

            Status = NtfsProcessException( IrpContext,
                                           Irp,
                                           ExceptionCode );
        }

        ASSERT( (Status != STATUS_WAIT_FOR_OPLOCK) || (ThreadTopLevelContext == &TopLevelContext) );

        Retries++;

    } while ((Status == STATUS_CANT_WAIT || Status == STATUS_LOG_FILE_FULL || Status == STATUS_WAIT_FOR_OPLOCK) && 
             (ThreadTopLevelContext == &TopLevelContext));

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdWrite -> %08lx\n", Status) );

    return Status;

    UNREFERENCED_PARAMETER( VolumeDeviceObject );
}



NTSTATUS
NtfsCommonWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Write called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFILE_OBJECT UserFileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

#ifdef  COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
    PCOMPRESSED_DATA_INFO CompressedDataInfo;
    ULONG EngineMatches;
    ULONG CompressionUnitSize, ChunkSize;
#endif

    PNTFS_ADVANCED_FCB_HEADER Header;

    BOOLEAN OplockPostIrp = FALSE;
    BOOLEAN PostIrp = FALSE;

    PVOID SystemBuffer = NULL;
    PVOID SafeBuffer = NULL;

    BOOLEAN RecursiveWriteThrough = FALSE;
    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN PagingIoAcquired = FALSE;

    BOOLEAN UpdateMft = FALSE;
    BOOLEAN DoingIoAtEof = FALSE;
    BOOLEAN SetWriteSeen = FALSE;

    BOOLEAN RestoreValidDataToDisk = FALSE;

    BOOLEAN Wait;
    BOOLEAN OriginalTopLevel;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN SynchronousIo;
    ULONG PagingFileIo;
    BOOLEAN SynchPagingIo;
    BOOLEAN RawEncryptedWrite = FALSE;

    NTFS_IO_CONTEXT LocalContext;

    VBO StartingVbo;
    LONGLONG ByteCount;
    LONGLONG ByteRange;
    LONGLONG OldFileSize;

    PVOID NewBuffer;
    PMDL NewMdl;
    PMDL OriginalMdl;
    PVOID OriginalBuffer;
    ULONG TempLength;

    PATTRIBUTE_RECORD_HEADER Attribute;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttributeContext = FALSE;

    LONGLONG LlTemp1;
    LONGLONG LlTemp2;

    LONGLONG ZeroStart;
    LONGLONG ZeroLength;

#ifdef SYSCACHE_DEBUG
    BOOLEAN PurgeResult;
    LONG TempEntry;
    ULONG Flags;
#endif

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonWrite\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    UserFileObject = FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Let's kill invalid write requests.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != StreamFileOpen) &&
        (TypeOfOpen != UserVolumeOpen)) {

        DebugTrace( 0, Dbg, ("Invalid file object for write\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  If this is a recursive request which has already failed then
    //  complete this request with STATUS_FILE_LOCK_CONFLICT.  Always let the
    //  log file requests go through though since Cc won't get a chance to
    //  retry.
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY ) &&
        !NT_SUCCESS( IrpContext->TopLevelIrpContext->ExceptionStatus ) &&
        (Scb != Vcb->LogFileScb)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_FILE_LOCK_CONFLICT );
        return STATUS_FILE_LOCK_CONFLICT;
    }

    //
    //  Check if this volume has already been shut down.  If it has, fail
    //  this write request.
    //

    //**** ASSERT( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN) );

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN)) {

        Irp->IoStatus.Information = 0;

        DebugTrace( 0, Dbg, ("Write for volume that is already shutdown.\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_TOO_LATE) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_TOO_LATE );
        return STATUS_TOO_LATE;
    }

    //
    //  Fail if the volume is mounted read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Irp->IoStatus.Information = 0;

        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_MEDIA_WRITE_PROTECTED) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Initialize the appropriate local variables.
    //

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    PagingIo = BooleanFlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = BooleanFlagOn( Irp->Flags,IRP_NOCACHE );
    SynchronousIo = BooleanFlagOn( FileObject->Flags, FO_SYNCHRONOUS_IO );
    PagingFileIo = FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA );
    SynchPagingIo = (BOOLEAN) FlagOn( Irp->Flags, IRP_SYNCHRONOUS_PAGING_IO );
    OriginalTopLevel = NtfsIsTopLevelRequest( IrpContext );

    //
    //  If this is async paging io then check if we are being called by the mapped page writer.
    //  Convert it back to synchronous if not.
    //

    if (!Wait && PagingIo && !PagingFileIo) {

        if ((IrpContext->TopLevelIrpContext != IrpContext) ||
            (NtfsGetTopLevelContext()->SavedTopLevelIrp != (PIRP) FSRTL_MOD_WRITE_TOP_LEVEL_IRP)) {

            Wait = TRUE;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
        }
    }

    DebugTrace( 0, Dbg, ("PagingIo       -> %04x\n", PagingIo) );
    DebugTrace( 0, Dbg, ("NonCachedIo    -> %04x\n", NonCachedIo) );
    DebugTrace( 0, Dbg, ("SynchronousIo  -> %04x\n", SynchronousIo) );

    //
    //  Extract starting Vbo and offset. Restore back write to eof if the
    //  flag was set that we came through and adjusted for it and now the filesize
    //  has shrunk due to a failure to adjust size or an intervening seteof
    //  it should be safe to add the irp params since we validated for overflows when
    //  we set the writing_at_eof flag
    //

    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF ) &&
        (Scb->Header.FileSize.QuadPart < IrpSp->Parameters.Write.ByteOffset.QuadPart + IrpSp->Parameters.Write.Length)) {

        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF );
        IrpSp->Parameters.Write.ByteOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
        IrpSp->Parameters.Write.ByteOffset.HighPart = -1;
    }

    StartingVbo = IrpSp->Parameters.Write.ByteOffset.QuadPart;
    ByteCount = (LONGLONG) IrpSp->Parameters.Write.Length;

    //
    //  Check for overflows. However, 0xFFFFFFFF is a valid value
    //  when we are appending at EOF.
    //

    ASSERT( !WriteToEof ||
            (IrpSp->Parameters.Write.ByteOffset.HighPart == -1 &&
             IrpSp->Parameters.Write.ByteOffset.LowPart == FILE_WRITE_TO_END_OF_FILE));

    if ((MAXLONGLONG - StartingVbo < ByteCount) && (!WriteToEof)) {

        ASSERT( !PagingIo );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    ByteRange = StartingVbo + ByteCount;

    DebugTrace( 0, Dbg, ("StartingVbo   -> %016I64x\n", StartingVbo) );

    //
    //  If this is a null request, return immediately.
    //

    if ((ULONG)ByteCount == 0) {

        Irp->IoStatus.Information = 0;

        DebugTrace( 0, Dbg, ("No bytes to write\n") );
        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_SUCCESS) );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

#if DBG
    if (PagingIo &&
        NtfsIsTypeCodeEncryptible( Scb->AttributeTypeCode ) &&
        Scb->Header.PagingIoResource != NULL &&
        NtfsIsSharedScbPagingIo( Scb ) &&
        FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
        Scb->EncryptionContext == NULL) {

        //
        //  We're in trouble if we can't encrypt the data in the pages before writing
        //  it out.  Naturally, if this is a directory or some other unencryptible
        //  attribute type, we don't care, since we weren't going to encrypt the data
        //  anyway.  It is valid to do raw writes to an encypted stream without an
        //  encryption context, but raw encrypted writes shouldn't look like paging io.
        //

        ASSERTMSG( "Encrypted file without an encryption context -- can't do paging io", FALSE );
    }
#endif

    //
    //  If this is async Io to a compressed stream
    //  then we will make this look synchronous.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

        Wait = TRUE;
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    }

    //
    //  See if we have to defer the write.
    //

    if (!PagingIo &&
        !NonCachedIo &&
        !FlagOn( FileObject->Flags, FO_WRITE_THROUGH ) &&
        !CcCanIWrite( FileObject,
                      (ULONG)ByteCount,
                      (BOOLEAN)(FlagOn( IrpContext->State,
                                       IRP_CONTEXT_STATE_WAIT | IRP_CONTEXT_STATE_IN_FSP ) == IRP_CONTEXT_STATE_WAIT),
                      BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE))) {

        BOOLEAN Retrying = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE);

        NtfsPrePostIrp( IrpContext, Irp );

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE );
        CcDeferWrite( FileObject,
                      (PCC_POST_DEFERRED_WRITE)NtfsAddToWorkque,
                      IrpContext,
                      Irp,
                      (ULONG)ByteCount,
                      Retrying );

        return STATUS_PENDING;
    }

    //
    //  Use a local pointer to the Scb header for convenience.
    //

    Header = &Scb->Header;

    //
    //  Make sure there is an initialized NtfsIoContext block.
    //  If there is a context pointer, we need to make sure it was
    //  allocated and not a stale stack pointer.
    //

    if (!PagingFileIo) {
        NtfsInitializeIoContext( IrpContext, &LocalContext, PagingIo );
    }

    DebugTrace( 0, Dbg, ("PagingIo       -> %04x\n", PagingIo) );
    DebugTrace( 0, Dbg, ("NonCachedIo    -> %04x\n", NonCachedIo) );
    DebugTrace( 0, Dbg, ("SynchronousIo  -> %04x\n", SynchronousIo) );
    DebugTrace( 0, Dbg, ("WriteToEof     -> %04x\n", WriteToEof) );

    //
    //  Handle volume Dasd here.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        //
        //  If the caller has not asked for extended DASD IO access then
        //  limit with the volume size.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_XTENDED_DASD_IO )) {

            //
            //  If this is a volume file, we cannot write past the current
            //  end of file (volume).  We check here now before continueing.
            //
            //  If the starting vbo is past the end of the volume, we are done.
            //

            if (WriteToEof || (Scb->Header.FileSize.QuadPart <= StartingVbo)) {

                DebugTrace( 0, Dbg, ("No bytes to write\n") );
                DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", STATUS_SUCCESS) );

                NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
                return STATUS_SUCCESS;

            //
            //  If the write extends beyond the end of the volume, truncate the
            //  bytes to write.
            //

            } else if (Scb->Header.FileSize.QuadPart < ByteRange) {

                ByteCount = Scb->Header.FileSize.QuadPart - StartingVbo;
            }
        }

        //
        //  Set the io context async if necc. before doing the i/o
        //

        if (!Wait) {
            NtfsSetIoContextAsync( IrpContext, NULL, (ULONG)ByteCount );
        }

        SetFlag( UserFileObject->Flags, FO_FILE_MODIFIED );
        Status = NtfsVolumeDasdIo( IrpContext,
                                   Irp,
                                   Scb,
                                   Ccb,
                                   StartingVbo,
                                   (ULONG)ByteCount );

        //
        //  If the volume was opened for Synchronous IO, update the current
        //  file position.
        //

        if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

            UserFileObject->CurrentByteOffset.QuadPart = StartingVbo + (LONGLONG) Irp->IoStatus.Information;
        }

        DebugTrace( 0, Dbg, ("Complete with %08lx bytes written\n", Irp->IoStatus.Information) );
        DebugTrace( -1, Dbg, ("NtfsCommonWrite:  Exit -> %08lx\n", Status) );

        if (Wait) {
            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
        return Status;
    }

    //
    //  If this is a paging file, just send it to the device driver.
    //  We assume Mm is a good citizen.
    //

    if (PagingFileIo != 0) {

        if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
        }

        //
        //  Do the usual STATUS_PENDING things.
        //

        IoMarkIrpPending( Irp );

        //
        //  Perform the actual IO, it will be completed when the io finishes.
        //

        NtfsPagingFileIo( IrpContext,
                          Irp,
                          Scb,
                          StartingVbo,
                          (ULONG)ByteCount );

        //
        //  We, nor anybody else, need the IrpContext any more.
        //

        NtfsCompleteRequest( IrpContext, NULL, 0 );

        return STATUS_PENDING;
    }

    //
    //  Special processing for paging io.
    //

    if (PagingIo) {

        //
        //  If this is the Usn Journal then bias the Io to the correct location in the
        //  file.
        //

        if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

            StartingVbo += Vcb->UsnCacheBias;
            ByteRange = StartingVbo + (LONGLONG) IrpSp->Parameters.Write.Length;
        }

        //
        //  Gather statistics on this IO.
        //

        CollectWriteStats( Vcb, TypeOfOpen, Scb, Fcb, ByteCount, IrpContext,
                           IrpContext->TopLevelIrpContext );
    }

    //
    //  Use a try-finally to free Scb and buffers on the way out.
    //  At this point we can treat all requests identically since we
    //  have a usable Scb for each of them.  (Volume, User or Stream file)
    //

    Status = STATUS_SUCCESS;

    try {

        //
        //  If this is a noncached transfer and is not a paging I/O, and
        //  the file has been opened cached, then we will do a flush here
        //  to avoid stale data problems.  Note that we must flush before
        //  acquiring the Fcb shared since the write may try to acquire
        //  it exclusive.
        //
        //  CcFlushCache may not raise.
        //
        //  The Purge following the flush will guarantee cache coherency.
        //

        //
        //  If this request is paging IO then check if our caller already
        //  owns any of the resources for this file.  If so then we don't
        //  want to perform a log file full in this thread.
        //

        if (!PagingIo) {

            //
            //  Capture the source information.
            //

            IrpContext->SourceInfo = Ccb->UsnSourceInfo;

            //
            //  Check for rawencryptedwrite
            //

            if (NonCachedIo &&
                !NtfsIsTopLevelNtfs( IrpContext )) {

#if DBG || defined( NTFS_FREE_ASSERT )
                ASSERT( (IrpContext->TopLevelIrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                        (IoGetCurrentIrpStackLocation( IrpContext->TopLevelIrpContext->OriginatingIrp )->Parameters.FileSystemControl.FsControlCode == FSCTL_WRITE_RAW_ENCRYPTED ));
#endif

                RawEncryptedWrite = TRUE;
            }

            if (NonCachedIo &&
                (TypeOfOpen != StreamFileOpen) &&
                (FileObject->SectionObjectPointer->DataSectionObject != NULL)) {

                //
                //  Acquire the paging io resource to test the compression state.  If the
                //  file is compressed this will add serialization up to the point where
                //  CcCopyWrite flushes the data, but those flushes will be serialized
                //  anyway.  Uncompressed files will need the paging io resource
                //  exclusive to do the flush.
                //

                NtfsAcquirePagingResourceExclusive( IrpContext, Scb, TRUE );
                PagingIoAcquired = TRUE;

                if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    if (WriteToEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {

                        CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                        TempEntry = FsRtlLogSyscacheEvent( Scb, SCE_CC_FLUSH, Flags, WriteToEof ? Header->FileSize.QuadPart : StartingVbo, ByteCount, -1 );
                    }
#endif
                    CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                                  WriteToEof ? &Header->FileSize : (PLARGE_INTEGER)&StartingVbo,
                                  (ULONG)ByteCount,
                                  &Irp->IoStatus );

#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        FsRtlUpdateSyscacheEvent( Scb, TempEntry, Irp->IoStatus.Status, 0 );
                    }
#endif

                    if (WriteToEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }

                    //
                    //  Make sure there was no error in the flush path.
                    //

                    if (!NT_SUCCESS( IrpContext->TopLevelIrpContext->ExceptionStatus ) ||
                        !NT_SUCCESS( Irp->IoStatus.Status )) {

                        NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                            &Irp->IoStatus.Status,
                                                            TRUE,
                                                            STATUS_UNEXPECTED_IO_ERROR );
                    }

                    //
                    //  Now purge the data for this range.
                    //

                    NtfsDeleteInternalAttributeStream( Scb, FALSE, FALSE );

#ifdef SYSCACHE_DEBUG
                    PurgeResult =
#endif
                    CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                       (PLARGE_INTEGER)&StartingVbo,
                                                       (ULONG)ByteCount,
                                                       FALSE );
#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb ) && !PurgeResult) {
                        KdPrint( ("NTFS: Failed Purge 0x%x 0x%I64x 0x%x\n", Scb, StartingVbo, ByteCount) );
                        DbgBreakPoint();

                        //
                        // Repeat attempt so we can watch
                        //

                        PurgeResult = CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                           (PLARGE_INTEGER)&StartingVbo,
                                                           (ULONG)ByteCount,
                                                           FALSE );
                    }
#endif
                }

            //
            //  If not paging I/O, then we must acquire a resource, and do some
            //  other initialization.  We already have the resource if we performed
            //  the coherency flush above.
            //

            } else {

                //  We want to acquire the paging io resource if not already acquired.
                //  Acquire exclusive if we failed a previous convert to non-resident because
                //  of a possible deadlock.  Otherwise get it shared.
                //

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                    if (!NtfsAcquirePagingResourceExclusive( IrpContext, Scb, Wait )) {
                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                    }

                } else {
                    if (!NtfsAcquirePagingResourceSharedWaitForExclusive( IrpContext, Scb, Wait )) {
                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                    }
                }
                PagingIoAcquired = TRUE;
            }


            //
            //  Check if we have already gone through cleanup on this handle.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_CLEANUP )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CLOSED, NULL, NULL );
            }

            //
            //  Now check if the attribute has been deleted or is on a dismounted volume.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED)) {

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
                } else {
                    NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                }
            }
            //
            //  Now synchronize with the FsRtl Header
            //

            NtfsAcquireFsrtlHeader( Scb );

            //
            //  Now see if we will change FileSize.  We have to do it now
            //  so that our reads are not nooped.
            //

            if ((ByteRange > Header->ValidDataLength.QuadPart) || WriteToEof) {

                if ((IrpContext->TopLevelIrpContext->CleanupStructure == Fcb) ||
                    (IrpContext->TopLevelIrpContext->CleanupStructure == Scb)) {

                    DoingIoAtEof = TRUE;
                    OldFileSize = Header->FileSize.QuadPart;

                } else {

                    ASSERT( IrpContext->TopLevelIrpContext->CleanupStructure == NULL );

                    DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                                   NtfsWaitForIoAtEof( Header, (PLARGE_INTEGER)&StartingVbo, (ULONG)ByteCount );

                    //
                    //  Set the Flag if we are changing FileSize or ValidDataLength,
                    //  and save current values.
                    //

                    if (DoingIoAtEof) {

                        SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
    #if (DBG || defined( NTFS_FREE_ASSERTS ))
                        ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
    #endif

                        //
                        //  Store this in the IrpContext until commit or post
                        //

                        IrpContext->CleanupStructure = Scb;

                        OldFileSize = Header->FileSize.QuadPart;

                        //
                        //  Check for writing to end of File.  If we are, then we have to
                        //  recalculate the byte range.
                        //

                        if (WriteToEof) {

                            //
                            //  Mark the in irp context that the write is at eof and change its paramters
                            //  to reflect where the end of the file is.
                            //

                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF );
                            IrpSp->Parameters.Write.ByteOffset.QuadPart = Header->FileSize.QuadPart;

                            StartingVbo = Header->FileSize.QuadPart;
                            ByteRange = StartingVbo + ByteCount;

                            //
                            //  If the ByteRange now exceeds our maximum value, then
                            //  return an error.
                            //

                            if (ByteRange < StartingVbo) {

                                NtfsReleaseFsrtlHeader( Scb );
                                try_return( Status = STATUS_INVALID_PARAMETER );
                            }
                        }

    #if (DBG || defined( NTFS_FREE_ASSERTS ))
                    } else {

                        ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
    #endif
                    }

                }

                //
                //  Make sure the user isn't writing past our maximum file size.
                //

                if ((ULONGLONG)ByteRange > MAXFILESIZE) {

                    NtfsReleaseFsrtlHeader( Scb );
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }
            }

            NtfsReleaseFsrtlHeader( Scb );

            //
            //  We cannot handle user noncached I/Os to compressed files, so we always
            //  divert them through the cache with write through.
            //
            //  The reason that we always handle the user requests through the cache,
            //  is that there is no other safe way to deal with alignment issues, for
            //  the frequent case where the user noncached I/O is not an integral of
            //  the Compression Unit.  We cannot, for example, read the rest of the
            //  compression unit into a scratch buffer, because we are not synchronized
            //  with anyone mapped to the file and modifying the other data.  If we
            //  try to assemble the data in the cache in the noncached path, to solve
            //  the above problem, then we have to somehow purge these pages away
            //  to solve cache coherency problems, but then the pages could be modified
            //  by a file mapper and that would be wrong, too.
            //
            //  Bottom line is we can only really support cached writes to compresed
            //  files.
            //

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) && NonCachedIo) {

                NonCachedIo = FALSE;

                if (Scb->FileObject == NULL) {

                    //
                    //  Make sure we are serialized with the FileSizes, and
                    //  will remove this condition if we abort.
                    //

                    if (!DoingIoAtEof) {
                        FsRtlLockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = Scb;
                    }

                    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

                    if (!DoingIoAtEof) {
                        FsRtlUnlockFsRtlHeader( Header );
                        IrpContext->CleanupStructure = NULL;
                    }
                }

                FileObject = Scb->FileObject;
                SetFlag( FileObject->Flags, FO_WRITE_THROUGH );
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH );
            }

            //
            //  Set the flag in our IrpContext to indicate that we have entered
            //  write.
            //

            ASSERT( !FlagOn( IrpContext->TopLevelIrpContext->Flags,
                    IRP_CONTEXT_FLAG_WRITE_SEEN ));

            SetFlag( IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN );
            SetWriteSeen = TRUE;

            //
            //  Now post any Usn changes.  We will blindly make the call here, because
            //  usually all but the first call is in the fast path anyway.
            //  Checkpoint the transaction to reduce resource contention of the UsnJournal
            //  and Mft.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                ULONG Reason = 0;

                ASSERT( Vcb->UsnJournal != NULL );

                if (ByteRange > Header->FileSize.QuadPart) {
                    Reason |= USN_REASON_DATA_EXTEND;
                }
                if (StartingVbo < Header->FileSize.QuadPart) {
                    Reason |= USN_REASON_DATA_OVERWRITE;
                }

                NtfsPostUsnChange( IrpContext, Scb, Reason );
                if (IrpContext->TransactionId != 0) {
                    NtfsCheckpointCurrentTransaction( IrpContext );
                }
            }

        } else {

            //
            //  Only do the check if we are the top-level Ntfs case.  In any
            //  recursive Ntfs case we don't perform a log-file full.
            //

            if (NtfsIsTopLevelRequest( IrpContext )) {

                if (NtfsIsSharedScb( Scb ) ||
                    ((Scb->Header.PagingIoResource != NULL) &&
                     NtfsIsSharedScbPagingIo( Scb ))) {

                    //
                    //  Don't try to do a clean checkpoint in this thread.
                    //

                    NtfsGetTopLevelContext()->TopLevelRequest = FALSE;
                }
            }

            //
            //  For all paging I/O, the correct resource has already been
            //  acquired shared - PagingIoResource if it exists, or else
            //  main Resource.  In some rare cases this is not currently
            //  true (shutdown & segment dereference thread), so we acquire
            //  shared here, but we starve exclusive in these rare cases
            //  to be a little more resilient to deadlocks!  Most of the
            //  time all we do is the test.
            //

            if ((Header->PagingIoResource != NULL) &&
                !NtfsIsSharedScbPagingIo( (PSCB) Header ) &&
                !NtfsIsSharedScb( (PSCB) Header ) ) {

                ExAcquireSharedStarveExclusive( Header->PagingIoResource, TRUE );
                PagingIoAcquired = TRUE;
            }

            //
            //  Now check if the attribute has been deleted or is on a dismounted volume.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED)) {

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_DELETED, NULL, NULL );
                } else {
                    NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                }
            }

            //
            //  If this is async paging IO to a compressed file force it to be
            //  synchronous.
            //

            if (!Wait && (Scb->CompressionUnit != 0)) {

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    Wait = TRUE;
                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
                }
            }

            //
            //  Note that the lazy writer must not be allowed to try and
            //  acquire the resource exclusive.  This is not a problem since
            //  the lazy writer is paging IO and thus not allowed to extend
            //  file size, and is never the top level guy, thus not able to
            //  extend valid data length.
            //

            if (

#ifdef COMPRESS_ON_WIRE
               (Scb->LazyWriteThread[0]  == PsGetCurrentThread()) ||
               (Scb->LazyWriteThread[1]  == PsGetCurrentThread())
#else


               (NtfsGetTopLevelContext()->SavedTopLevelIrp == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP)
#endif
               ) {

                DebugTrace( 0, Dbg, ("Lazy writer generated write\n") );
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE );

                //
                //  If the temporary bit is set in the Scb then set the temporary
                //  bit in the file object.  In case the temporary bit has changed
                //  in the Scb, this is a good file object to fix it in!
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {
                    SetFlag( FileObject->Flags, FO_TEMPORARY_FILE );
                } else {
                    ClearFlag( FileObject->Flags, FO_TEMPORARY_FILE );
                }

            //
            //  Test if we are the result of a recursive flush in the write path.  In
            //  that case we won't have to update valid data.
            //

            } else {

                //
                //  Check if we are recursing into write from a write via the
                //  cache manager.
                //

                if (FlagOn( IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN )) {

                    RecursiveWriteThrough = TRUE;

                    //
                    //  If the top level request is a write to the same file object
                    //  then set the write-through flag in the current Scb.  We
                    //  know the current request is not top-level because some
                    //  other write has already set the bit in the top IrpContext.
                    //

                    if ((IrpContext->TopLevelIrpContext->MajorFunction == IRP_MJ_WRITE) &&
                        (IrpContext->TopLevelIrpContext->OriginatingIrp != NULL) &&
                        (FileObject->FsContext ==
                         IoGetCurrentIrpStackLocation( IrpContext->TopLevelIrpContext->OriginatingIrp )->FileObject->FsContext)) {

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH );
                    }

                //
                //  Otherwise set the flag in the top level IrpContext showing that
                //  we have entered write.
                //

                } else {

                    SetFlag(IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN);
                    SetWriteSeen = TRUE;

                }

            }

            //
            //  This could be someone who extends valid data or valid data to disk,
            //  like the Mapped Page Writer or a flush or the lazy writer
            //  writing the last page contianing the VDL, so we have to
            //  duplicate code from above in the non paging case to serialize this guy with I/O
            //  at the end of the file.  We do not extend valid data for
            //  metadata streams and need to eliminate them to avoid deadlocks
            //  later.
            //

            if (!RecursiveWriteThrough) {

                if (!FlagOn(Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE)) {

                    ASSERT(!WriteToEof);

                    //
                    //  Now synchronize with the FsRtl Header
                    //

                    NtfsAcquireFsrtlHeader( Scb );

                    //
                    //  Now see if we will change FileSize.  We have to do it now
                    //  so that our reads are not nooped.
                    //

                    if (ByteRange > Header->ValidDataLength.QuadPart) {

                        //
                        //  Our caller may already be synchronized with EOF.
                        //  The FcbWithPaging field in the top level IrpContext
                        //  will have either the current Fcb/Scb if so.
                        //

                        if ((IrpContext->TopLevelIrpContext->CleanupStructure == Fcb) ||
                            (IrpContext->TopLevelIrpContext->CleanupStructure == Scb)) {

                            DoingIoAtEof = TRUE;
                            OldFileSize = Header->FileSize.QuadPart;

                        } else {

                            //
                            //  We can change FileSize and ValidDataLength if either, no one
                            //  else is now, or we are still extending after waiting.
                            //  We won't block the mapped page writer or deref seg thread on IoAtEof.                                  //  We also won't block on non-top level requests that are not recursing from the filesystem like the deref
                            //  seg thread. Mm initiated flushes are originally not top level but the top level
                            //  irp context is the current irp context. (as opposed to recursive file system writes
                            //  which are not top level and top level irp context is different from the current one)

                            if (FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE )) {

                                if (!OriginalTopLevel && NtfsIsTopLevelNtfs( IrpContext )) {

                                    NtfsReleaseFsrtlHeader( Scb );
                                    try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                                }

                                DoingIoAtEof = NtfsWaitForIoAtEof( Header, (PLARGE_INTEGER)&StartingVbo, (ULONG)ByteCount );

                            } else {

                                DoingIoAtEof = TRUE;
                            }

                            //
                            //  Set the Flag if we are changing FileSize or ValidDataLength,
                            //  and save current values.
                            //

                            if (DoingIoAtEof) {

                                SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                                ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif
                                //
                                //  Store this in the IrpContext until commit or post
                                //

                                IrpContext->CleanupStructure = Scb;

                                OldFileSize = Header->FileSize.QuadPart;
#if (DBG || defined( NTFS_FREE_ASSERTS ))
                            } else {

                                ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                            }
                        }

                    }
                    NtfsReleaseFsrtlHeader( Scb );
                }

                //
                //  Now that we're synchronized with doing io at eof we can check
                //  the lazywrite's bounds
                //

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {

                    //
                    //  The lazy writer should always be writing data ends on
                    //  or before the page containing ValidDataLength.
                    //  In some cases the lazy writer may be writing beyond this point.
                    //
                    //  1. The user may have truncated the size to zero through
                    //  SetAllocation but the page was already queued to the lazy
                    //  writer. In the typical case this write will be nooped
                    //
                    //  2. If there is a mapped section and the user actually modified
                    //  the page in which VDL is contained but beyond VDL this page is written to disk
                    //  and VDL is updated. Otherwise it may never get written since the mapped writer
                    //  defers to the lazywriter
                    //
                    //  3. For all writes really beyond the page containing VDL when
                    //  the file is mapped since ValidDataLength is notupdated here a
                    //  subsequent write may zero this range and the data would be lost.  So
                    //  We will return FILE_LOCK_CONFLICT to lazy writer if there is a mapped section and wait
                    //  for the mapped page writer to write this page (or any
                    //  page beyond this point).
                    //
                    //  Returning FILE_LOCK_CONFLICT should never cause us to lose
                    //  the data so we can err on the conservative side here.
                    //  There is nothing to worry about unless the file has been
                    //  mapped.
                    //

                    if (FlagOn( Header->Flags, FSRTL_FLAG_USER_MAPPED_FILE )) {

                        //
                        //  Fail if the start of this request is beyond valid data length.
                        //  Don't worry if this is an unsafe test.  MM and CC won't
                        //  throw this page away if it is really dirty.
                        //

                        if ((ByteRange > Header->ValidDataLength.QuadPart) &&
                            (StartingVbo < Header->FileSize.QuadPart)) {

                            //
                            //  It's OK if byte range is within the page containing valid data length.
                            //

                            if (ByteRange > ((Header->ValidDataLength.QuadPart + PAGE_SIZE - 1) & ~((LONGLONG) (PAGE_SIZE - 1)))) {

                                //
                                //  Don't flush this now.
                                //

                                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                            }

                        }

                    //
                    //  This is a stale callback by cc we can discard the data
                    //  this usually indicates a failed purge at some point during a truncate
                    //

                    } else if (ByteRange >= Header->ValidDataLength.QuadPart)  {

                        //
                        //  Trim the write down
                        //

                        ByteRange = Header->ValidDataLength.QuadPart;
                        ByteCount = ByteRange - StartingVbo;

                        //
                        //  If all of the write is beyond vdl just noop it
                        //

                        if (StartingVbo >= Header->ValidDataLength.QuadPart) {
                            DoingIoAtEof = FALSE;
                            Irp->IoStatus.Information = 0;
                            try_return( Status = STATUS_SUCCESS );
                        }
                    }
                }  //  lazy writer
            }  //  not recursive write through


            //
            //  If are paging io, then we do not want
            //  to write beyond end of file.  If the base is beyond Eof, we will just
            //  Noop the call.  If the transfer starts before Eof, but extends
            //  beyond, we will truncate the transfer to the last sector
            //  boundary.
            //
            //  Just in case this is paging io, limit write to file size.
            //  Otherwise, in case of write through, since Mm rounds up
            //  to a page, we might try to acquire the resource exclusive
            //  when our top level guy only acquired it shared. Thus, =><=.
            //

            NtfsAcquireFsrtlHeader( Scb );
            if (ByteRange > Header->FileSize.QuadPart) {

                if (StartingVbo >= Header->FileSize.QuadPart) {
                    DebugTrace( 0, Dbg, ("PagingIo started beyond EOF.\n") );

                    Irp->IoStatus.Information = 0;

                    //
                    //  Make sure we do not advance ValidDataLength!
                    //  We also haven't really written anything so set doingioateof back to
                    //  false
                    //

                    ByteRange = Header->ValidDataLength.QuadPart;
                    DoingIoAtEof = FALSE;

                    NtfsReleaseFsrtlHeader( Scb );

                    try_return( Status = STATUS_SUCCESS );

                } else {

                    DebugTrace( 0, Dbg, ("PagingIo extending beyond EOF.\n") );

#ifdef NTFS_RWC_DEBUG
                    if ((FileObject->SectionObjectPointer != &Scb->NonpagedScb->SegmentObject) &&
                        (StartingVbo < NtfsRWCHighThreshold) &&
                        (ByteRange > NtfsRWCLowThreshold)) {

                        PRWC_HISTORY_ENTRY NextBuffer;

                        NextBuffer = NtfsGetHistoryEntry( Scb );

                        NextBuffer->Operation = TrimCompressedWrite;
                        NextBuffer->Information = Scb->Header.FileSize.LowPart;
                        NextBuffer->FileOffset = (ULONG) StartingVbo;
                        NextBuffer->Length = (ULONG) ByteRange;
                    }
#endif
                    ByteCount = Header->FileSize.QuadPart - StartingVbo;
                    ByteRange = Header->FileSize.QuadPart;
                }
            }

            NtfsReleaseFsrtlHeader( Scb );

            //
            //  If there is a user-mapped file and a Usn Journal, then try to post a change.
            //  Checkpoint the transaction to reduce resource contention of the UsnJournal
            //  and Mft.
            //

            if (FlagOn(Header->Flags, FSRTL_FLAG_USER_MAPPED_FILE) &&
                FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

                ASSERT( Vcb->UsnJournal != NULL );

                NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_OVERWRITE );
                if (IrpContext->TransactionId != 0) {
                    NtfsCheckpointCurrentTransaction( IrpContext );
                }
            }
        }

        ASSERT( PagingIo || FileObject->WriteAccess || RawEncryptedWrite );
        ASSERT( !(PagingIo && RawEncryptedWrite) );

        //
        //  If the Scb is uninitialized, we initialize it now.
        //  We skip this step for a $INDEX_ALLOCATION stream.  We need to
        //  protect ourselves in the case where an $INDEX_ALLOCATION
        //  stream was created and deleted in an aborted transaction.
        //  In that case we may get a lazy-writer call which will
        //  naturally be nooped below since the valid data length
        //  in the Scb is 0.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            if (Scb->AttributeTypeCode != $INDEX_ALLOCATION) {

                DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );

                //
                //  Acquire and drop the Scb when doing this.
                //
                //  Make sure we don't have any Mft records.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                ScbAcquired = TRUE;
                NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

                NtfsReleaseResource( IrpContext, Scb );
                ScbAcquired = FALSE;

            } else {

                ASSERT( Header->ValidDataLength.QuadPart == Li0.QuadPart );
            }
        }

        //
        //  We assert that Paging Io writes will never WriteToEof.
        //

        ASSERT( !WriteToEof || !PagingIo );

        //
        //  We assert that we never get a non-cached io call for a non-$DATA,
        //  resident attribute.
        //

        ASSERTMSG( "Non-cached I/O call on resident system attribute\n",
                    NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) ||
                    NtfsIsTypeCodeLoggedUtilityStream( Scb->AttributeTypeCode ) ||
                    !NonCachedIo ||
                    !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ));

        //
        //  Here is the deal with ValidDataLength and FileSize:
        //
        //  Rule 1: PagingIo is never allowed to extend file size.
        //
        //  Rule 2: Only the top level requestor may extend Valid
        //          Data Length.  This may be paging IO, as when a
        //          a user maps a file, but will never be as a result
        //          of cache lazy writer writes since they are not the
        //          top level request.
        //
        //  Rule 3: If, using Rules 1 and 2, we decide we must extend
        //          file size or valid data, we take the Fcb exclusive.
        //

        //
        //  Now see if we are writing beyond valid data length, and thus
        //  maybe beyond the file size.  If so, then we must
        //  release the Fcb and reacquire it exclusive.  Note that it is
        //  important that when not writing beyond EOF that we check it
        //  while acquired shared and keep the FCB acquired, in case some
        //  turkey truncates the file.  Note that for paging Io we will
        //  already have acquired the file correctly.
        //

        if (DoingIoAtEof) {

            //
            //  If this was a non-cached asynchronous operation we will
            //  convert it to synchronous.  This is to allow the valid
            //  data length change to go out to disk and to fix the
            //  problem of the Fcb being in the exclusive Fcb list.
            //

            if (!Wait && NonCachedIo) {

                Wait = TRUE;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

            //
            //  If this is async Io to a compressed stream
            //  then we will make this look synchronous.
            //

            } else if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                Wait = TRUE;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
            }

            //
            //  If the Scb is uninitialized, we initialize it now.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );

                //
                //  Acquire and drop the Scb when doing this.
                //
                //  Make sure we don't have any Mft records.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                NtfsAcquireResourceShared( IrpContext, Scb, TRUE );
                ScbAcquired = TRUE;
                NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

                NtfsReleaseResource( IrpContext, Scb );
                ScbAcquired = FALSE;
            }
        }

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!PagingIo && (TypeOfOpen == UserFileOpen)) {

            BOOLEAN Inline = FALSE;
            PVOLUME_DEVICE_OBJECT Vdo = CONTAINING_RECORD( Vcb, VOLUME_DEVICE_OBJECT, Vcb );

            //
            //  For non-fsp, blocking writes that are top level lets complete oplocks inline
            //  Also if an unsafe test shows we're at the overflow queue limit and we're toplevel
            //  also do it inline
            //  

            if (((Vdo->OverflowQueueCount >= OVERFLOW_QUEUE_LIMIT) || CanFsdWait( Irp )) && 
                 !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ) &&
                 NtfsIsTopLevelRequest( IrpContext )) {
                
                SetFlag( IrpContext->Union.NtfsIoContext->Flags, NTFS_IO_CONTEXT_INLINE_OPLOCK );
                Inline = TRUE;
            }

            Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NtfsOplockComplete,
                                       NtfsWriteOplockPrePostIrp );

            if (Status != STATUS_SUCCESS) {

                if ((Status == STATUS_PENDING) && Inline) {

                    Status = STATUS_WAIT_FOR_OPLOCK;
                }

                OplockPostIrp = TRUE;
                PostIrp = TRUE;
                try_return( NOTHING );
            }

            //
            //  This oplock call can affect whether fast IO is possible.
            //  We may have broken an oplock to no oplock held.  If the
            //  current state of the file is FastIoIsNotPossible then
            //  recheck the fast IO state.
            //

            if (Header->IsFastIoPossible == FastIoIsNotPossible) {

                NtfsAcquireFsrtlHeader( Scb );
                Header->IsFastIoPossible = NtfsIsFastIoPossible( Scb );
                NtfsReleaseFsrtlHeader( Scb );
            }

            //
            // We have to check for write access according to the current
            // state of the file locks, and set FileSize from the Fcb.
            //

            if ((Scb->ScbType.Data.FileLock != NULL) &&
                !FsRtlCheckLockForWriteAccess( Scb->ScbType.Data.FileLock, Irp )) {

                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
            }
        }

        //  ASSERT( Header->ValidDataLength.QuadPart <= Header->FileSize.QuadPart);

        //
        //  If we are extending a file size, we may have to extend the allocation.
        //  For a non-resident attribute, this is a call to the add allocation
        //  routine.  For a resident attribute it depends on whether we
        //  can use the change attribute routine to automatically extend
        //  the attribute.
        //

        if (DoingIoAtEof && !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {

            //
            //  EXTENDING THE FILE
            //

            //
            //  If the write goes beyond the allocation size, add some
            //  file allocation.
            //

            if (ByteRange > Header->AllocationSize.QuadPart) {

                BOOLEAN NonResidentPath;

                NtfsAcquireExclusiveScb( IrpContext, Scb );
                ScbAcquired = TRUE;

                NtfsMungeScbSnapshot( IrpContext, Scb, OldFileSize );

                //
                //  We have to deal with both the resident and non-resident
                //  case.  For the resident case we do the work here
                //  only if the new size is too large for the change attribute
                //  value routine.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                    PFILE_RECORD_SEGMENT_HEADER FileRecord;

                    NonResidentPath = FALSE;

                    //
                    //  Now call the attribute routine to change the value, remembering
                    //  the values up to the current valid data length.
                    //

                    NtfsInitializeAttributeContext( &AttrContext );
                    CleanupAttributeContext = TRUE;

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );

                    FileRecord = NtfsContainingFileRecord( &AttrContext );
                    Attribute = NtfsFoundAttribute( &AttrContext );
                    LlTemp1 = (LONGLONG) (Vcb->BytesPerFileRecordSegment
                                                   - FileRecord->FirstFreeByte
                                                   + QuadAlign( Attribute->Form.Resident.ValueLength ));

                    //
                    //  If the new attribute size will not fit then we have to be
                    //  prepared to go non-resident.  If the byte range takes more
                    //  more than 32 bits or this attribute is big enough to move
                    //  then it will go non-resident.  Otherwise we simply may
                    //  end up moving another attribute or splitting the file
                    //  record.
                    //

                    //
                    //  Note, there is an infinitesimal chance that before the Lazy Writer
                    //  writes the data for an attribute which is extending, but fits
                    //  when we check it here, that some other attribute will grow,
                    //  and this attribute no longer fits.  If in addition, the disk
                    //  is full, then the Lazy Writer will fail to allocate space
                    //  for the data when it gets around to writing.  This is
                    //  incredibly unlikely, and not fatal; the Lazy Writer gets an
                    //  error rather than the user.  What we are trying to avoid is
                    //  having to update the attribute every time on small writes
                    //  (also see comments below in NONCACHED RESIDENT ATTRIBUTE case).
                    //

                    if (ByteRange > LlTemp1) {

                        //
                        //  Go ahead and convert this attribute to non-resident.
                        //  Then take the non-resident path below.  There is a chance
                        //  that there was a more suitable candidate to move non-resident
                        //  but we don't want to change the file size until we copy
                        //  the user's data into the cache in case the buffer is
                        //  corrupt.
                        //

                        //
                        //  We must have the paging Io resource exclusive to prevent a
                        //  collided page wait while doing the convert to non-resident.
                        //

                        if (!PagingIo &&
                            !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX ) &&
                            (Scb->Header.PagingIoResource != NULL)) {

                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                        }

                        NtfsConvertToNonresident( IrpContext,
                                                  Fcb,
                                                  Attribute,
                                                  NonCachedIo,
                                                  &AttrContext );

                        NonResidentPath = TRUE;

                    //
                    //  If there is room for the data, we will write a zero
                    //  to the last byte to reserve the space since the
                    //  Lazy Writer cannot grow the attribute with shared
                    //  access.
                    //

                    } else {

                        //
                        //  The attribute will stay resident because we
                        //  have already checked that it will fit.  It will
                        //  not update the file size and valid data size in
                        //  the Scb.
                        //

                        NtfsChangeAttributeValue( IrpContext,
                                                  Fcb,
                                                  (ULONG) ByteRange,
                                                  NULL,
                                                  0,
                                                  TRUE,
                                                  FALSE,
                                                  FALSE,
                                                  FALSE,
                                                  &AttrContext );

                        Header->AllocationSize.LowPart = QuadAlign( (ULONG)ByteRange );
                        Scb->TotalAllocated = Header->AllocationSize.QuadPart;
                    }

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    CleanupAttributeContext = FALSE;

                } else {

                    NonResidentPath = TRUE;
                }

                //
                //  Note that we may have gotten all the space we need when
                //  we converted to nonresident above, so we have to check
                //  again if we are extending.
                //

                if (NonResidentPath &&
                    ByteRange > Scb->Header.AllocationSize.QuadPart) {

                    BOOLEAN AskForMore = TRUE;

                    //
                    //  Assume we start allocating from the current allocation size unless we're
                    //  sparse in which case we'll allocate from the starting compression unit if
                    //  its beyond vdl
                    //

                    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) ||
                        (BlockAlignTruncate( StartingVbo, (LONG)Scb->CompressionUnit) <= Scb->Header.ValidDataLength.QuadPart )) {

                        LlTemp1 = Scb->Header.AllocationSize.QuadPart;
                    } else {
                        LlTemp1 = BlockAlignTruncate( StartingVbo, (LONG)Scb->CompressionUnit );
                    }

                    //
                    //  If we are not writing compressed then we may need to allocate precisely.
                    //  This includes the uncompressed sparse file case
                    //

                    if (!FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED )) {

                        //
                        //  If there is a compression unit then we could be in the process of
                        //  decompressing.  Allocate precisely in this case because we don't
                        //  want to leave any holes.  Specifically the user may have truncated
                        //  the file and is now regenerating it yet the clear compression operation
                        //  has already passed this point in the file (and dropped all resources).
                        //  No one will go back to cleanup the allocation if we leave a hole now.
                        //

                        if (Scb->CompressionUnit != 0) {

                            LlTemp2 = ByteRange + Scb->CompressionUnit - 1;
                            ((PLARGE_INTEGER) &LlTemp2)->LowPart &= ~(Scb->CompressionUnit - 1);
                            LlTemp2 -= LlTemp1;
                            AskForMore = FALSE;

                        //
                        //  Allocate through ByteRange.
                        //

                        } else {

                            LlTemp2 = ByteRange - LlTemp1;
                        }

                    //
                    //  If the file is compressed, we want to limit how far we are
                    //  willing to go beyond ValidDataLength, because we would just
                    //  have to throw that space away anyway in NtfsZeroData.  If
                    //  we would have to zero more than two compression units (same
                    //  limit as NtfsZeroData), then just allocate space where we
                    //  need it.
                    //

                    } else {

                        if ((StartingVbo - Header->ValidDataLength.QuadPart) > (LONGLONG) (Scb->CompressionUnit * 2)) {

                            ASSERT( FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ));

                            LlTemp1 = StartingVbo;
                            ((PLARGE_INTEGER) &LlTemp1)->LowPart &= ~(Scb->CompressionUnit - 1);
                        }

                        //
                        //  Allocate to the end of ByteRange.
                        //

                        LlTemp2 = ByteRange - LlTemp1;
                    }

                    //
                    //
                    //  This will add the allocation and modify the allocation
                    //  size in the Scb.
                    //

                    NtfsAddAllocation( IrpContext,
                                       FileObject,
                                       Scb,
                                       LlClustersFromBytesTruncate( Vcb, LlTemp1 ),
                                       LlClustersFromBytes( Vcb, LlTemp2 ),
                                       AskForMore,
                                       Ccb );

                    //
                    //  Assert that the allocation worked
                    //

                    ASSERT( Header->AllocationSize.QuadPart >= ByteRange ||
                            (Scb->CompressionUnit != 0));

                    SetFlag(Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE);

                    //
                    //  If this is a sparse file lets pad the allocation by adding a
                    //  hole at the end of the allocation.  This will let us utilize
                    //  the fast IO path.
                    //

                    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                        LlTemp2 = Int64ShllMod32( LlTemp2, 3 );

                        if (MAXFILESIZE - Header->AllocationSize.QuadPart > LlTemp2) {

                            NtfsAddSparseAllocation( IrpContext,
                                                     FileObject,
                                                     Scb,
                                                     Header->AllocationSize.QuadPart,
                                                     LlTemp2 );
                        }
                    }
                }

                //
                //  Now that we have grown the attribute, it is important to
                //  checkpoint the current transaction and free all main resources
                //  to avoid the tc type deadlocks.  Note that the extend is ok
                //  to stand in its own right, and the stream will be truncated
                //  on close anyway.
                //

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  Make sure we purge the file record cache as well.  Otherwise
                //  a purge of the Mft may fail in a different thread which owns a resource
                //  this thread needs later.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                //
                //  Growing allocation can change file size (in ChangeAttributeValue).
                //  Make sure we know the correct value for file size to restore.
                //

                OldFileSize = Header->FileSize.QuadPart;
                while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

                    NtfsReleaseFcb( IrpContext,
                                    (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                                            FCB,
                                                            ExclusiveFcbLinks ));
                }

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                              IRP_CONTEXT_FLAG_RELEASE_MFT );

                //
                //  Go through and free any Scb's in the queue of shared
                //  Scb's for transactions.
                //

                if (IrpContext->SharedScb != NULL) {

                    NtfsReleaseSharedResources( IrpContext );
                }

                ScbAcquired = FALSE;
            }

            //
            //  Now synchronize with the FsRtl Header and set FileSize
            //  now so that our reads will not get truncated.
            //

            NtfsAcquireFsrtlHeader( Scb );
            if (ByteRange > Header->FileSize.QuadPart) {
                ASSERT( ByteRange <= Header->AllocationSize.QuadPart );
                Header->FileSize.QuadPart = ByteRange;
                SetFlag( UserFileObject->Flags, FO_FILE_SIZE_CHANGED );
            }
            NtfsReleaseFsrtlHeader( Scb );
        }


        //
        //  HANDLE THE NONCACHED RESIDENT ATTRIBUTE CASE
        //
        //  We let the cached case take the normal path for the following
        //  reasons:
        //
        //    o To insure data coherency if a user maps the file
        //    o To get a page in the cache to keep the Fcb around
        //    o So the data can be accessed via the Fast I/O path
        //    o To reduce the number of calls to NtfsChangeAttributeValue,
        //      to infrequent calls from the Lazy Writer.  Calls to CcCopyWrite
        //      are much cheaper.  With any luck, if the attribute actually stays
        //      resident, we will only have to update it (and log it) once
        //      when the Lazy Writer gets around to the data.
        //
        //  The disadvantage is the overhead to fault the data in the
        //  first time, but we may be able to do this with asynchronous
        //  read ahead.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT | SCB_STATE_CONVERT_UNDERWAY )
            && NonCachedIo) {

            //
            //  The attribute is already resident and we have already tested
            //  if we are going past the end of the file.
            //

            DebugTrace( 0, Dbg, ("Resident attribute write\n") );

            //
            //  If this buffer is not in system space then we can't
            //  trust it.  In that case we will allocate a temporary buffer
            //  and copy the user's data to it.
            //

            SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

            if (!PagingIo && (Irp->RequestorMode != KernelMode)) {

                SafeBuffer = NtfsAllocatePool( NonPagedPool,
                                                (ULONG) ByteCount );

                try {

                    RtlCopyMemory( SafeBuffer, SystemBuffer, (ULONG)ByteCount );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    try_return( Status = STATUS_INVALID_USER_BUFFER );
                }

                SystemBuffer = SafeBuffer;
            }

            //
            //  Make sure we don't have any Mft records.
            //

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsAcquireExclusiveScb( IrpContext, Scb );
            ScbAcquired = TRUE;

            //
            //  If the Scb is uninitialized, we initialize it now.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );

                //
                //  Unlike the other cases, we're already holding the Scb, so
                //  there's no need to acquire & drop it around the Update call.
                //

                NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

                //
                //  Make sure we purge the file record cache as well.  Otherwise
                //  a purge of the Mft may fail in a different thread which owns a resource
                //  this thread needs later.
                //

                NtfsPurgeFileRecordCache( IrpContext );
            }

            
            //
            //  Now see if the file is still resident, and if not
            //  fall through below.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  If this Scb is for an $EA attribute which is now resident then
                //  we don't want to write the data into the attribute.  All resident
                //  EA's are modified directly.
                //

                if (Scb->AttributeTypeCode != $EA) {

                    NtfsInitializeAttributeContext( &AttrContext );
                    CleanupAttributeContext = TRUE;

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );

                    Attribute = NtfsFoundAttribute( &AttrContext );

                    //
                    //  The attribute should already be optionally extended,
                    //  just write the data to it now.
                    //

                    NtfsChangeAttributeValue( IrpContext,
                                              Fcb,
                                              ((ULONG)StartingVbo),
                                              SystemBuffer,
                                              (ULONG)ByteCount,
                                              (BOOLEAN)((((ULONG)StartingVbo) + (ULONG)ByteCount) >
                                                        Attribute->Form.Resident.ValueLength),
                                              FALSE,
                                              FALSE,
                                              FALSE,
                                              &AttrContext );
                }

                //
                //  Make sure the cache FileSizes are updated if this is not paging I/O.
                //

                if (!PagingIo && DoingIoAtEof) {
                    NtfsSetBothCacheSizes( FileObject,
                                           (PCC_FILE_SIZES)&Header->AllocationSize,
                                           Scb );
                }

                Irp->IoStatus.Information = (ULONG)ByteCount;

                try_return( Status = STATUS_SUCCESS );

            //
            //  Gee, someone else made the file nonresident, so we can just
            //  free the resource and get on with life.
            //

            } else {
                NtfsReleaseScb( IrpContext, Scb );
                ScbAcquired = FALSE;
            }
        }

        //
        //  HANDLE THE NON-CACHED CASE
        //

        if (NonCachedIo) {

            ULONG SectorSize;
            ULONG BytesToWrite;

            //
            //  Make sure the cache FileSizes are updated if this is not paging I/O.
            //

            if (!PagingIo && DoingIoAtEof) {
                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Header->AllocationSize,
                                       Scb );
            }

            //
            //  Get the sector size
            //

            SectorSize = Vcb->BytesPerSector;

            //
            //  Round up to a sector boundry
            //

            BytesToWrite = ((ULONG)ByteCount + (SectorSize - 1))
                           & ~(SectorSize - 1);

            //
            //  All requests should be well formed and
            //  make sure we don't wipe out any data
            //

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {

                if ((((ULONG)StartingVbo) & (SectorSize - 1))

                    || ((BytesToWrite != (ULONG)ByteCount)
                        && ByteRange < Header->ValidDataLength.QuadPart )) {

                    //**** we only reach this path via fast I/O and by returning not implemented we
                    //**** force it to return to use via slow I/O

                    DebugTrace( 0, Dbg, ("NtfsCommonWrite -> STATUS_NOT_IMPLEMENTED\n") );

                    try_return( Status = STATUS_NOT_IMPLEMENTED );
                }
            }

            //
            //  If this is a write to an encrypted file then make it synchronous.  We
            //  need to do this so that the encryption driver has a thread to run in.
            //

            if ((Scb->EncryptionContext != NULL) &&
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) &&
                (NtfsData.EncryptionCallBackTable.BeforeWriteProcess != NULL) &&
                NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                Wait = TRUE;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
            }

            //
            // If this noncached transfer is at least one sector beyond
            // the current ValidDataLength in the Scb, then we have to
            // zero the sectors in between.  This can happen if the user
            // has opened the file noncached, or if the user has mapped
            // the file and modified a page beyond ValidDataLength.  It
            // *cannot* happen if the user opened the file cached, because
            // ValidDataLength in the Fcb is updated when he does the cached
            // write (we also zero data in the cache at that time), and
            // therefore, we will bypass this action when the data
            // is ultimately written through (by the Lazy Writer).
            //
            //  For the paging file we don't care about security (ie.
            //  stale data), do don't bother zeroing.
            //
            //  We can actually get writes wholly beyond valid data length
            //  from the LazyWriter because of paging Io decoupling.
            //
            //  We drop this zeroing on the floor in any case where this
            //  request is a recursive write caused by a flush from a higher level write.
            //

            if (Header->ValidDataLength.QuadPart > Scb->ValidDataToDisk) {
                LlTemp1 = Header->ValidDataLength.QuadPart;
            } else {

                //
                //  This can only occur for compressed files
                //

                LlTemp1 = Scb->ValidDataToDisk;
            }

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE ) &&
                !RecursiveWriteThrough &&
                (StartingVbo > LlTemp1)) {

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {

                    CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                    TempEntry = FsRtlLogSyscacheEvent( Scb, SCE_ZERO_NC, Flags, LlTemp1, StartingVbo - LlTemp1, 0);
                }
#endif

                if (!NtfsZeroData( IrpContext,
                                   Scb,
                                   FileObject,
                                   LlTemp1,
                                   StartingVbo - LlTemp1,
                                   &OldFileSize )) {
#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        FsRtlUpdateSyscacheEvent( Scb, TempEntry, Header->ValidDataLength.QuadPart, 0 );
                    }
#endif
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlUpdateSyscacheEvent( Scb, TempEntry, Header->ValidDataLength.QuadPart, 0 );
                }
#endif
            }

            //
            //  If this Scb uses update sequence protection, we need to transform
            //  the blocks to a protected version.  We first allocate an auxilary
            //  buffer and Mdl.  Then we copy the data to this buffer and
            //  transform it.  Finally we attach this Mdl to the Irp and use
            //  it to perform the Io.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT )) {

                TempLength = BytesToWrite;

                //
                //  Find the system buffer for this request and initialize the
                //  local state.
                //

                SystemBuffer = NtfsMapUserBuffer( Irp, HighPagePriority );

                OriginalMdl = Irp->MdlAddress;
                OriginalBuffer = Irp->UserBuffer;
                NewBuffer = NULL;

                //
                //  Protect this operation with a try-finally.
                //

                try {

                    //
                    //  If this is the Mft Scb and the range of bytes falls into
                    //  the range for the Mirror Mft, we generate a write to
                    //  the mirror as well.  Don't do this if we detected a problem
                    //  with the Mft when analyzing the first file records.  We
                    //  can use the presence of the version number in the Vcb
                    //  to tell us this.
                    //

                    if ((Scb == Vcb->MftScb) &&
                        (StartingVbo < Vcb->Mft2Scb->Header.FileSize.QuadPart) &&
                        (Vcb->MajorVersion != 0)) {

                        LlTemp1 = Vcb->Mft2Scb->Header.FileSize.QuadPart - StartingVbo;

                        if ((ULONG)LlTemp1 > BytesToWrite) {

                            (ULONG)LlTemp1 = BytesToWrite;
                        }

                        CcCopyWrite( Vcb->Mft2Scb->FileObject,
                                     (PLARGE_INTEGER)&StartingVbo,
                                     (ULONG)LlTemp1,
                                     TRUE,
                                     SystemBuffer );

                        //
                        //  Now flush this to disk.
                        //

                        CcFlushCache( &Vcb->Mft2Scb->NonpagedScb->SegmentObject,
                                      (PLARGE_INTEGER)&StartingVbo,
                                      (ULONG)LlTemp1,
                                      &Irp->IoStatus );

                        NtfsCleanupTransaction( IrpContext, Irp->IoStatus.Status, TRUE );
                    }

                    //
                    //  Start by allocating buffer and Mdl.
                    //

                    NtfsCreateMdlAndBuffer( IrpContext,
                                            Scb,
                                            RESERVED_BUFFER_ONE_NEEDED,
                                            &TempLength,
                                            &NewMdl,
                                            &NewBuffer );

                    //
                    //  Now transform and write out the original stream.
                    //

                    RtlCopyMemory( NewBuffer, SystemBuffer, BytesToWrite );

                    //
                    //  We copy our Mdl into the Irp and then perform the Io.
                    //

                    Irp->MdlAddress = NewMdl;
                    Irp->UserBuffer = NewBuffer;

                    //
                    //  Now increment the sequence number in both the original
                    //  and copied buffer, and transform the copied buffer.
                    //  If this is the LogFile then adjust the range of the transform.
                    //

                    if ((PAGE_SIZE != LFS_DEFAULT_LOG_PAGE_SIZE) &&
                        (Scb == Vcb->LogFileScb)) {

                        LONGLONG LfsFileOffset;
                        ULONG LfsLength;
                        ULONG LfsBias;

                        LfsFileOffset = StartingVbo;
                        LfsLength = BytesToWrite;

                        LfsCheckWriteRange( &Vcb->LfsWriteData, &LfsFileOffset, &LfsLength );
                        LfsBias = (ULONG) (LfsFileOffset - StartingVbo);

                        NtfsTransformUsaBlock( Scb,
                                               Add2Ptr( SystemBuffer, LfsBias ),
                                               Add2Ptr( NewBuffer, LfsBias ),
                                               LfsLength );

                    } else {

                        NtfsTransformUsaBlock( Scb,
                                               SystemBuffer,
                                               NewBuffer,
                                               BytesToWrite );
                    }

                    ASSERT( Wait );
                    NtfsNonCachedIo( IrpContext,
                                     Irp,
                                     Scb,
                                     StartingVbo,
                                     BytesToWrite,
                                     0 );

                } finally {

                    //
                    //  In all cases we restore the user's Mdl and cleanup
                    //  our Mdl and buffer.
                    //

                    if (NewBuffer != NULL) {

                        Irp->MdlAddress = OriginalMdl;
                        Irp->UserBuffer = OriginalBuffer;

                        NtfsDeleteMdlAndBuffer( NewMdl, NewBuffer );
                    }
                }

            //
            //  Otherwise we simply perform the Io.
            //

            } else {

                ULONG StreamFlags = 0;

                //
                //  Setup async info in the io context before doing non cached io
                //

                if (!Wait) {

                    if (!PagingIo) {
                        NtfsSetIoContextAsync( IrpContext, Scb->Header.PagingIoResource, IrpSp->Parameters.Write.Length );
                    } else {
                        NtfsSetIoContextAsync( IrpContext, NULL, IrpSp->Parameters.Write.Length );
                    }
                }

                //
                //  If the file has an UpdateLsn, then flush the log file before
                //  allowing the data to go out.  The UpdateLsn is synchronized
                //  with the FcbLock.  However, since we are in the process of
                //  doing a write, if we see a 0 in our unsafe test, it is ok
                //  to procede without an LfsFlush.
                //

                if (Fcb->UpdateLsn.QuadPart != 0) {

                    LSN UpdateLsn;

                    NtfsLockFcb( IrpContext, Fcb );
                    UpdateLsn = Fcb->UpdateLsn;
                    Fcb->UpdateLsn.QuadPart = 0;
                    NtfsUnlockFcb( IrpContext, Fcb );
                    LfsFlushToLsn( Vcb->LogHandle, UpdateLsn );
                }

                //
                //  Remember that from this point on we need to restore ValidDataToDisk.
                //  (Doing so earlier can get us into deadlocks if we hit the finally
                //  clause holding the Mft & UsnJournal.)
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                    RestoreValidDataToDisk = TRUE;
                }


                //
                //  Let's decide if there's anything special we need to tell NonCachedIo
                //  about this stream and how we're accessing it.
                //

                if (FileObject->SectionObjectPointer != &Scb->NonpagedScb->SegmentObject) {

                    SetFlag( StreamFlags, COMPRESSED_STREAM );
                }

                if (RawEncryptedWrite) {

                    SetFlag( StreamFlags, ENCRYPTED_STREAM );
                }

#ifdef NTFS_RWC_DEBUG
                if (FlagOn( StreamFlags, COMPRESSED_STREAM )) {

                    if ((StartingVbo < NtfsRWCHighThreshold) &&
                        (StartingVbo + BytesToWrite > NtfsRWCLowThreshold)) {

                        PRWC_HISTORY_ENTRY NextBuffer;

                        NextBuffer = NtfsGetHistoryEntry( Scb );

                        NextBuffer->Operation = WriteCompressed;
                        NextBuffer->Information = 0;
                        NextBuffer->FileOffset = (ULONG) StartingVbo;
                        NextBuffer->Length = (ULONG) BytesToWrite;
                    }
                }
#endif

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {

                    CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );

                    if (DoingIoAtEof && (StartingVbo + BytesToWrite > Scb->Header.FileSize.QuadPart)) {
                        SetFlag( Flags, SCE_FLAG_END_BUFFER );
                    }

                    TempEntry = FsRtlLogSyscacheEvent( Scb, SCE_WRITE, Flags, StartingVbo, BytesToWrite, Status );

                    SystemBuffer = NtfsMapUserBufferNoRaise( Irp, NormalPagePriority );

                    if (DoingIoAtEof && (StartingVbo + BytesToWrite > Scb->Header.FileSize.QuadPart)) {

                        Flags = *((UNALIGNED LONG *)Add2Ptr( SystemBuffer, BytesToWrite - sizeof(LONG) ));

                    } else {

                        Flags = *((UNALIGNED LONG *)SystemBuffer);
                    }

                    FsRtlUpdateSyscacheEvent( Scb, TempEntry, Flags, 0 );
                }
#endif

#if defined( BENL_DBG ) || defined( SYSCACHE_DEBUG )
                try {
#endif


                Status = NtfsNonCachedIo( IrpContext,
                                          Irp,
                                          Scb,
                                          StartingVbo,
                                          BytesToWrite,
                                          StreamFlags );

#if defined( BENL_DBG ) || defined( SYSCACHE_DEBUG )
                } finally {
#endif

#ifdef SYSCACHE_DEBUG
                    if (AbnormalTermination()) {
                        if (ScbIsBeingLogged( Scb )) {

                            FsRtlUpdateSyscacheEvent( Scb, TempEntry, IrpContext->ExceptionStatus, 0 );
                        }
                    }
#endif

#if defined( BENL_DBG ) || defined( SYSCACHE_DEBUG )
                }
#endif

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb ) && !NT_SUCCESS( Status ) && (Status != STATUS_PENDING)) {

                    FsRtlUpdateSyscacheEvent( Scb, TempEntry, Status, 0 );
                }
#endif

                if (Status == STATUS_PENDING) {

                    IrpContext->Union.NtfsIoContext = NULL;
                    PagingIoAcquired = FALSE;
                    Irp = NULL;

                    try_return( Status );
                }
            }

            //
            //  Show that we want to immediately update the Mft.
            //

            UpdateMft = TRUE;

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

                NtfsNormalizeAndRaiseStatus( IrpContext, Status, STATUS_UNEXPECTED_IO_ERROR );

            } else {

                //
                //  Else set the context block to reflect the entire write
                //  Also assert we got how many bytes we asked for.
                //

                ASSERT( Irp->IoStatus.Information == BytesToWrite );

                Irp->IoStatus.Information = (ULONG)ByteCount;
            }

            //
            // The transfer is either complete, or the Iosb contains the
            // appropriate status.
            //

            try_return( Status );

        } // if No Intermediate Buffering


        //
        //  HANDLE THE CACHED CASE
        //

        ASSERT( !PagingIo );

        //
        //  Remember if we need to update the Mft.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            UpdateMft = BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH );
        }

        //
        //  If this write is beyond (valid data length / valid data to disk), then we
        //  must zero the data in between. Only compressed files have a nonzero VDD
        //

        if (Header->ValidDataLength.QuadPart > Scb->ValidDataToDisk) {
            ZeroStart = Header->ValidDataLength.QuadPart;
        } else {
            ZeroStart = Scb->ValidDataToDisk;
        }
        ZeroLength = StartingVbo - ZeroStart;

        //
        // We delay setting up the file cache until now, in case the
        // caller never does any I/O to the file, and thus
        // FileObject->PrivateCacheMap == NULL.  Don't cache the normal
        // stream unless we need to.
        //

        if ((FileObject->PrivateCacheMap == NULL)

                &&

            !FlagOn(IrpContext->MinorFunction, IRP_MN_COMPRESSED) || (ZeroLength > 0)) {

            DebugTrace( 0, Dbg, ("Initialize cache mapping.\n") );

            //
            //  Get the file allocation size, and if it is less than
            //  the file size, raise file corrupt error.
            //

            if (Header->FileSize.QuadPart > Header->AllocationSize.QuadPart) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Now initialize the cache map.  Notice that we may extending
            //  the ValidDataLength with this write call.  At this point
            //  we haven't updated the ValidDataLength in the Scb header.
            //  This way we will get a call from the cache manager
            //  when the lazy writer writes out the data.
            //

            //
            //  Make sure we are serialized with the FileSizes, and
            //  will remove this condition if we abort.
            //

            if (!DoingIoAtEof) {
                FsRtlLockFsRtlHeader( Header );
                IrpContext->CleanupStructure = Scb;
            }

            CcInitializeCacheMap( FileObject,
                                  (PCC_FILE_SIZES)&Header->AllocationSize,
                                  FALSE,
                                  &NtfsData.CacheManagerCallbacks,
                                  Scb );

            if (!DoingIoAtEof) {
                FsRtlUnlockFsRtlHeader( Header );
                IrpContext->CleanupStructure = NULL;
            }

            CcSetReadAheadGranularity( FileObject, READ_AHEAD_GRANULARITY );
        }

        //
        //  Make sure the cache FileSizes are updated.
        //

        if (DoingIoAtEof) {
            NtfsSetBothCacheSizes( FileObject,
                                   (PCC_FILE_SIZES)&Header->AllocationSize,
                                   Scb );
        }

        if (ZeroLength > 0) {

            //
            //  If the caller is writing zeros way beyond ValidDataLength,
            //  then noop it.  We need to wrap the compare in a try-except
            //  to protect ourselves from an invalid user buffer.
            //

            if ((ZeroLength > PAGE_SIZE) &&
                (ByteCount <= sizeof( LARGE_INTEGER ))) {

                ULONG Zeroes;

                try {

                    Zeroes = RtlEqualMemory( NtfsMapUserBuffer( Irp, NormalPagePriority ),
                                             &Li0,
                                             (ULONG)ByteCount );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    try_return( Status = STATUS_INVALID_USER_BUFFER );
                }

                if (Zeroes) {

                    ByteRange = Header->ValidDataLength.QuadPart;
                    Irp->IoStatus.Information = (ULONG)ByteCount;
                    try_return( Status = STATUS_SUCCESS );
                }
            }

            //
            // Call the Cache Manager to zero the data.
            //

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {

                CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                TempEntry = FsRtlLogSyscacheEvent( Scb, SCE_ZERO_C, Flags, ZeroStart, ZeroLength, StartingVbo );
            }
#endif


            if (!NtfsZeroData( IrpContext,
                               Scb,
                               FileObject,
                               ZeroStart,
                               ZeroLength,
                               &OldFileSize )) {
#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlUpdateSyscacheEvent( Scb, TempEntry, Header->ValidDataLength.QuadPart, SCE_FLAG_CANT_WAIT );
                }
#endif
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }
        }


        //
        //  For a compressed stream, we must first reserve the space.
        //

        if ((Scb->CompressionUnit != 0) &&
            !FlagOn(Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE) &&
            !NtfsReserveClusters(IrpContext, Scb, StartingVbo, (ULONG)ByteCount)) {

            //
            //  If the file is only sparse and is fully allocated then there is no
            //  reason to reserve.
            //

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                VCN CurrentVcn;
                LCN CurrentLcn;
                ULONGLONG RemainingClusters;
                ULONGLONG CurrentClusters;

                CurrentVcn = LlClustersFromBytesTruncate( Vcb, StartingVbo );
                RemainingClusters = LlClustersFromBytes( Vcb, StartingVbo + ByteCount );

                while (NtfsLookupAllocation( IrpContext,
                                             Scb,
                                             CurrentVcn,
                                             &CurrentLcn,
                                             &CurrentClusters,
                                             NULL,
                                             NULL )) {

                    if (CurrentClusters >= RemainingClusters) {

                        RemainingClusters = 0;
                        break;
                    }

                    CurrentVcn += CurrentClusters;
                    RemainingClusters -= CurrentClusters;
                }

                if (RemainingClusters != 0) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                }

            } else {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
            }
        }

        //
        //  We need to go through the cache for this
        //  file object.  First handle the noncompressed calls.
        //

        if (!FlagOn(IrpContext->MinorFunction, IRP_MN_COMPRESSED)) {

            //
            //  If there is a compressed section, we have to do cache coherency for
            //  that stream, and loop here to do a Cache Manager view at a time.
            //

#ifdef  COMPRESS_ON_WIRE
            if (Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                LONGLONG LocalOffset = StartingVbo;
                ULONG LocalLength;
                ULONG LengthLeft = (ULONG)ByteCount;

                //
                //  Create the compressed stream if not there.
                //

                if (Header->FileObjectC == NULL) {
                    NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );
                }

                if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                    //
                    //  Get hold of the user's buffer.
                    //

                    SystemBuffer = NtfsMapUserBuffer( Irp );
                }

                //
                //  We must loop to do a view at a time, because that is how much
                //  we synchronize at once below.
                //

                do {

                    //
                    //  Calculate length left in view.
                    //

                    LocalLength = (ULONG)LengthLeft;
                    if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                        LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                    }

                    //
                    //  Synchronize the current view.
                    //

                    Status = NtfsSynchronizeUncompressedIo( Scb,
                                                            &LocalOffset,
                                                            LocalLength,
                                                            TRUE,
                                                            &CompressionSync );

                    //
                    //  If we successfully synchronized, then do a piece of the transfer.
                    //

                    if (NT_SUCCESS(Status)) {

                        if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                            DebugTrace( 0, Dbg, ("Cached write.\n") );

                            //
                            // Do the write, possibly writing through
                            //
                            //  Make sure we don't have any Mft records.
                            //

                            NtfsPurgeFileRecordCache( IrpContext );

                            if (!CcCopyWrite( FileObject,
                                              (PLARGE_INTEGER)&LocalOffset,
                                              LocalLength,
                                              (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                                              SystemBuffer )) {

                                DebugTrace( 0, Dbg, ("Cached Write could not wait\n") );

                                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

                            } else if (!NT_SUCCESS( IrpContext->ExceptionStatus )) {

                                NtfsRaiseStatus( IrpContext, IrpContext->ExceptionStatus, NULL, NULL );
                            }

                            Irp->IoStatus.Status = STATUS_SUCCESS;

                            SystemBuffer = Add2Ptr( SystemBuffer, LocalLength );

                        } else {

                            //
                            //  DO AN MDL WRITE
                            //

                            DebugTrace( 0, Dbg, ("MDL write.\n") );

                            ASSERT( FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT) );

                            //
                            //  If we got this far and then hit a log file full the Mdl will
                            //  already be present.
                            //

                            ASSERT((Irp->MdlAddress == NULL) || (LocalOffset != StartingVbo));

#ifdef NTFS_RWCMP_TRACE
                            if (NtfsCompressionTrace && IsSyscache(Header)) {
                                DbgPrint("CcMdlWrite: FO = %08lx, Len = %08lx\n", (ULONG)LocalOffset, LocalLength );
                            }
#endif

                            CcPrepareMdlWrite( FileObject,
                                               (PLARGE_INTEGER)&LocalOffset,
                                               LocalLength,
                                               &Irp->MdlAddress,
                                               &Irp->IoStatus );
                        }

                        Status = Irp->IoStatus.Status;

                        LocalOffset += LocalLength;
                        LengthLeft -= LocalLength;
                    }

                } while ((LengthLeft != 0) && NT_SUCCESS(Status));

                if (NT_SUCCESS(Status)) {
                    Irp->IoStatus.Information = (ULONG)ByteCount;
                }

                try_return( Status );
            }
#endif

            //
            // DO A NORMAL CACHED WRITE, if the MDL bit is not set,
            //

            if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                DebugTrace( 0, Dbg, ("Cached write.\n") );

                //
                //  Get hold of the user's buffer.
                //

                SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

                //
                // Do the write, possibly writing through
                //
                //  Make sure we don't have any Mft records.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                if (!CcCopyWrite( FileObject,
                                  (PLARGE_INTEGER)&StartingVbo,
                                  (ULONG)ByteCount,
                                  (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                                  SystemBuffer )) {

                    DebugTrace( 0, Dbg, ("Cached Write could not wait\n") );

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

                } else if (!NT_SUCCESS( IrpContext->ExceptionStatus )) {

                    NtfsRaiseStatus( IrpContext, IrpContext->ExceptionStatus, NULL, NULL );
                }

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG)ByteCount;

                try_return( Status = STATUS_SUCCESS );

            } else {

                //
                //  DO AN MDL WRITE
                //

                DebugTrace( 0, Dbg, ("MDL write.\n") );

                ASSERT( FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT) );

                //
                //  If we got this far and then hit a log file full the Mdl will
                //  already be present.
                //

                ASSERT(Irp->MdlAddress == NULL);

#ifdef NTFS_RWCMP_TRACE
                if (NtfsCompressionTrace && IsSyscache(Header)) {
                    DbgPrint("CcMdlWrite: FO = %08lx, Len = %08lx\n", (ULONG)StartingVbo, (ULONG)ByteCount );
                }
#endif

                CcPrepareMdlWrite( FileObject,
                                   (PLARGE_INTEGER)&StartingVbo,
                                   (ULONG)ByteCount,
                                   &Irp->MdlAddress,
                                   &Irp->IoStatus );

                Status = Irp->IoStatus.Status;

                ASSERT( NT_SUCCESS( Status ));

                try_return( Status );
            }

        //
        //  Handle the compressed calls.
        //

        } else {

#ifdef  COMPRESS_ON_WIRE

            ASSERT((StartingVbo & (NTFS_CHUNK_SIZE - 1)) == 0);

            //
            //  Get out if COW is not supported.
            //

            if (!NtfsEnableCompressedIO) {

                NtfsRaiseStatus( IrpContext, STATUS_UNSUPPORTED_COMPRESSION, NULL, NULL );
            }


            if ((Scb->Header.FileObjectC == NULL) ||
                (Scb->Header.FileObjectC->PrivateCacheMap == NULL)) {

                //
                //  Don't do compressed IO on a stream which is changing its
                //  compression state.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE )) {

                    NtfsRaiseStatus( IrpContext, STATUS_UNSUPPORTED_COMPRESSION, NULL, NULL );
                }

                //
                //  Make sure we are serialized with the FileSizes, and
                //  will remove this condition if we abort.
                //

                if (!DoingIoAtEof) {
                    FsRtlLockFsRtlHeader( Header );
                    IrpContext->CleanupStructure = Scb;
                }

                NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );

                if (!DoingIoAtEof) {
                    FsRtlUnlockFsRtlHeader( Header );
                    IrpContext->CleanupStructure = NULL;
                }
            }

            //
            //  Make sure the cache FileSizes are updated.
            //

            if (DoingIoAtEof) {
                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Header->AllocationSize,
                                       Scb );
            }

            //
            //  Assume success.
            //

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG)(ByteRange - StartingVbo);

            //
            //  Based on the Mdl minor function, set up the appropriate
            //  parameters for the call below.  (NewMdl is not exactly the
            //  right type, so it is cast...)
            //

            if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                //
                //  Get hold of the user's buffer.
                //

                SystemBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
                NewMdl = NULL;

            } else {

                //
                //  We will deliver the Mdl directly to the Irp.
                //

                SystemBuffer = NULL;
                NewMdl = (PMDL)&Irp->MdlAddress;
            }

            CompressedDataInfo = (PCOMPRESSED_DATA_INFO)IrpContext->Union.AuxiliaryBuffer->Buffer;

            //
            //  Calculate the compression unit and chunk sizes.
            //

            CompressionUnitSize = Scb->CompressionUnit;
            ChunkSize = 1 << CompressedDataInfo->ChunkShift;

            //
            //  See if the engine matches, so we can pass that on to the
            //  compressed write routine.
            //

            EngineMatches =
              ((CompressedDataInfo->CompressionFormatAndEngine == ((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1)) &&
               (CompressedDataInfo->ChunkShift == NTFS_CHUNK_SHIFT));

            //
            //  Do the compressed write in common code with the Fast Io path.
            //  We do it from a loop because we may need to create the other
            //  data stream.
            //

            while (TRUE) {

                Status = NtfsCompressedCopyWrite( FileObject,
                                                  (PLARGE_INTEGER)&StartingVbo,
                                                  (ULONG)ByteCount,
                                                  SystemBuffer,
                                                  (PMDL *)NewMdl,
                                                  CompressedDataInfo,
                                                  IoGetRelatedDeviceObject(FileObject),
                                                  Header,
                                                  Scb->CompressionUnit,
                                                  NTFS_CHUNK_SIZE,
                                                  EngineMatches );

                //
                //  On successful Mdl requests we hang on to the PagingIo resource.
                //

                if ((NewMdl != NULL) && NT_SUCCESS(Status) && (*((PMDL *) NewMdl) != NULL)) {
                    PagingIoAcquired = FALSE;
                }

                //
                //  Check for the status that says we need to create the normal
                //  data stream, else we are done.
                //

                if (Status != STATUS_NOT_MAPPED_DATA) {
                    break;
                }

                //
                //  Create the normal data stream and loop back to try again.
                //

                ASSERT(Scb->FileObject == NULL);

                //
                //  Make sure we are serialized with the FileSizes, and
                //  will remove this condition if we abort.
                //

                if (!DoingIoAtEof) {
                    FsRtlLockFsRtlHeader( Header );
                    IrpContext->CleanupStructure = Scb;
                }

                NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

                if (!DoingIoAtEof) {
                    FsRtlUnlockFsRtlHeader( Header );
                    IrpContext->CleanupStructure = NULL;
                }
            }
#endif
        }


    try_exit: NOTHING;

        if (Irp) {

            if (PostIrp) {

                //
                //  If we acquired this Scb exclusive, we won't need to release
                //  the Scb.  That is done in the oplock post request.
                //

                if (OplockPostIrp) {

                    ScbAcquired = FALSE;
                }

            //
            //  If we didn't post the Irp, we may have written some bytes to the
            //  file.  We report the number of bytes written and update the
            //  file object for synchronous writes.
            //

            } else {

                DebugTrace( 0, Dbg, ("Completing request with status = %08lx\n", Status) );

                DebugTrace( 0, Dbg, ("                   Information = %08lx\n",
                            Irp->IoStatus.Information));

                //
                //  Record the total number of bytes actually written
                //

                LlTemp1 = Irp->IoStatus.Information;

                //
                //  If the file was opened for Synchronous IO, update the current
                //  file position.
                //

                if (SynchronousIo && !PagingIo) {

                    UserFileObject->CurrentByteOffset.QuadPart = StartingVbo + LlTemp1;
                }

                //
                //  The following are things we only do if we were successful
                //

                if (NT_SUCCESS( Status )) {

                    //
                    //  Mark that the modify time needs to be updated on close.
                    //  Note that only the top level User requests will generate
                    //  correct

                    if (!PagingIo) {

                        //
                        //  Set the flag in the file object to know we modified this file.
                        //

                        SetFlag( UserFileObject->Flags, FO_FILE_MODIFIED );

                    //
                    //  On successful paging I/O to a compressed or sparse data stream
                    //  which is not mapped, try to free any reserved space for the stream.
                    //  Note: mapped compressed streams will generally not free reserved
                    //  space
                    //

                    } else if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                        NtfsFreeReservedClusters( Scb,
                                                  StartingVbo,
                                                  (ULONG) Irp->IoStatus.Information );
                    }

                    //
                    //  If we extended the file size and we are meant to
                    //  immediately update the dirent, do so. (This flag is
                    //  set for either WriteThrough or noncached, because
                    //  in either case the data and any necessary zeros are
                    //  actually written to the file.)  Note that a flush of
                    //  a user-mapped file could cause VDL to get updated the
                    //  first time because we never had a cached write, so we
                    //  have to be sure to update VDL here in that case as well.
                    //

                    if (DoingIoAtEof) {

                        CC_FILE_SIZES CcFileSizes;

                        //
                        //  If we know this has gone to disk we update the Mft.
                        //  This variable should never be set for a resident
                        //  attribute.
                        //  The lazy writer uses callbacks to have the filesizes updated on disk
                        //  so we don't do any of this here
                        //

                        if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE )) {

                            if (UpdateMft) {

                                //
                                //  Get the Scb if we don't already have it.
                                //

                                if (!ScbAcquired) {

                                    //
                                    //  Make sure we don't have any Mft records.
                                    //

                                    NtfsPurgeFileRecordCache( IrpContext );
                                    NtfsAcquireExclusiveScb( IrpContext, Scb );
                                    ScbAcquired = TRUE;

                                    if (FlagOn( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY )) {

                                        goto RestoreUnderway;
                                    }

                                    NtfsMungeScbSnapshot( IrpContext, Scb, OldFileSize );

                                } else if (FlagOn( Scb->ScbState, SCB_STATE_RESTORE_UNDERWAY )) {

                                    goto RestoreUnderway;
                                }

                                //
                                //  Start by capturing any file size changes.
                                //

                                NtfsUpdateScbFromFileObject( IrpContext, UserFileObject, Scb, FALSE );

                                //
                                //  Write a log entry to update these sizes.
                                //

                                NtfsWriteFileSizes( IrpContext,
                                                    Scb,
                                                    &ByteRange,
                                                    TRUE,
                                                    TRUE,
                                                    TRUE );

                                //
                                //  Clear the check attribute size flag.
                                //

                                NtfsAcquireFsrtlHeader( Scb );
                                ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );

                            //
                            //  Otherwise we set the flag indicating that we need to
                            //  update the attribute size.
                            //

                            } else {

                            RestoreUnderway:

                                NtfsAcquireFsrtlHeader( Scb );
                                SetFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
                            }
                        } else {
                            NtfsAcquireFsrtlHeader( Scb );
                        }

                        ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE ) ||
                                ByteRange <= ((Header->ValidDataLength.QuadPart + PAGE_SIZE - 1) & ~((LONGLONG) (PAGE_SIZE - 1))) );

                        //
                        //  Now is the time to update valid data length.
                        //  The Eof condition will be freed when we commit.
                        //

                        if (ByteRange > Header->ValidDataLength.QuadPart) {

                            Header->ValidDataLength.QuadPart = ByteRange;

#ifdef SYSCACHE_DEBUG
                            if (ScbIsBeingLogged( Scb )) {

                                CalculateSyscacheFlags( IrpContext, Flags, SCE_FLAG_WRITE );
                                FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, Flags, StartingVbo, ByteCount, ByteRange );
                            }
#endif
                        }
                        CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
                        DoingIoAtEof = FALSE;

                        //
                        //  Inform Cc that we changed the VDL for non cached toplevel
                        //

                        if (CcIsFileCached( FileObject ) && NonCachedIo) {
                            NtfsSetBothCacheSizes( FileObject, &CcFileSizes, Scb );
                        } else {

                            //
                            //  If there is a compressed section, then update both file sizes to get
                            //  the ValidDataLength update in the one we did not write.
                            //

#ifdef  COMPRESS_ON_WIRE
                            if (Header->FileObjectC != NULL) {
                                if (FlagOn(IrpContext->MinorFunction, IRP_MN_COMPRESSED)) {
                                    if (Scb->NonpagedScb->SegmentObject.SharedCacheMap != NULL) {
                                        CcSetFileSizes( FileObject, &CcFileSizes );
                                    }
                                } else {
                                    CcSetFileSizes( Header->FileObjectC, &CcFileSizes );
                                }
                            }
#endif
                        }

                        NtfsReleaseFsrtlHeader( Scb );
                    }
                }

                //
                //  Abort transaction on error by raising.  If this is the log file itself
                //  then just return normally.
                //

                NtfsPurgeFileRecordCache( IrpContext );

                if (Scb != Scb->Vcb->LogFileScb) {

                    NtfsCleanupTransaction( IrpContext, Status, FALSE );
                }
            }
        }

    } finally {

        DebugUnwind( NtfsCommonWrite );

        //
        //  Clean up any Bcb from read/synchronize compressed.
        //
#ifdef  COMPRESS_ON_WIRE
        if (CompressionSync != NULL) {
            NtfsReleaseCompressionSync( CompressionSync );
        }
#endif

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        if (SafeBuffer) {

            NtfsFreePool( SafeBuffer );
        }

        //
        //  Now is the time to restore FileSize on errors.
        //  The Eof condition will be freed when we commit.
        //

        if (DoingIoAtEof && !PagingIo) {

            //
            //  Acquire the main resource to knock valid data to disk back.
            //

            if (RestoreValidDataToDisk) {

                //
                //  Make sure we purge the file record cache as well.  Otherwise
                //  a purge of the Mft may fail in a different thread which owns a resource
                //  this thread needs.
                //

                NtfsPurgeFileRecordCache( IrpContext );
                NtfsAcquireExclusiveScb( IrpContext, Scb );

                if (Scb->ValidDataToDisk > OldFileSize) {
                    Scb->ValidDataToDisk = OldFileSize;
                }

                NtfsReleaseScb( IrpContext, Scb );
            }

            NtfsAcquireFsrtlHeader( Scb );

            //
            //  Always force a recalc for write at eof unless we've commited the filesize
            //  forward. In that case we should write at the calculated offset unless the
            //  file shrinks in between. See test at beginning of common write
            //

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF ) &&
                OldFileSize == IrpSp->Parameters.Write.ByteOffset.QuadPart) {

                ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WRITING_AT_EOF );
                IrpSp->Parameters.Write.ByteOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
                IrpSp->Parameters.Write.ByteOffset.HighPart = -1;
            }

            Header->FileSize.QuadPart = OldFileSize;

            ASSERT( Header->ValidDataLength.QuadPart <= Header->FileSize.QuadPart );

            if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                CcGetFileSizePointer(FileObject)->QuadPart = OldFileSize;
            }
#ifdef COMPRESS_ON_WIRE
            if (Header->FileObjectC != NULL) {
                CcGetFileSizePointer(Header->FileObjectC)->QuadPart = OldFileSize;
            }
#endif
            NtfsReleaseFsrtlHeader( Scb );

        }

        //
        //  If the Scb or PagingIo resource has been acquired, release it.
        //

        if (PagingIoAcquired) {
            ExReleaseResourceLite( Header->PagingIoResource );
        }

        if (Irp) {

            if (ScbAcquired) {
                NtfsReleaseScb( IrpContext, Scb );
            }

            //
            //  Now remember to clear the WriteSeen flag if we set it. We only
            //  do this if there is still an Irp.  It is possible for the current
            //  Irp to be posted or asynchronous.  In that case this is a top
            //  level request and the cleanup happens elsewhere.  For synchronous
            //  recursive cases the Irp will still be here.
            //

            if (SetWriteSeen) {
                ClearFlag(IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN);
            }
        }


        DebugTrace( -1, Dbg, ("NtfsCommonWrite -> %08lx\n", Status) );
    }

    //
    //  Complete the request if we didn't post it and no exception
    //
    //  Note that NtfsCompleteRequest does the right thing if either
    //  IrpContext or Irp are NULL
    //
    if (!PostIrp) {

        NtfsCompleteRequest( IrpContext, Irp, Status );

    } else if (!OplockPostIrp) {

        Status = NtfsPostRequest( IrpContext, Irp );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS NtfsGetIoAtEof (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG StartingVbo,
    IN LONGLONG ByteCount,
    IN BOOLEAN Wait,
    OUT PBOOLEAN DoingIoAtEof,
    OUT PLONGLONG OldFileSize
    )

{
    //
    //  Our caller may already be synchronized with EOF.
    //  The FcbWithPaging field in the top level IrpContext
    //  will have either the current Fcb/Scb if so.
    //

    if ((IrpContext->TopLevelIrpContext->CleanupStructure == Scb->Fcb) ||
        (IrpContext->TopLevelIrpContext->CleanupStructure == Scb)) {

        *DoingIoAtEof = TRUE;
        *OldFileSize = Scb->Header.FileSize.QuadPart;

    } else {

        if (FlagOn( Scb->Header.Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) && !Wait) {
            return STATUS_FILE_LOCK_CONFLICT;
        }

        *DoingIoAtEof = !FlagOn( Scb->Header.Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                       NtfsWaitForIoAtEof( &(Scb->Header), (PLARGE_INTEGER)&StartingVbo, (ULONG)ByteCount );

        //
        //  Set the Flag if we are changing FileSize or ValidDataLength,
        //  and save current values.
        //

        if (*DoingIoAtEof) {

            SetFlag( Scb->Header.Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
#if (DBG || defined( NTFS_FREE_ASSERTS ))
            Scb->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

            //
            //  Store this in the IrpContext until commit or post
            //

            IrpContext->CleanupStructure = Scb;
            *OldFileSize = Scb->Header.FileSize.QuadPart;

#if (DBG || defined( NTFS_FREE_ASSERTS ))
        } else {

            ASSERT( Scb->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\fsfile.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsfile.c

Abstract:

    This file contains code for commands that affect
    individual files.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>

//----------------------------------
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>

#define MAX_ALLOC_RANGES                          32

//
//  Common command line args
//

#define ARG_OFFSET      L"offset="
#define ARG_OFFSET_LEN  7

#define ARG_LENGTH      L"length="
#define ARG_LENGTH_LEN  7

INT
FileHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_FILE );
    return EXIT_CODE_SUCCESS;
}

INT
FindFilesBySid(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine finds file owned by the user specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl findbysid <user> <pathname>'.

Return Value:

    None

--*/
{
    #define SID_MAX_LENGTH  (FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOL Status;

    struct {
        ULONG Restart;
        BYTE Sid[SID_MAX_LENGTH];
    } InBuffer;

    DWORD nInBufferSize;
    DWORD BytesReturned;
    ULONG SidLength = sizeof( InBuffer.Sid );
    WCHAR Domain[MAX_PATH];
    ULONG DomainLength = sizeof( Domain );
    SID_NAME_USE SidNameUse;
    DWORD nOutBufferSize;
    PBYTE lpOutBuffer;
    PFILE_NAME_INFORMATION FileNameInfo;
    ULONG Length;
    PWSTR Filename;
    ULONG Found = 0;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_FINDBYSID );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[1] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nInBufferSize = sizeof(InBuffer);

        nOutBufferSize = 32768;
        lpOutBuffer = (PBYTE) malloc( nOutBufferSize );
        if (lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        memset( lpOutBuffer, 0, nOutBufferSize );
        memset( &InBuffer, 0, sizeof(InBuffer) );

        if (!LookupAccountName(
                NULL,
                argv[0],
                InBuffer.Sid,
                &SidLength,
                Domain,
                &DomainLength,
                &SidNameUse
                ))
        {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        InBuffer.Restart = 1;

        do {
            Status = DeviceIoControl(
                FileHandle,
                FSCTL_FIND_FILES_BY_SID,
                &InBuffer,
                nInBufferSize,
                lpOutBuffer,
                nOutBufferSize,
                &BytesReturned,
                (LPOVERLAPPED)NULL
                );
            if (!Status) {
                DisplayError();
                ExitCode = EXIT_CODE_FAILURE;
                leave;
            }

            InBuffer.Restart = 0;
            FileNameInfo = (PFILE_NAME_INFORMATION) lpOutBuffer;
            while ((PBYTE)FileNameInfo < lpOutBuffer + BytesReturned) {
                Length = sizeof( FILE_NAME_INFORMATION ) - sizeof( WCHAR ) + FileNameInfo->FileNameLength;
                
                OutputMessageLength( FileNameInfo->FileName, FileNameInfo->FileNameLength / sizeof( WCHAR ));
                OutputMessage( L"\r\n" );
                FileNameInfo = (PFILE_NAME_INFORMATION) Add2Ptr( FileNameInfo, QuadAlign( Length ) );
                Found += 1;
            }
        } while (Status && BytesReturned);

        if (Found == 0) {
            DisplayMsg( MSG_FINDFILESBYSID_NONE );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( lpOutBuffer );
        free( Filename );
    }

    return ExitCode;
}


INT
SetZeroData(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine sets zero data for the range in the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setzero offset=<val> beyond=<val> <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    PWSTR EndPtr;
    BOOL Status;
    PFILE_ZERO_DATA_INFORMATION lpInBuffer;
    DWORD nInBufferSize;
    DWORD BytesReturned;
    ULONGLONG Offset;
    ULONGLONG Length;
    ULONGLONG Beyond;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 3) {
            DisplayMsg( MSG_SETZERO_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[2] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (_wcsnicmp( argv[0], ARG_OFFSET, ARG_OFFSET_LEN)) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        Offset = My_wcstoui64( argv[0] + ARG_OFFSET_LEN, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Offset, EndPtr )) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        if (_wcsnicmp( argv[1], ARG_LENGTH, ARG_LENGTH_LEN)) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        Length = My_wcstoui64( argv[1] + ARG_LENGTH_LEN, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Length, EndPtr )) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Beyond = Offset + Length;
        if (Beyond < Offset) {
            DisplayMsg( MSG_SETZERO_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nInBufferSize = sizeof(FILE_ZERO_DATA_INFORMATION);
        lpInBuffer = (PFILE_ZERO_DATA_INFORMATION) malloc ( nInBufferSize );
        if (lpInBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        lpInBuffer->FileOffset.QuadPart = Offset;
        lpInBuffer->BeyondFinalZero.QuadPart = Beyond;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_SET_ZERO_DATA,
            (LPVOID) lpInBuffer,
            nInBufferSize,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
        } else {
            DisplayMsg( MSG_SET_ZERODATA );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (Filename) {
            free( Filename );
        }
    }

    return ExitCode;
}


INT
QueryAllocatedRanges(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine scans for any allocated range within the range
    specified in the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl qryalcrnge offset=<val> length=<val> <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    PWSTR EndPtr;
    BOOL Status;
    PFILE_ALLOCATED_RANGE_BUFFER lpInBuffer = NULL;
    DWORD nInBufferSize;
    PFILE_ALLOCATED_RANGE_BUFFER *lpOutBuffer = NULL;
    PFILE_ALLOCATED_RANGE_BUFFER pBuffer;
    DWORD nOutBufferSize;
    DWORD BytesReturned;
    ULARGE_INTEGER Offset;
    ULARGE_INTEGER Length;
    INT NumberOfBuffers;
    INT Index;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 3) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[2] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Offset.QuadPart = Length.QuadPart = 0;

        if (_wcsnicmp( argv[0], ARG_OFFSET, ARG_OFFSET_LEN )) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        Offset.QuadPart = My_wcstoui64( argv[0] + ARG_OFFSET_LEN, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Offset.QuadPart, EndPtr)) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        if (_wcsnicmp( argv[1], ARG_LENGTH, ARG_LENGTH_LEN )) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        Length.QuadPart = My_wcstoui64( argv[1] + ARG_LENGTH_LEN, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Length.QuadPart, EndPtr )) {
            DisplayMsg( MSG_ALLOCRANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nInBufferSize = sizeof(FILE_ALLOCATED_RANGE_BUFFER);
        lpInBuffer = (PFILE_ALLOCATED_RANGE_BUFFER) malloc ( nInBufferSize );
        nOutBufferSize = sizeof(FILE_ALLOCATED_RANGE_BUFFER) * MAX_ALLOC_RANGES;
        lpOutBuffer = (PFILE_ALLOCATED_RANGE_BUFFER *) calloc ( MAX_ALLOC_RANGES, sizeof(FILE_ALLOCATED_RANGE_BUFFER) );

        if (lpInBuffer == NULL || lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpInBuffer->FileOffset.QuadPart = Offset.QuadPart;
        lpInBuffer->Length.QuadPart = Length.QuadPart;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_QUERY_ALLOCATED_RANGES,
            (LPVOID) lpInBuffer,
            nInBufferSize,
            lpOutBuffer,
            nOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        pBuffer = (PFILE_ALLOCATED_RANGE_BUFFER) lpOutBuffer ;
        NumberOfBuffers = (BytesReturned) / sizeof(FILE_ALLOCATED_RANGE_BUFFER);

        for ( Index=0; Index<NumberOfBuffers; Index++ ) {
            DisplayMsg( MSG_ALLOCRANGE_RANGES, Index, QuadToHexText( pBuffer[Index].FileOffset.QuadPart ), QuadToHexText( pBuffer[Index].Length.QuadPart ));
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
        free( lpInBuffer );
        free( lpOutBuffer );
    }

    return ExitCode;
}


typedef BOOL
(WINAPI *PSETFILEVALIDDATA)(
    IN HANDLE hFile,
    IN LONGLONG ValidDataLength
    );

PSETFILEVALIDDATA pSetFileValidData = NULL;

BOOL WINAPI
DefaultSetFileValidData(
    IN HANDLE hFile,
    IN LONGLONG ValidDataLength
    )
{
    return FALSE;
}


INT
SetValidDataLength(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_VALID_DATA );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if(!EnablePrivilege( SE_MANAGE_VOLUME_NAME )) {
            DisplayError( );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        hFile = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (hFile == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!RunningOnWin2K) {
            LONGLONG ValidDataLength;
            PWSTR EndStr;
            
            if (pSetFileValidData == NULL) {
                pSetFileValidData = (PSETFILEVALIDDATA) GetProcAddress( GetModuleHandle(L"KERNEL32.DLL"), "SetFileValidData" );
            } else {
                pSetFileValidData = DefaultSetFileValidData;
            }
            
            ValidDataLength = My_wcstoui64( argv[1], &EndStr, 0 );
            if (UnsignedI64NumberCheck( ValidDataLength, EndStr )
                || !pSetFileValidData( hFile, ValidDataLength)
                ) {
                DisplayError( );
                ExitCode = EXIT_CODE_FAILURE;
            } else {
                DisplayMsg( MSG_SET_VDL );
            }
        }

    } finally {

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
        }
        free( Filename );
    }

    return ExitCode;
}


typedef BOOL
(WINAPI *PSETFILESHORTNAMEW)(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    );

BOOL WINAPI
DoNothingSetShortName(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    )
{
    return FALSE;
}


BOOL WINAPI
InitialSetShortName(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    );

PSETFILESHORTNAMEW pSetFileShortName = InitialSetShortName;

BOOL WINAPI
InitialSetShortName(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    )
{
    HANDLE Handle = GetModuleHandle( L"KERNEL32.DLL" );
    FARPROC Proc;

    if (Handle == INVALID_HANDLE_VALUE) {
        pSetFileShortName = DoNothingSetShortName;
    } else if ((Proc = GetProcAddress( Handle, "SetFileShortNameW" )) != NULL) {
        pSetFileShortName = (PSETFILESHORTNAMEW) Proc;
    } else {
        pSetFileShortName = DoNothingSetShortName;
    }

    return pSetFileShortName( hFile, lpShortName );
}


INT
SetShortName(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_SHORTNAME, argv[1] );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!EnablePrivilege( SE_RESTORE_NAME )) {
            DisplayError( );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        hFile = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (hFile == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!RunningOnWin2K) {
            if (!pSetFileShortName( hFile, argv[1] )) {
                DisplayError();
                ExitCode = EXIT_CODE_FAILURE;
            }
        }

    } finally {

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
        }
        free( Filename );
    }

    return ExitCode;
}

INT
CreateNewFile(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    LARGE_INTEGER Length;
    BOOL GoodFile = TRUE;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {
        PWSTR EndPtr;

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_CREATEFILE, argv[1] );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Length.QuadPart = My_wcstoui64( argv[1], &EndPtr, 0 );
        if (UnsignedI64NumberCheck( Length.QuadPart, EndPtr )) {
            DisplayMsg( MSG_USAGE_CREATEFILE, argv[1] );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        hFile = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
            0,
            NULL,
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        
        if (hFile == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        GoodFile = FALSE;

        if (!SetFilePointerEx( hFile, Length, NULL, FILE_BEGIN )) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!SetEndOfFile( hFile )) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        GoodFile = TRUE;
        DisplayMsg( MSG_CREATEFILE_SUCCEEDED, Filename );

    } finally {

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
        }
        if (!GoodFile) {
            DeleteFile( Filename );
        }
        free( Filename );
    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\fsinfo.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsinfo.c

Abstract:

    This file contains code for commands that affect
    information specific to the file system.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
FsInfoHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_FSINFO );
    return EXIT_CODE_SUCCESS;
}

typedef struct _NTFS_FILE_SYSTEM_STATISTICS {
        FILESYSTEM_STATISTICS Common;
        NTFS_STATISTICS Ntfs;
        UCHAR Pad[64-(sizeof(FILESYSTEM_STATISTICS)+sizeof(NTFS_STATISTICS))%64];
} NTFS_FILE_SYSTEM_STATISTICS, *PNTFS_FILE_SYSTEM_STATISTICS;

typedef struct _FAT_FILE_SYSTEM_STATISTICS {
        FILESYSTEM_STATISTICS Common;
        FAT_STATISTICS Fat;
        UCHAR Pad[64-(sizeof(FILESYSTEM_STATISTICS)+sizeof(NTFS_STATISTICS))%64];
} FAT_FILE_SYSTEM_STATISTICS, *PFAT_FILE_SYSTEM_STATISTICS;



ULONGLONG
FsStat(
    IN PVOID FsStats,
    IN ULONG FsSize,
    IN ULONG Offset,
    IN ULONG NumProcs
    )
/*++

Routine Description:

    This routine iterates through the file system statistics structure
    and accumulates a total amount for a given statistic field.

    Note: This function assumes that the width of the field being accumulated
          is a ULONG.  If this assumption is invalidated then a width argument
          should be added to this function.

Arguments:

    FsStats - Pointer to an array of file system statistics structures
    FsSize - Size of the individual file system statistics structures in the array
    Offset - Offset of the desired field from the beginning of the file system statistics structure
    NumProcs - Number of processors on the machine where the stats were gathered

Return Value:

    Accumulated total.

--*/
{
    ULONG i;
    ULONGLONG Total = 0;

    for (i=0; i<NumProcs; i++) {
        Total += *(PULONG)((PUCHAR)FsStats + Offset);
        FsStats = (PVOID)((PUCHAR)FsStats + FsSize);
    }

    return Total;
}


INT
ListDrives(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine lists all the drive names in the system.

Arguments:

    argc - The argument count
    argv - Array of Strings of the form : 'fscutl lsdrv'.

Return Value:

    None

--*/
{
    DWORD nBufferLen = MAX_PATH;
    DWORD Length;
    LPWSTR lpBuffer = NULL;
    int Index;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 0) {
            DisplayMsg( MSG_LISTDRIVES_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpBuffer = (LPWSTR) malloc( nBufferLen * sizeof(WCHAR) );
        if (!lpBuffer) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Length = GetLogicalDriveStrings( nBufferLen, lpBuffer );
        if (!Length) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        OutputMessage( L"\r\n" );
        DisplayMsg( MSG_DRIVES );
        Index = 0;
        while ((Length = wcslen( &lpBuffer[Index] )) != 0) {
            OutputMessageLength( &lpBuffer[Index], Length );
            OutputMessage( L" " );
            Index += Length + 1;
        }
        OutputMessage( L"\r\n" );

    } finally {

        if (lpBuffer) {
            free( lpBuffer );
        }

    }
    return ExitCode;
}


INT
DriveType(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine describes the drive type of the drive passed in.

Arguments:

    argc - The argument count
    argv - Array of Strings of the form :
          'fscutl dt <drive name>' or
          'fscutl drivetype <drive name>'

Return Value:

   None

--*/
{
    if (argc != 1) {
        DisplayMsg( MSG_USAGE_DRIVETYPE );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    switch (GetDriveType( argv[0] )) {
    case DRIVE_NO_ROOT_DIR:
        DisplayMsg( MSG_DRIVE_NO_ROOT_DIR, argv[0] );
        break;
    case DRIVE_REMOVABLE:
        DisplayMsg( MSG_DRIVE_REMOVABLE, argv[0] );
        break;
    case DRIVE_FIXED:
        DisplayMsg( MSG_DRIVE_FIXED, argv[0] );
        break;
    case DRIVE_REMOTE:
        DisplayMsg( MSG_DRIVE_REMOTE, argv[0] );
        break;
    case DRIVE_CDROM:
        DisplayMsg( MSG_DRIVE_CDROM, argv[0] );
        break;
    case DRIVE_RAMDISK:
        DisplayMsg( MSG_DRIVE_RAMDISK, argv[0] );
        break;
    case DRIVE_UNKNOWN:
    default:
        DisplayMsg( MSG_DRIVE_UNKNOWN, argv[0] );
        break;
    }
    return EXIT_CODE_SUCCESS;
}


INT
VolumeInfo(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine provides the information about the Volume.

Arguments:

    argc - The argument count
    argv - Array of Strings of the form :
           'fscutl infov <root pathname>'.

Return Value:

    None

--*/
{
    LPWSTR lpVolumeNameBuffer = NULL;         // address of name of the volume
    DWORD nVolumeNameSize;                    // length of lpVolumeNameBuffer
    LPDWORD lpVolumeSerialNumber = NULL;      // address of volume serial number
    LPDWORD lpMaximumComponentLength = NULL;  // address of system's maximum
                                              // filename length
    LPDWORD lpFileSystemFlags = NULL;         // address of file system flags
    LPWSTR lpFileSystemNameBuffer = NULL;     // address of name of file system
    DWORD nFileSystemNameSize;                // length of lpFileSystemNameBuffer
    BOOL Status;                              // return status
    DWORD dwMask;                             // FileSystem Flag Mask
    DWORD Index;
    DWORD  FsFlag;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_INFOV );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        nVolumeNameSize = MAX_PATH;

        lpVolumeNameBuffer = (LPWSTR) malloc ( MAX_PATH * sizeof(WCHAR) );
        if (lpVolumeNameBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpVolumeSerialNumber = (LPDWORD) malloc( sizeof(DWORD) );
        if (lpVolumeSerialNumber == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpFileSystemFlags = (LPDWORD) malloc ( sizeof(DWORD) );
        if (lpFileSystemFlags == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpMaximumComponentLength = (LPDWORD) malloc ( sizeof(DWORD) );
        if (lpMaximumComponentLength == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nFileSystemNameSize = MAX_PATH;
        lpFileSystemNameBuffer = (LPWSTR) malloc ( MAX_PATH * sizeof(WCHAR) );
        if (lpFileSystemNameBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = GetVolumeInformation (
            argv[0],
            lpVolumeNameBuffer,
            nVolumeNameSize,
            lpVolumeSerialNumber,
            lpMaximumComponentLength,
            lpFileSystemFlags,
            lpFileSystemNameBuffer,
            nFileSystemNameSize
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg( MSG_VOLNAME, lpVolumeNameBuffer );
        DisplayMsg( MSG_SERIALNO, *lpVolumeSerialNumber );
        DisplayMsg( MSG_MAX_COMP_LEN, *lpMaximumComponentLength );
        DisplayMsg( MSG_FS_NAME, lpFileSystemNameBuffer );

        dwMask = 1 ;
        FsFlag = *lpFileSystemFlags;

        for ( Index=0 ; Index<32 ; Index++ ) {
            switch (FsFlag & dwMask) {
                case FILE_CASE_SENSITIVE_SEARCH:
                    DisplayMsg( MSG_FILE_CASE_SENSITIVE_SEARCH );
                    break;

                case FILE_CASE_PRESERVED_NAMES:
                    DisplayMsg( MSG_FILE_CASE_PRESERVED_NAMES );
                    break;

                case FILE_UNICODE_ON_DISK:
                    DisplayMsg( MSG_FILE_UNICODE_ON_DISK );
                    break;

                case FILE_PERSISTENT_ACLS:
                    DisplayMsg( MSG_FILE_PERSISTENT_ACLS );
                    break;

                case FILE_FILE_COMPRESSION:
                    DisplayMsg( MSG_FILE_FILE_COMPRESSION );
                    break;

                case FILE_VOLUME_QUOTAS:
                    DisplayMsg( MSG_FILE_VOLUME_QUOTAS );
                    break;

                case FILE_SUPPORTS_SPARSE_FILES:
                    DisplayMsg( MSG_FILE_SUPPORTS_SPARSE_FILES );
                    break;

                case FILE_SUPPORTS_REPARSE_POINTS:
                    DisplayMsg( MSG_FILE_SUPPORTS_REPARSE_POINTS );
                    break;

                case FILE_SUPPORTS_REMOTE_STORAGE:
                    DisplayMsg( MSG_FILE_SUPPORTS_REMOTE_STORAGE );
                    break;

                case FILE_VOLUME_IS_COMPRESSED:
                    DisplayMsg( MSG_FILE_VOLUME_IS_COMPRESSED );
                    break;

                case FILE_SUPPORTS_OBJECT_IDS:
                    DisplayMsg( MSG_FILE_SUPPORTS_OBJECT_IDS );
                    break;

                case FILE_SUPPORTS_ENCRYPTION:
                    DisplayMsg( MSG_FILE_SUPPORTS_ENCRYPTION );
                    break;

                case FILE_NAMED_STREAMS:
                    DisplayMsg( MSG_FILE_NAMED_STREAMS );
                    break;
            }
            dwMask <<= 1;
        }

    } finally {

        free( lpVolumeNameBuffer );
        free( lpVolumeSerialNumber );
        free( lpFileSystemFlags );
        free( lpMaximumComponentLength );
        free( lpFileSystemNameBuffer );
    }

    return ExitCode;
}


INT
GetNtfsVolumeData(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the NTFS volume data for the volume
    specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl getntfsdv <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    BYTE Buffer[sizeof( NTFS_VOLUME_DATA_BUFFER ) + sizeof( NTFS_EXTENDED_VOLUME_DATA )];
    PNTFS_VOLUME_DATA_BUFFER pvdb = (PNTFS_VOLUME_DATA_BUFFER)Buffer;
    PNTFS_EXTENDED_VOLUME_DATA pevd = (PNTFS_EXTENDED_VOLUME_DATA)(pvdb + 1);
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_NTFSINFO );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[0] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[0] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_GET_NTFS_VOLUME_DATA,
            NULL,
            0,
            pvdb,
            sizeof( Buffer ),
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg(
            MSG_NTFSINFO_STATS,
            QuadToPaddedHexText( pvdb->VolumeSerialNumber.QuadPart ),  //  Serial number in hex
            pevd->MajorVersion,
            pevd->MinorVersion,
            QuadToPaddedHexText( pvdb->NumberSectors.QuadPart ),
            QuadToPaddedHexText( pvdb->TotalClusters.QuadPart ),
            QuadToPaddedHexText( pvdb->FreeClusters.QuadPart ),
            QuadToPaddedHexText( pvdb->TotalReserved.QuadPart ),
            pvdb->BytesPerSector,
            pvdb->BytesPerCluster,
            pvdb->BytesPerFileRecordSegment,
            pvdb->ClustersPerFileRecordSegment,
            QuadToPaddedHexText( pvdb->MftValidDataLength.QuadPart ),
            QuadToPaddedHexText( pvdb->MftStartLcn.QuadPart ),
            QuadToPaddedHexText( pvdb->Mft2StartLcn.QuadPart ),
            QuadToPaddedHexText( pvdb->MftZoneStart.QuadPart ),
            QuadToPaddedHexText( pvdb->MftZoneEnd.QuadPart )
            );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }
    return ExitCode;
}


INT
GetFileSystemStatistics(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the file system statistics for the volume
    specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl getfss <volume pathname>'.

Return Value:

    None

--*/
{
    #define FS_STAT(_f)   FsStat( FsStats, StrucSize, offsetof(FILESYSTEM_STATISTICS,_f), SysInfo.dwNumberOfProcessors )
    #define FAT_STAT(_f)  FsStat( FatFsStats, StrucSize, offsetof(FAT_FILE_SYSTEM_STATISTICS,_f), SysInfo.dwNumberOfProcessors )
    #define NTFS_STAT(_f) FsStat( NtfsFsStats, StrucSize, offsetof(NTFS_FILE_SYSTEM_STATISTICS,_f), SysInfo.dwNumberOfProcessors )

    BOOL Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    PFILESYSTEM_STATISTICS FsStats = NULL;
    DWORD OutBufferSize;
    DWORD BytesReturned;
    SYSTEM_INFO SysInfo;
    PNTFS_FILE_SYSTEM_STATISTICS NtfsFsStats = NULL;
    PFAT_FILE_SYSTEM_STATISTICS FatFsStats = NULL;
    ULONG StrucSize;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_GETFSS );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[0] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[0]  );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        GetSystemInfo( &SysInfo );

        OutBufferSize = max(sizeof(NTFS_FILE_SYSTEM_STATISTICS),sizeof(FAT_FILE_SYSTEM_STATISTICS)) * SysInfo.dwNumberOfProcessors;

        FsStats = (PFILESYSTEM_STATISTICS) malloc ( OutBufferSize );
        if (FsStats == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_FILESYSTEM_GET_STATISTICS,
            NULL,
            0,
            FsStats,
            OutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        switch (FsStats->FileSystemType) {
            case FILESYSTEM_STATISTICS_TYPE_NTFS:
                DisplayMsg( MSG_FSTYPE_NTFS );
                NtfsFsStats = (PNTFS_FILE_SYSTEM_STATISTICS) FsStats;
                StrucSize = sizeof(NTFS_FILE_SYSTEM_STATISTICS);
                break;

            case FILESYSTEM_STATISTICS_TYPE_FAT:
                DisplayMsg( MSG_FSTYPE_FAT );
                FatFsStats = (PFAT_FILE_SYSTEM_STATISTICS) FsStats;
                StrucSize = sizeof(FAT_FILE_SYSTEM_STATISTICS);
                break;
        }

        DisplayMsg(
            MSG_GENERAL_FSSTAT,
            QuadToDecimalText( FS_STAT(UserFileReads)),
            QuadToDecimalText( FS_STAT(UserFileReadBytes)),
            QuadToDecimalText( FS_STAT(UserDiskReads)),
            QuadToDecimalText( FS_STAT(UserFileWrites)),
            QuadToDecimalText( FS_STAT(UserFileWriteBytes)),
            QuadToDecimalText( FS_STAT(UserDiskWrites)),
            QuadToDecimalText( FS_STAT(MetaDataReads)),
            QuadToDecimalText( FS_STAT(MetaDataReadBytes)),
            QuadToDecimalText( FS_STAT(MetaDataDiskReads)),
            QuadToDecimalText( FS_STAT(MetaDataWrites)),
            QuadToDecimalText( FS_STAT(MetaDataWriteBytes)),
            QuadToDecimalText( FS_STAT(MetaDataDiskWrites))
            );

        //
        // Print FileSystem specific data
        //

        switch (FsStats->FileSystemType) {
            case FILESYSTEM_STATISTICS_TYPE_FAT:
                DisplayMsg(
                    MSG_FAT_FSSTA,
                    QuadToDecimalText( FAT_STAT(Fat.CreateHits)),
                    QuadToDecimalText( FAT_STAT(Fat.SuccessfulCreates)),
                    QuadToDecimalText( FAT_STAT(Fat.FailedCreates)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedReads)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedReadBytes)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedWrites)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedWriteBytes)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedDiskReads)),
                    QuadToDecimalText( FAT_STAT(Fat.NonCachedDiskWrites))
                    );
                break;

            case FILESYSTEM_STATISTICS_TYPE_NTFS:
                DisplayMsg(
                    MSG_NTFS_FSSTA,
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.Mft2Writes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.Mft2WriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.RootIndexReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.RootIndexReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.RootIndexWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.RootIndexWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.BitmapReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.BitmapReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.BitmapWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.BitmapWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftBitmapReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftBitmapReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftBitmapWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.MftBitmapWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.UserIndexReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.UserIndexReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.UserIndexWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.UserIndexWriteBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.LogFileReads)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.LogFileReadBytes)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.LogFileWrites)),
                    QuadToDecimalText( NTFS_STAT(Ntfs.LogFileWriteBytes))
                    );

                //
                // Still some more fields left
                //
                break;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (FsStats) {
            free( FsStats );
        }

    }
    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\dirty.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    volume.c

Abstract:

    This file contains code for commands that affect
    the the dirty bit of ntfs volumes.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
DirtyHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_DIRTY );
    return EXIT_CODE_SUCCESS;
}

INT
IsVolumeDirty(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine checks if the Volume specified is dirty.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl isdirtyv <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    DWORD VolumeStatus;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_ISVDIRTY );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocal( argv[0][0] )) {
            DisplayMsg( MSG_NEED_LOCAL_VOLUME );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[0] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[0] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_IS_VOLUME_DIRTY,
            NULL,
            0,
            (LPVOID)&VolumeStatus,
            sizeof(VolumeStatus),
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (VolumeStatus & VOLUME_IS_DIRTY) {
            DisplayMsg( MSG_ISVDIRTY_YES, argv[0] );
        } else {
            DisplayMsg( MSG_ISVDIRTY_NO, argv[0] );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}


INT
MarkVolumeDirty(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine marks the volume as dirty.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl markv <volume pathname>'.

Return Value:

    None

--*/
{
    BOOL Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD BytesReturned;
    WCHAR FileName[MAX_PATH];
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_MARKV );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[0] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[0] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_MARK_VOLUME_DIRTY,
            NULL,
            0,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
        } else {
            DisplayMsg( MSG_DIRTY_SET, argv[0] );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }
    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\behavior.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    behavior.c

Abstract:

    This file contains routines that control file system behavior

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
BehaviorHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_BEHAVIOR );
    return EXIT_CODE_SUCCESS;
}

#define NTFS_KEY  L"System\\CurrentControlSet\\Control\\FileSystem"

typedef struct _BEHAVIOR_OPTION {
    PWSTR   Name;
    PWSTR   RegVal;
    ULONG   MinVal;
    ULONG   MaxVal;
} BEHAVIOR_OPTION, *PBEHAVIOR_OPTION;

BEHAVIOR_OPTION Options[] = {
    { L"disable8dot3",         L"NtfsDisable8dot3NameCreation",           0,  1 },
    { L"allowextchar",         L"NtfsAllowExtendedCharacterIn8dot3Name",  0,  1 },
    { L"disablelastaccess",    L"NtfsDisableLastAccessUpdate",            0,  1 },
    { L"quotanotify",          L"NtfsQuotaNotifyRate",                    1, -1 },
    { L"mftzone",              L"NtfsMftZoneReservation",                 1,  4 },
    { L"memoryusage",          L"NtfsMemoryUsage",                        1,  2 },
};

#define NUM_OPTIONS  (sizeof(Options)/sizeof(BEHAVIOR_OPTION))


INT
RegistryQueryValueKey(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This is the routine for querying the Registry Key Value.
    This routine display the value associated with the corresponding
    Key Value.

Arguments:

    argc - The argument count and must be 1

    argv - Array with one string element that is the registry key to display.

Return Value:

    None

--*/
{
    ULONG i,Value,Size;
    HKEY hKey = NULL;
    LONG Status;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_RQUERYVK );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        //
        //  Verify that the option is correct
        //

        for (i = 0; i < NUM_OPTIONS; i++) {
            if (_wcsicmp( argv[0], Options[i].Name ) == 0) {
                break;
            }
        }

        if (i >= NUM_OPTIONS) {
            DisplayMsg( MSG_USAGE_RSETVK );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Open the registry key
        //

        Status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            NTFS_KEY,
            0,
            KEY_ALL_ACCESS,
            &hKey
            );
        if (Status != ERROR_SUCCESS ) {
            DisplayErrorMsg( Status, NTFS_KEY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Query the value
        //

        Size = sizeof(ULONG);

        Status = RegQueryValueEx(
            hKey,
            Options[i].RegVal,
            0,
            NULL,
            (PBYTE)&Value,
            &Size
            );

        if (Status != ERROR_SUCCESS ) {
            DisplayMsg( MSG_BEHAVIOR_OUTPUT_NOT_SET, Options[i].Name );
        } else {
            DisplayMsg( MSG_BEHAVIOR_OUTPUT, Options[i].Name, Value );
        }

    } finally {

        if (hKey) {
            RegCloseKey( hKey );
        }

    }

    return ExitCode;
}


INT
RegistrySetValueKey (
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This is the routine for setting the Registry Key Value.
    This routine sets the value for the Key Value Name given.

Arguments:

    argc - The argument count.
    argv - Array of strings which contain the DataType, DataLength,
           Data and KeyValue Name.

Return Value:

    None

--*/
{
    ULONG i,j;
    HKEY hKey = NULL;
    LONG Status;
    INT ExitCode = EXIT_CODE_SUCCESS;
    PWSTR EndPtr;

    try {

        if (argc != 2) {
            DisplayMsg( MSG_USAGE_RSETVK );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        //
        //  Verify that the option is correct
        //

        for (i = 0; i < NUM_OPTIONS; i++) {
            if (_wcsicmp( argv[0], Options[i].Name ) == 0) {
                break;
            }
        }

        if (i == NUM_OPTIONS) {
            DisplayMsg( MSG_USAGE_RSETVK );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Verify that the value is correct
        //

        j = My_wcstoul( argv[1], &EndPtr, 0 );

        //
        //  If we did not parse the entire string or
        //  if we overflowed ULONG or
        //  if we're out of range
        //

        if (UnsignedNumberCheck( j, EndPtr )
            || j > Options[i].MaxVal
            || j < Options[i].MinVal) {

            DisplayMsg( MSG_USAGE_RSETVK );
            ExitCode = EXIT_CODE_FAILURE;
            leave;

        }

        //
        //  Open the registry key
        //

        Status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            NTFS_KEY,
            0,
            KEY_ALL_ACCESS,
            &hKey
            );
        if (Status != ERROR_SUCCESS ) {
            DisplayErrorMsg( Status, NTFS_KEY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Set the value
        //

        Status = RegSetValueEx(
            hKey,
            Options[i].RegVal,
            0,
            REG_DWORD,
            (PBYTE)&j,
            sizeof(DWORD)
            );
        if (Status != ERROR_SUCCESS ) {
            DisplayErrorMsg( Status, Options[i].RegVal );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (hKey) {
            RegCloseKey( hKey );
        }

    }
    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\main.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This file implements the main entry point
    for this project and also processes all
    command dispatching.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>

BOOL RunningOnWin2K;
WCHAR *DotPrefix = L"\\\\.\\";

typedef INT (*PFSCOMMANDFUNC)(INT,PWSTR*);

typedef struct _COMMAND_VECTOR {
    PWSTR CommandName;
    union {
        PVOID _make_it_compile;
        PFSCOMMANDFUNC CommandFunc;
        struct _COMMAND_VECTOR *CommandVector;
        DWORD_PTR HelpMessage;
    };
} COMMAND_VECTOR, *PCOMMAND_VECTOR;

COMMAND_VECTOR CmdVectorUsn[] =
{
    { L"?",                           UsnHelp                  },
    { L"help",                        UsnHelp                  },
    { L"createjournal",               CreateUsnJournal         },
    { L"deletejournal",               DeleteUsnJournal         },
    { L"enumdata",                    EnumUsnData              },
    { L"queryjournal",                QueryUsnJournal          },
    { L"readdata",                    ReadFileUsnData          },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorQuota[] =
{
    { L"?",                           QuotaHelp                },
    { L"help",                        QuotaHelp                },
    { L"disable",                     DisableQuota             },
    { L"track",                       TrackQuota               },
    { L"enforce",                     EnforceQuota             },
    { L"violations",                  GetDiskQuotaViolation    },
    { L"modify",                      ChangeDiskQuota          },
    { L"query",                       QueryDiskQuota           },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorDirty[] =
{
    { L"?",                           DirtyHelp                },
    { L"help",                        DirtyHelp                },
    { L"query",                       IsVolumeDirty            },
    { L"set",                         MarkVolumeDirty          },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorFsInfo[] =
{
    { L"?",                           FsInfoHelp               },
    { L"help",                        FsInfoHelp               },
    { L"drives",                      ListDrives               },
    { L"drivetype",                   DriveType                },
    { L"volumeinfo",                  VolumeInfo               },
    { L"ntfsinfo",                    GetNtfsVolumeData        },
    { L"statistics",                  GetFileSystemStatistics  },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorReparse[] =
{
    { L"?",                           ReparseHelp              },
    { L"help",                        ReparseHelp              },
    { L"query",                       GetReparsePoint          },
    { L"delete",                      DeleteReparsePoint       },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorBehavior[] =
{
    { L"?",                           BehaviorHelp             },
    { L"help",                        BehaviorHelp             },
    { L"query",                       RegistryQueryValueKey    },
    { L"set",                         RegistrySetValueKey      },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorFile[] =
{
    { L"?",                           FileHelp                 },
    { L"help",                        FileHelp                 },
    { L"findbysid",                   FindFilesBySid           },
    { L"queryallocranges",            QueryAllocatedRanges     },
    { L"setshortname",                SetShortName             },
    { L"setvaliddata",                SetValidDataLength       },
    { L"setzerodata",                 SetZeroData              },
    { L"createnew",                   CreateNewFile            },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorVolume[] =
{
    { L"?",                           VolumeHelp               },
    { L"help",                        VolumeHelp               },
    { L"dismount",                    DismountVolume           },
    { L"diskfree",                    DiskFreeSpace            },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorObjectId[] =
{
    { L"?",                           ObjectIdHelp             },
    { L"help",                        ObjectIdHelp             },
    { L"query",                       GetObjectId              },
    { L"set",                         SetObjectId              },
    { L"delete",                      DeleteObjectId           },
    { L"create",                      CreateOrGetObjectId      },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorSparse[] =
{
    { L"?",                           SparseHelp               },
    { L"help",                        SparseHelp               },
    { L"setflag",                     SetSparse                },
    { L"queryflag",                   QuerySparse              },
    { L"queryrange",                  QuerySparseRange         },
    { L"setrange",                    SetSparseRange           },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorHardLink[] =
{
    { L"?",                           HardLinkHelp             },
    { L"help",                        HardLinkHelp             },
    { L"create",                      CreateHardLinkFile       },
    { NULL,                           NULL                     }
};

COMMAND_VECTOR CmdVectorGroups[] =
{
    { L"behavior",                    CmdVectorBehavior        },
    { L"dirty",                       CmdVectorDirty           },
    { L"file",                        CmdVectorFile            },
    { L"fsinfo",                      CmdVectorFsInfo          },
    { L"hardlink",                    CmdVectorHardLink        },
    { L"objectid",                    CmdVectorObjectId        },
    { L"quota",                       CmdVectorQuota           },
    { L"reparsepoint",                CmdVectorReparse         },
    { L"sparse",                      CmdVectorSparse          },
    { L"usn",                         CmdVectorUsn             },
    { L"volume",                      CmdVectorVolume          },
    { NULL,                           NULL                     }
};



PCOMMAND_VECTOR
FindCommand(
    PCOMMAND_VECTOR Cmds,
    LPWSTR CmdName
    )
{
    while (Cmds->CommandName) {
        if (!_wcsicmp( Cmds->CommandName, CmdName )) {
            return Cmds;
        }
        Cmds += 1;
    }
    return NULL;
}


INT
__cdecl wmain(
    INT argc,
    PWSTR argv[]
    )
/*++

Routine Description:

    This routine is the 'main' routine for the tool 'fscutl'.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl <command> <options/flags> <parameters> ...'

Return Value:

    INT - Return Status

--*/
{
    PCOMMAND_VECTOR Cmds = NULL;
    PCOMMAND_VECTOR Cmds2 = NULL;
    OSVERSIONINFOEX OsVer;

    LANGID (WINAPI *pSetThreadUILanguage)(  ) = NULL;

    if (pSetThreadUILanguage == NULL) {
        pSetThreadUILanguage = (PVOID) GetProcAddress( GetModuleHandle( TEXT( "kernel32" )), "SetThreadUILanguage" );
    }

    if (pSetThreadUILanguage == NULL) {
        SetThreadLocale( MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT ));
    } else {
        (*pSetThreadUILanguage)( 0 );
    }

    setlocale( LC_ALL, ".OCP" ) ;


    SHIFT( argc, argv );

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx( (LPOSVERSIONINFO)&OsVer ) && OsVer.dwMajorVersion == 5 && OsVer.dwMinorVersion == 0) {
        RunningOnWin2K = TRUE;
    }

    if (!IsUserAdmin()) {
        DisplayMsg( MSG_ADMIN_REQUIRED );
        return EXIT_CODE_FAILURE;
    }

    //
    //  Check for blind usage
    //

    if (argc == 0) {
        Help( 0, NULL );
        return EXIT_CODE_SUCCESS;
    }
    
    //
    //  We have a two-level dispatch scheme.  First level selects a table and second
    //  selects a function
    //

    Cmds = FindCommand( CmdVectorGroups, argv[0] );
    if (Cmds == NULL) {
        DisplayMsg( MSG_INVALID_PARAMETER, argv[0] );
        Help( 0, NULL );
        return EXIT_CODE_FAILURE;
    }
    
    SHIFT( argc, argv );

    //
    //  If there's no argument, then it's a cry for help
    //

    if (argc == 0) {
        Cmds2 = FindCommand( Cmds->CommandVector, L"?" );
        Cmds2->CommandFunc( argc, argv );
        return EXIT_CODE_SUCCESS;
    }
    
    //
    //  Go to second level dispatch.
    //

    Cmds2 = FindCommand( Cmds->CommandVector, argv[0] );
    if (Cmds2 == NULL) {
        DisplayMsg( MSG_INVALID_PARAMETER, argv[0] );
        Cmds2 = FindCommand( Cmds->CommandVector, L"?" );
        SHIFT( argc, argv );
        Cmds2->CommandFunc( argc, argv );
        return EXIT_CODE_FAILURE;
    }
    
    SHIFT( argc, argv );

    return Cmds2->CommandFunc( argc, argv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\hardlink.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hardlink.c

Abstract:

    This file contains code for commands that affect hardlinks.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
HardLinkHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_HARDLINK );
    return EXIT_CODE_SUCCESS;
}

INT
CreateHardLinkFile(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    PWSTR Filename1 = NULL;
    PWSTR Filename2 = NULL;
    INT ExitCode = EXIT_CODE_SUCCESS;

    do {
        if (argc != 2) {
            DisplayMsg( MSG_USAGE_HARDLINK_CREATE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            break;
        }

        Filename1 = GetFullPath( argv[0] );
        if (!Filename1) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        Filename2 = GetFullPath( argv[1] );
        if (!Filename2) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        if ((!IsVolumeLocalNTFS( Filename1[0] )) || (!IsVolumeLocalNTFS( Filename2[0] ))) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        if (CreateHardLink( Filename1, Filename2, NULL )) {
            DisplayMsg( MSG_HARDLINK_CREATED, Filename1, Filename2 );
        } else {
            if (GetLastError( ) == ERROR_NOT_SAME_DEVICE) {
                DisplayMsg( MSG_NOT_SAME_DEVICE );
            } else {
                DisplayError();
            }
            ExitCode = EXIT_CODE_FAILURE;
        }
    } while ( FALSE );

    free( Filename1 );
    free( Filename2 );

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the main header file.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#ifndef _FSCUTL_
#define _FSCUTL_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>

#include <malloc.h>
#include <time.h>
#include <errno.h>
#include <limits.h>

#include <windows.h>
#include <winioctl.h>

#include <objbase.h>
#include <locale.h>

#include "msg.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


#ifdef _cplusplus
extern "C" {
#endif


#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))
#define QuadAlign(P) (((((ULONG)(P)) + 7) & 0xfffffff8))

#define UnsignedI64NumberCheck(v,p) ((*p) != L'\0' || ((v) == _UI64_MAX && errno == ERANGE))
#define UnsignedNumberCheck(v,p)    ((*p) != L'\0' || ((v) == ULONG_MAX && errno == ERANGE))

#define SHIFT(c,v)      ((c)--,(v)++)


extern BOOL RunningOnWin2K;

extern WCHAR *DotPrefix;

//
//  Exit codes.  Note that we will treat asking for usage information as a success
//

#define EXIT_CODE_SUCCESS   0
#define EXIT_CODE_FAILURE   1



//
// Function Prototypes
//

INT
Help (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
ListDrives (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DriveType (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
VolumeInfo (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DiskFreeSpace (
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DismountVolume(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
MarkVolumeDirty(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetFileSystemStatistics(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetNtfsVolumeData(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
IsVolumeDirty(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetReparsePoint(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DeleteReparsePoint(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DeleteObjectId(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
CreateOrGetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
CreateUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QueryUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DeleteUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
EnumUsnData(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
ReadFileUsnData(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
CreateHardLinkFile(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
FindFilesBySid(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetSparse(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QuerySparse(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetSparseRange(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QuerySparseRange(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetZeroData(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QueryAllocatedRanges(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
RegistryQueryValueKey(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
RegistrySetValueKey(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
GetDiskQuotaViolation(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DisableQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
TrackQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
EnforceQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QuotaControl(
    IN PWSTR Drive,
    IN ULONG QuotaControBits
    );

INT
ChangeDiskQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QueryDiskQuota(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetValidDataLength(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
CreateNewFile(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SetShortName(
    IN INT argc,
    IN PWSTR argv[]
    );

VOID
DisplayError(
    void
    );

BOOL
IsUserAdmin(
    VOID
    );

BOOL
IsVolumeLocalNTFS(
    WCHAR DriveLetter
    );

BOOL
IsVolumeNTFS(
    PWCHAR path
    );

BOOL
IsVolumeLocal(
    WCHAR DriveLetter
    );

PWSTR
GetFullPath(
    IN PWSTR FilenameIn
    );

VOID
OutputMessage(
    LPWSTR Message
    );

VOID
OutputMessageLength(
    PWCHAR Message,
    int Length
    );

VOID
DisplayMsg(
    LONG msgId,
    ...
    );

VOID DisplayErrorMsg(
    IN LONG msgId,
    ...
    );

LPWSTR
FileTime2String(
    IN PLARGE_INTEGER Time,
    IN LPWSTR Buffer,
    IN ULONG BufferSize     //in bytes
    );

LPWSTR
Guid2Str(
    IN GUID *Guid,
    IN LPWSTR Buffer,
    IN ULONG BufferSize     //in bytes
    );

BOOL
EnablePrivilege(
    LPCWSTR SePrivilege
    );

__int64  __cdecl My_wcstoi64(
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    );

unsigned __int64  __cdecl My_wcstoui64 (
	const wchar_t *nptr,
	wchar_t **endptr,
	int ibase
	);

unsigned long __cdecl My_wcstoul (
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    );

PWSTR
QuadToDecimalText(
    ULONGLONG Value
    );

PWSTR
QuadToHexText(
    ULONGLONG Value
    );

PWSTR
QuadToPaddedHexText(
    ULONGLONG Value
    );

INT
UsnHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
QuotaHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
DirtyHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
FsInfoHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
ReparseHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
BehaviorHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
FileHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
VolumeHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
ObjectIdHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
SparseHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

INT
HardLinkHelp(
    IN INT argc,
    IN PWSTR argv[]
    );

#ifdef _cplusplus
}
#endif

#endif // _FSCUTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\objectid.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    objectid.c

Abstract:

    This file contains code for commands that affect object ids.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
ObjectIdHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_OBJECTID );
    return EXIT_CODE_SUCCESS;
}

VOID
PrintObjectId(
    PFILE_OBJECTID_BUFFER lpOutBuffer
    )
{
    INT Index;
    
    #define CHARLENGTH  16
    //  Remember two characters in each byte dump
    WCHAR Buffer[2 * CHARLENGTH + 1];
    int BufferOffset;

    DisplayMsg( MSG_OBJECTID_TEXT );
    BufferOffset = 0;
    for ( Index = 0 ; Index < CHARLENGTH ; Index++ ) {
        BufferOffset += swprintf( &Buffer[BufferOffset], 
                                  L"%02x", 
                                  lpOutBuffer->ObjectId[Index] );
        
    }

    OutputMessage( Buffer );
    OutputMessage( L"\r\n" );

    DisplayMsg( MSG_BIRTHVOLID_TEXT );
    BufferOffset = 0;
    for ( Index = 0 ; Index < CHARLENGTH ; Index++ ) {
        BufferOffset += swprintf( &Buffer[BufferOffset],
                                  L"%02x", 
                                  lpOutBuffer->BirthVolumeId[Index] );
    }

    OutputMessage( Buffer );
    OutputMessage( L"\r\n" );
    
    DisplayMsg( MSG_BIRTHOBJECTID_TEXT );
    BufferOffset = 0;
    for ( Index = 0 ; Index < CHARLENGTH ; Index++ ) {
        BufferOffset += swprintf( &Buffer[BufferOffset],
                                  L"%02x", 
                                  lpOutBuffer->BirthObjectId[Index] );
    }

    OutputMessage( Buffer );
    OutputMessage( L"\r\n" );
    
    DisplayMsg( MSG_DOMAINID_TEXT );
    BufferOffset = 0;
    for ( Index = 0 ; Index < CHARLENGTH ; Index++ ) {
        BufferOffset += swprintf( &Buffer[BufferOffset],
                                  L"%02x", 
                                  lpOutBuffer->DomainId[Index] );
    }
    
    OutputMessage( Buffer );
    OutputMessage( L"\r\n" );
    
}

UCHAR
GetNibbleValue(
    IN OUT PCWSTR *String
    )
{
    UCHAR v;
    WCHAR c;
    
    c = *(*String)++;
    c = (UCHAR) toupper( c );
    if (isdigit( c )) {
        v = c - L'0';
    } else if (isalpha( c ) && c <= L'F') {
        v = c - L'A' + 10;
    } else {
        (*String)--;
        return 0;
    }
    return v;
}

UCHAR
GetByteValue(
    IN OUT PCWSTR *String
    )
{
    UCHAR v = GetNibbleValue( String );
    v *= 16;
    v += GetNibbleValue( String );
    return v;
}


BOOL
ConvertStringToHexData(
    IN PCWSTR Arg,
    OUT PUCHAR Buffer
    )
{
    int i;

    for (i = 0; i < 16; i++) {
        Buffer[i] = GetByteValue( &Arg );
    }

    return *Arg == L'\0';
}


INT
SetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine sets the objectID for the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setoid <oid=val> <bvid=val> <boid=val> <did=val> <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PFILE_OBJECTID_BUFFER lpInBuffer = NULL;
    BOOL Status;
    DWORD nInBufferSize;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 5) {
            DisplayMsg( MSG_USAGE_SETOBJECTID );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[4] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nInBufferSize = sizeof(FILE_OBJECTID_BUFFER);
        lpInBuffer = (PFILE_OBJECTID_BUFFER) malloc ( nInBufferSize );
        if (lpInBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Convert the input strings into the correct data
        //

        if (!ConvertStringToHexData( argv[0], lpInBuffer->ObjectId)
            || !ConvertStringToHexData( argv[1], lpInBuffer->BirthVolumeId)
            || !ConvertStringToHexData( argv[2], lpInBuffer->BirthObjectId)
            || !ConvertStringToHexData( argv[3], lpInBuffer->DomainId)) {
            DisplayMsg( MSG_USAGE_SETOBJECTID );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        if (!EnablePrivilege( SE_RESTORE_NAME )) {
            DisplayError( );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_SET_OBJECT_ID,
            (LPVOID) lpInBuffer,
            nInBufferSize,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free(lpInBuffer);
        free( Filename );
    }
    return ExitCode;
}

INT
GetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the objectID associated with the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl getoid <pathname> '.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    PFILE_OBJECTID_BUFFER lpOutBuffer = NULL;
    BOOL Status;
    DWORD nOutBufferSize;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 1) {
          DisplayMsg( MSG_USAGE_GETOBJECTID );
          if (argc != 0) {
              ExitCode = EXIT_CODE_FAILURE;
          }
          leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeNTFS( Filename )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = sizeof(FILE_OBJECTID_BUFFER);
        lpOutBuffer = (PFILE_OBJECTID_BUFFER) malloc ( nOutBufferSize );
        if (lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_GET_OBJECT_ID,
            NULL,
            0,
            (LPVOID) lpOutBuffer,
            nOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        
        if (!Status) {

            if (GetLastError( ) == ERROR_FILE_NOT_FOUND) {
                DisplayMsg( MSG_NO_OBJECT_ID );
            } else {
                DisplayError();
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        PrintObjectId( lpOutBuffer );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free(lpOutBuffer);
        free( Filename );
    }
    
    return ExitCode;
}


INT
CreateOrGetObjectId(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the objectID for the file, if it exists, else
    creates an objectID and returns it.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl crgetoid <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PFILE_OBJECTID_BUFFER lpOutBuffer = NULL;
    BOOL Status;
    DWORD nOutBufferSize;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_CREATEOBJECTID );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }


        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = sizeof(FILE_OBJECTID_BUFFER);
        lpOutBuffer = (PFILE_OBJECTID_BUFFER)  malloc ( nOutBufferSize );
        if (lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_CREATE_OR_GET_OBJECT_ID,
            NULL,
            0,
            (LPVOID) lpOutBuffer,
            nOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        PrintObjectId( lpOutBuffer );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (lpOutBuffer) {
            free(lpOutBuffer);
        }
        if (Filename) {
            free( Filename );
        }
    }

    return ExitCode;
}


INT
DeleteObjectId(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine deletes the objectID associated with the file
    specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl deloid <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PWSTR Filename = NULL;
    BOOL Status;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {


        if (argc != 1) {
            DisplayMsg( MSG_USAGE_DELETEOBJECTID );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;}
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_DELETE_OBJECT_ID,
            NULL,
            0,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\quota.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    quota.c

Abstract:

    This file contains code for commands that affect quotas.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


#define BUFFER_SIZE                      1024
#define IO_FILE_QUOTA_THRESHOLD          0x40040024L
#define IO_FILE_QUOTA_LIMIT              0x40040025L

#define SID_MAX_LENGTH                   (FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)

INT
QuotaHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_QUOTA );
    return EXIT_CODE_SUCCESS;
}

HANDLE
QuotaOpenVolume(
    IN PWSTR Drive
    )
{
    NTSTATUS Status;
    HANDLE hFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    WCHAR Buffer[MAX_PATH];
    UNICODE_STRING FileName;

    if (_snwprintf( Buffer,
                    sizeof( Buffer ) / sizeof( Buffer[0] ) - 1,     /* leave space for null */
                    L"\\DosDevices\\%s\\$Extend\\$Quota:$Q:$INDEX_ALLOCATION",
                    Drive ) < 0) {
        DisplayMsg( MSG_DRIVE_TOO_LONG );
        return INVALID_HANDLE_VALUE;
    }

    RtlInitUnicodeString( &FileName, Buffer );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
        &hFile,
        FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatus,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT
        );
    if (!NT_SUCCESS( Status )) {
        DisplayErrorMsg( RtlNtStatusToDosError( Status ), Drive );
        return INVALID_HANDLE_VALUE;
    }

    return hFile;
}

INT
QuotaControl(
    IN PWSTR Drive,
    IN ULONG QuotaControlBits
    )
{
    HANDLE Handle = INVALID_HANDLE_VALUE;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_FS_CONTROL_INFORMATION ControlInfo;
    INT ExitCode = EXIT_CODE_SUCCESS;

    do {
        if (!IsVolumeLocalNTFS( Drive[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        Handle = QuotaOpenVolume( Drive );
        if (Handle == INVALID_HANDLE_VALUE) {
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        //
        //  get the current state of quota tracking on this volume
        //

        Status = NtQueryVolumeInformationFile(
            Handle,
            &IoStatus,
            &ControlInfo,
            sizeof( ControlInfo ),
            FileFsControlInformation
            );

        if (!NT_SUCCESS( Status )) {
            DisplayErrorMsg( RtlNtStatusToDosError( Status ));
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

        //
        //  Set in the new control bits
        //

        ControlInfo.FileSystemControlFlags &= ~FILE_VC_QUOTA_MASK;
        ControlInfo.FileSystemControlFlags |= QuotaControlBits;

        //
        //  Set the control info back onto the volume
        //

        Status = NtSetVolumeInformationFile(
            Handle,
            &IoStatus,
            &ControlInfo,
            sizeof( ControlInfo ),
            FileFsControlInformation
            );

        if (!NT_SUCCESS( Status )) {
            DisplayErrorMsg( RtlNtStatusToDosError( Status ));
            ExitCode = EXIT_CODE_FAILURE;
            break;
        }

    } while (FALSE);


    if (Handle != INVALID_HANDLE_VALUE) {
        CloseHandle( Handle );
    }

    return ExitCode;
}



INT
DisableQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    Disables quotas on a specified volume

Arguments:

    argc - The argument count, should be 1
    argv - Array of strings, the first one must be a drive

Return Value:

    None

--*/
{
    if (argc != 1) {
        DisplayMsg( MSG_USAGE_QUOTA_DISABLE );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }

    }

    return QuotaControl( argv[0], FILE_VC_QUOTA_NONE );
}

INT
TrackQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    Tracks quotas on a specified volume

Arguments:

    argc - The argument count, should be 1
    argv - Array of strings, the first one must be a drive

Return Value:

    None

--*/
{
    if (argc != 1) {
        DisplayMsg( MSG_USAGE_QUOTA_TRACK );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    return QuotaControl( argv[0], FILE_VC_QUOTA_TRACK );
}

INT
EnforceQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    Enforces quotas on a specified volume

Arguments:

    argc - The argument count, should be 1
    argv - Array of strings, the first one must be a drive

Return Value:

    None

--*/
{
    if (argc != 1) {
        DisplayMsg( MSG_USAGE_QUOTA_ENFORCE );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    return QuotaControl( argv[0], FILE_VC_QUOTA_ENFORCE );
}

INT
GetDiskQuotaViolation(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This is the routine for querying the disk quota violation.

Arguments:

    argc - The argument count.
    argv - Array of strings of the form:
           ' fscutl getdskqv '

Return Value:

    None

--*/
{
    HANDLE handle = NULL;
    EVENTLOGRECORD *pevlr, *ptr;
    PWCHAR EventString;
    DWORD dwRead;
    DWORD dwNeeded;
    BOOLEAN flag = TRUE;
    BOOL Status;
    PSID psid;
    SID_NAME_USE Use;
    WCHAR Name[MAX_PATH];
    DWORD dwNameSize;
    WCHAR Domain[MAX_PATH];
    DWORD dwDomainSize;
    WCHAR Log[2][16] = { L"System", L"Application" };
    WORD index;
    INT ExitCode = EXIT_CODE_SUCCESS;


    try {

        if (argc != 0) {
            DisplayMsg( MSG_USAGE_QUOTA_VIOLATIONS );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        for ( index = 0 ; index < 2 ; index++ ) {
            handle = OpenEventLog( NULL, Log[index] );
            if ( handle == NULL ) {
                DisplayMsg( MSG_COULD_NOT_OPEN_EVENTLOG );
                DisplayError();
                ExitCode = EXIT_CODE_FAILURE;
                leave;
            }
            ptr = pevlr = (EVENTLOGRECORD *) malloc (BUFFER_SIZE);
            if (ptr == NULL) {
                DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
                ExitCode = EXIT_CODE_FAILURE;
                leave;
            }

            DisplayMsg( MSG_SEARCHING_EVENTLOG, Log[index] );

            while(ReadEventLog(
                    handle,
                    EVENTLOG_FORWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                    0,
                    pevlr,
                    BUFFER_SIZE,
                    &dwRead,
                    &dwNeeded))
            {
                while(dwRead > 0)   {
                    if (pevlr->EventID == IO_FILE_QUOTA_THRESHOLD || pevlr->EventID == IO_FILE_QUOTA_LIMIT) {
                        flag = FALSE;
                        switch(pevlr->EventID) {
                            case IO_FILE_QUOTA_THRESHOLD :
                                DisplayMsg( MSG_QUOTA_THREASHOLD );
                                break;
                            case IO_FILE_QUOTA_LIMIT:
                                DisplayMsg( MSG_QUOTA_LIMIT );
                                break;
                        }

                        DisplayMsg( MSG_EVENT_ID, pevlr->EventID );

                        switch(pevlr->EventType) {
                            case EVENTLOG_ERROR_TYPE:
                                DisplayMsg( MSG_EVENT_TYPE_ERROR );
                                break;
                            case EVENTLOG_WARNING_TYPE:
                                DisplayMsg( MSG_EVENT_TYPE_WARNING );
                                break;
                            case EVENTLOG_INFORMATION_TYPE:
                                DisplayMsg( MSG_EVENT_TYPE_INFORMATION );
                                break;
                            case EVENTLOG_AUDIT_SUCCESS:
                                DisplayMsg( MSG_EVENT_TYPE_AUDIT_SUCCESS );
                                break;
                            case EVENTLOG_AUDIT_FAILURE:
                                DisplayMsg( MSG_EVENT_TYPE_AUDIT_FAILURE );
                                break;
                        }

                        DisplayMsg( MSG_EVENT_CATEGORY, pevlr->EventCategory );
                        DisplayMsg( MSG_EVENT_SOURCE, (LPWSTR)((LPBYTE) pevlr + sizeof(EVENTLOGRECORD)) );

                        if (pevlr->UserSidOffset > 0) {
                            psid = (PSID) ( (PBYTE)pevlr + pevlr->UserSidOffset );

                            dwNameSize = MAX_PATH;
                            dwDomainSize = MAX_PATH;

                            Status = LookupAccountSid(
                                NULL,
                                psid,
                                Name,
                                &dwNameSize,
                                Domain,
                                &dwDomainSize,
                                &Use
                                );
                            if (Status) {
                                DisplayMsg( MSG_USERNAME, Domain, Name );
                            }
                        }
                        if (pevlr->NumStrings == 2) {
                            EventString = (PWCHAR) ((PBYTE)pevlr + pevlr->StringOffset);
                            EventString += wcslen( EventString ) + 1;
                            DisplayMsg( MSG_EVENT_DATA, EventString );
                        }
                    }
                    dwRead -= pevlr->Length;
                    pevlr = (EVENTLOGRECORD *)((PBYTE) pevlr + pevlr->Length);
                }
                pevlr = ptr;
            }
            CloseEventLog(handle);
            handle = NULL;
        }

        if (flag) {
            DisplayMsg( MSG_GOOD_QUOTA );
        }

    } finally {

        if (handle != NULL) {
            CloseHandle( handle );
        }

    }

    return ExitCode;
}

PWSTR
FileTimeToString(
    PLARGE_INTEGER FileTime
    )
{
    ULONG ElapsedSeconds;

    if (RtlTimeToSecondsSince1970( FileTime, &ElapsedSeconds )) {
        PWSTR TimeString = _wctime( (time_t*)&ElapsedSeconds );
        if (TimeString) {
            TimeString[wcslen(TimeString)-1] = 0;
        }
        return TimeString;
    }
    return L"";
}

BOOL
GetUserSid(
    PWSTR UserName,
    PFILE_QUOTA_INFORMATION *QuotaInfoPtr,
    PFILE_GET_QUOTA_INFORMATION *SidListPtr
    )
{
    WCHAR Domain[128];
    ULONG DomainLength;
    SID_NAME_USE SidNameUse;


    (*QuotaInfoPtr)->SidLength = SID_MAX_LENGTH;
    DomainLength = sizeof(Domain);

    if (!LookupAccountName(
         NULL,
         UserName,
         &(*QuotaInfoPtr)->Sid,
         &(*QuotaInfoPtr)->SidLength,
         Domain,
         &DomainLength,
         &SidNameUse))
    {
        DomainLength = GetLastError();
        return FALSE;
    }

    //
    // Initialize the values to something resonable.
    //

    (*QuotaInfoPtr)->QuotaThreshold.QuadPart = ~0;
    (*QuotaInfoPtr)->QuotaLimit.QuadPart = ~0;

    (*QuotaInfoPtr)->SidLength = RtlLengthSid( &(*QuotaInfoPtr)->Sid);

    (*QuotaInfoPtr)->NextEntryOffset =
        FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) +
        QuadAlign((*QuotaInfoPtr)->SidLength);

    memcpy( &(*SidListPtr)->Sid, &(*QuotaInfoPtr)->Sid, (*QuotaInfoPtr)->SidLength);
    (*SidListPtr)->SidLength = (*QuotaInfoPtr)->SidLength;

    (*SidListPtr)->NextEntryOffset =
        FIELD_OFFSET( FILE_GET_QUOTA_INFORMATION, Sid ) +
        QuadAlign((*SidListPtr)->SidLength);

    return TRUE;
}

BOOL
DumpVolumeQuotaInfo(
    IN HANDLE hFile,
    IN BOOL DisplayAlways
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_FS_CONTROL_INFORMATION TempControlInfo = {0};
    ULONG StatusId;
    ULONG LoggingId;
    ULONG ValueId;


    Status = NtQueryVolumeInformationFile(
        hFile,
        &IoStatus,
        &TempControlInfo,
        sizeof(FILE_FS_CONTROL_INFORMATION),
        FileFsControlInformation
        );

    //
    //  If quotas aren't enforced or tracked, then quotas must be disabled.
    //

    if ((TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) == FILE_VC_QUOTA_NONE) {
        StatusId = MSG_QUOTA_STATUS_DISABLED;
    } else if ((TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) == FILE_VC_QUOTA_TRACK) {
        StatusId = MSG_QUOTA_STATUS_TRACKING;
    } else {
        ASSERT( TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_ENFORCE );
        StatusId = MSG_QUOTA_STATUS_ENFORCE;
    }

    if (!DisplayAlways) {
        return StatusId != MSG_QUOTA_STATUS_DISABLED;
    }

    switch (TempControlInfo.FileSystemControlFlags & (FILE_VC_LOG_QUOTA_LIMIT | FILE_VC_LOG_QUOTA_THRESHOLD)) {
        case FILE_VC_LOG_QUOTA_LIMIT:
            LoggingId = MSG_QUOTA_LOGGING_LIMITS;
            break;

        case FILE_VC_LOG_QUOTA_THRESHOLD:
            LoggingId = MSG_QUOTA_LOGGING_THRESH;
            break;

        case FILE_VC_LOG_QUOTA_LIMIT | FILE_VC_LOG_QUOTA_THRESHOLD:
            LoggingId = MSG_QUOTA_LOGGING_BOTH;
            break;

        case 0:
            LoggingId = MSG_QUOTA_LOGGING_EVENTS;
            break;
    }

    if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) {
        if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTAS_INCOMPLETE) {
            ValueId = MSG_QUOTA_VALUES_INCOMPLETE;
        } else {
            ValueId = MSG_QUOTA_VALUES_GOOD;
        }
    } else {
        ValueId = MSG_QUOTA_VALUES_GOOD;
    }

    DisplayMsg( MSG_USAGE_QUOTA_VOLUME_INFO, TempControlInfo.FileSystemControlFlags );
    DisplayMsg( StatusId );
    DisplayMsg( LoggingId );
    DisplayMsg( ValueId );
    DisplayMsg( MSG_USAGE_QUOTA_LIMITS,
        QuadToPaddedHexText( TempControlInfo.DefaultQuotaThreshold.QuadPart ),
        QuadToPaddedHexText( TempControlInfo.DefaultQuotaLimit.QuadPart )
        );

    return TRUE;
}


VOID
DumpQuota (
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo,
    IN PWSTR ServerName
    )
{
    NTSTATUS Status;
    SID_NAME_USE SidNameUse;
    ULONG AccountLength, DomainLength;
    WCHAR AccountName[128];
    WCHAR DomainName[128];

    AccountLength = sizeof(AccountName) - 1;
    DomainLength = sizeof(DomainName) - 1;

    if (FileQuotaInfo->SidLength == 0) {

        DisplayMsg( MSG_QUOTA_DUMP_DEFAULT );

    } else if (LookupAccountSid(
            ServerName,
            &FileQuotaInfo->Sid,
            AccountName,
            &AccountLength,
            DomainName,
            &DomainLength,
            &SidNameUse))
    {

        AccountName[AccountLength] = 0;
        DomainName[DomainLength] = 0;

        switch (SidNameUse) {
        case SidTypeUser:
            DisplayMsg( MSG_QUOTA_SID_USER, DomainName, AccountName );
            break;
        case SidTypeGroup:
            DisplayMsg( MSG_QUOTA_SID_GROUP, DomainName, AccountName );
            break;
        case SidTypeDomain:
            DisplayMsg( MSG_QUOTA_SID_DOMAIN, DomainName, AccountName );
            break;
        case SidTypeAlias:
            DisplayMsg( MSG_QUOTA_SID_ALIAS, DomainName, AccountName );
            break;
        case SidTypeWellKnownGroup:
            DisplayMsg( MSG_QUOTA_SID_WELLKNOWNGROUP, DomainName, AccountName );
            break;
        case SidTypeDeletedAccount:
            DisplayMsg( MSG_QUOTA_SID_DELETEDACCOUNT, DomainName, AccountName );
            break;
        case SidTypeInvalid:
            DisplayMsg( MSG_QUOTA_SID_INVALID, DomainName, AccountName );
            break;
        case SidTypeUnknown:
        default:
            DisplayMsg( MSG_QUOTA_SID_USER, DomainName, AccountName );
            break;
        }

    } else {

        DisplayError( );
    }

    DisplayMsg(
        MSG_QUOTA_DUMP_INFO,
        FileTimeToString(&FileQuotaInfo->ChangeTime),
        QuadToDecimalText( FileQuotaInfo->QuotaUsed.QuadPart ),
        QuadToDecimalText( FileQuotaInfo->QuotaThreshold.QuadPart ),
        QuadToDecimalText( FileQuotaInfo->QuotaLimit.QuadPart )
        );
}

INT
QueryDiskQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    NTSTATUS Status;
    HANDLE hFile;
    IO_STATUS_BLOCK IoStatus;
    PFILE_QUOTA_INFORMATION QuotaInfo;
    INT ExitCode = EXIT_CODE_SUCCESS;

    if (argc != 1) {
        DisplayMsg( MSG_USAGE_QUOTA_QUERY, argv[1] );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    if (!IsVolumeLocalNTFS( argv[0][0] )) {
        DisplayMsg( MSG_NTFS_REQUIRED );
        return EXIT_CODE_FAILURE;
    }

    hFile = QuotaOpenVolume( argv[0] );
    if (hFile == INVALID_HANDLE_VALUE) {
        return EXIT_CODE_FAILURE;
    }


    if (!DumpVolumeQuotaInfo( hFile, FALSE )) {
        DisplayMsg( MSG_USAGE_QUOTA_REQUIRED, argv[0] );
        CloseHandle( hFile );
        return EXIT_CODE_FAILURE;
    }

    DumpVolumeQuotaInfo( hFile, TRUE );


    QuotaInfo = malloc( sizeof( FILE_QUOTA_INFORMATION ) + SID_MAX_LENGTH );
    if (QuotaInfo == NULL) {
        DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
        CloseHandle( hFile );
        return EXIT_CODE_FAILURE;
    }

    while (TRUE) {

        Status = NtQueryQuotaInformationFile(
            hFile,                      //  File Handle
            &IoStatus,                  //  IO status block
            QuotaInfo,                  //  Buffer
            sizeof( FILE_QUOTA_INFORMATION ) + SID_MAX_LENGTH,          //  Length
            TRUE,                      //  Return Single Entry
            NULL,                       //  SidList
            0,                          //  SidListLength
            NULL,                       //  StartSid
            FALSE                       //  RestartScan
            );

        if (!NT_SUCCESS( Status )) {
            if (Status != STATUS_NO_MORE_ENTRIES) {
                DisplayErrorMsg( RtlNtStatusToDosError( Status ));
                ExitCode = EXIT_CODE_FAILURE;
            }
            break;
        }

        DumpQuota( QuotaInfo, NULL );

    }

    CloseHandle( hFile );
    free( QuotaInfo );

    return ExitCode;
}


INT
ChangeDiskQuota(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    NTSTATUS Status;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatus;
    PFILE_QUOTA_INFORMATION QuotaInfo;
    PFILE_GET_QUOTA_INFORMATION SidList;
    PFILE_QUOTA_INFORMATION QuotaInfoPtr;
    PFILE_GET_QUOTA_INFORMATION SidListPtr;
    ULONG BufferSize;
    ULONG SidListLength;
    PWSTR EndPtr;
    INT retval = EXIT_CODE_SUCCESS;

    if (argc != 4) {
        DisplayMsg( MSG_USAGE_QUOTA_MODIFY );
        if (argc != 0) {
            return EXIT_CODE_FAILURE;
        } else {
            return EXIT_CODE_SUCCESS;
        }
    }

    if (!IsVolumeLocalNTFS( argv[0][0] )) {
        DisplayMsg( MSG_NTFS_REQUIRED );
        return EXIT_CODE_FAILURE;
    }

    QuotaInfo = malloc( sizeof( FILE_QUOTA_INFORMATION ) + SID_MAX_LENGTH );
    SidList = malloc( sizeof( FILE_GET_QUOTA_INFORMATION ) + SID_MAX_LENGTH );

    try {

        if (QuotaInfo == NULL || SidList == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            retval = EXIT_CODE_FAILURE;
            leave;
        }

        RtlZeroMemory(QuotaInfo, sizeof( FILE_QUOTA_INFORMATION ) + SID_MAX_LENGTH);
        QuotaInfoPtr = QuotaInfo;
        RtlZeroMemory(SidList, sizeof( FILE_GET_QUOTA_INFORMATION ) + SID_MAX_LENGTH);
        SidListPtr = SidList;

        if (!GetUserSid( argv[3], &QuotaInfoPtr, &SidListPtr )) {
            DisplayError();
            retval = EXIT_CODE_FAILURE;
            leave;
        }

        QuotaInfoPtr->QuotaThreshold.QuadPart = My_wcstoui64( argv[1], &EndPtr, 0 );
        if (UnsignedI64NumberCheck( QuotaInfoPtr->QuotaThreshold.QuadPart, EndPtr )) {

            DisplayMsg( MSG_USAGE_QUOTA_MODIFY );
            retval = EXIT_CODE_FAILURE;
            leave;
        }

        QuotaInfoPtr->QuotaLimit.QuadPart = My_wcstoui64( argv[2], &EndPtr, 0 );
        if (UnsignedI64NumberCheck( QuotaInfoPtr->QuotaLimit.QuadPart, EndPtr )) {

            DisplayMsg( MSG_USAGE_QUOTA_MODIFY );
            retval = EXIT_CODE_FAILURE;
            leave;
        }

        //
        //  Build the complete quota info data structure
        //

        QuotaInfoPtr->NextEntryOffset = 0;
        //  QuotaInfoPtr->SidLength set in GetUserSid
        //  QuotaInfoPtr->ChangeTime is ignored
        //  QuotaInfoPtr->QuotaUsed is ignored
        //  QuotaInfoPtr->QuotaThreshold is set above
        //  QuotaInfoPtr->QuotaLimit is set above
        //  QuotaInfoPtr->Sid is set in GetUserSid

        //
        // Terminate the list.
        //

        BufferSize = FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid )  + QuotaInfoPtr->SidLength;

        //
        // Change it
        //

        hFile = QuotaOpenVolume( argv[0] );
        if (hFile == INVALID_HANDLE_VALUE) {
            DisplayError();
            retval = EXIT_CODE_FAILURE;
            leave;
        }

        Status = NtSetQuotaInformationFile(
                                          hFile,
                                          &IoStatus,
                                          QuotaInfo,
                                          BufferSize
                                          );
        if (!NT_SUCCESS( Status )) {
            DisplayErrorMsg( RtlNtStatusToDosError( Status ));
            retval = EXIT_CODE_FAILURE;
            leave;
        }
        retval = EXIT_CODE_SUCCESS;
    } finally {
        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
        }

        free( QuotaInfo );
        free( SidList );
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\sparse.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sparse.c

Abstract:

    This file contains code for commands that affect
    sparse files.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
SparseHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_SPARSE );

    return EXIT_CODE_SUCCESS;
}

BOOL
GetSparseFlag( 
    HANDLE Handle
    )
/*++

Routine Description:

    Retrieves the sparse attribute bit from an open file handle. If there's
    an error (due to the file system not supporting FileAttributeTagInformation)
    then we assume that the file cannot be sparse.

Arguments:

    Handle - handle to the stream.

Return Value:

    TRUE => stream attached to Handle is sparse
    FALSE otherwise

--*/
{
    FILE_ATTRIBUTE_TAG_INFORMATION TagInformation;
    IO_STATUS_BLOCK iosb;
    NTSTATUS Status;

    Status = NtQueryInformationFile( Handle, 
                                     &iosb, 
                                     &TagInformation, 
                                     sizeof( TagInformation ), 
                                     FileAttributeTagInformation );

    if (NT_SUCCESS( Status ) && 
        (TagInformation.FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}



INT
SetSparse(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine set the file specified as sparse.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setsparse <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOL Status;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_SETSPARSE_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_SET_SPARSE,
            NULL,
            0,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}


INT
QuerySparse(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine queries the file specified to see if it is sparse.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setsparse <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PVOID Frs;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
          DisplayMsg( MSG_QUERYSPARSE_USAGE );
          if (argc != 0) {
              ExitCode = EXIT_CODE_FAILURE;
          }
          leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Filename[2] = 0;

        if (GetSparseFlag( FileHandle )) {
            DisplayMsg( MSG_SPARSE_IS_SET );
        } else {
            DisplayMsg( MSG_SPARSE_ISNOT_SET );
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}

INT
SetSparseRange(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine sets a range of the file as sparse.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setsparse <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    FILE_ZERO_DATA_INFORMATION ZeroData;
    ULONG BytesReturned;
    BOOL b;
    PWSTR EndPtr;
    ULONGLONG v;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 3) {
            DisplayMsg( MSG_SETSPARSE_RANGE_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Filename[2] = 0;

        if (!GetSparseFlag( FileHandle )) {
            DisplayMsg( MSG_FILE_IS_NOT_SPARSE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        v = My_wcstoui64( argv[1], &EndPtr, 0 );
        if (UnsignedI64NumberCheck( v, EndPtr)) {
            DisplayMsg( MSG_SETSPARSE_RANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        ZeroData.FileOffset.QuadPart = v;


        v = My_wcstoui64( argv[2], &EndPtr, 0 );
        if (UnsignedI64NumberCheck( v, EndPtr)) {
            DisplayMsg( MSG_SETSPARSE_RANGE_USAGE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        ZeroData.BeyondFinalZero.QuadPart = v + ZeroData.FileOffset.QuadPart;

        b = DeviceIoControl(
            FileHandle,
            FSCTL_SET_ZERO_DATA,
            &ZeroData,
            sizeof(ZeroData),
            NULL,
            0,
            &BytesReturned,
            NULL
            );
        if (!b) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Filename );
    }

    return ExitCode;
}

INT
QuerySparseRange(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine queries a range of the file specified to see if it is sparse.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl setsparse <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOL b;
    FILE_ALLOCATED_RANGE_BUFFER RangesIn;
    PFILE_ALLOCATED_RANGE_BUFFER Ranges = NULL;
    ULONG NumRanges = 0;
    ULONG RangesSz = 0;
    ULONG BytesReturned;
    ULONG i;
    ULONG RangesReturned;
    LONGLONG LastOffset = 0;
    LARGE_INTEGER FileSize;
    ULONG gle = 0;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_QUERYSPARSE_RANGE_USAGE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Filename[2] = 0;

        if (!GetSparseFlag( FileHandle )) {
            DisplayMsg( MSG_FILE_IS_NOT_SPARSE );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        NumRanges = 64;
        RangesSz = sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NumRanges;
        Ranges = (PFILE_ALLOCATED_RANGE_BUFFER) malloc( RangesSz );
        if (Ranges == NULL) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        memset( Ranges, 0, RangesSz );

        GetFileSizeEx( FileHandle, &FileSize );

        RangesIn.FileOffset.QuadPart = 0;
        RangesIn.Length.QuadPart = FileSize.QuadPart;

        do {

            b = DeviceIoControl(
                FileHandle,
                FSCTL_QUERY_ALLOCATED_RANGES,
                &RangesIn,
                sizeof(RangesIn),
                Ranges,
                RangesSz,
                &BytesReturned,
                NULL
                );
            if (!b) {
                gle = GetLastError();
                if (gle == ERROR_INSUFFICIENT_BUFFER) {
                    //
                    //  No data were returned because the buffer is too small
                    //
                    free( Ranges );
                    NumRanges += 64;
                    RangesSz = sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NumRanges;
                    Ranges = (PFILE_ALLOCATED_RANGE_BUFFER) malloc( RangesSz );
                    if (Ranges == NULL) {
                        DisplayError();
                        ExitCode = EXIT_CODE_FAILURE;
                        leave;
                    }
                    memset( Ranges, 0, RangesSz );
                } else if (gle == ERROR_MORE_DATA) {

                } else {
                    DisplayError();
                    ExitCode = EXIT_CODE_FAILURE;
                    leave;
                }
            }

            RangesReturned = BytesReturned / sizeof(FILE_ALLOCATED_RANGE_BUFFER);

            for (i=0; i<RangesReturned; i++) {
                if (Ranges[i].FileOffset.QuadPart >= LastOffset) {
                    WCHAR Buffer[32];
                    swprintf( Buffer, L"[%I64d] [%I64d]", Ranges[i].FileOffset.QuadPart, Ranges[i].Length.QuadPart );
                    DisplayMsg( MSG_SPARSE_RANGE, Buffer );
                }
                LastOffset = Ranges[i].FileOffset.QuadPart;
            }

        } while(gle);

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( Ranges );
        free( Filename );
    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\reparse.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    reparse.c

Abstract:

    This file contains code for commands that affect
    reparse points.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
ReparseHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_REPARSEPOINT );
    return EXIT_CODE_SUCCESS;
}

//
//  This is the definition of the DATA portion of the SIS reparse buffer.
//

#define	SIS_REPARSE_BUFFER_FORMAT_VERSION 5

typedef struct _SIS_REPARSE_BUFFER {

	ULONG							ReparsePointFormatVersion;
	ULONG							Reserved;

	//
	// The id of the common store file.
	//
	GUID							CSid;

	//
	// The index of this link file.
	//
	LARGE_INTEGER   				LinkIndex;

    //
    // The file ID of the link file.
    //
    LARGE_INTEGER                   LinkFileNtfsId;

    //
    // The file ID of the common store file.
    //
    LARGE_INTEGER                   CSFileNtfsId;

	//
	// A "131 hash" checksum of the contents of the
	// common store file.
	//
	LARGE_INTEGER					CSChecksum;

    //
    // A "131 hash" checksum of this structure.
    // N.B.  Must be last.
    //
    LARGE_INTEGER                   Checksum;

} SIS_REPARSE_BUFFER, *PSIS_REPARSE_BUFFER;


INT
DisplaySISReparsePointData( 
    PREPARSE_DATA_BUFFER ReparseData
    )

/*++

Routine Description:

    This routine displays the SIS reparse data

Arguments:


Return Value:

    None

--*/
{
    PSIS_REPARSE_BUFFER sisRp;
    WCHAR csID[40];

    //
    //  Point to the SIS unique portion of the buffer
    //

    sisRp = (PSIS_REPARSE_BUFFER)&ReparseData->GenericReparseBuffer.DataBuffer;

    DisplayMsg( MSG_SIS_REPARSE_INFO,
                sisRp->ReparsePointFormatVersion,
                Guid2Str( &sisRp->CSid, csID, sizeof(csID) ),
                sisRp->LinkIndex.HighPart, 
                sisRp->LinkIndex.LowPart,
                sisRp->LinkFileNtfsId.HighPart,
                sisRp->LinkFileNtfsId.LowPart,
                sisRp->CSFileNtfsId.HighPart,
                sisRp->CSFileNtfsId.LowPart,
                sisRp->CSChecksum.HighPart,
                sisRp->CSChecksum.LowPart,
                sisRp->Checksum.HighPart,
                sisRp->Checksum.LowPart);

    return EXIT_CODE_SUCCESS;
}

//
// Placeholder data - all versions unioned together
//

#define RP_RESV_SIZE 52

typedef struct _RP_PRIVATE_DATA {
   CHAR           reserved[RP_RESV_SIZE];        // Must be 0
   ULONG          bitFlags;            // bitflags indicating status of the segment
   LARGE_INTEGER  migrationTime;       // When migration occurred
   GUID           hsmId;
   GUID           bagId;
   LARGE_INTEGER  fileStart;
   LARGE_INTEGER  fileSize;
   LARGE_INTEGER  dataStart;
   LARGE_INTEGER  dataSize;
   LARGE_INTEGER  fileVersionId;
   LARGE_INTEGER  verificationData;
   ULONG          verificationType;
   ULONG          recallCount;
   LARGE_INTEGER  recallTime;
   LARGE_INTEGER  dataStreamStart;
   LARGE_INTEGER  dataStreamSize;
   ULONG          dataStream;
   ULONG          dataStreamCRCType;
   LARGE_INTEGER  dataStreamCRC;
} RP_PRIVATE_DATA, *PRP_PRIVATE_DATA;



typedef struct _RP_DATA {
   GUID              vendorId;         // Unique HSM vendor ID -- This is first to match REPARSE_GUID_DATA_BUFFER
   ULONG             qualifier;        // Used to checksum the data
   ULONG             version;          // Version of the structure
   ULONG             globalBitFlags;   // bitflags indicating status of the file
   ULONG             numPrivateData;   // number of private data entries
   GUID              fileIdentifier;   // Unique file ID
   RP_PRIVATE_DATA   data;             // Vendor specific data
} RP_DATA, *PRP_DATA;

INT
DisplayRISReparsePointData( 
    PREPARSE_DATA_BUFFER ReparseData
    )

/*++

Routine Description:

    This routine displays the SIS reparse data

Arguments:


Return Value:

    None

--*/
{
    PRP_DATA risRp;
    WCHAR vendorID[40];
    WCHAR fileID[40];
    WCHAR hsmID[40];
    WCHAR bagID[40];
    WCHAR migrationTime[32];
    WCHAR recallTime[32];

    //
    //  Point to the SIS unique portion of the buffer
    //

    risRp = (PRP_DATA)&ReparseData->GenericReparseBuffer.DataBuffer;

    DisplayMsg( MSG_RIS_REPARSE_INFO,
                Guid2Str( &risRp->vendorId, vendorID, sizeof(vendorID) ),
                risRp->qualifier,
                risRp->version,
                risRp->globalBitFlags,
                risRp->numPrivateData,
                Guid2Str( &risRp->fileIdentifier, fileID, sizeof(fileID) ),
                risRp->data.bitFlags,
                FileTime2String( &risRp->data.migrationTime, migrationTime, sizeof(migrationTime) ),
                Guid2Str( &risRp->data.hsmId, hsmID, sizeof(hsmID) ),
                Guid2Str( &risRp->data.bagId, bagID, sizeof(bagID) ),
                risRp->data.fileStart.HighPart,
                risRp->data.fileStart.LowPart,
                risRp->data.fileSize.HighPart,
                risRp->data.fileSize.LowPart,
                risRp->data.dataStart.HighPart,
                risRp->data.dataStart.LowPart,
                risRp->data.dataSize.HighPart,
                risRp->data.dataSize.LowPart,
                risRp->data.fileVersionId.HighPart,
                risRp->data.fileVersionId.LowPart,
                risRp->data.verificationData.HighPart,
                risRp->data.verificationData.LowPart,
                risRp->data.verificationType,
                risRp->data.recallCount,
                FileTime2String( &risRp->data.recallTime, recallTime, sizeof(recallTime) ),
                risRp->data.dataStreamStart.HighPart,
                risRp->data.dataStreamStart.LowPart,
                risRp->data.dataStreamSize.HighPart,
                risRp->data.dataStreamSize.LowPart,
                risRp->data.dataStream,
                risRp->data.dataStreamCRCType,
                risRp->data.dataStreamCRC.HighPart,
                risRp->data.dataStreamCRC.LowPart );

    return EXIT_CODE_SUCCESS;
}


INT
DisplayMountPointData( 
    PREPARSE_DATA_BUFFER ReparseData
    )

/*++

Routine Description:

    This routine displays the SIS reparse data

Arguments:


Return Value:

    None

--*/
{
    //
    //  Display offset and length values
    //

    DisplayMsg( MSG_MOUNT_POINT_INFO,
                ReparseData->MountPointReparseBuffer.SubstituteNameOffset,
                ReparseData->MountPointReparseBuffer.SubstituteNameLength,
                ReparseData->MountPointReparseBuffer.PrintNameOffset,
                ReparseData->MountPointReparseBuffer.PrintNameLength);

    //
    //  Display Name Substitue name if there is one
    //

    if (ReparseData->MountPointReparseBuffer.SubstituteNameLength > 0) {

        DisplayMsg( MSG_MOUNT_POINT_SUBSTITUE_NAME,
                    (ReparseData->MountPointReparseBuffer.SubstituteNameLength / sizeof(WCHAR)),
                    &ReparseData->MountPointReparseBuffer.PathBuffer[ReparseData->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)]);
    }

    //
    //  Display PRINT NAME if there is one
    //

    if (ReparseData->MountPointReparseBuffer.PrintNameLength > 0) {

        DisplayMsg( MSG_MOUNT_POINT_PRINT_NAME,
                    (ReparseData->MountPointReparseBuffer.PrintNameLength / sizeof(WCHAR)),
                    &ReparseData->MountPointReparseBuffer.PathBuffer[ReparseData->MountPointReparseBuffer.PrintNameOffset/sizeof(WCHAR)]);
    }


    return EXIT_CODE_SUCCESS;
}


VOID
DisplayGenericReparseData( 
    UCHAR *ReparseData,
    DWORD DataSize
    )

/*++

Routine Description:

    This routine displays the SIS reparse data

Arguments:


Return Value:

    None

--*/
{
    ULONG i, j;
    WCHAR Buf[17];
    WCHAR CharBuf[3 + 1];

    OutputMessage( L"\r\n" );
    DisplayMsg( MSG_REPARSE_DATA_LENGTH, DataSize );

    if (DataSize > 0) {
        
        DisplayMsg( MSG_GETREPARSE_DATA );
        for (i = 0; i < DataSize; i += 16 ) {
            swprintf( Buf, L"%04x: ", i );
            OutputMessage( Buf );
            for (j = 0; j < 16 && j + i < DataSize; j++) {
                UCHAR c = ReparseData[ i + j ];

                if (c >= 0x20 && c <= 0x7F) {
                    Buf[j] = c;
                } else {
                    Buf[j] = L'.';
                }
                
                swprintf( CharBuf, L" %02x", c );
                OutputMessage( CharBuf );

                if (j == 7)
                    OutputMessage( L" " );
            }
            
            Buf[j] = L'\0';

            for ( ; j < 16; j++ ) {
                OutputMessage( L"   " );

                if (j == 7)
                    OutputMessage( L" " );
            }

            OutputMessage( L"  " );
            OutputMessage( Buf );
            OutputMessage( L"\r\n" );
        }
    }
}




INT
GetReparsePoint(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine gets the reparse point for the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl getrp <pathname>'.

Return Value:

    None

--*/
{
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PREPARSE_DATA_BUFFER lpOutBuffer = NULL;
    BOOL Status;
    HRESULT Result;
    DWORD BytesReturned;
    ULONG ulMask;
    WCHAR Buffer[256];
    LPWSTR GuidStr;
    INT ExitCode = EXIT_CODE_SUCCESS;

#define MAX_REPARSE_DATA 0x4000

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_GETREPARSE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpOutBuffer = (PREPARSE_DATA_BUFFER)  malloc ( MAX_REPARSE_DATA );
        if (lpOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_GET_REPARSE_POINT,
            NULL,
            0,
            (LPVOID) lpOutBuffer,
            MAX_REPARSE_DATA,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg( MSG_GETREPARSE_TAGVAL, lpOutBuffer->ReparseTag );

        if (IsReparseTagMicrosoft( lpOutBuffer->ReparseTag )) {
            DisplayMsg( MSG_TAG_MICROSOFT );
        }
        if (IsReparseTagNameSurrogate( lpOutBuffer->ReparseTag )) {
            DisplayMsg( MSG_TAG_NAME_SURROGATE );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_SYMBOLIC_LINK) {
            DisplayMsg( MSG_TAG_SYMBOLIC_LINK );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {
            DisplayMsg( MSG_TAG_MOUNT_POINT );
            ExitCode = DisplayMountPointData( lpOutBuffer );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_HSM) {
            DisplayMsg( MSG_TAG_HSM );
            ExitCode = DisplayRISReparsePointData( lpOutBuffer );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_SIS) {
            DisplayMsg( MSG_TAG_SIS );
            ExitCode = DisplaySISReparsePointData( lpOutBuffer );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_FILTER_MANAGER) {
            DisplayMsg( MSG_TAG_FILTER_MANAGER );
        }
        if (lpOutBuffer->ReparseTag == IO_REPARSE_TAG_DFS) {
            DisplayMsg( MSG_TAG_DFS );
        }

        //
        //  This is an unknown tag, display the data
        //

        if (IsReparseTagMicrosoft( lpOutBuffer->ReparseTag )) {

            //
            //  Display Microsoft tag data, note that these do NOT use
            //  the GUID form of the buffer
            //

            DisplayGenericReparseData( lpOutBuffer->GenericReparseBuffer.DataBuffer,
                                       lpOutBuffer->ReparseDataLength );

        } else {

            //
            //  Display NON-Microsoft tag data, note that these DO use
            //  the GUID form of the buffer
            //

            PREPARSE_GUID_DATA_BUFFER nmReparseData = (PREPARSE_GUID_DATA_BUFFER)lpOutBuffer;

            Result = StringFromIID( &nmReparseData->ReparseGuid, &GuidStr );
            if (Result != S_OK) {
                DisplayErrorMsg( Result );
                ExitCode = EXIT_CODE_FAILURE;
                leave;
            }

            DisplayMsg( MSG_GETREPARSE_GUID, GuidStr );
        
            DisplayGenericReparseData( nmReparseData->GenericReparseBuffer.DataBuffer,
                                       nmReparseData->ReparseDataLength );

            CoTaskMemFree(GuidStr);
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( lpOutBuffer );
        free( Filename );
    }
    return ExitCode;
}


INT
DeleteReparsePoint(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine deletes the reparse point associated with
    the file specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl delrp <pathname>'.

Return Value:

    None

--*/
{
    BOOL Status;
    PWSTR Filename = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PREPARSE_GUID_DATA_BUFFER lpInOutBuffer = NULL;
    DWORD nInOutBufferSize;
    DWORD BytesReturned;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_DELETE_REPARSE );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        Filename = GetFullPath( argv[0] );
        if (!Filename) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( Filename[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nInOutBufferSize = REPARSE_GUID_DATA_BUFFER_HEADER_SIZE + MAX_REPARSE_DATA;
        lpInOutBuffer = (PREPARSE_GUID_DATA_BUFFER)  malloc ( nInOutBufferSize );
        if (lpInOutBuffer == NULL) {
            DisplayErrorMsg( ERROR_NOT_ENOUGH_MEMORY );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        FileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_GET_REPARSE_POINT,
            NULL,
            0,
            (LPVOID) lpInOutBuffer,
            nInOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        lpInOutBuffer->ReparseDataLength = 0;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_DELETE_REPARSE_POINT,
            (LPVOID) lpInOutBuffer,
            REPARSE_GUID_DATA_BUFFER_HEADER_SIZE,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        free( lpInOutBuffer );
        free( Filename );
    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\volume.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    volume.c

Abstract:

    This file contains code for all commands that effect a volume

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
VolumeHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_VOLUME );

    return EXIT_CODE_SUCCESS;
}

DWORD
QueryHardDiskNumber(
    IN UCHAR DriveLetter
    )
{
    WCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = DriveLetter;
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFile(
        driveName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE
        );
    if (h == INVALID_HANDLE_VALUE) {
        return (DWORD) -1;
    }

    b = DeviceIoControl(
        h,
        IOCTL_STORAGE_GET_DEVICE_NUMBER,
        NULL,
        0,
        &number,
        sizeof(number),
        &bytes,
        NULL
        );

    CloseHandle(h);

    if (!b) {
        return (DWORD) -1;
    }

    return number.DeviceNumber;
}


INT
DismountVolume(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine dismounts the volume.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl dismountv <volume pathname>'.

Return Value:

    None

--*/
{
    BOOL Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD BytesReturned;
    WCHAR FileName[MAX_PATH];
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_DISMOUNTV );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[0] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        
        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[0] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_DISMOUNT_VOLUME,
            NULL,
            0,
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}


INT
DiskFreeSpace(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine provides information about free disk space in the
    directory path passed in.

Arguments:

    argc - The argument count
    argv - Array of Strings of the form :
           'fscutl df <drive name>'.

Return Value:

    None

--*/
{
    ULARGE_INTEGER FreeBytesAvailableToCaller; // receives the number of bytes on disk available to the caller
    ULARGE_INTEGER TotalNumberOfBytes;         // receives the number of bytes on disk
    ULARGE_INTEGER TotalNumberOfFreeBytes;     // receives the free bytes on disk
    BOOL Status;                               // return status
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_DF );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave ;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = GetDiskFreeSpaceEx(
            argv[0],
            &FreeBytesAvailableToCaller,
            &TotalNumberOfBytes,
            &TotalNumberOfFreeBytes
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg( MSG_DISKFREE, 
                    QuadToDecimalText( TotalNumberOfFreeBytes.QuadPart ), 
                    QuadToDecimalText( TotalNumberOfBytes.QuadPart ), 
                    QuadToDecimalText( FreeBytesAvailableToCaller.QuadPart ));

    } finally {

    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\usn.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usn.c

Abstract:

    This file contains code for commands that affect
    the usn journal.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


#define MAX_USN_DATA                              4096

//
//  Arguments and lengths
//

#define ARG_MAXSIZE         L"m="
#define ARG_MAXSIZE_LEN     2

#define ARG_ALLOCDELTA      L"a="
#define ARG_ALLOCDELTA_LEN  2


INT
UsnHelp(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    DisplayMsg( MSG_USAGE_USN );
    return EXIT_CODE_SUCCESS;
}

__inline PUSN_RECORD
NextUsnRecord(
    const PUSN_RECORD input
    )
{
    ULONGLONG output;

    // Get the base address of the current record.
    (PUSN_RECORD) output = input;

    // Add the size of the record (structure + file name after the end
    // of the structure).
    output += input->RecordLength;

    // Round up the record size to match the 64-bit alignment, if the
    // size is not already a multiple of 8. Perform a bitwise AND
    // operation here instead of division because it is much faster than
    // division. However, the bitwise AND operation only works because
    // the divisor 8 is a power of 2.

    if (output & 8-1) {
        // Round down to nearest multiple of 8.
        output &= -8;
        // Then add 8.
        output += 8;
    }

    return((PUSN_RECORD) output);
}

VOID
DisplayUsnRecord(
    const PUSN_RECORD UsnRecord
    )
{

    WCHAR DateString[128];
    WCHAR TimeString[128];
    TIME_FIELDS TimeFields;
    SYSTEMTIME SystemTime;

    RtlTimeToTimeFields(&UsnRecord->TimeStamp, &TimeFields);

    SystemTime.wYear         = TimeFields.Year        ;
    SystemTime.wMonth        = TimeFields.Month       ;
    SystemTime.wDayOfWeek    = TimeFields.Weekday     ;
    SystemTime.wDay          = TimeFields.Day         ;
    SystemTime.wHour         = TimeFields.Hour        ;
    SystemTime.wMinute       = TimeFields.Minute      ;
    SystemTime.wSecond       = TimeFields.Second      ;
    SystemTime.wMilliseconds = TimeFields.Milliseconds;


    GetDateFormat( LOCALE_USER_DEFAULT,
       DATE_SHORTDATE,
       &SystemTime,
       NULL,
       DateString,
       sizeof( DateString ) / sizeof( DateString[0] ));

    GetTimeFormat( LOCALE_USER_DEFAULT,
       FALSE,
       &SystemTime,
       NULL,
       TimeString,
       sizeof( TimeString ) / sizeof( TimeString[0] ));

    DisplayMsg(
        MSG_USNRECORD,
        UsnRecord->MajorVersion,
        UsnRecord->MinorVersion,
        QuadToPaddedHexText( UsnRecord->FileReferenceNumber ),
        QuadToPaddedHexText( UsnRecord->ParentFileReferenceNumber ),
        QuadToPaddedHexText( UsnRecord->Usn ),
        QuadToPaddedHexText( UsnRecord->TimeStamp.QuadPart ),
        TimeString, DateString,
        UsnRecord->Reason,
        UsnRecord->SourceInfo,
        UsnRecord->SecurityId,
        UsnRecord->FileAttributes,
        UsnRecord->FileNameLength,
        UsnRecord->FileNameOffset,
        UsnRecord->FileNameLength/sizeof(WCHAR),
        UsnRecord->FileName
        );
}


INT
CreateUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine create the USN journal for the volume specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl crusnj m=<max-value> a=<alloc-delta> <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    CREATE_USN_JOURNAL_DATA InBuffer;
    ULONGLONG MaxSize;
    ULONGLONG AllocDelta;
    PWSTR EndPtr;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 3) {
            DisplayMsg( MSG_USAGE_CREATEUSN );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[2][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[2] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[2] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (_wcsnicmp( argv[0], ARG_MAXSIZE, ARG_MAXSIZE_LEN)
            || wcslen( argv[0] ) == ARG_MAXSIZE_LEN) {
            DisplayMsg( MSG_INVALID_PARAMETER, argv[0] );
            DisplayMsg( MSG_USAGE_CREATEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }
        if (_wcsnicmp( argv[1], ARG_ALLOCDELTA, ARG_ALLOCDELTA_LEN)
            || wcslen( argv[1] ) == ARG_ALLOCDELTA_LEN) {
            DisplayMsg( MSG_INVALID_PARAMETER, argv[1] );
            DisplayMsg( MSG_USAGE_CREATEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        MaxSize = My_wcstoui64( argv[0] + ARG_MAXSIZE_LEN, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( MaxSize, EndPtr )) {
            DisplayMsg( MSG_INVALID_PARAMETER, argv[0] );
            DisplayMsg( MSG_USAGE_CREATEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        AllocDelta = My_wcstoui64( argv[1] + ARG_ALLOCDELTA_LEN, &EndPtr, 0 );
        if (UnsignedI64NumberCheck( AllocDelta, EndPtr )) {
            DisplayMsg( MSG_INVALID_PARAMETER, argv[1] );
            DisplayMsg( MSG_USAGE_CREATEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        InBuffer.MaximumSize = MaxSize;
        InBuffer.AllocationDelta = AllocDelta;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_CREATE_USN_JOURNAL,
            &InBuffer,
            sizeof(InBuffer),
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}


INT
QueryUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine queries the USN journal for the volume specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl queryusnj <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    USN_JOURNAL_DATA UsnJournalData;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_QUERYUSN );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[0][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[0] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[0] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_QUERY_USN_JOURNAL,
            NULL,
            0,
            &UsnJournalData,
            sizeof(USN_JOURNAL_DATA),
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayMsg(
            MSG_QUERYUSN,
            QuadToPaddedHexText( UsnJournalData.UsnJournalID ),
            QuadToPaddedHexText( UsnJournalData.FirstUsn ),
            QuadToPaddedHexText( UsnJournalData.NextUsn ),
            QuadToPaddedHexText( UsnJournalData.LowestValidUsn ),
            QuadToPaddedHexText( UsnJournalData.MaxUsn ),
            QuadToPaddedHexText( UsnJournalData.MaximumSize ),
            QuadToPaddedHexText( UsnJournalData.AllocationDelta )
            );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}


INT
DeleteUsnJournal(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine deletes the USN journal for the volume specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl delusnj <flags> <volume pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    DELETE_USN_JOURNAL_DATA DeleteUsnJournalData;
    USN_JOURNAL_DATA UsnJournalData;
    INT i;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc < 2) {
            DisplayMsg( MSG_USAGE_DELETEUSN );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[argc-1][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[argc - 1] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[argc - 1] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_QUERY_USN_JOURNAL,
            NULL,
            0,
            &UsnJournalData,
            sizeof(USN_JOURNAL_DATA),
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DeleteUsnJournalData.DeleteFlags = USN_DELETE_FLAG_DELETE ;

        for (i = 0; i < argc - 1; i++) {
            if (argv[i][0] == L'/' && wcslen( argv[i] ) == 2) {
                switch (towupper( argv[i][1] ) ) {
                case L'D':
                    DeleteUsnJournalData.DeleteFlags |= USN_DELETE_FLAG_DELETE ;
                    continue;

                case L'N':
                    DeleteUsnJournalData.DeleteFlags |= USN_DELETE_FLAG_NOTIFY ;
                    continue;
                }

            }
            DisplayMsg( MSG_INVALID_PARAMETER, argv[i] );
            DisplayMsg( MSG_USAGE_DELETEUSN );
            ExitCode = EXIT_CODE_FAILURE;
            leave;

        }

        DeleteUsnJournalData.UsnJournalID = UsnJournalData.UsnJournalID;

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_DELETE_USN_JOURNAL,
            &DeleteUsnJournalData,
            sizeof(DELETE_USN_JOURNAL_DATA),
            NULL,
            0,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }

    }

    return ExitCode;
}

INT
EnumUsnData(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine enumerated the USN data associated with the volume
    specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl enusndata <file ref#> <lowUsn> <highUsn> <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    MFT_ENUM_DATA MftEnumData;
    PVOID lpOutBuffer = NULL;
    DWORD nOutBufferSize;
    PUSN_RECORD UsnRecord;
    WORD Index;
    LONG Length;
    PWSTR EndStr;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 4) {
            DisplayMsg( MSG_USAGE_ENUMDATA );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        if (!IsVolumeLocalNTFS( argv[argc-1][0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( argv[argc - 1] ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, DotPrefix );
        wcscat( FileName, argv[argc - 1] );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = MAX_USN_DATA;
        lpOutBuffer = (PVOID) malloc ( nOutBufferSize );

        MftEnumData.StartFileReferenceNumber = My_wcstoui64( argv[0], &EndStr, 0 );
        if (UnsignedI64NumberCheck( MftEnumData.StartFileReferenceNumber, EndStr )) {
            DisplayMsg( MSG_USAGE_ENUMDATA );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        MftEnumData.LowUsn = My_wcstoui64( argv[1], &EndStr, 0 );
        if (UnsignedI64NumberCheck( MftEnumData.LowUsn, EndStr )) {
            DisplayMsg( MSG_USAGE_ENUMDATA );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        MftEnumData.HighUsn = My_wcstoui64( argv[2], &EndStr, 0 );
        if (UnsignedI64NumberCheck( MftEnumData.HighUsn, EndStr )) {
            DisplayMsg( MSG_USAGE_ENUMDATA );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        while (TRUE) {
            Status = DeviceIoControl(
                FileHandle,
                FSCTL_ENUM_USN_DATA,
                &MftEnumData,
                sizeof(MFT_ENUM_DATA),
                lpOutBuffer,
                nOutBufferSize,
                &BytesReturned,
                (LPOVERLAPPED)NULL
                );
            if (!Status) {
                if (GetLastError() != ERROR_HANDLE_EOF) {
                    DisplayError();
                    ExitCode = EXIT_CODE_FAILURE;
                }
                leave;
            }

            if ( BytesReturned < sizeof( ULONGLONG ) + sizeof( USN_RECORD )) {
                break;
            }

            UsnRecord = (PUSN_RECORD) ((PBYTE)lpOutBuffer + sizeof( ULONGLONG ));
            while ((PBYTE)UsnRecord < (PBYTE)lpOutBuffer + BytesReturned) {
                DisplayMsg(
                    MSG_ENUMDATA,
                    QuadToPaddedHexText( UsnRecord->FileReferenceNumber ),
                    QuadToPaddedHexText( UsnRecord->ParentFileReferenceNumber ),
                    QuadToPaddedHexText( UsnRecord->Usn ),
                    UsnRecord->SecurityId,
                    UsnRecord->Reason,
                    UsnRecord->FileNameLength,
                    UsnRecord->FileNameLength / sizeof(WCHAR),
                    UsnRecord->FileName
                    );
                UsnRecord = NextUsnRecord( UsnRecord );
            }
            MftEnumData.StartFileReferenceNumber = *(PLONGLONG)lpOutBuffer;
        }

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (lpOutBuffer) {
            free( lpOutBuffer );
        }

    }

    return ExitCode;
}


INT
ReadFileUsnData(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine reads the usn data for the volume specified.

Arguments:

    argc - The argument count.
    argv - Array of Strings of the form :
           ' fscutl rdusndata <pathname>'.

Return Value:

    None

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    WCHAR FileName[MAX_PATH];
    BOOL Status;
    DWORD BytesReturned;
    DWORD nOutBufferSize;
    PUSN_RECORD UsnRecord = NULL;
    PWSTR FullName;
    INT ExitCode = EXIT_CODE_SUCCESS;

    try {

        if (argc != 1) {
            DisplayMsg( MSG_USAGE_READDATA );
            if (argc != 0) {
                ExitCode = EXIT_CODE_FAILURE;
            }
            leave;
        }

        FullName = GetFullPath( argv[0] );

        if (!FullName) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (!IsVolumeLocalNTFS( FullName[0] )) {
            DisplayMsg( MSG_NTFS_REQUIRED );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        if (wcslen( DotPrefix ) + wcslen( FullName ) + 1 > MAX_PATH) {
            DisplayMsg( MSG_FILENAME_TOO_LONG );
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        wcscpy( FileName, DotPrefix );
        wcscat( FileName, FullName );

        FileHandle = CreateFile(
            FileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (FileHandle == INVALID_HANDLE_VALUE) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        nOutBufferSize = MAX_USN_DATA;
        UsnRecord = (PUSN_RECORD) malloc ( nOutBufferSize );

        Status = DeviceIoControl(
            FileHandle,
            FSCTL_READ_FILE_USN_DATA,
            NULL,
            0,
            UsnRecord,
            nOutBufferSize,
            &BytesReturned,
            (LPOVERLAPPED)NULL
            );
        if (!Status) {
            DisplayError();
            ExitCode = EXIT_CODE_FAILURE;
            leave;
        }

        DisplayUsnRecord( UsnRecord );

    } finally {

        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( FileHandle );
        }
        if (UsnRecord) {
            free( UsnRecord );
        }

        free( FullName );

    }

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fu\utility.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utility.c

Abstract:

    This file contains utility functions that are
    used by all other files in this project.

Author:

    Wesley Witt           [wesw]        1-March-2000

Revision History:

--*/

#include <precomp.h>


INT
Help(
    IN INT argc,
    IN PWSTR argv[]
    )
/*++

Routine Description:

    This routine lists out the various command supported by the
    tool.

Arguments:

    None

Return Value:

    None

--*/
{
    DisplayMsg( MSG_USAGE );
    return EXIT_CODE_SUCCESS;
}



VOID
OutputMessage(
    LPWSTR Message
    )
{
    OutputMessageLength( Message, wcslen( Message ));
}

VOID
OutputMessageLength(
    LPWSTR Message,
    int Length
    )
{
    DWORD       dwBytesWritten;
    DWORD       fdwMode;
    HANDLE      outHandle = GetStdHandle( STD_OUTPUT_HANDLE );    
    
    //
    //  If we have a char mode output handle and that handle
    //  looks like a console handle, then use unicode
    //  output
    //
    
    if (GetFileType( outHandle ) == FILE_TYPE_CHAR  
        && GetConsoleMode( outHandle, &fdwMode )) {
    
        WriteConsole( outHandle, 
                      Message, 
                      Length, 
                      &dwBytesWritten, 
                      0 );
    
    } else {
    
        //
        //  Output device can't handle Unicode.  The best we can do is
        //  convert to multibyte byte strings and just write it out.
        //  Yes, some codepoints won't make it out, but the convention
        //  is that file output is MBCS
        //
        
        int charCount = 
            WideCharToMultiByte( GetConsoleOutputCP( ), 
                                 0, 
                                 Message, 
                                 Length, 
                                 0, 
                                 0, 
                                 0, 
                                 0 );

        PCHAR szaStr = (PCHAR) malloc( charCount + 1 );
    
        if (szaStr != NULL) {
            WideCharToMultiByte( GetConsoleOutputCP( ), 0, Message, Length, szaStr, charCount + 1, 0, 0);

            WriteFile( outHandle, szaStr, charCount, &dwBytesWritten, 0 );

            free( szaStr );     
        }
    }
}



HANDLE NtDllHandle = INVALID_HANDLE_VALUE;

VOID
DisplayErrorMsg(
    LONG msgId,
    ...
    )
/*++

Routine Description:

    This routine displays the error message correspnding to
    the error indicated by msgId.

Arguments:

    msgId - the errorId. This is either the Win32 status code or the message ID.

Return Value:

    None

--*/
{
    
    va_list args;
    LPWSTR lpMsgBuf;

    va_start( args, msgId );
    
    if (FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_ERROR,
        0,
        (LPWSTR) &lpMsgBuf,
        0,
        NULL
        ))
    {
        OutputMessage( lpMsgBuf );
        LocalFree( lpMsgBuf );
    }

    if (FormatMessage(
        (msgId >= MSG_FIRST_MESSAGE_ID ? FORMAT_MESSAGE_FROM_HMODULE :
                                        FORMAT_MESSAGE_FROM_SYSTEM)
         | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL,
        msgId,
        0,
        (LPWSTR) &lpMsgBuf,
        0,
        &args
        ))
    {
        OutputMessage( L" " );
        OutputMessage( lpMsgBuf );
        OutputMessage( L"\r\n" );
        LocalFree( lpMsgBuf );
    } else {
        if (NtDllHandle == INVALID_HANDLE_VALUE) {
            NtDllHandle = GetModuleHandle( L"NTDLL" );
        }
        
        if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            (LPVOID)NtDllHandle,
            msgId,
            0,
            (LPWSTR) &lpMsgBuf,
            0,
            &args))
        {
            OutputMessage( L" " );
            OutputMessage( lpMsgBuf );
            OutputMessage( L"\r\n" );
            LocalFree( lpMsgBuf );
        } else {
            wprintf( L"Unable to format message for id %x - %x\n", msgId, GetLastError( ));
        }
    }
    
    va_end( args );
}


VOID
DisplayMsg(
    LONG msgId,
    ...
    )
/*++

Routine Description:

    This routine displays the error message correspnding to
    the error indicated by msgId.

Arguments:

    msgId - the errorId. This is either the Win32 status or the 
        message Id

Return Value:

    None

--*/
{
    va_list args;
    LPWSTR lpMsgBuf;


    va_start( args, msgId );

    if (FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        msgId,
        0, 
        (LPWSTR) &lpMsgBuf,
        0,
        &args
        ))
    {
        OutputMessage( lpMsgBuf );
        LocalFree( lpMsgBuf );
    } else {
        if (NtDllHandle == INVALID_HANDLE_VALUE) {
            NtDllHandle = GetModuleHandle( L"NTDLL" );
        }
        
        if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            (LPVOID)NtDllHandle,
            msgId,
            0,
            (LPWSTR) &lpMsgBuf,
            0,
            &args))
        {
            OutputMessage( L" " );
            OutputMessage( lpMsgBuf );
            OutputMessage( L"\r\n" );
            LocalFree( lpMsgBuf );
        } else {
            wprintf( L"Unable to format message for id %x - %x\n", msgId, GetLastError( ));
        }
    }
    va_end( args );
}

VOID
DisplayError(
    void
    )
/*++

Routine Description:

    This routine displays the last error message.

Arguments:

    None

Return Value:

    None

--*/
{
    DisplayErrorMsg( GetLastError() );
}


BOOL
EnablePrivilege(
    LPCWSTR SePrivilege
    )
{
    HANDLE              Token;
    PTOKEN_PRIVILEGES   NewPrivileges = NULL;
    BYTE                OldPriv[1024];
    PBYTE               pbOldPriv = NULL;
    ULONG               cbNeeded;
    BOOL                b = TRUE;
    LUID                LuidPrivilege;

    //
    // Make sure we have access to adjust and to get the old
    // token privileges
    //
    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &Token))
    {
        return( FALSE );
    }

    try {

        cbNeeded = 0;

        //
        // Initialize the privilege adjustment structure
        //

        LookupPrivilegeValue(NULL, SePrivilege, &LuidPrivilege );

        NewPrivileges = (PTOKEN_PRIVILEGES)
                        calloc(1,sizeof(TOKEN_PRIVILEGES) +
                               (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
        if (NewPrivileges == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            b = FALSE;
            leave;
        }

        NewPrivileges->PrivilegeCount = 1;
        NewPrivileges->Privileges[0].Luid = LuidPrivilege;
        NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        //
        // Enable the privilege
        //

        b = AdjustTokenPrivileges( Token,
                                   FALSE,
                                   NewPrivileges,
                                   1024,
                                   (PTOKEN_PRIVILEGES)OldPriv,
                                   &cbNeeded );

        if (!b) {
            //
            // If the stack was too small to hold the privileges
            // then allocate off the heap
            //
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                pbOldPriv = (PBYTE)calloc( 1, cbNeeded );
                if (pbOldPriv == NULL) {
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    leave;
                }

                b = AdjustTokenPrivileges( Token,
                                           FALSE,
                                           NewPrivileges,
                                           cbNeeded,
                                           (PTOKEN_PRIVILEGES)pbOldPriv,
                                           &cbNeeded );
            }
        }


    } finally {
        CloseHandle( Token );
        free( NewPrivileges );
        free( pbOldPriv );
    }
    return( b );
}

BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    BOOL b = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup = NULL;

    //
    //  Get SID for Administrators group
    //

    b = AllocateAndInitializeSid(
            &NtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &AdministratorsGroup
            );
    
    //
    //  If we got the sid, check to see if it's enabled in the
    //  current token
    //
    
    if (b) {
        if (!CheckTokenMembership( NULL, AdministratorsGroup, &b )) {
            b = FALSE;
        }
        FreeSid( AdministratorsGroup );
    }

    return(b);
}


BOOL
IsVolumeLocalNTFS(
    WCHAR DriveLetter
    )
{
    BOOL b;
    ULONG i;
    WCHAR DosName[16];
    WCHAR PhysicalName[MAX_PATH];


    DosName[0] = DriveLetter;
    DosName[1] = L':';
    DosName[2] = L'\\';
    DosName[3] = L'\0';

    switch (GetDriveType( DosName )) {
    case DRIVE_UNKNOWN:
    case DRIVE_REMOTE:
        return FALSE;
    }
    
    b = GetVolumeInformation(
        DosName,
        NULL,
        0,
        NULL,
        &i,
        &i,
        PhysicalName,
        sizeof(PhysicalName)/sizeof(WCHAR)
        );
    if (!b ) {
        DisplayError();
        return FALSE;
    }

    if (_wcsicmp( PhysicalName, L"NTFS" ) != 0) {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsVolumeNTFS(
    PWCHAR path
    )
{
    //
    //  Scan backwards through the path looking for \ and trying at each level until we
    //  get to the root. We'll terminate it there and pass it to GetVolumeInformation
    //

    PWCHAR LastBackSlash = path + wcslen( path );
    WCHAR c;
    BOOL b;
    ULONG i;
    WCHAR PhysicalName[MAX_PATH];

    
    while (TRUE) {
        while (TRUE) {
            if (LastBackSlash < path) {
                DisplayError();
                return FALSE;
            }

            if (*LastBackSlash == L'\\') {
                break;
            }

            LastBackSlash--;
        }

        c = LastBackSlash[1];
        LastBackSlash[1] = L'\0';

        b = GetVolumeInformation(
            path,
            NULL,
            0,
            NULL,
            &i,
            &i,
            PhysicalName,
            sizeof(PhysicalName)/sizeof(WCHAR)
            );

        LastBackSlash[1] = c;
        LastBackSlash--;

        if ( b ) {
            return _wcsicmp( PhysicalName, L"NTFS" ) == 0;
        }
    }
}

BOOL
IsVolumeLocal(
    WCHAR DriveLetter
    )
{
    BOOL b;
    ULONG i;
    WCHAR DosName[16];
    WCHAR PhysicalName[MAX_PATH];


    DosName[0] = DriveLetter;
    DosName[1] = L':';
    DosName[2] = L'\\';
    DosName[3] = L'\0';

    switch (GetDriveType( DosName )) {
    case DRIVE_UNKNOWN:
    case DRIVE_REMOTE:
        return FALSE;
    }
    return TRUE;
}

PWSTR
GetFullPath(
    IN PWSTR FilenameIn
    )
{
    WCHAR Filename[MAX_PATH];
    PWSTR FilePart;

    if (!GetFullPathName( FilenameIn, sizeof(Filename)/sizeof(WCHAR), Filename, &FilePart )) {
        return NULL;
    }

    return _wcsdup( Filename );
}

//
//  I64-width number formatting is broken in FormatMessage.  We have to convert the numbers
//  ourselves and then display them as strings.  Rather than declaring buffers on the stack,
//  we will allocate space dynamically, and format the text into that spot.
//
//  While *TECHNICALLY* this is a leak, the utility quickly exits.
//

#define NUMERICBUFFERLENGTH 40

PWSTR
QuadToDecimalText(
    ULONGLONG Value
    )
{
    PWSTR Buffer = malloc( sizeof( WCHAR ) * NUMERICBUFFERLENGTH );
    if (Buffer == NULL) {
        exit( 1);
    }

    swprintf( Buffer, L"%I64u", Value );
    return Buffer;
}

PWSTR
QuadToHexText(
    ULONGLONG Value
    )
{
    PWSTR Buffer = malloc( sizeof( WCHAR ) * NUMERICBUFFERLENGTH );
    if (Buffer == NULL) {
        exit( 1);
    }

    swprintf( Buffer, L"%I64x", Value );
    return Buffer;
}

PWSTR
QuadToPaddedHexText(
    ULONGLONG Value
    )
{
    PWSTR Buffer = malloc( sizeof( WCHAR ) * NUMERICBUFFERLENGTH );
    if (Buffer == NULL) {
        exit( 1);
    }

    swprintf( Buffer, L"%016I64x", Value );
    return Buffer;
}

#if TRUE
/***
*wcstoq, wcstouq(nptr,endptr,ibase) - Convert ascii string to un/signed	__int64.
*
*Purpose:
*	Convert an ascii string to a 64-bit __int64 value.  The base
*	used for the caculations is supplied by the caller.  The base
*	must be in the range 0, 2-36.  If a base of 0 is supplied, the
*	ascii string must be examined to determine the base of the
*	number:
*		(a) First wchar_t = '0', second wchar_t = 'x' or 'X',
*		    use base 16.
*		(b) First wchar_t = '0', use base 8
*		(c) First wchar_t in range '1' - '9', use base 10.
*
*	If the 'endptr' value is non-NULL, then wcstoq/wcstouq places
*	a pointer to the terminating character in this value.
*	See ANSI standard for details
*
*Entry:
*	nptr == NEAR/FAR pointer to the start of string.
*	endptr == NEAR/FAR pointer to the end of the string.
*	ibase == integer base to use for the calculations.
*
*	string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*	Good return:
*		result
*
*	Overflow return:
*		wcstoq -- _I64_MAX or _I64_MIN
*		wcstouq -- _UI64_MAX
*		wcstoq/wcstouq -- errno == ERANGE
*
*	No digits or bad base return:
*		0
*		endptr = nptr*
*
*Exceptions:
*	None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstouq called */
#define FL_NEG	      2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static unsigned __int64 __cdecl wcstoxq (
	const wchar_t *nptr,
	const wchar_t **endptr,
	int ibase,
	int flags
	)
{
	const wchar_t *p;
	wchar_t c;
	unsigned __int64 number;
	unsigned digval;
	unsigned __int64 maxval;

	p = nptr;			/* p is our scanning pointer */
	number = 0;			/* start with zero */

	c = *p++;			/* read wchar_t */
    while ( iswspace(c) )
		c = *p++;		/* skip whitespace */

	if (c == '-') {
		flags |= FL_NEG;	/* remember minus sign */
		c = *p++;
	}
	else if (c == '+')
		c = *p++;		/* skip sign */

	if (ibase < 0 || ibase == 1 || ibase > 36) {
		/* bad base! */
		if (endptr)
			/* store beginning of string in endptr */
			*endptr = nptr;
		return 0L;		/* return 0 */
	}
	else if (ibase == 0) {
		/* determine base free-lance, based on first two chars of
		   string */
		if (c != '0')
			ibase = 10;
		else if (*p == 'x' || *p == 'X')
			ibase = 16;
		else
			ibase = 8;
	}

	if (ibase == 16) {
		/* we might have 0x in front of number; remove if there */
		if (c == '0' && (*p == 'x' || *p == 'X')) {
			++p;
			c = *p++;	/* advance past prefix */
		}
	}

	/* if our number exceeds this, we will overflow on multiply */
	maxval = _UI64_MAX / ibase;


	for (;;) {	/* exit in middle of loop */
		/* convert c to value */
		if ( isdigit((unsigned)c) )
			digval = c - '0';
		else if ( isalpha((unsigned)c) )
			digval = toupper(c) - 'A' + 10;
		else
			break;
		if (digval >= (unsigned)ibase)
			break;		/* exit loop if bad digit found */

		/* record the fact we have read one digit */
		flags |= FL_READDIGIT;

		/* we now need to compute number = number * base + digval,
		   but we need to know if overflow occured.  This requires
		   a tricky pre-check. */

		if (number < maxval || (number == maxval &&
		(unsigned __int64)digval <= _UI64_MAX % ibase)) {
			/* we won't overflow, go ahead and multiply */
			number = number * ibase + digval;
		}
		else {
			/* we would have overflowed -- set the overflow flag */
			flags |= FL_OVERFLOW;
		}

		c = *p++;		/* read next digit */
	}

	--p;				/* point to place that stopped scan */

	if (!(flags & FL_READDIGIT)) {
		/* no number there; return 0 and point to beginning of
		   string */
        /* store beginning of string in endptr later on */
	   	p = nptr;
		number = 0L;		/* return 0 */
	}
	else if ((flags & FL_OVERFLOW) ||
             (!(flags & FL_UNSIGNED) &&
              (number & ((unsigned __int64)_I64_MAX+1)))) {
		/* overflow occurred or signed overflow occurred */
		errno = ERANGE;
		if (flags & FL_UNSIGNED)
			number = _UI64_MAX;
		else
			/* set error code, will be negated if necc. */
			number = _I64_MAX;
        flags &= ~FL_NEG;
    	}
    else if ((flags & FL_UNSIGNED) && (flags & FL_NEG)) {
        //  Disallow a negative sign if we're reading an unsigned
        number = 0L;
        p = nptr;
    }

	if (endptr != NULL)
		/* store pointer to wchar_t that stopped the scan */
		*endptr = p;

	if (flags & FL_NEG)
		/* negate result if there was a neg sign */
		number = (unsigned __int64)(-(__int64)number);

	return number;			/* done. */
}


__int64  __cdecl My_wcstoi64(
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    )
{
    return (__int64) wcstoxq(nptr, endptr, ibase, 0);
}
unsigned __int64  __cdecl My_wcstoui64 (
	const wchar_t *nptr,
	wchar_t **endptr,
	int ibase
	)
{
	return wcstoxq(nptr, endptr, ibase, FL_UNSIGNED);
}

/***
*wcstol, wcstoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*           (a) First char = '0', second char = 'x' or 'X',
*               use base 16.
*           (b) First char = '0', use base 8
*           (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then wcstol/wcstoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*           result
*
*       Overflow return:
*           wcstol -- LONG_MAX or LONG_MIN
*           wcstoul -- ULONG_MAX
*           wcstol/wcstoul -- errno == ERANGE
*
*       No digits or bad base return:
*           0
*           endptr = nptr*
*
*Exceptions:
*       None.
*
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long __cdecl wcstoxl (
        const wchar_t *nptr,
        const wchar_t **endptr,
        int ibase,
        int flags
        )
{
        const wchar_t *p;
        wchar_t c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        p = nptr;           /* p is our scanning pointer */
        number = 0;         /* start with zero */

        c = *p++;           /* read char */

        while ( iswspace(c) )
            c = *p++;       /* skip whitespace */

        if (c == '-') {
            flags |= FL_NEG;    /* remember minus sign */
            c = *p++;
        }
        else if (c == '+')
            c = *p++;       /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
            /* bad base! */
            if (endptr)
                /* store beginning of string in endptr */
                *endptr = nptr;
            return 0L;      /* return 0 */
        }
        else if (ibase == 0) {
            /* determine base free-lance, based on first two chars of
               string */
            if (c != L'0')
                ibase = 10;
            else if (*p == L'x' || *p == L'X')
                ibase = 16;
            else
                ibase = 8;
        }

        if (ibase == 16) {
            /* we might have 0x in front of number; remove if there */
            if (c == L'0' && (*p == L'x' || *p == L'X')) {
                ++p;
                c = *p++;   /* advance past prefix */
            }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {  /* exit in middle of loop */

            /* make sure c is not too big */
            if ( (unsigned)c > UCHAR_MAX )
                break;

            /* convert c to value */
            if ( iswdigit(c) )
                digval = c - L'0';
            else if ( iswalpha(c))
                digval = towupper(c) - L'A' + 10;
            else
                break;

            if (digval >= (unsigned)ibase)
                break;      /* exit loop if bad digit found */

            /* record the fact we have read one digit */
            flags |= FL_READDIGIT;

            /* we now need to compute number = number * base + digval,
               but we need to know if overflow occured.  This requires
               a tricky pre-check. */

            if (number < maxval || (number == maxval &&
            (unsigned long)digval <= ULONG_MAX % ibase)) {
                /* we won't overflow, go ahead and multiply */
                number = number * ibase + digval;
            }
            else {
                /* we would have overflowed -- set the overflow flag */
                flags |= FL_OVERFLOW;
            }

            c = *p++;       /* read next digit */
        }

        --p;                /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
            /* no number there; return 0 and point to beginning of
               string */
            if (endptr)
                /* store beginning of string in endptr later on */
                p = nptr;
            number = 0L;        /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
            /* overflow or signed overflow occurred */
            errno = ERANGE;
            if ( flags & FL_UNSIGNED )
                number = ULONG_MAX;
            else
                number = LONG_MAX;
            flags &= ~FL_NEG;
        }
        else if ((flags & FL_UNSIGNED) && (flags & FL_NEG)) {
            //  Disallow a negative sign if we're reading an unsigned
            number = 0L;
            p = nptr;
        }

        if (endptr != NULL)
            /* store pointer to char that stopped the scan */
            *endptr = p;

        if (flags & FL_NEG)
            /* negate result if there was a neg sign */
            number = (unsigned long)(-(long)number);

        return number;          /* done. */
}

long __cdecl My_wcstol (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return (long) wcstoxl(nptr, endptr, ibase, 0);
}

unsigned long __cdecl My_wcstoul (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return wcstoxl(nptr, endptr, ibase, FL_UNSIGNED);
}

#else
#define My_wcstoui64    _wcstoui64
#define My_wcstoul      _wcstoul
#endif


LPWSTR
FileTime2String(
    IN PLARGE_INTEGER Time,
    IN LPWSTR Buffer,
    IN ULONG BufferSize     //in bytes
    )
/*++

Routine Description:

    This routine will take a file time and convert it into a string in
    the given buffer.

Arguments:


Return Value:

    The passed in string buffer.

--*/
{
    TIME_FIELDS timeFields;
    SYSTEMTIME systemTime;
    WCHAR dateString[32];
    WCHAR timeString[32];

    if (Time->QuadPart == 0) {

        //
        //  If zero, return this string
        //

        (void)StringCbCopy( Buffer, BufferSize, L"<Undefined>" );

    } else {
    
        //
        //  Convert time to desired format
        //

        FileTimeToSystemTime( (PFILETIME) Time, &systemTime );

        //
        //  Get the date
        //

        GetDateFormat( LOCALE_USER_DEFAULT, 
           DATE_SHORTDATE, 
           &systemTime, 
           NULL, 
           dateString, 
           sizeof( dateString ) / sizeof( dateString[0] ));

        //
        //  Get the time
        //

        GetTimeFormat( LOCALE_USER_DEFAULT, 
           TIME_FORCE24HOURFORMAT|TIME_NOTIMEMARKER, 
           &systemTime, 
           NULL, 
           timeString, 
           sizeof( timeString ) / sizeof( timeString[0] ));

        //
        //  Return the generated strings
        //

        (void)StringCbCopy( Buffer, BufferSize, dateString );
        (void)StringCbCat( Buffer, BufferSize, L" " );
        (void)StringCbCat( Buffer, BufferSize, timeString );
    }

    return Buffer;
}



LPWSTR
Guid2Str(
    IN GUID *Guid,
    IN LPWSTR Buffer,
    IN ULONG BufferSize     //in bytes
    )
/*++

Routine Description:

    This routine will convert the given guid into a string and return
    that string in the given buffer.

Arguments:


Return Value:

    The passed in string buffer.

--*/
{
    LPWSTR guidString;

    if (StringFromIID( Guid, &guidString ) != S_OK) {
        
        (void)StringCbCopy( Buffer, BufferSize, L"<Invalid GUID>" );
        
    } else {

        //
        //  I want to exclude the starting and ending brace
        //

        (void)StringCbCopyN( Buffer, BufferSize, guidString+1, (36 * sizeof(WCHAR)) );
        CoTaskMemFree( guidString );
    }

    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfskd\gentable.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GenTable.c

Abstract:

    WinDbg Extension Api for walking RtlGenericTable structures
    Contains no direct ! entry points, but has makes it possible to
    enumerate through generic tables.  The standard Rtl functions
    cannot be used by debugger extensions because they dereference
    pointers to data on the machine being debugged.  The function
    KdEnumerateGenericTableWithoutSplaying implemented in this
    module can be used within kernel debugger extensions.  The
    enumeration function RtlEnumerateGenericTable has no parallel
    in this module, since splaying the tree is an intrusive operation,
    and debuggers should try not to be intrusive.

Author:

    Keith Kaplan [KeithKa]    09-May-96

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
#pragma hdrstop



ULONG64
KdParent (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlParent macro, but works in the kernel debugger.
    The description of RtlParent follows:

    The macro function Parent takes as input a pointer to a splay link in a
    tree and returns a pointer to the splay link of the parent of the input
    node.  If the input node is the root of the tree the return value is
    equal to the input value.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the  parent of the input
                       node.  If the input node is the root of the tree the
                       return value is equal to the input value.

--*/

{
    ULONG64 Parent = 0;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "Parent",
                        Parent) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return Parent;
}



ULONG64
KdLeftChild (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlLeftChild macro, but works in the kernel debugger.
    The description of RtlLeftChild follows:

    The macro function LeftChild takes as input a pointer to a splay link in
    a tree and returns a pointer to the splay link of the left child of the
    input node.  If the left child does not exist, the return value is NULL.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    ULONG64 - Pointer to the splay link of the left child of the input node.
                       If the left child does not exist, the return value is NULL.

--*/

{
    ULONG64 LeftChild = 0;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "LeftChild",
                        LeftChild) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return LeftChild;
}



ULONG64
KdRightChild (
    IN ULONG64 pLinks
    )

/*++

Routine Description:

    Analogous to RtlRightChild macro, but works in the kernel debugger.
    The description of RtlRightChild follows:

    The macro function RightChild takes as input a pointer to a splay link
    in a tree and returns a pointer to the splay link of the right child of
    the input node.  If the right child does not exist, the return value is
    NULL.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the right child of the input node.
                       If the right child does not exist, the return value is NULL.

--*/

{
    ULONG64 RightChild = 0;

    if ( GetFieldValue( pLinks,
                        "RTL_SPLAY_LINKS",
                        "RightChild",
                        RightChild) ) {
        dprintf( "%08p: Unable to read pLinks\n", pLinks );
        return 0;
    }

    return RightChild;
}



BOOLEAN
KdIsLeftChild (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlIsLeftChild macro, but works in the kernel debugger.
    The description of RtlIsLeftChild follows:

    The macro function IsLeftChild takes as input a pointer to a splay link
    in a tree and returns TRUE if the input node is the left child of its
    parent, otherwise it returns FALSE.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    BOOLEAN - TRUE if the input node is the left child of its parent,
              otherwise it returns FALSE.

--*/
{

    return (KdLeftChild(KdParent(Links)) == (Links));

}



BOOLEAN
KdIsRightChild (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlIsRightChild macro, but works in the kernel debugger.
    The description of RtlIsRightChild follows:

    The macro function IsRightChild takes as input a pointer to a splay link
    in a tree and returns TRUE if the input node is the right child of its
    parent, otherwise it returns FALSE.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    BOOLEAN - TRUE if the input node is the right child of its parent,
              otherwise it returns FALSE.

--*/
{

    return (KdRightChild(KdParent(Links)) == (Links));

}



BOOLEAN
KdIsGenericTableEmpty (
    IN ULONG64 Table
    )

/*++

Routine Description:

    Analogous to RtlIsGenericTableEmpty, but works in the kernel debugger.
    The description of RtlIsGenericTableEmpty follows:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{
    ULONG64 TableRoot = 0;

    if (GetFieldValue(Table, "RTL_AVL_TABLE", "TableRoot", TableRoot)) {
        return TRUE;
    }

    //
    // Table is empty if the root pointer is null.
    //

    return ((TableRoot)?(FALSE):(TRUE));

}



ULONG64
KdRealSuccessor (
    IN ULONG64 Links
    )

/*++

Routine Description:

    Analogous to RtlRealSuccessor, but works in the kernel debugger.
    The description of RtlRealSuccessor follows:

    The RealSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    ULONG64 Ptr = 0;

    /*
      first check to see if there is a right subtree to the input link
      if there is then the real successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = KdRightChild(Links)) != 0) {

        while (KdLeftChild(Ptr) != 0) {
            Ptr = KdLeftChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a right child so check to see if have a parent and if
      so find the first ancestor that we are a left decendent of. That
      is find and return P in the following diagram

                       P
                      /
                     .
                      .
                       .
                      Links
    */

    Ptr = Links;
    while (KdIsRightChild(Ptr)) {
        Ptr = KdParent(Ptr);
    }

    if (KdIsLeftChild(Ptr)) {
        return KdParent(Ptr);
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL
    //

    return 0;

}



ULONG64
KdEnumerateGenericTableWithoutSplaying (
    IN ULONG64  pTable,
    IN PULONG64 RestartKey
    )

/*++

Routine Description:

    Analogous to RtlEnumerateGenericTableWithoutSplaying, but works in the
    kernel debugger.  The description of RtlEnumerateGenericTableWithoutSplaying
    follows:

    The function EnumerateGenericTableWithoutSplaying will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        *RestartKey = NULL;

        for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{
    ULONG NumElements;
    ULONG64 TableRoot;


    if ( GetFieldValue(pTable,
                       "RTL_AVL_TABLE",
                       "NumberGenericTableElements",
                       NumElements) ) {
        dprintf( "%s: Unable to read pTable\n", FormatValue(pTable) );
        return 0;
    }

    if ( GetFieldValue(pTable,
                       "RTL_AVL_TABLE",
                       "BalancedRoot.RightChild",
                       TableRoot) ) {
        dprintf( "%s: Unable to read pTable root\n", FormatValue(pTable) );
        return 0;
    }

    if (!NumElements) {

        //
        // Nothing to do if the table is empty.
        //

        return 0;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        ULONG64 NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (*RestartKey == 0) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = TableRoot;
                KdLeftChild(NodeToReturn);
                NodeToReturn = KdLeftChild(NodeToReturn)
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            // The caller has passed in the previous entry found
            // in the table to enable us to continue the search.  We call
            // KdRealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = KdRealSuccessor(*RestartKey);

            if (NodeToReturn) {

                *RestartKey = NodeToReturn;

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   (NodeToReturn+GetTypeSize("RTL_BALANCED_LINKS")/*+GetTypeSize("PVOID")*/)
                  :0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfskd\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 6, 0, EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( dwReserved );

    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfskd\ntfskd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    NtfsKd.c

Abstract:

    KD Extension Api for examining Ntfs specific data structures

Author:

    Keith Kaplan [KeithKa]    24-Apr-1996
    Portions by Jeff Havens
    Ported to IA64 (wesw)     5-Aug-2000

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#undef FlagOn
#undef WordAlign
#undef LongAlign
#undef QuadAlign
#undef DebugPrint
#undef MAXULONGLONG

#define KDEXT
#include "gentable.h"

#undef DebugTrace
#include <cc.h>

#undef UpdateSequenceStructureSize
#undef UpdateSequenceArraySize
#include <lfsdisk.h>
#pragma hdrstop


#define AVERAGE(TOTAL,COUNT) ((COUNT) != 0 ? (TOTAL)/(COUNT) : 0)

const UCHAR FileSignature[4] = {'F', 'I', 'L', 'E'};


VOID
ResetFileSystemStatistics (
    IN ULONG64 VcbAddress,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    );

VOID
DumpFileSystemStatistics (
    IN ULONG64 VcbAddress,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    );


/*
 * Dump structures
 */

typedef struct _STATE {
    ULONG mask;
    ULONG value;
    CHAR *pszname;
} STATE;

STATE CcbState[] = {

    {   CCB_FLAG_IGNORE_CASE,               CCB_FLAG_IGNORE_CASE,               "IgnoreCase"},
    {   CCB_FLAG_OPEN_AS_FILE,              CCB_FLAG_OPEN_AS_FILE,              "OpenAsFile"},
    {   CCB_FLAG_WILDCARD_IN_EXPRESSION,    CCB_FLAG_WILDCARD_IN_EXPRESSION,    "WildcardInExpression"},
    {   CCB_FLAG_OPEN_BY_FILE_ID,           CCB_FLAG_OPEN_BY_FILE_ID,           "OpenByFileId"},
    {   CCB_FLAG_USER_SET_LAST_MOD_TIME,    CCB_FLAG_USER_SET_LAST_MOD_TIME,    "SetLastModTime"},
    {   CCB_FLAG_USER_SET_LAST_CHANGE_TIME, CCB_FLAG_USER_SET_LAST_CHANGE_TIME, "SetLastChangeTime"},
    {   CCB_FLAG_USER_SET_LAST_ACCESS_TIME, CCB_FLAG_USER_SET_LAST_ACCESS_TIME, "SetLastAccessTime"},
    {   CCB_FLAG_TRAVERSE_CHECK,            CCB_FLAG_TRAVERSE_CHECK,            "TraverseCheck"},
    {   CCB_FLAG_RETURN_DOT,                CCB_FLAG_RETURN_DOT,                "ReturnDot"},
    {   CCB_FLAG_RETURN_DOTDOT,             CCB_FLAG_RETURN_DOTDOT,             "ReturnDotDot"},
    {   CCB_FLAG_DOT_RETURNED,              CCB_FLAG_DOT_RETURNED,              "DotReturned"},
    {   CCB_FLAG_DOTDOT_RETURNED,           CCB_FLAG_DOTDOT_RETURNED,           "DotDotReturned"},
    {   CCB_FLAG_DELETE_FILE,               CCB_FLAG_DELETE_FILE,               "DeleteFile"},
    {   CCB_FLAG_DENY_DELETE,               CCB_FLAG_DENY_DELETE,               "DenyDelete"},
    {   CCB_FLAG_ALLOCATED_FILE_NAME,       CCB_FLAG_ALLOCATED_FILE_NAME,       "AllocatedFileName"},
    {   CCB_FLAG_CLEANUP,                   CCB_FLAG_CLEANUP,                   "Cleanup"},
    {   CCB_FLAG_SYSTEM_HIVE,               CCB_FLAG_SYSTEM_HIVE,               "SystemHive"},
    {   CCB_FLAG_PARENT_HAS_DOS_COMPONENT,  CCB_FLAG_PARENT_HAS_DOS_COMPONENT,  "ParentHasDosComponent"},
    {   CCB_FLAG_DELETE_ON_CLOSE,           CCB_FLAG_DELETE_ON_CLOSE,           "DeleteOnClose"},
    {   CCB_FLAG_CLOSE,                     CCB_FLAG_CLOSE,                     "Close"},
    {   CCB_FLAG_UPDATE_LAST_MODIFY,        CCB_FLAG_UPDATE_LAST_MODIFY,        "UpdateLastModify"},
    {   CCB_FLAG_UPDATE_LAST_CHANGE,        CCB_FLAG_UPDATE_LAST_CHANGE,        "UpdateLastChange"},
    {   CCB_FLAG_SET_ARCHIVE,               CCB_FLAG_SET_ARCHIVE,               "SetArchive"},
    {   CCB_FLAG_DIR_NOTIFY,                CCB_FLAG_DIR_NOTIFY,                "DirNotify"},
    {   CCB_FLAG_ALLOW_XTENDED_DASD_IO,     CCB_FLAG_ALLOW_XTENDED_DASD_IO,     "AllowExtendedDasdIo"},
    {   CCB_FLAG_READ_CONTEXT_ALLOCATED,    CCB_FLAG_READ_CONTEXT_ALLOCATED,    "ReadContextAllocated"},
    {   CCB_FLAG_DELETE_ACCESS,             CCB_FLAG_DELETE_ACCESS,             "DeleteAccess"},

    { 0 }
};

STATE FcbState[] = {

    {   FCB_STATE_FILE_DELETED,             FCB_STATE_FILE_DELETED,             "FileDeleted" },
    {   FCB_STATE_NONPAGED,                 FCB_STATE_NONPAGED,                 "Nonpaged" },
    {   FCB_STATE_PAGING_FILE,              FCB_STATE_PAGING_FILE,              "PagingFile" },
    {   FCB_STATE_DUP_INITIALIZED,          FCB_STATE_DUP_INITIALIZED,          "DupInitialized" },
    {   FCB_STATE_UPDATE_STD_INFO,          FCB_STATE_UPDATE_STD_INFO,          "UpdateStdInfo" },
    {   FCB_STATE_PRIMARY_LINK_DELETED,     FCB_STATE_PRIMARY_LINK_DELETED,     "PrimaryLinkDeleted" },
    {   FCB_STATE_IN_FCB_TABLE,             FCB_STATE_IN_FCB_TABLE,             "InFcbTable" },
    {   FCB_STATE_SYSTEM_FILE,              FCB_STATE_SYSTEM_FILE,              "SystemFile" },
    {   FCB_STATE_COMPOUND_DATA,            FCB_STATE_COMPOUND_DATA,            "CompoundData" },
    {   FCB_STATE_COMPOUND_INDEX,           FCB_STATE_COMPOUND_INDEX,           "CompoundIndex" },
    {   FCB_STATE_LARGE_STD_INFO,           FCB_STATE_LARGE_STD_INFO,           "LargeStdInfo" },
    {   FCB_STATE_MODIFIED_SECURITY,        FCB_STATE_MODIFIED_SECURITY,        "ModifiedSecurity" },
    {   FCB_STATE_DIRECTORY_ENCRYPTED,      FCB_STATE_DIRECTORY_ENCRYPTED,      "DirectoryEncrypted" },
    {   FCB_STATE_VALID_USN_NAME,           FCB_STATE_VALID_USN_NAME,           "ValidUsnName" },
    {   FCB_STATE_USN_JOURNAL,              FCB_STATE_USN_JOURNAL,              "UsnJournal" },
    {   FCB_STATE_ENCRYPTION_PENDING,       FCB_STATE_ENCRYPTION_PENDING,       "EncryptionPending" },

    { 0 }
};

STATE NtfsFlags[] = {

    {   NTFS_FLAGS_SMALL_SYSTEM,            NTFS_FLAGS_SMALL_SYSTEM,            "SmallSystem" },
    {   NTFS_FLAGS_MEDIUM_SYSTEM,           NTFS_FLAGS_MEDIUM_SYSTEM,           "MediumSystem" },
    {   NTFS_FLAGS_LARGE_SYSTEM,            NTFS_FLAGS_LARGE_SYSTEM,            "LargeSystem" },
    {   NTFS_FLAGS_CREATE_8DOT3_NAMES,      NTFS_FLAGS_CREATE_8DOT3_NAMES,      "Create8dot3names" },
    {   NTFS_FLAGS_ALLOW_EXTENDED_CHAR,     NTFS_FLAGS_ALLOW_EXTENDED_CHAR,     "AllowExtendedChar" },
    {   NTFS_FLAGS_DISABLE_LAST_ACCESS,     NTFS_FLAGS_DISABLE_LAST_ACCESS,     "DisableLastAccess" },
    {   NTFS_FLAGS_ENCRYPTION_DRIVER,       NTFS_FLAGS_ENCRYPTION_DRIVER,       "EncryptionDriver" },

    { 0 }
};

STATE ScbState[] = {

    {   SCB_STATE_TRUNCATE_ON_CLOSE,        SCB_STATE_TRUNCATE_ON_CLOSE,        "TruncateOnClose" },
    {   SCB_STATE_DELETE_ON_CLOSE,          SCB_STATE_DELETE_ON_CLOSE,          "DeleteOnClose" },
    {   SCB_STATE_CHECK_ATTRIBUTE_SIZE,     SCB_STATE_CHECK_ATTRIBUTE_SIZE,     "CheckAttributeSize" },
    {   SCB_STATE_ATTRIBUTE_RESIDENT,       SCB_STATE_ATTRIBUTE_RESIDENT,       "AttributeResident" },
    {   SCB_STATE_UNNAMED_DATA,             SCB_STATE_UNNAMED_DATA,             "UnnamedData" },
    {   SCB_STATE_HEADER_INITIALIZED,       SCB_STATE_HEADER_INITIALIZED,       "HeaderInitialized" },
    {   SCB_STATE_NONPAGED,                 SCB_STATE_NONPAGED,                 "Nonpaged" },
    {   SCB_STATE_USA_PRESENT,              SCB_STATE_USA_PRESENT,              "UsaPresent" },
    {   SCB_STATE_ATTRIBUTE_DELETED,        SCB_STATE_ATTRIBUTE_DELETED,        "AttributeDeleted" },
    {   SCB_STATE_FILE_SIZE_LOADED,         SCB_STATE_FILE_SIZE_LOADED,         "FileSizeLoaded" },
    {   SCB_STATE_MODIFIED_NO_WRITE,        SCB_STATE_MODIFIED_NO_WRITE,        "ModifiedNoWrite" },
    {   SCB_STATE_SUBJECT_TO_QUOTA,         SCB_STATE_SUBJECT_TO_QUOTA,         "SubjectToQuota" },
    {   SCB_STATE_UNINITIALIZE_ON_RESTORE,  SCB_STATE_UNINITIALIZE_ON_RESTORE,  "UninitializeOnRestore" },
    {   SCB_STATE_RESTORE_UNDERWAY,         SCB_STATE_RESTORE_UNDERWAY,         "RestoreUnderway" },
    {   SCB_STATE_NOTIFY_ADD_STREAM,        SCB_STATE_NOTIFY_ADD_STREAM,        "NotifyAddStream" },
    {   SCB_STATE_NOTIFY_REMOVE_STREAM,     SCB_STATE_NOTIFY_REMOVE_STREAM,     "NotifyRemoveStream" },
    {   SCB_STATE_NOTIFY_RESIZE_STREAM,     SCB_STATE_NOTIFY_RESIZE_STREAM,     "NotifyResizeStream" },
    {   SCB_STATE_NOTIFY_MODIFY_STREAM,     SCB_STATE_NOTIFY_MODIFY_STREAM,     "NotifyModifyStream" },
    {   SCB_STATE_TEMPORARY,                SCB_STATE_TEMPORARY,                "Temporary" },
    {   SCB_STATE_WRITE_COMPRESSED,         SCB_STATE_WRITE_COMPRESSED,         "Compressed" },
    {   SCB_STATE_REALLOCATE_ON_WRITE,      SCB_STATE_REALLOCATE_ON_WRITE,      "DeallocateOnWrite" },
    {   SCB_STATE_DELAY_CLOSE,              SCB_STATE_DELAY_CLOSE,              "DelayClose" },
    {   SCB_STATE_WRITE_ACCESS_SEEN,        SCB_STATE_WRITE_ACCESS_SEEN,        "WriteAccessSeen" },
    {   SCB_STATE_CONVERT_UNDERWAY,         SCB_STATE_CONVERT_UNDERWAY,         "ConvertUnderway" },
    {   SCB_STATE_VIEW_INDEX,               SCB_STATE_VIEW_INDEX,               "ViewIndex" },
    {   SCB_STATE_DELETE_COLLATION_DATA,    SCB_STATE_DELETE_COLLATION_DATA,    "DeleteCollationData" },
    {   SCB_STATE_VOLUME_DISMOUNTED,        SCB_STATE_VOLUME_DISMOUNTED,        "VolumeDismounted" },
    {   SCB_STATE_PROTECT_SPARSE_MCB,       SCB_STATE_PROTECT_SPARSE_MCB,       "ProtectSparseMcb" },
    {   SCB_STATE_MULTIPLE_OPENS,           SCB_STATE_MULTIPLE_OPENS,           "MultipleOpens" },

    { 0 }
};

STATE ScbPersist[] = {

    {   SCB_PERSIST_USN_JOURNAL,            SCB_PERSIST_USN_JOURNAL,            "UsnJournal" },

    { 0 }
};

STATE VcbState[] = {

    {   VCB_STATE_VOLUME_MOUNTED,           VCB_STATE_VOLUME_MOUNTED,           "Mounted" },
    {   VCB_STATE_LOCKED,                   VCB_STATE_LOCKED,                   "Locked" },
    {   VCB_STATE_REMOVABLE_MEDIA,          VCB_STATE_REMOVABLE_MEDIA,          "RemovableMedia" },
    {   VCB_STATE_VOLUME_MOUNTED_DIRTY,     VCB_STATE_VOLUME_MOUNTED_DIRTY,     "MountedDirty" },
    {   VCB_STATE_RESTART_IN_PROGRESS,      VCB_STATE_RESTART_IN_PROGRESS,      "RestartInProgress" },
    {   VCB_STATE_FLAG_SHUTDOWN,            VCB_STATE_FLAG_SHUTDOWN,            "FlagShutdown" },
    {   VCB_STATE_NO_SECONDARY_AVAILABLE,   VCB_STATE_NO_SECONDARY_AVAILABLE,   "NoSecondaryAvailable" },
    {   VCB_STATE_RELOAD_FREE_CLUSTERS,     VCB_STATE_RELOAD_FREE_CLUSTERS,     "ReloadFreeClusters" },
    {   VCB_STATE_PRELOAD_MFT,              VCB_STATE_PRELOAD_MFT,              "PreloadMft" },
    {   VCB_STATE_VOL_PURGE_IN_PROGRESS,    VCB_STATE_VOL_PURGE_IN_PROGRESS,    "VolPurgeInProgress" },
    {   VCB_STATE_TEMP_VPB,                 VCB_STATE_TEMP_VPB,                 "TempVpb" },
    {   VCB_STATE_PERFORMED_DISMOUNT,       VCB_STATE_PERFORMED_DISMOUNT,       "PerformedDismount" },
    {   VCB_STATE_VALID_LOG_HANDLE,         VCB_STATE_VALID_LOG_HANDLE,         "ValidLogHandle" },
    {   VCB_STATE_DELETE_UNDERWAY,          VCB_STATE_DELETE_UNDERWAY,          "DeleteUnderway" },
    {   VCB_STATE_REDUCED_MFT,              VCB_STATE_REDUCED_MFT,              "ReducedMft" },
    {   VCB_STATE_EXPLICIT_LOCK,            VCB_STATE_EXPLICIT_LOCK,            "ExplicitLock" },
    {   VCB_STATE_DISALLOW_DISMOUNT,        VCB_STATE_DISALLOW_DISMOUNT,        "DisallowDismount" },
    {   VCB_STATE_VALID_OBJECT_ID,          VCB_STATE_VALID_OBJECT_ID,          "ValidObjectId" },
    {   VCB_STATE_OBJECT_ID_CLEANUP,        VCB_STATE_OBJECT_ID_CLEANUP,        "ObjectIdCleanup" },
    {   VCB_STATE_USN_DELETE,               VCB_STATE_USN_DELETE,               "UsnDelete" },
    {   VCB_STATE_USN_JOURNAL_PRESENT,      VCB_STATE_USN_JOURNAL_PRESENT,      "UsnJournalPresent" },
    {   VCB_STATE_EXPLICIT_DISMOUNT,        VCB_STATE_EXPLICIT_DISMOUNT,        "ExplicitDismount" },

    { 0 }
};

STATE LcbState[] = {
    {   LCB_STATE_DELETE_ON_CLOSE,          LCB_STATE_DELETE_ON_CLOSE,          "DeleteOnClose" },
    {   LCB_STATE_LINK_IS_GONE,             LCB_STATE_LINK_IS_GONE,             "LinkIsGone" },
    {   LCB_STATE_EXACT_CASE_IN_TREE,       LCB_STATE_EXACT_CASE_IN_TREE,       "ExactCaseInTree" },
    {   LCB_STATE_IGNORE_CASE_IN_TREE,      LCB_STATE_IGNORE_CASE_IN_TREE,      "IgnoreCaseInTree" },
    {   LCB_STATE_DESIGNATED_LINK,          LCB_STATE_DESIGNATED_LINK,          "DesignatedLink" },
    {   LCB_STATE_VALID_HASH_VALUE,         LCB_STATE_VALID_HASH_VALUE,         "ValidHashValue" },

    { 0 }
};

char* LogOperation[] = {

    { "Noop                         " },
    { "CompensationLogRecord        " },
    { "InitializeFileRecordSegment  " },
    { "DeallocateFileRecordSegment  " },
    { "WriteEndOfFileRecordSegment  " },
    { "CreateAttribute              " },
    { "DeleteAttribute              " },
    { "UpdateResidentValue          " },
    { "UpdateNonresidentValue       " },
    { "UpdateMappingPairs           " },
    { "DeleteDirtyClusters          " },
    { "SetNewAttributeSizes         " },
    { "AddIndexEntryRoot            " },
    { "DeleteIndexEntryRoot         " },
    { "AddIndexEntryAllocation      " },
    { "DeleteIndexEntryAllocation   " },
    { "WriteEndOfIndexBuffer        " },
    { "SetIndexEntryVcnRoot         " },
    { "SetIndexEntryVcnAllocation   " },
    { "UpdateFileNameRoot           " },
    { "UpdateFileNameAllocation     " },
    { "SetBitsInNonresidentBitMap   " },
    { "ClearBitsInNonresidentBitMap " },
    { "HotFix                       " },
    { "EndTopLevelAction            " },
    { "PrepareTransaction           " },
    { "CommitTransaction            " },
    { "ForgetTransaction            " },
    { "OpenNonresidentAttribute     " },
    { "OpenAttributeTableDump       " },
    { "AttributeNamesDump           " },
    { "DirtyPageTableDump           " },
    { "TransactionTableDump         " },
    { "UpdateRecordDataRoot         " },
    { "UpdateRecordDataAllocation   " }
};

#define LastLogOperation 0x22

char* AttributeTypeCode[] = {

    { "$UNUSED                " },   //  (0X0)
    { "$STANDARD_INFORMATION  " },   //  (0x10)
    { "$ATTRIBUTE_LIST        " },   //  (0x20)
    { "$FILE_NAME             " },   //  (0x30)
    { "$OBJECT_ID             " },   //  (0x40)
    { "$SECURITY_DESCRIPTOR   " },   //  (0x50)
    { "$VOLUME_NAME           " },   //  (0x60)
    { "$VOLUME_INFORMATION    " },   //  (0x70)
    { "$DATA                  " },   //  (0x80)
    { "$INDEX_ROOT            " },   //  (0x90)
    { "$INDEX_ALLOCATION      " },   //  (0xA0)
    { "$BITMAP                " },   //  (0xB0)
    { "$REPARSE_POINT         " },   //  (0xC0)
    { "$EA_INFORMATION        " },   //  (0xD0)
    { "$EA                    " },   //  (0xE0)
    { "   INVALID TYPE CODE   " },   //  (0xF0)
    { "$LOGGED_UTILITY_STREAM " }    //  (0x100)
};


char * LogEvent[] =
{
    "SCE_VDL_CHANGE",
    "SCE_ZERO_NC",
    "SCE_ZERO_C",
    "SCE_READ",
    "SCE_WRITE",
    "SCE_ZERO_CAV",
    "SCE_ZERO_MF",
    "SCE_ZERO_FST",
    "SCE_CC_FLUSH",
    "SCE_CC_FLUSH_AND_PURGE",
    "SCE_WRITE_FILE_SIZES",
    "SCE_ADD_ALLOCATION",     
    "SCE_ADD_SP_ALLOCATION",
    "SCE_SETCOMP_ADD_ALLOCATION",     
    "SCE_SETSPARSE_ADD_ALLOCATION",   
    "SCE_MOD_ATTR_ADD_ALLOCATION",    
    "SCE_REALLOC1",                   
    "SCE_REALLOC2",                   
    "SCE_REALLOC3",                   
    "SCE_SETCOMPRESS",                
    "SCE_SETSPARSE",                  
    "SCE_ZERO_STREAM",                
    "SCE_VDD_CHANGE",                 
    "SCE_CC_SET_SIZE",
    "SCE_ZERO_C_TAIL_COMPRESSION",
    "SCE_ZERO_C_HEAD_COMPRESSION",
    "SCE_MAX_EVENT"
};


struct {
    NODE_TYPE_CODE TypeCode;
    char *Text;
} NodeTypeCodes[] = {
    {   NTFS_NTC_DATA_HEADER,       "Data Header" },
    {   NTFS_NTC_VCB,               "Vcb" },
    {   NTFS_NTC_FCB,               "Fcb" },
    {   NTFS_NTC_SCB_INDEX,         "ScbIndex" },
    {   NTFS_NTC_SCB_ROOT_INDEX,    "ScbRootIndex" },
    {   NTFS_NTC_SCB_DATA,          "ScbData" },
    {   NTFS_NTC_SCB_MFT,           "ScbMft" },
    {   NTFS_NTC_SCB_NONPAGED,      "ScbNonPaged" },
    {   NTFS_NTC_CCB_INDEX,         "CcbIndex" },
    {   NTFS_NTC_CCB_DATA,          "CcbData" },
    {   NTFS_NTC_IRP_CONTEXT,       "IrpContext" },
    {   NTFS_NTC_LCB,               "Lcb" },
    {   NTFS_NTC_PREFIX_ENTRY,      "PrefixEntry" },
    {   NTFS_NTC_QUOTA_CONTROL,     "QuotaControl" },
    {   NTFS_NTC_USN_RECORD,        "UsnRecord" },
    {   0,                          "Unknown" }
};



ULONG
MyGetFieldData(
    IN  ULONG64 TypeAddress,
    IN  PUCHAR  Type,
    IN  PUCHAR  Field,
    IN  ULONG   OutSize,
    OUT PULONG64 pOutValue,
    OUT PULONG64 pOutAddress
   )

/*++

Routine Description:

    Retrieves the symbol information for a field within a structure.

Arguments:

    TypeAddress - Virtual address of the structure
    Type - Qualified type string
    Field - Field name
    OutSize - Size of the field
    pOutValue - Value of the vield
    pOutAddress - Virtual address of the field

Return Value:

    Zero is success otherwise failure.

--*/

{
    ULONG RetVal = 0;
    FIELD_INFO flds = {
        Field,
        NULL,
        OutSize,
        DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS,
        0,
        pOutValue
    };
    SYM_DUMP_PARAM Sym = {
        sizeof(SYM_DUMP_PARAM),
        Type,
        DBG_DUMP_NO_PRINT,
        TypeAddress,
        NULL,
        NULL,
        NULL,
        1,
        &flds
    };

    ZeroMemory( pOutValue, OutSize );
    RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

    if (OutSize < flds.size) {
        if (OutSize == sizeof(ULONG64)) {
            *pOutValue = Sym.Fields->address;
        } else {
            memset( pOutValue, 0, OutSize );
        }
    }

    if (pOutAddress) {
        if (RetVal == 0) {
            *pOutAddress = Sym.Fields->address;
        } else {
            *pOutAddress = 0;
        }
    }

    return RetVal;
}


VOID
DumpValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Prints the value of a 64/32 bit value based on
    a symbol name and address.

Arguments:

    Address - Virtual address of the value
    Type - Qualified type string
    Field - Field name

Return Value:

    None.

--*/

{
    static ULONG64 ValueBuffer[128];
    ULONG64 Value,OutputAddress;
    if (MyGetFieldData( Address, Type, Field, sizeof(Value), (PVOID)ValueBuffer, &OutputAddress )) {
        Value = 0;
    } else {
        Value = ValueBuffer[0];
    }
    dprintf( "\n(%03x) ", (ULONG)(OutputAddress-Address) );
    dprintf( " %s", FormatValue(Value) );
    dprintf( "  %s ", Field );
}


VOID
DumpPtrValue(
    IN ULONG64 Address,
    IN PCHAR TextStr
    )

/*++

Routine Description:

    Prints the value of a pointer.

Arguments:

    Address - Virtual address of the value
    TextStr - Tag to print with the pointer value

Return Value:

    None.

--*/

{
    ULONG64 PtrValue;
    ULONG BytesRead;
    if (ReadMemory( Address, &PtrValue, sizeof(PtrValue), &BytesRead )) {
        dprintf( "\n       %s  %s", FormatValue(PtrValue), TextStr );
    }
}


ULONG64
ReadValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Reads the value of a 64/32 bit value

Arguments:

    Address - Virtual address of the value
    Type - Qualified type string
    Field - Field name

Return Value:

    The 64/32 bit value or zero.

--*/

{
    static ULONG64 ValueBuffer[128];
    ULONG64 Value,OutputAddress;
    if (MyGetFieldData( Address, Type, Field, sizeof(Value), (PVOID)ValueBuffer, &OutputAddress )) {
        Value = 0;
    } else {
        Value = ValueBuffer[0];
    }
    return Value;
}


ULONG
ReadUlongValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Reads the value of a 32 bit value

Arguments:

    Address - Virtual address of the value
    Type - Qualified type string
    Field - Field name

Return Value:

    The 32 bit value or zero.

--*/

{
    static ULONG ValueBuffer[128];
    ULONG Value;
    ULONG64 OutputAddress;
    if (MyGetFieldData( Address, Type, Field, sizeof(Value), (PVOID)ValueBuffer, &OutputAddress )) {
        Value = 0;
    } else {
        Value = ValueBuffer[0];
    }
    return Value;
}


USHORT
ReadShortValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Reads the value of a 16 bit value

Arguments:

    Address - Virtual address of the value
    Type - Qualified type string
    Field - Field name

Return Value:

    The 16 bit value or zero.

--*/

{
    static USHORT ValueBuffer[128];
    USHORT Value;
    ULONG64 OutputAddress;
    if (MyGetFieldData( Address, Type, Field, sizeof(Value), (PVOID)ValueBuffer, &OutputAddress )) {
        Value = 0;
    } else {
        Value = ValueBuffer[0];
    }
    return Value;
}


VOID
DumpUnicodeString(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field
    )

/*++

Routine Description:

    Prints the value (the actual string) of a string
    contained in a UNICODE_STRING structure

Arguments:

    Address - Virtual address of the structure
    Type - Qualified type string for the structure containing the string
    Field - Field name for the string

Return Value:

    None.

--*/

{
    ULONG64 Value;
    ULONG64 OutputAddress;
    USHORT Length;
    ULONG64 BufferAddr;
    PWSTR Buffer;
    if (MyGetFieldData( Address, Type, Field, 0, (PVOID)&Value, &OutputAddress ) == 0) {
        if (ReadMemory( OutputAddress, &Length, sizeof(Length), (PULONG)&Value )) {
            if (Length) {
                GetFieldOffset( "UNICODE_STRING", "Buffer", (PULONG)&Value );
                OutputAddress += Value;
                if (ReadMemory( OutputAddress, &BufferAddr, GetTypeSize("PWSTR"), (PULONG)&Value )) {
                    if (BufferAddr) {
                        Buffer = (PWSTR) malloc( Length + sizeof(WCHAR) );
                        if (Buffer) {
                            if (ReadMemory( BufferAddr, Buffer, Length, (PULONG)&Value )) {
                                Buffer[Length/sizeof(WCHAR)] = 0;
                                dprintf( "\n(%03x)  %s  %s [%ws]",
                                    (ULONG)(OutputAddress-Address),
                                    FormatValue(BufferAddr),
                                    Field,
                                    Buffer
                                    );
                                free( Buffer );
                                return;
                            }
                            free( Buffer );
                        }
                    }
                }
            }
        }
    }
    dprintf( "\n(%03x)  %16x  %s",
        (ULONG)(OutputAddress-Address),
        0,
        Field
        );
    return;
}


BOOL
DumpString(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   LengthField,
    IN PCHAR   StringField
    )

/*++

Routine Description:

    Prints the value (the actual string) of a string
    contained in a structure with a corresponding
    length field as another field member.

Arguments:

    Address - Virtual address of the structure
    Type - Qualified type string for the structure containing the string
    LengthField - Field name for the length value
    StringField - Field name for the string

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    BOOL Result = FALSE;
    ULONG Length;
    PWSTR String;
    ULONG Offset;

    //
    // read in the length
    //

    if (LengthField == NULL) {
        Length = GetTypeSize(StringField) / sizeof(WCHAR);
    } else {
        Length = (ULONG)ReadValue( Address, Type, LengthField );
    }

    if (Length) {

        Length *= sizeof(WCHAR);

        //
        // allocate some memory to hold the file name
        //

        String = malloc( Length + sizeof(WCHAR) );
        if (String) {

            //
            //  get the field offset of the string
            //

            if (!GetFieldOffset( Type, StringField, &Offset )) {

                //
                //  compute the address of the string
                //

                Address += Offset;

                //
                //  read the unicode characters for the string
                //

                if (ReadMemory( Address, String, Length, &Offset )) {

                    //
                    // zero terminate the string so we can print it out properly
                    //

                    String[Length/sizeof(WCHAR)] = 0;

                    //
                    // finally print the data
                    //

                    dprintf( "%ws", String );

                    Result = TRUE;
                }
            }

            //
            // free the string memory
            //

            free( String );
        }
    }

    return Result;
}


ULONG64
ReadArrayValue(
    IN ULONG64 Address,
    IN PCHAR   Type,
    IN PCHAR   Field,
    IN ULONG   Index
    )

/*++

Routine Description:

    Reads a value/element contained in an array.

Arguments:

    Address - Virtual address of the structure
    Type - Qualified type string for the structure containing the array
    Field - Field name for the array
    Index - The element that is requested

Return Value:

    The element value or zero

--*/

{
    CHAR Buff[64];
    sprintf( Buff, "%s[%d]", Field, Index );
    return ReadValue( Address, Type, Buff );
}


ULONG
GetOffset(
   IN LPSTR Type,
   IN LPSTR Field
   )

/*++

Routine Description:

    Gets the offset for a field within a structure

Arguments:

    Type - Qualified type string for the structure containing the field
    Field - Field name

Return Value:

    The offset value or zero

--*/

{
    FIELD_INFO flds = {
        (PUCHAR)Field,
        (PUCHAR)"",
        0,
        DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
        0,
        NULL};

    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM),
       (PUCHAR)Type,
       DBG_DUMP_NO_PRINT,
       0,
       NULL,
       NULL,
       NULL,
       1,
       &flds
    };

    ULONG Err;

    Sym.nFields = 1;
    Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
    if (Err == 0) {
        return (ULONG) (flds.address - Sym.addr);
    }
    return -1;
}


PSTR
FormatValue(
    ULONG64 addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.  This version does not print
    leading 0's.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same print.

Arguments:

    addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    #define MAX_FORMAT_STRINGS 8
    static CHAR strings[MAX_FORMAT_STRINGS][18];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS) {
        next = 0;
    }
    if ((KdDebuggerData.KernBase >> 32) != 0) {
        //
        // we're on a 64bit machines
        //
        sprintf( string, "%08x`%08x", (ULONG)(addr>>32), (ULONG)addr );
    } else {
        sprintf( string, "%08x", (ULONG)addr );
    }
    return string;
}


VOID
PrintState(
    STATE *ps,
    ULONG state
    )

/*++

Routine Description:

    Prints a state string based on the provided state value

Arguments:

    ps - State string array
    State - State value

Return Value:

    None

--*/

{
    ULONG ul = 0;

    while (ps->mask != 0) {
        ul |= ps->mask;
        if ((state & ps->mask) == ps->value) {
            dprintf(" %s", ps->pszname);
        }
        ps++;
    }
    state &= ~ul;
    if (state != 0) {
        dprintf(" +%lx!!", state);
    }
    dprintf("\n");
}


const char *
TypeCodeGuess (
    IN NODE_TYPE_CODE TypeCode
    )

/*++

Routine Description:

    Guess at a structure's type code

Arguments:

    TypeCode - Type code from the data structure

Return Value:

    None

--*/

{
    int i = 0;

    while (NodeTypeCodes[i].TypeCode != 0 &&
           NodeTypeCodes[i].TypeCode != TypeCode) {

        i++;

    }

    return NodeTypeCodes[i].Text;
}


VOID
FindData(
    IN ULONG64 FileObjectAddress,
    IN ULONG64 Offset,
    IN BOOL Trace,
    OUT PULONG64 DataAddress
    )

/*++

Routine Description:

    Find the cache address for a given file object at the given offset.

Arguments:

    FileObjectAddress - Gives the address of the file object to dump

    Offset - Gives the offset within the file to dump

    DataAddress - Where to store the address of the data.  This will
                  contain 0 if the data at the given offset is not mapped.

Return Value:

    None.

--*/

{
    ULONG64 VacbAddr;          //  the address of the vacb
    ULONG64 VacbAddrAddr;      //  the address of the address of the vacb
    ULONG VacbNumber;
    ULONG OffsetWithinVacb;
    ULONG Level;
    ULONG Shift;
    ULONG OffsetForLevel;
    LONGLONG OriginalOffset = Offset;
    ULONG PtrSize = GetTypeSize("PVOID");
    ULONG Type, InVacbsOffset;
    ULONG64 SectionObjectPointer, SharedCacheMap, Vacbs, SectionSize_Quad;

    *DataAddress = 0;

    if (Trace) {
        dprintf( "\n  FindData for FileObject %08p", FileObjectAddress );
    }
    
    if (GetFieldValue(FileObjectAddress, "FILE_OBJECT", "Type", Type)) {
        dprintf("Unable to read FILE_OBJECT at %p\n", FileObjectAddress);
        return;
    }

    //
    //  Before we get into too much trouble, make sure this looks like a FileObject.
    //

    //
    //  Type of a FileObject must be IO_TYPE_FILE.
    //

    if (Type != IO_TYPE_FILE) {

        dprintf( "\nFILE_OBJECT type signature does not match, type code is %s",
                 TypeCodeGuess((USHORT) Type ));
        return;
    }

    GetFieldValue(FileObjectAddress, "FILE_OBJECT", 
                  "SectionObjectPointer", SectionObjectPointer);

    if (Trace) {
        dprintf( "   Section Object Pointers: %08p", SectionObjectPointer );
    }
    
    if (GetFieldValue(SectionObjectPointer, 
                      "SECTION_OBJECT_POINTERS",
                      "SharedCacheMap",
                      SharedCacheMap)) {
        dprintf("Unable to read SECTION_OBJECT_POINTERS at %p\n", SectionObjectPointer);
        return;
    }

    if (Trace) {
        dprintf( "\n  Shared Cache Map: %08p", SharedCacheMap );
    }
    
    if (GetFieldValue(SharedCacheMap, 
                      "SHARED_CACHE_MAP",
                      "Vacbs",
                      Vacbs)) {
        dprintf("Unable to read SHARED_CACHE_MAP at %p\n", SharedCacheMap);
        return;
    }
    GetFieldValue(SharedCacheMap, "SHARED_CACHE_MAP",
                  "SectionSize.QuadPart", SectionSize_Quad);

    OffsetWithinVacb = (((ULONG) Offset) & (VACB_MAPPING_GRANULARITY - 1));
    GetFieldOffset("SHARED_CACHE_MAP", "InitialVacbs", &InVacbsOffset);

    if (Trace) {
        dprintf( "         File Offset: %I64x ", Offset );
    }
    

    if (Vacbs == (SharedCacheMap + InVacbsOffset)) {
        
        //
        //  Small file case -- we're using one of the Vacbs in the Shared Cache Map's
        //  embedded array.
        //

        CHAR Buff[50];

        VacbNumber = (ULONG) (Offset >> VACB_OFFSET_SHIFT);

        if (VacbNumber >= PREALLOCATED_VACBS) {

            dprintf( "\nInvalid VacbNumber for resident Vacb" );
            return;
        }

        sprintf(Buff, "InitialVacbs[%d]", VacbNumber);
        GetFieldValue(SharedCacheMap, "SHARED_CACHE_MAP",
                      Buff, VacbAddr);

        if (Trace) {
            dprintf( "in VACB number %x", VacbNumber );
        }

    } else if (SectionSize_Quad <= VACB_SIZE_OF_FIRST_LEVEL) {

        //
        //  Medium file case -- we're using a single level (linear) structure to
        //  store the Vacbs.
        //

        VacbNumber = (ULONG) (Offset >> VACB_OFFSET_SHIFT);
        VacbAddrAddr = Vacbs + (VacbNumber * PtrSize);
        if (ReadPtr(VacbAddrAddr, &VacbAddr)) {
            dprintf("Unable to read at %p\n", VacbAddrAddr);
            return;
        }

        if (Trace) {
            dprintf( "in VACB number %x", VacbNumber );
        }

    } else {

        //
        //  Large file case -- multilevel Vacb storage.
        //

        Level = 0;
        Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;
        
        //
        //  Loop to calculate how many levels we have and how much we have to
        //  shift to index into the first level.
        //

        do {

            Level += 1;
            Shift += VACB_LEVEL_SHIFT;

        } while (SectionSize_Quad > ((ULONG64)1 << Shift));
    
        //
        //  Now descend the tree to the bottom level to get the caller's Vacb.
        //



        Shift -= VACB_LEVEL_SHIFT;
//        dprintf( "Shift: 0x%x\n", Shift );

        OffsetForLevel = (ULONG) (Offset >> Shift);
        VacbAddrAddr = Vacbs + (OffsetForLevel * PtrSize);
        if (ReadPtr(VacbAddrAddr, &VacbAddr)) {
            dprintf("Unable to read at %p\n", VacbAddrAddr);
            return;
        } 

        while ((VacbAddr != 0) && (Level != 0)) {

            Level -= 1;

            Offset &= ((LONGLONG)1 << Shift) - 1;

            Shift -= VACB_LEVEL_SHIFT;

//            dprintf( "Shift: 0x%x\n", Shift );

            OffsetForLevel = (ULONG) (Offset >> Shift);
            VacbAddrAddr = VacbAddr + (OffsetForLevel * PtrSize);
            if (ReadPtr(VacbAddrAddr, &VacbAddr)) {
                dprintf("Unable to read at %p\n", VacbAddrAddr);
                return;
            } 
        }
    }

    if (VacbAddr != 0) {
        ULONG64 Base;

        if (Trace) {
            dprintf( "\n  Vacb: %08p", VacbAddr );
        }
        
        if (GetFieldValue(VacbAddr, "_VACB", "BaseAddress", Base)) {
            dprintf("Unable to read VACB base address at %p.", VacbAddr);
            return;
        }

        if (Trace) {
            dprintf( "\n  Your data is at: %08p", (Base + OffsetWithinVacb) );
        }
        *DataAddress = Base + OffsetWithinVacb;

    } else {

        if (Trace) {
            dprintf( "\n  Data at offset %I64x not mapped", OriginalOffset );
        }
    }

    return;
}


DECLARE_DUMP_FUNCTION( DumpCcb )

/*++

Routine Description:

    Dump a specific ccb.

Arguments:

    Address - Gives the address of the fcb to dump

Return Value:

    None

--*/

{
    ULONG64 Value;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(CCB), "NodeTypeCode" );

    //
    //  Before we get into too much trouble, make sure this looks like a ccb.
    //

    //
    //  Type of an fcb record must be NTFS_NTC_CCB_DATA or NTFS_NTC_CCB_INDEX
    //

    if (Value != NTFS_NTC_CCB_DATA && Value != NTFS_NTC_CCB_INDEX) {
        dprintf( "\nCCB signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ));
        return;
    }

    //
    //  Having established that this looks like a ccb, let's dump the
    //  interesting parts.
    //

    dprintf( "\nCcb: %s", FormatValue(Address) );

    Value = ReadValue( Address, SYM(CCB), "Flags" );
    PrintState( CcbState, (ULONG)Value );

    DumpValue( Address, SYM(CCB), "Flags" );

    dprintf( "\n      OpenType: " );

    Value = ReadValue( Address, SYM(CCB), "TypeOfOpen" );

    switch (Value) {
        case UserFileOpen :
           dprintf( "UserFileOpen" );
           break;

        case UserDirectoryOpen :
           dprintf( "UserDirectoryOpen" );
           break;

        case UserVolumeOpen :
           dprintf( "UserVolumeOpen" );
           break;

        case StreamFileOpen :
           dprintf( "StreamFileOpen" );
           break;

        case UserViewIndexOpen :
           dprintf( "UserViewIndexOpen" );
           break;
    }

    DumpUnicodeString( Address, SYM(CCB), "FullFileName" );

    DumpValue( Address, SYM(CCB), "LastFileNameOffset" );
    DumpValue( Address, SYM(CCB), "EaModificationCount" );
    DumpValue( Address, SYM(CCB), "NextEaOffset" );
    DumpValue( Address, SYM(CCB), "Lcb" );
    DumpValue( Address, SYM(CCB), "TypeOfOpen" );
    DumpValue( Address, SYM(CCB), "IndexContext" );
    DumpValue( Address, SYM(CCB), "QueryLength" );
    DumpValue( Address, SYM(CCB), "QueryBuffer" );
    DumpValue( Address, SYM(CCB), "IndexEntryLength" );
    DumpValue( Address, SYM(CCB), "IndexEntry" );
    DumpValue( Address, SYM(CCB), "LcbLinks.Flink" );
    DumpValue( Address, SYM(CCB), "FcbToAcquire" );

    dprintf( "\n" );
}


ULONG
DumpFcbLinks(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for FcbLinks

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 Lcb = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;


    if (CheckControlC()) {
        return TRUE;
    }

    if (dec->Options >= 1) {
        DumpLcb( Lcb, 0, dec->Options-1, dec->Processor, dec->hCurrentThread );
    } else {
        dprintf( "\n    Lcb %s", FormatValue(Lcb) );
    }

    return FALSE;
}


ULONG
DumpScbLinks(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for ScbLinks

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 Scb = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG Offset = 0;


    if (CheckControlC()) {
        return TRUE;
    }

    if (dec->Options >= 1) {
       DumpScb( Scb, 0, dec->Options-1, dec->Processor, dec->hCurrentThread );
    } else {
       dprintf( "\n    Scb %s", FormatValue(Scb) );
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpFcb )

/*++

Routine Description:

    Dump a specific fcb.

Arguments:

    Address - Gives the address of the fcb to dump

Return Value:

    None

--*/

{
    ULONG64 Value;
    DUMP_ENUM_CONTEXT dec;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(FCB), "NodeTypeCode" );

    //
    //  Before we get into too much trouble, make sure this looks like an fcb.
    //

    //
    //  Type of an fcb record must be NTFS_NTC_FCB
    //

    if (Value != NTFS_NTC_FCB) {
        dprintf( "\nFCB signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    dprintf( "\nFcb: %s", FormatValue(Address) );

    //
    //  Having established that this looks like an fcb, let's dump the
    //  interesting parts.
    //

    PrintState( FcbState, (ULONG)ReadValue( Address, SYM(FCB), "FcbState" ) );

    DumpValue( Address, SYM(FCB), "FcbState" );
    DumpValue( Address, SYM(FCB), "FileReference" );
    DumpValue( Address, SYM(FCB), "CleanupCount" );
    DumpValue( Address, SYM(FCB), "CloseCount" );
    DumpValue( Address, SYM(FCB), "ReferenceCount" );
    DumpValue( Address, SYM(FCB), "FcbDenyDelete" );
    DumpValue( Address, SYM(FCB), "FcbDeleteFile" );
    DumpValue( Address, SYM(FCB), "BaseExclusiveCount" );
    DumpValue( Address, SYM(FCB), "EaModificationCount" );
    DumpValue( Address, SYM(FCB), "Vcb" );
    DumpValue( Address, SYM(FCB), "FcbMutex" );
    DumpValue( Address, SYM(FCB), "Resource" );
    DumpValue( Address, SYM(FCB), "PagingIoResource" );
    DumpValue( Address, SYM(FCB), "InfoFlags" );
    DumpValue( Address, SYM(FCB), "LinkCount" );
    DumpValue( Address, SYM(FCB), "TotalLinks" );
    DumpValue( Address, SYM(FCB), "SharedSecurity" );
    DumpValue( Address, SYM(FCB), "QuotaControl" );
    DumpValue( Address, SYM(FCB), "ClassId" );
    DumpValue( Address, SYM(FCB), "OwnerId" );
    DumpValue( Address, SYM(FCB), "DelayedCloseCount" );
    DumpValue( Address, SYM(FCB), "SecurityId" );
    DumpValue( Address, SYM(FCB), "FcbUsnRecord" );

    //
    // walk the queue of links for this file
    //

    dec.hCurrentThread = hCurrentThread;
    dec.Processor = Processor;
    dec.Options = Options;

    dprintf( "\n\nLinks:" );
    Value = ReadValue( Address, SYM(FCB), "LcbQueue.Flink" );
    if (Value) {
        ListType( SYM(LCB), Value, TRUE, "FcbLinks.Flink", (PVOID)&dec, DumpFcbLinks );
    }

    dprintf( "\n\nStreams:" );
    Value = ReadValue( Address, SYM(FCB), "ScbQueue.Flink" );
    if (Value) {
        ListType( SYM(SCB), Value, TRUE, "FcbLinks.Flink", (PVOID)&dec, DumpScbLinks );
    }

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpFcbTable )

/*++

Routine Description:

    Dump the fcb table.

Arguments:

    Address - Gives the address of the fcb table to dump

Return Value:

    None

--*/

{
    ULONG64 Value;
    ULONG64 TableElemAddr;
    ULONG64 RestartKey;
    ULONG64 FcbAddr;
    ULONG Offset1;
    ULONG Offset2;
    PWSTR FileName;
    BOOL GotIt;


    INIT_DUMP();

    //
    //  Dump the FcbTable
    //

    Value = ReadValue( Address, SYM(RTL_AVL_TABLE), "CompareRoutine" );
    if (Value != GetExpression("NTFS!NtfsFcbTableCompare")) {
        dprintf( "\nThe address [%s] does not seem to point to a FCB table", FormatValue(Address) );
        return;
    }

    dprintf( "\n FcbTable %s", FormatValue(Address) );

    dprintf( "\n FcbTable has %x elements", (ULONG)ReadValue( Address, SYM(RTL_AVL_TABLE), "NumberGenericTableElements" ) );

    RestartKey = 0;

    for (TableElemAddr = KdEnumerateGenericTableWithoutSplaying(Address, &RestartKey);
         TableElemAddr != 0;
         TableElemAddr = KdEnumerateGenericTableWithoutSplaying(Address, &RestartKey)) {

        FcbAddr = ReadValue( TableElemAddr, SYM(FCB_TABLE_ELEMENT), "Fcb" );

        if (Options >= 1) {

            DumpFcb( FcbAddr, 0, Options - 2, Processor, hCurrentThread );

        } else {

            GotIt = FALSE;

            //
            //  get the address of the FCB.LcbQueue LIST_ENTRY
            //

            Value = ReadValue( FcbAddr, SYM(FCB), "LcbQueue.Flink" );
            if (Value) {

                //
                //  get the offset of the LCB.FcbLinks LIST_ENTRY
                //

                if (!GetFieldOffset( SYM(LCB), "FcbLinks.Flink", &Offset1 )) {

                    //
                    //  get the field offset of the FCB.LcbQueue LIST_ENTRY
                    //

                    if (!GetFieldOffset( SYM(FCB), "LcbQueue.Flink", &Offset2 )) {

                        //
                        //  check to see if the list is empty
                        //

                        if (Value != FcbAddr+Offset2) {

                            //
                            //  compute the address of the LCB
                            //

                            Value -= Offset1;

                            //
                            //  get the length of the file name
                            //

                            Offset2 = (ULONG)(ReadValue( Value, SYM(LCB), "FileNameLength" ) * GetTypeSize("WCHAR"));

                            if (Offset2) {

                                //
                                // allocate some memory to hold the file name
                                //

                                FileName = malloc( Offset2 + GetTypeSize("WCHAR") );
                                if (FileName) {

                                    //
                                    //  get the field offset of the LCB.FileName
                                    //

                                    if (!GetFieldOffset( SYM(LCB), "FileName", &Offset1 )) {

                                        //
                                        //  compute the address of the file name character array
                                        //

                                        Value += Offset1;

                                        //
                                        //  read the unicode characters for the file name
                                        //

                                        if (ReadMemory( Value, FileName, Offset2, (PULONG)&Offset1 )) {

                                            //
                                            // zero terminate the name so we can print it out properly
                                            //

                                            FileName[Offset2/GetTypeSize("WCHAR")] = 0;

                                            //
                                            // finally print the data
                                            //

                                            GotIt = TRUE;

                                            dprintf( "\n     Fcb %s for FileReference %08lx FcbTableElement %s %ws 0x%x",
                                                     FormatValue(FcbAddr),
                                                     (ULONG)ReadValue( TableElemAddr, SYM(FCB_TABLE_ELEMENT), "FileReference.SegmentNumberLowPart" ),
                                                     FormatValue(TableElemAddr),
                                                     FileName,
                                                     (ULONG)ReadValue( FcbAddr, SYM(FCB), "CleanupCount" )
                                                     );
                                        }
                                    }

                                    //
                                    // free the file name memory
                                    //

                                    free( FileName );
                                }
                            }
                        }
                    }
                }
            }
            if (!GotIt) {
                dprintf( "\n     Fcb %s for FileReference %08lx FcbTableElement %s <filename unavailable> 0x%x",
                         FormatValue(FcbAddr),
                         (ULONG)ReadValue( TableElemAddr, SYM(FCB_TABLE_ELEMENT), "FileReference.SegmentNumberLowPart" ),
                         FormatValue(TableElemAddr),
                         (ULONG)ReadValue( FcbAddr, SYM(FCB), "CleanupCount" )
                         );
            }
        }

        if (CheckControlC( )) {
            break;
        }
    } //  endfor
}


DECLARE_DUMP_FUNCTION( DumpFileObject )

/*++

Routine Description:

    Dump a FileObject.

Arguments:

    Address - Gives the address of the FileObject to dump

Return Value:

    None

--*/

{
    ULONG64 Value;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(FILE_OBJECT), "Type" );
    if (Value != IO_TYPE_FILE) {
        dprintf( "Invalid signature, probably not a file object" );
        return;
    }

    dprintf( "\nFileObject: %p", Address );

    Value = ReadValue( Address, SYM(FILE_OBJECT), "FsContext" );
    if (Value) {
        DumpScb( Value, 0, Options, Processor, hCurrentThread );
        Value = ReadValue( Address, SYM(FILE_OBJECT), "FsContext2" );
        if (Value) {
            DumpCcb( Value, 0, Options, Processor, hCurrentThread );
        }
    }

    DumpValue( Address, SYM(FILE_OBJECT), "DeviceObject" );
    DumpValue( Address, SYM(FILE_OBJECT), "Vpb" );
    DumpValue( Address, SYM(FILE_OBJECT), "FsContext" );
    DumpValue( Address, SYM(FILE_OBJECT), "FsContext2" );
    DumpValue( Address, SYM(FILE_OBJECT), "SectionObjectPointer" );
    DumpValue( Address, SYM(FILE_OBJECT), "PrivateCacheMap" );
    DumpValue( Address, SYM(FILE_OBJECT), "FinalStatus" );
    DumpValue( Address, SYM(FILE_OBJECT), "RelatedFileObject" );
    DumpValue( Address, SYM(FILE_OBJECT), "LockOperation" );
    DumpValue( Address, SYM(FILE_OBJECT), "DeletePending" );
    DumpValue( Address, SYM(FILE_OBJECT), "ReadAccess" );
    DumpValue( Address, SYM(FILE_OBJECT), "WriteAccess" );
    DumpValue( Address, SYM(FILE_OBJECT), "DeleteAccess" );
    DumpValue( Address, SYM(FILE_OBJECT), "SharedRead" );
    DumpValue( Address, SYM(FILE_OBJECT), "SharedWrite" );
    DumpValue( Address, SYM(FILE_OBJECT), "SharedDelete" );
    DumpValue( Address, SYM(FILE_OBJECT), "Flags" );
    DumpUnicodeString( Address, SYM(FILE_OBJECT), "FileName" );
    DumpValue( Address, SYM(FILE_OBJECT), "CurrentByteOffset" );
    DumpValue( Address, SYM(FILE_OBJECT), "Waiters" );
    DumpValue( Address, SYM(FILE_OBJECT), "Busy" );
    DumpValue( Address, SYM(FILE_OBJECT), "LastLock" );
    DumpValue( Address, SYM(FILE_OBJECT), "Lock" );
    DumpValue( Address, SYM(FILE_OBJECT), "Event" );
    DumpValue( Address, SYM(FILE_OBJECT), "CompletionContext" );

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpFileObjectFromIrp )

/*++

Routine Description:

    Dump a FileObject given an Irp.

Arguments:

    Address - Gives the address of the Irp where the FileObject can be found

Return Value:

    None

--*/
{
    ULONG64 Value;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(IRP), "Type" );
    if (Value != IO_TYPE_IRP) {
        dprintf( "IRP signature does not match, probably not an IRP\n" );
        return;
    }

    dprintf( "\nIrp: %s", FormatValue(Address) );

    //
    //  only the current irp stack is worth dumping
    //  the - 1 is there because irp.CurrentLocation is 1 based
    //

    Value = Address + GetTypeSize(NT(IRP)) + (GetTypeSize(NT(IO_STACK_LOCATION)) * (ReadValue( Address, NT(IRP), "CurrentLocation" ) - 1));
    Value = ReadValue( Value, NT(IO_STACK_LOCATION), "FileObject" );
    DumpFileObject( Value, 0, Options, Processor, hCurrentThread );
}


DECLARE_DUMP_FUNCTION( DumpFileRecord )

/*++

Routine Description:

    Dump a FileRecord given a FileObject or Fcb.

Arguments:

    Address - Gives the address of a FileObject or Fcb.

Return Value:

    None

--*/
{
    ULONG64 Value;
    ULONG64 DataAddress;
    ULONG64 ScbAddress;
    ULONG64 FcbAddress;
    ULONG64 VcbAddress;
    ULONG64 FoAddress;


    INIT_DUMP();

    Value = ReadValue( Address, NT(FILE_OBJECT), "Type" );
    switch (Value) {
        case IO_TYPE_FILE:
            dprintf( "\nFileObject: %s", FormatValue(Address) );
            ScbAddress = ReadValue( Address, NT(FILE_OBJECT), "FsContext" );
            if (ScbAddress == 0) {
                dprintf( "No FsContext in the file object" );
                return;
            }
            FcbAddress = ReadValue( ScbAddress, SYM(SCB), "Fcb" );
            break;

        case NTFS_NTC_FCB:
            dprintf( "\nFcb: %s", FormatValue(Address) );
            FcbAddress = Address;
            ScbAddress = 0;
            break;

        case NTFS_NTC_SCB_DATA:
        case NTFS_NTC_SCB_INDEX:
            dprintf( "\nScb: %s", FormatValue(Address) );
            ScbAddress = Address;
            FcbAddress = ReadValue( ScbAddress, SYM(SCB), "Fcb" );
            break;

        default:
            dprintf( "Invalid signature, not a file object or Fcb" );
            return;
    }

    VcbAddress = ReadValue( FcbAddress, SYM(FCB), "Vcb" );
    dprintf( "    Vcb: %s", FormatValue(VcbAddress) );

    dprintf( "    FRS: %08lx,%04lx",
             ReadValue( FcbAddress, SYM(FCB), "FileReference.SegmentNumberLowPart" ),
             ReadValue( FcbAddress, SYM(FCB), "FileReference.SequenceNumber" ));

    ScbAddress = ReadValue( VcbAddress, SYM(VCB), "MftScb" );
    dprintf( "    MftScb: %s", FormatValue(ScbAddress) );

    dprintf( "reading fo in mftscb 0x%x 0x%x\n", GetOffset( SYM(SCB), "Header.FilterContexts" ), GetOffset( SYM(SCB), "Header.PendingEofAdvances" ) );

    FoAddress = ReadValue( ScbAddress, SYM(SCB), "FileObject" );
    dprintf( "finding data in mft fo 0x%s\n", FormatValue(FoAddress) );

    FindData( FoAddress,
              ReadValue( FcbAddress, SYM(FCB), "FileReference.SegmentNumberLowPart" ) * ReadValue( VcbAddress, SYM(VCB), "BytesPerFileRecordSegment" ),
              Options,
              &DataAddress
              );

    if (DataAddress == 0) {

        dprintf( "\nFileRecord is not mapped" );

    } else {

        dprintf( "\nFileRecord at: %s", FormatValue(DataAddress) );
        DumpFileRecordContents( DataAddress, 0, Options, Processor, hCurrentThread );
    }
}


DECLARE_DUMP_FUNCTION( DumpFileRecordContents )

/*++

Routine Description:

    Dump a FileObject's contents given a pointer to where the FR is cached.

Arguments:

    Address - Gives the address where the FR is cached.

Return Value:

    None

--*/
{
    ULONG64 Value;
    ULONG64 AttrAddress;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(FILE_RECORD_SEGMENT_HEADER), "MultiSectorHeader.Signature" );
    if ((ULONG)Value != *(PULONG)FileSignature) {
        dprintf( "Not a file record %x", (ULONG)Value );
        return;
    }

    AttrAddress = Address + ReadValue( Address, SYM(FILE_RECORD_SEGMENT_HEADER), "FirstAttributeOffset" );

    while ((Value = ReadValue( AttrAddress, SYM(ATTRIBUTE_RECORD_HEADER), "TypeCode" )) != 0xffffffff) {
        dprintf( "\nAttribute type %x %s", (ULONG)Value, AttributeTypeCode[Value/0x10] );
        dprintf( " at offset %x", AttrAddress - Address );
        AttrAddress += ReadValue( AttrAddress, SYM(ATTRIBUTE_RECORD_HEADER), "RecordLength" );
        if (CheckControlC()) {
            break;
        }
    }
}


DECLARE_DUMP_FUNCTION( DumpIrpContext )

/*++

Routine Description:

    Dump an IrpContext.

Arguments:

    Address - Gives the address of the IrpContext to dump

Return Value:

    None

--*/

{
    ULONG64 Value;


    INIT_DUMP();

    dprintf( "\nIrpContext: %s", FormatValue(Address) );

    Value = ReadValue( Address, SYM(IRP_CONTEXT), "NodeTypeCode" );
    if (Value != NTFS_NTC_IRP_CONTEXT) {
        dprintf( "\nIRP_CONTEXT signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    Value = ReadValue( Address, SYM(IRP_CONTEXT), "OriginatingIrp" );
    if (Value) {
        DumpFileObjectFromIrp( Value, 0, Options, Processor, hCurrentThread );
    }

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpIrpContextFromThread )

/*++

Routine Description:

    Dump an IrpContext given a Thread.

Arguments:

    Address - Gives the address of the Thread where the IrpContext can be found

Return Value:

    None

--*/
{
    ULONG64 Value;


    INIT_DUMP();

    //
    //  Lookup the current thread if the user didn't specify one.
    //

    if (Address == 0) {
        GetCurrentThreadAddr( Processor, &Address );
    }

    Value = ReadValue( Address, NT(ETHREAD), "TopLevelIrp" );
    if (Value) {
        dprintf( "\nThread %s", FormatValue(Address) );
        Value = ReadValue( Value, SYM(TOP_LEVEL_CONTEXT), "ThreadIrpContext" );
        DumpIrpContext( Value, 0, Options, Processor, hCurrentThread );
    }

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpLcb )

/*++

Routine Description:

    Dump an Lcb.

Arguments:

    Address - Gives the address of the Lcb to dump

Return Value:

    None

--*/

{
    ULONG64 Value;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(LCB), "NodeTypeCode" );
    if (Value != NTFS_NTC_LCB) {
        dprintf( "\nLCB signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    dprintf( "\nLcb: %s", FormatValue(Address) );

    PrintState( LcbState, (ULONG)ReadValue( Address, SYM(LCB), "LcbState" ) );

    DumpUnicodeString( Address, SYM(LCB), "FileName" );
    DumpValue( Address, SYM(LCB), "Scb" );
    DumpValue( Address, SYM(LCB), "Fcb" );
}


DECLARE_DUMP_FUNCTION( DumpLogFile )

/*++

Routine Description:

    Dump a log file.

Arguments:

    Address - Gives the address of the Vcb whose log file should be dumped

Return Value:

    None

--*/

{
    ULONG64 Value;
    ULONG64 VcbAddress;
    ULONG64 LogFileSize;
    ULONG64 LogFileScb;
    ULONG SeqNumberBits;
    ULONG64 LogFileOffset;
    LONG LogFileMask;
    USHORT RedoOperation;
    USHORT UndoOperation;
    ULONG64 LogDataAddress;


    INIT_DUMP();

    LogFileOffset = Options;

    Value = ReadValue( Address, SYM(VCB), "NodeTypeCode" );

    switch (Value) {
        case NTFS_NTC_FCB:
            dprintf( "\nFcb: %s", FormatValue(Address) );
            VcbAddress = ReadValue( Address, SYM(FCB), "Vcb" );
            break;

        case NTFS_NTC_VCB:
            dprintf( "\nVcb: %s", FormatValue(Address) );
            VcbAddress = Address;
            break;

        default:
            dprintf( "\nSignature is not an FCB or VCB, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value) );
            return;
    }

    if (LogFileOffset == 0) {
        LogFileOffset = ReadValue( VcbAddress, SYM(VCB), "LastRestartArea.QuadPart" );
    }

    dprintf( "    Starting at LSN: 0x%016I64x", LogFileOffset );

    LogFileScb = ReadValue( VcbAddress, SYM(VCB), "LogFileScb" );
    LogFileSize = ReadValue( LogFileScb, SYM(SCB), "Header.FileSize.QuadPart" );

    for (SeqNumberBits=0; LogFileSize!=0; SeqNumberBits+=1,LogFileSize=((ULONGLONG)(LogFileSize)) >> 1 ) {
    }

    LogFileMask = (1 << (SeqNumberBits - 3)) - 1;

    while (TRUE) {

        LogFileOffset &= LogFileMask;           // clear some bits
        LogFileOffset = LogFileOffset << 3;     // multiply by 8

        Value = ReadValue( VcbAddress, SYM(VCB), "LogFileObject" );
        FindData( Value, LogFileOffset, FALSE, &LogDataAddress );

        if (LogDataAddress != 0) {

            //
            //  It's mapped.
            //

            RedoOperation = ReadShortValue( LogDataAddress+GetTypeSize(SYM(LFS_RECORD_HEADER)), SYM(NTFS_LOG_RECORD_HEADER), "RedoOperation" );
            UndoOperation = ReadShortValue( LogDataAddress+GetTypeSize(SYM(LFS_RECORD_HEADER)), SYM(NTFS_LOG_RECORD_HEADER), "UndoOperation" );

            if (RedoOperation <= LastLogOperation && UndoOperation <= LastLogOperation) {
                dprintf( "\nRedo: %s", LogOperation[RedoOperation] );
                dprintf( "    Undo: %s", LogOperation[UndoOperation] );
                dprintf( "    Lsn: 0x%08lx", (ULONG)ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ThisLsn.LowPart" ) );
            }

        } else {
            break;
        }

        if (CheckControlC()) {
            break;
        }

        LogFileOffset = (ULONG)ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ClientUndoNextLsn.LowPart" );

        if (LogFileOffset == 0) {
            break;
        }
    }
}


DECLARE_DUMP_FUNCTION( DumpTransaction )

/*++

Routine Description:

    Dump a log file.

Arguments:

    Address - Gives the address of the irpcontext to trace the transaction for

Return Value:

    None

--*/

{   ULONG64 TransactionId;
    ULONG64 VcbAddress;
    ULONG64 TransactionTable;
    LSN FirstLsn;
    LSN CurrentLsn;
    ULONG64 LogFileObject;
    ULONG64 LogFileSize;
    ULONG64 LogFileScb;
    ULONG SeqNumberBits;
    ULONG64 LogFileOffset;
    LONG LogFileMask;
    USHORT RedoOperation;
    USHORT UndoOperation;
    ULONG64 LogDataAddress;
    ULONG64 MftScbAddress;
    ULONG64 MftFileObject;
    ULONG64 DataAddress;
    USHORT Type;
    
    INIT_DUMP();

    //
    //  Determine what type of input it is
    //  

    Type = (USHORT) ReadValue( Address, SYM(IRP_CONTEXT), "NodeTypeCode"  );
    
    if (Type == NTFS_NTC_FCB) {

        //
        //  Its an Fcb so read the filerecord and find the last LSN on disk from it
        //  

        VcbAddress = ReadValue( Address, SYM(FCB), "Vcb" );
        MftScbAddress = ReadValue( VcbAddress, SYM(VCB), "MftScb" );
        MftFileObject = ReadValue( MftScbAddress, SYM(SCB), "FileObject" );
        
        FindData( MftFileObject,
                  ReadValue( Address, SYM(FCB), "FileReference.SegmentNumberLowPart" ) * ReadValue( VcbAddress, SYM(VCB), "BytesPerFileRecordSegment" ),
                  0,
                  &DataAddress
                  );

        CurrentLsn.QuadPart = ReadValue( DataAddress, SYM(FILE_RECORD_SEGMENT_HEADER), "Lsn" ); 

        dprintf( "Searching for last LSN: 0x%I64x on disk for file: 0x%I64x\n\n", CurrentLsn,
                 ReadValue( Address, SYM(FCB), "FileReference.SegmentNumberLowPart" ));

    } else if (Type == NTFS_NTC_VCB ) {

        //
        //  Its a vcb and  filerecord so directly get the last LSN from it
        //  
        
        VcbAddress = Address;
        CurrentLsn.QuadPart = ReadValue( Options, SYM(FILE_RECORD_SEGMENT_HEADER), "Lsn" ); 

        dprintf( "0x%x\n", Options );
        dprintf( "Searching for last LSN: 0x%I64x on disk for file: 0x%I64x\n\n", CurrentLsn,
                 ReadValue( Options, SYM(FILE_RECORD_SEGMENT_HEADER), "SegmentNumberLowPart" ));

    } else if (Type == NTFS_NTC_IRP_CONTEXT) {

        //
        //  Read in the transaction id and then find the transaction entry in the table
        // 

        TransactionId = ReadValue( Address, SYM(IRP_CONTEXT), "TransactionId" );
        VcbAddress = ReadValue( Address, SYM(IRP_CONTEXT), "Vcb" );
        TransactionTable = ReadValue( VcbAddress, SYM(VCB), "TransactionTable.Table" );
        FirstLsn.QuadPart = ReadValue( TransactionTable + TransactionId, SYM( TRANSACTION_ENTRY), "FirstLsn.QuadPart" );
        CurrentLsn.QuadPart = ReadValue( TransactionTable + TransactionId, SYM( TRANSACTION_ENTRY), "PreviousLsn.QuadPart" );

        if (TransactionId == 0) {
            dprintf( "No transaction active for this irpcontext\n" );
            return;
        }
        dprintf( "Transaction: 0x%I64x from Lsn: 0x%I64x to 0x%I64x\n\n", TransactionId, FirstLsn, CurrentLsn );

    } else {
        dprintf( "Unknown type 0x%x for ptr 0x%p\n", Type, Address );
        return;
    }

    LogFileScb = ReadValue( VcbAddress, SYM(VCB), "LogFileScb" );
    LogFileSize = ReadValue( LogFileScb, SYM(SCB), "Header.FileSize.QuadPart" );
    LogFileObject = ReadValue( VcbAddress, SYM(VCB), "LogFileObject" );

    for (SeqNumberBits=0; LogFileSize!=0; SeqNumberBits+=1,LogFileSize=((ULONGLONG)(LogFileSize)) >> 1 ) {
    }

    LogFileMask = (1 << (SeqNumberBits - 3)) - 1;
    LogFileOffset = CurrentLsn.QuadPart;

    while (TRUE) {

        LogFileOffset &= LogFileMask;           // clear some bits
        LogFileOffset = LogFileOffset << 3;     // multiply by 8

        FindData( LogFileObject, LogFileOffset, FALSE, &LogDataAddress );

        if (LogDataAddress != 0) {

            //
            //  It's mapped.
            //

            RedoOperation = ReadShortValue( LogDataAddress+GetTypeSize(SYM(LFS_RECORD_HEADER)), SYM(NTFS_LOG_RECORD_HEADER), "RedoOperation" );
            UndoOperation = ReadShortValue( LogDataAddress+GetTypeSize(SYM(LFS_RECORD_HEADER)), SYM(NTFS_LOG_RECORD_HEADER), "UndoOperation" );

            if (RedoOperation <= LastLogOperation && UndoOperation <= LastLogOperation) {
                dprintf( "Record: %p Lsn: %I64x Prev: %I64x Undo: %I64x\n", 
                         LogDataAddress,
                         ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ThisLsn.QuadPart" ),
                         ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ClientPreviousLsn.QuadPart" ),
                         ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ClientUndoNextLsn.QuadPart" ) );

                dprintf( "Redo: %s Undo: %s\n\n", LogOperation[RedoOperation], LogOperation[UndoOperation] );
            }

        } else {
            dprintf( "Data not mapped in log for offset: 0x%I64x\n", LogFileOffset );
            break;
        }

        if (CheckControlC()) {
            break;
        }

        LogFileOffset = (ULONG)ReadValue( LogDataAddress, SYM(LFS_RECORD_HEADER), "ClientPreviousLsn.QuadPart" );

        if (LogFileOffset == 0) {
            break;
        }
    }
}



DECLARE_DUMP_FUNCTION( DumpMcb )

/*++

Routine Description:

    Dump an Mcb.

Arguments:

    Address - Gives the address of the Mcb to dump

Return Value:

    None

--*/

{
    ULONG64 NtfsMcbArray;
    ULONG64 MappingPairsAddress;
    ULONG RangeIdx;
    ULONG NtfsMcbArraySizeInUse;


    INIT_DUMP();

    dprintf( "\nNtfsMcb: %s", FormatValue(Address) );

    DumpValue( Address, SYM(NTFS_MCB), "FcbHeader" );
    DumpValue( Address, SYM(NTFS_MCB), "PoolType" );
    DumpValue( Address, SYM(NTFS_MCB), "NtfsMcbArraySizeInUse" );
    DumpValue( Address, SYM(NTFS_MCB), "NtfsMcbArraySize" );
    DumpValue( Address, SYM(NTFS_MCB), "NtfsMcbArray" );
    DumpValue( Address, SYM(NTFS_MCB), "FastMutex" );

    NtfsMcbArray = ReadValue( Address, SYM(NTFS_MCB), "NtfsMcbArray" );
    NtfsMcbArraySizeInUse = (ULONG)ReadValue( Address, SYM(NTFS_MCB), "NtfsMcbArraySizeInUse" );

    for (RangeIdx=0; RangeIdx<NtfsMcbArraySizeInUse; RangeIdx++) {

        dprintf( "\n    Range %d", RangeIdx );

        DumpValue( NtfsMcbArray, SYM(NTFS_MCB_ARRAY), "StartingVcn" );
        DumpValue( NtfsMcbArray, SYM(NTFS_MCB_ARRAY), "EndingVcn" );
        DumpValue( NtfsMcbArray, SYM(NTFS_MCB_ARRAY), "NtfsMcbEntry" );

        MappingPairsAddress = ReadValue( NtfsMcbArray, SYM(NTFS_MCB_ARRAY), "NtfsMcbEntry" ) +
                              GetOffset(SYM(NTFS_MCB_ENTRY),"LargeMcb") +
                              GetOffset(SYM(LARGE_MCB),"Mapping");

        DumpPtrValue( MappingPairsAddress, "MappingPairs" );

        //
        //  Go on to the next range.
        //

        NtfsMcbArray += GetTypeSize(SYM(NTFS_MCB_ARRAY));

        if (CheckControlC()) {
            break;
        }
    }

    dprintf( "\n" );
}


ULONG
DumpVcbQueue(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for the Vcb Queue

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 Vcb = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG64 Vpb;


    if (CheckControlC()) {
        return TRUE;
    }

    if (dec->Options >= 1) {
        DumpVcb( Vcb, 0, dec->Options-1, dec->Processor, dec->hCurrentThread );
    } else {
        Vpb = ReadValue( Vcb, SYM(VCB), "Vpb" );
        dprintf( "\n   Vcb %s label: ", FormatValue(Vcb) );
        if (!DumpString( Vpb, NT(VPB), "VolumeLabelLength", "VolumeLabel" )) {
            dprintf( "<label unavailable>" );
        }
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpNtfsData )

/*++

Routine Description:

    Dump the list of Vcbs for the global NtfsData.

Arguments:

    Options - If 1, we recurse into the Vcbs and dump them

Return Value:

    None

--*/

{
    ULONG64 Value;
    DUMP_ENUM_CONTEXT dec;


    INIT_DUMP();

    Address = GetExpression( "Ntfs!NtfsData" );

    dprintf( "\nNtfsData: %s", FormatValue(Address) );

    Value = ReadValue( Address, SYM(NTFS_DATA), "NodeTypeCode" );
    if (Value != NTFS_NTC_DATA_HEADER) {
        dprintf( "\nNtfsData signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    PrintState( NtfsFlags, (ULONG)ReadValue( Address, SYM(NTFS_DATA), "Flags" ) );

    //
    // dump the vcb queue (mounted volumes)
    //

    dec.hCurrentThread = hCurrentThread;
    dec.Processor = Processor;
    dec.Options = Options;

    Value = ReadValue( Address, SYM(NTFS_DATA), "VcbQueue.Flink" );
    if (Value) {
        ListType( SYM(VCB), Value, TRUE, "VcbLinks.Flink", (PVOID)&dec, DumpVcbQueue );
    }

    dprintf( "\n" );

    DumpValue( Address, SYM(NTFS_DATA), "DriverObject" );
    DumpValue( Address, SYM(NTFS_DATA), "Resource" );
    DumpValue( Address, SYM(NTFS_DATA), "AsyncCloseActive" );
    DumpValue( Address, SYM(NTFS_DATA), "ReduceDelayedClose" );
    DumpValue( Address, SYM(NTFS_DATA), "AsyncCloseCount" );
    DumpValue( Address, SYM(NTFS_DATA), "OurProcess" );
    DumpValue( Address, SYM(NTFS_DATA), "DelayedCloseCount" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeFcbTableSize" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeEresourceSize" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeEresourceTotal" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeEresourceMiss" );
    DumpValue( Address, SYM(NTFS_DATA), "FreeEresourceArray" );
    DumpValue( Address, SYM(NTFS_DATA), "Flags" );
}


DECLARE_DUMP_FUNCTION( DumpScb )

/*++

Routine Description:

    Dump an Scb.

Arguments:

    Address - Gives the address of the Scb to dump

    Options - If 1, we dump the Fcb & Vcb for this Scb

Return Value:

    None

--*/

{
    ULONG64 Value = 0;


    INIT_DUMP();

    _try {

        Value = ReadValue( Address, SYM(SCB), "ScbState" );
        if (!Value) {
            _leave;
        }

        dprintf( "\nScb: %s", FormatValue(Address) );

        PrintState( ScbState, (ULONG)Value );

        dprintf( "\nScbPersist:" );
        PrintState( ScbPersist, (ULONG)ReadValue( Address, SYM(SCB), "ScbPersist" ) );

        Value = ReadValue( Address, SYM(FSRTL_COMMON_FCB_HEADER), "NodeTypeCode" );
        if (!Value) {
            _leave;
        }
        dprintf( "\n  ScbType: " );

        switch ( Value ) {

            case NTFS_NTC_SCB_INDEX:

               dprintf( "Index" );
               break;

            case NTFS_NTC_SCB_ROOT_INDEX:

               dprintf( "RootIndex" );
               break;

            case NTFS_NTC_SCB_DATA:

               dprintf( "Data" );
               break;

            case NTFS_NTC_SCB_MFT:

               dprintf( "Mft" );
               break;

            default:

               dprintf( "!!!UNKNOWN SCBTYPE!!!, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
               break;
        }

        if (Options >= 1) {

            Value = ReadValue( Address, SYM(SCB), "Fcb" );
            if (Value) {
                DumpFcb( Value, 0, Options - 1, Processor, hCurrentThread );
            }
            Value = ReadValue( Address, SYM(SCB), "Vcb" );
            if (Value) {
                DumpVcb( Value, 0, Options - 1, Processor, hCurrentThread );
            }

        } else {

            DumpValue( Address, SYM(SCB), "Fcb" );
            DumpValue( Address, SYM(SCB), "Vcb" );
            DumpValue( Address, SYM(SCB), "Mcb" );
            DumpValue( Address, SYM(SCB), "NonCachedCleanupCount" );
            DumpValue( Address, SYM(SCB), "CleanupCount" );
            DumpValue( Address, SYM(SCB), "CloseCount" );
            DumpValue( Address, SYM(SCB), "ShareAccess" );
            DumpValue( Address, SYM(SCB), "AttributeTypeCode" );
            DumpValue( Address, SYM(SCB), "AttributeName.Length" );
            DumpValue( Address, SYM(SCB), "AttributeName.Buffer" );
            DumpValue( Address, SYM(SCB), "AttributeFlags" );
            DumpValue( Address, SYM(SCB), "CompressionUnit" );
            DumpValue( Address, SYM(SCB), "FileObject" );
            DumpValue( Address, SYM(SCB), "NonpagedScb" );
            DumpValue( Address, SYM(SCB), "EncryptionContext" );
        }

    } finally {

    }

    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpVcb )

/*++

Routine Description:

    Dump a Vcb.

Arguments:

    Address - Gives the address of the Vcb to dump

    Options - If 1, we also dump the root Lcb and the Fcb table
              If 2, we dump everything for option 1, and also dump the Fcbs in the Fcb table

Return Value:

    None

--*/

{
    ULONG64 Value = 0;


    INIT_DUMP();

    Value = ReadValue( Address, SYM(VCB), "NodeTypeCode" );

    dprintf( "\n  Vcb: %s", FormatValue(Address) );

    if (Value != NTFS_NTC_VCB) {

        dprintf( "\nVCB signature does not match, type code is %s", TypeCodeGuess( (NODE_TYPE_CODE)Value ) );
        return;
    }

    PrintState( VcbState, (ULONG)ReadValue( Address, SYM(VCB), "VcbState" ) );

    DumpValue( Address, SYM(VCB), "CleanupCount" );
    DumpValue( Address, SYM(VCB), "CloseCount" );
    DumpValue( Address, SYM(VCB), "ReadOnlyCloseCount" );
    DumpValue( Address, SYM(VCB), "SystemFileCloseCount" );
    DumpValue( Address, SYM(VCB), "UsnJournal" );
    DumpValue( Address, SYM(VCB), "MftScb" );
    DumpValue( Address, SYM(VCB), "Mft2Scb" );
    DumpValue( Address, SYM(VCB), "LogFileScb" );
    DumpValue( Address, SYM(VCB), "VolumeDasdScb" );
    DumpValue( Address, SYM(VCB), "RootIndexScb" );
    DumpValue( Address, SYM(VCB), "BitmapScb" );
    DumpValue( Address, SYM(VCB), "AttributeDefTableScb" );
    DumpValue( Address, SYM(VCB), "UpcaseTableScb" );
    DumpValue( Address, SYM(VCB), "BadClusterFileScb" );
    DumpValue( Address, SYM(VCB), "QuotaTableScb" );
    DumpValue( Address, SYM(VCB), "ReparsePointTableScb" );
    DumpValue( Address, SYM(VCB), "OwnerIdTableScb" );
    DumpValue( Address, SYM(VCB), "SecurityDescriptorStream" );
    DumpValue( Address, SYM(VCB), "SecurityIdIndex" );
    DumpValue( Address, SYM(VCB), "SecurityDescriptorHashIndex" );
    DumpValue( Address, SYM(VCB), "ExtendDirectory" );
    DumpValue( Address, SYM(VCB), "ObjectIdTableScb" );
    DumpValue( Address, SYM(VCB), "MftBitmapScb" );
    DumpValue( Address, SYM(VCB), "RootLcb" );
    DumpValue( Address, SYM(VCB), "FcbTable" );
    DumpValue( Address, SYM(VCB), "Statistics" );
    DumpValue( Address, SYM(VCB), "Resource" );

    if (Options < 0) {

        ResetFileSystemStatistics( Address, Processor, hCurrentThread );

    } else if (Options >= 2) {

        DumpFileSystemStatistics( Address, Processor, hCurrentThread );

    } else if (Options >= 1) {

        DumpLcb( ReadValue( Address, SYM(VCB), "RootLcb" ), 0, Options - 1, Processor, hCurrentThread );
        DumpFcbTable( ReadValue( Address, SYM(VCB), "FcbTable" ), 0, Options - 1, Processor, hCurrentThread );
    }

    dprintf( "\n" );
}


VOID
ResetFileSystemStatistics (
    IN ULONG64 VcbAddress,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump the file system statitics of a vcb

Arguments:

    Vcb - Suppplies a pointer to a vcb that the debugger has already loaded.

Return Value:

    None

--*/

{
    ULONG Result;
    PUCHAR Stat;
    ULONG64 StatsAddr;

    dprintf( "\n" );
    dprintf( "\n" );

    //
    //  Write the Statistics structure based on the processor, but
    //  skip over the file system type and version field.
    //

    Result = GetTypeSize(SYM(FILE_SYSTEM_STATISTICS));
    Stat = malloc( Result );
    if (Stat) {
        StatsAddr = ReadValue( VcbAddress, SYM(VCB), "Statistics" );
        if (StatsAddr) {
            if (!WriteMemory( StatsAddr + (Result * Processor) + GetOffset(SYM(FILE_SYSTEM_STATISTICS),"Common.UserFileReads"),
                               &Stat,
                               Result - GetOffset(SYM(FILE_SYSTEM_STATISTICS),"Common.UserFileReads"),
                               &Result) ) {

                dprintf( "%s: Unable to reset Statistics\n", FormatValue(StatsAddr) );
            }
        }
        free( Stat );
        dprintf( "**** %s: Resetting Filesystem Statistics complete ****\n", FormatValue(StatsAddr) );
    }

    DumpFileSystemStatistics( VcbAddress, Processor, hCurrentThread );
}


VOID
DumpFileSystemStatistics (
    IN ULONG64 VcbAddress,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump the file system statitics of a vcb

Arguments:

    Vcb - Suppplies a pointer to a vcb that the debugger has already loaded.

Return Value:

    None

--*/

{
    ULONG Result;
    ULONG64 StatsAddr;
    FILE_SYSTEM_STATISTICS Stat;

    ULONG TotalReads;
    ULONG TotalReadBytes;
    ULONG TotalWrites;
    ULONG TotalWriteBytes;

    ULONG TotalClustersReturned;

    ULONG AverageRequestSize;
    ULONG AverageRunSize;
    ULONG AverageHintSize;
    ULONG AverageCacheSize;
    ULONG AverageCacheMissSize;

    UNREFERENCED_PARAMETER( hCurrentThread );

    //
    //  Read in the Statistics structure based on the processor
    //

    StatsAddr = ReadValue( VcbAddress, SYM(VCB), "Statistics" );

    if ( !ReadMemory( StatsAddr + (GetTypeSize(SYM(FILE_SYSTEM_STATISTICS)) * Processor),
                      &Stat,
                      GetTypeSize(SYM(FILE_SYSTEM_STATISTICS)),
                      &Result) ) {

        dprintf( "%08lx: Unable to read Statistics\n", StatsAddr );
        return;
    }

    //
    //  Sum up all the paging i/o reads and writes
    //

    TotalReads      = Stat.Common.UserFileReads      + Stat.Common.MetaDataReads      + Stat.Ntfs.UserIndexReads      + Stat.Ntfs.LogFileReads;
    TotalReadBytes  = Stat.Common.UserFileReadBytes  + Stat.Common.MetaDataReadBytes  + Stat.Ntfs.UserIndexReadBytes  + Stat.Ntfs.LogFileReadBytes;
    TotalWrites     = Stat.Common.UserFileWrites     + Stat.Common.MetaDataWrites     + Stat.Ntfs.UserIndexWrites     + Stat.Ntfs.LogFileWrites;
    TotalWriteBytes = Stat.Common.UserFileWriteBytes + Stat.Common.MetaDataWriteBytes + Stat.Ntfs.UserIndexWriteBytes + Stat.Ntfs.LogFileWriteBytes;

    //
    //  Sum up the total number of clusters returned
    //

    TotalClustersReturned = Stat.Ntfs.Allocate.HintsClusters + Stat.Ntfs.Allocate.CacheClusters + Stat.Ntfs.Allocate.CacheMissClusters;

    //
    //  Compute the average cluster count requested, returned, from hints, and from the cache, and cache misses.
    //

    AverageRequestSize   = AVERAGE(Stat.Ntfs.Allocate.Clusters, Stat.Ntfs.Allocate.Calls);
    AverageRunSize       = AVERAGE(TotalClustersReturned, Stat.Ntfs.Allocate.RunsReturned);

    AverageHintSize      = AVERAGE(Stat.Ntfs.Allocate.HintsClusters, Stat.Ntfs.Allocate.HintsHonored);
    AverageCacheSize     = AVERAGE(Stat.Ntfs.Allocate.CacheClusters, Stat.Ntfs.Allocate.Cache);
    AverageCacheMissSize = AVERAGE(Stat.Ntfs.Allocate.CacheMissClusters, Stat.Ntfs.Allocate.CacheMiss);

    dprintf( "\n" );
    dprintf( "\n      File System Statistics @ %s for Processor = %d", FormatValue(StatsAddr), Processor );
    dprintf( "\n        FileSystemType / Version = %d / %d", Stat.Common.FileSystemType, Stat.Common.Version );
    dprintf( "\n" );
    dprintf( "\n        Exceptions LogFileFull = %ld Other = %ld", Stat.Ntfs.LogFileFullExceptions, Stat.Ntfs.OtherExceptions );
    dprintf( "\n" );
    dprintf( "\n                       Reads       Bytes     Writes       Bytes" );
    dprintf( "\n                       -----       -----     ------       -----" );
    dprintf( "\n" );
    dprintf( "\n        UserFile  %10ld (%10ld)%10ld (%10ld)",           Stat.Common.UserFileReads,       Stat.Common.UserFileReadBytes,  Stat.Common.UserFileWrites,       Stat.Common.UserFileWriteBytes );
    dprintf( "\n         UserDisk %10ld             %10ld",              Stat.Common.UserDiskReads,       Stat.Common.UserDiskWrites );
    dprintf( "\n" );
    dprintf( "\n        MetaData  %10ld (%10ld)%10ld (%10ld)",           Stat.Common.MetaDataReads,       Stat.Common.MetaDataReadBytes,  Stat.Common.MetaDataWrites,       Stat.Common.MetaDataWriteBytes );
    dprintf( "\n         MetaDisk %10ld             %10ld",              Stat.Common.MetaDataDiskReads,   Stat.Common.MetaDataDiskWrites );
    dprintf( "\n" );
    dprintf( "\n         Mft      %10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.MftReads,       Stat.Ntfs.MftReadBytes,       Stat.Ntfs.MftWrites,       Stat.Ntfs.MftWriteBytes );
    dprintf( "\n         Mft2                            %10ld (%10lx)",                                                         Stat.Ntfs.Mft2Writes,      Stat.Ntfs.Mft2WriteBytes );
    dprintf( "\n         RootIndex%10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.RootIndexReads, Stat.Ntfs.RootIndexReadBytes, Stat.Ntfs.RootIndexWrites, Stat.Ntfs.RootIndexWriteBytes );
    dprintf( "\n         Bitmap   %10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.BitmapReads,    Stat.Ntfs.BitmapReadBytes,    Stat.Ntfs.BitmapWrites,    Stat.Ntfs.BitmapWriteBytes );
    dprintf( "\n         MftBitmap%10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.MftBitmapReads, Stat.Ntfs.MftBitmapReadBytes, Stat.Ntfs.MftBitmapWrites, Stat.Ntfs.MftBitmapWriteBytes );
    dprintf( "\n" );
    dprintf( "\n        UserIndex %10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.UserIndexReads, Stat.Ntfs.UserIndexReadBytes, Stat.Ntfs.UserIndexWrites, Stat.Ntfs.UserIndexWriteBytes );
    dprintf( "\n" );
    dprintf( "\n        LogFile   %10ld (%10ld)%10ld (%10ld)",           Stat.Ntfs.LogFileReads,   Stat.Ntfs.LogFileReadBytes,   Stat.Ntfs.LogFileWrites,   Stat.Ntfs.LogFileWriteBytes );
    dprintf( "\n" );
    dprintf( "\n        TOTAL     %10ld (%10ld)%10ld (%10ld)",           TotalReads, TotalReadBytes, TotalWrites, TotalWriteBytes );
    dprintf( "\n" );
    dprintf( "\n                                 Write   Create  SetInfo    Flush" );
    dprintf( "\n                                 -----   ------  -------    -----" );
    dprintf( "\n        MftWritesUserLevel       %5d    %5d    %5d    %5d", Stat.Ntfs.MftWritesUserLevel.Write,       Stat.Ntfs.MftWritesUserLevel.Create,       Stat.Ntfs.MftWritesUserLevel.SetInfo,       Stat.Ntfs.MftWritesUserLevel.Flush );
    dprintf( "\n        Mft2WritesUserLevel      %5d    %5d    %5d    %5d", Stat.Ntfs.Mft2WritesUserLevel.Write,      Stat.Ntfs.Mft2WritesUserLevel.Create,      Stat.Ntfs.Mft2WritesUserLevel.SetInfo,      Stat.Ntfs.Mft2WritesUserLevel.Flush );
    dprintf( "\n        BitmapWritesUserLevel    %5d    %5d    %5d",        Stat.Ntfs.BitmapWritesUserLevel.Write,    Stat.Ntfs.BitmapWritesUserLevel.Create,    Stat.Ntfs.BitmapWritesUserLevel.SetInfo );
    dprintf( "\n        MftBitmapWritesUserLevel %5d    %5d    %5d    %5d", Stat.Ntfs.MftBitmapWritesUserLevel.Write, Stat.Ntfs.MftBitmapWritesUserLevel.Create, Stat.Ntfs.MftBitmapWritesUserLevel.SetInfo, Stat.Ntfs.MftBitmapWritesUserLevel.Flush );
    dprintf( "\n" );
    dprintf( "\n                   FlushForLogFileFull  LazyWriter  UserRequest" );
    dprintf( "\n                   -------------------  ----------  -----------" );
    dprintf( "\n        MftWrites                %5d       %5d        %5d", Stat.Ntfs.MftWritesFlushForLogFileFull,       Stat.Ntfs.MftWritesLazyWriter,       Stat.Ntfs.MftWritesUserRequest );
    dprintf( "\n        Mft2Writes               %5d       %5d        %5d", Stat.Ntfs.Mft2WritesFlushForLogFileFull,      Stat.Ntfs.Mft2WritesLazyWriter,      Stat.Ntfs.Mft2WritesUserRequest );
    dprintf( "\n        BitmapWrites             %5d       %5d        %5d", Stat.Ntfs.BitmapWritesFlushForLogFileFull,    Stat.Ntfs.BitmapWritesLazyWriter,    Stat.Ntfs.BitmapWritesUserRequest );
    dprintf( "\n        MftBitmapWrites          %5d       %5d        %5d", Stat.Ntfs.MftBitmapWritesFlushForLogFileFull, Stat.Ntfs.MftBitmapWritesLazyWriter, Stat.Ntfs.MftBitmapWritesUserRequest );
    dprintf( "\n" );
    dprintf( "\n        Allocate                              Total     Average" );
    dprintf( "\n        Clusters        Runs       Hints   Clusters     RunSize" );
    dprintf( "\n                        ----       -----   --------     -------" );
    dprintf( "\n        Requested %10ld  %10ld %10ld  %10ld", Stat.Ntfs.Allocate.Calls, Stat.Ntfs.Allocate.Hints, Stat.Ntfs.Allocate.Clusters, AverageRequestSize );
    dprintf( "\n        Returned  %10ld  %10ld %10ld  %10ld", Stat.Ntfs.Allocate.RunsReturned, Stat.Ntfs.Allocate.HintsHonored, TotalClustersReturned, AverageRunSize );
    dprintf( "\n" );
    dprintf( "\n        FromHints %10ld             %10ld  %10ld", Stat.Ntfs.Allocate.HintsHonored, Stat.Ntfs.Allocate.HintsClusters, AverageHintSize );
    dprintf( "\n        CacheHit  %10ld             %10ld  %10ld", Stat.Ntfs.Allocate.Cache, Stat.Ntfs.Allocate.CacheClusters, AverageCacheSize );
    dprintf( "\n        CacheMiss %10ld             %10ld  %10ld", Stat.Ntfs.Allocate.CacheMiss, Stat.Ntfs.Allocate.CacheMissClusters, AverageCacheMissSize );
    dprintf( "\n" );
}


DECLARE_DUMP_FUNCTION( DumpSysCache )

/*++

Routine Description:

    Dump the syscache buffers.  The target system must have been
    built with syscache enabled.

Arguments:

    Address - Gives the address of the Vcb to dump

Return Value:

    None

--*/

{
    ULONG SyscacheLogEntryCount;
    ULONG CurrentSyscacheLogEntry;
    PSYSCACHE_LOG pLog = NULL;
    int iEnd;
    int iStart;
    int iTemp;
    int iIndex;


    INIT_DUMP();

    if (GetOffset( SYM(VCB), "SyscacheScb" ) == -1) {
        //
        // the system was not built with syscache debug
        //
        dprintf( "\nthe target system does not have syscache debug enabled\n" );
        return;
    }

    if (Options != 0) {
        dprintf( "Direct buffer dump\n" );
        dprintf("Num Entries: 0x%x\n", Options );
        dprintf("Current Entry: 0x%x\n", Options );

        CurrentSyscacheLogEntry = Options;
        SyscacheLogEntryCount = Options;

        pLog = (PSYSCACHE_LOG) malloc( GetTypeSize(SYM(SYSCACHE_LOG)) * SyscacheLogEntryCount );
        if (!pLog) {
            return;
        }

        if (!ReadMemory( Address, pLog, GetTypeSize(SYM(SYSCACHE_LOG)) * SyscacheLogEntryCount, &iTemp )) {

            dprintf( "Unable to read SCB.SyscacheLog\n" );
            return;
        }


    } else {
        SyscacheLogEntryCount = ReadUlongValue(Address,SYM(SCB),"SyscacheLogEntryCount");
        CurrentSyscacheLogEntry = ReadUlongValue(Address,SYM(SCB),"CurrentSyscacheLogEntry");
        dprintf("Num Entries: 0x%x\n", SyscacheLogEntryCount );
        dprintf("Current Entry: 0x%x\n", ReadUlongValue(Address,SYM(SCB),"CurrentSyscacheLogEntry") );

        pLog = (PSYSCACHE_LOG) malloc( GetTypeSize(SYM(SYSCACHE_LOG)) * SyscacheLogEntryCount );
        if (!pLog) {
            return;
        }

        if (!ReadMemory( ReadValue(Address,SYM(SCB),"SyscacheLog"), pLog,
                         GetTypeSize(SYM(SYSCACHE_LOG)) * SyscacheLogEntryCount, &iTemp )) {

            dprintf( "Unable to read SCB.SyscacheLog\n" );
            return;
        }
    }

    if (CurrentSyscacheLogEntry > SyscacheLogEntryCount) {
        iStart = CurrentSyscacheLogEntry;
        iEnd = CurrentSyscacheLogEntry + SyscacheLogEntryCount;;
    } else {
        iStart = 0;
        iEnd = CurrentSyscacheLogEntry;
    }

    for (iIndex= iStart; iIndex < iEnd; iIndex++) {

        iTemp = iIndex % SyscacheLogEntryCount;

        if (iStart == 0) {
            dprintf("Entry: 0x%x\n", iIndex);
        } else {
            dprintf("Entry: 0x%x\n", iIndex - SyscacheLogEntryCount);
        }

        dprintf("Event: 0x%x ", pLog[iTemp ].Event);
        if (pLog[iTemp].Event < SCE_MAX_EVENT) {
            dprintf("(%s)\n", LogEvent[pLog[iTemp].Event]);
        } else {
            dprintf("\n");
        }

        dprintf("Flags: 0x%x (", pLog[iTemp].Flags);
        if (pLog[iTemp].Flags & SCE_FLAG_WRITE) {
            dprintf("write ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_READ) {
            dprintf("read ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_PAGING) {
            dprintf("paging io ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_ASYNC) {
            dprintf("asyncfileobj ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SET_ALLOC) {
            dprintf("setalloc ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SET_EOF) {
            dprintf("seteof ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_CANT_WAIT) {
            dprintf("cantwait ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SYNC_PAGING) {
            dprintf("synchpaging ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_LAZY_WRITE) {
            dprintf("lazywrite ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_CACHED) {
             dprintf("cached ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_ON_DISK_READ) {
             dprintf("fromdisk ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_RECURSIVE) {
             dprintf("recursive ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_NON_CACHED) {
             dprintf("noncached ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_UPDATE_FROM_DISK) {
            dprintf("updatefromdisk ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_COMPRESSED) {
            dprintf("compressed ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SET_VDL) {
            dprintf("setvdl ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_FASTIO) {
            dprintf("fastio ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_ZERO) {
            dprintf("zero ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_PREPARE_BUFFERS) {
            dprintf("prepare buffers ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_END_BUFFER) {
            dprintf("end buffers ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_MDL) {
            dprintf("mdl ");
        }
        if (pLog[iTemp].Flags & SCE_FLAG_SUB_WRITE) {
            dprintf("subwrite ");
        }

        dprintf(")\n");
        dprintf("Start: 0x%I64x Range: 0x%I64x Result: 0x%I64x\n",
                pLog[iTemp].Start, pLog[iTemp].Range, pLog[iTemp].Result);

        dprintf("\n");
    }

    if (pLog) {
        free(pLog);
    }
}


DECLARE_DUMP_FUNCTION( DumpExtents )

/*++

Routine Description:

    Dump the extents for a file

Arguments:

    Address - Gives the address of the Vcb to dump

Return Value:

    None

--*/

{
    UCHAR FormCode;
    PVOID Buffer;
    PBYTE TempByte;
    ULONG ChangedLCNBytes;
    ULONG ChangedVCNBytes;
    ULONG Increment;
    ULONG Index;
    ULONG Increment2;
    ULONG LCN = 0;
    ULONG VCN = 0;
    ULONG RecordLength;
    USHORT MappingPairsOffset;


    INIT_DUMP();

    FormCode = (UCHAR)ReadValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "FormCode" );
    if (!(FormCode & NONRESIDENT_FORM)) {
        dprintf( "resident attribute\n" );
        return;
    }

    DumpValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.MappingPairsOffset" );
    DumpValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.LowestVcn" );
    DumpValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.HighestVcn" );
    DumpValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.AllocatedLength" );

    dprintf( "\n" );

    RecordLength = ReadUlongValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "RecordLength" );
    if (!RecordLength) {
        return;
    }

    MappingPairsOffset = ReadShortValue( Address, SYM(ATTRIBUTE_RECORD_HEADER), "Form.Nonresident.MappingPairsOffset" );
    if (!MappingPairsOffset) {
        return;
    }

    RecordLength -= MappingPairsOffset;

    Buffer = malloc( RecordLength );
    if (!ReadMemory( Address+MappingPairsOffset, Buffer, RecordLength, &RecordLength )) {
        dprintf( "Unable to read memory at %s\n", FormatValue(Address+MappingPairsOffset) );
        free( Buffer );
        return;
    }

    TempByte = Buffer;

    //
    // walk byte stream
    //

    while(*TempByte != 0) {
        ChangedLCNBytes = *TempByte >> 4;
        ChangedVCNBytes = *TempByte & (0x0f);

        TempByte++;

        for (Increment=0, Index=0; Index < ChangedVCNBytes; Index++) {
            Increment+= *TempByte++ << (8 * Index);
        }

        for (Increment2 =0, Index=0; Index < ChangedLCNBytes; Index++) {
            Increment2+= *TempByte++ << (8 * Index);
        }

        //
        // if last bit is set (this is a neg) extend with 0xff
        //

        if (0x80 & (*(TempByte-1))) {
            for(; Index < GetTypeSize("ULONG"); Index++) {
                Increment2 += 0xff << (8 * Index);
            }
        }

        LCN += Increment2;
        dprintf( "LCN: 0x%x  VCN: 0x%x Clusters: 0x%x ", LCN, VCN, Increment );

        for (Index = ChangedLCNBytes + ChangedVCNBytes + 1; Index > 0; Index--) {
            dprintf( "%02x", *(TempByte - Index));
        }
        dprintf( "\n" );

        VCN += Increment;
    }

    free( Buffer );
}


ULONG
ThreadListCallback(
    IN PFIELD_INFO listElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for cachedrecords to check for cached file records

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG64 ThreadAddress=listElement->address;
    ULONG64 TopLevelIrp;
    ULONG NtfsSig;
    ULONG64 ThreadIrpContext;
    int Index;
    ULONG RecordSize;
    ULONG64 RecordAddress;
    ULONG64 FileRecordBcb;
    ULONG64 FileRecord;
    ULONG UnsafeSegmentNumber;

    TopLevelIrp = ReadValue( ThreadAddress, NT(ETHREAD), "TopLevelIrp" );

    if (TopLevelIrp) {
        NtfsSig = ReadUlongValue( TopLevelIrp, SYM(TOP_LEVEL_CONTEXT), "Ntfs" );

        if (NtfsSig == 0x5346544e) {
            ThreadIrpContext = ReadValue( TopLevelIrp, SYM(TOP_LEVEL_CONTEXT), "ThreadIrpContext" );
            if (ThreadIrpContext) {
                RecordSize = GetTypeSize(SYM(IRP_FILE_RECORD_CACHE_ENTRY));
                RecordAddress = ThreadIrpContext + GetOffset(SYM(IRP_CONTEXT),"FileRecordCache");

                dprintf ("record: 0x%x\n", RecordAddress );

                for (Index=0; Index<IRP_FILE_RECORD_MAP_CACHE_SIZE; Index++) {

                    FileRecord = ReadValue( RecordAddress, SYM(IRP_FILE_RECORD_CACHE_ENTRY), "FileRecord" );
                    FileRecordBcb = ReadValue( RecordAddress, SYM(IRP_FILE_RECORD_CACHE_ENTRY), "FileRecordBcb" );

                    if (FileRecord) {
                        UnsafeSegmentNumber = ReadUlongValue( RecordAddress, SYM(IRP_FILE_RECORD_CACHE_ENTRY), "UnsafeSegmentNumber" );
                        dprintf( "Thread: 0x%s FileRecord: 0x%s Bcb: 0x%s SegmentNum: 0x%x\n",
                                 FormatValue(ThreadAddress),
                                 FormatValue(FileRecord),
                                 FormatValue(FileRecordBcb),
                                 UnsafeSegmentNumber
                                 );
                    }
                    RecordAddress += RecordSize;
                }
            }
        }
    }

    return FALSE;
}


ULONG
ProcessListCallback(
    IN PFIELD_INFO listElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function for cachedrecords to check for cached file records

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG64 ProcAddress=listElement->address;
    ULONG64 FirstThread;


    FirstThread = ReadValue( ProcAddress, NT(EPROCESS), "Pcb.ThreadListHead.Flink" );
    if (FirstThread) {
        ListType( NT(ETHREAD), FirstThread, 1, "Tcb.ThreadListEntry.Flink", (PVOID)dec, &ThreadListCallback );
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpCachedRecords )

/*++

Routine Description:

    Walk all processes and dump any which are holding filerecords cached in
    irpcontexts

Arguments:

    arg - none

Return Value:

    None

--*/

{
    ULONG64 FirstProcess;
    DUMP_ENUM_CONTEXT dec;

    INIT_DUMP();


    FirstProcess = ReadValue( KdDebuggerData.PsActiveProcessHead, NT(LIST_ENTRY), "Flink" );
    if (FirstProcess == 0) {
        dprintf( "Unable to read _LIST_ENTRY @ %s \n", FormatValue(KdDebuggerData.PsActiveProcessHead) );
        return;
    }

    dec.hCurrentThread = hCurrentThread;
    dec.Processor = Processor;
    dec.Options = Options;

    ListType( NT(EPROCESS), FirstProcess, 1, "ActiveProcessLinks.Flink", (PVOID)&dec, &ProcessListCallback );
}


DECLARE_DUMP_FUNCTION( DumpHashTable )

/*++

Routine Description:

    Dump a prefix hash table

Arguments:

    arg - none

Return Value:

    None

--*/

{
    ULONG64 HashSegmentsOffset;
    ULONG64 HashSegmentAddress;
    ULONG64 HashSegmentPtr;
    ULONG HashEntrySize;
    DWORD Index;
    DWORD Index2;
    ULONG BytesRead;
    ULONG64 NextAddr;
    ULONG PtrSize;


    INIT_DUMP();

    dprintf( "Hash Table: 0x%s\n", FormatValue(Address) );
    dprintf( "Max Buckets: 0x%x  Splitpoint: 0x%x\n",
        ReadUlongValue( Address, SYM(NTFS_HASH_TABLE), "MaxBucket" ),
        ReadUlongValue( Address, SYM(NTFS_HASH_TABLE), "SplitPoint" ) );

    HashSegmentsOffset = GetOffset(SYM(NTFS_HASH_TABLE),"HashSegments");
    HashEntrySize = GetTypeSize(SYM(NTFS_HASH_ENTRY));
    PtrSize = GetTypeSize(SYM(PVOID));
    HashSegmentAddress = Address + HashSegmentsOffset;

    for (Index=0; Index<HASH_MAX_SEGMENT_COUNT; Index++) {
        HashSegmentAddress += (Index * PtrSize);
        if (ReadMemory( HashSegmentAddress, &HashSegmentPtr, PtrSize, &BytesRead ) && HashSegmentPtr) {
            for (Index2=0; Index2<HASH_MAX_INDEX_COUNT; Index2++) {
                NextAddr = HashSegmentPtr + (Index2 * PtrSize);
                while (NextAddr) {
                    if (Address2 == 0 || ReadValue( NextAddr, SYM(NTFS_HASH_ENTRY), "HashLcb" ) == Address2) {
                        dprintf( "Lcb: 0x%s Hash: 0x%x\n",
                            FormatValue(ReadValue( NextAddr, SYM(NTFS_HASH_ENTRY), "HashLcb" )),
                            ReadUlongValue( NextAddr, SYM(NTFS_HASH_ENTRY), "HashValue" ) );
                    }
                    NextAddr = ReadValue( NextAddr, SYM(NTFS_HASH_ENTRY), "NextEntry" );
                    if (CheckControlC()) {
                        return;
                    }
                }
                if (CheckControlC()) {
                    return;
                }
            }
        }
        if (CheckControlC()) {
            return;
        }
    }
}


ULONG
FindIndexScb(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function to locate the index scb

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 Scb = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;


    if (CheckControlC()) {
        return TRUE;
    }

    if (ReadValue( Scb, SYM(SCB), "AttributeTypeCode" ) == $INDEX_ALLOCATION) {
        dec->ReturnValue = Scb;
        return TRUE;
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpFcbLcbChain )

/*++

Routine Description:

    Dump a fcb - lcb - chain to find the bottom

Arguments:

    arg - the initial fcb

Return Value:

    None

--*/

{
    ULONG64 FcbAddress = Address;
    ULONG64 ScbAddress = 0;
    ULONG64 LcbAddress = 0;
    ULONG64 Link = 0;
    DUMP_ENUM_CONTEXT dec;
    ULONG64 Value;

    INIT_DUMP();


    do {

        if (ReadValue( FcbAddress, SYM(FCB), "NodeTypeCode" ) != NTFS_NTC_FCB) {
            dprintf( "Not an FCB at 0x%s\n", FormatValue(FcbAddress) );
            return;
        }

        //
        // initialize the enum context for all out enumerations
        //

        dec.hCurrentThread = hCurrentThread;
        dec.Processor = Processor;
        dec.Options = Options;
        dec.ReturnValue = 0;

        //
        //   Find the index SCB
        //

        Value = ReadValue( FcbAddress, SYM(FCB), "ScbQueue.Flink" );
        if (Value) {
            ListType( SYM(SCB), Value, TRUE, "FcbLinks.Flink", (PVOID)&dec, FindIndexScb );
            if (dec.ReturnValue) {
                ScbAddress = dec.ReturnValue;
            }
        }

        if (ScbAddress == 0) {
            dprintf( "unable to find index scb in fcb: 0x%s\n", FormatValue(FcbAddress) );
            return;
        }

        dprintf( "Scb: 0x%s, NameLen: 0x%x Counts: 0x%x 0x%x\n",
            FormatValue(ScbAddress),
            ReadShortValue( ScbAddress, SYM(SCB), "ScbType.Index.NormalizedName.MaximumLength" ),
            ReadUlongValue( ScbAddress, SYM(SCB), "CleanupCount" ),
            ReadUlongValue( ScbAddress, SYM(SCB), "CloseCount" )
            );

        Value = ReadValue( ScbAddress, SYM(SCB), "ScbType.Index.LcbQueue.Flink" );

        if (Value != (ScbAddress + GetOffset(SYM(SCB),"Index.LcbQueue.Flink"))) {

            //
            //  Read the 1st lcb
            //

            LcbAddress = Value - GetOffset(SYM(LCB),"ScbLinks");

            dprintf( "lcb: 0x%s Cleanup: 0x%x fcb: 0x%s\n",
                FormatValue(LcbAddress),
                ReadUlongValue( LcbAddress, SYM(LCB), "CleanupCount" ),
                FormatValue(ReadValue( LcbAddress, SYM(LCB), "Fcb" ))
                );

            FcbAddress = ReadValue( LcbAddress, SYM(LCB), "Fcb" );

        } else {

            dprintf( "lcbqueue empty: 0x%s\n", FormatValue(ScbAddress) );
            return;
        }

        if (CheckControlC()) {
            return;
        }

    } while ( TRUE );
}


ULONG
EnumOverflow(
    IN PFIELD_INFO ListElement,
    IN PVOID Context
    )

/*++

Routine Description:

    Enumeration callback function to dump the overflow queue

Arguments:

    ListElement - Pointer to the containing record
    Context - Opaque context passed from the origination function

Return Value:

    TRUE to discontinue the enumeration
    FALSE to continue the enumeration

--*/

{
    ULONG64 IrpContext = ListElement->address;
    PDUMP_ENUM_CONTEXT dec = (PDUMP_ENUM_CONTEXT)Context;
    ULONG64 OriginatingIrp;
    ULONG64 MdlAddress;


    if (CheckControlC()) {
        return TRUE;
    }

    OriginatingIrp = ReadValue( IrpContext, SYM(IRP_CONTEXT), "OriginatingIrp" );
    if (OriginatingIrp) {
        dprintf( "0x%s 0x%x ", FormatValue(OriginatingIrp), ReadValue( OriginatingIrp, SYM(IRP), "Cancel" ) );
        MdlAddress = ReadValue( OriginatingIrp, SYM(IRP), "MdlAddress" );
        if (MdlAddress) {
            dprintf( "0x%s", FormatValue(ReadValue( MdlAddress, NT(MDL), "Process" )) );
        }
    }

    return FALSE;
}


DECLARE_DUMP_FUNCTION( DumpOverflow )

/*++

Routine Description:

    Dump the overflow queue

Arguments:

    arg - Vcb

Return Value:

    None

--*/

{
    ULONG64 VcbAddress;
    ULONG64 VdoAddress;
    ULONG64 Value;
    DUMP_ENUM_CONTEXT dec;

    INIT_DUMP();


    VcbAddress = Address;
    VdoAddress = VcbAddress - GetOffset(SYM(VOLUME_DEVICE_OBJECT),"Vcb");

    dprintf( "Volume Device: 0x%s Vcb: 0x%s  OverflowCount: 0x%x\n",
        FormatValue(VdoAddress), FormatValue(VcbAddress),
        ReadUlongValue( VdoAddress, SYM(VOLUME_DEVICE_OBJECT), "OverflowQueueCount" ) );

    dprintf("\nIrpContext Irp Cancelled Process\n");

    Value = ReadValue( VdoAddress, SYM(VOLUME_DEVICE_OBJECT), "OverflowQueue.Flink" );

    if (Value && Value != VdoAddress + GetOffset(SYM(VOLUME_DEVICE_OBJECT),"OverflowQueue.Flink")) {

        dec.hCurrentThread = hCurrentThread;
        dec.Processor = Processor;
        dec.Options = Options;
        dec.ReturnValue = 0;

        ListType( SYM(IRP_CONTEXT), Value, TRUE, "ListEntry.Flink", (PVOID)&dec, EnumOverflow );
    }
}


DECLARE_DUMP_FUNCTION( DumpCachedRuns )

/*++

Routine Description:

    Dumps the cached runs array
    
Arguments:

    Address - Gives the address of the cached runs array to be dumped

Return Value:

    None

--*/

{
    ULONG64 AvailRuns;
    ULONG64 MaxUsed;
    ULONG64 ClusterRunSize;
    int Index;
    LCN Lcn;
    LONGLONG Length;
    ULONG64 LcnArray;
    USHORT LenIndex;
    ULONG64 LengthArray;
    ULONG BytesRead;
    USHORT WindowStart;
    USHORT WindowEnd;
    ULONG DelWindowIndex = 0;
    ULONG64 DelArray;
    ULONG64 DelWindowSize;
    ULONG64 DelLengthCount;
    LONGLONG PrevLength = -1;

    INIT_DUMP();

    dprintf( "CachedRun: %p ", Address );

    AvailRuns = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "Avail" );
    MaxUsed = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "Used" );
    ClusterRunSize = GetTypeSize( SYM(NTFS_LCN_CLUSTER_RUN) );
    LcnArray = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "LcnArray" );
    LengthArray = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "LengthArray" );
    DelLengthCount = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "DelLengthCount" );
    DelArray = ReadValue( Address, SYM(NTFS_CACHED_RUNS), "DeletedLengthWindows" );
    DelWindowSize = GetTypeSize( SYM(NTFS_DELETED_RUNS) );

    if (DelWindowIndex < DelLengthCount) {

        WindowStart = (USHORT)ReadValue( DelArray + DelWindowSize * DelWindowIndex, SYM(NTFS_DELETED_RUNS), "StartIndex" );
        WindowEnd = (USHORT)ReadValue( DelArray + DelWindowSize * DelWindowIndex, SYM(NTFS_DELETED_RUNS), "EndIndex" );
        DelWindowIndex++;
    }

    dprintf( "Avail: 0x%I64x Used: 0x%I64x\n", AvailRuns, MaxUsed );
                          
    dprintf( "Lcns ranges sorted by length\n\n" );

    for (Index=0; Index < MaxUsed; Index++) {

        if (Index == WindowStart) {

            dprintf( "DeleteWindow: 0x%x to 0x%x\n", WindowStart, WindowEnd );

            Index = WindowEnd;

            if (DelWindowIndex < DelLengthCount) {

                WindowStart = (USHORT)ReadValue( DelArray + DelWindowSize * DelWindowIndex, SYM(NTFS_DELETED_RUNS), "StartIndex" );
                WindowEnd = (USHORT)ReadValue( DelArray + DelWindowSize * DelWindowIndex, SYM(NTFS_DELETED_RUNS), "EndIndex" );
                DelWindowIndex++;
            }
            continue;
        }

        ReadMemory( LengthArray + Index * sizeof( USHORT ), &LenIndex, sizeof( USHORT ), &BytesRead );

        if (NTFS_CACHED_RUNS_DEL_INDEX != LenIndex) {
            
            Lcn = ReadValue( LcnArray + LenIndex * (ClusterRunSize), SYM(NTFS_LCN_CLUSTER_RUN), "Lcn" );
            Length = ReadValue( LcnArray + LenIndex * (ClusterRunSize), SYM(NTFS_LCN_CLUSTER_RUN), "RunLength" );

            if (Length < PrevLength) {
                dprintf( "WARNING: OUT OF ORDER ENTRY\n" );
            }
            PrevLength = Length;

            dprintf( "0x%x: LcnIndex: 0x%x Lcn: 0x%I64x Length: 0x%I64x\n", Index, LenIndex, Lcn, Length );

        }

        if (CheckControlC()) {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfskd\gentable.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GenTable.c

Abstract:

    WinDbg Extension Api for walking RtlGenericTable structures
    Contains no direct ! entry points, but has makes it possible to
    enumerate through generic tables.  The standard Rtl functions
    cannot be used by debugger extensions because they dereference
    pointers to data on the machine being debugged.  The function
    KdEnumerateGenericTableWithoutSplaying implemented in this
    module can be used within kernel debugger extensions.  The
    enumeration function RtlEnumerateGenericTable has no parallel
    in this module, since splaying the tree is an intrusive operation,
    and debuggers should try not to be intrusive.

Author:

    Keith Kaplan [KeithKa]    09-May-96

Environment:

    User Mode.

Revision History:

--*/


PRTL_SPLAY_LINKS
KdParent (
    IN PRTL_SPLAY_LINKS pLinks
    );

PRTL_SPLAY_LINKS
KdLeftChild (
    IN PRTL_SPLAY_LINKS pLinks
    );

PRTL_SPLAY_LINKS
KdRightChild (
    IN PRTL_SPLAY_LINKS pLinks
    );

BOOLEAN
KdIsLeftChild (
    IN PRTL_SPLAY_LINKS Links
    );

BOOLEAN
KdIsRightChild (
    IN PRTL_SPLAY_LINKS Links
    );

BOOLEAN
KdIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    );

PRTL_SPLAY_LINKS
KdRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    );

ULONG64
KdEnumerateGenericTableWithoutSplaying (
    IN ULONG64 pTable,
    IN ULONG64 *RestartKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\enumfile.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    enumfile.c

Abstract:

    This module contains tests for enumeration-by-fileref and bulk security test

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>

#include <ddeml.h>      // for CP_WINUNICODE

#include <objidl.h>

extern "C"
{
#include <propapi.h>
}

#include <stgprop.h>

#include <stgvar.hxx>
#include <propstm.hxx>
#include <align.hxx>
#include <sstream.hxx>

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

#define QuadAlign(P) (                \
    ((((ULONG)(P)) + 7) & 0xfffffff8) \
)


//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}


void
BulkSecurityTest (
    char *FileName
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    WCHAR WFileName[MAX_PATH];
    IO_STATUS_BLOCK Iosb;


    //
    //  Open the file
    //
    
    SzToWsz( WFileName, FileName );

    Status = OpenObject( WFileName,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FALSE,
                         FILE_OPEN,
                         &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "Unable to open %s - %x\n", FileName, Status );
        return;
    }

#define SECURITY_COUNT  10
    char InputBuffer[sizeof( BULK_SECURITY_TEST_DATA ) - sizeof( ULONG ) + SECURITY_COUNT * sizeof( ULONG )];
    PBULK_SECURITY_TEST_DATA SecurityData = (PBULK_SECURITY_TEST_DATA) InputBuffer;

    SecurityData->DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA;
    for (int i = 0; i < SECURITY_COUNT; i++) {
        SecurityData->SecurityIds[i] = 0xFF + i;
    }
    
    NTSTATUS Output[SECURITY_COUNT];

    Status = NtFsControlFile(
        Handle,
        NULL,
        NULL,
        NULL,
        &Iosb,
        FSCTL_SECURITY_ID_CHECK,
        &InputBuffer,
        sizeof( InputBuffer ),
        Output,
        sizeof( Output ));

    printf( "Bulk test returned %x\n", Status );
    for (i = 0; i < SECURITY_COUNT; i++) {
        printf( " Status[%d] = %x\n", i, Output[i] );
    }

    NtClose( Handle );
}

void
EnumFile (
    char *FileName
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    WCHAR WFileName[MAX_PATH];
    char InputBuffer[10];
    char OutputBuffer[200];
    IO_STATUS_BLOCK Iosb;


    //
    //  Open the file
    //
    
    SzToWsz( WFileName, FileName );

    Status = OpenObject( WFileName,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FALSE,
                         FILE_OPEN,
                         &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "Unable to open %s - %x\n", FileName, Status );
        return;
    }

    //
    //  Set up input data
    //

    MFT_ENUM_DATA EnumData = { 1, 0, 1 };

    //
    //  Set up output buffer
    //
    
    BYTE Output[4096];

    while (TRUE) {
        
        Status = NtFsControlFile(
            Handle,
            NULL,
            NULL,
            NULL,
            &Iosb,
            FSCTL_ENUM_USN_DATA,
            &EnumData,
            sizeof( EnumData ),
            Output,
            sizeof( Output ));

        if (!NT_SUCCESS( Status )) {
            printf( "NtfsControlFile returned %x\n", Status );
            break;
        }

        //
        //  Display output buffer
        //

        printf( "Length is %x\n", Iosb.Information );

        if (Iosb.Information < sizeof( ULONGLONG ) + sizeof( USN_RECORD )) {
            break;
        }

        printf( "Next file reference is %16I64x\n", *(PULONGLONG)Output );
        
        PUSN_RECORD UsnRecord = (PUSN_RECORD) (Output + sizeof( ULONGLONG ));

        while ((PBYTE)UsnRecord < Output + Iosb.Information) {
            printf( "FR %16I64x  Parent %016I64x  Usn %016I64x  SecurityId %08x  Reason %08x  Name(%d): '%.*ws'\n",
                   UsnRecord->FileReferenceNumber,
                   UsnRecord->ParentFileReferenceNumber,
                   UsnRecord->Usn,
                   UsnRecord->SecurityId,
                   UsnRecord->Reason,
                   UsnRecord->FileNameLength,
                   UsnRecord->FileNameLength / sizeof( WCHAR ),
                   UsnRecord->FileName );

            ULONG Length = sizeof( USN_RECORD ) + UsnRecord->FileNameLength - sizeof( WCHAR );
            Length = QuadAlign( Length );
            UsnRecord = (PUSN_RECORD) Add2Ptr( UsnRecord, Length );
        }

        EnumData.StartFileReferenceNumber = *(PLONGLONG)Output;
    }
    
    
    //
    //  Close the file
    //

    Status = NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to close %s - %x\n", FileName, Status );
    }

}




#define SHIFT(c,v)  ((c)--,(v)++)

int __cdecl
main (
    int argc,
    char **argv)
{
    SHIFT( argc, argv );
    
    if (argc > 0) {
        if (!strcmp( *argv, "-e")) {
    
            SHIFT( argc, argv );
            
            while (argc != 0) {
                EnumFile( *argv );
                SHIFT( argc, argv );
            }
        } else {
            BulkSecurityTest( *argv );
        }
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\findfile.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    findfile.cxx

Abstract:

    This module contains tests for finding files by sid

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>

#define SID_MAX_LENGTH        \
    (FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)

__inline
VOID *
Add2Ptr(VOID *pv, ULONG cb)
{
    return((BYTE *) pv + cb);
}

__inline
ULONG
QuadAlign( ULONG Value )
{
    return (Value + 7) & ~7;
}

//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    HANDLE RelatedObject,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    if (RelatedObject == NULL) {
        
        RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    } else {
        
        RtlInitUnicodeString(&str, pwszFile);

    }

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		RelatedObject,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}

int __cdecl
main (
    int argc,
    char **argv)
{
    
    if (argc != 3) {
        printf( "Usage: findfile [user] [dir]\n" );
        return 1;
    }
    
    WCHAR FileName[MAX_PATH];
    SzToWsz( FileName, argv[2] );
    
    HANDLE Handle;
    NTSTATUS Status = OpenObject( FileName,
                                  NULL,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                                  FILE_READ_ATTRIBUTES,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  FILE_OPEN,
                                  &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "OpenObject returned %x\n", Status );
        return 1;
    }

    struct {
        ULONG Restart;
        BYTE Sid[SID_MAX_LENGTH];
    } FsCtlInput;
    
    ULONG SidLength = sizeof( FsCtlInput.Sid );
    CHAR Domain[MAX_PATH];
    ULONG DomainLength = sizeof( Domain );
    SID_NAME_USE SidNameUse;

    if (!LookupAccountName( NULL,
                            argv[1],
                            FsCtlInput.Sid, 
                            &SidLength,
                            Domain,
                            &DomainLength,
                            &SidNameUse )
        ) {

        printf( "LookupAccountName failed %x\n", GetLastError( ));
        return 1;
    }

    IO_STATUS_BLOCK Iosb;
    
    FsCtlInput.Restart = 1;
    
    BYTE Output[MAX_PATH + 10];
    
    while (TRUE) {
    
        Status = NtFsControlFile(
            Handle,
            NULL,
            NULL,
            NULL,
            &Iosb,
            FSCTL_FIND_FILES_BY_SID,
            &FsCtlInput,
            sizeof( FsCtlInput ),
            NULL,
            sizeof( Output ));
        
        Status = NtFsControlFile(
            Handle,
            NULL,
            NULL,
            NULL,
            &Iosb,
            FSCTL_FIND_FILES_BY_SID,
            &FsCtlInput,
            sizeof( FsCtlInput ),
            Output,
            sizeof( Output ));
        
        FsCtlInput.Restart = 0;
    
        if (!NT_SUCCESS( Status ) && Status != STATUS_BUFFER_OVERFLOW) {
            printf( "NtfsControlFile returned %x\n", Status );
            return 1;
        }
    
        //
        //  Display output buffer
        //
    
        printf( "Length is %x\n", Iosb.Information );
    
        if (Iosb.Information == 0) {
            break;
        }
    
        PFILE_NAME_INFORMATION FileNameInfo = (PFILE_NAME_INFORMATION) Output;
    
        while ((PBYTE)FileNameInfo < Output + Iosb.Information) {
            ULONG Length = 
                sizeof( FILE_NAME_INFORMATION ) - sizeof( WCHAR ) + 
                FileNameInfo->FileNameLength;

            printf( "%d: '%.*ws' ", 
                    FileNameInfo->FileNameLength,
                    FileNameInfo->FileNameLength / sizeof( WCHAR ),
                    FileNameInfo->FileName );

            HANDLE ChildHandle;
            WCHAR ChildFileName[ MAX_PATH ];
            
            RtlMoveMemory( ChildFileName, FileNameInfo->FileName, FileNameInfo->FileNameLength );
            ChildFileName[FileNameInfo->FileNameLength / sizeof( WCHAR )] = L'\0';
            Status = OpenObject( ChildFileName,
                                 Handle,
                                 FILE_SYNCHRONOUS_IO_NONALERT,
                                 FILE_READ_ATTRIBUTES,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN,
                                 &ChildHandle );

            if (!NT_SUCCESS( Status )) {
                printf( "\nUnable to open child - %x\n", Status );
            } else {
      