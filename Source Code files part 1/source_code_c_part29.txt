f client has called CreateETrigger then 
            //  parse input params to get trigger name, trigger desc, trigger action
            //  and trigger query for creating new instances of TriggerEventConsumer,
            //  __EventFilter and __FilterToConsumerBinding classes

            //initialize variables
            VariantInit( &varTriggerAction );
            VariantInit( &varTriggerQuery );
            VariantInit( &varTriggerDesc );
            VariantInit( &varRUser );
            VariantInit( &varRPwd );

            //Retrieve Trigger Name parameter from input params
            hRes = pIInParams->Get( IN_TRIGGER_NAME, 0, &varTriggerName, NULL, NULL );
            if( SUCCEEDED( hRes ) )
            {
                //Retrieve Trigger Action parameter from input params
                hRes = pIInParams->Get( IN_TRIGGER_ACTION, 0, &varTriggerAction, NULL, NULL );
                if( SUCCEEDED( hRes ) )
                {
                    //Retrieve Trigger Query parameter from input params
                    hRes = pIInParams->Get( IN_TRIGGER_QUERY, 0, &varTriggerQuery, NULL, NULL );
                    if( SUCCEEDED( hRes ) )
                    {
                        //Retrieve Trigger Description parameter from input params
                        hRes = pIInParams->Get( IN_TRIGGER_DESC, 0, &varTriggerDesc, NULL, NULL );
                        if( SUCCEEDED( hRes ) )
                        {
                            hRes = pIInParams->Get( IN_TRIGGER_USER, 0, &varRUser, NULL, NULL );
                            if( SUCCEEDED( hRes ) )
                            {
                                EnterCriticalSection( &g_critical_sec );
                                hRes = ValidateParams( varTriggerName, varTriggerAction,
                                                       varTriggerQuery, varRUser );
                                if( SUCCEEDED( hRes ) )
                                {
                                    hRes = pIInParams->Get( IN_TRIGGER_PWD, 0, &varRPwd, NULL, NULL );
                                    if( SUCCEEDED( hRes ) )
                                    {
                                        //call create trigger function to create the instances
                                        hRes = CreateTrigger( varTriggerName, varTriggerDesc,
                                                              varTriggerAction, varTriggerQuery,
                                                              varRUser, varRPwd, &hRes1 );
										// changed on 07/12/02 to send error instead of warning if account info not set
                                        if( ( SUCCEEDED( hRes ) ) || ( ERROR_TASK_SCHDEULE_SERVICE_STOP == hRes1 ) )
                                        {
                                            // increment the class member variable by one to get the new unique trigger id
                                            //for the next instance
                                            if( MAX_TRIGGEID_VALUE > m_dwNextTriggerID )
                                            {
                                                m_dwNextTriggerID = m_dwNextTriggerID + 1;
                                            }
                                            else
                                            {
                                                m_MaxTriggers = TRUE;
                                            }
                                        }
                                    }
                                }
                                LeaveCriticalSection( &g_critical_sec );
                            }
                        }
                    }
                }
            }
            VariantClear( &varTriggerAction );
            VariantClear( &varRUser );
            VariantClear( &varRPwd );
            VariantClear( &varTriggerDesc );
            VariantClear( &varTriggerQuery );
        }
        else if( ( StringCompare( bstrMethodName, DELETE_METHOD_NAME, TRUE, 0 ) == 0 ) ||
                ( StringCompare( bstrMethodName, DELETE_METHOD_NAME_EX, TRUE, 0 ) == 0 ) )
        {
            //Retrieve Trigger ID parameter from input params
            hRes = pIInParams->Get( IN_TRIGGER_NAME, 0, &varTriggerName, NULL, NULL );

            if( SUCCEEDED( hRes ) )
            {
                EnterCriticalSection( &g_critical_sec );
                //call Delete trigger function to delete the instances
                hRes = DeleteTrigger( varTriggerName, &dwTrigId );
                LeaveCriticalSection( &g_critical_sec );
            }
        }
        else if( ( StringCompare( bstrMethodName, QUERY_METHOD_NAME, TRUE, 0 ) == 0 ) ||
                ( StringCompare( bstrMethodName, QUERY_METHOD_NAME_EX, TRUE, 0 ) == 0 ) )
        {
            VariantInit( &varScheduledTaskName );
            VariantInit( &varRUser );
            //Retrieve schedule task name parameter from input params
            hRes = pIInParams->Get( IN_TRIGGER_TSCHDULER, 0, &varScheduledTaskName, NULL, NULL );
            if( SUCCEEDED( hRes ) )
            {
                EnterCriticalSection( &g_critical_sec );
                //call query trigger function to query the runasuser
                CHString szRunAsUser = L"";
                hRes = CoImpersonateClient();
                if( SUCCEEDED( hRes ) )
                {
                    varRUser.vt  = VT_BSTR;
                    varRUser.bstrVal = SysAllocString( L"" );
                    hRes = pIOutParams->Put( OUT_RUNAS_USER , 0, &varRUser, 0 );
                    VariantClear( &varRUser );
                    if( SUCCEEDED( hRes ) )
                    {
                        hRes = QueryTrigger( varScheduledTaskName, szRunAsUser );
                        if( SUCCEEDED( hRes ) )
                        {
                            VariantInit( &varRUser );
                            varRUser.vt  = VT_BSTR;
                            varRUser.bstrVal = SysAllocString( szRunAsUser );
                            hRes = pIOutParams->Put( OUT_RUNAS_USER , 0, &varRUser, 0 );
                        }
                    }
                }
                CoRevertToSelf();
                LeaveCriticalSection( &g_critical_sec );
            }
            VariantClear( &varScheduledTaskName );
            VariantClear( &varRUser );  
        }
        else
        {
             hRes = WBEM_E_INVALID_PARAMETER;
        }

        if( ( StringCompare( bstrMethodName, CREATE_METHOD_NAME, TRUE, 0 ) == 0 ) ||
            ( StringCompare( bstrMethodName, CREATE_METHOD_NAME_EX, TRUE, 0 ) == 0 ) )
        {
            lpResStr = ( LPTSTR ) AllocateMemory( MAX_RES_STRING1 );

            if ( lpResStr != NULL )
            {
				// changed on 07/12/02 to log error if account info is not set instead of success
                if( ( SUCCEEDED( hRes ) ) || ( ERROR_TASK_SCHDEULE_SERVICE_STOP == hRes1 ) )
                {
                    LoadStringW( g_hModule, IDS_CREATED, lpResStr, GetBufferSize(lpResStr)/sizeof(WCHAR) );
                    if( hRes1 != NO_ERROR )// write invalid user into log file
                    {
                        LPTSTR lpResStr1 = NULL; 
                        lpResStr1 = ( LPTSTR ) AllocateMemory( MAX_RES_STRING1 );
                        if ( lpResStr1 != NULL )
                        {
                            if( hRes1 == ERROR_TASK_SCHDEULE_SERVICE_STOP )
                            {
                                hRes = WBEM_S_NO_ERROR;
                                LoadStringW( g_hModule,IDS_INFO_SERVICE_STOPPED, lpResStr1, GetBufferSize(lpResStr1)/sizeof(WCHAR) );
                                StringConcat( lpResStr, lpResStr1, GetBufferSize(lpResStr)/sizeof(WCHAR) );
                            }
                            FreeMemory( (LPVOID*)&lpResStr1 );
                        }
                    }
                    ErrorLog( lpResStr, ( LPWSTR )_bstr_t( varTriggerName ), ( m_dwNextTriggerID - 1 ) );
                }
                else
                {
                    LoadStringW( g_hModule, IDS_CREATE_FAILED, lpResStr, GetBufferSize(lpResStr)/sizeof(WCHAR) );
                    ErrorLog( lpResStr, ( LPWSTR )_bstr_t( varTriggerName ), ( m_dwNextTriggerID - 1 ) );
                }
                FreeMemory( (LPVOID*)&lpResStr );
            }
            else
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else if( ( StringCompare( bstrMethodName, DELETE_METHOD_NAME, TRUE, 0 ) == 0 ) ||
                ( StringCompare( bstrMethodName, DELETE_METHOD_NAME_EX, TRUE, 0 ) == 0 ) )
        {
            lpResStr = ( LPTSTR ) AllocateMemory( MAX_RES_STRING1 );

            if ( lpResStr != NULL )
            {
                if(( SUCCEEDED( hRes ) ) )
                {
                    LoadStringW( g_hModule, IDS_DELETED, lpResStr, GetBufferSize(lpResStr)/sizeof(WCHAR) );
                    ErrorLog( lpResStr, ( LPWSTR )_bstr_t( varTriggerName ), dwTrigId );
                }
                else
                {
                    LoadStringW( g_hModule, IDS_DELETE_FAILED, lpResStr, GetBufferSize(lpResStr)/sizeof(WCHAR) );
                    ErrorLog( lpResStr,( LPWSTR )_bstr_t( varTriggerName ), dwTrigId );
                }
                FreeMemory( (LPVOID*)&lpResStr );

            }
            else
            {
                hRes = E_OUTOFMEMORY;
            }
        }

        VariantClear( &varTriggerName );
        VariantInit( &varTemp );
        V_VT( &varTemp ) = VT_I4;

        if ( NO_ERROR != hRes1 )
        {
            if( StringCompare( bstrMethodName, CREATE_METHOD_NAME, TRUE, 0 ) == 0 )
            {
                 V_I4( &varTemp ) = WARNING_INVALID_USER;
            }
            else
            {
                V_I4( &varTemp ) = hRes1;
            }
        }
        else
        {
            if( StringCompare( bstrMethodName, CREATE_METHOD_NAME, TRUE, 0 ) == 0 )
            {
                if ( hRes == ERROR_TRIGNAME_ALREADY_EXIST_EX )
                {
                    hRes = ( HRESULT )ERROR_TRIGNAME_ALREADY_EXIST;
                }
            }
            if( StringCompare( bstrMethodName, DELETE_METHOD_NAME, TRUE, 0 ) == 0 )
            {
                if ( hRes == ERROR_TRIGGER_NOT_FOUND_EX )
                {
                    hRes = ( HRESULT )ERROR_TRIGGER_NOT_FOUND;
                }
                if ( hRes == ERROR_TRIGGER_NOT_DELETED_EX )
                {
                    hRes = ( HRESULT )ERROR_TRIGGER_NOT_DELETED;
                }
            }
            if( StringCompare( bstrMethodName, QUERY_METHOD_NAME, TRUE, 0 ) == 0 )
            {
                if ( hRes == ERROR_TRIGGER_CORRUPTED_EX )
                {
                    hRes = WBEM_NO_ERROR;
                }
                if ( hRes == ERROR_INVALID_USER_EX )
                {
                    hRes = WBEM_NO_ERROR;
                }
            }
            V_I4( &varTemp ) = hRes;
        }

        // set out params
        hRes = pIOutParams->Put( RETURN_VALUE , 0, &varTemp, 0 );
        VariantClear( &varTemp );
        if( SUCCEEDED( hRes ) )
        {
            // Send the output object back to the client via the sink. Then 
            hRes = pIResultSink->Indicate( 1, &pIOutParams );
        }
            //release all the resources
        SAFERELEASE( pIOutParams );
        
        hRes = pIResultSink->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );
    }
    catch(_com_error& e)
    {
        VariantClear( &varTriggerName );
        FREESTRING( lpResStr );
        SAFERELEASE( pIOutParams );
        pIResultSink->SetStatus( 0, hRes, NULL, NULL );
        return e.Error();
    }
    catch( CHeap_Exception  )
    {
        VariantClear( &varTriggerName );
        FREESTRING( lpResStr );
        SAFERELEASE( pIOutParams );
        hRes = E_OUTOFMEMORY;
        pIResultSink->SetStatus( 0, hRes, NULL, NULL );
        return hRes;
    }

    return hRes;
}


HRESULT
CTriggerProvider::CreateTrigger(
    IN VARIANT varTName,
    IN VARIANT varTDesc,
    IN VARIANT varTAction,
    IN VARIANT varTQuery,
    IN VARIANT varRUser,
    IN VARIANT varRPwd,
    OUT HRESULT *phRes
    )
/*++
Routine Description:
    This routine creates the instance of TriggerEventConsumer,
    __EventFilter and __FilterToConsumerBinding classes.

Arguments:
    [IN] varTName   :  Trigger Name.
    [IN] VarTDesc   :  Trigger Description.
    [IN] varTAction :  Trigger Action.
    [IN] varTQuery  :  Trigger Query.
    [IN] varRUser   :  Run as user name.
    [IN] varRPwd    :  Run as Password.
    [OUT] phRes     :  Return value of scedule task creation.
Return Value:
    S_OK if successful.
    Otherwise failure  error code.
--*/
{
    IWbemClassObject            *pINtLogEventClass = 0;
    IWbemClassObject            *pIFilterClass = 0;
    IWbemClassObject            *pIBindClass = 0;
    IWbemClassObject            *pINewInstance = 0;
    IEnumWbemClassObject        *pIEnumClassObject = 0;
    HRESULT                     hRes = 0;
    DWORD                       dwTId = 0;
    VARIANT                     varTemp;
    TCHAR                       szTemp[MAX_RES_STRING1];
    TCHAR                       szTemp1[MAX_RES_STRING1];
    TCHAR                       szFName[MAX_RES_STRING1];
    SYSTEMTIME                  SysTime;
    BOOL                        bInvalidUser = FALSE;

    try
    {
        _bstr_t                     bstrcurInst;
        _bstr_t                     bstrcurInst1;
        //initialize memory for temporary variables
        SecureZeroMemory( szTemp, MAX_RES_STRING1 * sizeof( TCHAR ) );
        SecureZeroMemory( szTemp1, MAX_RES_STRING1 * sizeof( TCHAR ) );
        SecureZeroMemory( szFName, MAX_RES_STRING1 * sizeof( TCHAR ) );
        VariantInit( &varTemp );
        if ( NULL != phRes )
        {
            *phRes = S_OK;
        }

	   // changed on 07/12/02  just moved the block of code 
        /**************************************************************************

                               CREATING TriggerEventConsumer INSTANCE

        ***************************************************************************/

        //get NTEventConsumer class object
        hRes =m_pServices->GetObject( _bstr_t( CONSUMER_CLASS ), 0, 0, &pINtLogEventClass, NULL );

        //if unable to get the object of TriggerEventConsumer return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINtLogEventClass );// safer side
            return hRes;
        }

        // Create a new instance.
        pINewInstance = NULL;
        hRes = pINtLogEventClass->SpawnInstance( 0, &pINewInstance );
        SAFERELEASE( pINtLogEventClass );  // Don't need the class any more

        // if unable to spawn a instance return back to caller
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        //get the unique trigger id by enumerating CmdTriggerConsumer class. if there are no triggers then
        // intialize the trigger id to 1

        hRes =  m_pServices->ExecQuery( _bstr_t( QUERY_LANGUAGE ), _bstr_t( INSTANCE_EXISTS_QUERY ),
                                          WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pIEnumClassObject );
        if( FAILED( hRes ) )
        {
			SAFERELEASE( pIEnumClassObject );
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        DWORD dwReturned = 0;
        IWbemClassObject *pINTCons = NULL;
        // Enumerate through the resultset.
        hRes = pIEnumClassObject->Next( WBEM_INFINITE,
                                1,              // return just one service
                                &pINTCons,          // pointer to service
                                &dwReturned );  // number obtained: one or zero

        if ( SUCCEEDED( hRes ) && ( dwReturned == 1 ) )
        {
            SAFERELEASE( pINTCons );
        } // If Service Succeeded
        else
        {
             m_dwNextTriggerID = 1;
        }

        SAFERELEASE( pIEnumClassObject );

        dwTId = m_dwNextTriggerID;

        VariantInit(&varTemp);
        varTemp.vt = VT_I4;
        varTemp.lVal = dwTId;

        // set the trigger id property of NTEventConsumer
        hRes = pINewInstance->Put( TRIGGER_ID, 0, &varTemp, 0 );
        VariantClear( &varTemp );

        //if failed to set the property return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        // set Triggername  property.
        hRes = pINewInstance->Put( TRIGGER_NAME, 0, &varTName, 0 );
        
        //if failed to set the property return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        // set action property
        hRes = pINewInstance->Put( TRIGGER_ACTION, 0, &varTAction, 0 );
        
        //if failed to set the property return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        //set desc property
        hRes = pINewInstance->Put( TRIGGER_DESC, 0, &varTDesc, 0 );
                 
        //if failed to set the property return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        CHString szScheduler = L"";
        CHString szRUser = (LPCWSTR)_bstr_t(varRUser.bstrVal);
        {
            do
            {
                GetUniqueTScheduler( szScheduler, m_dwNextTriggerID, varTName );
                hRes = CoImpersonateClient();
                if( FAILED( hRes ) )
                {
                    SAFERELEASE( pINewInstance );
                    return hRes;
                }
                hRes = SetUserContext( varRUser, varRPwd, varTAction, szScheduler );
                CoRevertToSelf();
                if( HRESULT_FROM_WIN32 (ERROR_FILE_EXISTS ) != hRes )
                {
                    break;
                }
            }while( 1 );
            if( FAILED( hRes ) )
            {
				// changed on 07/12/02 not to handle user info not set as warning but as error
                if( hRes == ERROR_TASK_SCHDEULE_SERVICE_STOP ) //to send a warning msg to client
                {
                    *phRes = hRes;
                }
                else
                {
                    SAFERELEASE( pINewInstance );
                    return hRes;
                }
            }
        }
        VariantInit(&varTemp);
        varTemp.vt  = VT_BSTR;
        varTemp.bstrVal = SysAllocString( szScheduler );
        hRes = pINewInstance->Put( TASK_SHEDULER, 0, &varTemp, 0 );
        VariantClear( &varTemp );
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        // Write the instance to WMI. 
        hRes = m_pServices->PutInstance( pINewInstance, 0, 0, NULL );
        SAFERELEASE( pINewInstance );

        //if putinstance failed return error
        if( FAILED( hRes ) )
        {
            return hRes;
        }

        //get the current instance for binding it with __FilterToConsumerBinding class
        StringCchPrintf( szTemp, SIZE_OF_ARRAY( szTemp ), BIND_CONSUMER_PATH, dwTId);

        bstrcurInst1 = _bstr_t( szTemp );
        pINtLogEventClass = NULL;
        hRes = m_pServices->GetObject( bstrcurInst1, 0L, NULL, &pINtLogEventClass, NULL );

        //if unable to get the current instance return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINtLogEventClass );
            return hRes;
        }

 /**************************************************************************

                               CREATING __EventFilter INSTANCE

        ***************************************************************************/
        // get EventFilter class object
        hRes = m_pServices->GetObject( _bstr_t( FILTER_CLASS ), 0, 0, &pIFilterClass, NULL );
        
        if( FAILED( hRes ) )
        {
           SAFERELEASE( pINtLogEventClass );
           SAFERELEASE( pIFilterClass );
           return hRes;
        }

        // Create a new instance.
        hRes = pIFilterClass->SpawnInstance( 0, &pINewInstance );
        SAFERELEASE( pIFilterClass );  // Don't need the class any more

        //return error if unable to spawn a new instance of EventFilter class
        if( FAILED( hRes ) )
        {
           SAFERELEASE( pINtLogEventClass );
           SAFERELEASE( pINewInstance );
           return hRes;
        }

        // set query property for the new instance
        hRes = pINewInstance->Put( FILTER_QUERY, 0, &varTQuery, 0 );
            
        //if failed to set the property return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINtLogEventClass );
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        VariantInit( &varTemp ); 
        varTemp.vt = VT_BSTR;
        varTemp.bstrVal = SysAllocString( QUERY_LANGUAGE );
        
        //  set query language property for the new instance .
        hRes = pINewInstance->Put( FILTER_QUERY_LANGUAGE, 0, &varTemp, 0 );
        VariantClear( &varTemp ); 
            
        //if failed to set the property return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINtLogEventClass );
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        //generate unique name for name key property of EventFilter class by concatinating
        // current system date and time

        GetSystemTime( &SysTime );
        StringCchPrintf( szTemp, SIZE_OF_ARRAY( szTemp ), FILTER_UNIQUE_NAME, m_dwNextTriggerID, SysTime.wHour, SysTime.wMinute,
                  SysTime.wSecond, SysTime.wMonth, SysTime.wDay, SysTime.wYear );
        //set Filter name property
        VariantInit( &varTemp ); 
        varTemp.vt  = VT_BSTR;
        varTemp.bstrVal = SysAllocString( szTemp );
        
        hRes = pINewInstance->Put( FILTER_NAME, 0, &varTemp, 0 );
        VariantClear( &varTemp );
        
        //if failed to set the property return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINtLogEventClass );
            SAFERELEASE( pINewInstance );
            return hRes;
        }

        // Write the instance to WMI. 
        hRes = m_pServices->PutInstance( pINewInstance, 0, NULL, NULL );
        SAFERELEASE( pINewInstance );

        //if putinstance failed return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINtLogEventClass );
            return hRes;
        }

        //get the current Eventfilter instance for binding filter to consumer
        StringCchPrintf( szTemp1, SIZE_OF_ARRAY( szTemp1 ), BIND_FILTER_PATH );
        bstrcurInst = _bstr_t(szTemp1) + _bstr_t(szTemp) + _bstr_t(BACK_SLASH);
        pIFilterClass = NULL;
        hRes = m_pServices->GetObject( bstrcurInst, 0L, NULL, &pIFilterClass, NULL );

        //unable to get the current instance object return error
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pINtLogEventClass );
            SAFERELEASE( pIFilterClass );
            return hRes;
        }

        /**************************************************************************

                               BINDING FILTER TO CONSUMER

        ***************************************************************************/

        // if association class exists...
        if( ( hRes = m_pServices->GetObject( _bstr_t( BINDINGCLASS ), 0L, NULL, &pIBindClass, NULL ) ) == S_OK )
        {
            // spawn a new instance.
            pINewInstance = NULL;
            if( ( hRes = pIBindClass->SpawnInstance( 0, &pINewInstance ) ) == WBEM_S_NO_ERROR )
            {
                // set consumer instance name
                if ( ( hRes = pINtLogEventClass->Get( REL_PATH, 0L, 
                                            &varTemp, NULL, NULL ) ) == WBEM_S_NO_ERROR ) 
                {
                    hRes = pINewInstance->Put( CONSUMER_BIND, 0, &varTemp, 0 );
                    VariantClear( &varTemp );
                
                    // set Filter ref
                    if ( ( hRes = pIFilterClass->Get( REL_PATH, 0L, 
                                                &varTemp, NULL, NULL ) ) == WBEM_S_NO_ERROR ) 
                    {
                        hRes = pINewInstance->Put( FILTER_BIND, 0, &varTemp, 0 );
                        VariantClear( &varTemp );
                                
                        // putInstance
                        hRes = m_pServices->PutInstance( pINewInstance,
                                                        WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
                    }
                }
                SAFERELEASE( pINewInstance );
                SAFERELEASE( pINtLogEventClass );  // Don't need the class any more
                SAFERELEASE( pIFilterClass );  // Don't need the class any more
                SAFERELEASE( pIBindClass );
            }
            else
            {
                SAFERELEASE( pINtLogEventClass );  // Don't need the class any more
                SAFERELEASE( pIFilterClass );  // Don't need the class any more
                SAFERELEASE( pIBindClass );
            }

        }
        else
        {
                SAFERELEASE( pINtLogEventClass );  // Don't need the class any more
                SAFERELEASE( pIFilterClass );  // Don't need the class any more
        }
    }
    catch(_com_error& e)
    {
        SAFERELEASE( pINewInstance );
        SAFERELEASE( pINtLogEventClass );  
        SAFERELEASE( pIFilterClass );  
        SAFERELEASE( pIBindClass );
		SAFERELEASE( pIEnumClassObject );
        return e.Error();
    }
    catch( CHeap_Exception  )
    {
        SAFERELEASE( pINewInstance );
        SAFERELEASE( pINtLogEventClass );  
        SAFERELEASE( pIFilterClass );  
        SAFERELEASE( pIBindClass );
		SAFERELEASE( pIEnumClassObject );
        return E_OUTOFMEMORY;
    }
    return hRes;
}

HRESULT
CTriggerProvider::DeleteTrigger(
    IN VARIANT varTName,
    OUT DWORD *dwTrigId
    )
/*++
Routine Description:
    This routine deletes the instance of TriggerEventConsumer,
    __EventFilter and __FilterToConsumerBinding classes.

Arguments:
    [IN] varTName      : Trigger Name.
    [OUT] dwTrigId     : Trigger id.

Return Value:
    WBEM_S_NO_ERROR if successful.
    Otherwise failure  error code.
--*/
{
    HRESULT                         hRes = 0;
    IEnumWbemClassObject            *pIEventBinder   = NULL;
    IWbemClassObject                *pINTCons = NULL;
    DWORD                           dwReturned = 1;
    DWORD                           i =0;
    DWORD                           j = 0;
    TCHAR                           szTemp[MAX_RES_STRING1];
    TCHAR                           szTemp1[MAX_RES_STRING1];
    VARIANT                         varTemp;
    BSTR                            bstrFilInst = NULL;
    DWORD                           dwFlag = 0;
    wchar_t                         *szwTemp2 = NULL;
    wchar_t                         szwFilName[MAX_RES_STRING1];
    try
    {
        _bstr_t                         bstrBinInst;
        CHString                        strTScheduler = L"";

        SecureZeroMemory( szTemp, MAX_RES_STRING1 * sizeof( TCHAR ) );
        SecureZeroMemory( szTemp1, MAX_RES_STRING1 * sizeof( TCHAR ) );
        SecureZeroMemory( szwFilName, MAX_RES_STRING1 * sizeof( TCHAR ) );

        StringCchPrintf( szTemp, SIZE_OF_ARRAY( szTemp ), TRIGGER_INSTANCE_NAME, varTName.bstrVal );
        hRes =  m_pServices->ExecQuery( _bstr_t( QUERY_LANGUAGE ), _bstr_t( szTemp ),
                        WBEM_FLAG_RETURN_IMMEDIATELY| WBEM_FLAG_FORWARD_ONLY, NULL,
                        &pIEventBinder );
       
        SecureZeroMemory( szTemp, MAX_RES_STRING1 * sizeof( TCHAR ) );
        if( FAILED( hRes ) )
        {
            return hRes;
        }
        while ( ( 1 == dwReturned ) &&  ( 0 == dwFlag ) )
        {
            // Enumerate through the resultset.
            hRes = pIEventBinder->Next( WBEM_INFINITE,
                                    1,              // return just one service
                                    &pINTCons,          // pointer to service
                                    &dwReturned );  // number obtained: one or zero

            if ( SUCCEEDED( hRes ) && ( 1 == dwReturned ) )
            {
                dwFlag = 1;
        
            } // If Service Succeeded

        }
        SAFERELEASE( pIEventBinder );
        if( 0 == dwFlag )
        {
            SAFERELEASE( pINTCons );
            return ERROR_TRIGGER_NOT_FOUND_EX;
        }

        VariantInit( &varTemp );
        hRes = pINTCons->Get( TRIGGER_ID, 0, &varTemp, 0, NULL );
        if (FAILED( hRes ) )
        {
            SAFERELEASE( pINTCons );
            return hRes;
        }
        *dwTrigId = ( DWORD )varTemp.lVal;
        VariantClear( &varTemp );

        hRes = pINTCons->Get( TASK_SHEDULER, 0, &varTemp, 0, NULL );
        if (FAILED( hRes ) )
        {
            SAFERELEASE( pINTCons );
            return hRes;
        }
        SAFERELEASE( pINTCons );
        strTScheduler = (LPCWSTR) _bstr_t(varTemp.bstrVal);
        VariantClear( &varTemp );
        if( strTScheduler.GetLength() > 0 )
        {
            hRes = CoImpersonateClient();
            if( FAILED( hRes ) )
            {
                return hRes;
            }
            dwReturned = 0;
            hRes =  DeleteTaskScheduler( strTScheduler );
            if ( FAILED( hRes ) && ( ERROR_TRIGGER_CORRUPTED_EX != hRes ) )
            {
                CoRevertToSelf();
                return hRes;
            }
            hRes = CoRevertToSelf();
        }

        StringCchPrintf( szTemp, SIZE_OF_ARRAY( szTemp ), BIND_CONSUMER_PATH, *dwTrigId );

        //enumerate the binding class
        hRes = m_pServices->CreateInstanceEnum(
                            _bstr_t(BINDINGCLASS),
                            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                            NULL, &pIEventBinder );

        if ( SUCCEEDED( hRes ) )
        {
            dwReturned = 1;
            dwFlag = 0;
            //loop through all the instances of binding class to find that trigger
            //id specified. If found loop out and proceed else return error
            // Final Next will return with ulReturned = 0
            while ( ( 1 == dwReturned ) && ( 0 == dwFlag ) )
            {
                IWbemClassObject *pIBind = NULL;

                // Enumerate through the resultset.
                hRes = pIEventBinder->Next( WBEM_INFINITE,
                                        1,              // return just one Logfile
                                        &pIBind,        // pointer to Logfile
                                        &dwReturned );  // number obtained: one or zero

                if ( SUCCEEDED( hRes ) && ( 1 == dwReturned ) )
                {
                    VariantInit(&varTemp);
                    //get consumer property of binding class
                    hRes = pIBind->Get( CONSUMER_BIND, 0, &varTemp, 0, NULL );
                    if ( SUCCEEDED( hRes ) )
                    {
                        if (varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY)
                        {
                            CHString strTemp;
                            strTemp = varTemp.bstrVal;

                            //compare with the inputed value
                            if( StringCompare( szTemp, strTemp, TRUE, 0 ) == 0 ) 
                            {
                                VariantClear( &varTemp );
                                //get the filter property
                                hRes = pIBind->Get( FILTER_BIND, 0, &varTemp, 0, NULL );
                                if ( hRes != WBEM_S_NO_ERROR )
                                {
                                    SAFERELEASE( pIBind );
                                    break;
                                }
                                bstrFilInst = SysAllocString( varTemp.bstrVal );
                                dwFlag = 1;
                            }
                        }
                        else
                        {
                            SAFERELEASE( pIBind );
                            break;
                        }
                    }
                    else
                    {
                        SAFERELEASE( pIBind );
                        break;
                    }
                    SAFERELEASE( pIBind );
                    VariantClear( &varTemp );
                }
                else
                {
                    break;
                }
            } //end of while
            SAFERELEASE( pIEventBinder );
        }
        else
        {
            return( hRes );
        }

        //if instance has been found delete the instances from consumer,filter
        // and binding class
        if( 1 == dwFlag )
        {
            //get the key properties for binding class
            StringCchPrintf( szTemp1, SIZE_OF_ARRAY( szTemp1 ), FILTER_PROP, szTemp );
            szwTemp2 =  (wchar_t *) bstrFilInst;
                
            //manpulate the filter property value to insert the filter name property
            // value in quotes
            i =0;
            while( szwTemp2[i] != EQUAL )
            {
                i++;
            }
            i += 2;
            j = 0;
            while( szwTemp2[i] != DOUBLE_QUOTE )
            {
                szwFilName[j] = ( wchar_t )szwTemp2[i];
                i++;
                j++;
            }
            szwFilName[j] = END_OF_STRING;
            bstrBinInst = _bstr_t( szTemp1 ) + _bstr_t( szwFilName ) + _bstr_t(DOUBLE_SLASH);

            //got it so delete the instance
            hRes = m_pServices->DeleteInstance( bstrBinInst, 0, 0, NULL );
            
            if( FAILED( hRes ) )
            {   
                SysFreeString( bstrFilInst );
                return hRes;    
            }
            //deleting instance from EventFilter class
            hRes = m_pServices->DeleteInstance( bstrFilInst, 0, 0, NULL );
            if( FAILED( hRes ) )
            {
                SysFreeString( bstrFilInst );
                return hRes;
            }

            //deleting instance from TriggerEventConsumer Class
            hRes = m_pServices->DeleteInstance( _bstr_t(szTemp), 0, 0, NULL );
            if( FAILED( hRes ) )
            {
                SysFreeString( bstrFilInst );
                return hRes;
            }
            SysFreeString( bstrFilInst );
        }
        else
        {
            return ERROR_TRIGGER_NOT_FOUND_EX;
        }
    }
    catch(_com_error& e)
    {
		SAFERELEASE( pINTCons );
		SAFERELEASE( pIEventBinder );
        return e.Error();
    }
    catch( CHeap_Exception  )
    {
		SAFERELEASE( pINTCons );
		SAFERELEASE( pIEventBinder );
        return E_OUTOFMEMORY;
    }
    return hRes;
}

HRESULT
CTriggerProvider::QueryTrigger(
    IN VARIANT varScheduledTaskName,
    OUT CHString &szRunAsUser
    )
/*++
Routine Description:
    This routine queries task scheduler for account information

Arguments:
    [IN] varScheduledTaskName : Task scheduler name.
    [OUT] szRunAsUser         : stores account information.

Return Value:
    WBEM_S_NO_ERROR if successful.
    Otherwise failure  error code.
--*/
{

    HRESULT        hRes = 0;
    ITaskScheduler *pITaskScheduler = NULL;
    IEnumWorkItems *pIEnum = NULL;
    ITask          *pITask = NULL;

    LPWSTR *lpwszNames = NULL;
    DWORD dwFetchedTasks = 0;
    DWORD dwTaskIndex = 0;
    TCHAR szActualTask[MAX_STRING_LENGTH] = NULL_STRING;
    try
    {
        hRes = GetTaskScheduler(&pITaskScheduler);
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pITaskScheduler );
            return hRes;
        }

        hRes = pITaskScheduler->SetTargetComputer( NULL );
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pITaskScheduler );
            return hRes;
        }
        hRes = pITaskScheduler->Enum( &pIEnum );
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pITaskScheduler );
            return hRes;
        }
        while ( SUCCEEDED( pIEnum->Next( 1,
                                       &lpwszNames,
                                       &dwFetchedTasks ) )
                          && (dwFetchedTasks != 0))
        {
            dwTaskIndex = dwFetchedTasks-1;
            StringCopy( szActualTask,  lpwszNames[ --dwFetchedTasks ], SIZE_OF_ARRAY( szActualTask ) );
            // Parse the TaskName to remove the .job extension.
            szActualTask[StringLength( szActualTask, 0 ) - StringLength( JOB, 0 ) ] = NULL_CHAR;
            StrTrim( szActualTask, TRIM_SPACES );
            CHString strTemp;
            strTemp = varScheduledTaskName.bstrVal;
            if( StringCompare( szActualTask, strTemp, TRUE, 0 ) == 0 )
            {
                hRes = pITaskScheduler->Activate(lpwszNames[dwTaskIndex],IID_ITask,
                                           (IUnknown**) &pITask);
                CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );
                CoTaskMemFree( lpwszNames );
                pIEnum->Release();
                SAFERELEASE( pITaskScheduler );
                if( SUCCEEDED( hRes ) )
                {
                    LPWSTR lpwszUser = NULL;
                    hRes = pITask->GetAccountInformation( &lpwszUser ); 
                    if( SUCCEEDED( hRes ) )
                    {
                        if( 0 == StringLength( ( LPWSTR ) lpwszUser, 0 ) )
                        {
                            szRunAsUser = L"NT AUTHORITY\\SYSTEM";
                        }
                        else
                        {
                            szRunAsUser = ( LPWSTR ) lpwszUser;
                        }
						SAFERELEASE( pITask );
                        return hRes;
                    }
                    else
                    {
						SAFERELEASE( pITask );
                        return hRes;
                    }
                }
                else
                {
                    if( 0x80070005 == hRes )
                    {
                        return ERROR_INVALID_USER_EX;
                    }
                    else
                    {
                        return hRes;
                    }
                }
            }
            CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );
            CoTaskMemFree( lpwszNames );
        }
        pIEnum->Release();
        SAFERELEASE( pITaskScheduler );
    }
    catch(_com_error& e)
    {
		SAFERELEASE( pITask );
		SAFERELEASE( pITaskScheduler );
		SAFERELEASE( pIEnum );
        return e.Error();
    }
    catch( CHeap_Exception  )
    {
		SAFERELEASE( pITask );
		SAFERELEASE( pITaskScheduler );
		SAFERELEASE( pIEnum );
        return E_OUTOFMEMORY;
    }
    return ERROR_TRIGGER_CORRUPTED_EX;
}

HRESULT
CTriggerProvider::ValidateParams(
    IN VARIANT varTrigName,
    IN VARIANT varTrigAction,
    IN VARIANT varTrigQuery,
    IN VARIANT varRUser
    )
/*++
Routine Description:
    This routine validates input parameters trigger name,
    Trigger Query, Trigger Desc, Trigger Action.

Arguments:
    [IN] varTrigName   :  Trigger Name.
    [IN] varTrigAction :  Trigger Action.
    [IN] varTrigQuery  :  Trigger Query.
    [IN] varRUser  :  Trigger Query.

Return Value:
    WBEM_S_NO_ERROR if successful.
    WBEM_E_INVALID_PARAMETER if invalid inputs.
--*/
{
    //local variables
    HRESULT                   hRes = 0;
    IEnumWbemClassObject     *pINTEConsumer = NULL;
    DWORD                     dwReturned = 0;
    DWORD                     dwFlag = 0;
    TCHAR                     szTemp[MAX_RES_STRING1];
    TCHAR                     szTemp1[MAX_RES_STRING1];
    LPTSTR                    lpSubStr = NULL;
    LONG                      lPos = 0;
    try
    {
        CHString                  strTemp = L"";
        if( TRUE == m_MaxTriggers )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }
        //check if input values are null
        if ( varTrigName.vt == VT_NULL )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }
        if ( varTrigAction.vt == VT_NULL )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }
        if( varTrigQuery.vt == VT_NULL )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }

        if( varRUser.vt == VT_NULL )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }

        //validate run as user
        strTemp = (LPCWSTR) _bstr_t(varRUser.bstrVal);
        // user name should not be just '\'
        if ( 0 == strTemp.CompareNoCase( L"\\" ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        // user name should not contain invalid characters
        if ( -1 != strTemp.FindOneOf( L"/[]:|<>+=;,?*" ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        lPos = strTemp.Find( L'\\' );
        if ( -1 != lPos )
        {
            // '\' character exists in the user name
            // strip off the user info upto first '\' character
            // check for one more '\' in the remaining string
            // if it exists, invalid user
            strTemp = strTemp.Mid( lPos + 1 );
            lPos = strTemp.Find( L'\\' );
            if ( -1 != lPos )
            {
                return WBEM_E_INVALID_PARAMETER;
            }
        }

        //validate trigger action
        strTemp = (LPCWSTR) _bstr_t(varTrigAction.bstrVal);
        if( strTemp.GetLength() > 262 )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }

        //validate trigger name
        strTemp = (LPCWSTR) _bstr_t(varTrigName.bstrVal);
        dwReturned = strTemp.FindOneOf( L":|<>?*\\/" ); 
        if( dwReturned != -1 )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }

        // Triggername cannot be more than 196 characters.
        if( MAX_TRIGGERNAME_LENGTH < strTemp.GetLength() )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }
        //validate trigger query
        SecureZeroMemory( szTemp, MAX_RES_STRING1 * sizeof( TCHAR ) );
        SecureZeroMemory( szTemp1, MAX_RES_STRING1 * sizeof( TCHAR ) );

        strTemp = (LPCWSTR) _bstr_t(varTrigQuery.bstrVal);
        StringCopy( szTemp, ( LPCWSTR )strTemp, MAX_RES_STRING1 );
        lpSubStr = _tcsstr( szTemp, _T( "__instancecreationevent where targetinstance isa \"win32_ntlogevent\"" ) );

        if( lpSubStr == NULL )
        {
            return ( WBEM_E_INVALID_PARAMETER );
        }

        //make the SQL staements to query trigger event consumer class to check whether
        //an instance with the inputted trigger is already exists
        strTemp = (LPCWSTR) _bstr_t(varTrigName.bstrVal);
        SecureZeroMemory( szTemp, MAX_RES_STRING1 * sizeof( TCHAR ) );
        StringCopy( szTemp, (LPCWSTR)strTemp, MAX_RES_STRING1 );
        
        StringCchPrintf(szTemp1, SIZE_OF_ARRAY( szTemp1 ) , CONSUMER_QUERY, szTemp );
        //query triggereventconsumer class
        hRes = m_pServices->ExecQuery( _bstr_t( QUERY_LANGUAGE ), _bstr_t( szTemp1 ),
                        WBEM_FLAG_RETURN_IMMEDIATELY| WBEM_FLAG_FORWARD_ONLY, NULL,
                        &pINTEConsumer );

        //enumerate the result set of execquery for trigger name
        dwReturned = 1;
        if ( hRes == WBEM_S_NO_ERROR )
        {
            while ( ( dwReturned == 1 ) &&  ( dwFlag == 0 ) )
            {
                IWbemClassObject *pINTCons = NULL;

                // Enumerate through the resultset.
                hRes = pINTEConsumer->Next( WBEM_INFINITE,
                                    1,              // return just one service
                                    &pINTCons,          // pointer to service
                                    &dwReturned );  // number obtained: one or zero

                if ( SUCCEEDED( hRes ) && ( dwReturned == 1 ) )
                {
                    SAFERELEASE( pINTCons );
                    dwFlag = 1;
                } // If Service Succeeded

            }
            SAFERELEASE( pINTEConsumer );
        }

        if( dwFlag == 1 )
        {
            return ERROR_TRIGNAME_ALREADY_EXIST_EX;
        }
        else
        {
            return WBEM_S_NO_ERROR;
        }
    }
    catch(_com_error& e)
    {
		SAFERELEASE( pINTEConsumer );
        return e.Error();
    }
    catch( CHeap_Exception  )
    {
        SAFERELEASE( pINTEConsumer );
        return E_OUTOFMEMORY;
    }
}

HRESULT
CTriggerProvider::SetUserContext(
    IN VARIANT varRUser,
    IN VARIANT varRPwd,
    IN VARIANT varTAction,
    IN CHString &szscheduler
    )
/*++
Routine Description:
    This routine creates task scheduler.

Arguments:
    [IN] varRUser    : User name.
    [IN] varRPwd     : Password.
    [IN] varTAction  : TriggerAction.
    [IN] szscheduler : Task scheduler name.

Return Value:
    Returns HRESULT value.
--*/
{
    HRESULT hRes = 0;
    ITaskScheduler *pITaskScheduler = NULL;
    ITaskTrigger *pITaskTrig = NULL;
    ITask *pITask = NULL;
    IPersistFile *pIPF = NULL;
    try
    {
        CHString     strTemp = L"";
        CHString     strTemp1 = L"";

        SYSTEMTIME systime = {0,0,0,0,0,0,0,0};
        WORD  wTrigNumber = 0;
        WCHAR wszCommand[ MAX_STRING_LENGTH ] = L"";
        WCHAR wszApplName[ MAX_STRING_LENGTH ] = L"";
        WCHAR wszParams[ MAX_STRING_LENGTH ] = L"";
        WORD  wStartDay     = 0;
        WORD  wStartMonth   = 0;
        WORD  wStartYear    = 0;
        WORD  wStartHour    = 0; 
        WORD  wStartMin     = 0;

        TASK_TRIGGER TaskTrig;
        SecureZeroMemory( &TaskTrig, sizeof( TASK_TRIGGER ));
        TaskTrig.cbTriggerSize = sizeof(TASK_TRIGGER); 
        TaskTrig.Reserved1 = 0; // reserved field and must be set to 0.
        TaskTrig.Reserved2 = 0; // reserved field and must be set to 0.

        strTemp = (LPCWSTR) _bstr_t(varTAction.bstrVal);
        StringCopy( wszCommand, (LPCWSTR) strTemp, SIZE_OF_ARRAY( wszCommand ) );

        hRes = GetTaskScheduler( &pITaskScheduler );
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pITaskScheduler );
            return hRes;
        }
        hRes = pITaskScheduler->SetTargetComputer( NULL );
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pITaskScheduler );
            return hRes;
        }

        hRes = pITaskScheduler->NewWorkItem( szscheduler, CLSID_CTask, IID_ITask,
                                          ( IUnknown** )&pITask );
        SAFERELEASE( pITaskScheduler );
        if( FAILED( hRes ) )
        {
            return hRes;
        }
        hRes = pITask->QueryInterface( IID_IPersistFile, ( void ** ) &pIPF );
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            return hRes;
        }
        
        BOOL bRet = ProcessFilePath( wszCommand, wszApplName, wszParams );
        if( bRet == FALSE )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            return WBEM_E_INVALID_PARAMETER;
        }
        if( FindOneOf2( wszApplName, L"|<>?*/", TRUE, 0 ) != -1 )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            return WBEM_E_INVALID_PARAMETER;
        }

        hRes = pITask->SetApplicationName( wszApplName );
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            return hRes;
        }

        wchar_t* wcszStartIn = wcsrchr( wszApplName, _T('\\') );

        if( wcszStartIn != NULL )
        {
        *( wcszStartIn ) = _T( '\0' );
        }

        hRes = pITask->SetWorkingDirectory( wszApplName ); 
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            return hRes;
        }

        hRes = pITask->SetParameters( wszParams );
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            return hRes;
        }

        DWORD dwMaxRunTimeMS = INFINITE;
        hRes = pITask->SetMaxRunTime(dwMaxRunTimeMS);
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            return hRes;
        }

        strTemp = (LPCWSTR)_bstr_t(varRUser.bstrVal);
        if( strTemp.CompareNoCase(L"system") == 0 )
        {
            hRes = pITask->SetAccountInformation(L"",NULL);
        }
        else if( strTemp.CompareNoCase(L"NT AUTHORITY\\SYSTEM") == 0 )
        {
            hRes = pITask->SetAccountInformation(L"",NULL);
        }
        else if( strTemp.CompareNoCase(L"") == 0 )
        {
            hRes = pITask->SetAccountInformation(L"",NULL);
        }
        else
        {
            strTemp1 = (LPCWSTR)_bstr_t(varRPwd.bstrVal);
            hRes = pITask->SetAccountInformation( ( LPCWSTR ) strTemp, ( LPCWSTR )strTemp1 );
        }
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            return hRes;
        }
        GetLocalTime(&systime);
        wStartDay = systime.wDay;
        wStartMonth = systime.wMonth;
        wStartYear = systime.wYear - 1;
        GetLocalTime(&systime);
        wStartHour = systime.wHour;
        wStartMin = systime.wMinute;

        hRes = pITask->CreateTrigger( &wTrigNumber, &pITaskTrig );
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            SAFERELEASE( pITaskTrig );
            return hRes;
        }
        TaskTrig.TriggerType = TASK_TIME_TRIGGER_ONCE;
        TaskTrig.wStartHour = wStartHour;
        TaskTrig.wStartMinute = wStartMin;
        TaskTrig.wBeginDay = wStartDay;
        TaskTrig.wBeginMonth = wStartMonth;
        TaskTrig.wBeginYear = wStartYear;

        hRes = pITaskTrig->SetTrigger( &TaskTrig ); 
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pIPF );
            SAFERELEASE( pITask );
            SAFERELEASE( pITaskTrig );
            return hRes;
        }
        hRes  = pIPF->Save( NULL,TRUE );
        if ( FAILED( hRes ) )
        {
             if ( ( 0x80041315 != hRes ) && ( 0x800706B5 != hRes ) )
            {
                hRes = ERROR_INVALID_USER_EX;
            }
        }
        SAFERELEASE( pIPF );
        SAFERELEASE( pITask );
        SAFERELEASE( pITaskTrig );
    }
    catch(_com_error& e)
    {
        SAFERELEASE( pIPF );
        SAFERELEASE( pITask );
        SAFERELEASE( pITaskTrig );
		SAFERELEASE( pITaskScheduler );
        return e.Error();
    }
    catch( CHeap_Exception )
    {
        SAFERELEASE( pIPF );
        SAFERELEASE( pITask );
        SAFERELEASE( pITaskTrig );
		SAFERELEASE( pITaskScheduler );
        return E_OUTOFMEMORY;
    }
    return hRes;
}

HRESULT
CTriggerProvider::DeleteTaskScheduler(
    IN CHString strTScheduler
    )
/*++
Routine Description:
    This routine deletes task scheduler.

Arguments:
    [IN] szTScheduler : Task Scheduler name.

Return Value:
     Returns HRESULT value.
--*/
{
    HRESULT hRes = 0;
    ITaskScheduler *pITaskScheduler = NULL;
    IEnumWorkItems *pIEnum = NULL;
    ITask *pITask = NULL;
    LPWSTR *lpwszNames = NULL;
    DWORD dwFetchedTasks = 0;
    DWORD dwTaskIndex = 0;
    TCHAR szActualTask[MAX_RES_STRING1] = NULL_STRING;

    try
    {
        hRes = GetTaskScheduler( &pITaskScheduler );
        if ( FAILED( hRes ) )
        {
            SAFERELEASE( pITaskScheduler );
            return hRes;
        }
        hRes = pITaskScheduler->SetTargetComputer( NULL );
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pITaskScheduler );
            return hRes;
        }

        // Enumerate the Work Items
        hRes = pITaskScheduler->Enum( &pIEnum );
        if( FAILED( hRes ) )
        {
            SAFERELEASE( pITaskScheduler );
            SAFERELEASE( pIEnum );
            return hRes;
        }

        while ( SUCCEEDED( pIEnum->Next( 1,
                           &lpwszNames,
                           &dwFetchedTasks ) )
                           && (dwFetchedTasks != 0))
        {
            dwTaskIndex = dwFetchedTasks-1;
            // Get the TaskName.
            StringCopy( szActualTask, lpwszNames[ --dwFetchedTasks ], SIZE_OF_ARRAY( szActualTask ) );
            // Parse the TaskName to remove the .job extension.
            szActualTask[StringLength(szActualTask, 0 ) - StringLength( JOB, 0 ) ] = NULL_CHAR;
            StrTrim( szActualTask, TRIM_SPACES );

            if( StringCompare( szActualTask, strTScheduler, TRUE, 0 ) == 0 )
            {
                hRes = pITaskScheduler->Activate(lpwszNames[dwTaskIndex],IID_ITask,
                                           (IUnknown**) &pITask);
                if( FAILED( hRes ) )
                {
                    CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );
                    SAFERELEASE( pIEnum );
                    SAFERELEASE( pITaskScheduler );
                     if ( 0x80070005 == hRes || 0x8007000D ==  hRes || 
                            SCHED_E_UNKNOWN_OBJECT_VERSION == hRes || E_INVALIDARG == hRes )
                     {
                        return ERROR_TRIGGER_NOT_DELETED_EX;
                     }
                     else
                     {
                        return hRes;
                     }
                }
                hRes = pITaskScheduler->Delete( szActualTask );
                CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );
                SAFERELEASE( pIEnum );
                SAFERELEASE( pITask );
                SAFERELEASE( pITaskScheduler );
                return hRes;
            }
            CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );
        }
    }
    catch(_com_error& e)
    {
        SAFERELEASE( pITaskScheduler );
        SAFERELEASE( pIEnum );
        SAFERELEASE( pITask );
        return e.Error();
    }
    SAFERELEASE( pITaskScheduler );
    return ERROR_TRIGGER_CORRUPTED_EX;
}

HRESULT
CTriggerProvider::GetTaskScheduler( 
    OUT ITaskScheduler   **ppITaskScheduler
    )
/*++
Routine Description:
    This routine gets task scheduler interface.

Arguments:
    [OUT] pITaskScheduler   - Pointer to ITaskScheduler object.

Return Value:
    Returns HRESULT.
--*/
{
    HRESULT hRes = S_OK;

    hRes = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_ALL, 
                           IID_ITaskScheduler,(LPVOID*) ppITaskScheduler );
    if( FAILED(hRes))
    {
        return hRes;
    }
    return hRes;
}

VOID
CTriggerProvider::GetUniqueTScheduler(
    OUT CHString& szScheduler,
    IN DWORD dwTrigID,
    IN VARIANT varTrigName
    )
/*++
Routine Description:
    This routine generates unique task scheduler name.

Arguments:
    [OUT] szScheduler : Unique task scheduler name.
    [IN] dwTrigID     : Trigger id.
    [IN] varTrigName  : Trigger name.

Return Value:
    none.
--*/
{
    DWORD dwTickCount = 0;
    TCHAR szTaskName[ MAX_RES_STRING1 ] =  NULL_STRING;
    CHString strTemp = L"";

    strTemp = (LPCWSTR)_bstr_t(varTrigName.bstrVal);
    dwTickCount = GetTickCount();
    StringCchPrintf( szTaskName, SIZE_OF_ARRAY( szTaskName ), UNIQUE_TASK_NAME, ( LPCWSTR )strTemp, dwTrigID, dwTickCount );

    szScheduler = szTaskName;
}

STDMETHODIMP
CTriggerProvider::FindConsumer(
    IN IWbemClassObject* pLogicalConsumer,
    OUT IWbemUnboundObjectSink** ppConsumer
    )
/*++
Routine Description:
    When Windows Management needs to deliver events to a
    particular logical consumer, it will call the
    IWbemEventConsumerProvider::FindConsumer method so that
    the consumer provider can locate the associated consumer event sink.

Arguments:
    [IN] pLogicalConsumer : Pointer to the logical consumer object
                            to which the event objects are to be  delivered. 
    [OUT] ppConsumer      : Returns an event object sink to Windows 
                            Management. Windows Management calls
                            AddRef for this pointer and deliver the
                            events associated with the logical
                            consumer to this sink.

Return Value:
    returns an HRESULT object that indicates the status of the method call.
--*/
{
    // create the logical consumer.
    CTriggerConsumer* pSink = new CTriggerConsumer();
    
    // return it's "sink" interface.
    return pSink->QueryInterface( IID_IWbemUnboundObjectSink, ( LPVOID* ) ppConsumer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\diamond.c ===
/*++

Module Name:

    diamond.c

Abstract:

    Diamond compression interface.

    This module contains functions to compress a file using
    the mszip compression library.

Author:

    Ted Miller

Environment:

    Windows

--*/





#include <io.h>
#include <fcntl.h>
#include <errno.h>

//#include "main.h"
//#include <diamondc.h>
//#include "mydiam.h"


#include "pch.h"

CHAR MakeCompressedName( LPSTR );

typedef struct _DIAMOND_INFO {
    DWORD SourceFileSize;
    DWORD CompressedSize;
    FILETIME SourceFileCreationTime;
    FILETIME SourceFileModifiedTime;
    FILETIME SourceFileAccessedTime;
} DIAMOND_INFO, *PDIAMOND_INFO;

//
// Callback functions to perform memory allocation, io, etc.
// We pass addresses of these functions to diamond.
//
int
DIAMONDAPI
fciFilePlacedCB(
    OUT PCCAB Cabinet,
    IN  LPSTR  FileName,
    IN  LONG  FileSize,
    IN  BOOL  Continuation,
    IN  PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to indicate that a file has been
    comitted to a cabinet.

    No action is taken and success is returned.

Arguments:

    Cabinet - cabinet structure to fill in.

    FileName - name of file in cabinet

    FileSize - size of file in cabinet

    Continuation - TRUE if this is a partial file, continuation
        of compression begun in a different cabinet.

    Context - supplies context information.

Return Value:

    0 (success).

--*/

{
    UNREFERENCED_PARAMETER(Cabinet);
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(FileSize);
    UNREFERENCED_PARAMETER(Continuation);
    UNREFERENCED_PARAMETER(Context);

    return(0);
}



PVOID
DIAMONDAPI
fciAllocCB(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by diamond to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return((PVOID)LocalAlloc(LMEM_FIXED,NumberOfBytes));
}


VOID
DIAMONDAPI
fciFreeCB(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by diamond to free a memory block.
    The block must have been allocated with fciAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    LocalFree((HLOCAL)Block);
}



FNFCIGETTEMPFILE(fciTempFileCB)
{
    CHAR TempPath[MAX_PATH];
    DWORD cchTemp;

    cchTemp = GetTempPathA(sizeof(TempPath),TempPath);
    if ((cchTemp == 0) || (cchTemp >= sizeof(TempPath))) {
        TempPath[0] = '.';
        TempPath[1] = '\0';
    }


    if(GetTempFileNameA(TempPath,"dc",0,pszTempName)) {
        DeleteFileA(pszTempName);
    }

    return(TRUE);
}


BOOL
DIAMONDAPI
fciNextCabinetCB(
    OUT PCCAB Cabinet,
    IN  DWORD CabinetSizeEstimate,
    IN  PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to request a new cabinet file.
    This functionality is not used in our implementation as
    we deal only with single-file cabinets.

Arguments:

    Cabinet - cabinet structure to be filled in.

    CabinetSizeEstimate - estimated size of cabinet.

    Context - supplies context information.

Return Value:

    FALSE (failure).

--*/

{
    UNREFERENCED_PARAMETER(Cabinet);
    UNREFERENCED_PARAMETER(CabinetSizeEstimate);
    UNREFERENCED_PARAMETER(Context);

    return(FALSE);
}


BOOL
DIAMONDAPI
fciStatusCB(
    IN UINT  StatusType,
    IN DWORD Count1,
    IN DWORD Count2,
    IN PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to give status on file compression
    and cabinet operations, etc.

Arguments:

    Status Type - supplies status type.

        0 = statusFile   - compressing block into a folder.
                              Count1 = compressed size
                              Count2 = uncompressed size

        1 = statusFolder - performing AddFilder.
                              Count1 = bytes done
                              Count2 = total bytes

    Context - supplies context info.

Return Value:

    TRUE (success).

--*/

{
    PDIAMOND_INFO context;

    UNREFERENCED_PARAMETER(Count2);

    context = (PDIAMOND_INFO)Context;

    if(StatusType == statusFile) {

        //
        // Track compressed size.
        //
        context->CompressedSize += Count1;
    }

    return(TRUE);
}



FNFCIGETOPENINFO(fciOpenInfoCB)
{
    int h;
    WIN32_FIND_DATAA FindData;
    HANDLE FindHandle;
    PDIAMOND_INFO context;
    FILETIME ftLocal;

    context = pv;

    FindHandle = FindFirstFileA(pszName,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        return(-1);
    }
    FindClose(FindHandle);

    context->SourceFileSize = FindData.nFileSizeLow;
    context->SourceFileCreationTime = FindData.ftCreationTime;
    context->SourceFileModifiedTime = FindData.ftLastWriteTime;
    context->SourceFileAccessedTime = FindData.ftLastAccessTime;

    FileTimeToLocalFileTime(&FindData.ftLastWriteTime, &ftLocal);
    FileTimeToDosDateTime(&ftLocal, pdate, ptime);
    *pattribs = (WORD)(FindData.dwFileAttributes &
            ( FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN |
              FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE ));

    h = _open(pszName,_O_RDONLY | _O_BINARY);
    if(h == -1) {
        return(-1);
    }

    return(h);
}


FNFCIOPEN(fciOpen)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

FNFCIREAD(fciRead)
{
    UINT result;

    result = (UINT) _read((HFILE)hf, memory, cb);

    if (result != cb) {
        *err = errno;
    }

    return(result);
}

FNFCIWRITE(fciWrite)
{
    UINT result;

    result = (UINT) _write((HFILE)hf, memory, cb);

    if (result != cb) {
        *err = errno;
    }

    return(result);
}

FNFCICLOSE(fciClose)
{
    int result;

    result = _close((HFILE)hf);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

FNFCISEEK(fciSeek)
{
    long result;

    result = _lseek((HFILE)hf, dist, seektype);

    if (result == -1) {
        *err = errno;
    }

    return(result);

}

FNFCIDELETE(fciDelete)
{
    int result;

    result = _unlink(pszFile);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}


INT
DiamondCompressFile(
    IN  NOTIFYPROC CompressNotify,
    IN  LPSTR       SourceFile,
    IN  LPSTR       TargetFile,
    IN  BOOL       Rename,
    OUT PLZINFO    pLZI
    )
{
    BOOL b;
    LPSTR SourceFilenamePart,p;
    HFCI FciContext;
    ERF  FciError;
    CCAB ccab;
    CHAR targetFile[MAX_PATH];
    WCHAR wszSourceFile[MAX_PATH]   =   NULL_STRING;
    WCHAR wszTargetFile[MAX_PATH]   =   NULL_STRING;
    DIAMOND_INFO Context;
    INT Status;

    __try {

        //
        // Isolate the filename part of the source file.
        //
        if(SourceFilenamePart = strrchr(SourceFile, '\\')) {
            SourceFilenamePart++;
        } else {
            SourceFilenamePart = SourceFile;
        }

        //
        // Form the actual name of the target file.
        //
        strcpy(targetFile,TargetFile);
        if(Rename) {
            MakeCompressedName(targetFile);
        }

        //
        // Fill in the cabinet structure.
        //
        ZeroMemory(&ccab,sizeof(ccab));

        lstrcpyA(ccab.szCabPath, targetFile);
        if(p=strrchr(ccab.szCabPath,'\\')) {
            lstrcpyA(ccab.szCab,++p);
            *p = 0;
        } else {
            lstrcpyA(ccab.szCab,targetFile);
            ccab.szCabPath[0] = 0;
        }

        //
        // Call the notification function to see whether we are really
        // supposed to compress this file.
        //
        MultiByteToWideChar( CP_THREAD_ACP, 0, SourceFile, strlen(SourceFile), wszSourceFile, MAX_PATH );
        MultiByteToWideChar( CP_THREAD_ACP, 0, targetFile, strlen(targetFile), wszTargetFile, MAX_PATH );
        if(!CompressNotify(wszSourceFile,wszTargetFile,NOTIFY_START_COMPRESS)) {
            Status = BLANK_ERROR;
            __leave;
        }

        ZeroMemory(&Context,sizeof(Context));

        //
        // Compress the file.
        //
        FciContext = FCICreate(
                        &FciError,
                        fciFilePlacedCB,
                        fciAllocCB,
                        fciFreeCB,
                        fciOpen,
                        fciRead,
                        fciWrite,
                        fciClose,
                        fciSeek,
                        fciDelete,
                        fciTempFileCB,
                        &ccab,
                        &Context
                        );

        if(FciContext) {

            b = FCIAddFile(
                    FciContext,
                    SourceFile,         // file to add to cabinet.
                    SourceFilenamePart, // filename part, name to store in cabinet.
                    FALSE,
                    fciNextCabinetCB,   // routine for next cabinet (always fails)
                    fciStatusCB,
                    fciOpenInfoCB,
                    DiamondCompressionType
                    );

            if(b) {

                b = FCIFlushCabinet(
                        FciContext,
                        FALSE,
                        fciNextCabinetCB,
                        fciStatusCB
                        );

                if(b) {

                    HANDLE FindHandle;
                    WIN32_FIND_DATA FindData;

                    //
                    // Context.CompressedSize does not include headers
                    // and any other file overhead.
                    //
                    FindHandle = FindFirstFile((LPCWSTR)targetFile,&FindData);
                    if(FindHandle == INVALID_HANDLE_VALUE) {
                        pLZI->cblOutSize = (LONG)Context.CompressedSize;
                    } else {
                        pLZI->cblOutSize = (LONG)FindData.nFileSizeLow;
                        FindClose(FindHandle);
                    }

                    pLZI->cblInSize = (LONG)Context.SourceFileSize;

                    FindHandle = CreateFile((LPWSTR)targetFile,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
                    if (FindHandle != INVALID_HANDLE_VALUE)
                    {
                        SetFileTime(FindHandle,
                            &Context.SourceFileCreationTime,
                            &Context.SourceFileAccessedTime,
                            &Context.SourceFileModifiedTime);

                        CloseHandle(FindHandle);
                    }
                }
            }

            if(b) {
                Status = TRUE;
            } else {

                switch(FciError.erfOper) {

                case FCIERR_OPEN_SRC:
                    Status = LZERROR_BADINHANDLE;
                    break;

                case FCIERR_READ_SRC:
                    Status = LZERROR_READ;
                    break;

                case FCIERR_CAB_FILE:
                    Status = LZERROR_WRITE;
                    break;

                case FCIERR_ALLOC_FAIL:
                    Status = LZERROR_GLOBALLOC;
                    break;

                case FCIERR_TEMP_FILE:
                case FCIERR_BAD_COMPR_TYPE:
                case FCIERR_USER_ABORT:
                case FCIERR_MCI_FAIL:
                default:
                    Status = FALSE;
                }
            }

            FCIDestroy(FciContext);
        } else {
            Status = LZERROR_GLOBALLOC;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
          Status = GetLastError();
    }


    return(Status);
}


CHAR MakeCompressedName(CHAR ARG_PTR *pszFileName)
{
    CHAR chReplaced = '\0';

    ULONG NameLength = strlen( pszFileName );
    ULONG DotIndex   = NameLength;

    while (( DotIndex > 0 ) && ( pszFileName[ --DotIndex ] != '.' )) {
        if (( pszFileName[ DotIndex ] == '\\' ) ||
            ( pszFileName[ DotIndex ] == ':' )) {   // end of filename part of path
            DotIndex = 0;                       // name has no extension
            break;
            }
        }

    if ( DotIndex > 0 ) {                       // name has an extension
        if (( NameLength - DotIndex ) <= 3 ) {  // extension less than 3 chars
            pszFileName[ NameLength++ ] = '_';  // append '_' to extension
            pszFileName[ NameLength ] = 0;      // terminate
            }
        else {                                  // extension more than 3 chars
            chReplaced = pszFileName[ NameLength - 1 ]; // return original
            pszFileName[ NameLength - 1 ] = '_';   // replace last char with '_'
            }
        }
    else {                                      // name has no extension
        pszFileName[ NameLength++ ] = '.';      // append '.'
        pszFileName[ NameLength++ ] = '_';      // append '_'
        pszFileName[ NameLength ] = 0;          // terminate
        }

    return(chReplaced);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\lzcommon.c ===
/*
** lzcommon.c - Routines common to LZ compression / expansion.
**
** Author:  DavidDi
*/


// Headers
///////////

#include "pch.h"

/*
** bool LZInitTree(void);
**
** Initializes trees used in LZ compression.
**
** Arguments:  none
**
** Returns:    true/false
**
** Globals:    RightChild[] and Parent[] arrays reset to NIL to begin
**             encoding.
*/
BOOL LZInitTree(PLZINFO pLZI)
{
   INT i;

   /*
   ** For i = 0 to RING_BUF_LEN - 1, rightChild[i] and leftChild[i] will be the
   ** right and left children of node i.  These nodes need not be initialized.
   ** Also, parent[i] is the parent of node i.  These are initialized to
   ** NIL (= N), which stands for 'not used.'
   ** For i = 0 to 255, rightChild[RING_BUF_LEN + i + 1] is the root of the tree
   ** for strings that begin with character i.  These are initialized to NIL.
   ** n.b., there are 256 trees.
   */

   if (!pLZI->rightChild) {
      if (!(pLZI->rightChild = (INT*)LocalAlloc(LPTR, (RING_BUF_LEN + 257) * sizeof(INT)))) {
         return(FALSE);
      }
   }

   if (!pLZI->leftChild) {
      if (!(pLZI->leftChild = (INT*)LocalAlloc(LPTR, (RING_BUF_LEN + 1) * sizeof(INT)))) {
         return(FALSE);
      }
   }

   if (!pLZI->parent) {
      if (!(pLZI->parent = (INT*)LocalAlloc(LPTR, (RING_BUF_LEN + 1) * sizeof(INT)))) {
         return(FALSE);
      }
   }

   for (i = RING_BUF_LEN + 1; i <= RING_BUF_LEN + 256; i++)
      pLZI->rightChild[i] = NIL;

   for (i = 0; i < RING_BUF_LEN; i++)
      pLZI->parent[i] = NIL;

   return(TRUE);
}

VOID
LZFreeTree(PLZINFO pLZI)
{
   // Sanity check
   if (!pLZI) {
      return;
   }

   if (pLZI->rightChild) {
      LocalFree((HLOCAL)pLZI->rightChild);
      pLZI->rightChild = NULL;
   }

   if (pLZI->leftChild) {
      LocalFree((HLOCAL)pLZI->leftChild);
      pLZI->leftChild = NULL;
   }

   if (pLZI->parent) {
      LocalFree((HLOCAL)pLZI->parent);
      pLZI->parent = NULL;
   }
}

/*
** void LZInsertNode(int nodeToInsert, BOOL bDoArithmeticInsert);
**
** Inserts a new tree into the forest.  Inserts string of length
** cbMaxMatchLen, rgbyteRingBuf[r..r + cbMaxMatchLen - 1], into one of the trees
** (rgbyteRingBuf[r]'th tree).
**
** Arguments:  nodeToInsert        - start of string in ring buffer to insert
**                                   (also, associated tree root)
**             bDoArithmeticInsert - flag for performing regular LZ node
**                                   insertion or arithmetic encoding node
**                                   insertion
**
** Returns:    void
**
** Globals:    cbCurMatch - set to length of longest match
**             iCurMatch  - set to start index of longest matching string in
**                          ring buffer
**
** N.b., if cbCurMatch == cbMaxMatchLen, we remove the old node in favor of
** the new one, since the old node will be deleted sooner.
*/
VOID LZInsertNode(INT nodeToInsert, BOOL bDoArithmeticInsert, PLZINFO pLZI)
{
   INT  i, p, cmp, temp;
   BYTE FAR *key;

   // Sanity check
   if (!pLZI) {
      return;
   }

   cmp = 1;

   key = pLZI->rgbyteRingBuf + nodeToInsert;
   p = RING_BUF_LEN + 1 + key[0];

   pLZI->rightChild[nodeToInsert] = pLZI->leftChild[nodeToInsert] = NIL;
   pLZI->cbCurMatch = 0;

   FOREVER
   {
      if (cmp >= 0)
      {
         if (pLZI->rightChild[p] != NIL)
            p = pLZI->rightChild[p];
         else
         {
            pLZI->rightChild[p] = nodeToInsert;
            pLZI->parent[nodeToInsert] = p;
            return;
         }
      }
      else
      {
         if (pLZI->leftChild[p] != NIL)
            p = pLZI->leftChild[p];
         else
         {
            pLZI->leftChild[p] = nodeToInsert;
            pLZI->parent[nodeToInsert] = p;
            return;
         }
      }

      for (i = 1; i < pLZI->cbMaxMatchLen; i++)
         if ((cmp = key[i] - pLZI->rgbyteRingBuf[p + i]) != 0)
            break;

      if (bDoArithmeticInsert == TRUE)
      {
         // Do node insertion for arithmetic encoding.
         if (i > MAX_LITERAL_LEN)
         {
            if (i > pLZI->cbCurMatch)
            {
               pLZI->iCurMatch = (nodeToInsert - p) & (RING_BUF_LEN - 1);
               if ((pLZI->cbCurMatch = i) >= pLZI->cbMaxMatchLen)
                  break;
            }
            else if (i == pLZI->cbCurMatch)
            {
               if ((temp = (nodeToInsert - p) & (RING_BUF_LEN - 1)) < pLZI->iCurMatch)
                  pLZI->iCurMatch = temp;
            }
         }
      }
      else
      {
         // Do node insertion for LZ.
         if (i > pLZI->cbCurMatch)
         {
            pLZI->iCurMatch = p;
            if ((pLZI->cbCurMatch = i) >= pLZI->cbMaxMatchLen)
               break;
         }
      }
   }

   pLZI->parent[nodeToInsert] = pLZI->parent[p];
   pLZI->leftChild[nodeToInsert] = pLZI->leftChild[p];
   pLZI->rightChild[nodeToInsert] = pLZI->rightChild[p];

   pLZI->parent[pLZI->leftChild[p]] = nodeToInsert;
   pLZI->parent[pLZI->rightChild[p]] = nodeToInsert;

   if (pLZI->rightChild[pLZI->parent[p]] == p)
      pLZI->rightChild[pLZI->parent[p]] = nodeToInsert;
   else
      pLZI->leftChild[pLZI->parent[p]] = nodeToInsert;

   // Remove p.
   pLZI->parent[p] = NIL;

   return;
}


/*
** void LZDeleteNode(int nodeToDelete);
**
** Delete a tree from the forest.
**
** Arguments:  nodeToDelete - tree to delete from forest
**
** Returns:    void
**
** Globals:    Parent[], RightChild[], and LeftChild[] updated to reflect the
**             deletion of nodeToDelete.
*/
VOID LZDeleteNode(INT nodeToDelete, PLZINFO pLZI)
{
   INT  q;

   // Sanity check
   if (!pLZI) {
      return;
   }

   if (pLZI->parent[nodeToDelete] == NIL)
      // Tree nodeToDelete is not in the forest.
      return;

   if (pLZI->rightChild[nodeToDelete] == NIL)
      q = pLZI->leftChild[nodeToDelete];
   else if (pLZI->leftChild[nodeToDelete] == NIL)
      q = pLZI->rightChild[nodeToDelete];
   else
   {
      q = pLZI->leftChild[nodeToDelete];
      if (pLZI->rightChild[q] != NIL)
      {
         do
         {
            q = pLZI->rightChild[q];
         } while (pLZI->rightChild[q] != NIL);

         pLZI->rightChild[pLZI->parent[q]] = pLZI->leftChild[q];
         pLZI->parent[pLZI->leftChild[q]] = pLZI->parent[q];
         pLZI->leftChild[q] = pLZI->leftChild[nodeToDelete];
         pLZI->parent[pLZI->leftChild[nodeToDelete]] = q;
      }
      pLZI->rightChild[q] = pLZI->rightChild[nodeToDelete];
      pLZI->parent[pLZI->rightChild[nodeToDelete]] = q;
   }
   pLZI->parent[q] = pLZI->parent[nodeToDelete];

   if (pLZI->rightChild[pLZI->parent[nodeToDelete]] == nodeToDelete)
      pLZI->rightChild[pLZI->parent[nodeToDelete]] = q;
   else
      pLZI->leftChild[pLZI->parent[nodeToDelete]] = q;

   // Remove nodeToDelete.
   pLZI->parent[nodeToDelete] = NIL;

   return;
}

//these are additional functions required by both diamond.c and compress.c

WCHAR
MakeCompressedNameW(
    LPWSTR pszFileName)
/*++
    Routine Description: Returns the last character that is stripped out and also
                         changes the pszFilename

--*/
{
   WCHAR chReplaced = L'\0';
   WCHAR ARG_PTR *pszExt;

   if ((pszExt = ExtractExtensionW(pszFileName)) != NULL)
   {
      if (lstrlenW(pszExt) >= 3)
      {
         chReplaced = pszExt[lstrlenW(pszExt) - 1];
         pszExt[lstrlenW(pszExt) - 1] = chEXTENSION_CHARW;
      }
      else
         lstrcatW(pszExt, pszEXTENSION_STRW);
   }
   else
      lstrcatW(pszFileName, pszNULL_EXTENSIONW);

   return(chReplaced);
}

LPWSTR
ExtractExtensionW(
    LPWSTR pszFileName)
/*
   char ARG_PTR *ExtractExtension(char ARG_PTR *pszFileName);

   Find the extension of a file name.

   Arguments:  pszFileName - file name to examine

   Returns:    char ARG_PTR * - Pointer to file name extension if one exists.
                              NULL if the file name doesn't include an
                                extension.
*/

{
   WCHAR *psz;

   // Make sure we have an isolated file name.
   psz = ExtractFileNameW(pszFileName);

   while (*psz != L'\0' && *psz != L'.')
      psz++;

   if (*psz == L'.')
      return(psz + 1);
   else
      return(NULL);
}


LPWSTR
ExtractFileNameW(
    LPWSTR pszPathName)
/*++
 Find the file name in a fully specified path name.

 Arguments:  pszPathName - path string from which to extract file name

 Returns:    char ARG_PTR * - Pointer to file name in pszPathName.

 Globals:    none
--*/
{
   LPWSTR pszLastComponent, psz;

   for (pszLastComponent = psz = pszPathName; *psz != L'\0'; psz++)
   {
      if (*psz == L'\\' || *psz == L':')
         pszLastComponent = psz + 1;
   }

   return(pszLastComponent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\lzcommon.h ===
/*
** lzcommon.h - Shared information for LZ modules.
**
** Author:  DavidDi
*/

//global variable
BYTE   byteAlgorithm;

// Constants
/////////////

#define RING_BUF_LEN       4096        // size of ring buffer
#define MAX_RING_BUF_LEN   4224        // size of ring buffer - from LZFile
                                       // struct declaration in lzexpand.h

#define NIL                RING_BUF_LEN   // flag index used in binary search
                                          // trees

#define BUF_CLEAR_BYTE     ((BYTE) ' ')   // rgbyteRingBuf[] initializer

#define MAX_LITERAL_LEN    2           // encode string into position and
                                       // length if match length greater than
                                       // this value (== # of bytes required
                                       // to encode position and length)

#define FIRST_MAX_MATCH_LEN   0x10     // ALG_FIRST used this length
#define LZ_MAX_MATCH_LEN      (0x10 + MAX_LITERAL_LEN)
#define LZA_MAX_MATCH_LEN     64
                                       // upper limit for match length
                                       // (n.b., assume length field implies
                                       // length += 3)

// Maximum number of bytes LZDecode() and LZADecode() will expand beyond
// position requested.
#define MAX_OVERRUN        ((long)pLZI->cbMaxMatchLen)


// Globals
///////////

extern INT iCurMatch,      // index of longest match (set by LZInsertNode())
           cbCurMatch;     // length of longest match (set by LZInsertNode())

extern DWORD uFlags;    // LZ decoding description byte

extern INT iCurRingBufPos; // ring buffer offset

// Prototypes
//////////////

// lzcommon.c
extern BOOL LZInitTree(PLZINFO pLZI);
extern VOID LZFreeTree(PLZINFO pLZI);
extern VOID LZInsertNode(INT nodeToInsert, BOOL bDoArithmeticInsert, PLZINFO pLZI);
extern VOID LZDeleteNode(INT nodeToDelete, PLZINFO pLZI);

// lzcomp.c
extern INT LZEncode(HANDLE doshSource, HANDLE doshDest, PLZINFO pLZI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\lzcomp.c ===
/*
** lzcomp.c - Routines used in Lempel-Ziv compression (a la 1977 article).
**
** Author:  DavidDi
*/


// Headers
///////////

#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"
#include "lzcommon.h"


/*
** int LZEncode(int doshSource, int doshDest);
**
** Compress input file into output file.
**
** Arguments:  doshSource    - open DOS file handle of input file
**             doshDest      - open DOS file handle of output file
**
** Returns:    int - TRUE if compression was successful.  One of the LZERROR_
**                   codes if the compression failed.
**
** Globals:
*/
INT LZEncode(INT doshSource, INT doshDest, PLZINFO pLZI)
{
   INT   i, len, f,
         iCurChar,      // current ring buffer position
         iCurString,    // start of current string in ring buffer
         iCodeBuf,      // index of next open buffer position
         cbLastMatch;   // length of last match
   BYTE byte,           // temporary storage for next byte to write
        byteMask,       // bit mask (and counter) for eight code units
        codeBuf[1 + 8 * MAX_LITERAL_LEN]; // temporary storage for encoded data

#if 0
   pLZI->cbMaxMatchLen = LZ_MAX_MATCH_LEN;
#else
   pLZI->cbMaxMatchLen = FIRST_MAX_MATCH_LEN;
#endif

   ResetBuffers();

   pLZI->cblOutSize += HEADER_LEN;

   // Initialize encoding trees.
   if (!LZInitTree(pLZI)) {
      return( LZERROR_GLOBALLOC );
   }

   // CodeBuf[1..16] saves eight units of code, and CodeBuf[0] works as eight
   // flags.  '1' representing that the unit is an unencoded letter (1 byte),
   // '0' a position-and-length pair (2 bytes).  Thus, eight units require at
   // most 16 bytes of code, plus the one byte of flags.
   codeBuf[0] = (BYTE)0;
   byteMask = (BYTE)1;
   iCodeBuf = 1;

   iCurString = 0;
   iCurChar = RING_BUF_LEN - pLZI->cbMaxMatchLen;

   for (i = 0; i < RING_BUF_LEN - pLZI->cbMaxMatchLen; i++)
      pLZI->rgbyteRingBuf[i] = BUF_CLEAR_BYTE;

   // Read bytes into the last cbMaxMatchLen bytes of the buffer.
   for (len = 0; len < pLZI->cbMaxMatchLen && ((f = ReadByte(byte)) != END_OF_INPUT);
        len++)
   {
      if (f != TRUE) {
         return( f );
      }

      pLZI->rgbyteRingBuf[iCurChar + len] = byte;
   }

   // Insert the cbMaxMatchLen strings, each of which begins with one or more
   // 'space' characters.  Note the order in which these strings are inserted.
   // This way, degenerate trees will be less likely to occur.
   for (i = 1; i <= pLZI->cbMaxMatchLen; i++)
      LZInsertNode(iCurChar - i, FALSE, pLZI);

   // Finally, insert the whole string just read.  The global variables
   // cbCurMatch and iCurMatch are set.
   LZInsertNode(iCurChar, FALSE, pLZI);

   do // while (len > 0)
   {
      // cbCurMatch may be spuriously long near the end of text.
      if (pLZI->cbCurMatch > len)
         pLZI->cbCurMatch = len;

      if (pLZI->cbCurMatch <= MAX_LITERAL_LEN)
      {
         // This match isn't long enough to encode, so copy it directly.
         pLZI->cbCurMatch = 1;
         // Set 'one uncoded byte' bit flag.
         codeBuf[0] |= byteMask;
         // Write literal byte.
         codeBuf[iCodeBuf++] = pLZI->rgbyteRingBuf[iCurChar];
      }
      else
      {
         // This match is long enough to encode.  Send its position and
         // length pair.  N.b., pLZI->cbCurMatch > MAX_LITERAL_LEN.
         codeBuf[iCodeBuf++] = (BYTE)pLZI->iCurMatch;
         codeBuf[iCodeBuf++] = (BYTE)((pLZI->iCurMatch >> 4 & 0xf0) |
                                      (pLZI->cbCurMatch - (MAX_LITERAL_LEN + 1)));
      }

      // Shift mask left one bit.
      if ((byteMask <<= 1) == (BYTE)0)
      {
         // Send at most 8 units of code together.
         for (i = 0; i < iCodeBuf; i++)
            if ((f = WriteByte(codeBuf[i])) != TRUE) {
               return( f );
            }

         // Reset flags and mask.
         codeBuf[0] = (BYTE)0;
         byteMask = (BYTE)1;
         iCodeBuf = 1;
      }

      cbLastMatch = pLZI->cbCurMatch;

      for (i = 0; i < cbLastMatch && ((f = ReadByte(byte)) != END_OF_INPUT);
           i++)
      {
         if (f != TRUE) {
            return( f );
         }

         // Delete old string.
         LZDeleteNode(iCurString, pLZI);
         pLZI->rgbyteRingBuf[iCurString] = byte;

         // If the start position is near the end of buffer, extend the
         // buffer to make string comparison easier.
         if (iCurString < pLZI->cbMaxMatchLen - 1)
            pLZI->rgbyteRingBuf[iCurString + RING_BUF_LEN] = byte;

         // Increment position in ring buffer modulo RING_BUF_LEN.
         iCurString = (iCurString + 1) & (RING_BUF_LEN - 1);
         iCurChar = (iCurChar + 1) & (RING_BUF_LEN - 1);

         // Register the string in rgbyteRingBuf[r..r + cbMaxMatchLen - 1].
         LZInsertNode(iCurChar, FALSE, pLZI);
      }

      while (i++ < cbLastMatch)
      {
         // No need to read after the end of the input, but the buffer may
         // not be empty.
         LZDeleteNode(iCurString, pLZI);
         iCurString = (iCurString + 1) & (RING_BUF_LEN - 1);
         iCurChar = (iCurChar + 1) & (RING_BUF_LEN - 1);
         if (--len)
            LZInsertNode(iCurChar, FALSE, pLZI);
      }
   } while (len > 0);   // until there is no input to process

   if (iCodeBuf > 1)
      // Send remaining code.
      for (i = 0; i < iCodeBuf; i++)
         if ((f = WriteByte(codeBuf[i])) != TRUE) {
            return( f );
         }

   // Flush output buffer to file.
   if ((f = FlushOutputBuffer(doshDest, pLZI)) != TRUE) {
      return( f );
   }

   LZFreeTree(pLZI);
   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\lz_buffers.h ===
/*
** buffers.h - Function prototypes and global variables used to manipulate
** buffers used in I/O and expansion.
**
** Author:  DavidDi
*/


// Constants
/////////////

// N.b., rgbyteInBuf[] allocated with one extra byte for UnreadByte().
#define MAX_IN_BUF_SIZE    32768U   // maximum size of input buffer
#define MAX_OUT_BUF_SIZE   32768U   // maximum size of output buffer

#define IN_BUF_STEP        1024U    // decrement sizes used in I/O buffer
#define OUT_BUF_STEP       1024U    // allocation in InitBuffers()

#define FLUSH_BYTE         ((BYTE) 'F')   // dummy character used to flush
                                          // rgbyteOutBuf[] to output file

#define END_OF_INPUT       500      // ReadInBuf() EOF flag for input file

// DOS file handle flag indicating that the compression savings should be
// computed, but no output file written.
#define NO_DOSH            (-2)

#define READ_IT            TRUE     // GetIOHandle() bRead flag values
#define WRITE_IT           FALSE


// Macros
//////////

// Read a byte (buffered) from input file.  Stores byte read in argument.
// Returns TRUE if successful, or one of ReadInBuf()'s error codes if
// unsuccessful.
//-protect-
#define ReadByte(byte)         ((pLZI->pbyteInBuf < pLZI->pbyteInBufEnd) ? \
                               ((byte = *pLZI->pbyteInBuf++), TRUE) : \
                               ReadInBuf((BYTE ARG_PTR *)&byte, doshSource, pLZI))

// Put at most one byte back into the buffered input.  N.b., may be used at
// most (pbyteInBuf - &rgbyteInBuf[1]) times.  E.g., may be used only once at
// beginning of buffer.  Return value is always TRUE.
//-protect-
#define UnreadByte()          ((pLZI->pbyteInBuf == &pLZI->rgbyteInBuf[1]) ? \
                               (pLZI->bLastUsed = TRUE) : \
                               (--pLZI->pbyteInBuf, TRUE))

// Write a byte (buffered) to output file.  Returns TRUE if successful, or
// one of WriteOutBuf()'s error codes if unsuccessful.  ALWAYS increments
// cblOutSize.
#define WriteByte(byte)        ((pLZI->pbyteOutBuf < pLZI->pbyteOutBufEnd) ? \
                               ((*pLZI->pbyteOutBuf++ = byte), pLZI->cblOutSize++, TRUE) : \
                               (pLZI->cblOutSize++, WriteOutBuf(byte, doshDest, pLZI)))

// Flush output buffer.  DOES NOT increment cblOutSize.  N.b., you cannot
// perform a valid UnreadByte() immediately after FlushOutputBuffer() because
// the byte kept will be the bogus FLUSH_BYTE.
#define FlushOutputBuffer(dosh, pLZI)  WriteOutBuf(FLUSH_BYTE, dosh, pLZI)

// Reset buffer pointers to empty buffer state.
//-protect-
#define ResetBuffers()        {  pLZI->pbyteInBufEnd = &pLZI->rgbyteInBuf[1] + pLZI->ucbInBufLen; \
                                 pLZI->pbyteInBuf = &pLZI->rgbyteInBuf[1] + pLZI->ucbInBufLen; \
                                 pLZI->bLastUsed = FALSE; \
                                 pLZI->pbyteOutBufEnd = pLZI->rgbyteOutBuf + pLZI->ucbOutBufLen; \
                                 pLZI->pbyteOutBuf = pLZI->rgbyteOutBuf; \
                                 pLZI->cblOutSize = 0L; \
                              }

// The buffer pointers are initialized to NULL to indicate the buffers have
// not yet been allocated.  init.c!InitGlobalBuffers() allocates the buffers
// and sets the buffers' base pointers.  buffers.h!ResetBufferPointers() sets
// the buffers' current position and end position pointers.

// Prototypes
//////////////

// buffers.c
extern INT ReadInBuf(BYTE ARG_PTR *pbyte, HANDLE doshSource, PLZINFO pLZI);
extern INT WriteOutBuf(BYTE byteNext, HANDLE doshDest, PLZINFO pLZI);

// init.c
extern PLZINFO InitGlobalBuffers(DWORD dwOutBufSize, DWORD dwRingBufSize, DWORD dwInBufSize);
extern PLZINFO InitGlobalBuffersEx();
extern VOID FreeGlobalBuffers(PLZINFO);

extern INT GetIOHandle(LPWSTR pszFileName, BOOL bRead, HANDLE *pdosh,
   LONG *pcblInSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\lzdos.h ===
#include <lzexpand.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\lz_common.h ===
/*
** common.h - housekeeping for Lempel-Ziv compression / expansion DOS
**            command-line programs, DOS static library module, and Windows
**            DLL
**
** Author:  DavidDi
*/


// Headers
///////////

#ifdef LZA_DLL
#include <windows.h>
#include <port1632.h>
#endif

//#include <lzdos.h>
#include "translat.h"


// Set up type for function argument pointers.
#ifdef LZA_DLL
#define ARG_PTR         FAR
#else
#define ARG_PTR         // nada
#endif


// Constants
/////////////


#define NOTIFY_START_COMPRESS 0        // file processing notifications
#define NOTIFY_START_EXPAND   1        //
#define NOTIFY_START_COPY     2        //

#define BLANK_ERROR           0        // error condition requiring no error
                                       // message display


// Types
/////////

// Callback notification procedure.
typedef BOOL (*NOTIFYPROC)(LPWSTR pszSource, LPWSTR pszDest,
                           WORD wProcessFlag);

// Flag indicating whether or not rgbyteInBuf[0], which holds the last byte
// from the previous input buffer, should be read as the next input byte.
// (Only used so that at least one unReadUChar() can be done at all input
// buffer positions.)

typedef struct tagLZI {
   BYTE *rgbyteRingBuf;  // ring buffer for expansion
   BYTE *rgbyteInBuf;    // input buffer for reads
   BYTE *pbyteInBufEnd;  // pointer past end of rgbyteInBuf[]
   BYTE *pbyteInBuf;     // pointer to next byte to read from
   BYTE *rgbyteOutBuf;   // output buffer for writes
   BYTE *pbyteOutBufEnd; // pointer past end of rgbyteOutBuf[]
   BYTE *pbyteOutBuf;    // pointer to last byte to write from
   // Flag indicating whether or not rgbyteInBuf[0], which holds the last byte
   // from the previous input buffer, should be read as the next input byte.
   // (Only used so that at least one unReadUChar() can be done at all input
   // buffer positions.)
   BOOL bLastUsed;
   // Actually, rgbyteInBuf[] has length (ucbInBufLen + 1) since rgbyteInBuf[0]
   // is used when bLastUsed is TRUE.
   INT cbMaxMatchLen;         // longest match length for current algorithm
   LONG cblInSize,       // size in bytes of input file
        cblOutSize;      // size in bytes of output file
   DWORD ucbInBufLen,    // length of input buffer
        ucbOutBufLen;    // length of output buffer
   DWORD uFlags;        // LZ decoding description byte
   INT iCurRingBufPos;     // ring buffer offset
   INT *leftChild;      // parents and left and right
   INT *rightChild;     // children that make up the
   INT *parent;         // binary search trees

   INT iCurMatch,          // index of longest match (set by LZInsertNode())
       cbCurMatch;         // length of longest match (set by LZInsertNode())

} LZINFO;


typedef LZINFO *PLZINFO;


// Macros
//////////

#define FOREVER   for(;;)

#ifndef MAX
#define MAX(a, b)             (((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a, b)             (((a) < (b)) ? (a) : (b))
#endif


// Prototypes
//////////////

// compress.c
extern INT Compress(NOTIFYPROC pfnNotify, LPWSTR pszSource,
                    LPWSTR pszDest, BYTE byteAlgorithm,
                    BOOL bDoRename, PLZINFO pLZI);

// expand.c

// dosdir.asm
extern INT GetCurDrive(VOID);
extern INT GetCurDir(LPSTR lpszDirBuf);
extern INT SetDrive(INT wDrive);
extern INT SetDir(LPSTR lpszDirName);
extern INT IsDir(LPSTR lpszDir);
extern INT IsRemoveable(INT wDrive);

extern WCHAR MakeCompressedNameW(LPWSTR pszFileName);
extern INT CopyDateTimeStamp(HANDLE doshFrom, HANDLE doshTo);
LPWSTR ExtractExtensionW(LPWSTR pszFileName);
LPWSTR ExtractFileNameW(LPWSTR pszPathName);


extern BOOL  LZIsCharLowerA(char cChar);
extern BOOL  LZIsCharUpperA(char cChar);
extern LPSTR LZCharNextA(LPCSTR lpCurrentChar);
extern LPSTR LZCharPrevA(LPCSTR lpStart, LPCSTR lpCurrentChar);

#undef IsCharLower
#undef IsCharUpper
#undef CharNext
#undef CharPrev
#define IsCharLower LZIsCharLowerA
#define IsCharUpper LZIsCharUpperA
#define CharNext    LZCharNextA
#define CharPrev    LZCharPrevA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\mydiam.h ===
INT
DiamondCompressFile(
    IN  NOTIFYPROC CompressNotify,
    IN  LPSTR       SourceFile,
    IN  LPSTR       TargetFile,
    IN  BOOL       Rename,
    OUT PLZINFO    pLZI
    );

TCOMP DiamondCompressionType;  // 0 if not diamond (ie, LZ)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\lz_header.h ===
/*
** header.h - Common information used in compressed file header manipulation.
**
** Author:  DavidDi
*/


// Constants
/////////////

// compressed file signature: "SZDD'3"
#define COMP_SIG        "SZDD\x88\xf0\x27\x33"

#define COMP_SIG_LEN    8              // length of signature (bytes)
                                       // (no '\0' terminator)

#define ALG_FIRST       ((BYTE) 'A')   // first version algorithm label for
                                       // Lempel-Ziv
#define ALG_LZ          ((BYTE) 'B')   // new Lempel-Ziv algorithm label
#define ALG_LZA         ((BYTE) 'C')   // Lempel-Ziv with arithmetic encoding
                                       // algorithm label

// length of entire compressed file header (used as offset to start of
// compressed data)
#define HEADER_LEN      14
// (14 == cbCompSigLength + algorithm + extension character
//        + uncompressed length)

#define BYTE_MASK       0xff           // mask used to isolate low-order byte


// Types
/////////

// Declare compressed file header information structure.  N.b., the
// compressed file header does not contain the file size of the compressed
// file since this is readily obtainable through filelength() or lseek().
// The file info structure, however, does contain the compressed file size,
// which is used when expanding the file.
typedef struct tagFH
{
   BYTE rgbyteMagic[COMP_SIG_LEN];  // array of compressed file signature
                                    // (magic bytes)

   BYTE byteAlgorithm;              // algorithm label
   WCHAR byteExtensionChar;          // last extension character
                                    // (always 0 for ALG_FIRST)

   // The file sizes are unsigned longs instead of signed longs for backward
   // compatibilty with version 1.00.
   DWORD cbulUncompSize;    // uncompressed file size
   DWORD cbulCompSize;      // compressed file size (not stored in
                                    // header)
} FH;
typedef struct tagFH *PFH;


// Macros
//////////

#if 0
#define RecognizeCompAlg(chAlg)  ((chAlg) == ALG_FIRST || \
                                  (chAlg) == ALG_LZ    || \
                                  (chAlg) == ALG_LZA)
#else
#define RecognizeCompAlg(chAlg)  ((chAlg) == ALG_FIRST)
#endif


// Prototypes
//////////////

// header.c
extern INT WriteHdr(PFH pFH, HANDLE doshDest, PLZINFO pLZI);
extern BOOL IsCompressed(PFH pFHIn);
extern VOID MakeHeader(PFH pFHBlank, BYTE byteAlgorithm, WCHAR byteExtensionChar,
   PLZINFO pLZI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\pch.h ===
#ifndef __PCH_H
#define __PCH_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once

//
// public Windows header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <Security.h>
#include <SecExt.h>

#include <windows.h>
#include <wchar.h>
#include <io.h>
#include <sys/stat.h>
#include <limits.h>
#include "Shlwapi.h"
#include "winbase.h"

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <dbghelp.h>
#include <psapi.h>
#include <ntexapi.h>


//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
#include <Winioctl.h>
#include <Rpcdce.h>
#include <crtdbg.h>
#include <diskguid.h>
#include <rpc.h>
#include <errno.h>

#include "cmdline.h"
#include "cmdlineres.h"

//compress related include files

#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"
#include "lzcommon.h"
#include "lzdos.h"
#include <diamondc.h>
#include "mydiam.h"

//
// private Common header files
//

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\lzcompress.c ===
/*
** lzcomp.c - Routines used in Lempel-Ziv compression (a la 1977 article).
**
** Author:  DavidDi
*/



// Headers
///////////

#include "pch.h"
#include "compress.h"
#include "resource.h"

#ifndef LZA_DLL

#include <dos.h>
#include <errno.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

#endif


/*
** N.b., one reason DOS file handles are used for file references in this
** module is that using FILE *'s for file references poses a problem.
** fclose()'ing a file which was fopen()'ed in write "w" or append "a" mode
** stamps the file with the current date.  This undoes the intended effect of
** CopyDateTimeStamp().  We could also get around this fclose() problem by
** first fclose()'ing the file, and then fopen()'ing it again in read "r"
** mode.
**
** Using file handles also allows us to bypass stream buffering, so reads and
** writes may be done with whatever buffer size we choose.  Also, the
** lower-level DOS file handle functions are faster than their stream
** counterparts.
*/


INT Compress(
   NOTIFYPROC pfnNotify,
   LPWSTR pszSource,
   LPWSTR pszDest,
   BYTE byteAlgorithm,
   BOOL bDoRename,
   PLZINFO pLZI)
/*++

 Compress one file to another.

 Arguments:  pszSource         - name of file to compress
             pszDest           - name of compressed output file
             byteAlgorithm     - compression algorithm to use
             byteExtensionChar - compressed file name extension character

 Returns:    int - TRUE if compression finished successfully.  One of the
                   LZERROR_ codes if not.

 Globals:    none
*/
{
   HANDLE   doshSource              =   NULL;            // input file handle
   HANDLE   doshDest                =   NULL;              // output file handle
   INT      nRetVal                 =   TRUE;
   WCHAR szBuffer[MAX_PATH]         =   NULL_STRING;
   WCHAR szDestFileName[MAX_PATH]   =   NULL_STRING;
   WCHAR byteExtensionChar;
   FH FHOut;                                    // compressed header info struct


   // Sanity check
   if (!pLZI) {
      return(FALSE);
   }

   // Set up input file handle. Set cblInSize to length of input file.
   if ((nRetVal = GetIOHandle(pszSource, READ_IT, &doshSource, &pLZI->cblInSize)) != TRUE)
   {
      DISPLAY_MESSAGE1( stderr, szBuffer, GetResString(IDS_FILE_NOT_FOUND), _X(pszSource) );
      return(nRetVal);
   }

   // Rewind input file.
   if( 0 != SetFilePointer(doshSource, 0L, NULL, FILE_BEGIN) )
   {
      CloseHandle(doshSource);
      return(FALSE);
   }

   // Create destination file name.

   STRCPY(szDestFileName, pszDest);

   if (bDoRename == TRUE)
      // Rename output file.
      byteExtensionChar = MakeCompressedNameW(szDestFileName);
   else
      byteExtensionChar = '\0';

   // Ask if we should compress this file.
   if (! (*pfnNotify)(pszSource, szDestFileName, NOTIFY_START_COMPRESS))
   {
      // Don't compress file.    This error condition should be handled in
      // pfnNotify, so indicate that it is not necessary for the caller to
      // display an error message.
      CloseHandle( doshSource );
      return(FALSE);
   }

   // Setup output file handle.
   if ((nRetVal = GetIOHandle(szDestFileName, WRITE_IT, &doshDest, &pLZI->cblInSize)) != TRUE)
   {
      DISPLAY_MESSAGE1( stderr, szBuffer, GetResString(IDS_FILE_NOT_FOUND), pszSource );
      CloseHandle(doshSource);
      return(nRetVal);
   }

   // Fill in compressed file header.
   MakeHeader(& FHOut, byteAlgorithm, byteExtensionChar, pLZI);

   // Write compressed file header to output file.
   if ((nRetVal = WriteHdr(& FHOut, doshDest, pLZI)) != TRUE)
   {
       CloseHandle( doshSource );
       CloseHandle(doshDest);
       DISPLAY_MESSAGE( stderr, GetResString( IDS_FAILED_WRITE_HDR ) );
       return( FALSE );
   }



   // Compress input file into output file.
    switch (byteAlgorithm)
   {
      case ALG_FIRST:

      case ALG_LZ:

         nRetVal = LZEncode(doshSource, doshDest, pLZI);
         break;

      default:
         nRetVal = FALSE;
         break;
   }

   if (nRetVal != TRUE)
   {
      CloseHandle(doshSource);
      return(FALSE);
   }


   // Copy date and time stamp from source file to destination file.
   nRetVal = CopyDateTimeStamp(doshSource, doshDest);

   // Close files.
   CloseHandle(doshSource);
   CloseHandle(doshDest);

   return(nRetVal);
}

INT LZEncode(HANDLE doshSource, HANDLE doshDest, PLZINFO pLZI)
/*
** int LZEncode(int doshSource, int doshDest);
**
** Compress input file into output file.
**
** Arguments:  doshSource    - open DOS file handle of input file
**             doshDest      - open DOS file handle of output file
**
** Returns:    int - TRUE if compression was successful.  One of the LZERROR_
**                   codes if the compression failed.
**
** Globals:
*/
{
   INT   i, len, f,
         iCurChar,      // current ring buffer position
         iCurString,    // start of current string in ring buffer
         iCodeBuf,      // index of next open buffer position
         cbLastMatch;   // length of last match
   BYTE byte,           // temporary storage for next byte to write
        byteMask,       // bit mask (and counter) for eight code units
        codeBuf[1 + 8 * MAX_LITERAL_LEN]; // temporary storage for encoded data

#if 0
   pLZI->cbMaxMatchLen = LZ_MAX_MATCH_LEN;
#else
   pLZI->cbMaxMatchLen = FIRST_MAX_MATCH_LEN;
#endif

   ResetBuffers();

   pLZI->cblOutSize += HEADER_LEN;

   // Initialize encoding trees.
   if (!LZInitTree(pLZI)) {
      return( LZERROR_GLOBALLOC );
   }

   // CodeBuf[1..16] saves eight units of code, and CodeBuf[0] works as eight
   // flags.  '1' representing that the unit is an unencoded letter (1 byte),
   // '0' a position-and-length pair (2 bytes).  Thus, eight units require at
   // most 16 bytes of code, plus the one byte of flags.
   codeBuf[0] = (BYTE)0;
   byteMask = (BYTE)1;
   iCodeBuf = 1;

   iCurString = 0;
   iCurChar = RING_BUF_LEN - pLZI->cbMaxMatchLen;

   for (i = 0; i < RING_BUF_LEN - pLZI->cbMaxMatchLen; i++)
      pLZI->rgbyteRingBuf[i] = BUF_CLEAR_BYTE;

   // Read bytes into the last cbMaxMatchLen bytes of the buffer.
   for (len = 0; len < pLZI->cbMaxMatchLen && ((f = ReadByte(byte)) != END_OF_INPUT);
        len++)
   {
      if (f != TRUE) {
         return( f );
      }

      pLZI->rgbyteRingBuf[iCurChar + len] = byte;
   }

   // Insert the cbMaxMatchLen strings, each of which begins with one or more
   // 'space' characters.  Note the order in which these strings are inserted.
   // This way, degenerate trees will be less likely to occur.
   for (i = 1; i <= pLZI->cbMaxMatchLen; i++)
      LZInsertNode(iCurChar - i, FALSE, pLZI);

   // Finally, insert the whole string just read.  The global variables
   // cbCurMatch and iCurMatch are set.
   LZInsertNode(iCurChar, FALSE, pLZI);

   do // while (len > 0)
   {
      // cbCurMatch may be spuriously long near the end of text.
      if (pLZI->cbCurMatch > len)
         pLZI->cbCurMatch = len;

      if (pLZI->cbCurMatch <= MAX_LITERAL_LEN)
      {
         // This match isn't long enough to encode, so copy it directly.
         pLZI->cbCurMatch = 1;
         // Set 'one uncoded byte' bit flag.
         codeBuf[0] |= byteMask;
         // Write literal byte.
         codeBuf[iCodeBuf++] = pLZI->rgbyteRingBuf[iCurChar];
      }
      else
      {
         // This match is long enough to encode.  Send its position and
         // length pair.  N.b., pLZI->cbCurMatch > MAX_LITERAL_LEN.
         codeBuf[iCodeBuf++] = (BYTE)pLZI->iCurMatch;
         codeBuf[iCodeBuf++] = (BYTE)((pLZI->iCurMatch >> 4 & 0xf0) |
                                      (pLZI->cbCurMatch - (MAX_LITERAL_LEN + 1)));
      }

      // Shift mask left one bit.
      if ((byteMask <<= 1) == (BYTE)0)
      {
         // Send at most 8 units of code together.
         for (i = 0; i < iCodeBuf; i++)
            if ((f = WriteByte(codeBuf[i])) != TRUE) {
                 return( f );
            }

         // Reset flags and mask.
         codeBuf[0] = (BYTE)0;
         byteMask = (BYTE)1;
         iCodeBuf = 1;
      }

      cbLastMatch = pLZI->cbCurMatch;

      for (i = 0; i < cbLastMatch && ((f = ReadByte(byte)) != END_OF_INPUT);
           i++)
      {
         if (f != TRUE) {
             return( f );
         }

         // Delete old string.
         LZDeleteNode(iCurString, pLZI);
         pLZI->rgbyteRingBuf[iCurString] = byte;

         // If the start position is near the end of buffer, extend the
         // buffer to make string comparison easier.
         if (iCurString < pLZI->cbMaxMatchLen - 1)
            pLZI->rgbyteRingBuf[iCurString + RING_BUF_LEN] = byte;

         // Increment position in ring buffer modulo RING_BUF_LEN.
         iCurString = (iCurString + 1) & (RING_BUF_LEN - 1);
         iCurChar = (iCurChar + 1) & (RING_BUF_LEN - 1);

         // Register the string in rgbyteRingBuf[r..r + cbMaxMatchLen - 1].
         LZInsertNode(iCurChar, FALSE, pLZI);
      }

      while (i++ < cbLastMatch)
      {
         // No need to read after the end of the input, but the buffer may
         // not be empty.
         LZDeleteNode(iCurString, pLZI);
         iCurString = (iCurString + 1) & (RING_BUF_LEN - 1);
         iCurChar = (iCurChar + 1) & (RING_BUF_LEN - 1);
         if (--len)
            LZInsertNode(iCurChar, FALSE, pLZI);
      }
   } while (len > 0);   // until there is no input to process

   if (iCodeBuf > 1)
      // Send remaining code.
      for (i = 0; i < iCodeBuf; i++)
         if ((f = WriteByte(codeBuf[i])) != TRUE) {
            return( f );
         }

   // Flush output buffer to file.
   if ((f = FlushOutputBuffer(doshDest, pLZI)) != TRUE) {
      return( f );
   }

   LZFreeTree(pLZI);
   return(TRUE);
}


INT WriteHdr(PFH pFH, HANDLE doshDest, PLZINFO pLZI)
/*
** int WriteHdr(PFH pFH, int doshDest);
**
** Write compressed file header to output file.
**
** Arguments:  pFH      - pointer to source header information structure
**             doshDest - DOS file handle of open output file
**
** Returns:    int - TRUE if successful.  LZERROR_BADOUTHANDLE if
**                   unsuccessful.
**
** Globals:    none
**
** header format:
**                8 bytes  -->   compressed file signature
**                1 byte   -->   algorithm label
**                1 byte   -->   extension char
**                4 bytes  -->   uncompressed file size (LSB to MSB)
**
**       length = 14 bytes
*/
{
   INT i, j;
   DWORD ucbWritten;
   BYTE rgbyteHeaderBuf[HEADER_LEN];   // temporary storage for next header byte to write
   LPWSTR   lpBuf = NULL;

   // Sanity check
   if (!pLZI) {
      return(FALSE);
   }

   // Copy the compressed file signature.
   for (i = 0; i < COMP_SIG_LEN; i++)
      rgbyteHeaderBuf[i] = pFH->rgbyteMagic[i];

   // Copy the algorithm label and file name extension character.
   rgbyteHeaderBuf[i++] = pFH->byteAlgorithm;
   rgbyteHeaderBuf[i++] = (BYTE) pFH->byteExtensionChar;
   rgbyteHeaderBuf[i++] = (BYTE) pFH->byteExtensionChar+1;

   // Copy input file size (long ==> 4 bytes),
   // LSB first to MSB last.
   for (j = 0; j < 4; j++)
      rgbyteHeaderBuf[i++] = (BYTE)((pFH->cbulUncompSize >> (8 * j)) &
                                    (DWORD)BYTE_MASK);

   // Write header to file.
   if ( FALSE  == WriteFile(doshDest,
                            rgbyteHeaderBuf,
                            HEADER_LEN,
                            &ucbWritten,
                            NULL))
   {
       FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        GetLastError(),
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPWSTR) &lpBuf,
                        0,
                        NULL );

         DISPLAY_MESSAGE( stdout, lpBuf );
         LocalFree( lpBuf );

#ifdef LZA_DLL
      if (ucbWritten == (DWORD)(-1))
#else
      if (_error != 0U)
#endif
         // Bad DOS file handle.
         return(FALSE);
      else
         // Insufficient space on destination drive.
          return(FALSE);

   }

   // Keep track of bytes written.
   pLZI->cblOutSize += (LONG)ucbWritten;

   // Header written ok.
   return(TRUE);
}

INT WriteOutBuf(BYTE byteNext, HANDLE doshDest, PLZINFO pLZI)
/*++
 Dumps output buffer to output file.  Prompts for new floppy disk if the
 old one if full.  Continues dumping to output file of same name on new
 floppy disk.

 Arguments:  byteNext - first byte to be added to empty buffer after buffer
                        is written
             doshDest - output DOS file handle

 Returns:    int - TRUE if successful.  LZERROR_BADOUTHANDLE or
                   LZERROR_WRITE if unsuccessful.

 Globals:    pbyteOutBuf - reset to point to free byte after byteNext in
                           rgbyteOutBuf
--*/

{
   DWORD    ucbToWrite      =   0;   // number of bytes to write from buffer
   DWORD    ucbWritten      =   0;       // number of bytes actually written
   DWORD    ucbTotWritten   =   0;   // total number of bytes written to output
   BOOL     bStatus         =   FALSE;

   // !!! Assumes pLZI parm is valid.  No sanity check (should be done above in caller).

   // How much of the buffer should be written to the output file?
   ucbTotWritten = ucbToWrite = (DWORD)(pLZI->pbyteOutBuf - pLZI->rgbyteOutBuf);
   // Reset pointer to beginning of buffer.
   pLZI->pbyteOutBuf = pLZI->rgbyteOutBuf;

   // Write to ouput file.

   bStatus = WriteFile(doshDest, pLZI->pbyteOutBuf, ucbToWrite, &ucbWritten, NULL);
   if ( ucbWritten != ucbToWrite )
   {
#ifdef LZA_DLL
      if (ucbWritten == (DWORD)(-1)) {
#else
      if (_error != 0U) {
#endif
         // Bad DOS file handle.
         return(FALSE);
      }
      else {
         // Insufficient space on destination drive.
         return(FALSE);
      }
   }

   // Add the next byte to the buffer.
   *pLZI->pbyteOutBuf++ = byteNext;

   return(TRUE);
}

INT ReadInBuf(BYTE ARG_PTR *pbyte, HANDLE doshSource, PLZINFO pLZI)
/*++
 int ReadInBuf(BYTE ARG_PTR *pbyte, int doshSource);

 Read input file into input buffer.

 Arguments:  pbyte      - pointer to storage for first byte read from file
                          into buffer
             doshSource - DOS file handle to open input file

 Returns:    int - TRUE or END_OF_INPUT if successful.  LZERROR_BADINHANDLE
                   if not.

 Globals:    rgbyteInBuf[0] - holds last byte from previous buffer
             pbyteInBufEnd  - set to point to first byte beyond end of data
                              in input buffer
             bLastUsed      - reset to FALSE if currently TRUE
--*/

{
   DWORD    ucbRead     =   0;          // number of bytes actually read
   DWORD    dwBytesRead =   0;

   // !!! Assumes pLZI parm is valid.  No sanity check (should be done above in caller).

   pLZI->rgbyteInBuf[0] = *(pLZI->pbyteInBufEnd - 1);

   ReadFile(doshSource, &pLZI->rgbyteInBuf[1], pLZI->ucbInBufLen, &ucbRead, NULL);
   if (ucbRead != pLZI->ucbInBufLen)
   {
#ifdef LZA_DLL
      if (ucbRead == (DWORD)(-1)) {
#else
      if (_error != 0U) {
#endif
         // We were handed a bad input file handle.
         return(FALSE);
      }
      else if (ucbRead > 0U)
         // Read last ucbRead bytes of input file.  Change input buffer end
         // to account for shorter read.
         pLZI->pbyteInBufEnd = &pLZI->rgbyteInBuf[1] + ucbRead;
      else  { // (ucbRead == 0U) {
         // We couldn't read any bytes from input file (EOF reached).
         return(END_OF_INPUT);
      }
   }

   // Reset read pointer to beginning of input buffer.
   pLZI->pbyteInBuf = &pLZI->rgbyteInBuf[1];

   // Was an UnreadByte() done at the beginning of the last buffer?
   if (pLZI->bLastUsed)
   {
      // Return the last byte from the previous input buffer
      *pbyte = pLZI->rgbyteInBuf[0];
      pLZI->bLastUsed = FALSE;
   }
   else
      // Return the first byte from the new input buffer.
      *pbyte = *pLZI->pbyteInBuf++;

   return(TRUE);
}


VOID MakeHeader(PFH pFHBlank, BYTE byteAlgorithm,
                WCHAR byteExtensionChar, PLZINFO pLZI)
/*++
 void MakeHeader(PFH pFHBlank, BYTE byteAlgorithm,
                 BYTE byteExtensionChar);

 Arguments:  pFHBlank          - pointer to compressed file header struct
                                 that is to be filled in
             byteAlgorithm     - algorithm label
             byteExtensionChar - uncompressed file name extension character

 Returns:    void

 Globals:    none

 Global cblInSize is used to fill in expanded file length field.
 Compressed file length field is set to 0 since it isn't written.

--*/
{
   INT i;

   // !!! Assumes pLZI parm is valid.  No sanity check (should be done above in caller).

   // Fill in compressed file signature.
   for (i = 0; i < COMP_SIG_LEN; i++)
      pFHBlank->rgbyteMagic[i] = (BYTE)(*(COMP_SIG + i));

   // Fill in algorithm and extesion character.
   pFHBlank->byteAlgorithm = byteAlgorithm;
   pFHBlank->byteExtensionChar = byteExtensionChar;

   // Fill in file sizes.  (cbulCompSize not written to compressed file
   // header, so just set it to 0UL.)
   pFHBlank->cbulUncompSize = (DWORD)pLZI->cblInSize;
   pFHBlank->cbulCompSize = 0UL;
}


BOOL
 FileTimeIsNewer( LPWSTR pszFile1,
                  LPWSTR pszFile2 )

/*++  static BOOL FileTimeIsNewer( const char* pszFile1, const char* pszFile2 );

  Return value is TRUE if time stamp on pszFile1 is newer than the
  time stamp on pszFile2.  If either of the two files do not exist,
  the return value is also TRUE (for indicating that pszFile2 should
  be update from pszFile1).  Otherwise, the return value is FALSE.
--*/

{

    struct _stat StatBufSource,
                 StatBufDest;

    if (( _wstat( pszFile2, &StatBufDest   )) ||
        ( _wstat( pszFile1, &StatBufSource )) ||
        ( StatBufSource.st_mtime > StatBufDest.st_mtime ))
        return TRUE;

    return FALSE;

}


PLZINFO InitGlobalBuffers(
   DWORD dwOutBufSize,
   DWORD dwRingBufSize,
   DWORD dwInBufSize)
{
   PLZINFO pLZI;

   if (!(pLZI = (PLZINFO)LocalAlloc(LPTR, sizeof(LZINFO)))) {
      return(NULL);
   }

   // Set up ring buffer.  N.b., extra (cbStrMax - 1) bytes used to
   // facilitate string comparisons near end of ring buffer.
   // (The size allocated for the ring buffer may be at most 4224, since
   //  that's the ring buffer length embedded in the LZFile structs in
   //  lzexpand.h.)

   if (dwRingBufSize == 0) {
      dwRingBufSize = MAX_RING_BUF_LEN;
   }

   if ((pLZI->rgbyteRingBuf = (BYTE FAR *)FALLOC(dwRingBufSize * sizeof(BYTE))) == NULL)
      // Bail out, since without the ring buffer, we can't decode anything.
      return(NULL);


   if (dwInBufSize == 0) {
      dwInBufSize = MAX_IN_BUF_SIZE;
   }

   if (dwOutBufSize == 0) {
      dwOutBufSize = MAX_OUT_BUF_SIZE;
   }

   for (pLZI->ucbInBufLen = dwInBufSize, pLZI->ucbOutBufLen = dwOutBufSize;
      pLZI->ucbInBufLen > 0U && pLZI->ucbOutBufLen > 0U;
      pLZI->ucbInBufLen -= IN_BUF_STEP, pLZI->ucbOutBufLen -= OUT_BUF_STEP)
   {
      // Try to set up input buffer.  N.b., extra byte because rgbyteInBuf[0]
      // will be used to hold last byte from previous input buffer.
      if ((pLZI->rgbyteInBuf = (BYTE *)FALLOC(pLZI->ucbInBufLen + 1U)) == NULL)
         continue;

      // And try to set up output buffer...
      if ((pLZI->rgbyteOutBuf = (BYTE *)FALLOC(pLZI->ucbOutBufLen)) == NULL)
      {
         FFREE(pLZI->rgbyteInBuf);
         continue;
      }

      return(pLZI);
   }

   // Insufficient memory for I/O buffers.
   FFREE(pLZI->rgbyteRingBuf);
   return(NULL);
}

PLZINFO InitGlobalBuffersEx()
{
   return(InitGlobalBuffers(MAX_OUT_BUF_SIZE, MAX_RING_BUF_LEN, MAX_IN_BUF_SIZE));
}

VOID FreeGlobalBuffers(
   PLZINFO pLZI)
{

   // Sanity check

   if (!pLZI) {
      return;
   }

   if (pLZI->rgbyteRingBuf)
   {
      FFREE(pLZI->rgbyteRingBuf);
      pLZI->rgbyteRingBuf = NULL;
   }

   if (pLZI->rgbyteInBuf)
   {
      FFREE(pLZI->rgbyteInBuf);
      pLZI->rgbyteInBuf = NULL;
   }

   if (pLZI->rgbyteOutBuf)
   {
      FFREE(pLZI->rgbyteOutBuf);
      pLZI->rgbyteOutBuf = NULL;
   }

   // Buffers deallocated ok.

   // reset thread info
   LocalFree(pLZI);
}


INT
 GetIOHandle(LPWSTR pszFileName,
            BOOL bRead,
            HANDLE *pdosh,
            LONG *pcblInSize)
/*
** int GetIOHandle(char ARG_PTR *pszFileName, BOOL bRead, int ARG_PTR *pdosh);
**
** Opens input and output files.
**
** Arguments:  pszFileName - source file name
**             bRead       - mode for opening file TRUE for read and FALSE
**                           for write
**             pdosh       - pointer to buffer for DOS file handle to be
**                           filled in
**
** Returns:    int - TRUE if file opened successfully.  LZERROR_BADINHANDLE
**                   if input file could not be opened.  LZERROR_BADOUTHANDLE
**                   if output file could not be opened.  Fills in
**                   *pdosh with open DOS file handle, or NO_DOSH if
**                   pszFileName is NULL.
**
** Globals:    cblInSize  - set to length of input file
*/
{
    LPVOID lpBuf    =   NULL;

   if (pszFileName == NULL)
      *pdosh = NULL;
   else if (bRead == WRITE_IT)
   {
      // Set up output DOS file handle.
      if ((*pdosh = CreateFile( pszFileName, GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) == INVALID_HANDLE_VALUE )
      return(FALSE);

   }
   else // (bRead == READ_IT)
   {
       if ((*pdosh = CreateFile( pszFileName, GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) == INVALID_HANDLE_VALUE)
         return(FALSE);

      // Move to the end of the input file to find its length,
      // then return to the beginning.
      if ((*pcblInSize = GetFileSize( *pdosh, NULL )) == -1 )
      {
         CloseHandle(*pdosh);
         FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        GetLastError(),
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPWSTR) &lpBuf,
                        0,
                        NULL );

         DISPLAY_MESSAGE( stdout, (LPWSTR) lpBuf );
         //release memory allocated by LocalAlloc
		 LocalFree( lpBuf );
         return(FALSE);
      }
   }

   return(TRUE);
}



BOOL
 ProcessNotification(LPWSTR pszSource,
                     LPWSTR pszDest,
                     WORD wNotification
                     )

/*
 static BOOL ProcessNotification(char ARG_PTR *pszSource,
                                 char ARG_PTR *pszDest,
                                 WORD wNotification);
 Callback function during file processing.

 Arguments:  pszSource     - source file name
             pszDest       - destination file name
             wNotification - process type query

  Returns:    BOOL - (wNotification == NOTIFY_START_*):
                         TRUE if the source file should be "processed" into
                         the destination file.  FALSE if not.
                    else
                         TRUE.

 Globals:    none
--*/
{
    WCHAR* szBuffer =   NULL;
    DWORD   dwSize  =   0;

   switch(wNotification)
   {
      case NOTIFY_START_COMPRESS:
      {
         // Fail if the source and destination files are identical.
         if( lstrcmp( pszSource, pszDest ) == 0 )
         {
             dwSize = lstrlen( GetResString( IDS_COLLISION ) )+ lstrlen(pszSource) + 10;
             szBuffer = malloc( dwSize*sizeof(WCHAR) );
             if( NULL == szBuffer )
              {
                DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                SetLastError( ERROR_OUTOFMEMORY );
                SaveLastError();
                DISPLAY_MESSAGE( stderr, GetReason() );
                return( EXIT_FAILURE );
              }
             DISPLAY_MESSAGE1( stderr, szBuffer, GetResString( IDS_COLLISION ), pszSource );
             free( szBuffer );
             return FALSE;
         }

         // Display start message.
         switch (byteAlgorithm)
         {
         case LZX_ALG:
              dwSize = lstrlen( GetResString( IDS_COMPRESSING_LZX ) )+ lstrlen(pszSource) + lstrlen(pszDest)+10;
              szBuffer = malloc( dwSize*sizeof(WCHAR) );
              if( NULL == szBuffer )
              {
                DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                SetLastError( ERROR_OUTOFMEMORY );
                SaveLastError();
                DISPLAY_MESSAGE( stderr, GetReason() );
                return( EXIT_FAILURE );
              }
              swprintf( szBuffer, GetResString( IDS_COMPRESSING_LZX ), pszSource, pszDest,
                        CompressionMemoryFromTCOMP(DiamondCompressionType) );
              ShowMessage(stdout, _X(szBuffer) );
              free( szBuffer );
             break;

         case QUANTUM_ALG:
             dwSize = lstrlen( GetResString( IDS_COMPRESSING_QUANTUM ) )+ lstrlen(pszSource) + lstrlen(pszDest)+10;
              szBuffer = malloc( dwSize*sizeof(WCHAR) );
              if( NULL == szBuffer )
              {
                DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                SetLastError( ERROR_OUTOFMEMORY );
                SaveLastError();
                DISPLAY_MESSAGE( stderr, GetReason() );
                return( EXIT_FAILURE );
              }
              swprintf( szBuffer, GetResString( IDS_COMPRESSING_QUANTUM ), pszSource, pszDest,
                        CompressionLevelFromTCOMP(DiamondCompressionType),
                        CompressionMemoryFromTCOMP(DiamondCompressionType)
                        );
              ShowMessage( stdout, _X(szBuffer) );
              free( szBuffer );
              break;

         default:
             dwSize = lstrlen( GetResString( IDS_COMPRESSING_MSZIP ) )+ lstrlen(pszSource) + lstrlen(pszDest)+10;
              szBuffer = malloc( dwSize*sizeof(WCHAR) );
              if( NULL == szBuffer )
              {
                DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                SetLastError( ERROR_OUTOFMEMORY );
                SaveLastError();
                DISPLAY_MESSAGE( stderr, GetReason() );
                return( EXIT_FAILURE );
              }
            swprintf(szBuffer,
                 (byteAlgorithm == MSZIP_ALG) ? GetResString( IDS_COMPRESSING_MSZIP ) : GetResString( IDS_COMPRESSING ),
                 pszSource,
                 pszDest);
            ShowMessage( stdout, _X(szBuffer) );
            free( szBuffer );
         }
      }
         break;

      default:
         break;
   }

   return(TRUE);
}

INT CopyDateTimeStamp(HANDLE doshFrom, HANDLE doshTo)
/*++


 Copy date and time stamp from one file to another.

 Arguments:  doshFrom - date and time stamp source DOS file handle
             doshTo   - target DOS file handle

 Returns:    TRUE if successful.  LZERROR_BADINHANDLE or
             LZERROR_BADOUTHANDLE if unsuccessful.

  Globals:    none

 N.b., stream-style I/O routines like fopen() and fclose() may counter the
 intended effect of this function.  fclose() writes the current date to any
 file it's called with which was opened in write "w" or append "a" mode.
 One way to get around this in order to modify the date of a file opened
 for writing or appending by fopen() is to fclose() the file and fopen() it
 again in read "r" mode.  Then set its date and time stamp with
 CopyDateTimeStamp().
--*/

{

    FILETIME lpCreationTime, lpLastAccessTime, lpLastWriteTime;

   if(!GetFileTime((HANDLE) doshFrom, &lpCreationTime, &lpLastAccessTime,
                    &lpLastWriteTime)){
      return(FALSE);
   }
   if(!SetFileTime((HANDLE) doshTo, &lpCreationTime, &lpLastAccessTime,
                    &lpLastWriteTime)){
      return(FALSE);
   }

   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by compress.rc
//

#define IDS_MAIN_HELP_BEGIN             30
#define IDS_USAGE_7                    31
#define IDS_USAGE_8                    32
#define IDS_USAGE_9                    33
#define IDS_USAGE_10                    34
#define IDS_USAGE_11                    35
#define IDS_USAGE_12                    36
#define IDS_USAGE_13                    37
#define IDS_USAGE_14                    38
#define IDS_USAGE_15                    39
#define IDS_USAGE_16                    40
#define IDS_USAGE_17                    41
#define IDS_USAGE_18                    42
#define IDS_USAGE_19                    43
#define IDS_USAGE_20                    44
#define IDS_USAGE_21                    45
#define IDS_USAGE_22                    46
#define IDS_USAGE_23                    47
#define IDS_USAGE_24                    48
#define IDS_USAGE_25                    49
#define IDS_MAIN_HELP_END               50

#define IDS_USAGE_29                    54
#define IDS_USAGE_30                    55
#define IDS_USAGE_31                    56


#define IDS_INVALID_SYNTAX              65
#define IDS_HELP_MESSAGE                66
#define IDS_NO_MEMORY                   67
#define IDS_ERROR_TAG                   68
#define IDS_DIRECTORY_NOTFOUND          69
#define IDS_INVALID_DIRECTORY           70
#define IDS_NO_DESTINATION_SPECIFIED    71
#define IDS_FILE_NOTFOUND               72
#define IDS_NO_SOURCEFILE               73

#define IDS_GEN_FAILURE                 74
#define IDS_COLLISION                   75
#define IDS_COMPRESSING                 76
#define IDS_COMPRESSING_MSZIP           77
#define IDS_COMPRESSING_QUANTUM         78
#define IDS_COMPRESSING_LZX             79
#define IDS_EMPTY_FILE_REPORT           80
#define IDS_TOTAL_REPORT                81
#define IDS_FILE_REPORT                 82
#define IDS_FILE_NOT_FOUND              83
#define IDS_FAILED_INITIALIZATION       84
#define IDS_FAILED_WRITE_HDR            85
#define IDS_ERROR_QUANTOM_LEVEL         86

#define IDS_BANNER_TEXT                 87
#define IDS_VER_PRODUCTVERSION_STR      88
#define IDS_MORETHAN_ONE_OPTION         89
#define IDS_NO_FILE_SPECIFIED           90
#define INVALID_FILE_NAME               91
#define IDS_FILE_ALREADY_UPDATED        92





// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\translat.h ===
/*
** translat.h - Translation macros for common DOS / Windows functions.
**
** Author:  DavidDi (stolen from ToddLa)
*/

#include "pch.h"

INT _ret;
INT _error;

/******************************* Windows code ******************************/


// near heap memory management

#define ALLOC(n)                 (VOID *)LocalAlloc(LPTR, n)
#define FREE(p)                  LocalFree(p)
#define SIZE(p)                  LocalSize(p)
#define REALLOC(p, n)            LocalRealloc(p, n, LMEM_MOVEABLE)

// FAR heap memory management

#ifdef ORGCODE
#define FALLOC(n)                (VOID FAR *)MAKELONG(0, GlobalAlloc(GPTR, (DWORD)n))
#define FFREE(n)                 GlobalFree((HANDLE)HIWORD((LONG)n))
#else
#define FALLOC(n)                GlobalAlloc(GPTR, (DWORD)n)
#define FFREE(n)                 GlobalFree((HANDLE)n)
#endif
// string manipulation

#define STRCAT(psz1, psz2)       lstrcat(psz1, psz2)
#define STRCMP(psz1, psz2)       lstrcmp(psz1, psz2)
#define STRCMPI(psz1, psz2)      lstrcmpi(psz1, psz2)
#define STRCPY(psz1, psz2)       lstrcpy(psz1, psz2)
#define STRLEN(psz)              lstrlen(psz)
#define STRLWR(psz)              AnsiLower(psz)
#define STRUPR(psz)              AnsiUpper(psz)

#define chEXTENSION_CHARW      L'_'
#define pszEXTENSION_STRW      L"_"
#define pszNULL_EXTENSIONW     L"._"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventcreate\pch.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Module Name:
//
//      pch.h
//
//  Abstract:
//
//      pre-compiled header declaration
//      files that has to be pre-compiled into .pch file
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//
// *********************************************************************************
#ifndef __PCH_H
#define __PCH_H

#define CMDLINE_VERSION     200

#ifdef __cplusplus
extern "C" {
#endif

#pragma once        // include header file only once

//
// public Windows header files
//
#include <windows.h>
#include "winerror.h"

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <wchar.h>
#include <crtdbg.h>

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#ifdef __cplusplus
}
#endif

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventcreate\eventcreate.c ===
// ****************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Module Name:
//
//    EventCreate.c
//
//  Abstract:
//
//    This modules implements creation of event in the user
//    specified log / application
//
//    Syntax:
//    ------
//    EventCreate [-s server [-u username [-p password]]]
//      [-log name] [-source name] -id eventid -description description -type eventtype
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//
// ****************************************************************************

#include "pch.h"
#include "EvcrtMsg.h"
#include "EventCreate.h"

//
// constants / defines / enumerators
//
#define FULL_SUCCESS            0
#define PARTIALLY_SUCCESS       1
#define COMPLETELY_FAILED       1

#define MAX_KEY_LENGTH      256
#define EVENT_LOG_NAMES_LOCATION    L"SYSTEM\\CurrentControlSet\\Services\\EventLog"

// constants
// NOTE: though the values in these variables are constants across
//       the tool, we are not marking them as contants on purpose.
WCHAR g_wszDefaultLog[] = L"Application";
WCHAR g_wszDefaultSource[] = L"EventCreate";

typedef struct
{
    // original buffers for command-line arguments
    BOOL bUsage;
    LPWSTR pwszServer;
    LPWSTR pwszUserName;
    LPWSTR pwszPassword;
    LPWSTR pwszLogName;
    LPWSTR pwszSource;
    LPWSTR pwszType;
    LPWSTR pwszDescription;
    DWORD dwEventID;

    // translations
    WORD wEventType;
    BOOL bCloseConnection;
    DWORD dwUserNameLength;
    DWORD dwPasswordLength;

} TEVENTCREATE_PARAMS, *PTEVENTCREATE_PARAMS;

//
// function prototypes
//
BOOL Usage();
BOOL CreateLogEvent( PTEVENTCREATE_PARAMS pParams );
BOOL CheckExistence( PTEVENTCREATE_PARAMS pParams );

BOOL UnInitializeGlobals( PTEVENTCREATE_PARAMS pParams );
BOOL AddEventSource( HKEY hLogsKey, LPCWSTR pwszSource );
BOOL ProcessOptions( LONG argc,
                     LPCWSTR argv[],
                     PTEVENTCREATE_PARAMS pParams, PBOOL pbNeedPwd );

// ***************************************************************************
// Routine Description:
//      This the entry point to this utility.
//
// Arguments:
//      [ in ] argc     : argument(s) count specified at the command prompt
//      [ in ] argv     : argument(s) specified at the command prompt
//
// Return Value:
//      The below are actually not return values but are the exit values
//      returned to the OS by this application
//          0       : utility successfully created the events
//          255     : utility completely failed in creating events
//          128     : utility has partially successfull in creating events
// ***************************************************************************
DWORD _cdecl wmain( LONG argc, LPCWSTR argv[] )
{
    // local variables
    BOOL bResult = FALSE;
    BOOL bNeedPassword = FALSE;
    TEVENTCREATE_PARAMS params;

    // init the structure to zero
    SecureZeroMemory( &params, sizeof( TEVENTCREATE_PARAMS ) );

    // process the command-line options
    bResult = ProcessOptions( argc, argv, &params, &bNeedPassword );

    // check the result of the parsing
    if ( bResult == FALSE )
    {
        // invalid syntax
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );

        // exit from program
        UnInitializeGlobals( &params );
        return 1;
    }

    // check whether usage has to be displayed or not
    if ( params.bUsage == TRUE )
    {
        // show the usage of the utility
        Usage();

        // finally exit from the program
        UnInitializeGlobals( &params );
        return 0;
    }

    // ******
    // actual creation of events in respective log files will start from here

    // try establishing connection to the required terminal
    params.bCloseConnection = TRUE;
    bResult = EstablishConnection( params.pwszServer,
        params.pwszUserName, params.dwUserNameLength,
        params.pwszPassword, params.dwPasswordLength, bNeedPassword );
    if ( bResult == FALSE )
    {
        //
        // failed in establishing n/w connection
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );

        // try with next server
        UnInitializeGlobals( &params );
        return 1;
    }
    else
    {
        // though the connection is successfull, some conflict might have occured
        switch( GetLastError() )
        {
        case I_NO_CLOSE_CONNECTION:
            params.bCloseConnection = FALSE;
            break;

        case E_LOCAL_CREDENTIALS:
        case ERROR_SESSION_CREDENTIAL_CONFLICT:
            {
                params.bCloseConnection = FALSE;
                ShowLastErrorEx( stderr, SLE_TYPE_WARNING | SLE_INTERNAL );
                break;
            }
        }
    }

    // report the log message
    bResult = CreateLogEvent( &params );
    if ( bResult == TRUE )
    {
        // both log and source would have specified
        if ( params.pwszSource != NULL && params.pwszLogName != NULL )
        {
            ShowMessage( stdout, L"\n" );
            ShowMessageEx( stdout, 2, TRUE, MSG_SUCCESS,
                params.pwszType, params.pwszLogName, params.pwszSource );
        }

        // only source name would have specified
        else if ( params.pwszSource != NULL )
        {
            ShowMessage( stdout, L"\n" );
            ShowMessageEx( stdout, 1, TRUE,
                MSG_SUCCESS_SOURCE, params.pwszType, params.pwszSource);
        }

        // only log name would have specified
        else if ( params.pwszLogName != NULL )
        {
            ShowMessage( stdout, L"\n" );
            ShowMessageEx( stdout, 1, TRUE,
                MSG_SUCCESS_LOG, params.pwszType, params.pwszLogName);
        }

        // nothing is specified -- can never be happened
        else
        {
            SetLastError( ERROR_PROCESS_ABORTED );
            ShowLastError( stderr );
            UnInitializeGlobals( &params );
            return 1;
        }
    }
    else
    {
        // display the message depending on the mode of conncetivity
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // exit
    UnInitializeGlobals( &params );
    return ((bResult == TRUE) ? 0 : 1);
}


BOOL
CreateLogEvent( PTEVENTCREATE_PARAMS pParams )
/*++
 Routine Description:
      This function connects to the specified server's event log (or) source
      and appropriately creates the needed event in it.

 Arguments:

 Return Value:
      TRUE    : if the event creation is successful
      FALSE   : if failed in creating the event
--*/
{
    // local variables
    BOOL bReturn = 0;                           // return value
    HANDLE hEventLog = NULL;                    // points to the event log
    LPCWSTR pwszDescriptions[ 1 ] = { NULL };   // building descriptions
    HANDLE hToken = NULL;                       // Handle to the process token.
    PTOKEN_USER ptiUserName = NULL;                    // Structure to username info.
    DWORD dwUserLen = 0;                        // Buffer length of username SID.

    // check the input
    if ( pParams == NULL )
    {
        SetLastError( ERROR_PROCESS_ABORTED );
        SaveLastError();
        return FALSE;
    }

    //
    // start the process

    // extract the SID for the current logged on user -- in case of local machine
    // and SID for user specified with -u at the command prompt -- if not specified
    // get the current logged user SID only


    // check whether the log / source exists in the registry or not
    if ( CheckExistence( pParams ) == FALSE )
    {
        return FALSE;       // return failure
    }

    // open the appropriate event log using the specified 'source' or 'log file'
    // and check the result of the operation
    // Note: At one time, we will make use of log name (or) source but not both
    if ( pParams->pwszSource != NULL )
    {
         // open log using source name
        hEventLog = RegisterEventSource( pParams->pwszServer, pParams->pwszSource );
    }
    else if ( pParams->pwszLogName != NULL )
    {
        // open log
        hEventLog = OpenEventLog( pParams->pwszServer, pParams->pwszLogName );
    }
    else
    {
        SetLastError( ERROR_PROCESS_ABORTED );
        SaveLastError();
        return FALSE;
    }

    // check the log open/register result
    if ( hEventLog == NULL )
    {
        // opening/registering  is failed
        SaveLastError();
        return FALSE;
    }

    // Set boolean flag to FALSE.
    bReturn = FALSE;
    // Get handle to current process token.
    bReturn = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken );
    // Is 'OpenPrcessToken' successful.
    if ( TRUE == bReturn )
    {
        bReturn = FALSE;
        // Get buffer length, required to store the owner SID.
        GetTokenInformation( hToken, TokenUser, NULL, 0, &dwUserLen );
        // 'GetTokenInformation' fails because of insufficient buffer space.
        if( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {   // Assign memory and check whether it's allocated.
            ptiUserName = (PTOKEN_USER) AllocateMemory( dwUserLen + 1 );
            if( NULL != ptiUserName )
            {   // Memory allocation is successful, get current process owber SID.
                bReturn = GetTokenInformation( hToken, TokenUser, ptiUserName, dwUserLen, &dwUserLen );
                if( TRUE == bReturn  )
                {   // Obtained the owner SID of current process.
                    // report event
                    pwszDescriptions[ 0 ] = pParams->pwszDescription;
                    bReturn = ReportEvent( hEventLog, pParams->wEventType, 0,
                        pParams->dwEventID, ptiUserName->User.Sid, 1, 0, pwszDescriptions, NULL);
                }
            }
        }
    }
    // check the result, save any error occured.
    if ( bReturn == FALSE )
    {
        // save the error info
        SaveLastError();
    }

    // Free handle to token and token info structure.
    if( NULL != hToken )
    {
        CloseHandle( hToken );
    }
    if( NULL != ptiUserName )
    {
        FreeMemory( &ptiUserName );
    }

    // close the event source
    if ( pParams->pwszSource != NULL )
    {
        DeregisterEventSource( hEventLog );
    }
    else
    {
        CloseEventLog( hEventLog );
    }

    // return the result
    return bReturn;
}

// ***************************************************************************
// Routine Description:
//      This function checks wether the log name or source name specified
//      actually exists in the registry
//
// Arguments:
//      [ in ] szServer         - server name
//      [ in ] szLog            - log name
//      [ in ] szSource         - source name
//
// Return Value:
//      TRUE    : If log / source exists in the registry
//      FALSE   : if failed find the match
// ***************************************************************************
BOOL CheckExistence( PTEVENTCREATE_PARAMS pParams )
{
    // local variables
    DWORD dwSize = 0;
    LONG lResult = 0L;
    LPCWSTR pwsz = NULL;
    BOOL bCustom = FALSE;
    DWORD dwLogsIndex = 0;
    DWORD dwSourcesIndex = 0;
    BOOL bFoundMatch = FALSE;
    BOOL bDuplicating = FALSE;
    BOOL bErrorOccurred = FALSE;
    BOOL bLog = FALSE, bLogMatched = FALSE;
    BOOL bSource = FALSE, bSourceMatched = FALSE;

    HKEY hKey = NULL;
    HKEY hLogsKey = NULL;
    HKEY hSourcesKey = NULL;

    FILETIME ftLastWriteTime;    // variable that will hold the last write info

    WCHAR wszRLog[ MAX_KEY_LENGTH ] = L"\0";
    WCHAR wszRSource[ MAX_KEY_LENGTH ] = L"\0";

    //
    // actual control flow starts
    //

    // check the input
    if ( pParams == NULL )
    {
        SetLastError( ERROR_PROCESS_ABORTED );
        SaveLastError();
        return FALSE;
    }

    // prepare the server name into UNC format
    pwsz = pParams->pwszServer;
    if ( pwsz != NULL && IsUNCFormat( pwsz ) == FALSE )
    {
        // format the server name in UNC format
        // NOTE: make use of the failure buffer to get the server name
        //       in UNC format
        if ( SetReason2( 2, L"\\\\%s", pwsz ) == FALSE )
        {
            SaveLastError();
            return FALSE;
        }

        // ...
        pwsz = GetReason();
    }

    // Connect to the registry
    lResult = RegConnectRegistry( pwsz, HKEY_LOCAL_MACHINE, &hKey );
    if ( lResult != ERROR_SUCCESS)
    {
        // save the error information and return FAILURE
        SetLastError( lResult );
        SaveLastError();
        return FALSE;
    }

    // open the "EventLogs" registry key for enumerating its sub-keys (which are log names)
    lResult = RegOpenKeyEx( hKey, EVENT_LOG_NAMES_LOCATION, 0, KEY_READ, &hLogsKey );
    if ( lResult != ERROR_SUCCESS )
    {
        switch( lResult )
        {
        case ERROR_FILE_NOT_FOUND:
            SetLastError( ERROR_REGISTRY_CORRUPT );
            break;

        default:
            // save the error information and return FAILURE
            SetLastError( lResult );
            break;
        }

        // close the key and return
        SaveLastError();
        RegCloseKey( hKey );
        return FALSE;
    }

    // start enumerating the logs present
    dwLogsIndex = 0;            // initialize the logs index
    bFoundMatch = FALSE;        // assume neither log (or) source doesn't match
    bErrorOccurred = FALSE;     // assume error is not occured
    dwSize = MAX_KEY_LENGTH;    // max. size of the key buffer
    bLogMatched = FALSE;
    bSourceMatched = FALSE;
    bDuplicating = FALSE;

    ////////////////////////////////////////////////////////////////////////
    // Logic:-
    //      1. determine whether user has supplied the log name or not
    //      2. determine whether user has supplied the source name or not
    //      3. Start enumerating all the logs present in the system
    //      4. check whether log is supplied or not, if yes, check whether
    //         the current log matches with user supplied one.
    //      5. check whether source is supplied or not, if yes, enumerate the
    //         sources available under the current log

    // determine whether searching has to be done of LOG (or) SOURCE
    bLog = (pParams->pwszLogName != NULL) ? TRUE : FALSE;           // #1
    bSource = (pParams->pwszSource != NULL) ? TRUE : FALSE;         // #2

    // initiate the enumeration of log present in the system        -- #3
    SecureZeroMemory( wszRLog, MAX_KEY_LENGTH * sizeof( WCHAR ) );
    lResult = RegEnumKeyEx( hLogsKey, 0, wszRLog,
        &dwSize, NULL, NULL, NULL, &ftLastWriteTime );

    // traverse thru the sub-keys until there are no more items     -- #3
    do
    {
        // check the result
        if ( lResult != ERROR_SUCCESS )
        {
            // save the error and break from the loop
            bErrorOccurred = TRUE;
            SetLastError( lResult );
            SaveLastError();
            break;
        }

        // if log name is passed, compare the current key value
        // compare the log name with the current key                -- #4
        if ( bLog == TRUE &&
             StringCompare( pParams->pwszLogName, wszRLog, TRUE, 0 ) == 0 )
        {
            bLogMatched = TRUE;
        }

        // if source name is passed ...                             -- #5
        if ( bSource == TRUE && bSourceMatched == FALSE )
        {
            // open the current log name to enumerate the sources under this log
            lResult = RegOpenKeyEx( hLogsKey, wszRLog, 0, KEY_READ, &hSourcesKey );
            if ( lResult != ERROR_SUCCESS )
            {
                // save the error and break from the loop
                bErrorOccurred = TRUE;
                SetLastError( lResult );
                SaveLastError();
                break;
            }

            // start enumerating the sources present
            dwSourcesIndex = 0;         // initialize the sources index
            dwSize = MAX_KEY_LENGTH;    // max. size of the key buffer
            SecureZeroMemory( wszRSource, dwSize * sizeof( WCHAR ) );
            lResult = RegEnumKeyEx( hSourcesKey, 0,
                wszRSource, &dwSize, NULL, NULL, NULL, &ftLastWriteTime );

            // traverse thru the sub-keys until there are no more items
            do
            {
                if ( lResult != ERROR_SUCCESS )
                {
                    // save the error and break from the loop
                    bErrorOccurred = TRUE;
                    SetLastError( lResult );
                    SaveLastError();
                    break;
                }

                // check whether this key matches with the required source or not
                if ( StringCompare( pParams->pwszSource, wszRSource, TRUE, 0 ) == 0 )
                {
                    // source matched
                    bSourceMatched = TRUE;
                    break;      // break from the loop
                }

                // update the sources index and fetch the next source key
                dwSourcesIndex += 1;
                dwSize = MAX_KEY_LENGTH;    // max. size of the key buffer
                SecureZeroMemory( wszRSource, dwSize * sizeof( WCHAR ) );
                lResult = RegEnumKeyEx( hSourcesKey, dwSourcesIndex,
                    wszRSource, &dwSize, NULL, NULL, NULL, &ftLastWriteTime );
            } while( lResult != ERROR_NO_MORE_ITEMS );

            // close the sources registry key
            RegCloseKey( hSourcesKey );
            hSourcesKey = NULL;     // clear the key value

            // check how the loop ended
            //      1. Source might have found
            //         Action:- we found required key .. exit from the main loop
            //      2. Error might have occured
            //         Action:- ignore the error and continue fetching other
            //                  log's sources
            //      3. End of sources reached in this log
            //         Action:- check if log name is supplied or not.
            //                  if log specified, then source if not found, break
            //  for cases 2 & 3, clear the contents of lResult for smooth processing

            // Case #2 & #3
            lResult = 0;                // we are not much bothered abt the errors
            bErrorOccurred = FALSE;     // occured while traversing thru the source under logs

            // Case #1
            if ( bSourceMatched == TRUE )
            {
                // check whether log is specified or not
                // if log is specified, it should have matched .. otherwise
                // error ... because duplicate source should not be created
                if ( bLog == FALSE ||
                     ( bLog == TRUE &&
                       bLogMatched == TRUE &&
                       StringCompare(pParams->pwszLogName, wszRLog, TRUE, 0) == 0 ) )
                {
                    // no problem ...
                    bFoundMatch = TRUE;

                    //
                    // determine whether this is custom created source or not

                    // mark this as custom source
                    bCustom = FALSE;

                    // open the source registry key
                    // NOTE: make use of the failure buffer as temp buffer for
                    //       formatting
                    if ( SetReason2( 3,
                                     L"%s\\%s\\%s",
                                     EVENT_LOG_NAMES_LOCATION,
                                     wszRLog, wszRSource ) == FALSE )
                    {
                        SaveLastError();
                        bErrorOccurred = TRUE;
                        break;
                    }

                    pwsz = GetReason();
                    lResult = RegOpenKeyEx( hKey, pwsz,
                        0, KEY_QUERY_VALUE, &hSourcesKey );
                    if ( lResult != ERROR_SUCCESS )
                    {
                        SetLastError( lResult );
                        SaveLastError();
                        bErrorOccurred = TRUE;
                        break;
                    }

                    // now query for the value
                    lResult = RegQueryValueEx( hSourcesKey,
                        L"CustomSource", NULL, NULL, NULL, NULL );
                    if ( lResult != ERROR_SUCCESS &&
                         lResult != ERROR_FILE_NOT_FOUND )
                    {
                        RegCloseKey( hSourcesKey );
                        SetLastError( lResult );
                        SaveLastError();
                        bErrorOccurred = TRUE;
                        break;
                    }

                    // close the souces key
                    RegCloseKey( hSourcesKey );

                    // mark this as custom source
                    if ( lResult == ERROR_SUCCESS )
                    {
                        bCustom = TRUE;
                    }

                    // break from the loop
                    break;
                }
                else
                {
                    // this should not be the case .. sources should not be duplicated
                    SetReason2( 1, ERROR_SOURCE_DUPLICATING, wszRLog );
                    bDuplicating = TRUE;
                }
            }
        }
        else if ( bLogMatched == TRUE && bSource == FALSE )
        {
            // mark this as a custom event source
            bCustom = TRUE;

            // ...
            bFoundMatch = TRUE;
            break;
        }
        else if ( bLogMatched == TRUE && bDuplicating == TRUE )
        {
            bErrorOccurred = TRUE;
            break;
        }

        // update the sources index and fetch the next log key
        dwLogsIndex += 1;
        dwSize = MAX_KEY_LENGTH;    // max. size of the key buffer
        SecureZeroMemory( wszRLog, dwSize * sizeof( WCHAR ) );
        lResult = RegEnumKeyEx( hLogsKey, dwLogsIndex,
            wszRLog, &dwSize, NULL, NULL, NULL, &ftLastWriteTime );
    } while( lResult != ERROR_NO_MORE_ITEMS );

    // close the logs registry key
    RegCloseKey( hLogsKey );
    hLogsKey = NULL;

    // check whether any error has occured or not in doing above tasks
    if ( bErrorOccurred == TRUE )
    {
        // close the still opened registry keys
        RegCloseKey( hKey );
        hKey = NULL;

        // return failure
        return FALSE;
    }

    // now check whether location for creating the event is found or not
    // if not, check for the possibilities to create the source at appropriate location
    // NOTE:-
    //        we won't create the logs. also to create the source, user needs to specify
    //        the log name in which this source needs to be created.
    if ( bFoundMatch == FALSE )
    {
        if ( bLog == TRUE && bLogMatched == FALSE )
        {
            // log itself was not found ... error message
            SetReason2( 1, ERROR_LOG_NOTEXISTS, pParams->pwszLogName );
        }
        else if ( bLog == TRUE && bSource == TRUE &&
                  bLogMatched == TRUE && bSourceMatched == FALSE )
        {
            //
            // log name and source both were supplied but only log was found
            // so create the source in it

            // open the "EventLogs\{logname}" registry key for creating new source
            // NOTE: we will make use of failure buffer to do the formatting
            if ( SetReason2( 2, L"%s\\%s",
                             EVENT_LOG_NAMES_LOCATION, pParams->pwszLogName ) == FALSE )
            {
                SaveLastError();
                return FALSE;
            }

            pwsz = GetReason();
            lResult = RegOpenKeyEx( hKey, pwsz, 0, KEY_WRITE, &hLogsKey );
            if ( lResult != ERROR_SUCCESS )
            {
                switch( lResult )
                {
                case ERROR_FILE_NOT_FOUND:
                    SetLastError( ERROR_REGISTRY_CORRUPT );
                    break;

                default:
                    // save the error information and return FAILURE
                    SetLastError( lResult );
                    break;
                }

                // close the key and return
                SaveLastError();
                RegCloseKey( hKey );
                return FALSE;
            }

            // now create the subkey with the source name given
            if ( AddEventSource( hLogsKey, pParams->pwszSource ) == FALSE )
            {
                RegCloseKey( hKey );
                RegCloseKey( hLogsKey );
                return FALSE;
            }

            // creation of new source is successfull
            bFoundMatch = TRUE;
            RegCloseKey( hSourcesKey );
            RegCloseKey( hLogsKey );

            // mark this as a custom event source
            bCustom = TRUE;
        }
        else if ( bLog == FALSE && bSource == TRUE && bSourceMatched == FALSE )
        {
            // else we need both log name and source in order to create the source
            SetReason( ERROR_NEED_LOG_ALSO );
        }
    }

    // check whether the source is custom create or pre-existing source
    if ( bFoundMatch == TRUE && bCustom == FALSE )
    {
        // we wont create events in a non-custom source
        SetReason( ERROR_NONCUSTOM_SOURCE );
        return FALSE;
    }

    // close the currently open registry keys
    RegCloseKey( hKey );

    // return the result
    return bFoundMatch;
}

// ***************************************************************************
// Routine Description:
//      This function adds a new source to under the specifie log
//
// Arguments:
//
// Return Value:
//      TRUE    : on success
//      FALSE   : on failure
// ***************************************************************************
BOOL AddEventSource( HKEY hLogsKey, LPCWSTR pwszSource )
{
    // local variables
    LONG lResult = 0;
    DWORD dwData = 0;
    DWORD dwLength = 0;
    DWORD dwDisposition = 0;
    HKEY hSourcesKey = NULL;
    LPWSTR pwszBuffer = NULL;

    // validate the inputs
    if ( hLogsKey == NULL || pwszSource == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return FALSE;
    }

    // set the name of the message file ( +2 == buffer )
    dwLength = StringLength( L"%SystemRoot%\\System32\\EventCreate.exe", 0 ) + 2;
    pwszBuffer = ( LPWSTR) AllocateMemory( dwLength * sizeof( WCHAR ) );
    if ( pwszBuffer == NULL )
    {
        // set the error and return
        SaveLastError();
        return FALSE;
    }

    // copy the required value into buffer
    StringCopy( pwszBuffer, L"%SystemRoot%\\System32\\EventCreate.exe", dwLength );

    // create the custom source
    lResult = RegCreateKeyEx( hLogsKey, pwszSource, 0, L"",
        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSourcesKey, &dwDisposition );
    if ( lResult != ERROR_SUCCESS )
    {
        SetLastError( lResult );
        SaveLastError();

        // free the allocated memory
        FreeMemory( &pwszBuffer );
        //return.
        return FALSE;
    }

    // add the name to the EventMessageFile subkey.
    lResult = RegSetValueEx( hSourcesKey, L"EventMessageFile",
        0, REG_EXPAND_SZ, (LPBYTE) pwszBuffer, dwLength * sizeof( WCHAR ) );
    if ( lResult != ERROR_SUCCESS )
    {
        // save the error
        SetLastError( lResult );
        SaveLastError();

        // release the memories allocated till this point
        RegCloseKey( hSourcesKey );
        hSourcesKey = NULL;

        // free the allocated memory
        FreeMemory( &pwszBuffer );

        // return
        return FALSE;
    }

    // set the supported event types in the TypesSupported subkey.
    dwData = EVENTLOG_SUCCESS | EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    lResult = RegSetValueEx( hSourcesKey,
        L"TypesSupported", 0, REG_DWORD, (LPBYTE) &dwData, sizeof( DWORD ) );
    if ( lResult != ERROR_SUCCESS )
    {
        // save the error
        SetLastError( lResult );
        SaveLastError();

        // release the memories allocated till this point
        RegCloseKey( hSourcesKey );
        hSourcesKey = NULL;

        // free the allocated memory
        FreeMemory( &pwszBuffer );

        // return
        return FALSE;
    }

    // mark this source as custom created source
    dwData = 1;
    lResult = RegSetValueEx( hSourcesKey,
        L"CustomSource", 0, REG_DWORD, (LPBYTE) &dwData, sizeof( DWORD ) );
    if ( lResult != ERROR_SUCCESS )
    {
        // save the error
        SetLastError( lResult );
        SaveLastError();

        // release the memories allocated till this point
        RegCloseKey( hSourcesKey );
        hSourcesKey = NULL;

        // free the allocated memory
        FreeMemory( &pwszBuffer );

        // return
        return FALSE;
    }

    // close the key
    RegCloseKey( hSourcesKey );

    // free the allocated memory
    FreeMemory( &pwszBuffer );

    // return success
    return TRUE;
}

BOOL ProcessOptions( LONG argc,
                     LPCWSTR argv[],
                     PTEVENTCREATE_PARAMS pParams, PBOOL pbNeedPwd )
/*++
 Routine Description:
        This function parses the options specified at the command prompt

 Arguments:
        [ in  ] argc            -   count of elements in argv
        [ in  ] argv            -   command-line parameterd specified by the user
        [ out ] pbNeedPwd       -   sets to TRUE if -s exists without -p in 'argv'

 Return Value:
        TRUE        -   the parsing is successful
        FALSE       -   errors occured in parsing
--*/
{
    // local variables
    PTCMDPARSER2 pcmdOption = NULL;
    TCMDPARSER2 cmdOptions[ MAX_OPTIONS ];

    //
    // prepare the command options
    SecureZeroMemory( cmdOptions, sizeof( TCMDPARSER2 ) * MAX_OPTIONS );

    // -?
    pcmdOption = &cmdOptions[ OI_HELP ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->pValue = &pParams->bUsage;
    pcmdOption->pwszOptions = OPTION_HELP;

    // -s
    pcmdOption = &cmdOptions[ OI_SERVER ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_SERVER;

    // -u
    pcmdOption = &cmdOptions[ OI_USERNAME ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_USERNAME;

    // -p
    pcmdOption = &cmdOptions[ OI_PASSWORD ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_PASSWORD;

    // -log
    pcmdOption = &cmdOptions[ OI_LOG ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_LOG;

    // -type
    pcmdOption = &cmdOptions[ OI_TYPE ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_MODE_VALUES | CP2_ALLOCMEMORY |
        CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszValues = OVALUES_TYPE;
    pcmdOption->pwszOptions = OPTION_TYPE;

    // -source
    pcmdOption = &cmdOptions[ OI_SOURCE ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_SOURCE;

    // -id
    pcmdOption = &cmdOptions[ OI_ID ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->pValue = &pParams->dwEventID;
    pcmdOption->pwszOptions = OPTION_ID;

    // -description
    pcmdOption = &cmdOptions[ OI_DESCRIPTION ];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_MANDATORY | CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_DESCRIPTION;

    //
    // do the parsing
    if ( DoParseParam2( argc, argv, -1, MAX_OPTIONS, cmdOptions, 0 ) == FALSE )
    {
        return FALSE;           // invalid syntax
    }

    //
    // now, check the mutually exclusive options

    // check the usage option
    if ( pParams->bUsage == TRUE  )
    {
        if ( argc > 2 )
        {
            // no other options are accepted along with -? option
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason( ERROR_INVALID_USAGE_REQUEST );
            return FALSE;
        }
        else
        {
            // no need of furthur checking of the values
            return TRUE;
        }
    }

    // validate the range of the event id specified
    if ( pParams->dwEventID < MSG_EVENTID_START ||
         pParams->dwEventID >= MSG_EVENTID_END )
    {
        SetReason2( 2, ERROR_ID_OUTOFRANGE, MSG_EVENTID_START, MSG_EVENTID_END - 1 );
        SetLastError( (DWORD) MK_E_SYNTAX );
        return FALSE;
    }

    // get the buffer pointers allocated by command line parser
    pParams->pwszType = cmdOptions[ OI_TYPE ].pValue;
    pParams->pwszLogName = cmdOptions[ OI_LOG ].pValue;
    pParams->pwszSource = cmdOptions[ OI_SOURCE ].pValue;
    pParams->pwszServer = cmdOptions[ OI_SERVER ].pValue;
    pParams->pwszUserName = cmdOptions[ OI_USERNAME ].pValue;
    pParams->pwszPassword = cmdOptions[ OI_PASSWORD ].pValue;
    pParams->pwszDescription = cmdOptions[ OI_DESCRIPTION ].pValue;

    // "-u" should not be specified without "-s"
    if ( pParams->pwszUserName != NULL && pParams->pwszServer == NULL )
    {
        // invalid syntax
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason( ERROR_USERNAME_BUT_NOMACHINE );
        return FALSE;           // indicate failure
    }

    // "-p" should not be specified without "-u"
    if ( pParams->pwszPassword != NULL && pParams->pwszUserName == NULL )
    {
        // invalid syntax
        SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
        return FALSE;           // indicate failure
    }

    // check the remote connectivity information
    if ( pParams->pwszServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( pParams->pwszUserName == NULL )
        {
            pParams->dwUserNameLength = MAX_STRING_LENGTH;
            pParams->pwszUserName = AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( pParams->pwszUserName == NULL )
            {
                SaveLastError();
                return FALSE;
            }
        }
        else
        {
            pParams->dwUserNameLength = StringLength( pParams->pwszUserName, 0 ) + 1;
        }

        // password
        if ( pParams->pwszPassword == NULL )
        {
            *pbNeedPwd = TRUE;
            pParams->dwPasswordLength = MAX_STRING_LENGTH;
            pParams->pwszPassword = AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( pParams->pwszPassword == NULL )
            {
                SaveLastError();
                return FALSE;
            }
        }

        // case 1
        if ( cmdOptions[ OI_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdOptions[ OI_PASSWORD ].pValue == NULL )
        {
            StringCopy( pParams->pwszPassword, L"*", pParams->dwPasswordLength );
        }

        // case 3
        else if ( StringCompareEx( pParams->pwszPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( &pParams->pwszPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                return FALSE;
            }

            // ...
            *pbNeedPwd = TRUE;
            pParams->dwPasswordLength = MAX_STRING_LENGTH;
        }
    }

    // either -source (or) -log must be specified ( both can also be specified )
    if ( pParams->pwszSource == NULL && pParams->pwszLogName == NULL )
    {
        // if log name and application were not specified, we will set to defaults
        pParams->pwszLogName = g_wszDefaultLog;
        pParams->pwszSource = g_wszDefaultSource;
    }

    // if log is "application" and source is not specified, even then we
    // will default the source to "EventCreate"
    else if ( pParams->pwszSource == NULL &&
              pParams->pwszLogName != NULL &&
              StringCompareEx( pParams->pwszLogName, g_wszDefaultLog, TRUE, 0 ) == 0 )
    {
        pParams->pwszSource = g_wszDefaultSource;
    }

    // block the user to create events in security log
    if ( pParams->pwszLogName != NULL &&
         StringCompare( pParams->pwszLogName, L"security", TRUE, 0 ) == 0 )
    {
        SetReason( ERROR_LOG_CANNOT_BE_SECURITY );
        return FALSE;
    }

    // determine the actual event type
    if ( StringCompareEx( pParams->pwszType, LOGTYPE_ERROR, TRUE, 0 ) == 0 )
    {
        pParams->wEventType = EVENTLOG_ERROR_TYPE;
    }
    else if ( StringCompareEx( pParams->pwszType, LOGTYPE_SUCCESS, TRUE, 0 ) == 0 )
    {
        pParams->wEventType = EVENTLOG_SUCCESS;
    }
    else if ( StringCompareEx( pParams->pwszType, LOGTYPE_WARNING, TRUE, 0 ) == 0 )
    {
        pParams->wEventType = EVENTLOG_WARNING_TYPE;
    }
    else if ( StringCompareEx( pParams->pwszType, LOGTYPE_INFORMATION, TRUE, 0 ) == 0 )
    {
        pParams->wEventType = EVENTLOG_INFORMATION_TYPE;
    }

    // command-line parsing is successfull
    return TRUE;
}


BOOL
Usage()
/*++
 Routine Description:

 Arguments:

 Return Value:

--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = ID_USAGE_START; dw <= ID_USAGE_END; dw++ )
    {
        ShowMessage( stdout, GetResString( dw ) );
    }

    // return
    return TRUE;
}


BOOL
UnInitializeGlobals( PTEVENTCREATE_PARAMS pParams )
/*++
 Routine Description:

 Arguments:

 Return Value:

--*/
{
    // close the connection -- if needed
    if ( pParams->bCloseConnection == TRUE )
    {
        CloseConnection( pParams->pwszServer );
    }

    //
    // NOTE: FreeMemory will clear the contents of the
    //       password buffer -- since it will be duplicated
    //

    // release the memory allocated
    FreeMemory( &pParams->pwszServer );
    FreeMemory( &pParams->pwszUserName );
    FreeMemory( &pParams->pwszPassword );
    FreeMemory( &pParams->pwszType );
    FreeMemory( &pParams->pwszDescription );

    //
    // check the pointers -- if it is not pointing to constant pointer
    // then only release it
    //

    if ( pParams->pwszLogName != g_wszDefaultLog )
    {
        FreeMemory( &pParams->pwszLogName );
    }

    if ( pParams->pwszSource != g_wszDefaultSource )
    {
        FreeMemory( &pParams->pwszSource );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventcreate\eventcreate.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  Module Name:
//
//    EventCreate.h
//
//  Abstract:
//
//    macros and prototypes of eventcreate.c
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//
// *********************************************************************************
#ifndef __EVENTCREATE_H
#define __EVENTCREATE_H

// include resource header
#include "resource.h"

//
// type definitions
//

//
// constants / defines / enumerators
//

// general purpose macros
#define EXIT_PROCESS( exitcode )    \
    ReleaseGlobals();   \
    return exitcode;    \
    1

//
// command line options and their indexes in the array
#define MAX_OPTIONS         9

// supported options ( do not localize )
#define OPTION_HELP         L"?"                      // 1
#define OPTION_SERVER       L"s"                      // 2
#define OPTION_USERNAME     L"u"                      // 3
#define OPTION_PASSWORD     L"p"                      // 4
#define OPTION_LOG          L"l"                      // 5
#define OPTION_TYPE         L"t"                      // 6
#define OPTION_SOURCE       L"so"                     // 7
#define OPTION_ID           L"id"                     // 8
#define OPTION_DESCRIPTION  L"d"                      // 9

// indexes
#define OI_HELP             0
#define OI_SERVER           1
#define OI_USERNAME         2
#define OI_PASSWORD         3
#define OI_LOG              4
#define OI_TYPE             5
#define OI_SOURCE           6
#define OI_ID               7
#define OI_DESCRIPTION      8

// values supported by 'type' option
#define OVALUES_TYPE        GetResString2( IDS_OVALUES_LOGTYPE, 2 )

//
// others
#define LOGTYPE_ERROR           GetResString2( IDS_LOGTYPE_ERROR, 0 )
#define LOGTYPE_WARNING         GetResString2( IDS_LOGTYPE_WARNING, 0 )
#define LOGTYPE_INFORMATION     GetResString2( IDS_LOGTYPE_INFORMATION, 0 )
#define LOGTYPE_SUCCESS         GetResString2( IDS_LOGTYPE_SUCCESS, 0 )

// error messages
#define ERROR_USERNAME_BUT_NOMACHINE    GetResString2( IDS_ERROR_USERNAME_BUT_NOMACHINE, 0 )
#define ERROR_PASSWORD_BUT_NOUSERNAME   GetResString2( IDS_ERROR_PASSWORD_BUT_NOUSERNAME, 0 )
#define ERROR_INVALID_EVENT_ID          GetResString2( IDS_ERROR_INVALID_EVENT_ID, 0 )
#define ERROR_DESCRIPTION_IS_EMPTY      GetResString2( IDS_ERROR_DESCRIPTION_IS_EMPTY, 0 )
#define ERROR_LOGSOURCE_IS_EMPTY        GetResString2( IDS_ERROR_LOGSOURCE_IS_EMPTY, 0 )
#define ERROR_LOG_SOURCE_BOTH_MISSING   GetResString2( IDS_ERROR_LOG_SOURCE_BOTH_MISSING, 0 )
#define ERROR_LOG_NOTEXISTS             GetResString2( IDS_ERROR_LOG_NOTEXISTS, 0 )
#define ERROR_NEED_LOG_ALSO             GetResString2( IDS_ERROR_NEED_LOG_ALSO, 0 )
#define ERROR_SOURCE_DUPLICATING        GetResString2( IDS_ERROR_SOURCE_DUPLICATING, 0 )
#define ERROR_USERNAME_EMPTY            GetResString2( IDS_ERROR_USERNAME_EMPTY, 0 )
#define ERROR_INVALID_USAGE_REQUEST     GetResString2( IDS_ERROR_INVALID_USAGE_REQUEST, 0 )
#define ERROR_SYSTEM_EMPTY              GetResString2( IDS_ERROR_SYSTEM_EMPTY, 0 )
#define ERROR_ID_OUTOFRANGE             GetResString2( IDS_ERROR_ID_OUTOFRANGE, 0 )
#define ERROR_NONCUSTOM_SOURCE          GetResString2( IDS_ERROR_NONCUSTOM_SOURCE, 0 )
#define ERROR_LOG_CANNOT_BE_SECURITY    GetResString2( IDS_ERROR_LOG_CANNOT_BE_SECURITY, 0 )

#define MSG_SUCCESS             GetResString2( IDS_EVENTCREATE_SUCCESS_BOTH, 0 )
#define MSG_SUCCESS_LOG         GetResString2( IDS_EVENTCREATE_SUCCESS_LOG, 0 )
#define MSG_SUCCESS_SOURCE      GetResString2( IDS_EVENTCREATE_SUCCESS_SOURCE, 0 )

#endif // __EVENTCREATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventcreate\resource.h ===
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
#define IDS_LOGTYPE_ERROR                       101
#define IDS_LOGTYPE_WARNING                     102
#define IDS_LOGTYPE_INFORMATION                 103
#define IDS_LOGTYPE_SUCCESS                     104
#define IDS_OVALUES_LOGTYPE                     106

#define IDS_EVENTCREATE_SUCCESS_LOG             150
#define IDS_EVENTCREATE_SUCCESS_SOURCE          151
#define IDS_EVENTCREATE_SUCCESS_BOTH            152
#define IDS_ERROR_LOG_NOTEXISTS                 153
#define IDS_ERROR_USERNAME_BUT_NOMACHINE        154
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME       155
#define IDS_ERROR_INVALID_EVENT_ID              156
#define IDS_ERROR_DESCRIPTION_IS_EMPTY          157
#define IDS_ERROR_LOGSOURCE_IS_EMPTY            158
#define IDS_ERROR_LOG_SOURCE_BOTH_MISSING       159
#define IDS_ERROR_NEED_LOG_ALSO                 160
#define IDS_ERROR_SOURCE_DUPLICATING            161
#define IDS_ERROR_USERNAME_EMPTY                162
#define IDS_ERROR_INVALID_USAGE_REQUEST         163
#define IDS_ERROR_SYSTEM_EMPTY                  164
#define IDS_ERROR_ID_OUTOFRANGE                 165
#define IDS_ERROR_NONCUSTOM_SOURCE              166
#define IDS_ERROR_LOG_CANNOT_BE_SECURITY        167

#define IDS_USAGE_SYNTAX1               1001
#define IDS_USAGE_SYNTAX2               1002
#define IDS_USAGE_NEWLINE1              1003
#define IDS_USAGE_DESC1                 1004
#define IDS_USAGE_DESC2                 1005
#define IDS_USAGE_DESC3                 1006
#define IDS_USAGE_NEWLINE2              1007
#define IDS_USAGE_PARAMLIST             1008
#define IDS_USAGE_PARAMLIST1            1009
#define IDS_USAGE_PARAMLIST2            1010
#define IDS_USAGE_PARAMLIST3            1011
#define IDS_USAGE_PARAMLIST4            1012
#define IDS_USAGE_PARAMLIST5            1013
#define IDS_USAGE_PARAMLIST6            1014
#define IDS_USAGE_PARAMLIST7            1015
#define IDS_USAGE_PARAMLIST8            1016
#define IDS_USAGE_PARAMLIST9            1017
#define IDS_USAGE_PARAMLIST10           1018
#define IDS_USAGE_PARAMLIST11           1019
#define IDS_USAGE_PARAMLIST12           1020
#define IDS_USAGE_PARAMLIST13           1021
#define IDS_USAGE_PARAMLIST14           1022
#define IDS_USAGE_PARAMLIST15           1023
#define IDS_USAGE_PARAMLIST16           1024
#define IDS_USAGE_PARAMLIST17           1025
#define IDS_USAGE_PARAMLIST18           1026
#define IDS_USAGE_PARAMLIST19           1027
#define IDS_USAGE_PARAMLIST20           1028
#define IDS_USAGE_NEWLINE3              1029
#define IDS_USAGE_EXAMPLES              1030
#define IDS_USAGE_EXAMPLE11             1031
#define IDS_USAGE_EXAMPLE12             1032
#define IDS_USAGE_EXAMPLE21             1033
#define IDS_USAGE_EXAMPLE22             1034
#define IDS_USAGE_EXAMPLE31             1035
#define IDS_USAGE_EXAMPLE32             1036
#define IDS_USAGE_EXAMPLE41             1037
#define IDS_USAGE_EXAMPLE42             1038
#define IDS_USAGE_EXAMPLE51             1039
#define IDS_USAGE_EXAMPLE52             1040
#define IDS_USAGE_EXAMPLE61             1041
#define IDS_USAGE_EXAMPLE62             1042
#define IDS_USAGE_EXAMPLE71             1043
#define IDS_USAGE_EXAMPLE72             1044

// NOTE: Be careful when defining this information
//       The help should be given in consecutive lines
#define ID_USAGE_START  IDS_USAGE_SYNTAX1
#define ID_USAGE_END    IDS_USAGE_EXAMPLE72
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\etcreate.cpp ===
/******************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    ETCreate.CPP

Abstract:

  This module  is intended to have the functionality for EVENTTRIGGERS.EXE
  with -create parameter.

  This will Create Event Triggers in local / remote system.

Author:
     Akhil Gokhale 03-Oct.-2000  (Created it)

Revision History:

******************************************************************************/
#include "pch.h"
#include "ETCommon.h"
#include "resource.h"
#include "ShowError.h"
#include "ETCreate.h"
#include "WMI.h"
#include <Lmcons.h>
#define NTAUTHORITY_USER L"NT AUTHORITY\\SYSTEM"
#define SYSTEM_USER      L"SYSTEM"

CETCreate::CETCreate()
/*++
 Routine Description:
      Class constructor

 Arguments:
      None
 Return Value:
      None
--*/
{
    m_pszServerName         = NULL;
    m_pszUserName           = NULL;
    m_pszPassword           = NULL;
    m_arrLogNames           = NULL;
    m_pszRunAsUserName      = NULL;
    m_pszRunAsUserPassword  = NULL;

    m_bNeedPassword     = FALSE;
    m_bCreate           = FALSE;

    m_bIsCOMInitialize  = FALSE;

    m_lMinMemoryReq     = 0;

    m_pWbemLocator      = NULL;
    m_pWbemServices     = NULL;
    m_pEnumObjects      = NULL;
    m_pAuthIdentity     = NULL;
    m_pClass            = NULL;
    m_pOutInst          = NULL;
    m_pInClass          = NULL;
    m_pInInst           = NULL;
    bstrTemp            = NULL;
    m_pEnumWin32_NTEventLogFile = NULL;
}

CETCreate::CETCreate(
    LONG lMinMemoryReq,
    BOOL bNeedPassword
    )
/*++
 Routine Description:
      Class constructor

 Arguments:
      None
 Return Value:
      None

--*/
{
    m_pszServerName     = NULL;
    m_pszUserName       = NULL;
    m_pszPassword       = NULL;
    m_arrLogNames       = NULL;
    m_bCreate           = FALSE;
    m_dwID              = 0;
    m_pszRunAsUserName      = NULL;
    m_pszRunAsUserPassword  = NULL;

    m_bIsCOMInitialize  = FALSE;

    m_pWbemLocator      = NULL;
    m_pWbemServices     = NULL;
    m_pEnumObjects      = NULL;
    m_pAuthIdentity     = NULL;

    m_pClass            = NULL;
    m_pOutInst          = NULL;
    m_pInClass          = NULL;
    m_pInInst           = NULL;

    bstrTemp            = NULL;
    m_lMinMemoryReq     = lMinMemoryReq;
    m_pEnumWin32_NTEventLogFile = NULL;
    m_bNeedPassword = bNeedPassword;
}

CETCreate::~CETCreate()
/*++
 Routine Description:
      Class destructor

 Arguments:
      None
 Return Value:
      None

--*/
{
   // Release all memory which is allocated.
    FreeMemory((LPVOID*)& m_pszServerName);
    FreeMemory((LPVOID*)& m_pszUserName);
    FreeMemory((LPVOID*)& m_pszPassword);
    FreeMemory((LPVOID*)& m_pszRunAsUserName);
    FreeMemory((LPVOID*)& m_pszRunAsUserPassword);
    DESTROY_ARRAY(m_arrLogNames);

    SAFE_RELEASE_INTERFACE(m_pWbemLocator);
    SAFE_RELEASE_INTERFACE(m_pWbemServices);
    SAFE_RELEASE_INTERFACE(m_pEnumObjects);
    SAFE_RELEASE_INTERFACE(m_pClass);
    SAFE_RELEASE_INTERFACE(m_pOutInst);
    SAFE_RELEASE_INTERFACE(m_pInClass);
    SAFE_RELEASE_INTERFACE(m_pInInst);
    SAFE_RELEASE_INTERFACE(m_pEnumWin32_NTEventLogFile);

    // Release Authority
    WbemFreeAuthIdentity(&m_pAuthIdentity);

    // Uninitialize COM only if it is initialized.
    if( TRUE == m_bIsCOMInitialize )
    {
        CoUninitialize();
    }

}

void
CETCreate::Initialize()
/*++
 Routine Description:
      Allocates and initialize variables.

 Arguments:
      NONE

 Return Value:
      NONE

--*/
{

    // if at all any occurs, we know that is 'coz of the
    // failure in memory allocation ... so set the error
    DEBUG_INFO;
    SetLastError( ERROR_OUTOFMEMORY );
    SaveLastError();
    SecureZeroMemory(m_szWMIQueryString,sizeof(m_szWMIQueryString));
    SecureZeroMemory(m_szTaskName,sizeof(m_szTaskName));
    SecureZeroMemory(m_szTriggerName,sizeof(m_szTriggerName));
    SecureZeroMemory(m_szDescription,sizeof(m_szDescription));
    SecureZeroMemory(m_szType,sizeof(m_szType));
    SecureZeroMemory(m_szSource,sizeof(m_szSource));

    m_arrLogNames = CreateDynamicArray();
    if( NULL == m_arrLogNames )
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    SecureZeroMemory(cmdOptions,sizeof(TCMDPARSER2) * MAX_COMMANDLINE_C_OPTION);

    // initialization is successful
    SetLastError( NOERROR );            // clear the error
    SetReason( L"");           // clear the reason
    DEBUG_INFO;
    return;
}

void
CETCreate::ProcessOption(
    DWORD argc,
    LPCTSTR argv[]
    )
/*++
 Routine Description:
      This function will process/parce the command line options.

 Arguments:
      [ in ] argc     : argument(s) count specified at the command prompt
      [ in ] argv     : argument(s) specified at the command prompt

 Return Value:
       none
--*/
{
    // local variable
    BOOL bReturn = TRUE;
    CHString szTempString;
    DEBUG_INFO;
    PrepareCMDStruct();
    DEBUG_INFO;
    // do the actual parsing of the command line arguments and check the result
    bReturn = DoParseParam2( argc, argv,ID_C_CREATE,MAX_COMMANDLINE_C_OPTION, cmdOptions,0);

    // Take values from 'cmdOptions' structure
    m_pszServerName = (LPWSTR)cmdOptions[ ID_C_SERVER ].pValue;
    m_pszUserName   = (LPWSTR)cmdOptions[ ID_C_USERNAME ].pValue;
    m_pszPassword   = (LPWSTR)cmdOptions[ ID_C_PASSWORD ].pValue;
    m_pszRunAsUserName  = (LPWSTR)cmdOptions[ ID_C_RU ].pValue;
    m_pszRunAsUserPassword  = (LPWSTR)cmdOptions[ ID_C_RP ].pValue;
    if(FALSE == bReturn )
    {
        DEBUG_INFO;
        throw CShowError(MK_E_SYNTAX);
    }
    DEBUG_INFO;
    CHString str = m_szTriggerName;

    if (-1 != str.FindOneOf(INVALID_TRIGGER_NAME_CHARACTERS))
    {
        DEBUG_INFO;
        throw CShowError(IDS_ID_INVALID_TRIG_NAME);
    }
    DEBUG_INFO;

    // At least any of -so , -t OR -i should be given .
    if((0 == cmdOptions[ ID_C_SOURCE].dwActuals ) &&
       (0 == cmdOptions[ ID_C_TYPE].dwActuals   ) &&
       (0 == cmdOptions[ ID_C_ID ].dwActuals    ))
    {
           throw CShowError(IDS_ID_TYPE_SOURCE);
    }

   // Trigger ID (/EID) should not be ZERO.
    if ( (1 == cmdOptions[ ID_C_ID ].dwActuals) && (0 == m_dwID))
    {
        throw CShowError(IDS_TRIGGER_ID_NON_ZERO);
    }

    // "-u" should not be specified without "-s"
    if ( 0 == cmdOptions[ ID_C_SERVER ].dwActuals  &&
         0 != cmdOptions[ ID_C_USERNAME ].dwActuals  )
    {
        throw CShowError(IDS_ERROR_USERNAME_BUT_NOMACHINE);
    }

    // "-p" should not be specified without -u
    if ( ( 0 == cmdOptions[ID_C_USERNAME].dwActuals ) &&
         ( 0 != cmdOptions[ID_C_PASSWORD].dwActuals ))
    {
        // invalid syntax
        throw CShowError(IDS_USERNAME_REQUIRED);
    }

    // "-rp" should not be specified without -ru
    if (( 0 == cmdOptions[ID_C_RU].dwActuals ) &&
        ( 0 != cmdOptions[ID_C_RP].dwActuals ))
    {
        // invalid syntax
        throw CShowError(IDS_RUN_AS_USERNAME_REQUIRED);
    }

    // added on 06/12/02 if /rp is given without any value set it to *
	if( ( 0 != cmdOptions[ID_C_RP].dwActuals ) && 
		( NULL == cmdOptions[ID_C_RP].pValue ) )
	{
	  if ( m_pszRunAsUserPassword == NULL )
        {
            m_pszRunAsUserPassword = (LPTSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( m_pszRunAsUserPassword == NULL )
            {
                DEBUG_INFO;
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }
        }
		StringCopy( m_pszRunAsUserPassword, L"*", SIZE_OF_DYN_ARRAY(m_pszRunAsUserPassword));
	}		

    // check the remote connectivity information
    if ( m_pszServerName != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        DEBUG_INFO;
        if ( m_pszUserName == NULL )
        {
           DEBUG_INFO;
            m_pszUserName = (LPTSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( m_pszUserName == NULL )
            {
               DEBUG_INFO;
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }
        }

        // password
        DEBUG_INFO;
        if ( m_pszPassword == NULL )
        {
            m_bNeedPassword = TRUE;
            m_pszPassword = (LPTSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( m_pszPassword == NULL )
            {
                DEBUG_INFO;
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }
        }

        // case 1
        if ( cmdOptions[ ID_C_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdOptions[ ID_C_PASSWORD ].pValue == NULL )
        {
            StringCopy( m_pszPassword, L"*", SIZE_OF_DYN_ARRAY(m_pszPassword));
        }

        // case 3
        else if ( StringCompare( m_pszPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&m_pszPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }

            // ...
            m_bNeedPassword = TRUE;
            DEBUG_INFO;
        }
    }
}

void
CETCreate::PrepareCMDStruct()
/*++
 Routine Description:
      This function will prepare column structure for DoParseParam Function.

 Arguments:
       none
 Return Value:
       none
--*/
{
     DEBUG_INFO;
    // Filling cmdOptions structure
   // -create
    StringCopyA( cmdOptions[ ID_C_CREATE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_CREATE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_C_CREATE ].pwszOptions = szCreateOption;
    cmdOptions[ ID_C_CREATE ].dwCount = 1;
    cmdOptions[ ID_C_CREATE ].dwActuals = 0;
    cmdOptions[ ID_C_CREATE ].dwFlags = 0;
    cmdOptions[ ID_C_CREATE ].pValue = &m_bCreate;
    cmdOptions[ ID_C_CREATE ].dwLength    = 0;


    // -s (servername)
    StringCopyA( cmdOptions[ ID_C_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_SERVER ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_SERVER ].pwszOptions = szServerNameOption;
    cmdOptions[ ID_C_SERVER ].dwCount = 1;
    cmdOptions[ ID_C_SERVER ].dwActuals = 0;
    cmdOptions[ ID_C_SERVER ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_C_SERVER ].pValue = NULL; //m_pszServerName
    cmdOptions[ ID_C_SERVER ].dwLength    = 0;

    // -u (username)
    StringCopyA( cmdOptions[ ID_C_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_USERNAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_USERNAME ].pwszOptions = szUserNameOption;
    cmdOptions[ ID_C_USERNAME ].dwCount = 1;
    cmdOptions[ ID_C_USERNAME ].dwActuals = 0;
    cmdOptions[ ID_C_USERNAME ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_C_USERNAME ].pValue = NULL; //m_pszUserName
    cmdOptions[ ID_C_USERNAME ].dwLength    = 0;

    // -p (password)
    StringCopyA( cmdOptions[ ID_C_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_PASSWORD ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_PASSWORD ].pwszOptions = szPasswordOption;
    cmdOptions[ ID_C_PASSWORD ].dwCount = 1;
    cmdOptions[ ID_C_PASSWORD ].dwActuals = 0;
    cmdOptions[ ID_C_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    cmdOptions[ ID_C_PASSWORD ].pValue = NULL; //m_pszPassword
    cmdOptions[ ID_C_PASSWORD ].dwLength    = 0;

    // -tr
    StringCopyA( cmdOptions[ ID_C_TRIGGERNAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_TRIGGERNAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_TRIGGERNAME ].pwszOptions = szTriggerNameOption;
    cmdOptions[ ID_C_TRIGGERNAME ].dwCount = 1;
    cmdOptions[ ID_C_TRIGGERNAME ].dwActuals = 0;
    cmdOptions[ ID_C_TRIGGERNAME ].dwFlags = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL
                                            |CP2_MANDATORY;
    cmdOptions[ ID_C_TRIGGERNAME ].pValue = m_szTriggerName;
    cmdOptions[ ID_C_TRIGGERNAME ].dwLength = MAX_TRIGGER_NAME;


    //-l
    StringCopyA( cmdOptions[ ID_C_LOGNAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_LOGNAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_LOGNAME ].pwszOptions = szLogNameOption;
    cmdOptions[ ID_C_LOGNAME ].dwCount = 0;
    cmdOptions[ ID_C_LOGNAME ].dwActuals = 0;
    cmdOptions[ ID_C_LOGNAME ].dwFlags = CP2_MODE_ARRAY|CP2_VALUE_TRIMINPUT|
                                         CP2_VALUE_NONULL|CP2_VALUE_NODUPLICATES;
    cmdOptions[ ID_C_LOGNAME ].pValue = &m_arrLogNames;
    cmdOptions[ ID_C_LOGNAME ].dwLength    = 0;

    //  -eid
    StringCopyA( cmdOptions[ ID_C_ID ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_ID ].dwType = CP_TYPE_UNUMERIC;
    cmdOptions[ ID_C_ID ].pwszOptions = szEIDOption;
    cmdOptions[ ID_C_ID ].dwCount = 1;
    cmdOptions[ ID_C_ID ].dwActuals = 0;
    cmdOptions[ ID_C_ID ].dwFlags = 0;
    cmdOptions[ ID_C_ID ].pValue = &m_dwID;

    // -t (type)
    StringCopyA( cmdOptions[ ID_C_TYPE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_TYPE ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_TYPE ].pwszOptions = szTypeOption;
    cmdOptions[ ID_C_TYPE ].pwszValues = GetResString(IDS_TYPE_OPTIONS);
    cmdOptions[ ID_C_TYPE ].dwCount = 1;
    cmdOptions[ ID_C_TYPE ].dwActuals = 0;
    cmdOptions[ ID_C_TYPE ].dwFlags = CP2_VALUE_TRIMINPUT|
                                      CP2_VALUE_NONULL|CP2_MODE_VALUES;
    cmdOptions[ ID_C_TYPE ].pValue = m_szType;
    cmdOptions[ ID_C_TYPE ].dwLength  = MAX_STRING_LENGTH;

    // -so (source)
    StringCopyA( cmdOptions[ ID_C_SOURCE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_SOURCE ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_SOURCE ].pwszOptions = szSource;
    cmdOptions[ ID_C_SOURCE ].dwCount = 1;
    cmdOptions[ ID_C_SOURCE ].dwActuals = 0;
    cmdOptions[ ID_C_SOURCE ].dwFlags = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_C_SOURCE ].pValue = m_szSource;
    cmdOptions[ ID_C_SOURCE ].dwLength    = MAX_STRING_LENGTH;


    // -d (description)
    StringCopyA( cmdOptions[ ID_C_DESCRIPTION ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_DESCRIPTION ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_DESCRIPTION ].pwszOptions = szDescriptionOption;
    cmdOptions[ ID_C_DESCRIPTION ].dwCount = 1;
    cmdOptions[ ID_C_DESCRIPTION ].dwActuals = 0;
    cmdOptions[ ID_C_DESCRIPTION ].dwFlags = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_C_DESCRIPTION ].pValue = m_szDescription;
    cmdOptions[ ID_C_DESCRIPTION ].dwLength    = MAX_STRING_LENGTH;


    // -tk (task)
    StringCopyA( cmdOptions[ ID_C_TASK ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_TASK ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_TASK ].pwszOptions = szTaskNameOption;
    cmdOptions[ ID_C_TASK ].dwCount = 1;
    cmdOptions[ ID_C_TASK ].dwActuals = 0;
    cmdOptions[ ID_C_TASK ].dwFlags = CP2_VALUE_NONULL|CP2_MANDATORY;
    cmdOptions[ ID_C_TASK ].pValue = m_szTaskName;
    cmdOptions[ ID_C_TASK ].dwLength = MAX_TASK_NAME;

    // -ru (RunAsUserName)
    StringCopyA( cmdOptions[ ID_C_RU ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_RU ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_RU ].pwszOptions = szRunAsUserNameOption;
    cmdOptions[ ID_C_RU ].dwCount = 1;
    cmdOptions[ ID_C_RU ].dwActuals = 0;
    cmdOptions[ ID_C_RU ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT;
    cmdOptions[ ID_C_RU ].pValue = NULL; //m_pszRunAsUserName
    cmdOptions[ ID_C_RU ].dwLength    = 0;

    // -rp (Run As User password)
    StringCopyA( cmdOptions[ ID_C_RP ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_C_RP ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_C_RP ].pwszOptions = szRunAsPasswordOption;
    cmdOptions[ ID_C_RP ].dwCount = 1;
    cmdOptions[ ID_C_RP ].dwActuals = 0;
    cmdOptions[ ID_C_RP ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    cmdOptions[ ID_C_RP ].pValue = NULL; //m_pszRunAsUserPassword
    cmdOptions[ ID_C_RP ].dwLength    = 0;
    DEBUG_INFO;
}

BOOL
CETCreate::ExecuteCreate()
/*++
 Routine Description:
      This routine will actualy creates eventtrigers in WMI.

 Arguments:
      None
 Return Value:
      None

--*/
{
    // local variables...
    BOOL bResult = FALSE;// Stores return status of function
    HRESULT hr = 0; // Stores return code.
    try
    {
        DEBUG_INFO;
        // Initialize COM
        InitializeCom(&m_pWbemLocator);

        // make m_bIsCOMInitialize to true which will be useful when
        // uninitialize COM.
        m_bIsCOMInitialize = TRUE;
        {
            // brackets used to restrict scope of following declered variables.
            CHString szTempUser = m_pszUserName; // Temp. variabe to store user
                                                // name.
            CHString szTempPassword = m_pszPassword;// Temp. variable to store
                                                    // password.
            m_bLocalSystem = TRUE;

            // Connect remote / local WMI.
            DEBUG_INFO;
            bResult = ConnectWmiEx( m_pWbemLocator,
                                    &m_pWbemServices,
                                    m_pszServerName,
                                    szTempUser,
                                    szTempPassword,
                                    &m_pAuthIdentity,
                                    m_bNeedPassword,
                                    WMI_NAMESPACE_CIMV2,
                                    &m_bLocalSystem);
            if( FALSE == bResult)
            {
                DEBUG_INFO;
                ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
                return FALSE;
            }
            AssignMinMemory();

            // Initialize. Required for XP version check. 5001
            bResult = FALSE;
            // check the remote system version and its compatiblity
            if ( FALSE == m_bLocalSystem )
            {
                DEBUG_INFO;
                DWORD dwVersion = 0;
                dwVersion = GetTargetVersionEx( m_pWbemServices,
                                                m_pAuthIdentity);
                if ( dwVersion <= 5000 )// to block win2k versions
                {
                    SetReason( E_REMOTE_INCOMPATIBLE );
                    ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
                    return FALSE;
                }
                // If remote system is a XP system then
                // have to take different route to accomplish the task.
                // Set boolean to TRUE.
                if( 5001 == dwVersion )
                {
                    bResult = TRUE;
                }
            }

            // check the local credentials and if need display warning
            DEBUG_INFO;
            if ( m_bLocalSystem && ( 0 != StringLength(m_pszUserName,0)) )
            {
                WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
                ShowLastErrorEx(stderr,SLE_TYPE_WARNING|SLE_INTERNAL);
            }

            if(0!= szTempUser.GetAllocLength())
            {
                DEBUG_INFO;
                LONG lSize = SIZE_OF_DYN_ARRAY(m_pszUserName);
                if (NULL == m_pszUserName ||
                   (lSize< (szTempUser.GetAllocLength())))
                {
                    DEBUG_INFO;
                    if ( ReallocateMemory( (LPVOID*)&m_pszUserName,
                                       (szTempUser.GetAllocLength()* sizeof( WCHAR ))+1 ) == FALSE )
                    {
                        DEBUG_INFO;
                        SaveLastError();
                        throw CShowError(E_OUTOFMEMORY);
                    }

                }
            }
            DEBUG_INFO;
            if(0 != szTempPassword.GetAllocLength())
            {
                DEBUG_INFO;
                LONG lSize = SIZE_OF_DYN_ARRAY(m_pszUserName);
                if (NULL == m_pszUserName || (lSize< szTempPassword.GetAllocLength()))
                {
                    DEBUG_INFO;
                    if ( ReallocateMemory( (LPVOID*)&m_pszPassword,
                                       (szTempPassword.GetAllocLength()* sizeof( WCHAR ))+1 ) == FALSE )
                    {
                        SaveLastError();
                        throw CShowError(E_OUTOFMEMORY);
                    }
                }

            }
            // Copy username and password returned from ConnectWmiEx
            if(m_pszUserName)
            {
                DEBUG_INFO;
                StringCopy(m_pszUserName, szTempUser, SIZE_OF_DYN_ARRAY(m_pszUserName));
            }
            if(m_pszPassword)
            {
                DEBUG_INFO;
                StringCopy(m_pszPassword, szTempPassword, SIZE_OF_DYN_ARRAY(m_pszPassword));
            }

        }

        CheckRpRu();

        // Password is no longer is needed now. For security reason release it.
        FreeMemory((LPVOID*)& m_pszPassword);

        // This will check for XP system. Version - 5001
        if( TRUE == bResult )
        {
            if( TRUE ==  CreateXPResults() )
            {
                // Displayed triggers present.
                return TRUE;
            }
            else
            {
                // Failed to display results .
                // Error message is displayed.
                return FALSE;
            }
        }

        // retrieves  TriggerEventCosumer class
        DEBUG_INFO;
        bstrTemp = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
        hr =  m_pWbemServices->GetObject(bstrTemp,
                                   0, NULL, &m_pClass, NULL);
        SAFE_RELEASE_BSTR(bstrTemp);
        ON_ERROR_THROW_EXCEPTION(hr);

        // Gets  information about the "CreateETrigger" method of
        // "TriggerEventCosumer" class
        DEBUG_INFO;
        bstrTemp = SysAllocString(FN_CREATE_ETRIGGER);
        hr = m_pClass->GetMethod(bstrTemp, 0, &m_pInClass, NULL);
        SAFE_RELEASE_BSTR(bstrTemp);
        ON_ERROR_THROW_EXCEPTION(hr);

        // create a new instance of a class "TriggerEventCosumer".
        DEBUG_INFO;
        hr = m_pInClass->SpawnInstance(0, &m_pInInst);
        ON_ERROR_THROW_EXCEPTION(hr);

        // Set the sTriggerName property .
        // sets a "TriggerName" property for Newly created Instance
        DEBUG_INFO;
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_NAME,(m_szTriggerName));
        ON_ERROR_THROW_EXCEPTION(hr);

        // Set the sTriggerAction property to Variant.
        DEBUG_INFO;
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_ACTION,(m_szTaskName));
        ON_ERROR_THROW_EXCEPTION(hr);

        // Set the sTriggerDesc property to Variant .
        DEBUG_INFO;
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_DESC,(m_szDescription));
        ON_ERROR_THROW_EXCEPTION(hr);


       // Set the RunAsUserName property .
        DEBUG_INFO;
        hr = PropertyPut(m_pInInst,FPR_RUN_AS_USER,(m_pszRunAsUserName));
        ON_ERROR_THROW_EXCEPTION(hr);

       // Set the RunAsUserNamePAssword property .

        DEBUG_INFO;
        hr = PropertyPut( m_pInInst,FPR_RUN_AS_USER_PASSWORD,
                          (m_pszRunAsUserPassword));
        ON_ERROR_THROW_EXCEPTION(hr);

        // Password is no longer is needed now. For security reason release it.
        FreeMemory((LPVOID*)& m_pszRunAsUserPassword);


        StringCopy(m_szWMIQueryString ,QUERY_STRING,SIZE_OF_ARRAY(m_szWMIQueryString));
        if( TRUE == ConstructWMIQueryString())
        {
            TCHAR szMsgString[MAX_RES_STRING * 4];
            TCHAR szMsgFormat[MAX_RES_STRING];

            DEBUG_INFO;
            hr = PropertyPut(m_pInInst,FPR_TRIGGER_QUERY,m_szWMIQueryString);
            ON_ERROR_THROW_EXCEPTION(hr);

            // All The required properties sets, so
            // executes CreateETrigger method to create eventtrigger
            DEBUG_INFO;
            hr = m_pWbemServices->ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                                        _bstr_t(FN_CREATE_ETRIGGER),
                                        0, NULL, m_pInInst, &m_pOutInst,NULL);
            ON_ERROR_THROW_EXCEPTION( hr );
            DEBUG_INFO;

            VARIANT vtValue;
            // initialize the variant and then get the value of the specified property
            VariantInit( &vtValue );

            hr = m_pOutInst->Get( _bstr_t( FPR_RETURN_VALUE ), 0, &vtValue, NULL, NULL );
            ON_ERROR_THROW_EXCEPTION( hr );

            //Get Output paramters.
            hr = vtValue.lVal;

            // Clear the variant variable
            VariantClear( &vtValue );
            if(FAILED(hr))
            {
				// added on 07/12/02 if unable to set account info of schedule task
				// show the error instead of warning as access denied
				if( hr == ERROR_UNABLE_SET_RU )
				{
					SetLastError(hr);
					SaveLastError();
					ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_SYSTEM);
					return FALSE;
				}
	            // Check if return code is cutomized or not.
                if( !(ERROR_TRIGNAME_ALREADY_EXIST  == hr || (ERROR_INVALID_RU == hr) ||
                      (SCHEDULER_NOT_RUNNING_ERROR_CODE == hr) ||
                      (RPC_SERVER_NOT_AVAILABLE == hr)  ||
                     // (ERROR_UNABLE_SET_RU  ==  hr) || ///commented on 07/12/02
                      (ERROR_INVALID_USER == hr) ||
                      (ERROR_TRIGGER_ID_EXCEED == hr)))
                {
                    ON_ERROR_THROW_EXCEPTION( hr );
                }
            }
            DEBUG_INFO;
            if(SUCCEEDED(hr))
            {
                 // SUCCESS: message on screen
                 DEBUG_INFO;
                 StringCopy(szMsgFormat, GetResString(IDS_CREATE_SUCCESS),
                            SIZE_OF_ARRAY(szMsgFormat));

                 StringCchPrintfW(szMsgString,SIZE_OF_ARRAY(szMsgString),
                                   szMsgFormat,_X(m_szTriggerName));
                 DEBUG_INFO;
                 // Message shown on screen will be...
                 // SUCCESS: The Event Trigger "EventTrigger Name" has
                 // successfully been created.
                 ShowMessage(stdout,szMsgString);
            }
            else if(ERROR_TRIGNAME_ALREADY_EXIST  == hr) // Means duplicate id found.
            {
                // Show Error Message
                DEBUG_INFO;
                StringCopy(szMsgFormat, GetResString(IDS_DUPLICATE_TRG_NAME),
                        SIZE_OF_ARRAY(szMsgFormat));

                StringCchPrintfW(szMsgString,SIZE_OF_ARRAY(szMsgString),
                               szMsgFormat,_X(m_szTriggerName));

                 // Message shown on screen will be...
                 // ERROR:Event  Trigger Name "EventTrigger Name"
                 // already exits.
                 ShowMessage(stderr,szMsgString);
                 return FALSE;
            }
            else if (ERROR_TRIGGER_ID_EXCEED == hr)
            {
                StringCopy(szMsgFormat, GetResString(IDS_TRIGGER_ID_EXCCED_LIMIT),
                        SIZE_OF_ARRAY(szMsgFormat));

                StringCchPrintfW(szMsgString,SIZE_OF_ARRAY(szMsgString),
                               szMsgFormat,UINT_MAX);

                 // Message shown on screen will be...
                 // ERROR:Event  Trigger Name "EventTrigger Name"
                 // already exits.
                 ShowMessage(stderr,szMsgString);

                 return FALSE;
            }

            if( ( ERROR_INVALID_RU == hr) || // (ERROR_UNABLE_SET_RU == hr) || ---commented on 07/12/02 as it is already handled
                (ERROR_INVALID_USER == hr))
            // Means ru is invalid so show warning....
                              // along with success message.
            {
                 DEBUG_INFO;

                // WARNING: The new event trigger ""%s"" has been created,
                 //        but may not run because the account information could not be set.
				 //changed on 07/12/02 the message as error instead of warning as account info could not be set
                StringCchPrintf ( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                  GetResString(IDS_INVALID_PARAMETER), _X(m_szTriggerName));
                ShowMessage ( stderr, _X(szMsgString));

            }
            else if ( hr == SCHEDULER_NOT_RUNNING_ERROR_CODE || hr == RPC_SERVER_NOT_AVAILABLE)
            {
                StringCchPrintf ( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                  GetResString(IDS_SCHEDULER_NOT_RUNNING), _X(m_szTriggerName));
                ShowMessage ( stderr, _X(szMsgString));
            }


        }
        else
        {
           return FALSE;
        }
        }
        catch(_com_error)
        {
            DEBUG_INFO;
            if(0x80041002 == hr )// WMI returns string for this hr value is
                                // "Not Found." which is not user friendly. So
                                // changing the message text.
            {
                ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
            }
            else
            {
                DEBUG_INFO;
                ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
            }
            return FALSE;
        }
    DEBUG_INFO;
    return TRUE;
}

BOOL
CETCreate::ConstructWMIQueryString()
/*++

Routine Description:
     This function Will create a WMI Query String  depending on other
     parameters supplied with -create parameter

Arguments:
     none

Return Value:
      TRUE - if Successfully creates Query string
      FALSE - if ERROR

--*/
{
    // Local variable
    TCHAR szLogName[MAX_RES_STRING+1];
    DWORD dNoOfLogNames = DynArrayGetCount( m_arrLogNames );
    DWORD dwIndx = 0;
    BOOL bBracket = FALSE;//user to check if brecket is used in WQL
    BOOL bAddLogToSQL = FALSE; // check whether to add log names to WQL
    BOOL bRequiredToCheckLogName = TRUE;// check whether to check log names

     DEBUG_INFO;
    // Check whether "*"  is given for -log
    // if it is there skip adding log to SQL
    for (dwIndx=0;dwIndx<dNoOfLogNames;dwIndx++)
    {
        if( NULL != m_arrLogNames)
        {
            StringCopy(szLogName,DynArrayItemAsString(m_arrLogNames,dwIndx),
                SIZE_OF_ARRAY(szLogName));
            DEBUG_INFO;
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return FALSE;
        }
        bAddLogToSQL = TRUE;
        if( 0 == StringCompare(szLogName,ASTERIX,TRUE,0))
        {
            DWORD dwNewIndx = 0;
            try
            {
                SAFE_RELEASE_BSTR(bstrTemp);
                bstrTemp = SysAllocString(CLS_WIN32_NT_EVENT_LOGFILE);
                DEBUG_INFO;
                HRESULT hr = m_pWbemServices->CreateInstanceEnum(bstrTemp,
                                                 WBEM_FLAG_SHALLOW,
                                                 NULL,
                                                 &m_pEnumWin32_NTEventLogFile);
                SAFE_RELEASE_BSTR(bstrTemp);
                ON_ERROR_THROW_EXCEPTION( hr );

                // set the security at the interface level also
                hr = SetInterfaceSecurity( m_pEnumWin32_NTEventLogFile,
                                           m_pAuthIdentity );
                ON_ERROR_THROW_EXCEPTION(hr);

                // remove all from parrLogName which is initialy filled by
                //DoParceParam()
                DynArrayRemoveAll(m_arrLogNames);
                DEBUG_INFO;
                while( TRUE == GetLogName(szLogName,
                                                  m_pEnumWin32_NTEventLogFile))
                {
                   if( -1 == DynArrayInsertString(m_arrLogNames,
                                                  dwNewIndx++,szLogName,
                                                  StringLength(szLogName,0)))
                   {
                       ShowMessage(stderr,GetResString(IDS_OUTOF_MEMORY));
                       return FALSE;
                   }
                }
                bAddLogToSQL = TRUE;
                bRequiredToCheckLogName = FALSE; // as log names are taken
                                                 // from target system so
                                                 // no need to check log names.
                dNoOfLogNames = DynArrayGetCount( m_arrLogNames );
                break;
            }
            catch(_com_error )
            {
                DEBUG_INFO;
                ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
                return FALSE;
            }

        }
    }
    DEBUG_INFO;
    if( TRUE == bAddLogToSQL)
    {
        for (dwIndx=0;dwIndx<dNoOfLogNames;dwIndx++)
        {
            if( NULL != m_arrLogNames)
            {
                StringCopy(szLogName,DynArrayItemAsString(m_arrLogNames,dwIndx),
                          SIZE_OF_ARRAY(szLogName));
            }
            else
            {
                ShowMessage(stderr,GetResString(IDS_OUTOF_MEMORY));
                return FALSE;
            }
            DEBUG_INFO;
           if(bRequiredToCheckLogName ? CheckLogName(szLogName,m_pWbemServices)
                                      : 1)
            {
              DEBUG_INFO;
              if( 0 == dwIndx)
              {
                if( 1 != dNoOfLogNames)
                {
                  StringConcat(m_szWMIQueryString,
                               L" AND (targetinstance.LogFile =\"",
                               SIZE_OF_ARRAY(m_szWMIQueryString));
                  bBracket = TRUE;
                }
                else
                {
                   StringConcat(m_szWMIQueryString,
                            L" AND targetinstance.LogFile =\"",
                            SIZE_OF_ARRAY(m_szWMIQueryString));
                }
              }
              else
              {
                StringConcat(m_szWMIQueryString,
                        L" OR targetinstance.LogFile =\"",
                        SIZE_OF_ARRAY(m_szWMIQueryString));
              }
              DEBUG_INFO;
             StringConcat(m_szWMIQueryString,szLogName,SIZE_OF_ARRAY(m_szWMIQueryString));
             StringConcat(m_szWMIQueryString,L"\"",SIZE_OF_ARRAY(m_szWMIQueryString));
             if( (dNoOfLogNames-1) == dwIndx &&( TRUE == bBracket))
             {
                StringConcat(m_szWMIQueryString,L")",SIZE_OF_ARRAY(m_szWMIQueryString));
             }
            }
            else
            {
                 return FALSE;
            }
        }
    }
    DEBUG_INFO;
    if( 1 == cmdOptions[ ID_C_TYPE ].dwActuals)// Updates Query string only if Event Type given
    {
        // In help -t can except "SUCCESSAUDIT" and "FAILUREAUDIT"
        // but this string directly cannot be appended to WQL as valid wmi
        // string for these two are "audit success" and "audit failure"
        // respectively
        DEBUG_INFO;
        StringConcat(m_szWMIQueryString,L" AND targetinstance.Type =\"",
                     SIZE_OF_ARRAY(m_szWMIQueryString));

        if(0 == StringCompare(m_szType,GetResString(IDS_FAILURE_AUDIT),
                              TRUE,0))
        {
             StringConcat(m_szWMIQueryString,GetResString(IDS_AUDIT_FAILURE),SIZE_OF_ARRAY(m_szWMIQueryString));

        }
        else if(0 == StringCompare(m_szType, GetResString(IDS_SUCCESS_AUDIT),
                                   TRUE,0))
        {
             StringConcat(m_szWMIQueryString,GetResString(IDS_AUDIT_SUCCESS),SIZE_OF_ARRAY(m_szWMIQueryString));
        }
        else
        {
             StringConcat(m_szWMIQueryString,m_szType,SIZE_OF_ARRAY(m_szWMIQueryString));
        }

        DEBUG_INFO;

        StringConcat(m_szWMIQueryString,L"\"",SIZE_OF_ARRAY(m_szWMIQueryString));
    }
    if( 1 == cmdOptions[ ID_C_SOURCE ].dwActuals)// Updates Query string only if Event Source
                              // given
    {
       DEBUG_INFO;
       StringConcat(m_szWMIQueryString,
                    L" AND targetinstance.SourceName =\"",
                    SIZE_OF_ARRAY(m_szWMIQueryString));
       StringConcat(m_szWMIQueryString,m_szSource,SIZE_OF_ARRAY(m_szWMIQueryString));
       StringConcat(m_szWMIQueryString,L"\"",SIZE_OF_ARRAY(m_szWMIQueryString));
    }

    if(m_dwID>0)
    {
        DEBUG_INFO;
        TCHAR szID[15];
        _itot(m_dwID,szID,10);
        StringConcat(m_szWMIQueryString,
                     L" AND targetinstance.EventCode = ",
                     SIZE_OF_ARRAY(m_szWMIQueryString));
        StringConcat(m_szWMIQueryString,szID,SIZE_OF_ARRAY(m_szWMIQueryString));
    }
    DEBUG_INFO;
    return TRUE;
}

BOOL
CETCreate::GetLogName(
    OUT PTCHAR pszLogName,
    IN  IEnumWbemClassObject *pEnumWin32_NTEventLogFile
    )
/*++

Routine Description:
     This function Will return all available log available in system

Arguments:
    [out] pszLogName      : Will have the NT Event Log names .
    [in ] pEnumWin32_NTEventLogFile : Pointer to WBEM Class object Enum.
Return Value:

      TRUE - if Log name returned
      FALSE - if no log name

--*/
{
    HRESULT hr = 0;
    BOOL bReturn = FALSE;
    IWbemClassObject *pObj = NULL;
    try
    {
        VARIANT vVariant;// variable used to get/set values from/to
                        // COM functions
        ULONG uReturned = 0;
        TCHAR szTempLogName[MAX_RES_STRING];
        DEBUG_INFO;
        hr = pEnumWin32_NTEventLogFile->Next(0,1,&pObj,&uReturned);
        ON_ERROR_THROW_EXCEPTION(hr);
        if( 0 == uReturned )
        {
            SAFE_RELEASE_INTERFACE(pObj);
            return FALSE;
        }
        DEBUG_INFO;
        VariantInit(&vVariant);
        SAFE_RELEASE_BSTR(bstrTemp);
        bstrTemp = SysAllocString(L"LogfileName");
        hr = pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
        SAFE_RELEASE_BSTR(bstrTemp);
        ON_ERROR_THROW_EXCEPTION(hr);

        StringCopy(szTempLogName, V_BSTR(&vVariant), SIZE_OF_ARRAY(szTempLogName));

        hr = VariantClear(&vVariant);
        ON_ERROR_THROW_EXCEPTION(hr);
        StringCopy(pszLogName,szTempLogName,SIZE_OF_DYN_ARRAY(pszLogName));
        bReturn = TRUE;
        DEBUG_INFO;

    }
    catch(_com_error )
    {
        DEBUG_INFO;
		SAFE_RELEASE_INTERFACE(pObj);
        ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        bReturn = FALSE;
    }
    SAFE_RELEASE_BSTR(bstrTemp);
	SAFE_RELEASE_INTERFACE(pObj);
    DEBUG_INFO;
    return bReturn;
}

BOOL
CETCreate::CheckLogName(
    IN PTCHAR pszLogName,
    IN IWbemServices *pNamespace
    )
/*++

Routine Description:
     This function Will return whether log name given at commandline is a valid
     log name or not. It chekcs the log name with WMI
Arguments:
     [in] pszLogName  : Log name which is to be checked.
     [in] pNamespace  : Wbem service pointer.
Return Value:

      TRUE - if Successfully Log name founds in WMI
      FALSE - if ERROR

--*/
{
   // Local Variables
    IEnumWbemClassObject* pEnumWin32_NTEventLogFile = NULL;
    IWbemClassObject *pObj = NULL;
    HRESULT hr = 0;
    BOOL bReturn = FALSE;
    BSTR bstrTemp = NULL;
    BOOL bAlwaysTrue = TRUE;
    BOOL bIsException = FALSE;
    try
    {
        SAFE_RELEASE_BSTR(bstrTemp);
        DEBUG_INFO;
        bstrTemp = SysAllocString(CLS_WIN32_NT_EVENT_LOGFILE);
        hr = pNamespace->CreateInstanceEnum(bstrTemp,
                                            WBEM_FLAG_SHALLOW,
                                            NULL,
                                            &pEnumWin32_NTEventLogFile);
        DEBUG_INFO;
        ON_ERROR_THROW_EXCEPTION(hr);

        // set the security at the interface level also
        hr = SetInterfaceSecurity(pEnumWin32_NTEventLogFile, m_pAuthIdentity);
        DEBUG_INFO;
        ON_ERROR_THROW_EXCEPTION(hr);
        pEnumWin32_NTEventLogFile->Reset();

        while(bAlwaysTrue)
        {
            VARIANT vVariant;// variable used to get/set values from/to
                            // COM functions
            ULONG uReturned = 0;
            TCHAR szTempLogName[MAX_RES_STRING];
            DEBUG_INFO;
            hr = pEnumWin32_NTEventLogFile->Next(0,1,&pObj,&uReturned);
            ON_ERROR_THROW_EXCEPTION(hr);
            if( 0 == uReturned )
            {
                SAFE_RELEASE_INTERFACE(pObj);
                bReturn = FALSE;
                break;
            }

            // clear variant, containts not used now
            VariantInit(&vVariant);
            SAFE_RELEASE_BSTR(bstrTemp);// string will be no loger be used
            bstrTemp = SysAllocString(L"LogfileName");
            hr = pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
            SAFE_RELEASE_BSTR(bstrTemp);
            StringCopy(szTempLogName, V_BSTR(&vVariant),
                       SIZE_OF_ARRAY(szTempLogName));
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);

            // Means log name found in WMI
            if( 0 == StringCompare(szTempLogName,pszLogName,TRUE,0))
            {
                DEBUG_INFO;
                SAFE_RELEASE_INTERFACE(pObj);
                bReturn = TRUE;
                break;
            }
         }
    }
    catch(_com_error )
    {
        DEBUG_INFO;
		SAFE_RELEASE_INTERFACE(pEnumWin32_NTEventLogFile);
        SAFE_RELEASE_INTERFACE(pObj);
        ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        bReturn = FALSE;
        bIsException = TRUE;
    }

    SAFE_RELEASE_BSTR(bstrTemp);
    SAFE_RELEASE_INTERFACE(pObj);
    SAFE_RELEASE_INTERFACE(pEnumWin32_NTEventLogFile);
    DEBUG_INFO;

    if ((FALSE == bReturn) && (FALSE == bIsException))
    {
        TCHAR szMsgFormat[MAX_STRING_LENGTH];
        TCHAR szMsgString[MAX_STRING_LENGTH];
        SecureZeroMemory(szMsgFormat,sizeof(szMsgFormat));
        SecureZeroMemory(szMsgString,sizeof(szMsgString));
        // Show Log name doesn't exit.
         StringCopy(szMsgFormat,GetResString(IDS_LOG_NOT_EXISTS),
                    SIZE_OF_ARRAY(szMsgFormat));
         StringCchPrintfW(szMsgString, SIZE_OF_ARRAY(szMsgString),
                          szMsgFormat,pszLogName);

         // Message shown on screen will be...
         // FAILURE: "Log Name" Log not exists on system
         ShowMessage(stderr,szMsgString);
    }
    return bReturn;
}

void
CETCreate::CheckRpRu(
    void
    )
/*++

Routine Description:
     This function will check/set values for rp and ru.
Arguments:
     None
Return Value:
    none
--*/

{
   TCHAR szTemp[MAX_STRING_LENGTH]; // To Show Messages
   TCHAR szTemp1[MAX_STRING_LENGTH];// To Show Messages
   TCHAR szWarnPassWord[MAX_STRING_LENGTH];

   SecureZeroMemory(szTemp,sizeof(szTemp));
   SecureZeroMemory(szTemp1,sizeof(szTemp1));
   SecureZeroMemory(szWarnPassWord,sizeof(szWarnPassWord));

   StringCchPrintfW(szWarnPassWord,SIZE_OF_ARRAY(szWarnPassWord),
                           GetResString(IDS_WARNING_PASSWORD),NTAUTHORITY_USER);

   // Check if run as username is "NT AUTHORITY\SYSTEM" OR "SYSTEM" Then
   // make this as BLANK (L"") and do not ask for password, any how

   // Compare the string irrespective of language.
   DEBUG_INFO;
   INT iCompareResult1 = CompareString(MAKELCID( MAKELANGID(LANG_ENGLISH,
                                                SUBLANG_ENGLISH_US),
                                                SORT_DEFAULT),
                                   NORM_IGNORECASE,
                                   m_pszRunAsUserName,
                                   StringLength(m_pszRunAsUserName,0),
                                   NTAUTHORITY_USER ,
                                   StringLength(NTAUTHORITY_USER,0)
                                  );
   INT iCompareResult2 =  CompareString(MAKELCID( MAKELANGID(LANG_ENGLISH,
                                                SUBLANG_ENGLISH_US),
                                                SORT_DEFAULT),
                                   NORM_IGNORECASE,
                                   m_pszRunAsUserName,
                                   StringLength(m_pszRunAsUserName,0),
                                   SYSTEM_USER ,
                                   StringLength(SYSTEM_USER,0)
                                  );
   if((CSTR_EQUAL ==  iCompareResult1) || (CSTR_EQUAL == iCompareResult2))
    {

      DEBUG_INFO;
      if( 1 == cmdOptions[ ID_C_RP ].dwActuals)
         DISPLAY_MESSAGE(stderr,szWarnPassWord);
      return;
    }

	// added on 07/12/02 /ru is given and is "" and /rp is given
    if( ( 1 == cmdOptions[ ID_C_RU ].dwActuals ) &&
        ( 0 == StringLength(m_pszRunAsUserName,0)) &&
		 ( 1 == cmdOptions[ ID_C_RP ].dwActuals ))
	{
         DISPLAY_MESSAGE(stderr,szWarnPassWord);
		 return;
	}
    // /rp is given and is "" (blank), show warning message.
    if( (1 == cmdOptions[ ID_C_RP ].dwActuals) &&
        (0 == StringLength(m_pszRunAsUserPassword,0)))
    {
       ShowMessage(stderr,GetResString(IDS_WARN_NULL_PASSWORD));
       return;
    }
    // /rp is given and is '*', ask for the password only if -ru is not equal to ""
	// added on 07/12/02
   else if(( 1 == cmdOptions[ ID_C_RP ].dwActuals ) &&
          ( 0 == StringCompare(m_pszRunAsUserPassword,ASTERIX,FALSE,0)) &&
		  ( 0 != StringLength(m_pszRunAsUserName,0))) 
    {
           DEBUG_INFO;

           // Free the allocated memory;
           FreeMemory((LPVOID*)& m_pszRunAsUserPassword);
           m_pszRunAsUserPassword = (LPTSTR) AllocateMemory(MAX_STRING_LENGTH * sizeof(WCHAR));
           if(NULL == m_pszRunAsUserPassword)
           {
               throw CShowError(E_OUTOFMEMORY);
           }
           StringCopy(szTemp, GetResString(IDS_ASK_PASSWORD),
                      SIZE_OF_ARRAY(szTemp));

           StringCchPrintfW(szTemp1, SIZE_OF_ARRAY(szTemp1), szTemp,
                      m_pszRunAsUserName);
           ShowMessage(stdout,szTemp1);
           GetPassword(m_pszRunAsUserPassword,
                      SIZE_OF_DYN_ARRAY(m_pszRunAsUserPassword));
            if( 0 == StringLength(m_pszRunAsUserPassword,0))
            {
                ShowMessage(stderr,GetResString(IDS_WARN_NULL_PASSWORD));
            }

           return;
    }

   if( TRUE == m_bLocalSystem)
    {
       // RULES:
       // For the local system following cases are considered.
       // if /ru not given, ru will be current logged on user
       // and for 'rp' utility will prompt for the password.
       //    If /ru is given and /rp is not given, utiliry
       //    will ask for the password.
       if( 0 == cmdOptions[ ID_C_RU ].dwActuals)
       {
           DEBUG_INFO;
           SetToLoggedOnUser();
           return;
       }
	   // added on 07/12/02  check -ru is not equal to ""
       else if(( 1 == cmdOptions[ ID_C_RU ].dwActuals) &&
              (( 0 == cmdOptions[ ID_C_RP ].dwActuals)) && (0 != StringLength(m_pszRunAsUserName,0)) )
        {
           StringCopy(szTemp,GetResString(IDS_ASK_PASSWORD),
                      SIZE_OF_ARRAY(szTemp));
           StringCchPrintfW(szTemp1, SIZE_OF_ARRAY(szTemp1), szTemp,
                      m_pszRunAsUserName);
           ShowMessage(stdout,szTemp1);
           GetPassword(m_pszRunAsUserPassword,SIZE_OF_DYN_ARRAY(m_pszRunAsUserPassword));
            if( 0 == StringLength(m_pszRunAsUserPassword,0))
            {
                ShowMessage(stderr,GetResString(IDS_WARN_NULL_PASSWORD));
            }
            DEBUG_INFO;
           return;
        }
    }
    else // remote system
    {
       // RULES:
       // For the local system following cases are considered.
       // 1. /u, /p , /ru and /rp not given:
       //    'ru' will be current logged on user and for 'rp'
       //    utility will  prompt for password.
       // 2. /u given and /p , /ru and /rp not given:
       //    /ru will be /u and for 'rp' utility will
       //    prompt for the password.
       // 3. /u and /p given and /ru - /rp not given:
       //    /ru will be /u and /rp will be /p
       if( (0 == cmdOptions[ ID_C_USERNAME ].dwActuals) &&
           (0 == cmdOptions[ ID_C_RU ].dwActuals))
       {
           DEBUG_INFO;
           SetToLoggedOnUser();
       }
       else if ((1 == cmdOptions[ ID_C_USERNAME ].dwActuals) &&
                (0 == cmdOptions[ ID_C_RU ].dwActuals) )
       {
           DEBUG_INFO;
           // free memory if at at all it is allocated
           FreeMemory((LPVOID*)& m_pszRunAsUserName);
            m_pszRunAsUserName = (LPTSTR) AllocateMemory(GetBufferSize((LPVOID)m_pszUserName)+1);
            if( (NULL == m_pszRunAsUserName))
            {
                throw CShowError(E_OUTOFMEMORY);
            }
            StringCopy(m_pszRunAsUserName,m_pszUserName,SIZE_OF_DYN_ARRAY(m_pszRunAsUserName));

            // ask for the password (rp).
            // NOTE: memory is already allocated for 'm_pszRunAsUserPassword'.
            StringCopy(szTemp, GetResString(IDS_ASK_PASSWORD),
                      SIZE_OF_ARRAY(szTemp));

            StringCchPrintfW(szTemp1, SIZE_OF_ARRAY(szTemp1), szTemp,
                      m_pszRunAsUserName);
            ShowMessage(stdout,szTemp1);
            GetPassword(m_pszRunAsUserPassword,
                      SIZE_OF_DYN_ARRAY(m_pszRunAsUserPassword));
            if( 0 == StringLength(m_pszRunAsUserPassword,0))
            {
                ShowMessage(stderr,GetResString(IDS_WARN_NULL_PASSWORD));
            }
       }
       else if ((0 == cmdOptions[ ID_C_USERNAME ].dwActuals) &&
                (1 == cmdOptions[ ID_C_RU ].dwActuals) &&
                (0 == cmdOptions[ ID_C_RP ].dwActuals))
       {
            // ask for the password (rp).
            // NOTE: memory is already allocated for 'm_pszRunAsUserPassword'.
            StringCopy(szTemp, GetResString(IDS_ASK_PASSWORD),
                      SIZE_OF_ARRAY(szTemp));

            StringCchPrintfW(szTemp1, SIZE_OF_ARRAY(szTemp1), szTemp,
                      m_pszRunAsUserName);
            ShowMessage(stdout,szTemp1);
            GetPassword(m_pszRunAsUserPassword,
                      SIZE_OF_DYN_ARRAY(m_pszRunAsUserPassword));
            if( 0 == StringLength(m_pszRunAsUserPassword,0))
            {
                ShowMessage(stderr,GetResString(IDS_WARN_NULL_PASSWORD));
            }

       }

       else if ((1 == cmdOptions[ ID_C_USERNAME ].dwActuals) &&
                (1 == cmdOptions[ ID_C_RU ].dwActuals) &&
                (0 == cmdOptions[ ID_C_RP ].dwActuals))
        {
           if( 0 == StringCompare(m_pszUserName,m_pszRunAsUserName,TRUE,0))
            {
                StringCopy(m_pszRunAsUserPassword,m_pszPassword,
                           SIZE_OF_ARRAY(m_pszRunAsUserPassword));
            }
            else
            {
               StringCopy(szTemp,GetResString(IDS_ASK_PASSWORD),
                          SIZE_OF_ARRAY(szTemp));
               StringCchPrintfW(szTemp1, SIZE_OF_ARRAY(szTemp1), szTemp,
                                m_pszRunAsUserName);
               ShowMessage(stdout,szTemp1);
               GetPassword( m_pszRunAsUserPassword,
                            SIZE_OF_DYN_ARRAY(m_pszRunAsUserPassword));
                if(StringLength(m_pszRunAsUserPassword,0) == 0)
               {
                    ShowMessage(stderr,
                                    GetResString(IDS_WARN_NULL_PASSWORD));
               }
            }
        }
    }
    DEBUG_INFO;
    return;
}

void
CETCreate::AssignMinMemory(
    void
    )
/*++

Routine Description:
     This function will allocate memory to those string pointer which
     are NULL.

     NOTE
Arguments:
     None
Return Value:
    none
--*/

{
    DEBUG_INFO;
    if( NULL == m_pszServerName)
    {
        m_pszServerName = (LPTSTR)AllocateMemory(MAX_STRING_LENGTH * sizeof(WCHAR));
        if(NULL == m_pszServerName)
        {
            throw CShowError(E_OUTOFMEMORY);
        }
    }
    if( NULL == m_pszUserName)
    {
        m_pszUserName = (LPTSTR)AllocateMemory(MAX_STRING_LENGTH* sizeof(WCHAR));
        if(NULL == m_pszUserName)
        {
            throw CShowError(E_OUTOFMEMORY);
        }
    }
    if( NULL == m_pszPassword)
    {
        m_pszPassword = (LPTSTR)AllocateMemory(MAX_STRING_LENGTH* sizeof(WCHAR));
        if(NULL == m_pszPassword)
        {
            throw CShowError(E_OUTOFMEMORY);
        }
    }
    if( NULL == m_pszRunAsUserName)
    {
        m_pszRunAsUserName = (LPTSTR)AllocateMemory(MAX_STRING_LENGTH* sizeof(WCHAR));
        if(NULL == m_pszRunAsUserName)
        {
            throw CShowError(E_OUTOFMEMORY);
        }
    }
    if( NULL == m_pszRunAsUserPassword)
    {
        m_pszRunAsUserPassword = (LPTSTR)AllocateMemory(MAX_STRING_LENGTH* sizeof(WCHAR));
        if(NULL == m_pszRunAsUserPassword)
        {
            throw CShowError(E_OUTOFMEMORY);
        }
    }
    DEBUG_INFO;
}

void
CETCreate::SetToLoggedOnUser(
    void
    )
/*++

Routine Description:
    This function will Set RunAsUser to current logged on user.
    and also ask for its password (RunAsPassword).
Arguments:
     None
Return Value:
    none
--*/



{
   TCHAR szTemp[MAX_STRING_LENGTH]; // To Show Messages
   TCHAR szTemp1[MAX_STRING_LENGTH];// To Show Messages
   TCHAR szWarnPassWord[MAX_STRING_LENGTH];

   SecureZeroMemory(szTemp,sizeof(szTemp));
   SecureZeroMemory(szTemp1,sizeof(szTemp1));
   SecureZeroMemory(szWarnPassWord,sizeof(szWarnPassWord));

   StringCchPrintfW(szWarnPassWord,SIZE_OF_ARRAY(szWarnPassWord),
                           GetResString(IDS_WARNING_PASSWORD),NTAUTHORITY_USER);

   // Get Current logged on user name.
   ULONG ulSize = UNLEN + 1;


   // free memory if at at all it is allocated
   FreeMemory((LPVOID*)& m_pszRunAsUserName);

   m_pszRunAsUserName = (LPTSTR) AllocateMemory( ulSize * sizeof( WCHAR ));


   if( (NULL == m_pszRunAsUserName))
   {
        throw CShowError(E_OUTOFMEMORY);
   }

   if(0 == GetUserName(m_pszRunAsUserName,&ulSize))
   {
       // display error
       ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_SYSTEM);
       throw 5000;
   }

   // ask for the password (rp).
   // NOTE: memory is already allocated for 'm_pszRunAsUserPassword'.
   StringCopy(szTemp, GetResString(IDS_ASK_PASSWORD),
              SIZE_OF_ARRAY(szTemp));

   StringCchPrintfW(szTemp1, SIZE_OF_ARRAY(szTemp1), szTemp,
              m_pszRunAsUserName);
   ShowMessage(stdout,szTemp1);
   GetPassword(m_pszRunAsUserPassword,
              SIZE_OF_DYN_ARRAY(m_pszRunAsUserPassword));
    if( 0 == StringLength(m_pszRunAsUserPassword,0))
    {
        ShowMessage(stderr,GetResString(IDS_WARN_NULL_PASSWORD));
    }
}


BOOL
CETCreate::CreateXPResults(
    void
    )
/*++
Routine Description:
   This function creates a new trigger if not present on a remote XP machine.
   This function is for compatibility of .NET to XP machine only.

Arguments:

    NONE

Return Value:
     BOOL: TRUE - If succedded in creating a new trigger results.
           FALSE- otherwise

--*/
{
    DWORD dwRetVal = 0;  // Check whether creation of trigger is succesful.
    HRESULT hr = S_OK;

    try
    {
        // retrieves  TriggerEventCosumer class
        DEBUG_INFO;
        hr =  m_pWbemServices->GetObject(_bstr_t( CLS_TRIGGER_EVENT_CONSUMER ),
                                   0, NULL, &m_pClass, NULL);
        ON_ERROR_THROW_EXCEPTION(hr);

        // Gets  information about the "CreateETrigger" method of
        // "TriggerEventCosumer" class
        DEBUG_INFO;
        hr = m_pClass->GetMethod(_bstr_t( FN_CREATE_ETRIGGER_XP ), 0, &m_pInClass, NULL);
        ON_ERROR_THROW_EXCEPTION(hr);

        // create a new instance of a class "TriggerEventCosumer".
        DEBUG_INFO;
        hr = m_pInClass->SpawnInstance(0, &m_pInInst);
        ON_ERROR_THROW_EXCEPTION(hr);

        // Set the sTriggerName property .
        // sets a "TriggerName" property for Newly created Instance
        DEBUG_INFO;
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_NAME,(m_szTriggerName));
        ON_ERROR_THROW_EXCEPTION(hr);

        // Set the sTriggerAction property to Variant.
        DEBUG_INFO;
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_ACTION,(m_szTaskName));
        ON_ERROR_THROW_EXCEPTION(hr);

        // Set the sTriggerDesc property to Variant .
        DEBUG_INFO;
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_DESC,(m_szDescription));
        ON_ERROR_THROW_EXCEPTION(hr);


       // Set the RunAsUserName property .
        DEBUG_INFO;
        hr = PropertyPut(m_pInInst,FPR_RUN_AS_USER,(m_pszRunAsUserName));
        ON_ERROR_THROW_EXCEPTION(hr);

       // Set the RunAsUserNamePAssword property .

        DEBUG_INFO;
        hr = PropertyPut( m_pInInst,FPR_RUN_AS_USER_PASSWORD,
                          (m_pszRunAsUserPassword));
        ON_ERROR_THROW_EXCEPTION(hr);

        // Password is no longer is needed now. For security reason release it.
        FreeMemory((LPVOID*)& m_pszRunAsUserPassword);


        StringCopy(m_szWMIQueryString ,QUERY_STRING,SIZE_OF_ARRAY(m_szWMIQueryString));

        if( TRUE == ConstructWMIQueryString())
        {
            TCHAR szMsgString[MAX_RES_STRING * 4];
            TCHAR szMsgFormat[MAX_RES_STRING];
            VARIANT vtValue;
            // initialize the variant and then get the value of the specified property
            VariantInit( &vtValue );

            DEBUG_INFO;
            hr = PropertyPut(m_pInInst,FPR_TRIGGER_QUERY,m_szWMIQueryString);
            ON_ERROR_THROW_EXCEPTION(hr);

            // All The required properties sets, so
            // executes CreateETrigger method to create eventtrigger
            DEBUG_INFO;
            hr = m_pWbemServices->ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                                        _bstr_t(FN_CREATE_ETRIGGER_XP),
                                        0, NULL, m_pInInst, &m_pOutInst,NULL);
            ON_ERROR_THROW_EXCEPTION( hr );
            DEBUG_INFO;

            hr = m_pOutInst->Get( _bstr_t( FPR_RETURN_VALUE ), 0, &vtValue, NULL, NULL );
            ON_ERROR_THROW_EXCEPTION( hr );

            //Get Output paramters.
            dwRetVal = ( DWORD )vtValue.lVal;
            VariantClear( &vtValue );

            switch( dwRetVal )
            {
            case 0:     // Success i ncreation a new trigger.
                 // SUCCESS: message on screen
                 DEBUG_INFO;
                 StringCopy(szMsgFormat, GetResString(IDS_CREATE_SUCCESS),
                            SIZE_OF_ARRAY(szMsgFormat));

                 StringCchPrintfW(szMsgString,SIZE_OF_ARRAY(szMsgString),
                                   szMsgFormat,_X(m_szTriggerName));
                 DEBUG_INFO;
                 // Message shown on screen will be...
                 // SUCCESS: The Event Trigger "EventTrigger Name" has
                 // successfully been created.
                 ShowMessage(stdout,L"\n");
                 ShowMessage(stdout,szMsgString);
                break;

            case 1:     // Duplicate id found. Failed to create.
                // Show Error Message
                DEBUG_INFO;
                StringCopy(szMsgFormat, GetResString(IDS_DUPLICATE_TRG_NAME),
                        SIZE_OF_ARRAY(szMsgFormat));

                StringCchPrintfW(szMsgString,SIZE_OF_ARRAY(szMsgString),
                               szMsgFormat,_X(m_szTriggerName));

                 // Message shown on screen will be...
                 // ERROR:Event  Trigger Name "EventTrigger Name"
                 // already exits.
                 ShowMessage(stderr,szMsgString);
                 return FALSE;
            case 2:     // Means ru is invalid so show warning....
                 DEBUG_INFO;

                // WARNING: The new event trigger ""%s"" has been created,
                 //        but may not run because the account information could not be set.
                StringCchPrintf ( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                  GetResString(IDS_INVALID_R_U), _X(m_szTriggerName));
                ShowMessage ( stderr, _X(szMsgString));
                return FALSE;
                break;
            default:
                // Control should not come here.
                DEBUG_INFO;
                StringCopy(szMsgFormat, GetResString(IDS_DUPLICATE_TRG_NAME),
                        SIZE_OF_ARRAY(szMsgFormat));

                StringCchPrintfW(szMsgString,SIZE_OF_ARRAY(szMsgString),
                               szMsgFormat,_X(m_szTriggerName));

                 // Message shown on screen will be...
                 // ERROR:Event  Trigger Name "EventTrigger Name"
                 // already exits.
                 ShowMessage(stderr,szMsgString);
                 return FALSE;
                break;
            }
        }
        else
        {
           return FALSE;
        }
    }
    catch( _com_error e )
    {
        DEBUG_INFO;

        // WMI returns string for this hr value is "Not Found." which is not
        // user friendly. So changing the message text.
        if( 0x80041002 == hr )
        {
            ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
        }
        else
        {
            DEBUG_INFO;
            WMISaveError( e );
            ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        }
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        return FALSE;
    }

    // Operation successful.
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\etcreate.h ===
/******************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    ETCreate.h

Abstract:

  This module  contanins function definations required by ETCreate.cpp

Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:

******************************************************************************/

#ifndef _ETCREATE_H
#define _ETCREATE_H



#define ID_C_CREATE        0
#define ID_C_SERVER        1
#define ID_C_USERNAME      2
#define ID_C_PASSWORD      3
#define ID_C_TRIGGERNAME   4
#define ID_C_LOGNAME       5
#define ID_C_ID            6
#define ID_C_TYPE          7
#define ID_C_SOURCE        8
#define ID_C_DESCRIPTION   9
#define ID_C_TASK          10
#define ID_C_RU            11
#define ID_C_RP            12

#define MAX_COMMANDLINE_C_OPTION 13  // Maximum Command Line  List
#define INVALID_TRIGGER_NAME_CHARACTERS L":|<>?*\\/"

class CETCreate
{
public:
    CETCreate();
    CETCreate(LONG lMinMemoryReq,BOOL bNeedPassword);
    virtual ~CETCreate();
public:
    BOOL ExecuteCreate();
    void ProcessOption( IN DWORD argc, IN LPCTSTR argv[]);
    void Initialize();

private:
    TCHAR m_szWMIQueryString[(MAX_RES_STRING*2)+1];
    BOOL CheckLogName( IN PTCHAR pszLogName, IN IWbemServices *pNamespace);
    BOOL GetLogName( OUT PTCHAR pszLogName,
                     IN IEnumWbemClassObject *pEnumWin32_NTEventLogFile);
    BOOL ConstructWMIQueryString();
    BOOL CreateXPResults( void );
    void AssignMinMemory(void);
    void CheckRpRu(void);
    void SetToLoggedOnUser(void);
    LPTSTR  m_pszServerName;
    LPTSTR  m_pszUserName;
    LPTSTR  m_pszPassword;
    TCHAR   m_szTriggerName[MAX_TRIGGER_NAME];
    TCHAR   m_szDescription[MAX_STRING_LENGTH];
    TCHAR   m_szType[MAX_STRING_LENGTH];
    TCHAR   m_szSource[MAX_STRING_LENGTH];

    LPTSTR  m_pszRunAsUserName;
    LPTSTR  m_pszRunAsUserPassword;
    TARRAY  m_arrLogNames;
    DWORD   m_dwID;

    TCHAR   m_szTaskName[MAX_TASK_NAME];
    BOOL    m_bNeedPassword;
    BOOL    m_bCreate;
    BOOL    m_bLocalSystem;
    BOOL    m_bIsCOMInitialize;
    BSTR    bstrTemp;
    // WMI / COM interfaces
    IWbemLocator*           m_pWbemLocator;
    IWbemServices*          m_pWbemServices;
    IEnumWbemClassObject*   m_pEnumObjects;
    IWbemClassObject*       m_pClass;
    IWbemClassObject*       m_pOutInst;
    IWbemClassObject*       m_pInClass;
    IWbemClassObject*       m_pInInst;
    IEnumWbemClassObject*   m_pEnumWin32_NTEventLogFile;


    // WMI connectivity
    COAUTHIDENTITY* m_pAuthIdentity;

    void InitCOM();
    void PrepareCMDStruct();
    LONG m_lMinMemoryReq;
    // Array to store command line options
    TCMDPARSER2 cmdOptions[MAX_COMMANDLINE_C_OPTION];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\etcommon.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    ETCommon.h

Abstract:
    This module contains all necessary defines & MACROs required by
    this project.


Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:


******************************************************************************/

#ifndef _ETCOMMON_H
#define _ETCOMMON_H
//
// general purpose macros
//

// Following macro will help for debuggig the application.
// To enable debugging define DEBUG.

//#define DEBUG_EVT
//#define DEBUG

#ifdef DEBUG_EVT
#define DEBUG_INFO wprintf(L"File Name: %S, Line No: %d\n",__FILE__,__LINE__)
#else
#define DEBUG_INFO  1
#endif


#define SCHEDULER_NOT_RUNNING_ERROR_CODE    0x80041315
#define RPC_SERVER_NOT_AVAILABLE            0x800706B5
#define ERROR_INVALID_RU                    0x80041310
#define ERROR_RUN_AS_USER                   0x8004130F
#define ERROR_UNABLE_SET_RU                 0x80070005
// Customized Error codes comming from Provider.


#define SUCCESS_OPERATION               0
#define ERROR_TRIGNAME_ALREADY_EXIST    MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 1 )
#define ERROR_TRIGGER_NOT_DELETED       MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 2 )
#define ERROR_TRIGGER_NOT_FOUND         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 3 )
#define ERROR_INVALID_USER              MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 4 )
#define WARNING_INVALID_USER            MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 5 )
#define ERROR_TRIGGER_ID_EXCEED         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 6 )
#define ERROR_TRIGGER_CORRUPTED         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 7 )

#define TRIGGER_CORRUPTED  GetResString(IDS_TRIGGER_CORRUPTED)
#define E_REMOTE_INCOMPATIBLE GetResString(IDS_E_REMOTE_INCOMPATIBLE)

#define MAX_TASK_NAME 263
#define MAX_TRIGGER_NAME 196

const WCHAR    szHelpOption[]           = L"?";
const WCHAR    szCreateOption[]         = L"CREATE";
const WCHAR    szDeleteOption[]         = L"DELETE";
const WCHAR    szQueryOption[]          = L"QUERY";
const WCHAR    szServerNameOption[]     = L"s";
const WCHAR    szUserNameOption[]       = L"u";
const WCHAR    szPasswordOption[]       = L"p";
const WCHAR    szTriggerNameOption[]    = L"tr";
const WCHAR    szLogNameOption[]        = L"l";
const WCHAR    szEIDOption[]            = L"eid";
const WCHAR    szTypeOption[]           = L"t";
const WCHAR    szSource[]               = L"so";
const WCHAR    szDescriptionOption[]    = L"d";
const WCHAR    szFormatOption[]         = L"fo";
const WCHAR    szNoHeaderOption[]       = L"nh";
const WCHAR    szVerboseOption[]        = L"v";
const WCHAR    szTaskNameOption[]       = L"tk";
const WCHAR    szTIDOption[]            = L"tid";
const WCHAR    szRunAsUserNameOption[]  = L"ru";
const WCHAR    szRunAsPasswordOption[]  = L"rp";
const WCHAR    szTriggerIDOption[]      = L"id";

HRESULT PropertyGet1( IWbemClassObject* pWmiObject,
                      LPCTSTR szProperty,
                      LPVOID pValue, DWORD dwSize );

extern DWORD  g_dwOptionFlag;
// CLS stands for class
#define CLS_TRIGGER_EVENT_CONSUMER    L"CmdTriggerConsumer"
#define CLS_FILTER_TO_CONSUMERBINDING L"__FilterToConsumerBinding"
#define CLS_WIN32_NT_EVENT_LOGFILE    L"Win32_NTEventLogFile"
#define CLS_EVENT_FILTER              L"__EventFilter"

// FN stands for Function name
#define FN_CREATE_ETRIGGER L"CreateETriggerEx"
#define FN_DELETE_ETRIGGER L"DeleteETriggerEx"
#define FN_QUERY_ETRIGGER  L"QueryETriggerEx"

// FN stands for Function name
// Used only for XP machines.
#define FN_CREATE_ETRIGGER_XP   L"CreateETrigger"
#define FN_DELETE_ETRIGGER_XP   L"DeleteETrigger"
#define FN_QUERY_ETRIGGER_XP    L"QueryETrigger"

// FPR stands for function-parameter
#define FPR_TRIGGER_NAME         L"TriggerName"
#define FPR_TRIGGER_DESC         L"TriggerDesc"
#define FPR_TRIGGER_QUERY        L"TriggerQuery"
#define FPR_TRIGGER_ACTION       L"TriggerAction"
#define FPR_TRIGGER_ID           L"TriggerID"
#define FPR_RETURN_VALUE         L"ReturnValue"
#define FPR_RUN_AS_USER          L"RunAsUser"
#define FPR_RUN_AS_USER_PASSWORD L"RunAsPwd"
#define FPR_TASK_SCHEDULER       L"ScheduledTaskName"


#define QUERY_STRING   L"select * from __instancecreationevent where targetinstance isa \"win32_ntlogevent\""
#define QUERY_LANGUAGE L"WQL"
#define QUERY_RANGE    L"select * from CmdTriggerConsumer where TriggerId >= %d and TriggerId <= %d"
#define BINDING_CLASS_QUERY L"select * from __filtertoconsumerbinding where Consumer = \"CmdTriggerConsumer.TriggerId=%d\""

#define RELEASE_MEMORY_EX( block )  \
    if ( (block) != NULL )  \
    {   \
        delete [] (block);  \
        (block) = NULL; \
    }   \
    1

#define DESTROY_ARRAY( array )  \
    if ( (array) != NULL )  \
    {   \
        DestroyDynamicArray( &(array) );    \
        (array) = NULL; \
    }   \
    1
#define SAFE_RELEASE_BSTR(bstr)\
    if(bstr != NULL)\
    {\
        SysFreeString(bstr);\
        bstr = NULL;\
    }

#define ON_ERROR_THROW_EXCEPTION( hr )\
    if(FAILED(hr))\
    {\
      WMISaveError(hr);\
     _com_issue_error(hr);\
    }

#define SAFE_RELEASE_INTERFACE( interfacepointer )  \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \
    1
#define SIZE_OF_DYN_ARRAY(array) GetBufferSize((LPVOID)array)/sizeof(WCHAR)
#define SIZE_OF_NEW_ARRAY(array) _msize(array)/sizeof(WCHAR)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\etdelete.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    ETDelete.h

Abstract:

  This module  contanins function definations required by ETDelete.cpp

Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:


*******************************************************************************/

#ifndef _ETDELETE
#define _ETDELETE

#define MAX_COMMANDLINE_D_OPTION  5

#define ID_D_DELETE        0
#define ID_D_SERVER        1
#define ID_D_USERNAME      2
#define ID_D_PASSWORD      3
#define ID_D_ID            4

#define ID_MAX_RANGE        UINT_MAX

#define SUCCESS_NO_ERROR          0
//#define ERROR_TRIGGER_NOT_FOUND 1
//#define ERROR_TRIGGER_NOT_DELETED    2
//#define ERROR_TRIGGER_NOT_FOUND   3

class CETDelete
{
public:
    BOOL ExecuteDelete();
    void Initialize();
    CETDelete();
    CETDelete(LONG lMinMemoryReq,BOOL bNeedPassword);
    void ProcessOption( IN DWORD argc, IN LPCTSTR argv[])throw (CShowError);
    virtual ~CETDelete();
private:
    BOOL GiveTriggerID( OUT LONG *pTriggerID, OUT LPTSTR pszTriggerName);
    BOOL GiveTriggerName( IN LONG lTriggerID, OUT LPTSTR pszTriggerName);
    BOOL DeleteXPResults( IN BOOL bIsWildcard, IN DWORD dNoOfIds );
    void PrepareCMDStruct();

    BOOL    m_bDelete;
    LPTSTR  m_pszServerName;
    LPTSTR  m_pszUserName;
    LPTSTR  m_pszPassword;
    TARRAY  m_arrID;
    BOOL    m_bNeedPassword;
    TCHAR   m_szTemp[MAX_STRING_LENGTH];

    // COM function related local variables..
    BOOL m_bIsCOMInitialize;
    IWbemLocator*           m_pWbemLocator;
    IWbemServices*          m_pWbemServices;
    IEnumWbemClassObject*   m_pEnumObjects;
    IWbemClassObject*       m_pClass;
    IWbemClassObject*       m_pInClass;
    IWbemClassObject*       m_pInInst;
    IWbemClassObject*       m_pOutInst;



    COAUTHIDENTITY* m_pAuthIdentity;

    LONG m_lMinMemoryReq;

    // Array to store command line options
    TCMDPARSER2 cmdOptions[MAX_COMMANDLINE_D_OPTION];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\etdelete.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

  ETDelete.CPP

Abstract:

  This module  is intended to have the functionality for EVENTTRIGGERS.EXE
  with -delete parameter.
  This will delete an Event Trigger From local / remote System

Author:
  Akhil Gokhale 03-Oct.-2000 (Created it)

Revision History:


******************************************************************************/
#include "pch.h"
#include "ETCommon.h"
#include "resource.h"
#include "ShowError.h"
#include "ETDelete.h"
#include "WMI.h"

CETDelete::CETDelete()
/*++
 Routine Description:
     Class constructor

 Arguments:
      None
 Return Value:
      None
--*/
{
    m_bDelete           = FALSE;
    m_pszServerName     = NULL;
    m_pszUserName       = NULL;
    m_pszPassword       = NULL;
    m_arrID             = NULL;
    m_bIsCOMInitialize  = FALSE;
    m_lMinMemoryReq     = 0;
    m_bNeedPassword     = FALSE;

    m_pWbemLocator    = NULL;
    m_pWbemServices   = NULL;
    m_pEnumObjects    = NULL;
    m_pAuthIdentity   = NULL;

    m_pClass        = NULL;
    m_pInClass      = NULL;
    m_pInInst       = NULL;
    m_pOutInst      = NULL;
}

CETDelete::CETDelete(
    LONG lMinMemoryReq,
    BOOL bNeedPassword
    )
/*++
 Routine Description:
        Class constructor

 Arguments:
      None
 Return Value:
        None

--*/
{
    m_pszServerName     = NULL;
    m_pszUserName       = NULL;
    m_pszPassword       = NULL;
    m_arrID             = NULL;
    m_bIsCOMInitialize  = FALSE;
    m_lMinMemoryReq     = lMinMemoryReq;
    m_bNeedPassword     = bNeedPassword;

    m_pWbemLocator    = NULL;
    m_pWbemServices   = NULL;
    m_pEnumObjects    = NULL;
    m_pAuthIdentity   = NULL;

    m_pClass    = NULL;
    m_pInClass  = NULL;
    m_pInInst   = NULL;
    m_pOutInst  = NULL;
}

CETDelete::~CETDelete()
/*++
 Routine Description:
        Class destructor

 Arguments:
      None
 Return Value:
        None
--*/
{
    FreeMemory((LPVOID*)& m_pszServerName);
    FreeMemory((LPVOID*)& m_pszUserName);
    FreeMemory((LPVOID*)& m_pszPassword);

    DESTROY_ARRAY(m_arrID);

    SAFE_RELEASE_INTERFACE(m_pWbemLocator);
    SAFE_RELEASE_INTERFACE(m_pWbemServices);
    SAFE_RELEASE_INTERFACE(m_pEnumObjects);

    SAFE_RELEASE_INTERFACE(m_pClass);
    SAFE_RELEASE_INTERFACE(m_pInClass);
    SAFE_RELEASE_INTERFACE(m_pInInst);
    SAFE_RELEASE_INTERFACE(m_pOutInst);

    WbemFreeAuthIdentity(&m_pAuthIdentity);

    // Uninitialize COM only when it is initialized.
    if( TRUE == m_bIsCOMInitialize)
    {
        CoUninitialize();
    }
}

void
CETDelete::Initialize()
/*++
 Routine Description:
        This function allocates and initializes variables.

 Arguments:
      None
 Return Value:
        None

--*/
{
   
    // if at all any occurs, we know that is 'coz of the
    // failure in memory allocation ... so set the error
    DEBUG_INFO;
    SetLastError( ERROR_OUTOFMEMORY );
    SaveLastError();

    SecureZeroMemory(m_szTemp,sizeof(m_szTemp));

    m_arrID = CreateDynamicArray();
    if( NULL == m_arrID )
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    
    SecureZeroMemory(cmdOptions,sizeof(TCMDPARSER2)* MAX_COMMANDLINE_D_OPTION);

    // initialization is successful
    SetLastError( NOERROR );            // clear the error
    SetReason( L"" );            // clear the reason
    DEBUG_INFO;
    return;

}

void
CETDelete::PrepareCMDStruct()
/*++
 Routine Description:
        This function will prepare column structure for DoParseParam Function.

 Arguments:
       none
 Return Value:
       none
--*/
{
    // Filling cmdOptions structure
    DEBUG_INFO;
   // -delete
    StringCopyA( cmdOptions[ ID_D_DELETE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_D_DELETE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_D_DELETE ].pwszOptions = szDeleteOption;
    cmdOptions[ ID_D_DELETE ].dwCount = 1;
    cmdOptions[ ID_D_DELETE ].dwActuals = 0;
    cmdOptions[ ID_D_DELETE ].dwFlags = 0;
    cmdOptions[ ID_D_DELETE ].pValue = &m_bDelete;
    cmdOptions[ ID_D_DELETE ].dwLength    = 0;


    // -s (servername)
    StringCopyA( cmdOptions[ ID_D_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_D_SERVER ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_D_SERVER ].pwszOptions = szServerNameOption;
    cmdOptions[ ID_D_SERVER ].dwCount = 1;
    cmdOptions[ ID_D_SERVER ].dwActuals = 0;
    cmdOptions[ ID_D_SERVER ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_D_SERVER ].pValue = NULL; //m_pszServerName
    cmdOptions[ ID_D_SERVER ].dwLength    = 0;


    // -u (username)
    StringCopyA( cmdOptions[ ID_D_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_D_USERNAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_D_USERNAME ].pwszOptions = szUserNameOption;
    cmdOptions[ ID_D_USERNAME ].dwCount = 1;
    cmdOptions[ ID_D_USERNAME ].dwActuals = 0;
    cmdOptions[ ID_D_USERNAME ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_D_USERNAME ].pValue = NULL; //m_pszUserName
    cmdOptions[ ID_D_USERNAME ].dwLength    = 0;

    // -p (password)
    StringCopyA( cmdOptions[ ID_D_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_D_PASSWORD ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_D_PASSWORD ].pwszOptions = szPasswordOption;
    cmdOptions[ ID_D_PASSWORD ].dwCount = 1;
    cmdOptions[ ID_D_PASSWORD ].dwActuals = 0;
    cmdOptions[ ID_D_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    cmdOptions[ ID_D_PASSWORD ].pValue = NULL; //m_pszPassword
    cmdOptions[ ID_D_PASSWORD ].dwLength    = 0;

    //  -tid
    StringCopyA( cmdOptions[ ID_D_ID ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_D_ID ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_D_ID ].pwszOptions = szTIDOption;
    cmdOptions[ ID_D_ID ].dwCount = 0;
    cmdOptions[ ID_D_ID ].dwActuals = 0;
    cmdOptions[ ID_D_ID ].dwFlags = CP2_MODE_ARRAY|CP2_VALUE_TRIMINPUT|
                                    CP2_VALUE_NONULL|CP_VALUE_NODUPLICATES;
    cmdOptions[ ID_D_ID ].pValue = &m_arrID;
    cmdOptions[ ID_D_ID ].dwLength    = 0;
    DEBUG_INFO;
    return;
}

void
CETDelete::ProcessOption(
    IN DWORD argc, 
    IN LPCTSTR argv[]
    ) throw (CShowError)
/*++
 Routine Description:
        This function will process/pace the command line options.
    NOTE: This function throws 'CShowError' type exception. Caller to this 
          function should handle the exception.
 Arguments:
        [ in ] argc        : argument(s) count specified at the command prompt
        [ in ] argv        : argument(s) specified at the command prompt

 Return Value:
       none
--*/
{
    // local variable
    BOOL bReturn = TRUE;
    CHString szTempString;

    PrepareCMDStruct();
    DEBUG_INFO;
    // do the actual parsing of the command line arguments and check the result
    bReturn = DoParseParam2( argc, argv, ID_D_DELETE, MAX_COMMANDLINE_D_OPTION, 
                             cmdOptions, 0);
    // Get option values from 'cmdOptions' structure.
    m_pszServerName = (LPWSTR) cmdOptions[ ID_D_SERVER ].pValue;
    m_pszUserName   = (LPWSTR) cmdOptions[ ID_D_USERNAME ].pValue;
    m_pszPassword   = (LPWSTR) cmdOptions[ ID_D_PASSWORD ].pValue;
    DEBUG_INFO;
    if( FALSE == bReturn)
    {
        throw CShowError(MK_E_SYNTAX);
    }

    // check the remote connectivity information
    if ( m_pszServerName != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name 
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails 
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password 
        // before trying to connect
        //
        // case 3: -p * is specified
        DEBUG_INFO;
        // user name
        if ( m_pszUserName == NULL )
        {
            m_pszUserName = (LPTSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( m_pszUserName == NULL )
            {
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }
        }

        // password
        if ( m_pszPassword == NULL )
        {
            m_bNeedPassword = TRUE;
            m_pszPassword = (LPTSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( m_pszPassword == NULL )
            {
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }
        }

        // case 1
        if ( cmdOptions[ ID_D_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdOptions[ ID_D_PASSWORD ].pValue == NULL )
        {
            StringCopy( m_pszPassword, L"*", SIZE_OF_DYN_ARRAY(m_pszPassword));
        }

        // case 3
        else if ( StringCompare( m_pszPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&m_pszPassword, 
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }

            // ...
            m_bNeedPassword = TRUE;
        }
    }
    DEBUG_INFO;
    if( 0 == cmdOptions[ ID_D_ID ].dwActuals)
    {
        throw CShowError(IDS_ID_REQUIRED);
    }
}

BOOL
CETDelete::ExecuteDelete()
/*++
 Routine Description:
        This routine will delete EventTriggers from WMI.

 Arguments:
      None
 Return Value:
        None

--*/
{
    // Stores functins return status.
    BOOL bResult = FALSE; 
    LONG lTriggerID = 0;
    DEBUG_INFO;
    // Total Number of Event Trigger Ids...
    DWORD dNoOfIds = 0; 
    DWORD dwIndx = 0;
    BOOL bIsValidCommandLine = TRUE;
    BOOL bIsWildcard = FALSE;

    // Used to reecive result form COM functions.
    HRESULT hr = S_OK; 

    // variable used to get/set values from/to COM functions.
    VARIANT vVariant;
    BSTR bstrTemp = NULL;
    TCHAR szEventTriggerName[MAX_RES_STRING];

    // Stores Message String
    TCHAR szMsgString[MAX_RES_STRING*4]; 
    TCHAR szMsgFormat[MAX_RES_STRING]; 
    BOOL bIsAtLeastOne = FALSE;
    try
    {
        // Analyze the default argument for ID
        DEBUG_INFO;
        dNoOfIds = DynArrayGetCount( m_arrID  );
        for(dwIndx = 0;dwIndx<dNoOfIds;dwIndx++)
        {
             StringCopy(m_szTemp,
                     DynArrayItemAsString(m_arrID,dwIndx),SIZE_OF_ARRAY(m_szTemp));
             if( 0 == StringCompare(m_szTemp,ASTERIX,TRUE,0))
             {
                // Wildcard "*" cannot be clubed with other ids
                 bIsWildcard = TRUE;
                 if(dNoOfIds > 1)
                 {
                     bIsValidCommandLine = FALSE;
                     break;
                 }
             }
             else if( FALSE == IsNumeric(m_szTemp,10,FALSE))
             {
                // Other than "*" are not excepted
                 throw CShowError(IDS_ID_NON_NUMERIC);
             }
             else if(( 0 == AsLong(m_szTemp,10))||
                     (AsLong(m_szTemp,10)>ID_MAX_RANGE))
             {
                  throw CShowError(IDS_INVALID_ID);
             }
        }
        DEBUG_INFO;
        InitializeCom(&m_pWbemLocator);
        m_bIsCOMInitialize = TRUE;

        // Connect Server.....
        // Brackets below used just to limit scope of following defined 
        // variables.
        {
            CHString szTempUser = m_pszUserName;
            CHString szTempPassword = m_pszPassword;
            BOOL bLocalSystem = TRUE;
            bResult = ConnectWmiEx( m_pWbemLocator,
                                    &m_pWbemServices,
                                    m_pszServerName,
                                    szTempUser,
                                    szTempPassword,
                                    &m_pAuthIdentity,
                                    m_bNeedPassword,
                                    WMI_NAMESPACE_CIMV2,
                                    &bLocalSystem);
            // Password is not needed , better to free it
            FreeMemory((LPVOID*)& m_pszPassword);

            if( FALSE == bResult)
            {
                DEBUG_INFO;
                ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
                return FALSE;
            }
            DEBUG_INFO;
            // check the remote system version and its compatiblity
            if ( FALSE == bLocalSystem )
            {
                DWORD dwVersion = 0;
                dwVersion = GetTargetVersionEx( m_pWbemServices, 
                                                m_pAuthIdentity );
                if ( dwVersion <= 5000 )// to block win2k versions
                {
                    SetReason( E_REMOTE_INCOMPATIBLE );
                    ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
                    return FALSE;
                }
                // For XP systems.
                if( 5001 == dwVersion )
                {
                    if( TRUE == DeleteXPResults( bIsWildcard, dNoOfIds ) )
                    {
                        // Displayed triggers present.
                        return TRUE;
                    }
                    else
                    {
                        // Failed to display results .
                        // Error message is already displayed.
                        return FALSE;
                    }
                }
            }

            // check the local credentials and if need display warning
            if ( bLocalSystem && ( 0 != StringLength(m_pszUserName,0)))
            {
                DEBUG_INFO;
                WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
                ShowLastErrorEx(stderr,SLE_TYPE_WARNING|SLE_INTERNAL);
            }

        }


    // retrieves  TriggerEventConsumer class
    DEBUG_INFO;
    bstrTemp = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
    hr = m_pWbemServices->GetObject(bstrTemp,
                               0, NULL, &m_pClass, NULL);
    SAFE_RELEASE_BSTR(bstrTemp);
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;
    
    // Gets  information about the "DeleteETrigger" method of
    // "TriggerEventConsumer" class
    bstrTemp = SysAllocString(FN_DELETE_ETRIGGER);
    hr = m_pClass->GetMethod(bstrTemp,
                            0, &m_pInClass, NULL);
    SAFE_RELEASE_BSTR(bstrTemp);
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

   // create a new instance of a class "TriggerEventConsumer ".
    hr = m_pInClass->SpawnInstance(0, &m_pInInst);
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

    //Following method will creates an enumerator that returns the instances of
    // a specified TriggerEventConsumer class
    bstrTemp = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
    hr = m_pWbemServices->CreateInstanceEnum(bstrTemp,
                                        WBEM_FLAG_SHALLOW,
                                        NULL,
                                        &m_pEnumObjects);
    SAFE_RELEASE_BSTR(bstrTemp);
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

    VariantInit(&vVariant);
    // set the security at the interface level also
        hr = SetInterfaceSecurity( m_pEnumObjects, m_pAuthIdentity );
     ON_ERROR_THROW_EXCEPTION(hr);
     DEBUG_INFO;

     if( TRUE == bIsWildcard) // means * is choosen
      {
          // instance of NTEventLogConsumer is cretated and now check
        // for available TriggerID
        DEBUG_INFO;
        while( TRUE == GiveTriggerID(&lTriggerID,szEventTriggerName))
        {
            DEBUG_INFO;
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);


            // Set the TriggerName property .
            hr = PropertyPut( m_pInInst, FPR_TRIGGER_NAME, 
                              _bstr_t(szEventTriggerName));
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;


            // All The required properties sets, so
            // executes DeleteETrigger method to delete eventtrigger
            hr = m_pWbemServices->
                ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                           _bstr_t(FN_DELETE_ETRIGGER),
                           0, NULL, m_pInInst,&m_pOutInst,NULL);
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

            VARIANT vtValue;
            // initialize the variant and then get the value of the specified property
            VariantInit( &vtValue );

            hr = m_pOutInst->Get( _bstr_t( FPR_RETURN_VALUE ), 0, &vtValue, NULL, NULL );
            ON_ERROR_THROW_EXCEPTION( hr );
            
            //Get Output paramters.
            hr = vtValue.lVal;

            // Clear the variant variable
            VariantClear( &vtValue );

            if( FAILED(hr))
            {
                if ( !(( ERROR_TRIGGER_NOT_FOUND == hr) ||
                     ( ERROR_TRIGGER_NOT_DELETED == hr) ||
                     ( ERROR_TRIGGER_NOT_FOUND == hr)))
                {
                      ON_ERROR_THROW_EXCEPTION(hr);
                }
            }
            DEBUG_INFO;
            if(SUCCEEDED(hr)) // Means deletion is successful......
            {
                DEBUG_INFO;
                StringCopy( szMsgFormat, GetResString(IDS_DELETE_SUCCESS),
                             SIZE_OF_ARRAY(szMsgFormat));
                StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString), 
                                  szMsgFormat, _X(szEventTriggerName), lTriggerID);
                ShowMessage(stdout,szMsgString);
                bIsAtLeastOne = TRUE;
            }
             // Means unable to delete trigger due to some problem like someone 
             // renamed Schedule task name etc.
             else if ( ERROR_TRIGGER_NOT_DELETED == hr) 
             {
                 // This error will come if logged on user has no 
                 // right on attached schedule task.
                 continue;
             }
             // This error will come only if multiple instances are running. 
             // This is due to sending a non existance Trigger Name.
             else if (ERROR_TRIGGER_NOT_FOUND == hr)
             {
                 DEBUG_INFO;

                 // Just ignore this error.
                 continue; 
             }
             else
             {
                  DEBUG_INFO;
                  ON_ERROR_THROW_EXCEPTION(hr);
             }
        } // End of while loop
        if( FALSE == bIsAtLeastOne)
        {
            DEBUG_INFO;
            ShowMessage(stdout,GetResString(IDS_NO_EVENTID));
        }
        else
        {
            // Display one balnk line.
            ShowMessage(stdout,L"\n");
        }
      } // end of if
      else // Idividual trigger is specified 
      {
        DEBUG_INFO;
        bIsAtLeastOne = FALSE;
        for(dwIndx=0;dwIndx<dNoOfIds;dwIndx++)
        {
            lTriggerID = AsLong(DynArrayItemAsString(m_arrID,dwIndx),10);
            DEBUG_INFO;
            if( TRUE == GiveTriggerName(lTriggerID,szEventTriggerName))
            {
                DEBUG_INFO;
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // Set the TriggerName property .
                hr = PropertyPut( m_pInInst, FPR_TRIGGER_NAME, 
                                  _bstr_t(szEventTriggerName));
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;

                // All The required properties sets, so
                // executes DeleteETrigger method to delete eventtrigger

                hr = m_pWbemServices->
                    ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                               _bstr_t(FN_DELETE_ETRIGGER),
                               0, NULL, m_pInInst, &m_pOutInst, NULL);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;


                VARIANT vtValue;
                // initialize the variant and then get the value of the specified property
                VariantInit( &vtValue );

                hr = m_pOutInst->Get( _bstr_t( FPR_RETURN_VALUE ), 0, &vtValue, NULL, NULL );
                ON_ERROR_THROW_EXCEPTION( hr );
                
                //Get Output paramters.
                hr = vtValue.lVal;

                // Clear the variant variable
                VariantClear( &vtValue );
                
                if( FAILED(hr))
                {
                    if ( !(( ERROR_TRIGGER_NOT_FOUND == hr) ||
                         ( ERROR_TRIGGER_NOT_DELETED == hr)    ||
                         ( ERROR_TRIGGER_NOT_FOUND == hr)))
                    {
                          ON_ERROR_THROW_EXCEPTION(hr);
                    }
                }

                if( SUCCEEDED(hr)) // Means deletion is successful......
                {
                    DEBUG_INFO;
                    bIsAtLeastOne = TRUE;
                    StringCopy( szMsgFormat, GetResString(IDS_DELETE_SUCCESS),
                                SIZE_OF_ARRAY(szMsgFormat));

                    StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString), 
                                      szMsgFormat, _X(szEventTriggerName), lTriggerID);
                    ShowMessage(stdout,szMsgString);
                }
                // Provider sends this if if failed to delete eventrigger of 
                // given ID.
                else if (ERROR_TRIGGER_NOT_FOUND == hr)
                {
                    DEBUG_INFO;
                    bIsAtLeastOne = TRUE;
                    StringCopy( szMsgFormat, GetResString(IDS_DELETE_ERROR),
                              SIZE_OF_ARRAY(szMsgFormat));

                    StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString), 
                                    szMsgFormat, lTriggerID);

                    // Message shown on screen will be...
                    // FAILURE: "EventID" is not a Valid Event ID
                    ShowMessage(stdout,szMsgString);
                }
                // Means unable to delete trigger due to some problem like 
                // someone renamed Schedule task name etc.
                else if ( ERROR_TRIGGER_NOT_DELETED == hr) 
                {
                    DEBUG_INFO;
                    StringCopy( szMsgFormat, GetResString(IDS_UNABLE_DELETE) ,
                              SIZE_OF_ARRAY(szMsgFormat));
                    StringCchPrintfW(szMsgString, SIZE_OF_ARRAY(szMsgString), 
                                   szMsgFormat,lTriggerID);
                    // Message shown on screen will be...
                    // Info: Unable to delete event trigger id "EventID".
                    ShowMessage( stdout, szMsgString);
                }
                else
                {
                   DEBUG_INFO;
                   ON_ERROR_THROW_EXCEPTION(hr);
                }

            } // End if
            else
            {
                  DEBUG_INFO;
                  bIsAtLeastOne = TRUE;
                  StringCopy( szMsgFormat, GetResString(IDS_DELETE_ERROR),
                              SIZE_OF_ARRAY(szMsgFormat));
                  StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString), 
                                    szMsgFormat,lTriggerID);

                 // Message shown on screen will be...
                 // FAILURE: "EventID" is not a Valid Event ID
                 ShowMessage(stdout,szMsgString);
            }

        }// End for
        if (TRUE == bIsAtLeastOne)
        {
            ShowMessage(stdout,L"\n");
        }

      } // End else
    }
    catch(_com_error)
    {
        DEBUG_INFO;
        if( 0x80041002 == hr )// WMI returns string for this hr value is
                            // "Not Found." which is not user friendly. So
                            // changing the message text.
        {
            ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
        }
        else
        {
            DEBUG_INFO;
            ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        }
        DEBUG_INFO;
        return FALSE;

    }
    DEBUG_INFO;
    return TRUE;
}

BOOL
CETDelete::GiveTriggerName(
    IN  LONG lTriggerID, 
    OUT LPTSTR pszTriggerName
    )
/*++

Routine Descripton:

     This function Will return Event Trigger Name for lTriggerID

Arguments:

    [in]  lTriggerID      : Will Have Event Trigger ID
    [out] pszTriggerName  : Will return Event Trigger Name
Return Value:

  TRUE - if Successfully Gets  EventTrigger ID and Event Trigger Name
  FALSE - if ERROR
--*/
{
    BOOL bReturn = TRUE; // holds status of return value of this function
    LONG lTriggerID1; // Holds trigger id
    IWbemClassObject *pObj1 = NULL;
    ULONG uReturned1 = 0;
    HRESULT hRes = S_OK; // used to reecive result form COM functions
    BOOL bAlwaysTrue = TRUE;
    
    DEBUG_INFO;    
    // Resets it as It may be previouly pointing to other than first instance
    m_pEnumObjects->Reset();
    while(bAlwaysTrue)
    {
        hRes = m_pEnumObjects->Next(0,1,&pObj1,&uReturned1);

        if(FAILED(hRes))
        {
            DEBUG_INFO;
            ON_ERROR_THROW_EXCEPTION( hRes );
            break;
        }
        DEBUG_INFO;
        if( 0 == uReturned1 )
        {
            SAFE_RELEASE_INTERFACE(pObj1);
            bReturn = FALSE;
            return bReturn;

        }

        // Get Trigger ID
        hRes = PropertyGet1(pObj1,FPR_TRIGGER_ID,&lTriggerID1,sizeof(LONG));
        if(FAILED(hRes))
        {
            DEBUG_INFO;
            SAFE_RELEASE_INTERFACE(pObj1);
            ON_ERROR_THROW_EXCEPTION( hRes );
            bReturn = FALSE;
            return bReturn;
        }
        DEBUG_INFO;

        if(lTriggerID == lTriggerID1)
        {

            DEBUG_INFO;
            // Get Trigger Name
            hRes = PropertyGet1(pObj1,FPR_TRIGGER_NAME,pszTriggerName,
                                MAX_RES_STRING);
            if(FAILED(hRes))
            {
                DEBUG_INFO;
                SAFE_RELEASE_INTERFACE(pObj1);
                ON_ERROR_THROW_EXCEPTION( hRes );
                bReturn = FALSE;
                return bReturn;
            }
                DEBUG_INFO;
                bReturn = TRUE;
                break;
        }
    }
    SAFE_RELEASE_INTERFACE(pObj1);
    DEBUG_INFO;
    return bReturn;
}

BOOL
CETDelete::GiveTriggerID(
    OUT LONG *pTriggerID,
    OUT LPTSTR pszTriggerName
    )
/*++

Routine Description:

  This function Will return Trigger Id and Trigger Name of class pointed
  by IEnumWbemClassObject pointer

Arguments:

    [out] pTriggerID              : Will return Event Trigger ID
    [out] pszTriggerName          : Will return Event Trigger Name
                                   
Return Value:

     TRUE - if Successfully Gets  EventTrigger ID and Event Trigger Name
     FALSE - if ERROR
--*/
{
    BOOL bReturn = TRUE; // status of return value of this function
    IWbemClassObject *pObj1 = NULL;
    ULONG uReturned1 = 0;
    DEBUG_INFO;
    HRESULT hRes = m_pEnumObjects->Next(0,1,&pObj1,&uReturned1);
    if(FAILED(hRes))
    {
        DEBUG_INFO;
        ON_ERROR_THROW_EXCEPTION( hRes );
        bReturn = FALSE;
        return bReturn;
    }
    if( 0 == uReturned1)
    {
        DEBUG_INFO;
        SAFE_RELEASE_INTERFACE(pObj1);
        bReturn = FALSE;
        return bReturn;

    }
    DEBUG_INFO;
    // Get Trigger ID
    hRes = PropertyGet1(pObj1,FPR_TRIGGER_ID,pTriggerID,sizeof(LONG));
    if(FAILED(hRes))
    {
        DEBUG_INFO;
        SAFE_RELEASE_INTERFACE(pObj1);
        ON_ERROR_THROW_EXCEPTION( hRes );
        bReturn = FALSE;
        return bReturn;
    }

    // Get Trigger Name
    hRes = PropertyGet1( pObj1, FPR_TRIGGER_NAME, pszTriggerName, 
                         MAX_RES_STRING);
    if(FAILED(hRes))
    {
        DEBUG_INFO;
        SAFE_RELEASE_INTERFACE(pObj1);
        ON_ERROR_THROW_EXCEPTION( hRes );
        bReturn = FALSE;
        return bReturn;
    }
    DEBUG_INFO;
    SAFE_RELEASE_INTERFACE(pObj1);
    return bReturn;
}



BOOL
CETDelete::DeleteXPResults(
    IN BOOL bIsWildcard,
    IN DWORD dNoOfIds
    )
/*++
Routine Description:
   This function deletes the triggers present on a remote XP machine.
   This function is for compatibility of .NET ot XP machine only.

Arguments:

    [in] bIsWildCard    - If TRUE then all triggers needs to be deleted.
    [in] dNoOfIds       - Contains the number of triggers present.

Return Value:
     BOOL: TRUE - If succedded in deleting results.
           FALSE- otherwise

--*/
{
    HRESULT hr = S_OK;
    VARIANT vVariant;
    LONG lTriggerID = 0;
    TCHAR szEventTriggerName[MAX_RES_STRING];
    TCHAR szMsgFormat[MAX_RES_STRING];
    TCHAR szMsgString[MAX_RES_STRING*4];
    BOOL bIsAtLeastOne = FALSE;

    try
    {
    // retrieves  TriggerEventConsumer class
    DEBUG_INFO;
    hr = m_pWbemServices->GetObject(_bstr_t( CLS_TRIGGER_EVENT_CONSUMER ),
                               0, NULL, &m_pClass, NULL);
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

    // Gets  information about the "DeleteETrigger" method of
    // "TriggerEventConsumer" class
    hr = m_pClass->GetMethod(_bstr_t( FN_DELETE_ETRIGGER_XP ),
                            0, &m_pInClass, NULL);
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

   // create a new instance of a class "TriggerEventConsumer ".
    hr = m_pInClass->SpawnInstance(0, &m_pInInst);
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

    //Following method will creates an enumerator that returns the instances of
    // a specified TriggerEventConsumer class
    hr = m_pWbemServices->CreateInstanceEnum(_bstr_t( CLS_TRIGGER_EVENT_CONSUMER ),
                                        WBEM_FLAG_SHALLOW,
                                        NULL,
                                        &m_pEnumObjects);
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

    VariantInit(&vVariant);
    // set the security at the interface level also
    hr = SetInterfaceSecurity( m_pEnumObjects, m_pAuthIdentity );
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

     if( TRUE == bIsWildcard) // means * is choosen
      {
          // instance of NTEventLogConsumer is cretated and now check
        // for available TriggerID
        DEBUG_INFO;
        while( TRUE == GiveTriggerID(&lTriggerID,szEventTriggerName))
        {
            DEBUG_INFO;
            VariantClear(&vVariant);

            // Set the TriggerName property .
            hr = PropertyPut( m_pInInst, FPR_TRIGGER_NAME,
                              _bstr_t(szEventTriggerName));
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

            // All The required properties sets, so
            // executes DeleteETrigger method to delete eventtrigger
            hr = m_pWbemServices->
                ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                           _bstr_t(FN_DELETE_ETRIGGER_XP),
                           0, NULL, m_pInInst,&m_pOutInst,NULL);
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

            // Get Return Value from DeleteETrigger function
            DWORD dwTemp;
            if( FALSE == PropertyGet(m_pOutInst,FPR_RETURN_VALUE,dwTemp))
            {

                return FALSE;
            }

            DEBUG_INFO;
            switch( (LONG)dwTemp )
            {
            case 0:     // Means deletion is successful......
                DEBUG_INFO;
                bIsAtLeastOne = TRUE;
                StringCopy( szMsgFormat, GetResString(IDS_DELETE_SUCCESS),
                            SIZE_OF_ARRAY(szMsgFormat));

                StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                  szMsgFormat, _X(szEventTriggerName), lTriggerID);
                ShowMessage(stdout,szMsgString);

                break;
            case 1:     // Provider returns if failed to delete eventrigger of given ID.
                DEBUG_INFO;
                bIsAtLeastOne = TRUE;
                StringCopy( szMsgFormat, GetResString(IDS_DELETE_ERROR),
                          SIZE_OF_ARRAY(szMsgFormat));

                StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                szMsgFormat, lTriggerID);

                // Message shown on screen will be...
                // FAILURE: "EventID" is not a Valid Event ID
                ShowMessage(stdout,szMsgString);
                break;
            default:
                  DEBUG_INFO;
                  bIsAtLeastOne = TRUE;
                  StringCopy( szMsgFormat, GetResString(IDS_DELETE_ERROR),
                              SIZE_OF_ARRAY(szMsgFormat));
                  StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                    szMsgFormat,lTriggerID);

                 // Message shown on screen will be...
                 // FAILURE: "EventID" is not a Valid Event ID
                 ShowMessage(stderr,szMsgString);
                break;
            }
        } // End of while loop
        if( FALSE == bIsAtLeastOne)
        {
            DEBUG_INFO;
            ShowMessage(stdout,GetResString(IDS_NO_EVENTID));
        }
        else
        {
            // Display one balnk line.
            ShowMessage(stdout,L"\n");
        }
      } // end of if
      else
      {
        DEBUG_INFO;
        for( DWORD dwIndx=0;dwIndx<dNoOfIds;dwIndx++)
        {
            lTriggerID = AsLong(DynArrayItemAsString(m_arrID,dwIndx),10);
            DEBUG_INFO;
            if( TRUE == GiveTriggerName(lTriggerID,szEventTriggerName))
            {
                DEBUG_INFO;
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // Set the TriggerName property .
                hr = PropertyPut( m_pInInst, FPR_TRIGGER_NAME,
                                  _bstr_t(szEventTriggerName));
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;

                // All The required properties sets, so
                // executes DeleteETrigger method to delete eventtrigger

                hr = m_pWbemServices->
                    ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                               _bstr_t(FN_DELETE_ETRIGGER_XP),
                               0, NULL, m_pInInst, &m_pOutInst, NULL);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;

                // Get Return Value from DeleteETrigger function
                DWORD dwTemp;
                if( FALSE == PropertyGet(m_pOutInst,FPR_RETURN_VALUE,dwTemp))
                {
                    return FALSE;
                }

                switch( (LONG)dwTemp )
                {
                case 0:     // Means deletion is successful......
                    DEBUG_INFO;
                    StringCopy( szMsgFormat, GetResString(IDS_DELETE_SUCCESS),
                                SIZE_OF_ARRAY(szMsgFormat));

                    StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                      szMsgFormat, _X(szEventTriggerName), lTriggerID);
                    ShowMessage(stdout,szMsgString);

                    break;
                case 1:     // Provider returns if failed to delete eventrigger of given ID.
                    DEBUG_INFO;
                    StringCopy( szMsgFormat, GetResString(IDS_DELETE_ERROR),
                              SIZE_OF_ARRAY(szMsgFormat));

                    StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                    szMsgFormat, lTriggerID);

                    // Message shown on screen will be...
                    // FAILURE: "EventID" is not a Valid Event ID
                    ShowMessage(stdout,szMsgString);
                    break;
                default:
                      DEBUG_INFO;
                      StringCopy( szMsgFormat, GetResString(IDS_DELETE_ERROR),
                                  SIZE_OF_ARRAY(szMsgFormat));
                      StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                        szMsgFormat,lTriggerID);

                     // Message shown on screen will be...
                     // FAILURE: "EventID" is not a Valid Event ID
                     ShowMessage(stderr,szMsgString);
                    break;
                }
            } // End if
            else
            {
                  DEBUG_INFO;
                  StringCopy( szMsgFormat, GetResString(IDS_DELETE_ERROR),
                              SIZE_OF_ARRAY(szMsgFormat));
                  StringCchPrintfW( szMsgString, SIZE_OF_ARRAY(szMsgString),
                                    szMsgFormat,lTriggerID);

                 // Message shown on screen will be...
                 // FAILURE: "EventID" is not a Valid Event ID
                 ShowMessage(stderr,szMsgString);
            }
        }// End for
        // Display one balnk line.
        ShowMessage(stdout,L"\n");
      } // End else
    }
    catch( _com_error e )
    {
        DEBUG_INFO;

        // WMI returns string for this hr value is "Not Found." which is not
        // user friendly. So changing the message text.
        if( 0x80041002 == hr )
        {
            ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
        }
        else
        {
            DEBUG_INFO;
            WMISaveError( e );
            ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        }
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        return FALSE;
    }

    // Operation successful.
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\etquery.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

  ETQuery.CPP

Abstract:

  This module  is intended to have the functionality for EVENTTRIGGERS.EXE
  with -query parameter.

  This will Query WMI and shows presently available Event Triggers.

Author:
  Akhil Gokhale 03-Oct.-2000 (Created it)

Revision History:

******************************************************************************/
#include "pch.h"
#include "ETCommon.h"
#include "resource.h"
#include "ShowError.h"
#include "ETQuery.h"
#include "WMI.h"
#define   DEFAULT_USER L"NT AUTHORITY\\SYSTEM"
#define   DBL_SLASH L"\\\\";
// Defines local to this file

#define SHOW_WQL_QUERY L"select * from __instancecreationevent where"
#define QUERY_STRING_AND L"select * from __instancecreationevent where \
targetinstance isa \"win32_ntlogevent\" AND"
#define BLANK_LINE L"\n"
#define QUERY_SCHEDULER_STATUS L"select * from Win32_Service where Name=\"Schedule\""
#define STATUS_PROPERTY  L"Started"
CETQuery::CETQuery()
/*++
 Routine Description:
    Class default constructor.

 Arguments:
      None
 Return Value:
        None

--*/
{
    // init to defaults
    m_bNeedDisconnect = FALSE;
    m_pszServerName   = NULL;
    m_pszUserName     = NULL;
    m_pszPassword     = NULL;
    m_pszFormat       = NULL;
    m_pszTriggerID    = NULL;
    m_bVerbose        = FALSE;
    m_bNoHeader       = FALSE;

    m_bNeedPassword         = FALSE;
    m_bUsage                = FALSE;
    m_bQuery                = FALSE;
    m_pWbemLocator          = NULL;
    m_pWbemServices         = NULL;
    m_pAuthIdentity         = NULL;
    m_pObj                  = NULL;
    m_pTriggerEventConsumer = NULL;
    m_pEventFilter          = NULL;
    m_arrColData            = NULL;
    m_pszEventQuery         = NULL;
    m_bIsCOMInitialize      = FALSE;
    m_dwLowerBound          = 0;
    m_dwUpperBound          = 0;


    m_pClass    = NULL;
    m_pInClass  = NULL;
    m_pInInst   = NULL;
    m_pOutInst  = NULL;

    m_pITaskScheduler = NULL;

    m_lHostNameColWidth    = WIDTH_HOSTNAME;
    m_lTriggerIDColWidth   = WIDTH_TRIGGER_ID;
    m_lETNameColWidth      = WIDTH_TRIGGER_NAME;
    m_lTaskColWidth        = WIDTH_TASK;
    m_lQueryColWidth       = WIDTH_EVENT_QUERY;
    m_lDescriptionColWidth = WIDTH_DESCRIPTION;
    m_lWQLColWidth         = 0;
    m_lTaskUserName        = WIDTH_TASK_USERNAME;

}

CETQuery::CETQuery(
    LONG lMinMemoryReq,
    BOOL bNeedPassword
    )
/*++
 Routine Description:
     Class constructor.

 Arguments:
      None
 Return Value:
        None

--*/
{
    // init to defaults
    m_bNeedDisconnect     = FALSE;

    m_pszServerName     = NULL;
    m_pszUserName       = NULL;
    m_pszPassword       = NULL;
    m_pszFormat         = NULL;
    m_pszTriggerID      = NULL;
    m_bVerbose          = FALSE;
    m_bNoHeader         = FALSE;
    m_bIsCOMInitialize  = FALSE;

    m_bNeedPassword   = bNeedPassword;
    m_bUsage          = FALSE;
    m_bQuery          = FALSE;
    m_lMinMemoryReq   = lMinMemoryReq;

    m_pClass    = NULL;
    m_pInClass  = NULL;
    m_pInInst   = NULL;
    m_pOutInst  = NULL;

    m_pWbemLocator          = NULL;
    m_pWbemServices         = NULL;
    m_pAuthIdentity         = NULL;
    m_arrColData            = NULL;
    m_pObj                  = NULL;
    m_pTriggerEventConsumer = NULL;
    m_pEventFilter          = NULL;
    m_dwLowerBound          = 0;
    m_dwUpperBound          = 0;
    m_pITaskScheduler = NULL;


    m_pszEventQuery         = NULL;
    m_lHostNameColWidth     = WIDTH_HOSTNAME;
    m_lTriggerIDColWidth    = WIDTH_TRIGGER_ID;
    m_lETNameColWidth       = WIDTH_TRIGGER_NAME;
    m_lTaskColWidth         = WIDTH_TASK;
    m_lQueryColWidth        = WIDTH_EVENT_QUERY;
    m_lDescriptionColWidth  = WIDTH_DESCRIPTION;
    m_lWQLColWidth          = 0;
    m_lTaskUserName         = WIDTH_TASK_USERNAME;
}

CETQuery::~CETQuery()
/*++
 Routine Description:
     Class desctructor. It frees memory which is allocated during instance
   creation.

 Arguments:
      None
 Return Value:
        None

--*/
{
    DEBUG_INFO;
    FreeMemory((LPVOID*)& m_pszUserName);
    FreeMemory((LPVOID*)& m_pszPassword);
    FreeMemory((LPVOID*)& m_pszFormat);
    FreeMemory((LPVOID*)& m_pszTriggerID);
    DESTROY_ARRAY(m_arrColData);


    SAFE_RELEASE_INTERFACE(m_pWbemLocator);
    SAFE_RELEASE_INTERFACE(m_pWbemServices);
    SAFE_RELEASE_INTERFACE(m_pObj);
    SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
    SAFE_RELEASE_INTERFACE(m_pEventFilter);

    SAFE_RELEASE_INTERFACE(m_pClass);
    SAFE_RELEASE_INTERFACE(m_pInClass);
    SAFE_RELEASE_INTERFACE(m_pInInst);
    SAFE_RELEASE_INTERFACE(m_pOutInst);
    SAFE_RELEASE_INTERFACE(m_pITaskScheduler);

    // Release Authority
    WbemFreeAuthIdentity(&m_pAuthIdentity);


    RELEASE_MEMORY_EX(m_pszEventQuery);

    // Close the remote connection if any.
    if (FALSE == m_bLocalSystem)
    {
        CloseConnection(m_pszServerName);
    }
    FreeMemory((LPVOID*)& m_pszServerName);

    // Uninitialize COM only when it is initialized.
    if( TRUE == m_bIsCOMInitialize )
    {
        CoUninitialize();
    }
    DEBUG_INFO;

}

void
CETQuery::PrepareCMDStruct()
/*++
 Routine Description:
        This function will prepare column structure for DoParseParam Function.

 Arguments:
       none
 Return Value:
       none
--*/
{
   DEBUG_INFO;
   // -query
    StringCopyA( cmdOptions[ ID_Q_QUERY ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_Q_QUERY ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_Q_QUERY ].pwszOptions = szQueryOption;
    cmdOptions[ ID_Q_QUERY ].dwCount = 1;
    cmdOptions[ ID_Q_QUERY ].dwActuals = 0;
    cmdOptions[ ID_Q_QUERY ].dwFlags = 0;
    cmdOptions[ ID_Q_QUERY ].pValue = &m_bQuery;
    cmdOptions[ ID_Q_QUERY ].dwLength    = 0;


    // -s (servername)
    StringCopyA( cmdOptions[ ID_Q_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_Q_SERVER ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_Q_SERVER ].pwszOptions = szServerNameOption;
    cmdOptions[ ID_Q_SERVER ].dwCount = 1;
    cmdOptions[ ID_Q_SERVER ].dwActuals = 0;
    cmdOptions[ ID_Q_SERVER ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_Q_SERVER ].pValue = NULL; //m_pszServerName
    cmdOptions[ ID_Q_SERVER ].dwLength    = 0;

    // -u (username)
    StringCopyA( cmdOptions[ ID_Q_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_Q_USERNAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_Q_USERNAME ].pwszOptions = szUserNameOption;
    cmdOptions[ ID_Q_USERNAME ].dwCount = 1;
    cmdOptions[ ID_Q_USERNAME ].dwActuals = 0;
    cmdOptions[ ID_Q_USERNAME ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_Q_USERNAME ].pValue = NULL; //m_pszUserName
    cmdOptions[ ID_Q_USERNAME ].dwLength    = 0;

    // -p (password)
    StringCopyA( cmdOptions[ ID_Q_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_Q_PASSWORD ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_Q_PASSWORD ].pwszOptions = szPasswordOption;
    cmdOptions[ ID_Q_PASSWORD ].dwCount = 1;
    cmdOptions[ ID_Q_PASSWORD ].dwActuals = 0;
    cmdOptions[ ID_Q_PASSWORD ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_OPTIONAL;
    cmdOptions[ ID_Q_PASSWORD ].pValue = NULL; //m_pszPassword
    cmdOptions[ ID_Q_PASSWORD ].dwLength    = 0;

    // -fo
    StringCopyA( cmdOptions[ ID_Q_FORMAT ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_Q_FORMAT ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_Q_FORMAT ].pwszOptions = szFormatOption;
    cmdOptions[ ID_Q_FORMAT ].pwszValues = GetResString(IDS_FORMAT_OPTIONS);
    cmdOptions[ ID_Q_FORMAT ].dwCount = 1;
    cmdOptions[ ID_Q_FORMAT ].dwActuals = 0;
    cmdOptions[ ID_Q_FORMAT ].dwFlags = CP2_MODE_VALUES  | CP2_VALUE_TRIMINPUT|
                                        CP2_VALUE_NONULL | CP2_ALLOCMEMORY;
    cmdOptions[ ID_Q_FORMAT ].pValue = NULL;
    cmdOptions[ ID_Q_FORMAT ].dwLength    = MAX_STRING_LENGTH;



    // -nh
    StringCopyA( cmdOptions[ ID_Q_NOHEADER ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_Q_NOHEADER ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_Q_NOHEADER ].pwszOptions = szNoHeaderOption;
    cmdOptions[ ID_Q_NOHEADER ].pwszValues = NULL;
    cmdOptions[ ID_Q_NOHEADER ].dwCount = 1;
    cmdOptions[ ID_Q_NOHEADER ].dwActuals = 0;
    cmdOptions[ ID_Q_NOHEADER ].dwFlags = 0;
    cmdOptions[ ID_Q_NOHEADER ].pValue = &m_bNoHeader;

    // -v verbose
    StringCopyA( cmdOptions[ ID_Q_VERBOSE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_Q_VERBOSE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_Q_VERBOSE ].pwszOptions = szVerboseOption;
    cmdOptions[ ID_Q_VERBOSE ].pwszValues = NULL;
    cmdOptions[ ID_Q_VERBOSE ].dwCount = 1;
    cmdOptions[ ID_Q_VERBOSE ].dwActuals = 0;
    cmdOptions[ ID_Q_VERBOSE ].dwFlags = 0;
    cmdOptions[ ID_Q_VERBOSE ].pValue = &m_bVerbose;
    cmdOptions[ ID_Q_VERBOSE ].dwLength    = 0;

    // -id
    StringCopyA( cmdOptions[ ID_Q_TRIGGERID ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_Q_TRIGGERID ].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_Q_TRIGGERID ].pwszOptions = szTriggerIDOption;
    cmdOptions[ ID_Q_TRIGGERID ].pwszValues = NULL;
    cmdOptions[ ID_Q_TRIGGERID ].dwCount = 1;
    cmdOptions[ ID_Q_TRIGGERID ].dwActuals = 0;
    cmdOptions[ ID_Q_TRIGGERID ].dwFlags = CP2_ALLOCMEMORY|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    cmdOptions[ ID_Q_TRIGGERID ].pValue = NULL;

    DEBUG_INFO;
}

void
CETQuery::ProcessOption(
    IN DWORD argc,
    IN LPCTSTR argv[])
/*++
 Routine Description:
        This function will process/parce the command line options.

 Arguments:
        [ in ] argc        : argument(s) count specified at the command prompt
        [ in ] argv        : argument(s) specified at the command prompt

 Return Value:
        TRUE  : On Successful
      FALSE : On Error

--*/
{
    // local variable
    BOOL bReturn = TRUE;
    CHString szTempString;
    DEBUG_INFO;
    PrepareCMDStruct ();

    // do the actual parsing of the command line arguments and check the result
    bReturn = DoParseParam2( argc, argv, ID_Q_QUERY,
                            MAX_COMMANDLINE_Q_OPTION, cmdOptions ,0);

    // Take values from 'cmdOptions' structure
    m_pszServerName = (LPWSTR)cmdOptions[ ID_Q_SERVER ].pValue;
    m_pszUserName   = (LPWSTR)cmdOptions[ ID_Q_USERNAME ].pValue;
    m_pszPassword   = (LPWSTR)cmdOptions[ ID_Q_PASSWORD ].pValue;
    m_pszFormat     = (LPWSTR)cmdOptions[ ID_Q_FORMAT ].pValue;
    m_pszTriggerID  = (LPWSTR)cmdOptions[ ID_Q_TRIGGERID ].pValue;
    if( FALSE == bReturn)
    {
        throw CShowError(MK_E_SYNTAX);
    }
    DEBUG_INFO;

    // "-p" should not be specified without -u
    if ( (0 == cmdOptions[ID_Q_USERNAME].dwActuals) &&
         (0 != cmdOptions[ID_Q_PASSWORD].dwActuals ))
    {
        // invalid syntax
        throw CShowError(IDS_USERNAME_REQUIRED);
    }

    DEBUG_INFO;
    if( (1 == cmdOptions[ID_Q_TRIGGERID].dwActuals) &&
       (FALSE == GetNValidateTriggerId( &m_dwLowerBound, &m_dwUpperBound )))
    {
        throw CShowError(IDS_INVALID_RANGE);

    }


    // check the remote connectivity information
    if ( m_pszServerName != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( m_pszUserName == NULL )
        {
            DEBUG_INFO;
            m_pszUserName = (LPTSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( m_pszUserName == NULL )
            {
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }
            DEBUG_INFO;
        }

        // password
        if ( m_pszPassword == NULL )
        {
            m_bNeedPassword = TRUE;
            m_pszPassword = (LPTSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( m_pszPassword == NULL )
            {
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }
        }

        // case 1
        if ( cmdOptions[ ID_Q_PASSWORD ].dwActuals == 0 )
        {
            // we need not do anything special here
        }

        // case 2
        else if ( cmdOptions[ ID_Q_PASSWORD ].pValue == NULL )
        {
            StringCopy( m_pszPassword, L"*", SIZE_OF_DYN_ARRAY(m_pszPassword));
        }

        // case 3
        else if ( StringCompare( m_pszPassword, L"*", TRUE, 0 ) == 0 )
        {
            if ( ReallocateMemory( (LPVOID*)&m_pszPassword,
                                   MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
            {
                SaveLastError();
                throw CShowError(E_OUTOFMEMORY);
            }

            // ...
            m_bNeedPassword = TRUE;
        }
    }
    DEBUG_INFO;
    if((TRUE == m_bNoHeader) &&(1 == cmdOptions[ ID_Q_FORMAT ].dwActuals) &&
       (0 == StringCompare(m_pszFormat,GetResString(IDS_STRING_LIST),TRUE,0)))
     {
        throw CShowError(IDS_HEADER_NOT_ALLOWED);
     }

    if (m_pszTriggerID && (((0 != cmdOptions[ID_Q_TRIGGERID].dwActuals) &&
        (0 == StringLength( m_pszTriggerID,0))) ||
        (0 == StringCompare( m_pszTriggerID,_T("0"),FALSE,0))))
    {
        DEBUG_INFO;
        throw CShowError(IDS_INVALID_ID);
    }

}

void
CETQuery::Initialize()
/*++
 Routine Description:
    This function will allocate memory to variables and also checks it and
  fills variable with value ZERO.

 Arguments:
      None
 Return Value:
        None

--*/
{
    // if at all any occurs, we know that is 'coz of the
    // failure in memory allocation ... so set the error
    SetLastError( ERROR_OUTOFMEMORY );
    SaveLastError();
    DEBUG_INFO;
    SecureZeroMemory(m_szBuffer,sizeof(m_szBuffer));
    SecureZeroMemory(m_szEventDesc,sizeof(m_szEventDesc));
    SecureZeroMemory(m_szTask,sizeof(m_szTask));
    SecureZeroMemory(m_szTaskUserName,sizeof(m_szTaskUserName));
    SecureZeroMemory(m_szScheduleTaskName,sizeof(m_szScheduleTaskName));

    m_pszEventQuery = new TCHAR[(m_lQueryColWidth)];
    CheckAndSetMemoryAllocation (m_pszEventQuery,(m_lQueryColWidth));


    m_arrColData = CreateDynamicArray();
    if( NULL == m_arrColData)
    {
        throw CShowError(E_OUTOFMEMORY);
    }

    SecureZeroMemory(cmdOptions, sizeof(TCMDPARSER2)* MAX_COMMANDLINE_Q_OPTION);

    // initialization is successful
    SetLastError( NOERROR );            // clear the error
    SetReason( L"" );            // clear the reason
    DEBUG_INFO;

}

void
CETQuery::CheckAndSetMemoryAllocation(
    IN OUT LPTSTR pszStr,
    IN     LONG lSize
    )
/*++
 Routine Description:
        Function will allocate memory to a string

 Arguments:
        [in][out] pszStr   : String variable to which memory to be  allocated
        [in]               : Number of bytes to be allocated.
 Return Value:
        NONE

--*/
{
    if( NULL == pszStr)
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    // init to ZERO's
    SecureZeroMemory( pszStr, lSize * sizeof( TCHAR ) );
    return;

}

BOOL
CETQuery::ExecuteQuery()
/*++
 Routine Description:
    This function will execute query. This will enumerate classes from WMI
  to get required data.

 Arguments:
      None
 Return Value:
        None

--*/
{
    // Local variables

    // Holds  values returned by COM functions
    HRESULT hr =  S_OK;

    // status of Return value of this function.
    BOOL bReturn = TRUE;

    // stores  FORMAT status values to show results
    DWORD dwFormatType;

    // COM related pointer variable. their usage is well understood by their
    //names.
    IEnumWbemClassObject *pEnumFilterToConsumerBinding = NULL;

    // variable used to get values from COM functions
    VARIANT vVariant;

    // Variables to store query results....
    TCHAR szHostName[MAX_STRING_LENGTH+1];
    TCHAR szEventTriggerName[MAX_TRIGGER_NAME];
    DWORD  dwEventId = 0;

    HRESULT hrTemp = S_OK;

    // store Row number.
    DWORD dwRowCount = 0;
    BOOL bAtLeastOneEvent = FALSE;

    BSTR bstrConsumer   = NULL;
    BSTR bstrFilter     = NULL;
    BSTR bstrCmdTrigger = NULL;
    BOOL bAlwaysTrue = TRUE;

    LONG lTemp = 0;

    try
    {
        DEBUG_INFO;
        InitializeCom(&m_pWbemLocator);
        m_bIsCOMInitialize = TRUE;
        {
            // Temp. variabe to store user name.
            CHString szTempUser = m_pszUserName;

            // Temp. variable to store password.
            CHString szTempPassword = m_pszPassword;
            m_bLocalSystem = TRUE;

            DEBUG_INFO;
           // Connect remote / local WMI.
            BOOL bResult = ConnectWmiEx( m_pWbemLocator,
                                    &m_pWbemServices,
                                    m_pszServerName,
                                    szTempUser,
                                    szTempPassword,
                                    &m_pAuthIdentity,
                                    m_bNeedPassword,
                                    WMI_NAMESPACE_CIMV2,
                                    &m_bLocalSystem);
            if( FALSE == bResult)
            {
                DEBUG_INFO;
				SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
                ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
                return FALSE;
            }
            DEBUG_INFO;
            // check the remote system version and its compatiblity
            if ( FALSE == m_bLocalSystem)
            {
                DWORD dwVersion = 0;
                DEBUG_INFO;
                dwVersion = GetTargetVersionEx( m_pWbemServices,
                                                m_pAuthIdentity );
                if ( dwVersion <= 5000 ) // to block win2k versions
                {
                    DEBUG_INFO;
					SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
                    SetReason( E_REMOTE_INCOMPATIBLE );
                    ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
                  return FALSE;
                }
                // For XP systems.
                if( 5001 == dwVersion )
                {
                    if( TRUE ==  DisplayXPResults() )
                    {
						SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
                        // Displayed triggers present.
                        return TRUE;
                    }
                    else
                    {
						SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
                        // Failed to display results .
                        // Error message is already displayed.
                        return FALSE;
                    }

                }

            }

            DEBUG_INFO;
            // check the local credentials and if need display warning
            if ( m_bLocalSystem && ( 0 != StringLength(m_pszUserName,0)))
            {
                DEBUG_INFO;
                WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
                ShowLastErrorEx(stderr,SLE_TYPE_WARNING|SLE_INTERNAL);
            }
         }

         // If query is for remote system, make a connection to it so
         // that ITaskScheduler will use this connection to get
         // application name.
        DEBUG_INFO;
        if( FALSE == m_bLocalSystem)
        {
            if( FALSE == EstablishConnection( m_pszServerName,
                                              m_pszUserName,
                                              GetBufferSize((LPVOID)m_pszUserName)/sizeof(WCHAR),
                                              m_pszPassword,
                                              GetBufferSize((LPVOID)m_pszPassword)/sizeof(WCHAR),
                                              FALSE ))
            {
				SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
                ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
                return FALSE;
           }
        }

        DEBUG_INFO;
        // Password is not needed , better to free it
        FreeMemory((LPVOID*)& m_pszPassword);
        if(FALSE == SetTaskScheduler())
        {
			SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
            return FALSE;
        }
        DEBUG_INFO;
        // if -id switch is specified
        if( (1 == cmdOptions[ ID_Q_TRIGGERID ].dwActuals) &&
            (StringLength( m_pszTriggerID,0) > 0 ))
        {

            IEnumWbemClassObject *pEnumCmdTriggerConsumer = NULL;
            TCHAR   szTemp[ MAX_STRING_LENGTH ];
            SecureZeroMemory(szTemp, MAX_STRING_LENGTH);
            StringCchPrintfW( szTemp,SIZE_OF_ARRAY(szTemp), QUERY_RANGE,
                        m_dwLowerBound, m_dwUpperBound );
            DEBUG_INFO;
            hr =  m_pWbemServices->
                      ExecQuery( _bstr_t(QUERY_LANGUAGE), _bstr_t(szTemp),
                        WBEM_FLAG_RETURN_IMMEDIATELY, NULL,
                        &pEnumCmdTriggerConsumer );

            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;
            hr = SetInterfaceSecurity( pEnumCmdTriggerConsumer,
                                   m_pAuthIdentity );
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

            // retrieves  CmdTriggerConsumer class
            bstrCmdTrigger = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
            DEBUG_INFO;
            hr = m_pWbemServices->GetObject(bstrCmdTrigger,
                                       0, NULL, &m_pClass, NULL);
            SAFE_RELEASE_BSTR(bstrCmdTrigger);
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

            // Gets  information about the "QueryETrigger( " method of
            // "cmdTriggerConsumer" class
            bstrCmdTrigger = SysAllocString(FN_QUERY_ETRIGGER);
            hr = m_pClass->GetMethod(bstrCmdTrigger,
                                    0, &m_pInClass, NULL);
            SAFE_RELEASE_BSTR(bstrCmdTrigger);
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

           // create a new instance of a class "TriggerEventConsumer ".
            hr = m_pInClass->SpawnInstance(0, &m_pInInst);
            ON_ERROR_THROW_EXCEPTION(hr);

            DEBUG_INFO;
            while(bAlwaysTrue)
            {
                hrTemp = S_OK;
                ULONG uReturned = 0;
                BSTR bstrTemp = NULL;
                CHString strTemp;

                hr = SetInterfaceSecurity( pEnumCmdTriggerConsumer,
                                       m_pAuthIdentity );

                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;

                // Get one  object starting at the current position in an
                //enumeration
                hr = pEnumCmdTriggerConsumer->Next(WBEM_INFINITE,
                                                    1,&m_pObj,&uReturned);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;
                if( 0 == uReturned)
                {
                    SAFE_RELEASE_INTERFACE(m_pObj);
                    break;
                }

                bstrTemp = SysAllocString(FPR_TRIGGER_ID);
                hr = m_pObj->Get(bstrTemp,
                                0, &vVariant, 0, 0);
                if(FAILED(hr))
                {
                    if( WBEM_E_NOT_FOUND == hr)
                    {
                        continue;
                    }
                    ON_ERROR_THROW_EXCEPTION(hr);
                }
                SAFE_RELEASE_BSTR(bstrTemp);
                DEBUG_INFO;
                dwEventId = vVariant.lVal ;
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // Retrieves the "TaskScheduler"  information
                bstrTemp = SysAllocString(FPR_TASK_SCHEDULER);
                hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;
                SAFE_RELEASE_BSTR(bstrTemp);
                hrTemp = GetRunAsUserName((LPCWSTR)_bstr_t(vVariant.bstrVal));
                if (FAILED(hrTemp) && (ERROR_TRIGGER_CORRUPTED != hrTemp))
                {
                    // This is because user does not has enough rights
                    // to see schtasks. Continue with next trigger.
                    SAFE_RELEASE_INTERFACE(m_pObj);
                    SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
                    SAFE_RELEASE_INTERFACE(m_pEventFilter);
                   continue;
                }
                StringCopy(m_szScheduleTaskName,(LPCWSTR)_bstr_t(vVariant.bstrVal),SIZE_OF_ARRAY(m_szScheduleTaskName));

                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // TriggerName
                //retrieves the  'TriggerName' value if exits
                bstrTemp = SysAllocString(FPR_TRIGGER_NAME);
                hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);
                SAFE_RELEASE_BSTR(bstrTemp);
                StringCopy(szEventTriggerName,vVariant.bstrVal,MAX_RES_STRING);
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                //retrieves the  'TriggerDesc' value if exits
                bstrTemp = SysAllocString(FPR_TRIGGER_DESC);
                hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                SAFE_RELEASE_BSTR(bstrTemp);

                StringCopy(m_szBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal),
                           SIZE_OF_ARRAY(m_szBuffer));
                lTemp = StringLength(m_szBuffer,0);
                DEBUG_INFO;

                StringCopy(m_szEventDesc,m_szBuffer,
                             SIZE_OF_ARRAY(m_szEventDesc));
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;

                // Host Name
                //retrieves the  '__SERVER' value if exits
                bstrTemp = SysAllocString(L"__SERVER");
                hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);
                SAFE_RELEASE_BSTR(bstrTemp);
                StringCopy(szHostName, vVariant.bstrVal,SIZE_OF_ARRAY(szHostName));
                DEBUG_INFO;



                DEBUG_INFO;
                if (ERROR_TRIGGER_CORRUPTED != hrTemp)
                {
                    //retrieves the 'Action' value if exits
                    hr = GetApplicationToRun();
                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;


                   /*

                    bstrTemp = SysAllocString(L"Action");
                    hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    SAFE_RELEASE_BSTR(bstrTemp);

                    StringCopy(m_szBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal),
                               SIZE_OF_ARRAY(m_szBuffer));

                    lTemp = StringLength(m_szBuffer,0);

                    StringCopy(m_szTask, m_szBuffer, SIZE_OF_ARRAY(m_szTask));
                    hr = VariantClear(&vVariant);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    */

                    StringCopy(szTemp,L"",SIZE_OF_ARRAY(szTemp));
                    StringCchPrintfW( szTemp, SIZE_OF_ARRAY(szTemp),
                                BINDING_CLASS_QUERY, dwEventId);

                    DEBUG_INFO;
                    hr =  m_pWbemServices->ExecQuery( _bstr_t(QUERY_LANGUAGE),
                                                     _bstr_t(szTemp),
                                                     WBEM_FLAG_RETURN_IMMEDIATELY,
                                                     NULL,
                                                     &pEnumFilterToConsumerBinding);

                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;

                    hr = SetInterfaceSecurity( pEnumFilterToConsumerBinding,
                                           m_pAuthIdentity );

                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;

                    // Get one  object starting at the current position in an
                    //enumeration
                    SAFE_RELEASE_INTERFACE(m_pClass);
                    hr = pEnumFilterToConsumerBinding->Next(WBEM_INFINITE,
                                                        1,&m_pClass,&uReturned);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;
                    if( 0 == uReturned )
                    {
                        SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
                        SAFE_RELEASE_INTERFACE(m_pObj);
                        SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
                        SAFE_RELEASE_INTERFACE(m_pEventFilter);
                       continue;
                    }

                    DEBUG_INFO;
                    bstrTemp = SysAllocString(L"Filter");
                    hr = m_pClass->Get(bstrTemp, 0, &vVariant, 0, 0);
                    SAFE_RELEASE_BSTR(bstrTemp);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    bstrFilter = SysAllocString(vVariant.bstrVal);
                    hr = VariantClear(&vVariant);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;
                    hr = m_pWbemServices->GetObject(    bstrFilter,
                                                        0,
                                                        NULL,
                                                        &m_pEventFilter,
                                                        NULL);
                    SAFE_RELEASE_BSTR(bstrFilter);
                    DEBUG_INFO;
                    if(FAILED(hr))
                    {
                        if( WBEM_E_NOT_FOUND == hr)
                            continue;
                        ON_ERROR_THROW_EXCEPTION(hr);
                    }

                    DEBUG_INFO;
                    hr = VariantClear(&vVariant);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    bstrTemp = SysAllocString(L"Query");
                    hr = m_pEventFilter->Get(bstrTemp, 0, &vVariant, 0, 0);
                    SAFE_RELEASE_BSTR(bstrTemp);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    StringCopy(m_szBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal),
                               SIZE_OF_ARRAY(m_szBuffer));
                    hr = VariantClear(&vVariant);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;

                    FindAndReplace(m_szBuffer,QUERY_STRING_AND,SHOW_WQL_QUERY);
                    FindAndReplace(m_szBuffer,L"targetinstance.LogFile",L"Log");
                    FindAndReplace(m_szBuffer,L"targetinstance.Type",L"Type");
                    FindAndReplace(m_szBuffer,L"targetinstance.EventCode",L"Id");
                    FindAndReplace(m_szBuffer,
                                   L"targetinstance.SourceName",L"Source");

                    DEBUG_INFO;
                    // Remove extra spaces
                    FindAndReplace( m_szBuffer,L"  ",L" ");

                    // Remove extra spaces
                    FindAndReplace(m_szBuffer,L"  ",L" ");

                    lTemp = StringLength(m_szBuffer,0);

                    // for the safer size for allocation of memory.
                    // allocates memory only if new WQL is greate than previous one.
                    lTemp += 4;

                   if(lTemp > m_lWQLColWidth)
                    {
                        DEBUG_INFO;
                        // first free it (if previously allocated)
                        RELEASE_MEMORY_EX(m_pszEventQuery);
                        m_pszEventQuery = new TCHAR[lTemp+1];
                        CheckAndSetMemoryAllocation(m_pszEventQuery,lTemp);
                    }
                    lTemp = m_lWQLColWidth;
                    CalcColWidth(lTemp,&m_lWQLColWidth,m_szBuffer);

                    // Now manipulate the WQL string to get EventQuery....
                    FindAndReplace(m_szBuffer,SHOW_WQL_QUERY,
                                    GetResString(IDS_EVENTS_WITH));

                    //to remove extra spaces
                    FindAndReplace(m_szBuffer,L"  ",L" ");

                    //to remove extra spaces
                    FindAndReplace( m_szBuffer,L"  ",L" ");
                    StringCopy( m_pszEventQuery,m_szBuffer,
                                  SIZE_OF_NEW_ARRAY(m_pszEventQuery));

                    DEBUG_INFO;

                }
                else
                {
                    StringCopy(m_szTask,TRIGGER_CORRUPTED,SIZE_OF_ARRAY(m_szTask));

                    // first free it (if previously allocated)
                    RELEASE_MEMORY_EX(m_pszEventQuery);
                    m_pszEventQuery = new TCHAR[MAX_STRING_LENGTH];
                    CheckAndSetMemoryAllocation(m_pszEventQuery,MAX_STRING_LENGTH);

                    StringCopy(m_pszEventQuery,GetResString(IDS_ID_NA),SIZE_OF_NEW_ARRAY(m_pszEventQuery));
                    StringCopy(m_szTaskUserName,GetResString(IDS_ID_NA),SIZE_OF_ARRAY(m_szTaskUserName));
                }

                // Now Shows the results on screen
                // Appends for in m_arrColData array
                dwRowCount = DynArrayAppendRow( m_arrColData, NO_OF_COLUMNS );

                // Fills Results in m_arrColData data structure
                DynArraySetString2( m_arrColData, dwRowCount, HOST_NAME,
                                  szHostName,0);
                DynArraySetDWORD2( m_arrColData , dwRowCount,
                                  TRIGGER_ID,dwEventId);
                DynArraySetString2( m_arrColData, dwRowCount, TRIGGER_NAME,
                                   szEventTriggerName,0);
                DynArraySetString2( m_arrColData, dwRowCount, TASK,
                                   m_szTask,0);
                DynArraySetString2( m_arrColData, dwRowCount, EVENT_QUERY,
                                   m_pszEventQuery,0);
                DynArraySetString2( m_arrColData, dwRowCount, EVENT_DESCRIPTION,
                                   m_szEventDesc,0);
                DynArraySetString2( m_arrColData, dwRowCount, TASK_USERNAME,
                                   m_szTaskUserName,0);


                bAtLeastOneEvent = TRUE;

                // Calculatate new column width for each column
                lTemp = m_lHostNameColWidth;
                CalcColWidth(lTemp,&m_lHostNameColWidth,szHostName);

                lTemp = m_lETNameColWidth;
                CalcColWidth(lTemp,&m_lETNameColWidth,szEventTriggerName);

                lTemp = m_lTaskColWidth;
                CalcColWidth(lTemp,&m_lTaskColWidth,m_szTask);

                lTemp = m_lQueryColWidth;
                CalcColWidth(lTemp,&m_lQueryColWidth,m_pszEventQuery);

                lTemp = m_lDescriptionColWidth;
                CalcColWidth(lTemp,&m_lDescriptionColWidth,m_szEventDesc);

                // Resets current containts..if any
                StringCopy(szHostName, L"",SIZE_OF_ARRAY(szHostName));
                dwEventId = 0;
                StringCopy(szEventTriggerName,L"",SIZE_OF_ARRAY(szEventTriggerName));
                StringCopy( m_szTask, L"",
                            SIZE_OF_ARRAY(m_szTask));
                StringCopy(m_pszEventQuery,L"",SIZE_OF_NEW_ARRAY(m_pszEventQuery));
                StringCopy(m_szEventDesc,L"",SIZE_OF_ARRAY(m_szEventDesc));
                SAFE_RELEASE_INTERFACE(m_pObj);
                SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
                SAFE_RELEASE_INTERFACE(m_pEventFilter);



                DEBUG_INFO;
            }
        }
        else
        {

            //Following method will creates an enumerator that returns the
            // instances of a specified __FilterToConsumerBinding class
            bstrConsumer = SysAllocString(CLS_FILTER_TO_CONSUMERBINDING);
            DEBUG_INFO;
            hr = m_pWbemServices->
                    CreateInstanceEnum(bstrConsumer,
                                       WBEM_FLAG_SHALLOW,
                                       NULL,
                                       &pEnumFilterToConsumerBinding);
            SAFE_RELEASE_BSTR(bstrConsumer);
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

            hr = SetInterfaceSecurity( pEnumFilterToConsumerBinding,
                                   m_pAuthIdentity );
            ON_ERROR_THROW_EXCEPTION(hr);


            // retrieves  CmdTriggerConsumer class
            bstrCmdTrigger = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
            hr = m_pWbemServices->GetObject(bstrCmdTrigger,
                                       0, NULL, &m_pClass, NULL);
            SAFE_RELEASE_BSTR(bstrCmdTrigger);
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

            // Gets  information about the "QueryETrigger( " method of
            // "cmdTriggerConsumer" class
            bstrCmdTrigger = SysAllocString(FN_QUERY_ETRIGGER);
            hr = m_pClass->GetMethod(bstrCmdTrigger,
                                    0, &m_pInClass, NULL);
            SAFE_RELEASE_BSTR(bstrCmdTrigger);
            ON_ERROR_THROW_EXCEPTION(hr);
            DEBUG_INFO;

            // create a new instance of a class "TriggerEventConsumer ".
            hr = m_pInClass->SpawnInstance(0, &m_pInInst);
            ON_ERROR_THROW_EXCEPTION(hr);

            while(bAlwaysTrue)
            {
                // Holds no. of object returns from Next mathod.
                ULONG uReturned = 0;

                BSTR bstrTemp = NULL;
                CHString strTemp;

                // set the security at the interface level also
                hr = SetInterfaceSecurity( pEnumFilterToConsumerBinding,
                                       m_pAuthIdentity );

                ON_ERROR_THROW_EXCEPTION(hr);

                // Get one  object starting at the current position in an
                //enumeration
                hr = pEnumFilterToConsumerBinding->Next(WBEM_INFINITE,
                                                    1,&m_pObj,&uReturned);
                ON_ERROR_THROW_EXCEPTION(hr);
                if( 0 == uReturned )
                {
                    SAFE_RELEASE_INTERFACE(m_pObj);
                    break;
                }
                DEBUG_INFO;
                VariantInit(&vVariant);
                SAFE_RELEASE_BSTR(bstrTemp);
                bstrTemp = SysAllocString(L"Consumer");
                hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
                SAFE_RELEASE_BSTR(bstrTemp);
                ON_ERROR_THROW_EXCEPTION(hr);

                bstrConsumer =SysAllocString( vVariant.bstrVal);
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // Search for trggereventconsumer string as we are interested
                // to get object from this class only
                strTemp = bstrConsumer;
                if( -1 == strTemp.Find(CLS_TRIGGER_EVENT_CONSUMER))
                {
                    SAFE_RELEASE_BSTR(bstrConsumer);
                    continue;
                }
                hr = SetInterfaceSecurity( m_pWbemServices,
                                           m_pAuthIdentity );

                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;
                hr = m_pWbemServices->GetObject(bstrConsumer,
                                                0,
                                                NULL,
                                                &m_pTriggerEventConsumer,
                                                NULL);
                SAFE_RELEASE_BSTR(bstrConsumer);
                if(FAILED(hr))
                {
                    if( WBEM_E_NOT_FOUND == hr)
                    {
                        continue;
                    }
                    ON_ERROR_THROW_EXCEPTION(hr);
                }
                DEBUG_INFO;
                bstrTemp = SysAllocString(L"Filter");
                hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
                SAFE_RELEASE_BSTR(bstrTemp);
                ON_ERROR_THROW_EXCEPTION(hr);
                bstrFilter = SysAllocString(vVariant.bstrVal);
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);
                hr = m_pWbemServices->GetObject(
                                                bstrFilter,
                                                0,
                                                NULL,
                                                &m_pEventFilter,
                                                NULL);
                SAFE_RELEASE_BSTR(bstrFilter);
                if(FAILED(hr))
                {
                    if( WBEM_E_NOT_FOUND == hr)
                    {
                        continue;
                    }
                    ON_ERROR_THROW_EXCEPTION(hr);
                }
                DEBUG_INFO;
                //retrieves the 'TriggerID' value if exits
                bstrTemp = SysAllocString(FPR_TRIGGER_ID);
                hr = m_pTriggerEventConsumer->Get(bstrTemp,
                                0, &vVariant, 0, 0);
                if(FAILED(hr))
                {
                    if( WBEM_E_NOT_FOUND == hr)
                    {
                        continue;
                    }
                    ON_ERROR_THROW_EXCEPTION(hr);
                }
                SAFE_RELEASE_BSTR(bstrTemp);
                DEBUG_INFO;
                dwEventId = vVariant.lVal ;
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // Retrieves the "TaskScheduler"  information
                bstrTemp = SysAllocString(FPR_TASK_SCHEDULER);
                DEBUG_INFO;
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;
                SAFE_RELEASE_BSTR(bstrTemp);
                DEBUG_INFO;
                hrTemp = GetRunAsUserName((LPCWSTR)_bstr_t(vVariant.bstrVal));
                DEBUG_INFO;
                if (FAILED(hrTemp) && (ERROR_TRIGGER_CORRUPTED != hrTemp))
                {
                    // This is because user does not has enough rights
                    // to see schtasks. Continue with next trigger.
                    DEBUG_INFO;
                    SAFE_RELEASE_INTERFACE(m_pObj);
                    SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
                    SAFE_RELEASE_INTERFACE(m_pEventFilter);
                   continue;
                }
                StringCopy(m_szScheduleTaskName,(LPCWSTR)_bstr_t(vVariant.bstrVal),SIZE_OF_ARRAY(m_szScheduleTaskName));

                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // TriggerName
                //retrieves the  'TriggerName' value if exits
                bstrTemp = SysAllocString(FPR_TRIGGER_NAME);
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0,0);
                ON_ERROR_THROW_EXCEPTION(hr);
                SAFE_RELEASE_BSTR(bstrTemp);
                StringCopy(szEventTriggerName,vVariant.bstrVal,MAX_RES_STRING);
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;

                //retrieves the  'TriggerDesc' value if exits
                bstrTemp = SysAllocString(FPR_TRIGGER_DESC);
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                SAFE_RELEASE_BSTR(bstrTemp);

                StringCopy(m_szBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal),
                           SIZE_OF_ARRAY(m_szBuffer));
                lTemp = StringLength(m_szBuffer,0);

                // Means description is not available make it N/A.
                if( 0 == lTemp)
                {
                    StringCopy(m_szBuffer,GetResString(IDS_ID_NA),SIZE_OF_ARRAY(m_szBuffer));
                    lTemp = StringLength(m_szBuffer,0);
                }

                StringCopy(m_szEventDesc,m_szBuffer,SIZE_OF_ARRAY(m_szEventDesc));
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);


                // Host Name
                //retrieves the  '__SERVER' value if exits
                bstrTemp = SysAllocString(L"__SERVER");
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0,0);
                ON_ERROR_THROW_EXCEPTION(hr);
                SAFE_RELEASE_BSTR(bstrTemp);
                StringCopy(szHostName, vVariant.bstrVal,SIZE_OF_ARRAY(szHostName));


                if ( ERROR_TRIGGER_CORRUPTED != hrTemp)
                {
                    hr = GetApplicationToRun();
                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;

                    /*
                    //retrieves the 'Action' value if exits
                    bstrTemp = SysAllocString(L"Action");
                    hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    SAFE_RELEASE_BSTR(bstrTemp);

                    StringCopy(m_szBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal),
                               SIZE_OF_ARRAY(m_szBuffer));

                    StringCopy(m_szTask, m_szBuffer,SIZE_OF_ARRAY(m_szTask));
                    hr = VariantClear(&vVariant);
                    ON_ERROR_THROW_EXCEPTION(hr);

                    hr = VariantClear(&vVariant);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    */

                    bstrTemp = SysAllocString(L"Query");
                    hr = m_pEventFilter->Get(bstrTemp, 0, &vVariant, 0, 0);
                    SAFE_RELEASE_BSTR(bstrTemp);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;
                    StringCopy(m_szBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal),
                               SIZE_OF_ARRAY(m_szBuffer));
                    hr = VariantClear(&vVariant);
                    ON_ERROR_THROW_EXCEPTION(hr);
                    DEBUG_INFO;

                    FindAndReplace(m_szBuffer,QUERY_STRING_AND,SHOW_WQL_QUERY);
                    FindAndReplace(m_szBuffer,L"targetinstance.LogFile",L"Log");
                    FindAndReplace(m_szBuffer,L"targetinstance.Type",L"Type");
                    FindAndReplace(m_szBuffer,L"targetinstance.EventCode",L"Id");
                    FindAndReplace(m_szBuffer,
                                   L"targetinstance.SourceName",L"Source");

                    //to remove extra spaces
                    FindAndReplace(m_szBuffer,L"  ",L" ");

                    //to remove extra spaces
                    FindAndReplace( m_szBuffer,L"  ",L" ");

                    lTemp = StringLength(m_szBuffer,0);

                    // for the safer size for allocation of memory.
                    // allocates memory only if new WQL is greate than previous one.
                    lTemp += 4;
                    if(lTemp > m_lWQLColWidth)
                    {
                        DEBUG_INFO;
                        // first free it (if previously allocated)
                        RELEASE_MEMORY_EX(m_pszEventQuery);
                        m_pszEventQuery = new TCHAR[lTemp+1];
                        CheckAndSetMemoryAllocation(m_pszEventQuery,lTemp);
                    }
                    lTemp = m_lWQLColWidth;
                    CalcColWidth(lTemp,&m_lWQLColWidth,m_szBuffer);

                    // Now manipulate the WQL string to get EventQuery....
                    FindAndReplace(m_szBuffer,SHOW_WQL_QUERY,
                                    GetResString(IDS_EVENTS_WITH));

                    // Remove extra spaces.
                    FindAndReplace(m_szBuffer,L"  ",L" ");

                    // Remove extra spaces.
                    FindAndReplace(m_szBuffer,L"  ",L" ");
                    StringCopy(m_pszEventQuery,m_szBuffer,
                               SIZE_OF_NEW_ARRAY(m_pszEventQuery));

                    DEBUG_INFO;
                }
                else
                {
                    StringCopy(m_szTask,TRIGGER_CORRUPTED,SIZE_OF_ARRAY(m_szTask));

                    // first free it (if previously allocated)
                    RELEASE_MEMORY_EX(m_pszEventQuery);
                    m_pszEventQuery = new TCHAR[MAX_STRING_LENGTH];
                    CheckAndSetMemoryAllocation(m_pszEventQuery,MAX_STRING_LENGTH);

                    StringCopy(m_pszEventQuery,GetResString(IDS_ID_NA),SIZE_OF_NEW_ARRAY(m_pszEventQuery));
                    StringCopy(m_szTaskUserName,GetResString(IDS_ID_NA),SIZE_OF_ARRAY(m_szTaskUserName));
                }

                // Now Shows the results on screen
                // Appends for in m_arrColData array
                dwRowCount = DynArrayAppendRow( m_arrColData, NO_OF_COLUMNS );
                DEBUG_INFO;

                // if hrTemp == ERROR_TRIGGER_CORRUPTED,
                // fill all the columns with "Trigger Corrupted except
                // Trigger id and Trigger Name

                // Fills Results in m_arrColData data structure
                DynArraySetString2(m_arrColData,dwRowCount,
                                  HOST_NAME,szHostName,0);
                DynArraySetDWORD2( m_arrColData , dwRowCount, TRIGGER_ID,
                                  dwEventId);
                DynArraySetString2( m_arrColData, dwRowCount, TRIGGER_NAME,
                                   szEventTriggerName,0);
                DynArraySetString2( m_arrColData, dwRowCount, TASK,
                                   m_szTask,0);
                DynArraySetString2( m_arrColData, dwRowCount, EVENT_QUERY,
                                   m_pszEventQuery,0);
                DynArraySetString2( m_arrColData, dwRowCount, EVENT_DESCRIPTION,
                                   m_szEventDesc,0);
                DynArraySetString2( m_arrColData, dwRowCount, TASK_USERNAME,
                                   m_szTaskUserName,0);

                bAtLeastOneEvent = TRUE;

                // Calculatate new column width for each column
                lTemp = m_lHostNameColWidth;
                CalcColWidth(lTemp,&m_lHostNameColWidth,szHostName);

                lTemp = m_lETNameColWidth;
                CalcColWidth(lTemp,&m_lETNameColWidth,szEventTriggerName);

                lTemp = m_lTaskColWidth;
                CalcColWidth(lTemp,&m_lTaskColWidth,m_szTask);

                lTemp = m_lQueryColWidth;
                CalcColWidth(lTemp,&m_lQueryColWidth,m_pszEventQuery);

                lTemp = m_lDescriptionColWidth;
                CalcColWidth(lTemp,&m_lDescriptionColWidth,m_szEventDesc);

                // Resets current containts..if any
                StringCopy(szHostName, L"",SIZE_OF_ARRAY(szHostName));
                dwEventId = 0;
                StringCopy(szEventTriggerName, L"",SIZE_OF_ARRAY(szEventTriggerName));
                StringCopy(m_szTask, L"",SIZE_OF_ARRAY(m_szTask));
                StringCopy(m_pszEventQuery, L"",SIZE_OF_NEW_ARRAY(m_pszEventQuery));
                StringCopy(m_szEventDesc,L"",SIZE_OF_ARRAY(m_szEventDesc));
                SAFE_RELEASE_INTERFACE(m_pObj);
                SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
                SAFE_RELEASE_INTERFACE(m_pEventFilter);
                DEBUG_INFO;
            } // End of while
        }
        if(0 == StringCompare( m_pszFormat,GetResString(IDS_STRING_TABLE),
                              TRUE,0))
        {
            dwFormatType = SR_FORMAT_TABLE;
        }
        else if(0 == StringCompare( m_pszFormat,
                                    GetResString(IDS_STRING_LIST),TRUE,0))
        {
            dwFormatType = SR_FORMAT_LIST;
        }
        else if(0 == StringCompare( m_pszFormat,
                                    GetResString(IDS_STRING_CSV),TRUE,0))
        {
            dwFormatType = SR_FORMAT_CSV;
        }
        else // Default
        {
           dwFormatType = SR_FORMAT_TABLE;
        }
        if( TRUE == bAtLeastOneEvent)
        {
            // Show Final Query Results on screen
            PrepareColumns ();
            DEBUG_INFO;
            if ( FALSE ==  IsSchSvrcRunning())
            {
                DEBUG_INFO;
                ShowMessage(stderr,GetResString(IDS_SERVICE_NOT_RUNNING));
            }
            if((SR_FORMAT_CSV & dwFormatType) != SR_FORMAT_CSV)
            {
                ShowMessage(stdout,BLANK_LINE);
            }
            if( TRUE == m_bNoHeader)
            {
                dwFormatType |=SR_NOHEADER;
            }

            ShowResults(NO_OF_COLUMNS,mainCols,dwFormatType,m_arrColData);
        }
        else if( StringLength(m_pszTriggerID,0)> 0)
        {
            // Show Message
            TCHAR szErrorMsg[MAX_RES_STRING+1];
            TCHAR szMsgFormat[MAX_RES_STRING+1];
            StringCopy(szMsgFormat,GetResString(IDS_NO_EVENTID_FOUND),
                       SIZE_OF_ARRAY(szMsgFormat));
            StringCchPrintfW(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg),
                             szMsgFormat,m_pszTriggerID);
            ShowMessage(stdout,szErrorMsg);
        }
        else
        {
            // Show Message
            ShowMessage(stdout,GetResString(IDS_NO_EVENT_FOUNT));
        }
    }
    catch(_com_error)
    {
        DEBUG_INFO;
		SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
        // WMI returns string for this hr value is "Not Found." which is not
        // user friendly. So changing the message text.
        if( 0x80041002 == hr )
        {
            ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
        }
        else
        {
            DEBUG_INFO;
            ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        }
        return FALSE;
    }
    DEBUG_INFO;
	SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
    return TRUE;
}

void
CETQuery::PrepareColumns()
/*++
 Routine Description:
    This function will prepare/fill structure which will be used to show
  output data.

 Arguments:
      None
 Return Value:
        None

--*/
{

    DEBUG_INFO;
    // For non verbose mode output, column width is predefined else
    // use dynamically calculated column width.
    m_lETNameColWidth = m_bVerbose?m_lETNameColWidth:V_WIDTH_TRIG_NAME;
    m_lTaskColWidth   = m_bVerbose?m_lTaskColWidth:V_WIDTH_TASK;
    m_lTriggerIDColWidth = m_bVerbose?m_lTriggerIDColWidth:V_WIDTH_TRIG_ID;


    StringCopy(mainCols[HOST_NAME].szColumn,COL_HOSTNAME,SIZE_OF_ARRAY(mainCols[HOST_NAME].szColumn));
    mainCols[HOST_NAME].dwWidth = m_lHostNameColWidth;
    if( TRUE == m_bVerbose)
    {
        mainCols[HOST_NAME].dwFlags = SR_TYPE_STRING;
    }
    else
    {
        mainCols[HOST_NAME].dwFlags = SR_HIDECOLUMN|SR_TYPE_STRING;
    }

    StringCopy(mainCols[HOST_NAME].szFormat,L"%s",SIZE_OF_ARRAY(mainCols[HOST_NAME].szFormat));
    mainCols[HOST_NAME].pFunction = NULL;
    mainCols[HOST_NAME].pFunctionData = NULL;

    StringCopy(mainCols[TRIGGER_ID].szColumn,COL_TRIGGER_ID,SIZE_OF_ARRAY(mainCols[TRIGGER_ID].szColumn));
    mainCols[TRIGGER_ID].dwWidth = m_lTriggerIDColWidth;
    mainCols[TRIGGER_ID].dwFlags = SR_TYPE_NUMERIC;
    StringCopy(mainCols[TRIGGER_ID].szFormat,L"%d",SIZE_OF_ARRAY(mainCols[TRIGGER_ID].szFormat));
    mainCols[TRIGGER_ID].pFunction = NULL;
    mainCols[TRIGGER_ID].pFunctionData = NULL;

    StringCopy(mainCols[TRIGGER_NAME].szColumn,COL_TRIGGER_NAME,
               SIZE_OF_ARRAY(mainCols[TRIGGER_NAME].szColumn));
    mainCols[TRIGGER_NAME].dwWidth = m_lETNameColWidth;
    mainCols[TRIGGER_NAME].dwFlags = SR_TYPE_STRING;
    StringCopy(mainCols[TRIGGER_NAME].szFormat,L"%s",
              SIZE_OF_ARRAY(mainCols[TRIGGER_NAME].szFormat));
    mainCols[TRIGGER_NAME].pFunction = NULL;
    mainCols[TRIGGER_NAME].pFunctionData = NULL;

    StringCopy(mainCols[TASK].szColumn,COL_TASK,
               SIZE_OF_ARRAY(mainCols[TASK].szColumn));
    mainCols[TASK].dwWidth = m_lTaskColWidth;

    mainCols[TASK].dwFlags = SR_TYPE_STRING;
    StringCopy(mainCols[TASK].szFormat,L"%s",
              SIZE_OF_ARRAY(mainCols[TASK].szFormat));
    mainCols[TASK].pFunction = NULL;
    mainCols[TASK].pFunctionData = NULL;

    StringCopy(mainCols[EVENT_QUERY].szColumn,COL_EVENT_QUERY,
               SIZE_OF_ARRAY(mainCols[EVENT_QUERY].szColumn));
    mainCols[EVENT_QUERY].dwWidth = m_lQueryColWidth;
    if(TRUE == m_bVerbose)
    {
        mainCols[EVENT_QUERY].dwFlags = SR_TYPE_STRING;
    }
    else
    {
        mainCols[EVENT_QUERY].dwFlags = SR_HIDECOLUMN|SR_TYPE_STRING;
    }

    StringCopy(mainCols[EVENT_QUERY].szFormat,L"%s",
               SIZE_OF_ARRAY(mainCols[EVENT_QUERY].szFormat));
    mainCols[EVENT_QUERY].pFunction = NULL;
    mainCols[EVENT_QUERY].pFunctionData = NULL;

    StringCopy(mainCols[EVENT_DESCRIPTION].szColumn,COL_DESCRIPTION,
               SIZE_OF_ARRAY(mainCols[EVENT_DESCRIPTION].szColumn));
    mainCols[EVENT_DESCRIPTION].dwWidth = m_lDescriptionColWidth;
    if( TRUE == m_bVerbose )
    {
        mainCols[EVENT_DESCRIPTION].dwFlags = SR_TYPE_STRING;
    }
    else
    {
        mainCols[EVENT_DESCRIPTION].dwFlags = SR_HIDECOLUMN|SR_TYPE_STRING;
    }

    // Task Username
    StringCopy(mainCols[TASK_USERNAME].szFormat,L"%s",
               SIZE_OF_ARRAY(mainCols[TASK_USERNAME].szFormat));
    mainCols[TASK_USERNAME].pFunction = NULL;
    mainCols[TASK_USERNAME].pFunctionData = NULL;

    StringCopy(mainCols[TASK_USERNAME].szColumn,COL_TASK_USERNAME,
               SIZE_OF_ARRAY(mainCols[TASK_USERNAME].szColumn));
    mainCols[TASK_USERNAME].dwWidth = m_lTaskUserName;
    if( TRUE == m_bVerbose)
    {
        mainCols[TASK_USERNAME].dwFlags = SR_TYPE_STRING;
    }
    else
    {
        mainCols[TASK_USERNAME].dwFlags = SR_HIDECOLUMN|SR_TYPE_STRING;
    }

    StringCopy(mainCols[TASK_USERNAME].szFormat,L"%s",
               SIZE_OF_ARRAY(mainCols[TASK_USERNAME].szFormat));
    mainCols[TASK_USERNAME].pFunction = NULL;
    mainCols[TASK_USERNAME].pFunctionData = NULL;
    DEBUG_INFO;
}

LONG
CETQuery::FindAndReplace(
    IN OUT LPTSTR  lpszSource,
    IN     LPCTSTR lpszFind,
    IN     LPCTSTR lpszReplace
    )
/*++
Routine Description:

    This function Will Find a string (lpszFind) in source string (lpszSource)
    and replace it with replace string (lpszReplace) for all occurences.

    It assumes the input 'lpszSource' is big enough to accomodate replace
    value.

Arguments:

    [in/out] lpszSource : String on which Find-Replace operation to be
                          performed
    [in] lpszFind       : String to be find
    [in] lpszReplace    : String to be replaced.
Return Value:
     0 - if Unsucessful
     else returns length of lpszSource.

--*/
{
     DEBUG_INFO;
    LONG lSourceLen = StringLength(lpszFind,0);
    LONG lReplacementLen = StringLength(lpszReplace,0);
    LONG lMainLength = StringLength(lpszSource,0);
    LPTSTR pszMainSafe= new TCHAR[StringLength(lpszSource,0)+1];

    LONG nCount = 0;
    LPTSTR lpszStart = NULL;
    lpszStart = lpszSource;
    LPTSTR lpszEnd = NULL;
    lpszEnd = lpszStart + lMainLength;
    LPTSTR lpszTarget=NULL;
    if ((0 == lSourceLen)||( NULL == pszMainSafe))
    {
        RELEASE_MEMORY_EX(pszMainSafe);
        return 0;
    }
    while (lpszStart < lpszEnd)
    {
        while ( NULL != (lpszTarget = (LPWSTR)FindString(lpszStart, lpszFind,0)))
        {
            nCount++;
            lpszStart = lpszTarget + lSourceLen;
        }
        lpszStart += StringLength(lpszStart,0) + 1;
    }

    // if any changes were made, make them
    if (nCount > 0)
    {
        StringCopy(pszMainSafe,lpszSource,SIZE_OF_NEW_ARRAY(pszMainSafe));
        LONG lOldLength = lMainLength;

        // else, we just do it in-place
        lpszStart= lpszSource;
        lpszEnd = lpszStart +StringLength(lpszSource,0);

        // loop again to actually do the work
        while (lpszStart < lpszEnd)
        {
            while ( NULL != (lpszTarget = (LPWSTR)FindString(lpszStart, lpszFind,0)))
            {
                #ifdef _WIN64
                    __int64 lBalance ;
                #else
                    LONG lBalance;
                #endif
                lBalance = lOldLength - (lpszTarget - lpszStart + lSourceLen);
                memmove(lpszTarget + lReplacementLen, lpszTarget + lSourceLen,
                (size_t)    lBalance * sizeof(TCHAR));
                memcpy(lpszTarget, lpszReplace, lReplacementLen*sizeof(TCHAR));
                lpszStart = lpszTarget + lReplacementLen;
                lpszStart[lBalance] = L'\0';
                lOldLength += (lReplacementLen - lSourceLen);

            }
            lpszStart += StringLength(lpszStart,0) + 1;
        }
    }
    RELEASE_MEMORY_EX(pszMainSafe);
    DEBUG_INFO;
    return StringLength(lpszSource,0);
}

void
CETQuery::CalcColWidth(
    IN  LONG lOldLength,
    OUT LONG *plNewLength,
    IN  LPTSTR pszString)
/*++
Routine Description:
    Calculates the width required for column
Arguments:

    [in]  lOldLength   : Previous length
    [out] plNewLength  : New Length
    [in]  pszString    : String .

Return Value:
     none

--*/
{
    LONG lStrLength = StringLength(pszString,0)+2;

    //Any way column width should not be greater than MAX_COL_LENGTH
    // Stores the maximum of WQL length.
    if(lStrLength > lOldLength)
    {
        *plNewLength = lStrLength;
    }
    else
    {
        *plNewLength = lOldLength;
    }

}

HRESULT
CETQuery::GetRunAsUserName(
    IN LPCWSTR pszScheduleTaskName,
    IN BOOL bXPorNET
    )
/*++
Routine Description:
   Get User Name from Task Scheduler
Arguments:
    [in]  pszScheduleTaskName   : Task Name
    [in]  bXPorNET              : TRUE if remote machine is XP else .NET.

Return Value:
     HRESULT
--*/
{

    // if pszSheduleTaskName is null or 0 length just return N/A.
    HRESULT hr = S_OK;
    BSTR bstrTemp = NULL;
    VARIANT vVariant;

    DEBUG_INFO;
    if(0 == StringLength(pszScheduleTaskName,0))
    {
        StringCopy(m_szTaskUserName,DEFAULT_USER,SIZE_OF_ARRAY(m_szTaskUserName));
        return S_OK;
    }
    StringCopy(m_szTaskUserName,GetResString(IDS_ID_NA),SIZE_OF_ARRAY(m_szTaskUserName));

    // Put input parameter for QueryETrigger method
    hr = PropertyPut(m_pInInst,FPR_TASK_SCHEDULER,_bstr_t(pszScheduleTaskName));
    ON_ERROR_THROW_EXCEPTION(hr);

    // All The required properties sets, so
    // executes DeleteETrigger method to delete eventtrigger
    DEBUG_INFO;
    if( TRUE == bXPorNET )
    {
        hr = m_pWbemServices->ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                                     _bstr_t(FN_QUERY_ETRIGGER_XP),
                                     0, NULL, m_pInInst,&m_pOutInst,NULL);
    }
    else
    {
        hr = m_pWbemServices->ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                                     _bstr_t(FN_QUERY_ETRIGGER),
                                     0, NULL, m_pInInst,&m_pOutInst,NULL);
    }
    ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;

    VARIANT vtValue;
    // initialize the variant and then get the value of the specified property
    VariantInit( &vtValue );

    hr = m_pOutInst->Get( _bstr_t( FPR_RETURN_VALUE ), 0, &vtValue, NULL, NULL );
    ON_ERROR_THROW_EXCEPTION( hr );

    //Get Output paramters.
    hr = vtValue.lVal;

    // Clear the variant variable
    VariantClear( &vtValue );

    if (FAILED(hr))
    {
        if (!((ERROR_INVALID_USER == hr) || (ERROR_RUN_AS_USER == hr) ||
            (SCHEDULER_NOT_RUNNING_ERROR_CODE == hr) ||
            (RPC_SERVER_NOT_AVAILABLE == hr) ||
            (ERROR_TRIGGER_NOT_FOUND == hr) ||
            (ERROR_TRIGGER_CORRUPTED) == hr))
        {
            ON_ERROR_THROW_EXCEPTION(hr);
        }

        if( ERROR_INVALID_USER == hr || ERROR_TRIGGER_NOT_FOUND == hr)
        {
            // means user doesnot has enough rights to
            // see schtask associated to it.
            DEBUG_INFO;
            return E_FAIL;
        }
        else if((ERROR_RUN_AS_USER == hr) || (SCHEDULER_NOT_RUNNING_ERROR_CODE == hr) ||
           (RPC_SERVER_NOT_AVAILABLE == hr))
        {
            // This means task scheduler not running, or run as user was set with
            // non existing user so while retriving it will throw error.

            DEBUG_INFO;
            StringCopy(m_szTaskUserName,GetResString(IDS_RUNAS_USER_UNKNOWN),
                       SIZE_OF_ARRAY(m_szTaskUserName));
            return S_OK;

        }
        else if (ERROR_TRIGGER_CORRUPTED == hr)
        {
            return hr;
        }
    }

    bstrTemp = SysAllocString(FPR_RUN_AS_USER);
    VariantInit(&vVariant);
    hr = m_pOutInst->Get(bstrTemp, 0, &vVariant, 0, 0);
    SAFE_RELEASE_BSTR(bstrTemp);
    ON_ERROR_THROW_EXCEPTION(hr);

    StringCopy(m_szTaskUserName,vVariant.bstrVal,SIZE_OF_ARRAY(m_szTaskUserName));
    hr = VariantClear(&vVariant);
    ON_ERROR_THROW_EXCEPTION(hr);
    if( 0 == StringLength(m_szTaskUserName,0))
    {
         StringCopy(m_szTaskUserName,GetResString(IDS_ID_NA),SIZE_OF_ARRAY(m_szTaskUserName));
    }
    DEBUG_INFO;
    return S_OK;
}

BOOL
CETQuery::GetNValidateTriggerId(
    IN OUT DWORD *dwLower,
    IN OUT DWORD *dwUpper
    )
/*++
Routine Description:
   Get and validate TriggerId
Arguments:

    [in/out]  dwLower   : Trigger id Lower bound.
    [in/out]  dwUpper   : Trigger id Upper bound.

Return Value:
     BOOL

--*/
{
    // temp variables
    CHString szTempId  = m_pszTriggerID;
    CHString szLowerBound = L"";
    CHString szUpperBound = L"";
    LPTSTR pszStopString = NULL;
    BOOL bReturn = TRUE;

    DEBUG_INFO;

    // Find whether it is a range
    DWORD dwIndex = szTempId.Find( '-' );

    // check if it is a range
    if( -1 == dwIndex)
    {
        // Check for numeric
        bReturn = IsNumeric( szTempId, 10, FALSE );
        if( FALSE == bReturn)
        {
            SetReason( GetResString(IDS_INVALID_ID) );
            return FALSE;
        }

        // set the upper bound and lower bound to given value
        *dwLower = wcstol( szTempId, &pszStopString, 10 );
        *dwUpper = wcstol( szTempId, &pszStopString, 10 );
    }
    // if it is a range
    else
    {
        // get and set the upper bound and lower bound
        DWORD dwLength = szTempId.GetLength();
        szLowerBound = szTempId.Left( dwIndex );
        szLowerBound.TrimLeft();
        szLowerBound.TrimRight();
        if( ( szLowerBound.GetLength() < 0 ) ||
            ( FALSE == IsNumeric( szLowerBound, 10, FALSE )))
        {
            SetReason( GetResString(IDS_INVALID_RANGE) );
            return FALSE;
        }

        szUpperBound = szTempId.Right( dwLength - ( dwIndex + 1) );
        szUpperBound.TrimLeft();
        szUpperBound.TrimRight();
        if( ( szUpperBound.GetLength() < 0 ) ||
            ( FALSE == IsNumeric( szUpperBound, 10, FALSE )))
        {
            SetReason( GetResString(IDS_INVALID_RANGE) );
            return FALSE;
        }
        *dwLower = wcstol( szLowerBound, &pszStopString, 10 );
        *dwUpper = wcstol( szUpperBound, &pszStopString, 10 );
        if ( *dwLower >= *dwUpper )
        {
            return FALSE;
        }
    }
    DEBUG_INFO;
    return TRUE;
}

BOOL
CETQuery::IsSchSvrcRunning()
/*++
Routine Description:
   This function returns whether schedule task services are
   started or not.
Arguments:

    [in/out]  dwLower   : Trigger id Lower bound.
    [in/out]  dwUpper   : Trigger id Upper bound.

Return Value:
     BOOL: TRUE - Service is started.
           FALSE- otherwise

--*/
{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pEnum = NULL;
    ULONG uReturned = 0;
    VARIANT vVariant;
    DEBUG_INFO;
    BOOL bRetValue = FALSE;
    hr = m_pWbemServices->ExecQuery(_bstr_t(QUERY_LANGUAGE),
                                    _bstr_t(QUERY_SCHEDULER_STATUS),
                                    WBEM_FLAG_RETURN_IMMEDIATELY, NULL,
                                    &pEnum);
	ON_ERROR_THROW_EXCEPTION(hr);
    DEBUG_INFO;
    hr = SetInterfaceSecurity( pEnum, m_pAuthIdentity );
    if(FAILED(hr))
    {
      WMISaveError(hr);
      SAFE_RELEASE_INTERFACE(pEnum);
      _com_issue_error(hr);
    }

    DEBUG_INFO;
    pEnum->Next(WBEM_INFINITE,1,&m_pObj,&uReturned);

    if(FAILED(hr))
    {
      WMISaveError(hr);
      SAFE_RELEASE_INTERFACE(pEnum);
      _com_issue_error(hr);
    }

    DEBUG_INFO;
    if( 0 == uReturned)
    {
        DEBUG_INFO;
        SAFE_RELEASE_INTERFACE(m_pObj);
        SAFE_RELEASE_INTERFACE(pEnum);
        return FALSE;
    }
    DEBUG_INFO;
    VariantInit(&vVariant);
    hr = m_pObj->Get(_bstr_t(STATUS_PROPERTY),0, &vVariant, 0, 0);
    SAFE_RELEASE_INTERFACE(m_pObj);
    SAFE_RELEASE_INTERFACE(pEnum);
    ON_ERROR_THROW_EXCEPTION(hr);
    if(VARIANT_TRUE == vVariant.boolVal)
    {
        DEBUG_INFO;
        bRetValue = TRUE;
    }
    DEBUG_INFO;
    VariantClear(&vVariant);
    return bRetValue;
}

/******************************************************************************

    Routine Description:

        This function sets the ITaskScheduler Interface.It also connects to
        the remote machine if specified &   helps  to operate
        ITaskScheduler on the specified target m/c.

    Arguments:
        none


    Return Value :
     BOOL    TRUE: If it successfully sets ITaskScheduler Interface
             FALSE: Otherwise.

******************************************************************************/

BOOL
CETQuery::SetTaskScheduler()
{
    HRESULT hr = S_OK;
    LPWSTR wszComputerName = NULL;
    WCHAR wszActualComputerName[ 2 * MAX_STRING_LENGTH ] = DOMAIN_U_STRING;
    wchar_t* pwsz = L"";
    WORD wSlashCount = 0 ;

    DEBUG_INFO;
    hr = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_ALL,
                           IID_ITaskScheduler,(LPVOID*) &m_pITaskScheduler);

    DEBUG_INFO;
    if( FAILED(hr))
    {
        DEBUG_INFO;
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        return FALSE;
    }
    DEBUG_INFO;

    //If the operation is on remote machine
    if( m_bLocalSystem == FALSE )
    {
        DEBUG_INFO;
        wszComputerName = (LPWSTR)m_pszServerName;

        //check whether the server name prefixed with \\ or not.
        if( wszComputerName != NULL )
        {
            pwsz =  wszComputerName;
            while ( ( *pwsz != NULL_U_CHAR ) && ( *pwsz == BACK_SLASH_U )  )
            {
                // server name prefixed with '\'..
                // so..increment the pointer and count number of black slashes..
                pwsz = _wcsinc(pwsz);
                wSlashCount++;
            }

            if( (wSlashCount == 2 ) ) // two back slashes are present
            {
                StringCopy( wszActualComputerName, wszComputerName, SIZE_OF_ARRAY(wszActualComputerName) );
            }
            else if ( wSlashCount == 0 )
            {
                //Append "\\" to computer name
                StringConcat(wszActualComputerName, wszComputerName, 2 * MAX_RES_STRING);
            }

        }

        hr = m_pITaskScheduler->SetTargetComputer( wszActualComputerName );

    }
    else
    {
        DEBUG_INFO;
        //Local Machine
        hr = m_pITaskScheduler->SetTargetComputer( NULL );
    }

    if( FAILED( hr ) )
    {
        SetLastError ((DWORD) hr);
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        return FALSE;
    }
    DEBUG_INFO;
    return TRUE;
}

/******************************************************************************

    Routine Description:

        This function returns the path of the scheduled task application

    Arguments:
        none
    Return Value:

        A HRESULT  value indicating S_OK on success  else S_FALSE on failure

******************************************************************************/

HRESULT
CETQuery::GetApplicationToRun( void)
{
    
	ITask *pITask = NULL; 
	LPWSTR lpwszApplicationName = NULL;
    LPWSTR lpwszParameters = NULL;
    WCHAR szAppName[MAX_STRING_LENGTH] = L"\0";
    WCHAR szParams[MAX_STRING_LENGTH] = L"\0";
	HRESULT hr = S_OK;

    hr = m_pITaskScheduler->Activate(m_szScheduleTaskName,
                      IID_ITask,
                      (IUnknown**) &pITask);

    if (FAILED(hr))
    {
		SAFE_RELEASE_INTERFACE(pITask);
        return hr;
    }

	// get the entire path of application name
    hr = pITask->GetApplicationName(&lpwszApplicationName);
    if (FAILED(hr))
    {
        CoTaskMemFree(lpwszApplicationName);
		SAFE_RELEASE_INTERFACE(pITask);
        return hr;
    }

    // get the parameters
    hr = pITask->GetParameters(&lpwszParameters);
	SAFE_RELEASE_INTERFACE(pITask);
    if (FAILED(hr))
    {
        CoTaskMemFree(lpwszApplicationName);
        CoTaskMemFree(lpwszParameters);
        return hr;
    }
    
    StringCopy( szAppName, lpwszApplicationName, SIZE_OF_ARRAY(szAppName));
    StringCopy(szParams, lpwszParameters, SIZE_OF_ARRAY(szParams));

    if(StringLength(szAppName, 0) == 0)
    {
        StringCopy(m_szTask, L"\0", MAX_STRING_LENGTH);
    }
    else
    {
        StringConcat( szAppName, _T(" "), SIZE_OF_ARRAY(szAppName) );
        StringConcat( szAppName, szParams, SIZE_OF_ARRAY(szAppName) );
        StringCopy( m_szTask, szAppName, MAX_STRING_LENGTH);
    }

	CoTaskMemFree(lpwszApplicationName);
    CoTaskMemFree(lpwszParameters);
    return S_OK;
	
}
	

BOOL
CETQuery::DisplayXPResults(
    void
    )
/*++
Routine Description:
   This function displays all the triggers present on a remote XP machine.
   This function is for compatibility of .NET ot XP machine only.

Arguments:

    NONE

Return Value:
     BOOL: TRUE - If succedded in displaying results.
           FALSE- otherwise

--*/
{
    HRESULT hr = S_OK;
    VARIANT vVariant;
    BOOL bAlwaysTrue = TRUE;
    DWORD  dwEventId = 0;
    LONG lTemp = 0;
    DWORD dwFormatType = SR_FORMAT_TABLE;

    // store Row number.
    DWORD dwRowCount = 0;
    BOOL bAtLeastOneEvent = FALSE;

    BSTR bstrConsumer   = NULL;
    BSTR bstrFilter     = NULL;

    TCHAR szHostName[MAX_STRING_LENGTH+1];
    TCHAR szEventTriggerName[MAX_TRIGGER_NAME];

    IEnumWbemClassObject *pEnumCmdTriggerConsumer = NULL;
    IEnumWbemClassObject *pEnumFilterToConsumerBinding = NULL;

    VariantInit( &vVariant );

    try
    {
        // if -id switch is specified
        if( (1 == cmdOptions[ ID_Q_TRIGGERID ].dwActuals) &&
            (StringLength( m_pszTriggerID,0) > 0 ))
        {

            TCHAR   szTemp[ MAX_STRING_LENGTH ];
            SecureZeroMemory(szTemp, MAX_STRING_LENGTH);
            StringCchPrintfW( szTemp,SIZE_OF_ARRAY(szTemp), QUERY_RANGE,
                        m_dwLowerBound, m_dwUpperBound );
            DEBUG_INFO;
            hr =  m_pWbemServices->ExecQuery( _bstr_t( QUERY_LANGUAGE), _bstr_t(szTemp),
                             WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL,
                                                       &pEnumCmdTriggerConsumer );
            ON_ERROR_THROW_EXCEPTION(hr);

            DEBUG_INFO;
            hr = SetInterfaceSecurity( pEnumCmdTriggerConsumer,
                                       m_pAuthIdentity );
            ON_ERROR_THROW_EXCEPTION(hr);

            DEBUG_INFO;

            // retrieves  CmdTriggerConsumer class
            DEBUG_INFO;
            hr = m_pWbemServices->GetObject(_bstr_t( CLS_TRIGGER_EVENT_CONSUMER ),
                                       0, NULL, &m_pClass, NULL);
            ON_ERROR_THROW_EXCEPTION(hr);

            DEBUG_INFO;

            // Gets  information about the "QueryETrigger( " method of
            // "cmdTriggerConsumer" class
            hr = m_pClass->GetMethod(_bstr_t( FN_QUERY_ETRIGGER_XP ),
                                    0, &m_pInClass, NULL);
            ON_ERROR_THROW_EXCEPTION(hr);

            DEBUG_INFO;

           // create a new instance of a class "TriggerEventConsumer ".
            hr = m_pInClass->SpawnInstance(0, &m_pInInst);
            ON_ERROR_THROW_EXCEPTION(hr);

            hr = SetInterfaceSecurity( pEnumCmdTriggerConsumer,
                                       m_pAuthIdentity );
            ON_ERROR_THROW_EXCEPTION(hr);

            DEBUG_INFO;
            while( bAlwaysTrue )
            {
                ULONG uReturned = 0;
                BSTR bstrTemp = NULL;
                CHString strTemp;

                DEBUG_INFO;
                // Get one  object starting at the current position in an
                //enumeration
                SAFE_RELEASE_INTERFACE(m_pObj);
                hr = pEnumCmdTriggerConsumer->Next(WBEM_INFINITE,
                                                    1,&m_pObj,&uReturned);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;
                if( 0 == uReturned)
                {
                    SAFE_RELEASE_INTERFACE(m_pObj);
                    break;
                }

                hr = m_pObj->Get(_bstr_t( FPR_TRIGGER_ID ),
                                0, &vVariant, 0, 0);
                if(FAILED(hr))
                {
                    SAFE_RELEASE_INTERFACE(m_pObj);
                    if( WBEM_E_NOT_FOUND == hr)
                    {
                        continue;
                    }
                    ON_ERROR_THROW_EXCEPTION(hr);
                }
                DEBUG_INFO;
                if( ( VT_EMPTY != V_VT( &vVariant ) ) &&
                    ( VT_NULL !=  V_VT( &vVariant ) ) )
                {
                    dwEventId = ( DWORD ) vVariant.lVal ;
                }
                else
                {
                    dwEventId = 0 ;
                }
                VariantClear(&vVariant);

        // Retrieves the "Trigger Name"  information
                hr = m_pObj->Get(_bstr_t( FPR_TRIGGER_NAME ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                if( VT_BSTR == V_VT( &vVariant ) )
                {
                    StringCopy(szEventTriggerName, ( LPTSTR )_bstr_t( vVariant ), MAX_RES_STRING);
                }
                else
                {
                   StringCopy(szEventTriggerName, GetResString( IDS_ID_NA ), MAX_RES_STRING);
                }
                VariantClear(&vVariant);

        // Retrieves the "Trigger Description"  information
                hr = m_pObj->Get(_bstr_t( FPR_TRIGGER_DESC ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                if( VT_BSTR == V_VT( &vVariant ) )
                {
                    StringCopy(m_szBuffer,( LPTSTR )_bstr_t( vVariant ),
                               SIZE_OF_ARRAY(m_szBuffer));
                }
                else
                {
                    StringCopy(m_szBuffer, GetResString( IDS_ID_NA ),
                               SIZE_OF_ARRAY(m_szBuffer));
                }
                lTemp = StringLength(m_szBuffer,0);
                DEBUG_INFO;

                StringCopy(m_szEventDesc,m_szBuffer,
                             SIZE_OF_ARRAY(m_szEventDesc));
                VariantClear(&vVariant);
                DEBUG_INFO;

        // Retrieves the "Host Name"  information
                hr = m_pObj->Get(_bstr_t( L"__SERVER" ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                if( VT_BSTR == V_VT( &vVariant ) )
                {
                    StringCopy(szHostName,( LPTSTR )_bstr_t( vVariant ),SIZE_OF_ARRAY(szHostName));
                }
                else
                {
                    StringCopy(szHostName, GetResString( IDS_ID_NA ), SIZE_OF_ARRAY(szHostName));
                }
                VariantClear(&vVariant);
                DEBUG_INFO;

        // Retrieves the "RunAs User"  information
                hr = m_pObj->Get(_bstr_t( FPR_TASK_SCHEDULER ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;

                GetRunAsUserName((LPCWSTR)_bstr_t(vVariant.bstrVal), TRUE);

                StringCopy(m_szScheduleTaskName,(LPCWSTR)_bstr_t(vVariant),
                               SIZE_OF_ARRAY(m_szScheduleTaskName));
                VariantClear(&vVariant);

        //retrieves the 'Action' value if exits
                hr = m_pObj->Get( _bstr_t( L"Action" ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                StringCopy(m_szBuffer,(LPWSTR)_bstr_t(vVariant),
                           SIZE_OF_ARRAY(m_szBuffer));

                lTemp = StringLength(m_szBuffer,0);

                StringCopy(m_szTask, m_szBuffer, SIZE_OF_ARRAY(m_szTask));
                VariantClear(&vVariant);


                StringCopy(szTemp,L"",SIZE_OF_ARRAY(szTemp));
                StringCchPrintfW( szTemp, SIZE_OF_ARRAY(szTemp),
                            BINDING_CLASS_QUERY, dwEventId);

                DEBUG_INFO;
                hr =  m_pWbemServices->ExecQuery( _bstr_t(QUERY_LANGUAGE),
                                                 _bstr_t(szTemp),
                                                 WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                                 NULL,
                                                 &pEnumFilterToConsumerBinding);
                ON_ERROR_THROW_EXCEPTION(hr);

                DEBUG_INFO;
                hr = SetInterfaceSecurity( pEnumFilterToConsumerBinding,
                                       m_pAuthIdentity );

                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;

                // Get one  object starting at the current position in an
                //enumeration
                SAFE_RELEASE_INTERFACE(m_pClass);
                hr = pEnumFilterToConsumerBinding->Next(WBEM_INFINITE,
                                                    1,&m_pClass,&uReturned);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;
                if( 0 == uReturned )
                {
                    SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
                    SAFE_RELEASE_INTERFACE(m_pObj);
                    SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
                    SAFE_RELEASE_INTERFACE(m_pEventFilter);
                   continue;
                }

                DEBUG_INFO;
                hr = m_pClass->Get(_bstr_t( L"Filter" ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);
                DEBUG_INFO;
                hr = m_pWbemServices->GetObject(    _bstr_t( vVariant ),
                                                    0,
                                                    NULL,
                                                    &m_pEventFilter,
                                                    NULL);
                VariantClear(&vVariant);
                DEBUG_INFO;
                if(FAILED(hr))
                {
                    if( WBEM_E_NOT_FOUND == hr)
                    {
                        SAFE_RELEASE_INTERFACE(pEnumFilterToConsumerBinding);
                        continue;
                    }
                    ON_ERROR_THROW_EXCEPTION(hr);
                }

                DEBUG_INFO;
                hr = m_pEventFilter->Get(_bstr_t( L"Query" ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                StringCopy(m_szBuffer,(LPWSTR)_bstr_t(vVariant),
                           SIZE_OF_ARRAY(m_szBuffer));
                VariantClear(&vVariant);

                DEBUG_INFO;

                FindAndReplace(m_szBuffer,QUERY_STRING_AND,SHOW_WQL_QUERY);
                FindAndReplace(m_szBuffer,L"targetinstance.LogFile",L"Log");
                FindAndReplace(m_szBuffer,L"targetinstance.Type",L"Type");
                FindAndReplace(m_szBuffer,L"targetinstance.EventCode",L"Id");
                FindAndReplace(m_szBuffer,
                               L"targetinstance.SourceName",L"Source");

                DEBUG_INFO;
                // Remove extra spaces
                FindAndReplace( m_szBuffer,L"  ",L" ");

                // Remove extra spaces
                FindAndReplace(m_szBuffer,L"  ",L" ");

                lTemp = StringLength(m_szBuffer,0);

                // for the safer size for allocation of memory.
                // allocates memory only if new WQL is greate than previous one.
                lTemp += 4;

               if(lTemp > m_lWQLColWidth)
                {
                    DEBUG_INFO;
                    // first free it (if previously allocated)
                    RELEASE_MEMORY_EX(m_pszEventQuery);
                    m_pszEventQuery = new TCHAR[lTemp+1];
                    CheckAndSetMemoryAllocation(m_pszEventQuery,lTemp);
                }
                lTemp = m_lWQLColWidth;
                CalcColWidth(lTemp,&m_lWQLColWidth,m_szBuffer);

                // Now manipulate the WQL string to get EventQuery....
                FindAndReplace(m_szBuffer,SHOW_WQL_QUERY,
                                GetResString(IDS_EVENTS_WITH));

                //to remove extra spaces
                FindAndReplace(m_szBuffer,L"  ",L" ");

                //to remove extra spaces
                FindAndReplace( m_szBuffer,L"  ",L" ");
                StringCopy( m_pszEventQuery,m_szBuffer,
                              SIZE_OF_NEW_ARRAY(m_pszEventQuery));

                DEBUG_INFO;


                // Now Shows the results on screen
                // Appends for in m_arrColData array
                dwRowCount = DynArrayAppendRow( m_arrColData, NO_OF_COLUMNS );

                // Fills Results in m_arrColData data structure
                DynArraySetString2( m_arrColData, dwRowCount, HOST_NAME,
                                  szHostName,0);
                DynArraySetDWORD2( m_arrColData , dwRowCount,
                                  TRIGGER_ID,dwEventId);
                DynArraySetString2( m_arrColData, dwRowCount, TRIGGER_NAME,
                                   szEventTriggerName,0);
                DynArraySetString2( m_arrColData, dwRowCount, TASK,
                                   m_szTask,0);
                DynArraySetString2( m_arrColData, dwRowCount, EVENT_QUERY,
                                   m_pszEventQuery,0);
                DynArraySetString2( m_arrColData, dwRowCount, EVENT_DESCRIPTION,
                                   m_szEventDesc,0);
                DynArraySetString2( m_arrColData, dwRowCount, TASK_USERNAME,
                                   m_szTaskUserName,0);


                bAtLeastOneEvent = TRUE;

                // Calculatate new column width for each column
                lTemp = m_lHostNameColWidth;
                CalcColWidth(lTemp,&m_lHostNameColWidth,szHostName);

                lTemp = m_lETNameColWidth;
                CalcColWidth(lTemp,&m_lETNameColWidth,szEventTriggerName);

                lTemp = m_lTaskColWidth;
                CalcColWidth(lTemp,&m_lTaskColWidth,m_szTask);

                lTemp = m_lQueryColWidth;
                CalcColWidth(lTemp,&m_lQueryColWidth,m_pszEventQuery);

                lTemp = m_lDescriptionColWidth;
                CalcColWidth(lTemp,&m_lDescriptionColWidth,m_szEventDesc);

                // Resets current containts..if any
                StringCopy(szHostName, L"",SIZE_OF_ARRAY(szHostName));
                dwEventId = 0;
                StringCopy(szEventTriggerName,L"",SIZE_OF_ARRAY(szEventTriggerName));
                StringCopy( m_szTask, L"",
                            SIZE_OF_ARRAY(m_szTask));
                StringCopy(m_pszEventQuery,L"",SIZE_OF_NEW_ARRAY(m_pszEventQuery));
                StringCopy(m_szEventDesc,L"",SIZE_OF_ARRAY(m_szEventDesc));
                SAFE_RELEASE_INTERFACE(m_pObj);
                SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
                SAFE_RELEASE_INTERFACE(m_pEventFilter);

                DEBUG_INFO;
            }
        }
        else
        {
            //Following method will creates an enumerator that returns the
            // instances of a specified __FilterToConsumerBinding class
            hr = m_pWbemServices->
                    CreateInstanceEnum(_bstr_t( CLS_FILTER_TO_CONSUMERBINDING ),
                                       WBEM_FLAG_SHALLOW,
                                       NULL,
                                       &pEnumFilterToConsumerBinding);
            ON_ERROR_THROW_EXCEPTION(hr);

           hr = SetInterfaceSecurity( pEnumFilterToConsumerBinding,
                                   m_pAuthIdentity );
           ON_ERROR_THROW_EXCEPTION(hr);


            // retrieves  CmdTriggerConsumer class
            hr = m_pWbemServices->GetObject(_bstr_t( CLS_TRIGGER_EVENT_CONSUMER ),
                                       0, NULL, &m_pClass, NULL);
            ON_ERROR_THROW_EXCEPTION(hr);

            // Gets  information about the "QueryETrigger( " method of
            // "cmdTriggerConsumer" class
            hr = m_pClass->GetMethod(_bstr_t( FN_QUERY_ETRIGGER_XP ),
                                    0, &m_pInClass, NULL);
            ON_ERROR_THROW_EXCEPTION(hr);

           // create a new instance of a class "TriggerEventConsumer ".
            hr = m_pInClass->SpawnInstance(0, &m_pInInst);
            ON_ERROR_THROW_EXCEPTION(hr);

            // set the security at the interface level also
            hr = SetInterfaceSecurity( pEnumFilterToConsumerBinding,
                                       m_pAuthIdentity );
            ON_ERROR_THROW_EXCEPTION(hr);

            while(1)
            {
                ULONG uReturned = 0; // holds no. of object returns from Next
                                    //mathod

                BSTR bstrTemp = NULL;
                CHString strTemp;

                // Get one  object starting at the current position in an
                //enumeration
                hr = pEnumFilterToConsumerBinding->Next(WBEM_INFINITE,
                                                    1,&m_pObj,&uReturned);
                ON_ERROR_THROW_EXCEPTION(hr);
                if(uReturned == 0)
                {
                    SAFE_RELEASE_INTERFACE(m_pObj);
                    break;
                }
                VariantInit(&vVariant);
                SAFE_RELEASE_BSTR(bstrTemp);
                hr = m_pObj->Get(_bstr_t( L"Consumer" ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                bstrConsumer =SysAllocString( vVariant.bstrVal);
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);
                // Search for trggereventconsumer string as we are interested to
                // get object from this class only
                strTemp = bstrConsumer;
                if(strTemp.Find(CLS_TRIGGER_EVENT_CONSUMER)==-1)
                    continue;
                hr = SetInterfaceSecurity( m_pWbemServices,
                                           m_pAuthIdentity );

                    ON_ERROR_THROW_EXCEPTION(hr);

                hr = m_pWbemServices->GetObject(bstrConsumer,
                                                0,
                                                NULL,
                                                &m_pTriggerEventConsumer,
                                                NULL);
                SAFE_RELEASE_BSTR(bstrConsumer);
                if(FAILED(hr))
                {
                    if(hr==WBEM_E_NOT_FOUND)
                        continue;
                    ON_ERROR_THROW_EXCEPTION(hr);
                }
                bstrTemp = SysAllocString(L"Filter");
                hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
                SAFE_RELEASE_BSTR(bstrTemp);
                ON_ERROR_THROW_EXCEPTION(hr);
                bstrFilter = SysAllocString(vVariant.bstrVal);
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);
                hr = m_pWbemServices->GetObject(
                                                    bstrFilter,
                                                    0,
                                                    NULL,
                                                    &m_pEventFilter,
                                                    NULL);
                SAFE_RELEASE_BSTR(bstrFilter);
                if(FAILED(hr))
                {
                    if(hr==WBEM_E_NOT_FOUND)
                        continue;
                    ON_ERROR_THROW_EXCEPTION(hr);
                }

                //retrieves the 'TriggerID' value if exits
                bstrTemp = SysAllocString(FPR_TRIGGER_ID);
                hr = m_pTriggerEventConsumer->Get(bstrTemp,
                                0, &vVariant, 0, 0);
                if(FAILED(hr))
                {
                    if(hr==WBEM_E_NOT_FOUND)
                        continue;
                    ON_ERROR_THROW_EXCEPTION(hr);
                }
                SAFE_RELEASE_BSTR(bstrTemp);
                dwEventId = vVariant.lVal ;
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                //retrieves the 'Action' value if exits
                bstrTemp = SysAllocString(L"Action");
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);
                SAFE_RELEASE_BSTR(bstrTemp);

                StringCopy( m_szBuffer, (LPWSTR)_bstr_t(vVariant),
                            SIZE_OF_ARRAY( m_szBuffer ));
                lTemp = StringLength( m_szBuffer, 0 );
                lTemp += 4; // for the safer size for allocation of memory.

                // allocates memory only if new task length is greate than previous one.
                if(lTemp > m_lTaskColWidth)
                {
                    CheckAndSetMemoryAllocation(m_szTask,lTemp);
                }
                StringCopy(m_szTask,m_szBuffer, SIZE_OF_ARRAY(m_szTask));
                VariantClear(&vVariant);

                //retrieves the  'TriggerDesc' value if exits
                bstrTemp = SysAllocString(FPR_TRIGGER_DESC);
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                SAFE_RELEASE_BSTR(bstrTemp);

                StringCopy(m_szBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal), SIZE_OF_ARRAY( m_szBuffer ));
                lTemp = StringLength(m_szBuffer, 0);
                if(lTemp == 0)// Means description is not available make it N/A.
                {
                    StringCopy(m_szBuffer,GetResString(IDS_ID_NA), SIZE_OF_ARRAY( m_szBuffer ));
                    lTemp = StringLength(m_szBuffer, 0);
                }
                lTemp += 4; // for the safer size for allocation of memory.

                // allocates memory only if new Description length is greate than
                // previous one.
                if(lTemp > m_lDescriptionColWidth)
                {
                    CheckAndSetMemoryAllocation(m_szEventDesc,lTemp);
                }
                StringCopy(m_szEventDesc,m_szBuffer, SIZE_OF_ARRAY( m_szEventDesc ));
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);
                // TriggerName
                //retrieves the  'TriggerName' value if exits
                bstrTemp = SysAllocString(FPR_TRIGGER_NAME);
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
                SAFE_RELEASE_BSTR(bstrTemp);
                ON_ERROR_THROW_EXCEPTION(hr);
                StringCchPrintfW(szEventTriggerName, SIZE_OF_ARRAY(szEventTriggerName),
                             _T("%s"), (LPWSTR)_bstr_t( vVariant ));
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // Host Name
                //retrieves the  '__SERVER' value if exits
                bstrTemp = SysAllocString(L"__SERVER");
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
                SAFE_RELEASE_BSTR(bstrTemp);
                ON_ERROR_THROW_EXCEPTION(hr);

                StringCchPrintfW(szHostName, SIZE_OF_ARRAY(szHostName),
                             _T("%s"), (LPWSTR)_bstr_t( vVariant ));
                VariantClear(&vVariant);

        // Retrieve 'Query' for the trigger.
                hr = m_pEventFilter->Get(_bstr_t( L"Query" ), 0, &vVariant, 0, 0);
                ON_ERROR_THROW_EXCEPTION(hr);

                StringCopy(m_szBuffer,(LPWSTR)_bstr_t(vVariant), SIZE_OF_ARRAY( m_szBuffer ));
                VariantClear(&vVariant);

                FindAndReplace(m_szBuffer,QUERY_STRING_AND,SHOW_WQL_QUERY);
                FindAndReplace(m_szBuffer,L"targetinstance.LogFile",L"Log");
                FindAndReplace(m_szBuffer,L"targetinstance.Type",L"Type");
                FindAndReplace(m_szBuffer,L"targetinstance.EventCode",L"Id");
                FindAndReplace(m_szBuffer,
                               L"targetinstance.SourceName",L"Source");
                FindAndReplace(m_szBuffer,L"  ",L" ");//to remove extra spaces
                FindAndReplace(m_szBuffer,L"  ",L" ");//to remove extra spaces

                lTemp = StringLength(m_szBuffer, 0);
                lTemp += 4; // for the safer size for allocation of memory.
                // allocates memory only if new WQL is greate than previous one.
               if(lTemp > m_lWQLColWidth)
                {
                    // first free it (if previously allocated)
                    RELEASE_MEMORY_EX(m_pszEventQuery);
                    m_pszEventQuery = new TCHAR[lTemp+1];
                    CheckAndSetMemoryAllocation(m_pszEventQuery,lTemp);
                }

                lTemp = m_lWQLColWidth;
                CalcColWidth(lTemp,&m_lWQLColWidth,m_szBuffer);
                // Now manipulate the WQL string to get EventQuery....
                FindAndReplace(m_szBuffer,SHOW_WQL_QUERY,
                                GetResString(IDS_EVENTS_WITH));
                FindAndReplace(m_szBuffer,L"  ",L" ");//to remove extra spaces
                FindAndReplace(m_szBuffer,L"  ",L" ");//to remove extra spaces

                StringCopy(m_pszEventQuery,m_szBuffer, SIZE_OF_NEW_ARRAY( m_pszEventQuery ));

                // Retrieves the "TaskScheduler"  information
                bstrTemp = SysAllocString(L"ScheduledTaskName");
                hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
                SAFE_RELEASE_BSTR(bstrTemp);
                ON_ERROR_THROW_EXCEPTION(hr);
                GetRunAsUserName((LPCWSTR)_bstr_t(vVariant.bstrVal), TRUE);
                StringCopy( m_szScheduleTaskName, (LPWSTR) _bstr_t( vVariant ),
                            SIZE_OF_ARRAY( m_szScheduleTaskName ) );
                VariantClear(&vVariant);

                //////////////////////////////////////////

               // Now Shows the results on screen
               // Appends for in m_arrColData array
                dwRowCount = DynArrayAppendRow( m_arrColData, NO_OF_COLUMNS );
               // Fills Results in m_arrColData data structure
               DynArraySetString2(m_arrColData,dwRowCount,HOST_NAME,szHostName,0);
               DynArraySetDWORD2(m_arrColData ,dwRowCount,TRIGGER_ID,dwEventId);
               DynArraySetString2(m_arrColData,dwRowCount,TRIGGER_NAME,szEventTriggerName,0);
               DynArraySetString2(m_arrColData,dwRowCount,TASK,m_szTask,0);
               DynArraySetString2(m_arrColData,dwRowCount,EVENT_QUERY,m_pszEventQuery,0);
               DynArraySetString2(m_arrColData,dwRowCount,EVENT_DESCRIPTION,m_szEventDesc,0);
               DynArraySetString2(m_arrColData,dwRowCount,TASK_USERNAME,m_szTaskUserName,0);
               bAtLeastOneEvent = TRUE;

              // Calculatate new column width for each column
              lTemp = m_lHostNameColWidth;
              CalcColWidth(lTemp,&m_lHostNameColWidth,szHostName);

              lTemp = m_lETNameColWidth;
              CalcColWidth(lTemp,&m_lETNameColWidth,szEventTriggerName);

              lTemp = m_lTaskColWidth;
              CalcColWidth(lTemp,&m_lTaskColWidth,m_szTask);

              lTemp = m_lQueryColWidth;
              CalcColWidth(lTemp,&m_lQueryColWidth,m_pszEventQuery);

              lTemp = m_lDescriptionColWidth;
              CalcColWidth(lTemp,&m_lDescriptionColWidth,m_szEventDesc);
               // Resets current containts..if any
               StringCopy( szHostName,L"", SIZE_OF_ARRAY(szHostName) );
               dwEventId = 0;
               StringCopy( szEventTriggerName, L"", SIZE_OF_ARRAY(szEventTriggerName));
               StringCopy( m_szTask, L"", SIZE_OF_ARRAY(m_szTask));
               StringCopy( m_pszEventQuery, L"", SIZE_OF_ARRAY(m_pszEventQuery));
               StringCopy( m_szEventDesc, L"", SIZE_OF_ARRAY(m_szEventDesc) );
               SAFE_RELEASE_INTERFACE(m_pObj);
               SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
               SAFE_RELEASE_INTERFACE(m_pEventFilter);
            } // End of while
        }
        if(0 == StringCompare( m_pszFormat,GetResString(IDS_STRING_TABLE),
                              TRUE,0))
        {
            dwFormatType = SR_FORMAT_TABLE;
        }
        else if(0 == StringCompare( m_pszFormat,
                                    GetResString(IDS_STRING_LIST),TRUE,0))
        {
            dwFormatType = SR_FORMAT_LIST;
        }
        else if(0 == StringCompare( m_pszFormat,
                                    GetResString(IDS_STRING_CSV),TRUE,0))
        {
            dwFormatType = SR_FORMAT_CSV;
        }
        else // Default
        {
           dwFormatType = SR_FORMAT_TABLE;
        }
        if( TRUE == bAtLeastOneEvent)
        {
            // Show Final Query Results on screen
            PrepareColumns ();
            DEBUG_INFO;
            if ( FALSE ==  IsSchSvrcRunning())
            {
                DEBUG_INFO;
                ShowMessage(stderr,GetResString(IDS_SERVICE_NOT_RUNNING));
            }
            if((SR_FORMAT_CSV & dwFormatType) != SR_FORMAT_CSV)
            {
                ShowMessage(stdout,BLANK_LINE);
            }
            if( TRUE == m_bNoHeader)
            {
                dwFormatType |= SR_NOHEADER;
            }

            ShowResults(NO_OF_COLUMNS,mainCols,dwFormatType,m_arrColData);
        }
        else if( StringLength(m_pszTriggerID,0)> 0)
        {
            // Show Message
            TCHAR szErrorMsg[MAX_RES_STRING+1];
            TCHAR szMsgFormat[MAX_RES_STRING+1];
            StringCopy(szMsgFormat,GetResString(IDS_NO_EVENTID_FOUND),
                       SIZE_OF_ARRAY(szMsgFormat));
            StringCchPrintfW(szErrorMsg, SIZE_OF_ARRAY(szErrorMsg),
                             szMsgFormat,m_pszTriggerID);
            ShowMessage(stdout,szErrorMsg);
        }
        else
        {
            // Show Message
            ShowMessage(stdout,GetResString(IDS_NO_EVENT_FOUNT));
        }
    }
    catch( _com_error e )
    {
        DEBUG_INFO;

        // WMI returns string for this hr value is "Not Found." which is not
        // user friendly. So changing the message text.
        if( 0x80041002 == hr )
        {
            ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
        }
        else
        {
            DEBUG_INFO;
            WMISaveError( e );
            ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        }
        SAFE_RELEASE_INTERFACE( pEnumCmdTriggerConsumer );
        SAFE_RELEASE_INTERFACE( pEnumFilterToConsumerBinding );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        ShowLastErrorEx(stderr,SLE_TYPE_ERROR|SLE_INTERNAL);
        SAFE_RELEASE_INTERFACE( pEnumCmdTriggerConsumer );
        SAFE_RELEASE_INTERFACE( pEnumFilterToConsumerBinding );
        return FALSE;
    }

    SAFE_RELEASE_INTERFACE( pEnumCmdTriggerConsumer );
    SAFE_RELEASE_INTERFACE( pEnumFilterToConsumerBinding );
    // Operation successful.
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\etquery.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    ETQuery.h

Abstract:

  This module  contanins function definations required by ETQuery.cpp

Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:


******************************************************************************/


#ifndef  _ETQUERY
#define _ETQUERY

#define COL_HOSTNAME        GetResString(IDS_HOSTNAME)
#define COL_TRIGGER_ID      GetResString(IDS_TRIGGER_ID)
#define COL_TRIGGER_NAME    GetResString(IDS_TRIGGER_NAME)
#define COL_TASK            GetResString(IDS_TASK)
#define COL_EVENT_QUERY     GetResString(IDS_EVENT_QUERY)
#define COL_DESCRIPTION     GetResString(IDS_DESCRIPTION)
#define COL_WQL             GetResString(IDS_QUERY_LAGUAGE)
#define COL_TASK_USERNAME   GetResString(IDS_TASK_USERNAME)

#define    MAX_COL_LENGTH        MAX_RES_STRING - 1
#define    V_WIDTH_TRIG_ID   10
#define    V_WIDTH_TRIG_NAME 25
#define    V_WIDTH_TASK      40

#define    WIDTH_HOSTNAME      StringLength(COL_HOSTNAME,0)+2
#define    WIDTH_TRIGGER_ID    StringLength(COL_TRIGGER_ID,0)+2
#define    WIDTH_TRIGGER_NAME  StringLength(COL_TRIGGER_NAME,0)
#define    WIDTH_TASK          StringLength(COL_TASK,0) + 2
#define    WIDTH_EVENT_QUERY   StringLength(COL_EVENT_QUERY,0)+2
#define    WIDTH_DESCRIPTION   StringLength(COL_DESCRIPTION,0)+2
#define    WIDTH_TASK_USERNAME 64 

#define DOMAIN_U_STRING     L"\\\\"
#define NULL_U_CHAR         L'\0'
#define BACK_SLASH_U        L'\\'

#define HOST_NAME          0
#define TRIGGER_ID         1
#define TRIGGER_NAME       2
#define TASK               3
#define EVENT_QUERY        4
#define EVENT_DESCRIPTION  5
#define TASK_USERNAME      6

#define MAX_COMMANDLINE_Q_OPTION 8  // Maximum Command Line  List
#define NO_OF_COLUMNS            7


#define ID_Q_QUERY         0
#define ID_Q_SERVER        1
#define ID_Q_USERNAME      2
#define ID_Q_PASSWORD      3
#define ID_Q_FORMAT        4
#define ID_Q_NOHEADER      5
#define ID_Q_VERBOSE       6
#define ID_Q_TRIGGERID     7

class CETQuery
{
public:
    BOOL ExecuteQuery();
    void Initialize();
    void ProcessOption( IN DWORD argc, IN LPCTSTR argv[]);
    BOOL GetNValidateTriggerId( IN OUT DWORD *szLower, 
                                IN OUT DWORD *szUpper );
    CETQuery();
    virtual ~CETQuery();
    CETQuery::CETQuery(LONG lMinMemoryReq,BOOL bNeedPassword);
private:
    LONG FindAndReplace( IN OUT LPTSTR lpszSource, IN LPCTSTR lpszFind,
                         IN LPCTSTR lpszReplace);
    TCHAR m_szBuffer[MAX_STRING_LENGTH * 4];
    TARRAY m_arrColData;
    void PrepareColumns();
    void CheckAndSetMemoryAllocation( IN OUT LPTSTR pszStr, IN LONG lSize);
    void CalcColWidth( IN LONG lOldLength, OUT LONG *plNewLength,
                       IN LPTSTR pszString);
    HRESULT GetRunAsUserName( IN LPCWSTR pszScheduleTaskName, IN BOOL bXPorNET = FALSE);
    HRESULT GetApplicationToRun(void);

    void PrepareCMDStruct();
    void CheckRpRu(void);
    BOOL IsSchSvrcRunning();
    BOOL SetTaskScheduler();
    BOOL DisplayXPResults();
    LPTSTR  m_pszServerName;
    LPTSTR  m_pszUserName;
    LPTSTR  m_pszPassword;
    LPTSTR  m_pszFormat;
    LPTSTR  m_pszTriggerID;
    BOOL    m_bVerbose;
    BOOL    m_bNoHeader;
    BOOL    m_bNeedPassword;
    BOOL    m_bUsage;
    BOOL    m_bQuery;
    BOOL    m_bLocalSystem;
    BOOL    m_bNeedDisconnect;
    BOOL    m_bIsCOMInitialize;
    LONG    m_lMinMemoryReq;
    TCHAR   m_szEventDesc[MAX_STRING_LENGTH];
    TCHAR   m_szTask[MAX_TASK_NAME];
    TCHAR   m_szTaskUserName[MAX_STRING_LENGTH];
    TCHAR   m_szScheduleTaskName[MAX_STRING_LENGTH];

    LONG    m_lHostNameColWidth;
    LONG    m_lTriggerIDColWidth;
    LONG    m_lETNameColWidth;
    LONG    m_lTaskColWidth;
    LONG    m_lQueryColWidth;
    LONG    m_lDescriptionColWidth;
    LONG    m_lTaskUserName;
    DWORD   m_dwLowerBound;
    DWORD   m_dwUpperBound;


    // variables required to show results..
    LPTSTR m_pszEventQuery;
    LONG   m_lWQLColWidth;

    // WMI / COM interfaces
    IWbemLocator*           m_pWbemLocator;
    IWbemServices*          m_pWbemServices;
    IWbemClassObject*       m_pObj; // Temp. pointers which holds
                                   //next instance
    IWbemClassObject*       m_pTriggerEventConsumer;
    IWbemClassObject*       m_pEventFilter;
    IWbemClassObject*       m_pClass;
    IWbemClassObject*       m_pInClass;
    IWbemClassObject*       m_pInInst;
    IWbemClassObject*       m_pOutInst;
    ITaskScheduler*         m_pITaskScheduler;

    // WMI connectivity
    COAUTHIDENTITY* m_pAuthIdentity;

    // Array to store command line options
    TCMDPARSER2 cmdOptions[MAX_COMMANDLINE_Q_OPTION];
    TCOLUMNS   mainCols[NO_OF_COLUMNS];


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\eventtriggers.cpp ===
/******************************************************************************

  Copyright (c) Microsoft Corporation

  Module Name:

      EventTriggers.cpp

  Abstract:

      This module implements the command-line parsing to create/delete/query
      EventTriggers on  current running on local and remote systems.


  Author:

      Akhil V. Gokhale (akhil.gokhale@wipro.com)

  Revision History:

      Akhil V. Gokhale (akhil.gokhale@wipro.com) 03-Oct-2000 (Created.)

******************************************************************************/
#include "pch.h"
#include "ETCommon.h"
#include "EventTriggers.h"
#include "ShowError.h"
#include "ETCreate.h"
#include "ETDelete.h"
#include "ETQuery.h"

DWORD g_dwOptionFlag;

DWORD __cdecl
_tmain( 
    IN DWORD argc, 
    IN LPCTSTR argv[] 
    )
/*++
 Routine Description:
      This module reads the input from commond line and calls appropriate
      functions to achive to functionality of EventTrigger-Client.

 Arguments:
      [ in ] argc     : argument(s) count specified at the command prompt
      [ in ] argv     : argument(s) specified at the command prompt

 Return Value:
      The below are actually not return values but are the exit values
      returned to the OS by this application
          0       : utility is successfull
          1       : utility failed
--*/
{
    // local variables
    CEventTriggers eventTriggers;
    BOOL bResult = DIRTY_EXIT; // Programs return value status variable.
    g_dwOptionFlag = 0;
    TCHAR szErrorMsg[(MAX_RES_STRING*2)+1];
    try
    {
        if( 1 == argc )
        {
            if( FALSE == IsWin2KOrLater())
            {
                ShowMessage(stderr,ERROR_OS_INCOMPATIBLE);
            }
            else
            {
                // If no command line parameter is given then  -query option
                // will be taken as default.
                g_dwOptionFlag = 3;
                CETQuery etQuery(MAX_RES_STRING,
                                 FALSE);
                
                // Initializes variables.
                etQuery.Initialize();
               
                // execute query method to query EventTriggers in WMI.
                if( TRUE == etQuery.ExecuteQuery ())
                {
                    // as ExecuteQuery routine returns with TRUE,
                    // exit from program with error level CLEAN_EXIT
                    bResult = CLEAN_EXIT;
                }
            }
        }
        else
        {
          
            // As commandline parameter is specified so command parscing will
            // required.
            // Initialize variables for eventTriggers object.
            eventTriggers.Initialize ();
            
            // Process command line parameters.
            eventTriggers.ProcessOption(argc,argv);
            
            //if usage option is selected
            if( TRUE == eventTriggers.IsUsage() ) 
            {
                if(TRUE == eventTriggers.IsCreate())
                {
                    //Display create usage
                    eventTriggers.ShowCreateUsage ();
                }
                else if( TRUE == eventTriggers.IsDelete())
                {
                    //Display delete usage
                    eventTriggers.ShowDeleteUsage ();
                }
                else if(TRUE == eventTriggers.IsQuery())
                {
                    //Display query usage
                    eventTriggers.ShowQueryUsage ();
                }
                else
                {
                    //Display main usage
                    eventTriggers.ShowMainUsage ();
                }
                bResult = CLEAN_EXIT;
            }
            //if user selected create
            else if( TRUE == eventTriggers.IsCreate())
            {

                // creates a object of type CETCreate.
                //for create option
                g_dwOptionFlag = 1;
                CETCreate etCreate(255,
                                   eventTriggers.GetNeedPassword());
                
                // Initializes variables.
                etCreate.Initialize ();
                
                // Process command line argument for -create option.
                etCreate.ProcessOption (argc,argv);
                
                // execute create method to create EventTriggers in WMI.
                if( TRUE == etCreate.ExecuteCreate())
                {
                    // as ExecuteCreate routine returns with TRUE,
                    // exit from program with error level CLEAN_EXIT
                    bResult = CLEAN_EXIT;
                }
            }
            //if user selected delete
            else if( TRUE == eventTriggers.IsDelete ())
            {
                // creates a object of type CETDelete.
                //for create option
                g_dwOptionFlag = 2;
                CETDelete  etDelete(255,
                                    eventTriggers.GetNeedPassword());
                
                // Initializes variables.
                etDelete.Initialize ();
                
                // Process command line argument for -delete option.
                etDelete.ProcessOption (argc,argv);
                
                // execute delete method to delete EventTriggers in WMI.
                if( TRUE == etDelete.ExecuteDelete())
                {
                    // as ExecuteDelete routine returns with TRUE,
                    // exit from program with error level CLEAN_EXIT
                    bResult = CLEAN_EXIT;
                }
            }
            
            //if user selected -query.
            else if( TRUE == eventTriggers.IsQuery())
            {
                // creates a object of type CETQuery.
                
                //for create option set value to 3
                g_dwOptionFlag = 3;
                CETQuery etQuery(255,
                                 eventTriggers.GetNeedPassword ());
                
                // Initializes variables.
                etQuery.Initialize();
                
                // Process command line argument for -Query option.
                etQuery.ProcessOption(argc,argv);
                
                // execute query method to query EventTriggers in WMI.
                if( TRUE == etQuery.ExecuteQuery())
                {
                    // as ExecuteQuery routine returns with TRUE,
                    // exit from program with error level CLEAN_EXIT
                    bResult = CLEAN_EXIT;
                }
            }
            else
            {
                // Although this condition will never occure, for safe side
                // show error message as "ERROR: Invalid Syntax.
                TCHAR szTemp[(MAX_RES_STRING*2)+1];
                StringCchPrintfW(szTemp,SIZE_OF_ARRAY(szTemp),
                                   GetResString(IDS_INCORRECT_SYNTAX),GetResString(IDS_UTILITY_NAME));
                SetReason(szTemp);
                throw CShowError(MK_E_SYNTAX);
            }
        } // End else
    }// try block
    catch(CShowError se)
    {
        // Show Error message on screen depending on value passed through
        // through machanism.
        StringCchPrintfW(szErrorMsg,SIZE_OF_ARRAY(szErrorMsg),L"%s %s",TAG_ERROR,se.ShowReason());
        ShowMessage(stderr,szErrorMsg);
    }
    catch(CHeap_Exception ch)
    {
        SetLastError( ERROR_OUTOFMEMORY );
        SaveLastError();
        StringCchPrintfW(szErrorMsg,SIZE_OF_ARRAY(szErrorMsg),L"%s %s",TAG_ERROR,GetReason());
        ShowMessage(stderr, szErrorMsg);
    }
    // Returns from program with error level stored in bResult.
    ReleaseGlobals();
    return bResult;
}

CEventTriggers::CEventTriggers()
/*++
 Routine Description:
      CEventTriggers contructor

 Arguments:
      NONE

 Return Value:
      NONE

--*/
{
    // init to defaults
    m_pszServerNameToShow = NULL;
    m_bNeedDisconnect     = FALSE;

    m_bNeedPassword       = FALSE;
    m_bUsage              = FALSE;
    m_bCreate             = FALSE;
    m_bDelete             = FALSE;
    m_bQuery              = FALSE;

    m_arrTemp             = NULL;
}

CEventTriggers::~CEventTriggers()
/*++
 Routine Description:
      CEventTriggers destructor

 Arguments:
      NONE

 Return Value:
      NONE

--*/
{
    //
    // de-allocate memory allocations
    //
    DESTROY_ARRAY(m_arrTemp);
}


void
CEventTriggers::Initialize()
/*++
 Routine Description:
      initialize the EventTriggers utility

 Arguments:
      NONE

 Return Value:
      NONE

--*/
  {
    // if at all any occurs, we know that is because of the
    // failure in memory allocation ... so set the error
    SetLastError( ERROR_OUTOFMEMORY );
    SaveLastError();

    // Allocates memory
    m_arrTemp = CreateDynamicArray();
    if( NULL == m_arrTemp)
    {
        // error occures while allocating required memory, so throw
        // exception.
        throw CShowError(E_OUTOFMEMORY);
    }
    
    SecureZeroMemory(cmdOptions,sizeof(TCMDPARSER2) * MAX_COMMANDLINE_OPTION);

    // initialization is successful
    SetLastError( NOERROR );            // clear the error
    SetReason( L"" );           // clear the reason

}

BOOL
CEventTriggers::ProcessOption(
    IN DWORD argc, 
    IN LPCTSTR argv[]
    )
/*++
 Routine Description:
      This function will process/parce the command line options.

 Arguments:
      [ in ] argc     : argument(s) count specified at the command prompt
      [ in ] argv     : argument(s) specified at the command prompt

 Return Value:
      TRUE  : On Successful
      FALSE : On Error

--*/
{
    // local variable
    BOOL bReturn = TRUE;// stores return value of function.
    TCHAR szTemp[MAX_RES_STRING];
    TCHAR szStr [MAX_RES_STRING];
    StringCopy(szStr,GetResString(IDS_UTILITY_NAME),SIZE_OF_ARRAY(szStr));
    StringCchPrintfW(szTemp,SIZE_OF_ARRAY(szTemp),
                  GetResString(IDS_INCORRECT_SYNTAX), szStr);
    PrepareCMDStruct();
    // do the actual parsing of the command line arguments and check the result
    bReturn = DoParseParam2( argc, argv,-1,MAX_COMMANDLINE_OPTION, cmdOptions,0 );

    if( FALSE == bReturn)
    {
        // Command line contains invalid parameter(s) so throw exception for
        // invalid syntax.
        // Valid reason already set in DoParceParam,.
        throw CShowError(MK_E_SYNTAX);
    }

    if(( TRUE == m_bUsage) && argc>3)
    {
        // Only one  option can be accepted along with -? option
        // Example: EvTrig.exe -? -query -nh should be invalid.
        SetReason(szTemp);
        throw CShowError(MK_E_SYNTAX);
    }
    if((m_bCreate+m_bDelete+m_bQuery)>1)
    {
        // Only ONE OF  the -create -delete and -query can be given as
        // valid command line parameter.
        SetReason(szTemp);
        throw CShowError(MK_E_SYNTAX);
    }
    else if((2 == argc)&&( TRUE == m_bUsage))
    {
       // if -? alone given its a valid conmmand line
        bReturn = TRUE;
    }
    else if((argc>=2)&& ( FALSE == m_bCreate)&&
             (FALSE == m_bDelete)&&(FALSE == m_bQuery))
    {
        // If command line argument is equals or greater than 2 atleast one
        // of -query OR -create OR -delete should be present in it.
        // (for "-?" previous condition already takes care)
        // This to prevent from following type of command line argument:
        // EvTrig.exe -nh ... Which is a invalid syntax.
        SetReason(szTemp);
        throw CShowError(MK_E_SYNTAX);

    }

   // Following checking done if user given command like
    // -? -nh OR -? -v , its an invalid syntax.
    else if((TRUE == m_bUsage)&&( FALSE == m_bCreate)&&
            (FALSE == m_bDelete )&&(FALSE == m_bQuery)&&
            (3 == argc))
    {
        SetReason(szTemp);
        throw CShowError(MK_E_SYNTAX);
    }
    // Any how following variables do not required.
    DESTROY_ARRAY(m_arrTemp);
    return bReturn;

}

void
CEventTriggers::PrepareCMDStruct()
/*++
 Routine Description:
      This function will prepare column structure for DoParseParam Function.

 Arguments:
       none
 Return Value:
       none
--*/
{

    // Filling cmdOptions structure
    // -?
    StringCopyA( cmdOptions[ ID_HELP ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_HELP ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_HELP ].pwszOptions = szHelpOption;
    cmdOptions[ ID_HELP ].dwCount = 1;
    cmdOptions[ ID_HELP ].dwActuals = 0;
    cmdOptions[ ID_HELP ].dwFlags = CP_USAGE;
    cmdOptions[ ID_HELP ].pValue = &m_bUsage;
    cmdOptions[ ID_HELP ].dwLength    = 0;



   // -create
    StringCopyA( cmdOptions[ ID_CREATE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_CREATE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_CREATE ].pwszOptions = szCreateOption;
    cmdOptions[ ID_CREATE ].dwCount = 1;
    cmdOptions[ ID_CREATE ].dwActuals = 0;
    cmdOptions[ ID_CREATE ].dwFlags = 0;
    cmdOptions[ ID_CREATE ].pValue = &m_bCreate;
    cmdOptions[ ID_CREATE ].dwLength    = 0;

    // -delete
    StringCopyA( cmdOptions[ ID_DELETE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_DELETE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_DELETE ].pwszOptions = szDeleteOption;
    cmdOptions[ ID_DELETE ].dwCount = 1;
    cmdOptions[ ID_DELETE ].dwActuals = 0;
    cmdOptions[ ID_DELETE ].dwFlags = 0;
    cmdOptions[ ID_DELETE ].pValue = &m_bDelete;
    cmdOptions[ ID_DELETE ].dwLength    = 0;

    // -query
    StringCopyA( cmdOptions[ ID_QUERY ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_QUERY ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ ID_QUERY ].pwszOptions = szQueryOption;
    cmdOptions[ ID_QUERY ].dwCount = 1;
    cmdOptions[ ID_QUERY ].dwActuals = 0;
    cmdOptions[ ID_QUERY ].dwFlags = 0;
    cmdOptions[ ID_QUERY ].pValue = &m_bQuery;
    cmdOptions[ ID_QUERY ].dwLength    = 0;


  //  default ..
  // Although there is no default option for this utility...
  // At this moment all the switches other than specified above will be
  // treated as default parameter for Main DoParceParam.
  // Exact parcing depending on optins (-create -query or -delete) will be done
  // at that respective places.
    StringCopyA( cmdOptions[ ID_DEFAULT ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ ID_DEFAULT].dwType = CP_TYPE_TEXT;
    cmdOptions[ ID_DEFAULT ].pwszOptions = NULL;
    cmdOptions[ ID_DEFAULT ].pwszFriendlyName = NULL;
    cmdOptions[ ID_DEFAULT ].pwszValues = NULL;
    cmdOptions[ ID_DEFAULT ].dwCount = 0;
    cmdOptions[ ID_DEFAULT ].dwActuals = 0;
    cmdOptions[ ID_DEFAULT ].dwFlags = CP2_MODE_ARRAY|CP2_DEFAULT;
    cmdOptions[ ID_DEFAULT ].pValue = &m_arrTemp;
    cmdOptions[ ID_DEFAULT ].dwLength    = 0;
}

void
CEventTriggers::ShowMainUsage()
/*++
 Routine Description:
      Displays Eventriggers main usage

 Arguments:
      None
 Return Value:
      None

--*/
{
    // Displaying main usage
    for(DWORD dwIndx=IDS_HELP_M1;dwIndx<=IDS_HELP_END;dwIndx++)
    {
      ShowMessage(stdout,GetResString(dwIndx));
    }
}
BOOL
CEventTriggers::GetNeedPassword()
/*++
 Routine Description:
      Returns whether to ask for password or not.

 Arguments:
      None
 Return Value:
      BOOL

--*/
{
    return m_bNeedPassword;
}

BOOL
CEventTriggers::IsCreate()
/*++
 Routine Description:
      Returns if create option is selected.

 Arguments:
      None
 Return Value:
      BOOL

--*/
{
    return m_bCreate;
}

BOOL
CEventTriggers::IsUsage()
/*++
 Routine Description:
      Returns if usage option is selected.

 Arguments:
      None
 Return Value:
      BOOL

--*/
{
    return m_bUsage;
}

BOOL
CEventTriggers::IsDelete()
/*++
 Routine Description:
      Returns if delete option is selected.

 Arguments:
      None
 Return Value:
      BOOL
--*/
{
    return m_bDelete;
}

BOOL
CEventTriggers::IsQuery()
/*++
 Routine Description:
      Returns if Query option is selected.

 Arguments:
      None
 Return Value:
      BOOL

--*/
{
    return m_bQuery;
}

void
CEventTriggers::ShowCreateUsage()
/*++

Routine Description

    This function shows help message for EventTriggers utility for
    -create operation

Arguments:
    NONE

Return Value
    None
--*/
{
    // Displaying Create usage
    for(int iIndx=IDS_HELP_C1;iIndx<=IDS_HELP_CREATE_END;iIndx++)
    {
       ShowMessage(stdout,GetResString(iIndx));
    }
    return;
}

void
CEventTriggers::ShowDeleteUsage()
/*++

Routine Description

    This function shows help message for EventTriggers utility for
    -delete operation

Arguments:
    NONE

Return Value
    None
--*/
{
    for(int iIndx=IDS_HELP_D1;iIndx<=IDS_HELP_DELETE_END;iIndx++)
    {
       ShowMessage(stdout,GetResString(iIndx));
    }
    return;
}

void
CEventTriggers::ShowQueryUsage()
/*++
Routine Description

    This function shows help message for EventTriggers utility for
    -query operation

Arguments:
    NONE

Return Value
    None
--*/
{
    for(int iIndx=IDS_HELP_Q1;iIndx<=IDS_HELP_QUERY_END;iIndx++)
    {
        ShowMessage(stdout,GetResString(iIndx));
    }
    return;
}

HRESULT 
PropertyGet1( 
    IN     IWbemClassObject* pWmiObject,
    IN     LPCTSTR szProperty,
    IN OUT LPVOID pValue, 
    IN     DWORD dwSize 
    )
/*++
 Routine Description:
      Get the value of a property for the given instance .

 Arguments:
      [in]     pWmiObject - A pointer to wmi class.
      [in]     szProperty - property name whose value to be returned.
      [in out] pValue     - Variable to hold the data.
      [in]     dwSize     - size of the variable.

 Return Value:
      HRESULT value.
--*/
{
    // local variables
    HRESULT hr = S_OK;
    VARIANT varValue;
    DEBUG_INFO;
    // value should not be NULL
    if ( NULL == pValue )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        SaveLastError();
        return S_FALSE;
    }
    // initialize the values with zeros ... to be on safe side
    SecureZeroMemory( pValue,dwSize );

    // initialize the variant and then get the value of the specified property
    VariantInit( &varValue );
    hr = pWmiObject->Get( szProperty, 0, &varValue, NULL, NULL );
    if ( FAILED( hr ) )
    {
        // clear the variant variable
        VariantClear( &varValue );
        // failed to get the value for the property
        return hr;
    }

    // get and put the value
    switch( varValue.vt )
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_I2:
        *( ( short* ) pValue ) = V_I2( &varValue );
        break;

    case VT_I4:
        *( ( long* ) pValue ) = V_I4( &varValue );
        break;

    case VT_R4:
        *( ( float* ) pValue ) = V_R4( &varValue );
        break;

    case VT_R8:
        *( ( double* ) pValue ) = V_R8( &varValue );
        break;


    case VT_UI1:
        *( ( UINT* ) pValue ) = V_UI1( &varValue );
        break;

    case VT_BSTR:
        {
            // get the unicode value
            LPWSTR pszTmp =  V_BSTR(&varValue);
            StringCopy((LPWSTR)pValue,pszTmp,dwSize);
          
           break;
        }
    }

    // clear the variant variable
    if(FAILED(VariantClear( &varValue )))
    {
        return E_FAIL;
    }

    // inform success
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\eventtriggers.h ===
/******************************************************************************

  Copyright (c) Microsoft Corporation

  Module Name:

      EventTriggers.h

  Abstract:

      macros and function prototypes of EventTriggers.cpp

  Author:

      Akhil V. Gokhale (akhil.gokhale@wipro.com)

  Revision History:

      Akhil V. Gokhale (akhil.gokhale@wipro.com) 03-Oct-2000 (Created)

******************************************************************************/
#ifndef _EVENTTRIGGERS_H
#define _EVENTTRIGGERS_H

// resource header file
#include "resource.h"

#define CLEAN_EXIT 0
#define DIRTY_EXIT 1
#define SINGLE_SLASH L"\\"
#define DOUBLE_SLASH L"\\\\"
#define MIN_MEMORY_REQUIRED  255;


       
//
// formats ( used in show results )

// command line options and their indexes in the array

#define MAX_COMMANDLINE_OPTION  5 // Maximum Command Line  List

//#define ET_RES_STRINGS MAX_RES_STRING
//#define ET_RES_BUF_SIZE MAX_RES_STRING


#define ID_HELP          0
#define ID_CREATE        1
#define ID_DELETE        2
#define ID_QUERY         3
#define ID_DEFAULT       4
class CEventTriggers
{
public: // constructure and destructure.
     CEventTriggers();
    ~CEventTriggers();
// data memebers
private:
    LPTSTR m_pszServerNameToShow;
    BOOL m_bNeedDisconnect;
    
    // Array to store command line options
    TCMDPARSER2 cmdOptions[MAX_COMMANDLINE_OPTION]; 
    TARRAY m_arrTemp;
public:

   // functions
private:
    void PrepareCMDStruct();

public:
    void ShowQueryUsage();
    void ShowDeleteUsage();
    void ShowCreateUsage();
    BOOL IsQuery();
    BOOL IsDelete();
    BOOL IsUsage();
    BOOL IsCreate();
    BOOL GetNeedPassword();
    void ShowMainUsage();
    BOOL ProcessOption( IN DWORD argc, IN LPCTSTR argv[]);
    void UsageMain();
    void Initialize();
private:
    BOOL    m_bNeedPassword;
    BOOL    m_bUsage;
    BOOL    m_bCreate;
    BOOL    m_bDelete;
    BOOL    m_bQuery;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\resource.h ===
#define IDS_OPTION_HELP                 1
#define IDS_OPTION_CREATE               2
#define IDS_OPTION_DELETE               3
#define IDS_OPTION_QUERY                4
#define IDS_OPTION_SERVER               5
#define IDS_OPTION_USERNAME             6
#define IDS_OPTION_PASSWARD             7
#define IDS_OPTION_TRIGGERNAME          8
#define IDS_OPTION_LOGNAME              9
#define IDS_OPTION_ID                   10
#define IDS_OPTION_TYPE                 11
#define IDS_OPTION_SOURCE               12
#define IDS_OPTION_DESCRIPTION          13
#define IDS_OPTION_FORMAT               14
#define IDS_OPTION_NOHEADER             15
#define IDS_QUERY_DEFAULT               16
#define IDS_OPTION_VERBOSE              17
#define IDS_LOCAL_MAND_OPTIONS          20
#define IDS_LOCAL_FORMAT_STRING         21
#define IDS_QUERY_TYPE                  27
#define IDS_QUERY_ID                    28
#define IDS_QUERY_TRIGGERNAME           29
#define IDS_QUERY_LOGNAME               30
#define IDS_QUERY_SOURCENAME            31
#define IDS_QUERY_AND                   32
#define IDS_QUERY_EQ                    34

#define IDS_HELP_M1                     40
#define IDS_HELP_M2                     41
#define IDS_HELP_M3                     42
#define IDS_HELP_M4                     43
#define IDS_HELP_M5                     44
#define IDS_HELP_M6                     45
#define IDS_HELP_M7                     46
#define IDS_HELP_M8                     47
#define IDS_HELP_M9                     48
#define IDS_HELP_M10                    49
#define IDS_HELP_M11                    50
#define IDS_HELP_M12                    51
#define IDS_HELP_M13                    52
#define IDS_HELP_END                    54

#define IDS_HELP_C1                     60
#define IDS_HELP_C2                     61
#define IDS_HELP_C3                     62
#define IDS_HELP_C4                     63
#define IDS_HELP_C5                     64
#define IDS_HELP_C6                     65
#define IDS_HELP_C7                     66
#define IDS_HELP_C8                     67
#define IDS_HELP_C9                     68
#define IDS_HELP_C10                    69
#define IDS_HELP_C11                    70
#define IDS_HELP_C12                    71
#define IDS_HELP_C13                    72
#define IDS_HELP_C14                    73
#define IDS_HELP_C15                    74
#define IDS_HELP_C16                    75
#define IDS_HELP_C17                    76
#define IDS_HELP_C18                    77
#define IDS_HELP_C19                    78
#define IDS_HELP_C20                    79
#define IDS_HELP_C21                    80
#define IDS_HELP_C22                    81
#define IDS_HELP_C23                    82
#define IDS_HELP_C24                    83
#define IDS_HELP_C25                    84
#define IDS_HELP_C26                    85
#define IDS_HELP_C27                    86
#define IDS_HELP_C28                    87
#define IDS_HELP_C29                    88
#define IDS_HELP_C30                    89
#define IDS_HELP_C31                    90
#define IDS_HELP_C32                    91
#define IDS_HELP_C33                    92
#define IDS_HELP_C34                    93
#define IDS_HELP_C35                    94
#define IDS_HELP_C36                    95
#define IDS_HELP_C37                    96
#define IDS_HELP_C38                    97
#define IDS_HELP_C39                    98
#define IDS_HELP_C40                    99
#define IDS_HELP_C41                    100
#define IDS_HELP_C42                    101
#define IDS_HELP_C43                    102
#define IDS_HELP_C44                    103
#define IDS_HELP_C45                    104
#define IDS_HELP_C46                    105
#define IDS_HELP_C47                    106
#define IDS_HELP_C48                    107
#define IDS_HELP_C49                    108
#define IDS_HELP_C50                    109
#define IDS_HELP_C51                    110
#define IDS_HELP_C52                    111
#define IDS_HELP_C53                    112
#define IDS_HELP_C54                    113
#define IDS_HELP_CREATE_END             114

#define IDS_HELP_D1                     120
#define IDS_HELP_D2                     121
#define IDS_HELP_D3                     122
#define IDS_HELP_D4                     123
#define IDS_HELP_D5                     124
#define IDS_HELP_D6                     125
#define IDS_HELP_D7                     126
#define IDS_HELP_D8                     127
#define IDS_HELP_D9                     128
#define IDS_HELP_D10                    129
#define IDS_HELP_D11                    130
#define IDS_HELP_D12                    131
#define IDS_HELP_D13                    132
#define IDS_HELP_D14                    133
#define IDS_HELP_D15                    134
#define IDS_HELP_D16                    135
#define IDS_HELP_D17                    136
#define IDS_HELP_D18                    137
#define IDS_HELP_DELETE_END             138

#define IDS_HELP_Q1                     140
#define IDS_HELP_Q2                     141
#define IDS_HELP_Q3                     142
#define IDS_HELP_Q4                     143
#define IDS_HELP_Q5                     144
#define IDS_HELP_Q6                     145
#define IDS_HELP_Q7                     146
#define IDS_HELP_Q8                     147
#define IDS_HELP_Q9                     148
#define IDS_HELP_Q10                    149
#define IDS_HELP_Q11                    150
#define IDS_HELP_Q12                    151
#define IDS_HELP_Q13                    152
#define IDS_HELP_Q14                    153
#define IDS_HELP_Q15                    154
#define IDS_HELP_Q16                    155
#define IDS_HELP_Q17                    156
#define IDS_HELP_Q18                    157
#define IDS_HELP_Q19                    158
#define IDS_HELP_Q20                    159
#define IDS_HELP_Q21                    160
#define IDS_HELP_Q22                    161
#define IDS_HELP_Q23                    162
#define IDS_HELP_Q24                    163
#define IDS_HELP_Q25                    164
#define IDS_HELP_QUERY_END              165

#define IDS_INCORRECT_SYNTAX            201
#define IDS_TYPE_PASSWARD               202
#define IDS_LAST_CHAR                   203
#define IDS_CREATE_SUCCESS              204
#define IDS_HOSTNAME                    205
#define IDS_TRIGGER_ID                  206
#define IDS_TRIGGER_NAME                207
#define IDS_TASK                        208
#define IDS_EVENT_QUERY                 209
#define IDS_DESCRIPTION                 210
#define IDS_WIDTH_HOSTNAME              212
#define IDS_WIDTH_TRIGGER_ID            213
#define IDS_WIDTH_TRIGGER_NAME          214
#define IDS_WIDTH_TASK                  215
#define IDS_WIDTH_EVENT_QUERY           216
#define IDS_WIDTH_DESCRIPTION           217
#define IDS_DELETE_SUCCESS              219
#define IDS_EVENTS_WITH                 220
#define IDS_DELETE_ERROR                221
#define IDS_USERNAME_REQUIRED           222
#define IDS_DUPLICATE_TRG_NAME          223
#define IDS_STRING_TABLE                225
#define IDS_STRING_CSV                  226
#define IDS_STRING_LIST                 227
#define IDS_TYPE_OPTIONS                228
#define IDS_FORMAT_OPTIONS              229
#define IDS_NO_EVENTID                  230
#define IDS_NO_EVENT_FOUNT              231
#define IDS_LOG_NOT_EXISTS              232
#define IDS_ID_VALUE_OUT_OF_RANGE       233
#define IDS_ID_TYPE_SOURCE              234
#define IDS_ID_SHOW_ERROR               235
#define IDS_ID_DEFAULT_MISSING          236
#define IDS_DEFAULT_VALUES_ONCE         237
#define IDS_CLASS_NOT_REG               238
#define IDS_FAILURE_AUDIT               239
#define IDS_SUCCESS_AUDIT               240
#define IDS_AUDIT_FAILURE               241
#define IDS_AUDIT_SUCCESS               242
#define IDS_ID_TRIG_NAME_MISSING        243
#define IDS_ACCESS_DENIED               244
#define IDS_INVALID_PARAMETER           245
#define IDS_OUTOF_MEMORY                246
#define IDS_ERROR_USERNAME_EMPTY        248
#define IDS_ERROR_SERVERNAME_EMPTY      249
#define IDS_INVALID_ID                  250
#define IDS_ID_TK_NAME_MISSING          251
#define IDS_ID_REQUIRED                 252
#define IDS_ID_NON_NUMERIC              253
#define IDS_HEADER_NOT_ALLOWED          254
#define IDS_ERROR_USERNAME_BUT_NOMACHINE 255
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME 256
#define IDS_COM_ERROR                    259
#define IDS_ERROR_COM_ERROR              260
#define IDS_ID_SOURCE_EMPTY              262
#define IDS_ID_DESC_EMPTY                263
#define IDS_ID_LOG_EMPTY                 264
#define IDS_ID_NA                        265
#define IDS_TYPE_HELP                    266
#define IDS_UTILITY_NAME                 267
#define IDS_ID_INVALID_TRIG_NAME         268
#define IDS_RUN_AS_USERNAME_REQUIRED     269
#define IDS_TASK_USERNAME                270
#define IDS_UNABLE_DELETE                271
#define IDS_ASK_PASSWORD                 272
#define IDS_WARNING_PASSWORD             273
#define IDS_ERROR_R_U_EMPTY              275
#define IDS_INVALID_R_U                  280
#define IDS_WARN_NULL_PASSWORD           283
#define IDS_INVALID_RANGE                284
#define IDS_NO_EVENTID_FOUND             285
#define IDS_SCHEDULER_NOT_RUNNING        286
#define IDS_RUNAS_USER_UNKNOWN           287
#define IDS_TRIGGER_ID_EXCCED_LIMIT      288
#define IDS_TRIGGER_CORRUPTED            289
#define IDS_E_REMOTE_INCOMPATIBLE        290
#define IDS_SERVICE_NOT_RUNNING          291
#define IDS_TRIGGER_ID_NON_ZERO          292
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\pch.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      pch.h
//
//  Abstract:
//
//      pre-compiled header declaration
//      files that has to be pre-compiled into .pch file
//
//  Author:
//
//    Akhil Gokhale (akhil.gokhale@wipro.com)
//
//  Revision History:
//
//    Akhil Gokhale (akhil.gokhale@wipro.com)
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once        // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//

   #include <nt.h>
   #include <ntrtl.h>
   #include <nturtl.h>
   #include <ntexapi.h>
   #include <security.h>
   #include <secExt.h>
//
// public Windows header files
//Wbemidl.h
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <ole2.h>
#include <mstask.h>
#include <msterr.h>
#include <mbctype.h>
#include <winperf.h>
#include <wbemidl.h>
#include <CHString.h>
#include <comdef.h>
#include <wbemtime.h>
#include <mstask.h>
//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <conio.h>
#include <tchar.h>
#include <wchar.h>
#include <crtdbg.h>
#include <strsafe.h>
//
// private Common header files
//
// Following define will link common functionality ver 2
#define CMDLINE_VERSION         200
#include "cmdlineres.h"
#include "cmdline.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\showerror.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    ShowError.h

Abstract:

  This module  contanins function definations required by ShowError.cpp

Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:


*******************************************************************************/

#ifndef SHOWERROR_H
#define SHOWERROR_H
class CShowError
{

public:
    LPCTSTR ShowReason();
    CShowError();
    CShowError(LONG lErrorNumber);
    virtual ~CShowError();

private:
    LONG m_lErrorNumber;
public:
    TCHAR m_szErrorMsg[(MAX_RES_STRING*2)+1];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\showerror.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

  ShowError.CPP

Abstract:

  This module  is intended to prepare  error messages.

Author:
  Akhil Gokhale 03-Oct.-2000 (Created it)

Revision History:

******************************************************************************/
#include "pch.h"
#include "ETCommon.h"
#include "ShowError.h"
#include "resource.h"

CShowError::CShowError()
/*++
 Routine Description:
  Class default constructor.

 Arguments:
      None
 Return Value:
      None

--*/
{
    m_lErrorNumber = 0;
}

CShowError::CShowError(
    IN LONG lErrorNumber
    )
/*++
 Routine Description:
  Class constructor.

 Arguments:
      IN lError?Number : Error Number
 Return Value:
      None

--*/
{
    m_lErrorNumber = lErrorNumber;
}

CShowError::~CShowError()
/*++
 Routine Description:
  Class default desctructor.

 Arguments:
      None
 Return Value:
      None

--*/
{

}

LPCTSTR CShowError::ShowReason()
/*++
 Routine Description:
  This function will return Text reason for given error code.

 Arguments:
      None
 Return Value:
      None

--*/
{

    WCHAR szTempStr[MAX_RES_STRING];
    BOOL bShowExtraMsg = TRUE;
    SecureZeroMemory(szTempStr,sizeof(WCHAR)*MAX_RES_STRING);
    DEBUG_INFO;
    switch(m_lErrorNumber )
    {
    case MK_E_SYNTAX:
    case E_OUTOFMEMORY:
        {
            StringCopy(m_szErrorMsg,GetReason(),
                       SIZE_OF_ARRAY(m_szErrorMsg));
            bShowExtraMsg = FALSE;
        }
        break;
    case IDS_USERNAME_REQUIRED:
        StringCopy(m_szErrorMsg,GetResString(IDS_USERNAME_REQUIRED),
                           SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ERROR_USERNAME_EMPTY:
        StringCopy(m_szErrorMsg,GetResString(IDS_ERROR_USERNAME_EMPTY),
                          SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ERROR_SERVERNAME_EMPTY:
        StringCopy(m_szErrorMsg,
                           GetResString(IDS_ERROR_SERVERNAME_EMPTY),
                            SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_TRIG_NAME_MISSING:
        StringCopy(m_szErrorMsg,GetResString(IDS_ID_TRIG_NAME_MISSING),
                           SIZE_OF_ARRAY(m_szErrorMsg));
        break;
    case IDS_ID_TYPE_SOURCE:
        StringCopy(m_szErrorMsg,GetResString(IDS_ID_TYPE_SOURCE),
                           SIZE_OF_ARRAY(m_szErrorMsg));
        break;
    case IDS_INVALID_ID:
        StringCopy(m_szErrorMsg,GetResString(IDS_INVALID_ID),
                           SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_TK_NAME_MISSING:
        StringCopy(m_szErrorMsg,GetResString(IDS_ID_TK_NAME_MISSING),
                          SIZE_OF_ARRAY(m_szErrorMsg));
        break;
    case IDS_ID_REQUIRED:
        StringCopy(m_szErrorMsg,GetResString(IDS_ID_REQUIRED),
                           SIZE_OF_ARRAY(m_szErrorMsg));
        break;
    case IDS_ID_NON_NUMERIC:
        StringCopy(m_szErrorMsg,GetResString(IDS_ID_NON_NUMERIC),
                           SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_HEADER_NOT_ALLOWED:
        StringCopy(m_szErrorMsg,GetResString(IDS_HEADER_NOT_ALLOWED),
                           SIZE_OF_ARRAY(m_szErrorMsg));
        break;
    case IDS_ERROR_USERNAME_BUT_NOMACHINE:
        StringCopy(m_szErrorMsg,
                              GetResString(IDS_ERROR_USERNAME_BUT_NOMACHINE),
                            SIZE_OF_ARRAY(m_szErrorMsg));
        bShowExtraMsg = FALSE;
        break;
    case IDS_ID_SOURCE_EMPTY:
       StringCopy(m_szErrorMsg,GetResString(IDS_ID_SOURCE_EMPTY),
                         SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_DESC_EMPTY:
       StringCopy(m_szErrorMsg,GetResString(IDS_ID_DESC_EMPTY),
                          SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_LOG_EMPTY:
        StringCopy(m_szErrorMsg,GetResString(IDS_ID_LOG_EMPTY),
                          SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_INVALID_TRIG_NAME:
        StringCopy(m_szErrorMsg,GetResString(IDS_ID_INVALID_TRIG_NAME),
                           SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_RUN_AS_USERNAME_REQUIRED:
        StringCopy(m_szErrorMsg,
                            GetResString(IDS_RUN_AS_USERNAME_REQUIRED),
                            SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_INVALID_RANGE:
        StringCopy(m_szErrorMsg,
                            GetResString(IDS_INVALID_RANGE),
                            SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;
        break;
     case IDS_ERROR_R_U_EMPTY:
        StringCopy(m_szErrorMsg,GetResString(IDS_ERROR_R_U_EMPTY),
                          SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;


    case IDS_TRIGGER_ID_NON_ZERO:

        StringCopy(m_szErrorMsg,GetResString(IDS_TRIGGER_ID_NON_ZERO),
                          SIZE_OF_ARRAY(m_szErrorMsg));
        g_dwOptionFlag = FALSE;

     default:
        break;
    }
    if(bShowExtraMsg)
    {
       WCHAR szStr[64]; 
       SecureZeroMemory(szStr, sizeof(WCHAR)*64);
       StringCopy(szStr,GetResString(IDS_UTILITY_NAME),SIZE_OF_ARRAY(szStr));

        switch(g_dwOptionFlag)
        {

            case 0:
                StringCopy(szTempStr,L"",SIZE_OF_ARRAY(szTempStr));
                break;
            case 1:
                StringCchPrintfW(szTempStr,SIZE_OF_ARRAY(szTempStr),
                           GetResString(IDS_TYPE_HELP),szStr,szCreateOption);
                break;
            case 2:
                StringCchPrintfW(szTempStr,SIZE_OF_ARRAY(szTempStr),
                            GetResString(IDS_TYPE_HELP),szStr,szDeleteOption);
                break;
            case 3:
               StringCchPrintfW(szTempStr,SIZE_OF_ARRAY(szTempStr),
                               GetResString(IDS_TYPE_HELP),szStr,szQueryOption);
                break;
            default:
                break;
        }
    }
    StringConcat(m_szErrorMsg,szTempStr,SIZE_OF_ARRAY(m_szErrorMsg));
    DEBUG_INFO;
    return m_szErrorMsg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\dmfon.h ===
/***    dmfon.h - DMF (Distribution Media Format -- 1.7M 3.5") support
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      13-May-1994 bens    Initial version
 */


/***    EnableDMFSupport - Enable DMF support on pre-Chicago DOS systems
 *
 *  Entry:
 *      None:
 *
 *  Exit:
 *      INT 13h vector hooked with code to ensure DOS and BIOS read
 *          DMF disks correctly.
 *      PSP:savedINT22 hooked so that we can *unhook* our INT13 hook
 *          when the calling program exits.
 */
void far EnableDMFSupport(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\wmi.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      WMI.h
//
//  Abstract:
//
//      Common functionality for WMI
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )    \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \
    1

#define SAFE_EXECUTE( statement )               \
    hr = statement;     \
    if ( FAILED( hr ) ) \
    {   \
        _com_issue_error( hr ); \
    }   \
    1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2     L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT   L"root\\default"

#define WMI_CLAUSE_AND          L"AND"
#define WMI_CLAUSE_OR           L"OR"
#define WMI_CLAUSE_WHERE        L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem   L"Win32_OperatingSystem"

#define WMI_REGISTRY                    L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE      L"GetStringValue"
#define WMI_REGISTRY_M_DWORDVALUE       L"GetDwordValue"

#define WMI_REGISTRY_IN_HDEFKEY         L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY          L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME       L"sValueName"
#define WMI_REGISTRY_OUT_VALUE          L"sValue"
#define WMI_REGISTRY_OUT_VALUE_DWORD    L"uValue"
#define WMI_REGISTRY_OUT_RETURNVALUE    L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT               2147483648
#define WMI_HKEY_CURRENT_USER               2147483649
#define WMI_HKEY_LOCAL_MACHINE              2147483650
#define WMI_HKEY_USERS                      2147483651
#define WMI_HKEY_CURRENT_CONFIG             2147482652

// messages
// #define ERROR_COM_ERROR                  GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator,
                 IWbemServices** ppServices,
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword,
                 COAUTHIDENTITY** ppAuthIdentity,
                 BOOL bCheckWithNullPwd = FALSE,
                 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2,
                 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL, IWbemContext* pWbemContext = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator,
                   IWbemServices** ppServices,
                   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword,
                   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE,
                   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL, 
                   DWORD dwPasswordLen = 0, IWbemContext* pWbemContext = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject,
                     LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,
                  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  BOOL& dwValue, BOOL bDefault = FALSE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey,
                       LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName,
                       CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices,
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName,
                       LPCWSTR pwszValueName, DWORD& dwValue, DWORD dwDefault = 0 );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, CHString& strValue,
                                VARTYPE vartype );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex,
                                IWbemClassObject **pScriptObject, VARTYPE vartype );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//
// Arguments:
//
// Return Value:
//
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
    WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\asrt.c ===
/***    asrt.c - Assertion Manager
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      10-Aug-1993 bens    Initial version
 *      11-Aug-1993 bens    Lift code from 1988 PSCHAR.EXE
 *      12-Aug-1993 bens    Improve documentation, move messages to asrt.msg
 *      14-Aug-1993 bens    Add assertion flags, query calls
 *
 *  Functions available in ASSERT build:
 *      AssertRegisterFunc - Register assertion failure call back function
 *      AsrtCheck          - Check that parameter is TRUE
 *      AsrtStruct         - Check that pointer points to specified structure
 *      AssertForce        - Force an assertion failure
 */

#include "types.h"
#include "asrt.h"

#ifdef ASSERT   // Must be after asrt.h!

#include "asrt.msg"


void doFailure(char *pszMsg, char *pszFile, int iLine);

STATIC PFNASSERTFAILURE  pfnafClient=NULL;  // Assertion call back function
STATIC ASSERTFLAGS       asfClient=asfNONE; // Assertion flags


/***    AssertRegisterFunc - Register assertion failure call back function
 *
 *  NOTE: See asrt.h for entry/exit conditions.
 */
void AssertRegisterFunc(PFNASSERTFAILURE pfnaf)
{
    pfnafClient = pfnaf;    // Store for future use
}


/***    AssertGetFunc - Get current assertion failure call back function
 *
 *  NOTE: See asrt.h for entry/exit conditions.
 */
PFNASSERTFAILURE AssertGetFunc(void)
{
    return pfnafClient;
}


/***    AssertSetFlags - Set special assertion control flags
 *
 *  NOTE: See asrt.h for entry/exit conditions.
 */
void AssertSetFlags(ASSERTFLAGS asf)
{
    asfClient = asf;
}


/***    AssertGetFlags - Get special assertion control flags
 *
 *  NOTE: See asrt.h for entry/exit conditions.
 */
ASSERTFLAGS  AssertGetFlags(void)
{
    return asfClient;
}


/***    AsrtCheck - Check assertion that argument is TRUE
 *
 *  Entry:
 *      f       - Boolean value to check
 *      pszFile - name of source file
 *      iLine   - source line number
 *
 *  Exit-Success:
 *      Returns; f was TRUE
 *
 *  Exit-Failure:
 *      Calls assertion failure callback function; f was false.
 */
void AsrtCheck(BOOL f, char *pszFile, int iLine)
{
    if (!f) {
        doFailure(pszASRTERR_FALSE,pszFile,iLine); // Inform client
        // Client returned, ignore error!
    }
}


/***    AsrtStruct - Check assertion that pointer is of correct type
 *
 *  Entry:
 *      pv      - Pointer to structure
 *      sig     - Expected signature
 *      pszFile - name of source file
 *      iLine   - source line number
 *
 *  Exit-Success:
 *      Returns; pv != NULL, and pv->sig == sig.
 *
 *  Exit-Failure:
 *      Calls assertion failure callback function; pv was bad.
 */
void AsrtStruct(void *pv, SIGNATURE sig, char *pszFile, int iLine)
{
    if (pv == NULL) {
        doFailure(pszASRTERR_NULL_POINTER,pszFile,iLine); // Inform client
        // Client returned, ignore error!
    }
    else if (*((PSIGNATURE)pv) != sig) {
        (*pfnafClient)(pszASRTERR_SIGNATURE_BAD,pszFile,iLine);// Inform client
        // Client returned, ignore error!
    }
}


/***    AssertForce - Force an assertion failure
 *
 *  NOTE: See asrt.h for entry/exit conditions.
 */
void AssertForce(char *pszMsg, char *pszFile, int iLine)
{
    doFailure(pszMsg,pszFile,iLine);   // Inform client
    // Client returned, ignore error!
}


/***    AssertErrPath - Report an internal error path
 *
 *  NOTE: See asrt.h for entry/exit conditions.
 */
void AssertErrPath(char *pszMsg, char *pszFile, int iLine)
{
    //** Only assert if we are not skipping error path assertions
    if (!(asfClient & asfSKIP_ERROR_PATH_ASSERTS)) {
        doFailure(pszMsg,pszFile,iLine);   // Inform client
    }
    // Client returned, ignore error!
}


/***    doFailure - Call registered call back function
 *
 *  Entry:
 *      pszMsg  - Message to display
 *      pszFile - Name of source file
 *      iLine   - Source line number
 *
 *  Exit-Success:
 *      Returns; client wanted to ignore assertion.
 *
 *  Exit-Failure:
 *      Does not return.
 */
void doFailure(char *pszMsg, char *pszFile, int iLine)
{
    if (pfnafClient == NULL) {
        //** Call back not registered!
        //
        // We don't have any output mechanism of our own, since we
        // are platform-independent.  So, just spin in a loop and
        // hope the developer can break in with a debugger to see
        // what is wrong!

        for (;;)
            ;
    }
    else {  //** Call back registered
        (*pfnafClient)(pszMsg,pszFile,iLine);   // Inform client
    }
}

#endif // !ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\eventtriggers\wmi.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    WMI.cpp

Abstract:

    Common functionlity for dealing with WMI.

Author:

    Wipro Technologies

Revision History:

    22-Dec-2000 : Created It.
    24-Apr-2001 : Closing the review comments given by client.

*********************************************************************************************/

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD              GetResString( IDS_STR_INPUT_PASSWORD )
#define INPUT_PASSWORD_LEN          256
// error constants
#define E_SERVER_NOTFOUND           0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface,
                              DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface,
                              LPCWSTR pwszUser,
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword,
                                      LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices,
                          LPCWSTR pwszMethod, DWORD dwHDefKey,
                          LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );


BOOL
IsValidUserEx(
    LPCWSTR pwszUser
    )
/*++

Routine Description:

    Checks wether the User name is a valid one or not

Arguments:

    [in] LPCWSTR    :   String containing the user name

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    CHString strUser;
    LONG lPos = 0;

    if ( ( NULL == pwszUser ) || ( 0 == StringLength( pwszUser, 0 ) ) )
    {
        return TRUE;
    }

    try
    {
        // get user into local memory
        strUser = pwszUser;

        // user name should not be just '\'
        if ( strUser.CompareNoCase( L"\\" ) == 0 )
        {
            return FALSE;
        }

        // user name should not contain invalid characters
        if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
        {
            return FALSE;
        }

        // SPECIAL CHECK
        // check for multiple '\' characters in the user name
        lPos = strUser.Find( L'\\' );
        if ( -1 != lPos )
        {
            // '\' character exists in the user name
            // strip off the user info upto first '\' character
            // check for one more '\' in the remaining string
            // if it exists, invalid user
            strUser = strUser.Mid( lPos + 1 );
            lPos = strUser.Find( L'\\' );
            if ( -1 != lPos )
            {
                return FALSE;
            }
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // user name is valid
    return TRUE;
}


BOOL
IsValidServerEx(
    LPCWSTR pwszServer,
    BOOL& bLocalSystem
    )
/*++

Routine Description:

    Checks wether the Server name is a valid one or not

Arguments:

    [in]  LPCWSTR   :   String containing the user name
    [out] BOOL      :   Is set to TRUE if the local system is being queried.

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    CHString strTemp;

    // Validate input arguments.
    if ( ( NULL == pwszServer ) || ( 0 == StringLength( pwszServer, 0 ) ) )
    {
       bLocalSystem = TRUE;
       return TRUE;
    }

    try
    {
        // kick-off
        bLocalSystem = FALSE;

        if( IsNumeric( pwszServer, 10, FALSE ) == TRUE )
        {
            return FALSE;
        }

        // get a local copy
        strTemp = pwszServer;

        // remove the forward slashes (UNC) if exist in the begining of the server name
        if ( IsUNCFormat( strTemp ) == TRUE )
        {
            strTemp = strTemp.Mid( 2 );
            if ( strTemp.GetLength() == 0 )
            {
                return FALSE;
            }
        }

        if ( strTemp.FindOneOf( L"`~!@#$^&*()+=[]{}|\\<>,?/\"':;" ) != -1 )
        {
            return FALSE;
        }

        // now check if any '\' character appears in the server name. If so error
        if ( strTemp.Find( L'\\' ) != -1 )
        {
            return FALSE;
        }

        // now check if server name is '.' only which represent local system in WMI
        // else determine whether this is a local system or not
        if ( strTemp.CompareNoCase( L"." ) == 0 )
        {
            bLocalSystem = TRUE;
        }
        else
        {
            bLocalSystem = IsLocalSystem( strTemp );
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // inform that server name is valid
    return TRUE;
}


BOOL
InitializeCom(
    IWbemLocator** ppLocator
    )
/*++
Routine Description:

    Initializes the COM library

Arguments:

    [in] IWbemLocator   :   pointer to the IWbemLocator

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;

    // clear the error
    SetLastError( WBEM_S_NO_ERROR );

    try
    {
        // Validate input arguments.
        if( ( NULL == ppLocator ) ||
            ( NULL != *ppLocator ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // initialize the COM library
        SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED ) );

        // initialize the security
        SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

        // create the locator and get the pointer to the interface of IWbemLocator
        SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

        // initialization successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the WMI error
        WMISaveError( e );
        // Error is returned. Release any interface pointers.
        SAFE_RELEASE( *ppLocator );
    }

    // return the result;
    return bResult;
}


BOOL
ConnectWmi(
    IWbemLocator* pLocator,
    IWbemServices** ppServices,
    LPCWSTR pwszServer,
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    COAUTHIDENTITY** ppAuthIdentity,
    BOOL bCheckWithNullPwd,
    LPCWSTR pwszNamespace,
    HRESULT* phr,
    BOOL* pbLocalSystem,
    IWbemContext* pWbemContext
    )
/*++

Routine Description:

    This function makes a connection to WMI.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;
    _bstr_t bstrServer;
    _bstr_t bstrNamespace;
    _bstr_t bstrUser, bstrPassword;

    // clear the error
    SetLastError( WBEM_S_NO_ERROR );

    // check whether locator object exists or not
    // if not exists, return
    if ( ( NULL == pLocator ) ||
         ( NULL == ppServices ) ||
         ( NULL != *ppServices ) ||
         ( NULL == pwszNamespace ) )
    {
        if ( NULL != phr )
        {
            *phr = WBEM_E_INVALID_PARAMETER;
        }
        // return failure
        return FALSE;
    }

    // kick-off
    if ( NULL != pbLocalSystem )
    {
        *pbLocalSystem = FALSE;
    }

    // ...
    if ( NULL != phr )
    {
        *phr = WBEM_S_NO_ERROR;
    }

    try
    {

        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // validate the server name
        // NOTE: The error being raised in custom define for '0x800706ba' value
        //       The message that will be displayed in "The RPC server is unavailable."
        if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
        {
            _com_issue_error( E_SERVER_NOTFOUND );
        }

        // validate the user name
        if ( IsValidUserEx( pwszUser ) == FALSE )
        {
            _com_issue_error( ERROR_NO_SUCH_USER );
        }

        // prepare namespace
        bstrNamespace = pwszNamespace;              // name space
        if ( ( NULL != pwszServer ) && ( FALSE == bLocalSystem ) )
        {
            // get the server name
            bstrServer = pwszServer;

            // prepare the namespace
            // NOTE: check for the UNC naming format of the server and do
            if ( IsUNCFormat( pwszServer ) == TRUE )
            {
                bstrNamespace = bstrServer + L"\\" + pwszNamespace;
            }
            else
            {
                bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
            }

            // user credentials
            if ( ( NULL != pwszUser ) && ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                // copy the user name
                bstrUser = pwszUser;

                // if password is empty string and if we need to check with
                // null password, then do not set the password and try
                bstrPassword = pwszPassword;
                if ( ( TRUE == bCheckWithNullPwd ) && ( 0 == bstrPassword.length() ) )
                {
                    bstrPassword = (LPWSTR) NULL;
                }
            }
        }
        else
        {    // Display warning message, credentials not required for local system.
            if( ( TRUE == bLocalSystem ) && ( NULL != pwszUser ) && 
                ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                 // got the credentials for the local system
                 if ( NULL != phr )
                 {
                     *phr = WBEM_E_LOCAL_CREDENTIALS;
                 }
            }
        }

        // connect to the remote system's WMI
        // there is a twist here ...
        // do not trap the ConnectServer function failure into exception
        // instead handle that action manually
        // by default try the ConnectServer function as the information which we have
        // in our hands at this point. If the ConnectServer is failed,
        // check whether password variable has any contents are not ... if no contents
        // check with "" (empty) password ... this might pass in this situation ..
        // if this call is also failed ... nothing is there that we can do ... throw the exception
        hr = pLocator->ConnectServer( bstrNamespace,
            bstrUser, bstrPassword, 0L, 0L, NULL, pWbemContext, ppServices );
        if ( FAILED( hr ) )
        {
            //
            // special case ...

            // check whether password exists or not
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'
            if ( hr == E_ACCESSDENIED )
            {
                // check if we tried to connect to the system using null password
                // if so, then try connecting to the remote system with empty string
                if ( bCheckWithNullPwd == TRUE &&
                     bstrUser.length() != 0 && bstrPassword.length() == 0 )
                {
                    // now invoke with ...
                    hr = pLocator->ConnectServer( bstrNamespace,
                        bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, pWbemContext, ppServices );
                }
            }
            else
            {
                if ( WBEM_E_LOCAL_CREDENTIALS == hr )
                {
                    // credentials were passed to the local system.
                    // So ignore the credentials and try to reconnect
                    bLocalSystem = TRUE;
                    bstrUser = (LPWSTR) NULL;
                    bstrPassword = (LPWSTR) NULL;
                    bstrNamespace = pwszNamespace;              // name space
                    hr = pLocator->ConnectServer( bstrNamespace,
                        NULL, NULL, 0L, 0L, NULL, pWbemContext, ppServices );
                }
            }

            // now check the result again .. if failed .. ummmm..
            if ( FAILED( hr ) )
            {
                _com_issue_error( hr );
            }
            else
            {
                bstrPassword = L"";
            }
        }

        // set the security at the interface level also
        SAFE_EXECUTE( SetInterfaceSecurity( *ppServices,
            bstrUser, bstrPassword, ppAuthIdentity ) );

        // ...
        if ( NULL != pbLocalSystem )
        {
            *pbLocalSystem = bLocalSystem;
        }

        // connection to WMI is successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the error
        WMISaveError( e );

        // save the hr value if needed by the caller
        if ( NULL != phr )
        {
            *phr = e.Error();
        }
        SAFE_RELEASE( *ppServices );
        bResult = FALSE;
    }

    // return the result
    return bResult;
}


BOOL
ConnectWmiEx(
    IWbemLocator* pLocator,
    IWbemServices** ppServices,
    LPCWSTR pwszServer,
    CHString& strUserName,
    CHString& strPassword,
    COAUTHIDENTITY** ppAuthIdentity,
    BOOL bNeedPassword,
    LPCWSTR pwszNamespace,
    BOOL* pbLocalSystem,
    DWORD dwPasswordLen,
    IWbemContext* pWbemContext
    )
/*++

Routine Description:

    This function is a wrapper function for the ConnectWmi function.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system
    [ in ] DWORD                :   Contains maximum password buffer length.

Return Value:

    TRUE on success
    FALSE on failure

NOTE: 'dwPasswordLen' WILL BE TAKEN AS 'MAX_STRING_LENGTH' IF NOT SPECIFIED.
      IT IS USER RESPOSIBILITY TO SET THIS PARAMETER TO LIMITING VALUE.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszPassword = NULL;
    CHString strBuffer;

    // clear the error .. if any
    SetLastError( WBEM_S_NO_ERROR );

    try
    {
        // sometime users want the utility to prompt for the password
        // check what user wants the utility to do
        if ( ( TRUE == bNeedPassword ) &&
             ( 0 == strPassword.Compare( L"*" ) ) )
        {
            // user wants the utility to prompt for the password
            // so skip this part and let the flow directly jump the password acceptance part
        }
        else
        {
            // try to establish connection to the remote system with the credentials supplied
            if ( 0 == strUserName.GetLength() )
            {
                // user name is empty
                // so, it is obvious that password will also be empty
                // even if password is specified, we have to ignore that
                bResult = ConnectWmi( pLocator, ppServices,
                    pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem, pWbemContext );
            }
            else
            {
                // credentials were supplied
                // but password might not be specified ... so check and act accordingly
                LPCWSTR pwszTemp = NULL;
                BOOL bCheckWithNull = TRUE;
                if ( bNeedPassword == FALSE )
                {
                    pwszTemp = strPassword;
                    bCheckWithNull = FALSE;
                }

                // ...
                bResult = ConnectWmi( pLocator, ppServices, pwszServer,
                    strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem, pWbemContext );
            }

            SetLastError( hr );
            // check the result ... if successful in establishing connection ... return
            if ( TRUE == bResult )
            {
                return TRUE;
            }

            // now check the kind of error occurred
            switch( hr )
            {
            case E_ACCESSDENIED:
                SetLastError( hr );
                break;

            case WBEM_E_LOCAL_CREDENTIALS:
                SetLastError( hr );
                // needs to do special processing
                break;

            case WBEM_E_ACCESS_DENIED:
            default:
                // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
                //       this error code says that user with the current credentials is not
                //       having access permisions to the 'namespace'
                WMISaveError( hr );
                return FALSE;       // no use of accepting the password .. return failure
                break;
            }

            // if failed in establishing connection to the remote terminal
            // even if the password is specifed, then there is nothing to do ... simply return failure
            if ( bNeedPassword == FALSE )
            {
                return FALSE;
            }
        }

        // check whether user name is specified or not
        // if not, get the local system's current user name under whose credentials, the process
        // is running
        if ( 0 == strUserName.GetLength() )
        {
            // sub-local variables
            LPWSTR pwszUserName = NULL;
            DWORD dwUserLength = 0;    // Username buffer length.
            // Retrieve the buffer length need to store username.
            GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength );

            // get the required buffer
            pwszUserName = strUserName.GetBufferSetLength( dwUserLength );

            if ( FALSE == GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) )
            {
                // error occured while trying to get the current user info
                SaveLastError();
                return FALSE;
            }
            // No need to call 'ReleaseBuffer' since only sufficient memory is allocated.
        }

        // get the required buffer
        if( 0 == dwPasswordLen )
        {
             dwPasswordLen = INPUT_PASSWORD_LEN;
        }
        pwszPassword = strPassword.GetBufferSetLength( dwPasswordLen );

        // accept the password from the user
        strBuffer.Format( INPUT_PASSWORD, strUserName );
        WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ),
            strBuffer, strBuffer.GetLength(), &dwSize, NULL );

        bResult = GetPassword( pwszPassword, dwPasswordLen );
        if ( TRUE != bResult )
        {
            return FALSE;
        }

        // release the buffer allocated for password
        strPassword.ReleaseBuffer();

        // now again try to establish the connection using the currently
        // supplied credentials
        bResult = ConnectWmi( pLocator, ppServices, pwszServer,
            strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace,
            NULL, pbLocalSystem, pWbemContext );
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return the failure
    return bResult;
}


HRESULT
GetSecurityArguments(
    IUnknown* pInterface,
    DWORD& dwAuthorization,
    DWORD& dwAuthentication
    )
/*++

Routine Description:

    This function gets the values for the security services.

Arguments:

    [in] IUnknown   :   pointer to the IUnkown interface
    [out] DWORD     :   to hold the authentication service value
    [out] DWORD     :   to hold the authorization service value

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
    IClientSecurity* pClientSecurity = NULL;

    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    // try to get the client security services values if possible
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
    if ( SUCCEEDED( hr ) )
    {
        // got the client security interface
        // now try to get the security services values
        hr = pClientSecurity->QueryBlanket( pInterface,
            &dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
        if ( SUCCEEDED( hr ) )
        {
            // we've got the values from the interface
            dwAuthentication = dwAuthnSvc;
            dwAuthorization = dwAuthzSvc;
        }

        // release the client security interface
        SAFE_RELEASE( pClientSecurity );
    }

    // return always success
    return hr;
}


HRESULT
SetInterfaceSecurity(
    IUnknown* pInterface,
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    COAUTHIDENTITY** ppAuthIdentity
    )
/*++

Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] LPCWSTR            :   string containing the User name
    [in] LPCWSTR            :   string containing the password
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    CHString strUser;
    CHString strDomain;
    LPCWSTR pwszUserArg = NULL;
    LPCWSTR pwszDomainArg = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    try
    {
        // check the interface
        if ( NULL == pInterface )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // check the authentity strcuture ... if authentity structure is already ready
        // simply invoke the 2nd version of SetInterfaceSecurity
        if ( NULL != *ppAuthIdentity )
        {
            return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
        }

        // If we are doing trivial case, just pass in a null authenication structure
        // for which the current logged in user's credentials will be considered
        if ( ( NULL == pwszUser ) &&
             ( NULL == pwszPassword ) )
        {
            // set the security
            hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization,
                NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

            // return the result
            return hr;
        }

        // if authority srtucture is NULL then no need to proceed
        if ( NULL == ppAuthIdentity )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // check if authenication info is available or not ...
        // initialize the security authenication information ... UNICODE VERSION STRUCTURE
        if ( NULL == *ppAuthIdentity )
        {
            // parse and find out if the user name contains the domain name
            // if contains, extract the domain value from it
            LONG lPos = -1;
            strDomain = L"";
            strUser = pwszUser;
            if ( -1 != ( lPos = strUser.Find( L'\\' ) ) )
            {
                // user name contains domain name ... domain\user format
                strDomain = strUser.Left( lPos );
                strUser = strUser.Mid( lPos + 1 );
            }
            else 
            {
                if ( -1 != ( lPos = strUser.Find( L'@' ) ) )
                {
                    // NEED TO IMPLEMENT THIS ... IF NEEDED
                    // This implementation needs to be done if WMI does not support
                    // UPN name formats directly and if we have to split the
                    // name(user@domain)
                }
                else
                {
                    // server itself is the domain
                    // NOTE: NEED TO DO SOME R & D ON BELOW COMMENTED LINE
                    // strDomain = pwszServer;
                }
             }

            // get the domain info if it exists only
            if ( 0 != strDomain.GetLength() )
            {
                pwszDomainArg = strDomain;
            }

            // get the user info if it exists only
            if ( 0 != strUser.GetLength() )
            {
                pwszUserArg = strUser;
            }

            hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
            if ( FAILED(hr) )
            {
              return hr;
            }
        }

        // set the security information to the interface
        hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );
    }
    catch( CHeap_Exception )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    // return the result
    return hr;
}


HRESULT
SetInterfaceSecurity(
    IUnknown* pInterface,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    // 'pAuthIdentity' can be NULL or not, so need to check.
    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // get the current security argument value
    hr = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}


HRESULT
WINAPI SetProxyBlanket(
    IUnknown* pInterface,
    DWORD dwAuthnSvc,
    DWORD dwAuthzSvc,
    LPWSTR pwszPrincipal,
    DWORD dwAuthLevel,
    DWORD dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
    DWORD dwCapabilities
    )
/*++

Routine Description:

    This function sets the authentication information (the security blanket)
    that will be used to make calls.

Arguments:

    [in] IUnknown                       :   pointer to the IUnkown interface
    [in] DWORD                          :   contains the authentication service to use
    [in] DWORD                          :   contains the authorization service to use
    [in] LPWSTR                         :   the server principal name to use
    [in] DWORD                          :   contains the authentication level to use
    [in] DWORD                          :   contains the impersonation level to use
    [in] RPC_AUTH_IDENTITY_HANDLE       :   pointer to the identity of the client
    [in] DWORD                          :   contains the capability flags

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

    // Validate input arguments.
    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if( ( NULL == pInterface ) ||
        ( ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) ) &&
          ( NULL != pAuthInfo ) )
      )
    {
        return( WBEM_E_INVALID_PARAMETER );
    }

    // get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( FAILED(hr) )
    {
        return hr;
    }

    // now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( FAILED(hr) )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    // now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pUnknown );
        SAFE_RELEASE( pClientSecurity );
        return hr;
    }

    // release the security interface
    SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( NULL != pAuthInfo )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( SUCCEEDED(hr) )
        {
            // set security authentication
            hr = pClientSecurity->SetBlanket( pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

            // release
            SAFE_RELEASE( pClientSecurity );
        }
        else
        {
            if ( E_NOINTERFACE == hr )
            {
                hr = S_OK;      // ignore no interface errors
            }
        }
    }

    // release the IUnknown
    SAFE_RELEASE( pUnknown );

    // return the result
    return hr;
}


HRESULT
WINAPI WbemAllocAuthIdentity(
    LPCWSTR pwszUser,
    LPCWSTR pwszPassword,
    LPCWSTR pwszDomain,
    COAUTHIDENTITY** ppAuthIdent
    )
/*++

Routine Description:

    This function allocates memory for the AUTHIDENTITY structure.

Arguments:

    [in] LPCWSTR            :   string containing the user name
    [in] LPCWSTR            :   string containing the password
    [in] LPCWSTR            :   string containing the domain name
    [out] COAUTHIDENTITY    :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    HRESULT

NOTE: 'ppAuthIdent' should be freed by calling 'WbemFreeAuthIdentity' by the user after
      their work is done.

--*/
{
    // local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

    // validate the input parameter
    if ( NULL == ppAuthIdent )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // init with 0's
    SecureZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

    //
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong

    // user
    if ( NULL != pwszUser )
    {
        // allocate memory for user
        LONG lLength = StringLength( pwszUser, 0 );
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->User )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        StringCopy( pAuthIdent->User, pwszUser, (lLength + 1) );
    }

    // domain
    if ( NULL != pwszDomain )
    {
        // allocate memory for domain
        LONG lLength = StringLength( pwszDomain, 0 );
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Domain )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        StringCopy( pAuthIdent->Domain, pwszDomain, (lLength + 1) );
    }

    // passsord
    if ( NULL != pwszPassword )
    {
        // allocate memory for passsord
        LONG lLength = StringLength( pwszPassword, 0 );
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Password )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        StringCopy( pAuthIdent->Password, pwszPassword, (lLength + 1) );
    }

    // type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
    *ppAuthIdent = pAuthIdent;

    // return result
    return S_OK;
}


VOID
WINAPI WbemFreeAuthIdentity(
    COAUTHIDENTITY** ppAuthIdentity
    )
/*++

Routine Description:

    This function releases the memory allocated for the AUTHIDENTITY structure.

Arguments:

    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    None

--*/
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
        // free the memory allocated for user
        if ( NULL != (*ppAuthIdentity)->User )
        {
            CoTaskMemFree( (*ppAuthIdentity)->User );
            (*ppAuthIdentity)->User = NULL;
        }

        // free the memory allocated for password
        if ( NULL != (*ppAuthIdentity)->Password )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Password );
            (*ppAuthIdentity)->Password = NULL;
        }

        // free the memory allocated for domain
        if ( NULL != (*ppAuthIdentity)->Domain )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Domain );
            (*ppAuthIdentity)->Domain = NULL;
        }

        // final the structure
        CoTaskMemFree( *ppAuthIdentity );
        *ppAuthIdentity = NULL;
    }
}


VOID
WMISaveError(
    HRESULT hrError
    )
/*++

Routine Description:

    This function saves the description of the last error returned by WMI

Arguments:

    HRESULT     :   The last return value from WMI

Return Value:

    NONE

--*/
{
    // local variables
    HRESULT hr = S_OK;
    IWbemStatusCodeText* pWbemStatus = NULL;
    _bstr_t bstrErrorString;

    try
    {
        // Set error to different value.
        if ( E_ACCESSDENIED == hrError )
        {
            // change the error message to "Logon failure: unknown user name or bad password."
            hrError = ERROR_LOGON_FAILURE;
        }

        //Set the reason to incompatible os when no class is registered on remote mechine
        if( 0x80040154 == hrError )
        {
            bstrErrorString = _bstr_t( GetResString(IDS_ERROR_REMOTE_INCOMPATIBLE) );
            SetReason( bstrErrorString );
            return;
        }
        else
        {   // Get error string.
            hr = CoCreateInstance( CLSID_WbemStatusCodeText,
                                   NULL, CLSCTX_INPROC_SERVER,
                                   IID_IWbemStatusCodeText,
                                   (LPVOID*) &pWbemStatus );
            if( SUCCEEDED( hr ) )
            {
                BSTR bstrString = NULL;
                // Get error string from error code.
                hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0,
                                                    &bstrString );
                if( NULL != bstrString )
                {
                    bstrErrorString = _bstr_t( bstrString );
                    SysFreeString( bstrString );
                }
                if( FAILED( hr ) )
                {
                    _com_issue_error( hrError );
                }
				SAFE_RELEASE(pWbemStatus);
            }
            else
            {
                _com_issue_error( hrError );
            }
        }
    }
    catch( _com_error& e )
    {   // We have got the error. Needs to handle carefully.
        LPWSTR lpwszGetString = NULL;
		SAFE_RELEASE(pWbemStatus);
        try
        {   // ErrorMessage() can throw an exception.
            DWORD dwLength = StringLength( e.ErrorMessage(), 0 ) + 5 ;
            lpwszGetString = ( LPWSTR )AllocateMemory( dwLength * sizeof( WCHAR ) );
            if( NULL != lpwszGetString )
            {
                StringCopy( lpwszGetString, e.ErrorMessage(), dwLength );
                StringConcat( lpwszGetString, L"\n", dwLength );
                SetReason( ( LPCWSTR )lpwszGetString );
                FreeMemory( (LPVOID*) &lpwszGetString );
            }
            else
            {   // Failed to know the exact error occured
                // due to insufficient memory.
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
            }
        }
        catch( ... )
        {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
        }
        return;
    }

    SetReason( (LPCWSTR) bstrErrorString );
    return;
}


HRESULT
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    _variant_t& varValue
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   property name
    [out] _variant_t            :   value of the property

Return Value:

    HRESULT

--*/
{
    // local variables
    HRESULT hr = S_OK;
    VARIANT vtValue;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // initialize the variant and then get the value of the specified property
        VariantInit( &vtValue );
        // Call 'Get' method to retireve the value from WMI.
        hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
        if ( FAILED( hr ) )
        {
            // Clear the variant variable
            VariantClear( &vtValue );
            // Return error.
            return hr;
        }

        // set the value
        varValue = vtValue;
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // Clear the variables.
    VariantClear( &vtValue );
    // Return.
    return hr;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    CHString& strValue,
    LPCWSTR pwszDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in string format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] CHString              :   variable to hold the retrieved property
    [in] LPCWSTR                :   string containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t var;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );
    strValue.Empty();

    try
    {
        // first copy the default value
        strValue = pwszDefault;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the property value
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // Get the value
        // If 'var' does not contain value of requested type
        // then default value is returned.
        if ( VT_BSTR == V_VT( &var ) )
        {
            strValue = (LPCWSTR) _bstr_t( var );
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    DWORD& dwValue,
    DWORD dwDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in dword format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] DWORD                 :   variable to hold the retrieved property
    [in] DWORD                  :   dword containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr;
    _variant_t var;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    try
    {
        // first set the defaul value
        dwValue = dwDefault;

        // check with object and property passed to the function are valid or not
        // if not, return failure
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the value of the property
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // get the process id from the variant
        switch( V_VT( &var ) )
        {
        case VT_I2:
            dwValue = V_I2( &var );
            break;
        case VT_I4:
            dwValue = V_I4( &var );
            break;
        case VT_UI2:
            dwValue = V_UI2( &var );
            break;
        case VT_UI4:
            dwValue = V_UI4( &var );
            break;
        case VT_INT:
            dwValue = V_INT( &var );
            break;
        case VT_UINT:
            dwValue = V_UINT( &var );
            break;
        default:
            // Requested type is not found.
            // If 'var' does not contain value of requested type
            // then default value is returned.
        break;
        };
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    BOOL& bValue,
    BOOL bDefault
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in bool format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] BOOL                  :   variable to hold the retrieved property
    [in] BOOL                   :   bool containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t var;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    try
    {
        // first set the default value
        bValue = bDefault;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the value of the property
        hr = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hr ) )
        {
            _com_issue_error( hr );
        }

        // Save value obtained.
        // If 'var' does not contain value of requested type
        // then default value is returned.
        if ( VT_BOOL == V_VT( &var ) )
        {
            bValue = var.boolVal;
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    ULONGLONG& ullValue
    )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in ulongulong format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] ULONGULONG            :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // Local variables
    CHString str;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );
    str.Empty();

    try
    {
        // first set the default value
        ullValue = 1;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }

        // get the value of the property
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) )
        { // Error is already set in 'PropertyGet' function.
            return FALSE;
        }

        // get the 64-bit value
        ullValue = _wtoi64( str );

        // Check for error condition.
        if( 0 == ullValue )
        {
            ullValue = 1;
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }
    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    WBEMTime& wbemtime )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in wbemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // local variables
    CHString str;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Clear method sets the time in the WBEMTime object to an invalid time.
    wbemtime.Clear();
    try
    {
        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }

        // get the value of the property
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) )
        {   // Error is already set in 'PropertyGet' function.
            return FALSE;
        }

        // convert into the time value
        wbemtime = _bstr_t( str );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    SYSTEMTIME& systime )
/*++

Routine Description:

    Gets the value of the property from the WMI class object in systemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // local variables
    CHString strTime;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // get the value of the property
        // 16010101000000.000000+000 is the default time
        if ( FALSE == PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) )
        {   // Error is already set.
            return FALSE;
        }

        // prepare the systemtime structure
        // yyyymmddHHMMSS.mmmmmmsUUU
        // NOTE: NO NEED CALL 'IsNumeric()' BEFORE 'AsLong'.
        // Left and MID methods can throw an exception.
        systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
        systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
        systime.wDayOfWeek = 0;
        systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
        systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
        systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
        systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
        systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    _variant_t& varValue
    )
/*++

Routine Description:

    Sets the value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] WBEMTime               :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    VARIANT var;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // put the value
        var = varValue;
        hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // return the result
    return hr;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    LPCWSTR pwszValue
    )
/*++

Routine Description:

    Sets the string value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] LPCWSTR                :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    _variant_t varValue;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) ||
         ( NULL == pwszValue ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = pwszValue;
        SAFE_EXECUTE( PropertyPut( pWmiObject, pwszProperty, varValue ) );
    }
    catch( _com_error& e )
    {
        hr = e.Error();
    }

    // return
    return hr;
}


HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCWSTR pwszProperty,
    DWORD dwValue
    )
/*++

Routine Description:

    Sets the dword value of the property to the WMI class object.

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] DWORD                  :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure

--*/
{
    // local variables
    _variant_t varValue;
    HRESULT hr = S_OK;

    // check the input value
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = ( LONG )dwValue;
        SAFE_EXECUTE( PropertyPut( pWmiObject, pwszProperty, varValue ) );
    }
    catch( _com_error& e )
    {
        return e.Error();
    }

    // return
    return S_OK;
}


HRESULT
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    LPCWSTR pwszMethod,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    _variant_t& varValue
    )
/*++

Routine Description:

    This function retrieves the value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] LPCWSTR                :   the name of the method to execute
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [in] _variant_t             :   variable holding the property value retrieved

Return Value:

    TRUE on success
    FALSE on failure

NOTE: Pass arguments of type mentioned in declaration of this function.
      EX: Don't pass 'CHString' argument if 'LPWSTR' is expected.
      Reason: 'CHString' can throw an exception of type 'CHEAP_EXCEPTION'
               which is not handled by this function.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;
    DWORD dwReturnValue = 0;
    IWbemClassObject* pClass = NULL;
    IWbemClassObject* pMethod = NULL;
    IWbemClassObject* pInParams = NULL;
    IWbemClassObject* pInParamsInstance = NULL;
    IWbemClassObject* pOutParamsInstance = NULL;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // check the input value
    if ( ( NULL == pWbemServices ) ||
         ( NULL == pwszMethod ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // NOTE: If SAFE_EXECUTE( pWbemServices->GetObject(
    //       _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
    //       is executed then,
    //       NO NEED TO CHECK FOR ( PCLASS == NULL ) SINCE IN ALL CASES
    //       OF ERROR THIS VARIABLE WILL BE NULL.

    try
    {
        // get the registry class object
        SAFE_EXECUTE( pWbemServices->GetObject(
            _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );

        // get the method reference required
        SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );

        // create the instance for the in parameters
        SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );

        // set the input values
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey ) );
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName ) );
        SAFE_EXECUTE(PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName ) );

        // now execute the method
        SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
            _bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
        if ( NULL == pOutParamsInstance )           // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // now check the return value of the method from the output params object
        bResult = PropertyGet( pOutParamsInstance,
            _bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
        if ( ( FALSE == bResult ) ||
             ( 0 != dwReturnValue ) )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // Comapre string and take appropriate action.
        if ( 0 == StringCompare( pwszMethod, WMI_REGISTRY_M_DWORDVALUE, TRUE, 0 ) )
        {
            SAFE_EXECUTE( PropertyGet( pOutParamsInstance,
                                       _bstr_t( WMI_REGISTRY_OUT_VALUE_DWORD ), varValue ) );
        }
        else
        {
            SAFE_EXECUTE( PropertyGet( pOutParamsInstance,
                                       _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue ) );
        }
    }
    catch( _com_error& e )
    {
        hr = e.Error();
		SAFE_RELEASE( pClass );
		SAFE_RELEASE( pMethod );
		SAFE_RELEASE( pInParams );
		SAFE_RELEASE( pInParamsInstance );
		SAFE_RELEASE( pOutParamsInstance );
    }

    // release the interfaces
    SAFE_RELEASE( pClass );
    SAFE_RELEASE( pMethod );
    SAFE_RELEASE( pInParams );
    SAFE_RELEASE( pInParamsInstance );
    SAFE_RELEASE( pOutParamsInstance );

    // return success
    return hr;
}


BOOL
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    CHString& strValue,
    LPCWSTR pwszDefault
    )
/*++

Routine Description:

    This function retrieves the string value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] CHString              :   variable holding the property value retrieved
    [in] LPCWSTR                :   the default value for this property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

      This function won't return values if they are obtained as reference
      from WMI.
      EX: 'VARTYPE' recieved is of type 'VT_BSTR | VT_BYREF' then FALSE is
           returned.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varValue;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Check the input
    if ( ( NULL == pWbemServices ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // Set the default value
        if ( NULL != pwszDefault )
        {
            strValue = pwszDefault;
        }

        // Get the value
        hr = RegQueryValueWMI( pWbemServices,
            WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // Get the value from the variant
        // Get the value
        if ( VT_BSTR == V_VT( &varValue ) )
        {
            strValue = (LPCWSTR)_bstr_t( varValue );
        }
        else
        {
            // Requested type is not found.
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {   // Exception throw by '_variant_t'.
        WMISaveError( e );
        return FALSE;
    }

    // return success
    return TRUE;
}


BOOL
RegQueryValueWMI(
    IWbemServices* pWbemServices,
    DWORD dwHDefKey,
    LPCWSTR pwszSubKeyName,
    LPCWSTR pwszValueName,
    DWORD& dwValue,
    DWORD dwDefault
    )
/*++

Routine Description:

    This function retrieves the dword value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] DWORD                 :   variable holding the property value retrieved
    [in] DWORD                  :   the default value for this property

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

      This function won't return values if they are obtained as reference
      from WMI.
      EX: 'VARTYPE' recieved is of type 'VT_I4 | VT_BYREF' then FALSE is
           returned.

--*/
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varValue;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Check the input.
    if ( ( NULL == pWbemServices ) ||
         ( NULL == pwszSubKeyName ) ||
         ( NULL == pwszValueName ) ||
         ( NULL == dwValue ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    try
    {
        // Set the default value.
        dwValue = dwDefault;

        // Get the value.
        hr = RegQueryValueWMI( pWbemServices, WMI_REGISTRY_M_DWORDVALUE, dwHDefKey,
                                pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            WMISaveError( hr );
            return FALSE;
        }

        // get the value from the variant
        switch( V_VT( &varValue ) )
        {
        case VT_I2:
            dwValue = V_I2( &varValue );
            break;
        case VT_I4:
            dwValue = V_I4( &varValue );
            break;
        case VT_UI2:
            dwValue = V_UI2( &varValue );
            break;
        case VT_UI4:
            dwValue = V_UI4( &varValue );
            break;
        case VT_INT:
            dwValue = V_INT( &varValue );
            break;
        case VT_UINT:
            dwValue = V_UINT( &varValue );
            break;
        default:
            // Requested type is not found.
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            return FALSE;
        }
    }
    catch( _com_error& e )
    {   // Exception thrown by _variant_t
        WMISaveError( e );
        return FALSE;
    }

    // return success
    return TRUE;
}


DWORD
GetTargetVersionEx(
    IWbemServices* pWbemServices,
    COAUTHIDENTITY* pAuthIdentity
    )
/*++

Routine Description:

    This function gets the version of the system from which we are trying to retrieve
    information from.

Arguments:

    [in] IWbemServices      :   pointer to the IWbemServices object
    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    DWORD   -   Target version of the machine if found else 0.

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF '0' IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/

{
    // local variables
    HRESULT hr = S_OK;
    LONG lPos = 0;
    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwVersion = 0;
    ULONG ulReturned = 0;
    CHString strVersion;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Check the input value
    if ( NULL == pWbemServices )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return 0;
    }

    try
    {
        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum(
            _bstr_t( CLASS_CIMV2_Win32_OperatingSystem ),
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time.
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( 0 == ulReturned )
        {
            // release the interfaces
            WMISaveError( WBEM_S_FALSE );
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( FALSE == PropertyGet( pWbemObject, L"Version", strVersion ) )
        {
            // release the interfaces
            // Error is already set in the called function.
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );

        //
        // now determine the os version
        dwMajor = dwMinor = 0;

        // Get the major version
        lPos = strVersion.Find( L'.' );
        if ( -1 == lPos )
        {
            // The version string itself is version ... THIS WILL NEVER HAPPEN
            if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion, 10 );
        }
        else
        {
            // major version
            if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

            // get the minor version
            strVersion = strVersion.Mid( lPos + 1 );
            lPos = strVersion.Find( L'.' );
            if ( -1 == lPos)
            {
                if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion, 10 );
            }
            else
            {
                if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
            }
        }

        // mix the version info
        dwVersion = dwMajor * 1000 + dwMinor;
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }

    // If successful then 'pWbemObject' and 'pWbemInstances' are already released.
    // return
    return dwVersion;
}


BOOL
GetPropertyFromSafeArray(
    SAFEARRAY *pSafeArray,
    LONG lIndex,
    CHString& strValue,
    VARTYPE vartype
    )
/*++

Routine Description:

    This function retrieves a property from the safe array.

Arguments:

    [in] SAFEARRAY          :   pointer to the array of elements
    [in] LONG               :   index to retrieve the data from
    [out] CHString          :   variable to hold the return value
    [in] VARTYPE            :   The type of variable to retrieve from the array

Return Value:

    TRUE on success
    FALSE on failure

NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

--*/
{
    // Local variables.
    VARIANT var;
    HRESULT hRes = S_OK;

     // Clear any errors.
     SetLastError( WBEM_S_NO_ERROR );

    // Check the inputs.
    if ( NULL == pSafeArray )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    // Initialize variant.
    VariantInit( &var );

    try
    {
        // get the value
        V_VT( &var ) = vartype;
        hRes = SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );
        if( FAILED( hRes ) )
        {   // Set error occured.
            WMISaveError( hRes );
            VariantClear( &var );
            return FALSE;
        }

        // Store requested information in
        switch( vartype )
        {
        case VT_BSTR:
            strValue = (LPCWSTR)_bstr_t( var );
            break;
        default:
            WMISaveError( WBEM_E_INVALID_PARAMETER );
            VariantClear( &var );
            return FALSE;
        }
    }
    catch( CHeap_Exception )
    {   // Exception thrown from 'strValue'.
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        VariantClear( &var );
        return FALSE;   // failure
    }

    // Clean-Up and return.
    VariantClear( &var );
    return TRUE;
}


BOOL
GetPropertyFromSafeArray(
    SAFEARRAY *pSafeArray,
    LONG lIndex,
    IWbemClassObject **pScriptObject,
    VARTYPE vartype
    )
/*++
Routine Description:

    This function retrieves a property from the safe array.

Arguments:

    [in] SAFEARRAY          :   pointer to the array of elements
    [in] LONG               :   index to retrieve the data from
    [out] IWbemClassObject  :   variable to hold the return value
    [in] VARTYPE            :   The type of variable to retrieve from the array

Return Value:

    TRUE on success
    FALSE on failure

NOTE: CALLED FUNCTION HAS TO MAKE SURE THAT '*pScriptObject' DOES NOT CONTAIN ANY
      VALUE WHICH MAY CAUSE MEMORY LEAK.
      THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.

NOTE: If TRUE is returned then 'VariantClear' is not called over 'var' since if
      a call is made to 'Variantcler' we will loose Interface pointer. Not calling
      'VariantClear' will free 'var' when its out of scope and leaving
      the interface pointer in memory which can be used by the called function.
      IT IS CALLING FUNCTION RESPONSIBILITY TO RELEASE THE INTERFACE POINTER.

--*/
{
    // Local variables.
    VARIANT var;
    HRESULT hRes = S_OK;

     // Clear any errors.
     SetLastError( WBEM_S_NO_ERROR );

    // Validate the inputs
    if ( ( NULL == pSafeArray ) ||
         ( NULL == pScriptObject ) )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return FALSE;
    }

    // Initialize variant.
    VariantInit( &var );

    // Set type of value expected.
    V_VT( &var ) = vartype;

    hRes = SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );
    // check for return value.
    if( FAILED( hRes ) )
    {   // Set error occured.
        WMISaveError( hRes );
        VariantClear( &var );
        return FALSE;
    }
    // Store information requested.
    switch( vartype )
    {
    case VT_UNKNOWN:
        *pScriptObject = (IWbemClassObject *) var.punkVal;
        break;
    default:
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        VariantClear( &var );
        return FALSE;
    }

    // return
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\asrt.h ===
/***    asrt.h - Definitions for Assertion Manager
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      10-Aug-1993 bens    Initial version
 *      11-Aug-1993 bens    Lifted old code from 1988 PSCHAR.EXE
 *  14-Aug-1993 bens    Added Get/Set functions
 *      01-Sep-1993 bens    Added AssertSub function
 *      10-Feb-1994 bens    Added Set/ClearAssertSignature
 *      15-Mar-1994 bens    Put back AssertMessage macro
 *
 *  Notes:
 *      o Every data structure must have a signature as first member.
 *      o Signatures MUST be unique over all structures.
 *      o sigBAD is a reserved signature.
 *      o When freeing a structure, blast the signature field with sigBAD.
 *      o Put an AssertXXX prior to dereferencing any pointer.
 *      o Signatures in structures and private Assert definitions should only
 *        be generated if ASSERT is defined.
 *
 *  Functions available in ASSERT build:
 *      AssertRegisterFunc - Register assertion failure call back function
 *  AssertGetFunc      - Get registered call back function
 *
 *  AssertSetFlags     - Set Assertion Manager flags
 *  AssertGetFlags     - Get Assertion Manager flags
 *
 *      Assert             - Check that parameter is TRUE
 *      AssertSub          - Check that parameter is TRUE, take explicit filename & line number
 *      AssertStrucure     - Check that pointer points to specified structure
 *      AssertForce        - Force an assertion failure
 *  AssertErrPath      - Error Path assertion failure
 *
 *      SetAssertSignature - Set the signature for a structure
 *      ClearAssertSignature - Clear the signature for a structure
 *
 *  Other definitions available in ASSERT build:
 *      PFNASSERTFAILURE - Assertion failure call back function type
 *      FNASSERTFAILURE  - Macro to simplify declaration of call back function
 *      SIGNATURE        - Structure signature type
 */

#ifndef INCLUDED_ASSERT
#define INCLUDED_ASSERT 1

#ifdef DIAMOND_DEBUG
#ifndef ASSERT
#define ASSERT 1
#endif // !ASSERT
#endif // _DEBUG

#ifdef ASSERT

typedef unsigned long ASSERTFLAGS;  /* asf - Assertion Manager Flags */
#define asfNONE             0x00
#define asfSKIP_ERROR_PATH_ASSERTS  0x01  /* Some clients may wish to set
                       * assertions in error paths, to
                       * ensure that the problem is
                       * noticed in a debug build.  But,
                       * in order to support automated
                       * testing of error paths, these
                       * assertions must be disabled.
                       * This flag allows a test program
                       * to disable these informational
                       * asserts!
                       */

typedef unsigned long SIGNATURE;    /* sig - structure signature */
typedef SIGNATURE *PSIGNATURE;      /* psig */
#define sigBAD  0                   // Invalid signature for ALL structs

/***    MAKESIG - construct a structure signature
 *
 *  Entry:
 *      ch1,ch2,ch3,ch4 - four characters
 *
 *  Exit:
 *      returns SIGNATURE
 */
#define MAKESIG(ch1,ch2,ch3,ch4)      \
          (  ((SIGNATURE)ch1)      +  \
            (((SIGNATURE)ch2)<< 8) +  \
            (((SIGNATURE)ch3)<<16) +  \
            (((SIGNATURE)ch4)<<24) )

/***    AssertMessage -- Force an Assertion with supplied message
 *
 *      Entry:
 *        pszMsg  -- message to display
 *
 *      Exit:
 *        none
 */

#define AssertMessage(pszMsg) AssertForce(pszMsg,__FILE__,__LINE__)


/***    PFNASSERTFAILURE - Assertion Failure call back function
 ***    FNASSERTFAILURE  - Define Assertion Failure call back function
 *
 *  Entry:
 *      pszMsg  - Description of failure
 *      pszFile - File where assertion failed
 *      iLine   - Line number in file where assertion failed
 *
 *  Exit-Success:
 *      Returns; ignore failure and continue
 *
 *  Exit-Failure:
 *      Function does not return, but cleans up and exits program.
 */
typedef void (*PFNASSERTFAILURE)(char *pszMsg, char *pszFile, int iLine);
#define FNASSERTFAILURE(fn) void fn(char *pszMsg, char *pszFile, int iLine)


/***    AssertRegisterFunc - Register assertion failure call back function
 *
 *  Entry:
 *      pfnaf - Call back function
 *
 *  Exit-Success:
 *      Returns; pfnaf is stored in the Assertion Manager
 *
 *  NOTES:
 *  (1) This function *must* be called prior to executing an assertion
 *  checks.  If not, and an assertion check fails, then the Assertion
 *  Manager will sit in a spin loop to catch the developer's attention.
 */
void AssertRegisterFunc(PFNASSERTFAILURE pfnaf);


/***    AssertGetFunc - Get current assertion failure call back function
 *
 *  Entry:
 *  none
 *
 *  Exit-Success:
 *  Returns current call back function registerd in Assertion Manager.
 */
PFNASSERTFAILURE AssertGetFunc(void);


/***    AssertSetFlags - Set special assertion control flags
 *
 *  Entry:
 *  flags - Set with combination of asfXXXX flags
 *
 *  Exit-Success:
 *  Returns; Flags are modified in Assertion Manager.
 */
void AssertSetFlags(ASSERTFLAGS asf);


/***    AssertGetFlags - Get special assertion control flags
 *
 *  Entry:
 *  none
 *
 *  Exit-Success:
 *  Returns current Assertion Manager flags.
 */
ASSERTFLAGS  AssertGetFlags(void);


/***    Assert - Check assertion that argument is true
 *
 *  Entry:
 *      b - Boolean value to check
 *
 *  Exit-Success:
 *      Returns; b was TRUE
 *
 *  Exit-Failure:
 *      Calls assertion failure callback function; b was FALSE
 */
#define Assert(b)   AsrtCheck(b,__FILE__,__LINE__)


/***    AssertSub - Check assertion, use passed in filename and line number
 *
 *  Entry:
 *      b - Boolean value to check
 *      pszFile - File where assertion occurred
 *      iLine   - Line in file where assertion occurred
 *
 *  Exit-Success:
 *      Returns; b was TRUE
 *
 *  Exit-Failure:
 *      Calls assertion failure callback function; b was FALSE
 */
#define AssertSub(b,pszFile,iLine) AsrtCheck(b,pszFile,iLine)


/***    AssertStructure - Check assertion that pointer is of correct type
 *
 *  Entry:
 *      pv  - Pointer to structure
 *      sig - Expected signature
 *
 *  Exit-Success:
 *      Returns; pv != NULL, and pv->sig == sig.
 *
 *  Exit-Failure:
 *      Calls assertion failure callback function; pv was bad.
 */
#define AssertStructure(pv,sig)   AsrtStruct(pv, sig, __FILE__, __LINE__)


/***    AssertForce - Force an assertion failure
 *
 *  Entry:
 *      pszMsg  - Message to display
 *      pszFile - File where assertion occurred
 *      iLine   - Line in file where assertion occurred
 *
 *  Exit-Success:
 *      Returns; client wanted to ignore assertion.
 *
 *  Exit-Failure:
 *      Does not return.
 */
void AssertForce(char *pszMsg, char *pszFile, int iLine);


/***    AssertErrorPath - Report an internal error path
 *
 *  Entry:
 *      pszMsg  - Message to display
 *      pszFile - File where assertion occurred
 *      iLine   - Line in file where assertion occurred
 *
 *  Exit-Success:
 *      Returns; client wanted to ignore assertion.
 *
 *  Exit-Failure:
 *      Does not return.
 */
void AssertErrPath(char *pszMsg, char *pszFile, int iLine);


/***    SetAssertSignature - Set the signature for a structure
 *
 *  Entry:
 *      p   - Structure with member "sigValue"
 *      sig - Signature to set
 *
 *  Exit:
 *      p->sig = sig
 */
#define SetAssertSignature(p,sigValue) p->sig = sigValue


/***    ClearAssertSignature - Clear the signature for a structure
 *
 *  Entry:
 *      p   - Structure with member "sig"
 *
 *  Exit:
 *      p->sig = sigBAD
 */
#define ClearAssertSignature(p) p->sig = sigBAD


//** Internal assertion manager worker routines

void AsrtCheck(BOOL f, char *pszFile, int iLine);
void AsrtStruct(void *pv, SIGNATURE sig, char *pszFile, int iLine);


#else // !ASSERT

//** Assertion checking is turned off, so it all evaporates!

#define FNASSERTFAILURE(fn)
#define AssertRegisterFunc(pfnaf)
#define Assert(b)
#define AssertSub(b,pszFile,iLine)
#define AssertStructure(pv,sig)
#define AssertMessage(pszMsg)
#define AssertForce(pszMsg,pszFile,iLine)
#define AssertErrPath(pszMsg,pszFile,iLine)
#define SetAssertSignature(p,sig)
#define ClearAssertSignature(p)

/** The following functions are not defined away, because any valid use
 *  of them requires a typedef'd variable or function that is not available
 *  in a non-ASSERT build.  So we don't define them so that if a client
 *  has used these outside of an #ifdef ASSERT, a compiler error/warning
 *  will be generated:
 *
 *  AssertGetFunc
 *  AssertSetFlags
 *  AssertGetFlags
 */

#endif // ASSERT
#endif // !INCLUDED_ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\error.c ===
/***    error.c - Error Reporting
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *      History:
 *          10-Aug-1993 bens    Initial version
 *          03-May-1994 bens    Add err.code and err.pv fields
 */

#include "types.h"
#include "asrt.h"
#include "error.h"
#include "message.h"


/***    ErrSet - Set error message
 *
 *      NOTE: See error.h for entry/exit conditions.
 */
void __cdecl ErrSet(PERROR perr, char *pszMsg, ...)
{
    va_list marker;
    char   *pszFmtList;

    Assert(perr!=NULL);
    Assert(pszMsg!=NULL);

    va_start(marker,pszMsg);            // Initialize variable arguments
    pszFmtList = (char *)va_arg(marker,char *); // Assume format string

    //** Format the message
    MsgSetWorker(perr->ach,pszMsg,pszFmtList,marker);
    va_end(marker);                     // Done with variable arguments
    perr->fError = TRUE;
}


/***    ErrClear - Clear ERROR
 *
 *      NOTE: See error.h for entry/exit conditions.
 */
void ErrClear(PERROR perr)
{
    Assert(perr != NULL);
    perr->fError = FALSE;   // No error
    perr->ach[0] = '\0';    // No message
    perr->code   = 0;
    perr->pv     = NULL;
}


#ifdef ASSERT
/***    ErrIsError - Check if error condition is set
 *
 *      NOTE: See error.h for entry/exit conditions.
 */
BOOL ErrIsError(PERROR perr)
{
    Assert(perr != NULL);
    return perr->fError;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\error.h ===
/***    error.h - Definitions for Error Reporting
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *      History:
 *          10-Aug-1993 bens    Initial version
 *          09-Feb-1994 bens    Add pszLine to ERROR structure
 *          03-May-1994 bens    Add err.code and err.pv fields
 */

#ifndef INCLUDED_ERROR
#define INCLUDED_ERROR 1

#include "message.h"

typedef struct {
    char    ach[cbMSG_MAX];     // Error message
    BOOL    fError;             // TRUE => error present
    char   *pszFile;            // Name of directives file being processed
    int     iLine;              // Line number in directives file, if >0
    char   *pszLine;            // Text of current line being processed
    int     code;               // Detailed error code
    void   *pv;                 // Additional error information
} ERROR;    /* err */
typedef ERROR *PERROR;  /* perr */


/***    ErrSet - Set error message
 *
 *  Entry
 *      perr   - ERROR structure to receive formatted message
 *      pszMsg - Message string, possibly including %1, %2, ... replaceable
 *               parameters.
 *      Remaining arguments are optional, and depend upon presence of %N
 *      replaceable parameters in pszMsg:
 *      pszFmt - If at least one %N string in pszMsg, then this contains
 *               sprintf() formatting strings.
 *      Arg1   - Present only if %1 is present.
 *      Arg2   - Present only if %2 is present.
 *      ...
 *
 *  Exit-Success
 *      perr filled in with formatted message.
 *          Arg1 is formatted according to the first sprintf format in
 *          pszFmt, and replaces the %1 in pszMsg.  Similar treatment for
 *          any other arguments.
 *
 *  Exit-Failure
 *      perr filled in with message describing bad arguments.
 */
void __cdecl ErrSet(PERROR perr, char *pszMsg, ...);


/***    ErrClear - Clear ERROR
 *
 *      Entry
 *          perr - ERROR structure to clear
 *
 *      Exit-Success
 *          perr is cleared
 */
void ErrClear(PERROR perr);


/***    ErrIsError - Check if error condition is set
 *
 *  Entry
 *      perr   - ERROR structure to check
 *
 *  Exit-Success
 *      Returns TRUE if an error message is set.
 *
 *  Exit-Failure
 *      Returns FALSE if no error message set.
 */
#ifdef ASSERT
BOOL ErrIsError(PERROR perr);
#else // !ASSERT
#define ErrIsError(perr) (perr->fError)     // Fast dereference
#endif // !ASSERT


#endif // !INCLUDED_ERROR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\extrcids.h ===
#define DLG_PROGRESS    101
#define IDC_PROGRESS    102
#define IDI_EXTRACT     103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\filelist.h ===
/***    filelist.h - Definitions for File List Manager
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      20-Aug-1993 bens    Initial version
 *  21-Aug-1993 bens    Add more set/query operations
 *      01-Apr-1994 bens    Added FLSetSource() message
 *
 *  Exported Functions:
 *    FLCreateList   - Create a file list
 *    FLDestroyList  - Destroy a file list
 *
 *    FLAddFile      - Add file spec to a file list
 *
 *    FLFirstFile    - Get first file spec from a file list
 *    FLNextFile     - Get next file spec
 *    FLPreviousFile     - Get previous file spec
 *
 *    FLGetDestination   - Get destination file name
 *    FLGetGroup     - Get group/disk number for a file spec
 *    FLGetSource    - Get source file name
 *
 *    FLSetSource        - Change source file name
 *    FLSetDestination   - Change destination file name
 *    FLSetGroup     - Set group/disk number for a file spec
 */

#include "error.h"

//** PUBLIC definitions

typedef int GROUP;  /* grp */
#define grpBAD     0    // Bad group value
#define grpNONE   -1    // File is not in a group
#define grpSTART  -2    // File is first file in a group
#define grpMIDDLE -3    // File is in a group
#define grpEND    -4    // File is last file in a group

typedef void *HFILESPEC; /* hfspec */
typedef void *HFILELIST; /* hflist */


/***    FLAddFile - Add file spec to a file list
 *
 *  Entry:
 *      hflist - List to add to
 *      pszSrc - Source file name
 *      pszDst - Destination file name (NULL if not specified)
 *      perr   - ERROR structure
 *
 *  Exit-Success:
 *      Returns HFILESPEC of newly added file spec
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in with error.
 */
HFILESPEC FLAddFile(HFILELIST hflist,char *pszSrc,char *pszDst,PERROR perr);


/***    FLCreateList - Create a file list
 *
 *  Entry:
 *      perr   - ERROR structure
 *
 *  Exit-Success:
 *      Returns HFILELIST of newly created file list
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in with error.
 */
HFILELIST FLCreateList(PERROR perr);


/***    FLDestroyList - Destroy a file list
 *
 *  Entry:
 *      hflist - List to destroy
 *      perr   - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; file list destroyed
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in with error.
 */
BOOL FLDestroyList(HFILELIST hflist,PERROR perr);


/***    FLFirstFile - Get first file spec from a file list
 *
 *  Entry:
 *  hflist - List to Get
 *
 *  Exit-Success:
 *      Returns HFILESPEC of first file spec in file list.
 *
 *  Exit-Failure:
 *      Returns NULL; hflist is bad or empty.
 */
HFILESPEC FLFirstFile(HFILELIST hflist);


/***    FLNextFile - Get next file spec
 *
 *  Entry:
 *      hfspec - File spec
 *
 *  Exit-Success:
 *      Returns HFILESPEC of next file spec following hfspec.
 *
 *  Exit-Failure:
 *      Returns NULL; no more file specs, or hfspec is bad.
 */
HFILESPEC FLNextFile(HFILESPEC hfspec);


/***    FLPreviousFile - Get previous file spec
 *
 *  Entry:
 *      hfspec - File spec
 *
 *  Exit-Success:
 *      Returns HFILESPEC of file spec immediately preceding hfspec.
 *
 *  Exit-Failure:
 *      Returns NULL; no more file specs, or hfspec is bad.
 */
HFILESPEC FLPreviousFile(HFILESPEC hfspec);


/***    FLGetGroup - Get group/disk number for a file spec
 *
 *  Entry:
 *  hfspec - File spec to get
 *
 *  Exit-Success:
 *      Returns GROUP (or disk number) of file spec.
 *
 *  Exit-Failure:
 *      Returns grpBAD; hfspec was bad
 */
GROUP FLGetGroup(HFILESPEC hfspec);


/***    FLGetDestination - Get destination file name
 *
 *  Entry:
 *  hfspec - File spec to get
 *
 *  Exit-Success:
 *  Returns destination file name
 *
 *  Exit-Failure:
 *  Returns NULL; no destination file name specified
 */
char *FLGetDestination(HFILESPEC hfspec);


/***    FLGetSource - Get source file name
 *
 *  Entry:
 *  hfspec - File spec to get
 *
 *  Exit-Success:
 *  Returns source file name
 *
 *  Exit-Failure:
 *  Returns NULL; no source file name specified
 */
char *FLGetSource(HFILESPEC hfspec);


/***    FLSetGroup - Set group/disk number for a file spec
 *
 *  Entry:
 *      hfspec - File spec
 *
 *  Exit-Success:
 *      Group/Disk number updated
 */
void FLSetGroup(HFILESPEC hfspec,GROUP grp);


/***    FLSetSource - Change source file name
 *
 *  Entry:
 *  hfspec - File spec to change
 *      pszSrc - New source file name
 *  perr   - ERROR structure
 *
 *  Exit-Success:
 *  Returns TRUE; destination updated.
 *
 *  Exit-Failure:
 *  Returns FALSE; perr filled in with error.
 */
BOOL FLSetSource(HFILESPEC hfspec, char *pszSrc, PERROR perr);


/***    FLSetDestination - Change destination file name
 *
 *  Entry:
 *  hfspec - File spec to change
 *  pszDst - New destination file name
 *  perr   - ERROR structure
 *
 *  Exit-Success:
 *  Returns TRUE; destination updated.
 *
 *  Exit-Failure:
 *  Returns FALSE; perr filled in with error.
 */
BOOL FLSetDestination(HFILESPEC hfspec, char *pszDst, PERROR perr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\filelist.c ===
/***    filelist.c - File List Manager
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      20-Aug-1993 bens    Initial version
 *      21-Aug-1993 bens    Add more set/query operations
 *      10-Feb-1994 bens    Add comments to FLDestroyList
 *      15-Feb-1994 bens    Fix bug in FLSetDestination
 *      01-Apr-1994 bens    Added FLSetSource() message
 *
 *  Exported Functions:
 *      FLAddFile        - Add file spec to a file list
 *      FLCreateList     - Create a file list
 *      FLDestroyList    - Destroy a file list
 *      FLFirstFile      - Get first file spec from a file list
 *      FLGetDestination - Get destination file name
 *      FLGetGroup       - Get group/disk number for a file spec
 *      FLGetSource      - Get source file name
 *      FLNextFile       - Get next file spec
 *      FLPreviousFile   - Get previous file spec
 *      FLSetSource      - Change source file name
 *      FLSetDestination - Change destination file name
 *      FLSetGroup       - Set group/disk number for a file spec
 */

#include "types.h"
#include "asrt.h"
#include "error.h"
#include "mem.h"

#include "filelist.h"

#include <filelist.msg> // LOCALIZED for EXTRACT.EXE -- specify "cl /Ipath"


typedef struct FILESPEC_t {
#ifdef ASSERT
    SIGNATURE          sig;         // structure signature sigFILESPEC
#endif
    char              *pszSrc;      // Source file name
    char              *pszDst;      // Destination file name
    GROUP              grp;         // Group status / Disk Number
    struct FILESPEC_t *pfspecPrev;  // Previous filespec in list
    struct FILESPEC_t *pfspecNext;  // Next filespec in list
} FILESPEC; /* fspec */
typedef FILESPEC *PFILESPEC; /* pfspec */
#ifdef ASSERT
#define sigFILESPEC MAKESIG('F','S','P','C')  // FILESPEC signature
#define AssertFSpec(pv) AssertStructure(pv,sigFILESPEC);
#else // !ASSERT
#define AssertFSpec(pv)
#endif // !ASSERT


typedef struct FILELIST_t {
#ifdef ASSERT
    SIGNATURE          sig;         // structure signature sigFILELIST
#endif
    PFILESPEC   pfspecHead;
    PFILESPEC   pfspecTail;
} FILELIST; /* flist */
typedef FILELIST *PFILELIST; /* pflist */
#ifdef ASSERT
#define sigFILELIST MAKESIG('F','L','S','T')  // FILELIST signature
#define AssertFList(pv) AssertStructure(pv,sigFILELIST);
#else // !ASSERT
#define AssertFList(pv)
#endif // !ASSERT

#define HFSfromPFS(hfs) ((PFILESPEC)(hfs))
#define PFSfromHFS(pfs) ((HFILESPEC)(pfs))

#define HFLfromPFL(hfl) ((PFILELIST)(hfl))
#define PFLfromHFL(pfl) ((HFILELIST)(pfl))



/***    FLAddFile - Add file spec to a file list
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
HFILESPEC FLAddFile(HFILELIST hflist,char *pszSrc,char *pszDst,PERROR perr)
{
    PFILESPEC   pfspec;
    PFILELIST   pflist;

    pflist = PFLfromHFL(hflist);
    AssertFList(pflist);
    Assert(pszSrc != NULL);

    //** Create file specification
    if (!(pfspec = MemAlloc(sizeof(FILESPEC)))) {
        goto error;
    }

    //** Intialize structure enough so that clean-up routine can determine
    //   if any resources need to be freed.
    pfspec->pszSrc = NULL;
    pfspec->pszDst = NULL;
    SetAssertSignature(pfspec,sigFILESPEC);

    //** Make copy of source name
    if (!(pfspec->pszSrc = MemStrDup(pszSrc))) {
        goto error;
    }

    //** pszDst is optional, may be NULL!
    if (pszDst == NULL) {
        pfspec->pszDst = NULL;
    }
    else if (!(pfspec->pszDst = MemStrDup(pszDst))) {
        goto error;
    }

    //** Finishing initializing file spec, and link onto list
    pfspec->grp        = grpNONE;       // Assume no group
    pfspec->pfspecNext = NULL;          // Always last on list
    pfspec->pfspecPrev = pflist->pfspecTail; // Always points to last file spec

    if (pflist->pfspecHead == NULL) {   // File list is empty
        pflist->pfspecHead = pfspec;
        pflist->pfspecTail = pfspec;
    }
    else {                              // File list is not empty
        AssertFSpec(pflist->pfspecTail);
        pflist->pfspecTail->pfspecNext = pfspec;  // Add to end of list
        pflist->pfspecTail = pfspec;            // New tail
    }

    // Success
    return HFSfromPFS(pfspec);

error:
    if (pfspec) {
        if (pfspec->pszSrc) {
            MemFree(pfspec->pszSrc);
        }
        if (pfspec->pszDst) {
            MemFree(pfspec->pszDst);
        }
        MemFree(pfspec);
    }

    ErrSet(perr,pszFLISTERR_OUT_OF_MEMORY,"%s",pszADDING_FILE);
    return NULL;                        // Failure

} /* FLAddFile */


/***    FLCreateList - Create a file list
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
HFILELIST FLCreateList(PERROR perr)
{
    PFILELIST   pflist;

    if (!(pflist = MemAlloc(sizeof(FILELIST)))) {
        ErrSet(perr,pszFLISTERR_OUT_OF_MEMORY,"%s",pszCREATING_FILE_LIST);
        return FALSE;
    }

    pflist->pfspecHead = NULL;
    pflist->pfspecTail = NULL;
    SetAssertSignature(pflist,sigFILELIST);

    return HFLfromPFL(pflist);

} /* FLCreateList */


/***    FLDestroyList - Destroy a file list
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
BOOL FLDestroyList(HFILELIST hflist,PERROR perr)
{
    PFILELIST   pflist;
    PFILESPEC   pfspecThis;
    PFILESPEC   pfspecNext;

    pflist = PFLfromHFL(hflist);
    AssertFList(pflist);

    pfspecThis = pflist->pfspecHead;

    while (pfspecThis != NULL) {

        AssertFSpec(pfspecThis);
        if (pfspecThis->pszSrc != NULL) {
            MemFree(pfspecThis->pszSrc);
        }
        if (pfspecThis->pszDst != NULL) {
            MemFree(pfspecThis->pszDst);
        }
        pfspecNext = pfspecThis->pfspecNext;
        ClearAssertSignature(pfspecThis);
        MemFree(pfspecThis);
        pfspecThis = pfspecNext;
    }

    ClearAssertSignature(pflist);
    MemFree(pflist);

    return TRUE;
}


/***    FLFirstFile - Get first file spec from a file list
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
HFILESPEC FLFirstFile(HFILELIST hflist)
{
    PFILELIST   pflist;

    pflist = PFLfromHFL(hflist);
    AssertFList(pflist);

    return HFSfromPFS(pflist->pfspecHead);
}


/***    FLNextFile - Get next file spec
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
HFILESPEC FLNextFile(HFILESPEC hfspec)
{
    PFILESPEC   pfspec;

    pfspec = PFSfromHFS(hfspec);
    AssertFSpec(pfspec);

    return HFSfromPFS(pfspec->pfspecNext);
}


/***    FLPreviousFile - Get previous file spec
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
HFILESPEC FLPreviousFile(HFILESPEC hfspec)
{
    PFILESPEC   pfspec;

    pfspec = PFSfromHFS(hfspec);
    AssertFSpec(pfspec);

    return HFSfromPFS(pfspec->pfspecPrev);
}


/***    FLGetGroup - Get group/disk number for a file spec
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
GROUP FLGetGroup(HFILESPEC hfspec)
{
    PFILESPEC   pfspec;

    pfspec = PFSfromHFS(hfspec);
    AssertFSpec(pfspec);

    return pfspec->grp;
}


/***    FLGetDestination - Get destination file name
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
char *FLGetDestination(HFILESPEC hfspec)
{
    PFILESPEC   pfspec;

    pfspec = PFSfromHFS(hfspec);
    AssertFSpec(pfspec);

    return pfspec->pszDst;

} /* FLGetDestination */


/***    FLGetSource - Get source file name
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
char *FLGetSource(HFILESPEC hfspec)
{
    PFILESPEC   pfspec;

    pfspec = PFSfromHFS(hfspec);
    AssertFSpec(pfspec);

    return pfspec->pszSrc;

} /* FLGetSource */


/***    FLSetGroup - Set group/disk number for a file spec
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
void FLSetGroup(HFILESPEC hfspec,GROUP grp)
{
    PFILESPEC   pfspec;

    pfspec = PFSfromHFS(hfspec);
    AssertFSpec(pfspec);

    pfspec->grp = grp;
}


/***    FLSetSource - Change source file name
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
BOOL FLSetSource(HFILESPEC hfspec, char *pszSrc, PERROR perr)
{
    PFILESPEC   pfspec;
    char       *pszOriginal;

    pfspec = PFSfromHFS(hfspec);
    AssertFSpec(pfspec);

    //** Save original destination, so we can free it later
    pszOriginal = pfspec->pszSrc;

    //** Set new destination
    if (!(pfspec->pszSrc = MemStrDup(pszSrc))) {
        ErrSet(perr,pszFLISTERR_OUT_OF_MEMORY,"%s",pszCHANGING_SOURCE);
        return FALSE;                       // Failure
    }

    //** Free old destination
    if (pszOriginal) {
        MemFree(pszOriginal);
    }

    //** Success
    return TRUE;
}


/***    FLSetDestination - Change destination file name
 *
 *  NOTE: See filelist.h for entry/exit conditions.
 */
BOOL FLSetDestination(HFILESPEC hfspec, char *pszDst, PERROR perr)
{
    PFILESPEC   pfspec;
    char       *pszDstOriginal;

    pfspec = PFSfromHFS(hfspec);
    AssertFSpec(pfspec);

    //** Save original destination, so we can free it later
    pszDstOriginal = pfspec->pszDst;

    //** Set new destination
    if (!(pfspec->pszDst = MemStrDup(pszDst))) {
        ErrSet(perr,pszFLISTERR_OUT_OF_MEMORY,"%s",pszCHANGING_DESTINATION);
        return FALSE;                       // Failure
    }

    //** Free old destination
    if (pszDstOriginal) {
        MemFree(pszDstOriginal);
    }

    //** Success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\extract.c ===
/***    extract.c - Main program for EXTRACT.EXE
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1994-1997
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      19-Feb-1994 bens    Initial version (started with diamond.c)
 *      22-Feb-1994 bens    Implement file extract
 *      03-Mar-1994 bens    Split cabinet paths from cabinet file names
 *      08-Mar-1994 bens    Add date/time/attribute display
 *      09-Mar-1994 bens    Improve response to FDI errors
 *      16-Mar-1994 bens    More FDI error codes
 *      21-Mar-1994 bens    Log all open/close calls to see if we are
 *                              losing file handles in FDI.LIB.
 *      28-Mar-1994 bens    Handle fdintCABINET_INFO, support /A switch
 *      30-Mar-1994 bens    Move MS-DOS/Win32 knowledge to fileutil.*
 *      31-Mar-1994 bens    Add SMALL_DOS to test small model FDI client
 *      01-Apr-1994 bens    Add /D and /E switches, support full command
 *                              line behavior.
 *      07-Apr-1994 bens    Add crypto support (at least for debugging)
 *      06-May-1994 bens    Improve /D display for long filenames
 *      13-May-1994 bens    Add prompting for next cabinet, DMF support
 *      27-May-1994 bens    Include correct strings for localization
 *      03-Jun-1994 bens    Report error on correct cabinet
 *      07-Jun-1994 bens    Localization enabled
 *      21-Jun-1994 bens    Localization enabled
 *      08-Jul-1994 bens    Quantum Spill File, self-extracting cabinets!
 *      11-Jul-1994 bens    Use 24-hour time format if am/pm strings are empty
 *      26-Jul-1994 bens    Add /C switch; no switches give /? help
 *      05-Aug-1994 bens    Chicago bug 13214 (don't show partial file info
 *                          unless name matches request).  Chicago bug 13221
 *                          (truncate extracted file to specified size, in
 *                          case file already existed and was larger!).
 *                          Chicago bug 9646 (give details of Quantum
 *                          decompress failure -- out of RAM, spill file).
 *                          Implement overwrite prompt and /Y switch.
 *      14-Dec-1994 bens    Include Floppy changeline fix from
 *                              ..\dmf\dmftsr\fixchg.c
 *      12-Mar-1995 bens    Define NOT_US_PC flag to disable use of DMF hook
 *                          and FixChangeline code.  Also, check COMSPEC to
 *                          detect boot drive, instead of hard-coding C:, so
 *                          that the Quantum spill file can default to the
 *                          boot drive if no TEMP path is found.  In the far
 *                          east, the hard disk boot drive is A:, so that's
 *                          why we have to check!
 *      31-Mar-1995 jeffwe  Fix Command line ambiguity when no /D or /E
 *                          option is specified
 *       2-Apr-1995 jeffwe  Fix file time/date set to change the correct
 *                          file when rename option being used
 *      28-Feb-1997 msliger Added /Z option to zap paths from CABs.  Fixed
 *                          32-bit self-extract feature.
 *      18-Mar-1997 msliger Mask attribs to watch out for UTF et al.
 *      24-Mar-1997 msliger Fix self-extract on NT (don't use argv[0])
 *      13-May-1997 msliger Merged in deltas for GUI Extrac32.EXE
 *      26-Jun-1997 msliger Support XIMPLANT self-extract (CAB is an added
 *                          section in the PE file with a certain name; this
 *                          makes self-extractors Authenticode 2 compatible.
 *      01-Jul-1997 msliger Fix reporting wrong cab name for corrupt cabinets.
 *      22-Mar-1999 msliger Added support for CAB-destructive extraction.
 *
 *
 *  Notes:
 *      A self-extracting cabinet file can be created using DIAMOND.EXE and
 *      EXTRACT.EXE very simply:
 *          1) Create a cabinet file using DIAMOND.EXE
 *          2) COPY /B EXTRACT.EXE+foo.cab foo.exe
 *      When EXTRACT starts executing, it compares the file size indicated
 *      in the EXE headers (MZ or PE, as appropriate) with the size of the
 *      file indicated in argv[0].  If the argv[0] size is greater, and a
 *      cabinet file appears there, then EXTRACT goes into self-extracting
 *      mode!
 *
 *      However, the EXE created this way is not Authenticode 2-compatible.
 *
 *      For Authenticode compatibility, 32-bit versions can also:
 *          1) Create a cabinet file using DIAMOND.EXE
 *          2) XIMPLANT EXTRACT.EXE foo.cab foo.exe
 *      This buries the cabinet inside the PE image in a way that doesn't
 *      offend Authenticode 2.
 */
//#include "resource.h"
//#include "pch.h"


#ifdef WIN32GUI
#include "extrac32.rc"
#else
#include "extract.rc"
#endif


#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <malloc.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <errno.h>
#include <direct.h>
#include <conio.h>

#ifdef BIT16
#include <dos.h>
#include "fixchg.h"
#else // !BIT16

//** Get minimal Win32 definitions

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#undef ERROR    // Override "#define ERROR 0" in wingdi.h
#endif // !BIT16

#ifdef WIN32GUI
#include <commctrl.h>
#include "extrcids.h"
#endif

#include "types.h"
#include "asrt.h"
#include "error.h"
#include "mem.h"
#include "message.h"

#include "filelist.h"
#include "fileutil.h"
#include "wildcard.h"

#include "dmfon.h"              // DMF support

#include <extract.msg> // LOCALIZED for EXTRACT.EXE -- specify "cl /Ipath"

#include "fdi.h"
#include "oldnames.h"


//** Constants

#define cbMAX_LINE          256 // Maximum output line length


#define cMAX_CAB_FILE_OPEN    2 // Maximum simultaneous opens on a single
                                // cabinet file

//** Error causes for failure of spill file
typedef enum {
    seNONE,                     // No error
    seNOT_ENOUGH_MEMORY,        // Not enough RAM
    seCANNOT_CREATE,            // Cannot create spill file
    seNOT_ENOUGH_SPACE,         // Not enough space for spill file
} SPILLERR; /* se */


//** Types

typedef enum {
    actBAD,         // Invalid action
    actHELP,        // Show help
    actDEFAULT,     // Perform default action based on command line arguments
    actDIRECTORY,   // Force display of cabinet directory
    actEXTRACT,     // Force file extraction
    actCOPY,        // Do single file-to-file copy
} ACTION;   /* act */


typedef struct {
    char    achCabPath[cbFILE_NAME_MAX]; // Cabinet file path
    char    achCabFilename[cbFILE_NAME_MAX]; // Cabinet file name.ext
    char    achDiskName[cbFILE_NAME_MAX]; // User readable disk label
    USHORT  setID;
    USHORT  iCabinet;
} CABINET; /* cab */
typedef CABINET *PCABINET; /* pcab */


#ifdef ASSERT
#define sigSESSION MAKESIG('S','E','S','S')  // SESSION signature
#define AssertSess(psess) AssertStructure(psess,sigSESSION);
#else // !ASSERT
#define AssertSess(psess)
#endif // !ASSERT

typedef struct {
#ifdef ASSERT
    SIGNATURE   sig;                // structure signature sigSESSION
#endif
    ACTION      act;                // Action to perform
    HFILELIST   hflist;             // List of files specified on cmd line
    BOOL        fAllCabinets;       // TRUE => Process continutation cabs
    BOOL        fOverwrite;         // TRUE => Overwrite existing files
    BOOL        fNoLineFeed;        // TRUE if last printf did not have \n
    BOOL        fSelfExtract;       // TRUE if self-extracting
    long        cbSelfExtract;      // Size of EXE portion of self-ex cabinet
    long        cbSelfExtractSize;  // Size of CAB portion of self-ex cabinet
    int         ahfSelf[cMAX_CAB_FILE_OPEN]; // Cabinet file handles
    int         cErrors;            // Count of errors encountered
    HFDI        hfdi;               // FDI context
    ERF         erf;                // FDI error structure
    long        cFiles;             // Total files processed
    long        cbTotalBytes;       // Total bytes extracted
    PERROR      perr;               // Pass through FDI
    SPILLERR    se;                 // Spill file error
    long        cbSpill;            // Size of spill file requested
    char        achSelf[cbFILE_NAME_MAX]; // Name of our EXE file
    char        achMsg[cbMAX_LINE*2]; // Message formatting buffer
    char        achLine[cbMAX_LINE]; // Line formatting buffer
    char        achLocation[cbFILE_NAME_MAX]; // Output directory
    char        achFile[cbFILE_NAME_MAX]; // Current filename being extracted
    char        achDest[cbFILE_NAME_MAX]; // Forced destination file name
    char        achCabPath[cbFILE_NAME_MAX]; // Path to look for cabinet file

    BOOL        fContinuationCabinet; // TRUE => not 1st cabinet processed
    BOOL        fShowReserveInfo;   // TRUE => show RESERVEd cabinet info

    //** fNextCabCalled allows us to figure out which of the acab[] entries
    //   to use if we are processing all file in a cabinet set (i.e., if
    //   fAllCabinet is TRUE).  If fdintNEXT_CABINET has never been called,
    //   then acab[1] has the information for the next cabinet.  But if
    //   it has been called, then fdintCABINET_INFO will have been called
    //   at least twice (once for the first cabinet, and once at least for
    //   a continuation cabinet), and so acab[0] is the cabinet we need to
    //   pass to a subsequent FDICopy() call.
    BOOL        fNextCabCalled;     // TRUE => GetNextCabinet called
    CABINET     acab[2];            // Last two fdintCABINET_INFO data sets
    char        achZap[cbFILE_NAME_MAX];  // prefix to strip from filename
    char        achCabinetFile[cbFILE_NAME_MAX];  // current cabinet file
    int         cArgv;              // default self-ext argc
    char        **pArgv;            // default self-ext argv[]
    int         fDestructive;       // TRUE => minimize disk space needed
    USHORT      iCurrentFolder;     // iff fDestructive, only extract this one
} SESSION;  /* sess */
typedef SESSION *PSESSION;  /* psess */


/*
 ** Spill file statics for Quantum
 */
INT_PTR  hfSpillFile;                   // File handle
char achSpillFile[cbFILE_NAME_MAX];     // File path

/*
 ** Global state for self-extract
 */
PSESSION    psessG;


#ifdef WIN32GUI
/*
 ** GUI support
 */

static INT_PTR hCabFile1 = -1;
static INT_PTR hCabFile2 = -1;
static unsigned long ibCabFilePosition1;
static unsigned long ibCabFilePosition2;
static unsigned long cbCabFileMax;
static unsigned long cbCabFileTotal;
static unsigned long cbCabFileScale;
static int iPercentLast;

static void ProgressReport(unsigned long cbCabFileMax);
LRESULT CALLBACK ProgressWndProc(HWND hdlg, UINT msg,
        WPARAM wparam, LPARAM lparam);

static HINSTANCE g_hinst;
static HWND g_hwndProgress = NULL;

#endif


//** Function Prototypes

FNASSERTFAILURE(fnafReport);

HFILESPEC addFileSpec(PSESSION psess, char *pszArg, PERROR perr);
BOOL      checkWildMatches(PSESSION psess, char *pszFile, PERROR perr);
BOOL      doCabinet(PSESSION psess, PERROR perr);
BOOL      doCopy(PSESSION psess, PERROR perr);
BOOL      ensureCabinet(PSESSION  psess,
                        char     *pszPath,
                        int       cbPath,
                        char     *pszFile,
                        char     *pszLabel,
                        USHORT    setID,
                        USHORT    iCabinet,
                        BOOL      fLoop,
                        BOOL      fPromptOnly,
                        PERROR    perr);
BOOL      checkOverwrite(PSESSION  psess,
                         char     *pszFile,
                         PERROR    perr,
                         int      *prc);
BOOL      checkSelfExtractingCab(PSESSION  psess,
                                 int       cArg,
                                 char     *apszArg[],
                                 PERROR    perr);
char     *getBootDrive(void);
BOOL      parseCommandLine(PSESSION psess,int cArg,char *apszArg[],PERROR perr);
void      printError(PSESSION psess, PERROR perr);
void      pszFromAttrFAT(char *psz, int cb, WORD attrFAT);
void      pszFromMSDOSTime(char *psz, int cb, WORD date, WORD time);
int       updateCabinetInfo(PSESSION psess, PFDINOTIFICATION pfdin);


//** FDI callbacks and related functions
FNALLOC(fdiAlloc);
FNFREE(fdiFree);
FNFDINOTIFY(fdiNotifyDir);
FNFDINOTIFY(fdiNotifyExt);
FNFDINOTIFY(doGetNextCab);

FNFDIDECRYPT(fdiDecryptDir);
FNFDIDECRYPT(fdiDecryptExt);

void mapFDIError(PERROR perr,PSESSION psess, char *pszCabinet, PERF perf);


//** File I/O wrapper functions
INT_PTR  FAR DIAMONDAPI wrap_open(char FAR *, int, int);
UINT FAR DIAMONDAPI wrap_read(INT_PTR, void FAR *, unsigned int);
UINT FAR DIAMONDAPI wrap_write(INT_PTR, void FAR *, unsigned int);
int  FAR DIAMONDAPI wrap_close(INT_PTR);
long FAR DIAMONDAPI wrap_lseek(INT_PTR, long, int);


#ifdef SMALL_DOS
#define STRCPY(dst,src) _fstrcpy((char far *)dst,(char far *)src)
#else
#define STRCPY(dst,src) strcpy(dst,src)
#endif

//FEATURE: 08-Jul-1994 bens Generate debug output
//#define DEBUG_FDI   1

#ifdef DEBUG_FDI
#define dbg(a) a
#else
#define dbg(a)
#endif

#define         HELP_MAX_SIZE    4096
#define         MAX_MESSAGE_SIZE 256
#define         EMPTY_SPACE      L" "
//** Functions

/***    main - Extract main program
 *
 *  See DIAMOND.DOC for spec and operation.
 *
 *  NOTE: We're sloppy, and don't free resources allocated by
 *        functions we call, on the assumption that program exit
 *        will clean up memory and file handles for us.
 */
int __cdecl wmain(DWORD cArg, LPWSTR apszArg[])
{
    ERROR       err;
    PSESSION    psess;
    WCHAR       szTemp[HELP_MAX_SIZE] = L"";
    DWORD       dw  = 0;
    LPSTR       *szArg  =   NULL;
    LPSTR       szTempArg;
    // #define NTVCPP_DEBUG_HACK
#ifdef NTVCPP_DEBUG_HACK
    _chdir("\\elroy\\diamond\\layout\\testnew");
#endif

    AssertRegisterFunc(fnafReport);     // Register assertion reporter
    ErrClear(&err);                     // No error
    err.pszFile = NULL;                 // No file being processed, yet
    achSpillFile[0] = '\0';             // No name constructed, yet

#ifdef BIT16
#ifndef NOT_US_PC
    //** Make sure we can read DMF disks -- only for pre-Chicago systems
    EnableDMFSupport();

    //** Turn off floppy disk changeline support to make sure systems
    //   with faulty change lines don't choke on disk 2 in the case
    //   where disk 1 is non-DMF and disk 2 is DMF.
    FixChangelines();
#endif
#endif

    if( cArg<=1 )
    {
        fwprintf( stderr, pszINVALID_SYNTAX );
        fwprintf( stderr, pszHELP_MESSAGE );
        return( EXIT_FAILURE);
    }
    //** Initialize session
    psess = MemAlloc(sizeof(SESSION));
    if (!psess) {
        ErrSet(&err,pszEXTERR_NO_SESSION);
        printError(psess,&err);
        exit(1);
    }
    SetAssertSignature((psess),sigSESSION);
    psessG = psess;                     // Save for wrap_open/wrap_close
    psess->fOverwrite           = FALSE; // Default to being save
    psess->fAllCabinets         = FALSE; // Don't do continuation cabinets
    psess->fNextCabCalled       = FALSE;
    psess->fContinuationCabinet = FALSE;
    psess->fShowReserveInfo     = FALSE;
    psess->fSelfExtract         = FALSE;
    psess->hflist               = NULL;
    psess->hfdi                 = NULL;
    psess->fNoLineFeed          = 0;     // TRUE if last printf did not have \n
    psess->cFiles               = 0;     // No files, yet
    psess->cbTotalBytes         = 0;     // No bytes, yet
    psess->se                   = seNONE; // No spill file error
    psess->achZap[0]            = '\0';  // No Zap pattern, yet
    psess->cArgv                = 0;    // No default self-ext cmd line
    psess->fDestructive         = FALSE; // Not truncating cab during extract

    //** Print Extract banner
    if (psess->act == actHELP) {          // Do help if any args, for now
        fwprintf(stdout, L"\n");                   // Separate banner from help

        MultiByteToWideChar( CP_THREAD_ACP, 0, pszBANNER, strlen(pszBANNER),
                             szTemp, HELP_MAX_SIZE );

        fwprintf(stderr, szTemp);
        ZeroMemory(szTemp, HELP_MAX_SIZE);
    }

    //** Parse command line,  convert command line wide char strings to LPSTR
    szArg = (LPSTR *)malloc( cArg*sizeof(LPSTR*) );
    if( NULL == szArg )
    {
        fwprintf( stderr, L"ERROR: Memory Allocation failed.\n" );
		//** Free resources
		AssertSess(psess);
		ClearAssertSignature((psess));
		MemFree(psess);
        return EXIT_FAILURE;
    }

    for(dw=0; dw<cArg; dw++ )
    {
        szTempArg =(LPSTR) malloc( wcslen(apszArg[dw] ) );
        if( NULL == szTempArg )
        {
            fwprintf( stderr, L"ERROR: Memory Allocation failed.\n" );
			if( szArg != NULL )
			{
				free(szArg );
				szArg = NULL;
			}

			//** Free resources
			AssertSess(psess);
			ClearAssertSignature((psess));
			MemFree(psess);
            return EXIT_FAILURE;
        }

        ZeroMemory( szTempArg, wcslen(apszArg[dw]) );
        if( FALSE == WideCharToMultiByte( CP_THREAD_ACP, 0, apszArg[dw], wcslen(apszArg[dw]),
                             szTempArg, wcslen(apszArg[dw]) , NULL, NULL ) )
            fwprintf( stderr, L"Error\n" );

        *(szTempArg+wcslen(apszArg[dw])) = '\0';

        szArg[dw] = szTempArg;
    }

    if (!parseCommandLine(psess,(int)cArg,szArg,&err)) {
        printError(psess,&err);
		if( szArg != NULL )
		{
			free(szArg );
			szArg = NULL;
		}

		if( szTempArg != NULL )
		{
			free(szTempArg );
			szTempArg = NULL;
		}

		//** Free resources
		AssertSess(psess);
		ClearAssertSignature((psess));
		MemFree(psess);
        return 1;
    }
/*
    //free the memory for szArg
    for( dw=0; dw<cArg; dw++ )
    {
        szTempArg = szArg[dw];
        if( szTempArg != NULL )
            free(szTempArg );
    } */
    
	if( szTempArg != NULL )
	{
		free(szTempArg );
		szTempArg = NULL;
	}

	if( szArg != NULL )
	{
		free(szArg );
		szArg = NULL;
	}

	
//  szArg = NULL;

    //** Quick out if command line help is requested
    if (psess->act == actHELP) {          // Do help if any args, for now
        fwprintf(stdout, L"\n");                   // Separate banner from help
        MultiByteToWideChar( CP_THREAD_ACP, 0, pszCMD_LINE_HELP, strlen(pszCMD_LINE_HELP),
                             szTemp, HELP_MAX_SIZE);
        fwprintf( stderr, szTemp );
		
		//** Free resources
		AssertSess(psess);
		ClearAssertSignature((psess));
		MemFree(psess);
        return 0;
    }
    ZeroMemory(szTemp, HELP_MAX_SIZE);

    //** Quick out for COPY command
    if (psess->act == actCOPY) {
        if (!doCopy(psess,&err)) {
            printError(psess,&err);
			
			//** Free resources
			AssertSess(psess);
			ClearAssertSignature((psess));
			MemFree(psess);

            return 1;
        }
        //** Success
        return 0;
    }

    //** Have some work to do -- go do it
    if (!doCabinet(psess,&err)) {
        printError(psess,&err);
        //** Make sure we delete spill file
        if (hfSpillFile != -1) {
            wrap_close(hfSpillFile);    // Close and delete it
        }
        
		//** Free resources
		AssertSess(psess);
		ClearAssertSignature((psess));
		MemFree(psess);

		return 1;
    }

    //** See if we actually got any files
    if (psess->cFiles == 0) {
        MsgSet(psess->achMsg,pszEXT_NO_MATCHING_FILES);
        MultiByteToWideChar( CP_THREAD_ACP, 0, psess->achMsg, strlen(psess->achMsg),
                             szTemp, HELP_MAX_SIZE);

        fwprintf(stderr, L"%s\n",szTemp);
        ZeroMemory(szTemp, HELP_MAX_SIZE);
    }
    else if (psess->act == actDIRECTORY) {
        //** Print out file and byte count
        MsgSet(psess->achMsg,
               psess->cFiles == 1 ? pszEXT_SUMMARY1 : pszEXT_SUMMARY2,
               "%,13ld%,13ld",
               psess->cFiles, psess->cbTotalBytes);

        MultiByteToWideChar( CP_THREAD_ACP, 0, psess->achMsg, strlen(psess->achMsg),
                             szTemp, HELP_MAX_SIZE);
        fwprintf(stdout, L"%s\n",szTemp);
        ZeroMemory(szTemp, HELP_MAX_SIZE);
    }

    //** Free resources
    AssertSess(psess);
    ClearAssertSignature((psess));
    MemFree(psess);

    //** Success
    return 0;
} /* main */


/***    doCopy - Copy one file
 *
 *  Entry:
 *      psess - Description of operation to perform
 *      perr  - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; file copied
 *
 *  Exit-Failure:
 *      Returns FALSE; error
 *
 *  NOTE:
 *      Supported SRC/DST syntax:
 *          Src     Dst     Example
 *          ----    ----    --------------------------
 *          file    dir     "foo.exe ."; "foo.exe c:\dir"
 *          file    file    "foo.exe c:bar.exe"
 */
BOOL doCopy(PSESSION psess, PERROR perr)
{
    char            achDst[cbFILE_NAME_MAX]; // Buffer for src file name
    HFILESPEC       hfspec;
    char           *pszSrc;
    char           *pszSrcJustFile;
    char           *pszDst;
    int             rc;
    struct _stat    stat;
    WCHAR           szTemp[MAX_MESSAGE_SIZE];

    //** Get the source file
    hfspec = FLFirstFile(psess->hflist);
    Assert(hfspec != NULL);
    pszSrc = FLGetSource(hfspec);
    Assert(pszSrc!=NULL);
    Assert(*pszSrc);

    //** Get the destination file
    hfspec = FLNextFile(hfspec);        // We have something
    Assert(hfspec != NULL);
    pszDst = FLGetSource(hfspec);
    Assert(pszDst!=NULL);
    Assert(*pszDst);

    //** Determine if destination is a directory
    if (-1 != _stat(pszDst,&stat)) {    // File/Dir exists
        //** Destination exists
        if (stat.st_mode & _S_IFDIR) {  // It is a directory
            //** It is a directory; get just file name and extension of source
            if (!(pszSrcJustFile = getJustFileNameAndExt(pszSrc,perr))) {
                return FALSE;
            }
            //** Construct destination name
            if (!catDirAndFile(
                     achDst,            // Buffer for full path
                     sizeof(achDst),    // Size of buffer
                     pszDst,            // Destination directory
                     pszSrcJustFile,    // File name
                     NULL,              // Don't have alternate name
                     perr)) {
                return FALSE;           // Failure
            }
            //** Use constructed name
            pszDst = achDst;
        }
    }

    //** Make sure it's OK to overwrite destination file
    if (!checkOverwrite(psess,pszDst,perr,&rc)) {
        //** Ignore skip/abort return code in rc
        return TRUE;                    // Skip file copy, everything is OK
    }

    //** Tell user we're copying the file
    MsgSet(psess->achMsg,pszEXT_EXTRACTING_FILE2,"%s%s",pszSrc,pszDst);
    MultiByteToWideChar( CP_THREAD_ACP, 0, psess->achMsg, strlen(psess->achMsg) ,
                          szTemp, MAX_MESSAGE_SIZE );
    *(szTemp+strlen(psess->achMsg)) = '\0';
    fwprintf(stdout, L"%s\n",szTemp);

    //** Do the file copy
    return CopyOneFile(pszDst,          // destination
                       pszSrc,          // source
                       TRUE,            // do the copy
                       32768U,          // copy buffer size
                       NULL,            // don't override date/time/attr
                       NULL,            // no callback context
                       perr);
} /* doCopy() */


/***    doCabinet - Show contents of one or more cabinet files
 *
 *  Entry:
 *      psess - Description of operation to perform
 *      perr  - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; directory displayed
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in with details.
 */
BOOL doCabinet(PSESSION psess, PERROR perr)
{
    char            achFile[cbFILE_NAME_MAX]; // Buffer for cabinet file
    FDICABINETINFO  fdici;
    BOOL            fCompatibilityCabinet; // TRUE => Exactly 1 file in 1 cabinet
    INT_PTR         hfCab = -1;         // File handle for peeking at cabinet
    HFILESPEC       hfspec;
    int             iCab;
    PFNFDINOTIFY    pfnfdin;
    PFNFDIDECRYPT   pfnfdid;
    char FAR       *pbMemReserve;       // Make sure we have some working mem
    char           *pszCabinet;         // Cabinet filespec
    char           *pszCabFile;         // Cabinet filename.ext
    char           *pszDestOrPattern;   // Destination or first pattern
    WCHAR          szTemp[MAX_MESSAGE_SIZE];
    //** Get the cabinet name
    hfspec = FLFirstFile(psess->hflist);
    Assert(hfspec != NULL);             // Must have at least one file
    pszCabinet = FLGetSource(hfspec);
    Assert(pszCabinet!=NULL);
    Assert(*pszCabinet);

    //** Get the destination file name or first pattern, if present
    if (NULL != (hfspec = FLNextFile(hfspec))) { // We have something
        pszDestOrPattern = FLGetSource(hfspec);
        Assert(pszDestOrPattern!=NULL);
        //** NOTE: hfspec must remain pointing to this 2nd file all the
        //         way down below where we may need to change its value!
    }
    else {
        pszDestOrPattern = NULL;        // No second argument on command line
    }

    //** Remember that we have not yet created a spill file
    hfSpillFile = -1;                   // No spill file, yet

    //** Prevent FDI from consuming all available memory
    //   Why 2048?  That's enough for 4 paths, which is more than we
    //   will ever need.
    pbMemReserve = fdiAlloc(2048);
    if (!pbMemReserve) {
        ErrSet(perr,pszFDIERR_ALLOC_FAIL,"%s",pszCabinet);
        return FALSE;
    }

    //** Create FDI context so we can get info from the cabinet file
    if (!(psess->hfdi = FDICreate(fdiAlloc,
                            fdiFree,
                            wrap_open,
                            wrap_read,
                            wrap_write,
                            wrap_close,
                            wrap_lseek,
                            cpuUNKNOWN, // Let FDI do the CPU detection
                            &(psess->erf)
                           ))) {
        //** FDICreate failed, generate error message
        mapFDIError(perr,psess,pszCabinet,&(psess->erf));
        fdiFree(pbMemReserve);          // Free reserved memory
        return FALSE;
    }
    fdiFree(pbMemReserve);              // Free it so we can use it

    //** Make sure file is a cabinet, and get cabinet info
    if (-1 == (hfCab = wrap_open(pszCabinet,_O_BINARY | _O_RDONLY,0))) {
        ErrSet(perr,pszEXTERR_CANNOT_OPEN_FILE,"%s",pszCabinet);
        goto cleanup;
    }
    if (!FDIIsCabinet(psess->hfdi,hfCab,&fdici)) {
        if (!ErrIsError(perr)) {        // Have to set error message
            ErrSet(perr,pszEXTERR_NOT_A_CABINET,"%s",pszCabinet);
        }
        goto cleanup;
    }
    wrap_close(hfCab);
    hfCab = -1;

    //** No Default Destination
    psess->achDest[0] = '\0';

    //** If no mode specified, figure out what mode we should be in:
    //
    //  The extract command has ambiguous syntax so we apply the following
    //  rules to resolve the ambiguity.
    //
    //  Most cabinet file authors use DIAMOND.EXE to create a set of
    //  cabinet files with many files in it.  A typical cabinet set would
    //  look like:
    //  (1) Cab#1
    //          foo.1
    //          foo.2
    //          foo.3 - partial
    //      Cab#2
    //          foo.3 - continued
    //          ...
    //
    //  However, there are some "old-style" customers of DIAMOND.EXE that
    //  like to compress each file independently, producing a "set" of
    //  cabinet files that each contain exactly one file, i.e.:
    //  (2) excel.ex_
    //      excel.in_
    //      setup.in_
    //
    //  The "_" character in the extension is a hint that the file is
    //  compressed.  However, this isn't useful to this program
    //
    //  Now, the question is, what does the customer want to have happen
    //  when she types "EXTRACT foo.cab bar"?  For the multi-file cabinet
    //  case (1) above, this means "seach foo.cab and extract all files
    //  that are named bar".  BUT, for the case (2), we have a compatibility
    //  constraint -- she thinks this means "extract the compressed
    //  file foo.cab and call the resulting uncompressed file bar".
    //
    //  Another question is what does the customer want to have happen
    //  when she types "EXTRACT foo.cab"?   For the multi-file cabinet
    //  case (1) above this means list the contents of the cabinet.
    //  But for case (2), we have a compatibility constraint -- customers
    //  think this means "extract the compressed file foo.cab".
    //
    //
    //  A cabinet is of type (1) if it contains more than one file,
    //  or has either a previous or next cabinet.  Otherwise, it is of
    //  type (2), i.e., the cabinet has exactly one file, and has no
    //  previous or next cabinet.

    if (psess->act == actDEFAULT) {     // No action specified on command line
        //** Determine if cabinet is of type (2) described above.
        fCompatibilityCabinet = (fdici.cFiles == 1) &&
                                (! (fdici.hasprev || fdici.hasnext));

        //** Now figure out what customer really wants
        if (pszDestOrPattern)  {        // extract foo.cab bar
            psess->act = actEXTRACT;
            if (fCompatibilityCabinet) {
                // Special Case Rename (see above (2))
                strcpy(psess->achDest, pszDestOrPattern);
                if (!FLSetSource(hfspec,pszALL_FILES,perr))  {
                    goto cleanup;
                }
            }
        } else {                        // extract foo.cab
            if (fCompatibilityCabinet) {
                // Special Case Extract (see above (2))
                psess->act = actEXTRACT;
            } else {
                psess->act = actDIRECTORY;
            }
        }
    }

    //** Supply a default pattern if no pattern is present
    if (!pszDestOrPattern) {
        if (addFileSpec(psess,pszALL_FILES,perr) == NULL) {
            ErrSet(perr,pszEXTERR_COULD_NOT_ADD_FILE,"%s",pszALL_FILES);
            goto cleanup;
        }
    }

    //** Now, select the appropriate FDI notification function
    Assert((psess->act == actEXTRACT) || (psess->act == actDIRECTORY));
    pfnfdin = (psess->act == actEXTRACT) ? fdiNotifyExt : fdiNotifyDir;
    if (fdici.fReserve) {               // Reserved area(s) present
        pfnfdid = (psess->act == actEXTRACT) ? fdiDecryptExt : fdiDecryptDir;
    }
    else {
        pfnfdid = NULL;                 // No reserved areas
    }

    //** Split cabinet spec into path and filename.ext
    pszCabFile = getJustFileNameAndExt(pszCabinet,perr);
    if (pszCabFile == NULL) {
        goto cleanup;                   // perr is already filled in
    }
    strcpy(achFile,pszCabFile);

    //** Need to trim off file name and keep just cabinet path
    strcpy(psess->achCabPath,pszCabinet);         // Store in our buffer
    psess->achCabPath[pszCabFile - pszCabinet] = '\0'; // Trim off file name

    if (psess->fDestructive) {

        //  don't do destructive extract on chained cabinets

        if ((psess->act != actEXTRACT) ||
            fdici.hasprev ||
            fdici.hasnext) {

            psess->fDestructive = FALSE;
        }
        else {
            psess->iCurrentFolder = fdici.cFolders - 1;
        }
    }

    psess->perr = perr;                 // Pass perr through FDI
    //** Do cabinets until there are no more, or an error occurs
    while ( (strlen(achFile) > 0) && !ErrIsError(perr) ) {
        //** Show which cabinet we are processing
        MsgSet(psess->achMsg,pszEXT_CABINET_HEADER,"%s",achFile);
        MultiByteToWideChar( CP_THREAD_ACP, 0, psess->achMsg, strlen( psess->achMsg ), szTemp, MAX_MESSAGE_SIZE );
        *(szTemp+strlen(psess->achMsg))  = '\0';
        fwprintf(stdout, L"\n%s\n\n",szTemp);

        strcpy(psess->achCabinetFile,achFile);

        //** Do the cabinet
        if (!FDICopy(psess->hfdi,       // FDI context
                     achFile,           // Cabinet file name.ext
                     psess->achCabPath, // Path to cabinet
                     0,                 // Flags (???)
                     pfnfdin,           // Notifcation callback
                     pfnfdid,           // Decrypt callback
                     psess              // Our context
                    )) {
            //** NOTE: psess->achCabPath *may* get changed during an
            //         fdintNEXT_CABINET callback if we had to prompt the
            //         use for a different path!

            //** FDICopy failed, construct error message
            if (!ErrIsError(perr)) {    // Need to set error message
                //** Construct error message
                mapFDIError(perr,psess,psess->achCabinetFile,&(psess->erf));

                //** Delete file if created, with the assumption that
                //   we were not able to completely write the file
                //   (for example, if the destination disk ran out of space!)
                if (psess->erf.erfOper == FDIERROR_TARGET_FILE) {
                    //** Ignore errors, if any
                    _unlink(psess->achFile);
                }
            }
        }
        else {
            //** OK so far, see if any more cabinets to process
            if (psess->fDestructive) {
                if (psess->iCurrentFolder != 0) {
                    FDITruncateCabinet(psess->hfdi,
                        pszCabinet,
                        psess->iCurrentFolder);
                    psess->iCurrentFolder--; // move down to next folder
                }
                else {
                    _unlink(pszCabinet);    // delete the CAB!
                    achFile[0] = '\0';      // Done
                }
            }
            else if (psess->fAllCabinets) {
                //** Skip "starts in ..." messages for subsequent cabinets
                psess->fContinuationCabinet = TRUE;

                //** Copy next cabinet file (ach[] is empty if no more!)
                iCab = psess->fNextCabCalled ? 0 : 1; // Select correct cabinet
                strcpy(achFile,psess->acab[iCab].achCabFilename);
                strcpy(psess->achCabinetFile,achFile);
                psess->fNextCabCalled = FALSE; // Reset flag

                //** If there is another cabinet to process, make sure it
                //   is available; psess->achCabPath may be edited if we
                //   can't find the cabinet until the user supplies another
                //   path; perr will be set if an error occurs.
                if (achFile[0] != '\0') { // Another cabinet
                    ensureCabinet(psess,
                                  psess->achCabPath,
                                  sizeof(psess->achCabPath),
                                  achFile,
                                  psess->acab[iCab].achDiskName,
                                  psess->acab[iCab].setID,
                                  (USHORT)(psess->acab[iCab].iCabinet+1),
                                  TRUE,  // Loop until right cab or abort
                                  FALSE, // Check cabinet
                                  perr);
                }
            }
            else {
                achFile[0] = '\0';      // Done
            }
        }
    }

cleanup:
    if (hfCab != -1) {
        wrap_close(hfCab);
    }

    if (!FDIDestroy(psess->hfdi)) {
        //** Only set error if we don't already have one
        if (!ErrIsError(perr)) {
            ErrSet(perr,pszEXTERR_FDIDESTROY_FAILED);
        }
    }
    psess->perr = NULL;

    //** Return success/failure indication
    return !ErrIsError(perr);
} /* doCabinet() */


/***    fdiNotifyDir - Callback from FDICopy for Directory display
 *
 *  Entry:
 *      fdint - type of notification
 *      pfdin - data for notification
 *
 *  Exit-Success:
 *      Return value varies (see FDI.H:PFNFDINOTIFY type)
 *
 *  Exit-Failure:
 *      Return value varies (see FDI.H:PFNFDINOTIFY type)
 */
FNFDINOTIFY(fdiNotifyDir)
{
    char        achAttr[10];
    PERROR      perr;
#ifdef SMALL_DOS
    PSESSION    psess=(PSESSION)(void *)(short)(long)pfdin->pv;
    char        szLocal[cbFILE_NAME_MAX];
#else
    PSESSION    psess=(PSESSION)pfdin->pv;
#endif
    WCHAR       szTemp[MAX_MESSAGE_SIZE];

    AssertSess(psess);
    perr = psess->perr;

    switch (fdint) {
    case fdintCABINET_INFO:
        return updateCabinetInfo(psess,pfdin);

    case fdintCOPY_FILE:
        //** See if filspec matches specified patterns
#ifdef SMALL_DOS
    _fstrcpy(szLocal,pfdin->psz1);
#else
#define szLocal pfdin->psz1
#endif
        if (!checkWildMatches(psess,szLocal,perr)) {
            //** Either no match, or failure -- figure out which
            if (ErrIsError(perr)) {
                return -1;              // Error, abort
            }
            else {
                return 0;               // No error, skip this file
            }
        }

        //** Show directory
        pszFromMSDOSTime(psess->achMsg,
                         sizeof(psess->achMsg),
                         pfdin->date,
                         pfdin->time);
        pszFromAttrFAT(achAttr, sizeof(achAttr), pfdin->attribs);
        MsgSet(psess->achLine,
               pszEXT_FILE_DETAILS,
#ifdef SMALL_DOS
               "%s%s%,13ld%-Fs",
#else
               "%s%s%,13ld%-s",
#endif
               psess->achMsg,achAttr,pfdin->cb,pfdin->psz1);
        MultiByteToWideChar( CP_THREAD_ACP, 0, psess->achLine, strlen(psess->achLine),
                             szTemp, MAX_MESSAGE_SIZE );
        *(szTemp+strlen(psess->achLine)) = '\0';
        fwprintf( stdout,L"%s\n",szTemp );

        psess->cFiles++;
        psess->cbTotalBytes += pfdin->cb;
        return 0;                       // Skip file, do not copy

    case fdintPARTIAL_FILE:
        //** Construct output filespec
#ifdef SMALL_DOS
    _fstrcpy(szLocal,pfdin->psz1);
#else
#define szLocal pfdin->psz1
#endif

        //** See if filspec matches specified patterns
        if (!checkWildMatches(psess,szLocal,perr)) {
            //** Either no match, or failure -- figure out which
            if (ErrIsError(perr)) {
                return -1;              // Error, abort
            }
            else {
                return 0;               // No error, skip this file
            }
        }

        //** Only show partial file messages for first cabinet
        if (!psess->fContinuationCabinet) { // First cabinet
            MsgSet(psess->achMsg,pszEXT_PARTIAL_FILE,
#ifdef SMALL_DOS
                "%Fs%Fs%Fs",
#else
                "%s%s%s",
#endif
                    pfdin->psz1,pfdin->psz2,pfdin->psz3);
        //do the localization print the message
        MultiByteToWideChar( CP_THREAD_ACP, 0, psess->achLine, strlen(psess->achLine),
                             szTemp, MAX_MESSAGE_SIZE );
        *(szTemp+strlen(psess->achLine)) = '\0';
        fwprintf( stdout,L"%s\n",szTemp );


            fwprintf( stdout, L"%s\n",szTemp);
        }
        return 0;                       // Continue

    case fdintNEXT_CABINET:
        return doGetNextCab(fdint,pfdin);

    case fdintENUMERATE:
        return 0;

    default:
        fwprintf(stdout, L"UNKNOWN NOTIFICATION: %d\n",fdint);
        return 0;   /* ??? */
    }
} /* fdiNotifyDir() */


/***    fdiNotifyExt - Callback from FDICopy for file extraction
 *
 *  <<< Extract files! >>>
 *
 *  Entry:
 *      fdint - type of notification
 *      pfdin - data for notification
 *
 *  Exit-Success:
 *      Return value varies (see FDI.H:PFNFDINOTIFY type)
 *
 *  Exit-Failure:
 *      Return value varies (see FDI.H:PFNFDINOTIFY type)
 */
FNFDINOTIFY(fdiNotifyExt)
{
    INT_PTR         fh;
    FILETIMEATTR    fta;
    PERROR          perr;
    char           *pszDestinationFile;
    int             rc;
#ifdef SMALL_DOS
    PSESSION        psess=(PSESSION)(void *)(short)(long)pfdin->pv;
    char            szLocal[cbFILE_NAME_MAX];
#else
    PSESSION        psess=(PSESSION)pfdin->pv;
#endif
    WCHAR           szTemp[MAX_MESSAGE_SIZE];
    AssertSess(psess);
    perr = psess->perr;

    //** Reset the spill file error code;
    //   We know that FDI is OK right now if it is asking us if we want
    //   to extract this file, so reset the spill file error code.  If
    //   we did not, then it may have seNOT_ENOUGH_MEMORY (for example)
    //   as a result of Quantum trying to eat up all available memory,
    //   and a real decompression failure would be reported as an out
    //   of memory problem.
    psess->se = seNONE;

    switch (fdint) {
    case fdintCABINET_INFO:
        return updateCabinetInfo(psess,pfdin);

    case fdintCOPY_FILE:

        if (psess->fDestructive && (pfdin->iFolder != psess->iCurrentFolder)) {
            return(0);  // only do files in the current folder
        }

        //** Construct output filespec
#ifdef SMALL_DOS
    _fstrcpy(szLocal,pfdin->psz1);
#else
#define szLocal pfdin->psz1
#endif
        //** See if filspec matches specified patterns
        if (!checkWildMatches(psess,szLocal,perr)) {
            //** Either no match, or failure -- figure out which
            if (ErrIsError(perr)) {
                return -1;              // Error, abort
            }
            else {
                return 0;               // No error, skip this file
            }
        }

        //** Figure out what destination file name should be
        if (psess->achDest[0] != '\0') { // Override name from cabinet
            pszDestinationFile = psess->achDest;
        }
        else {
            pszDestinationFile = szLocal;
        }

        if (psess->achZap[0] != '\0')   // if prefix-zapping
        {
            if (!strncmp(pszDestinationFile,psess->achZap,strlen(psess->achZap)))
            {
                pszDestinationFile += strlen(psess->achZap);
            }
        }

        //** Construct full destination file name
        if (!catDirAndFile(psess->achFile,      // Buffer for output filespec
                           sizeof(psess->achFile), // Size of output buffer
                           psess->achLocation,  // Output directory
                           pszDestinationFile,  // Output file name
                           NULL,                // Don't have alternate name
                           perr)) {
            return -1;                  // Abort with error;
        }

        //** Make sure output directory exists
        if (!ensureDirectory(psess->achFile,TRUE,perr)) {
            return -1;                  // perr already filled in
        }

        //** Do overwrite processing
        if (!checkOverwrite(psess,psess->achFile,perr,&rc)) {
            return rc;                  // Either Skip or Abort
        }

        //** Create file
        fh = wrap_open(psess->achFile,
                    _O_BINARY | _O_RDWR | _O_CREAT | _O_TRUNC, // No translation, R/W
                    _S_IREAD | _S_IWRITE); // Attributes when file is closed
        if (fh == -1) {
            ErrSet(psess->perr,pszEXTERR_CANNOT_CREATE_FILE,"%s",psess->achFile);
            return -1;                  // Failure
        }

#if 0
        // jforbes: if'd this out, added _O_TRUNC above

        //** Truncate file (in case it already existed and was larger)
        if (0 != _chsize(fh, 0)) {
            //** Not the best error, but avoids more localization!
            ErrSet(psess->perr,pszEXTERR_CANNOT_CREATE_FILE,"%s",psess->achFile);
            wrap_close(fh);
        }
#endif

        //** Show status
        if (pszDestinationFile == szLocal) {  // File name is not changed
            MsgSet(psess->achMsg,pszEXT_EXTRACTING_FILE,"%s",psess->achFile);
        }
        else {                          // Destination file is different
            MsgSet(psess->achMsg,pszEXT_EXTRACTING_FILE2,"%s%s",
                    szLocal,psess->achFile);
        }

        //add the multibyte conversion
        MultiByteToWideChar( CP_THREAD_ACP, 0, psess->achMsg, strlen(psess->achMsg),
                             szTemp, strlen(psess->achMsg) );
        *(szTemp+strlen(psess->achMsg)) = '\0';
        fwprintf( stdout,L"%s\n",szTemp );
        psess->fNoLineFeed = TRUE;
        psess->cFiles++;
        psess->cbTotalBytes += pfdin->cb;
        return fh;                      // Return open file handle

    case fdintCLOSE_FILE_INFO:
        //** Close the file
        wrap_close(pfdin->hf);

        //** Construct output filespec
#ifdef SMALL_DOS
    _fstrcpy(szLocal,pfdin->psz1);
#else
#define szLocal pfdin->psz1
#endif

        //** Figure out what destination file name should be
        if (psess->achDest[0] != '\0') { // Override name from cabinet
            pszDestinationFile = psess->achDest;
        }
        else {
            pszDestinationFile = szLocal;
        }

        if (psess->achZap[0] != '\0')   // if prefix-zapping
        {
            if (!strncmp(pszDestinationFile,psess->achZap,strlen(psess->achZap)))
            {
                pszDestinationFile += strlen(psess->achZap);
            }
        }

        //** Construct full destination file name
        if (!catDirAndFile(psess->achFile,      // Buffer for output filespec
                           sizeof(psess->achFile), // Size of output buffer
                           psess->achLocation,  // Output directory
                           pszDestinationFile,  // Output file name
                           NULL,                // Don't have alternate name
                           perr)) {
            return FALSE;               // Abort with error
        }


        //** Set file date, time, and attributes
        fta.date = pfdin->date;
        fta.time = pfdin->time;
        fta.attr = pfdin->attribs &
                    (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
        if (!SetFileTimeAndAttr(psess->achFile, &fta, perr)) {
            return FALSE;               // Abort with error
        }
        return TRUE;                    // Success

    case fdintPARTIAL_FILE:
        //** Construct output filespec
#ifdef SMALL_DOS
    _fstrcpy(szLocal,pfdin->psz1);
#else
#define szLocal pfdin->psz1
#endif
        //** See if filspec matches specified patterns
        if (!checkWildMatches(psess,szLocal,perr)) {
            //** Either no match, or failure -- figure out which
            if (ErrIsError(perr)) {
                return -1;              // Error, abort
            }
            else {
                return 0;               // No error, skip this file
            }
        }

        //** Only show partial file messages for first cabinet
        if (!psess->fContinuationCabinet) { // First cabinet
            MsgSet(psess->achMsg,pszEXT_PARTIAL_FILE,
#ifdef SMALL_DOS
                "%Fs%Fs%Fs",
#else
                "%s%s%s",
#endif
                    pfdin->psz1,pfdin->psz2,pfdin->psz3);
            printf("%s\n",psess->achMsg);
        }
        return 0;                       // Continue

    case fdintNEXT_CABINET:
        return doGetNextCab(fdint,pfdin);

    case fdintENUMERATE:
        return 0;

    default:
        printf("UNKNOWN NOTIFICATION: %d\n",fdint);
        return 0;   /* ??? */
    }
} /* fdiNotifyExt() */


/***    checkOverwrite - Check for file existence and do overwrite processing
 *
 *  Entry:
 *      psess       - Session
 *      pszFile     - File to check
 *      perr        - Error structure
 *      prc         - Gets return code
 *
 *  Exit-Success:
 *      Returns TRUE; file can be overwritten
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in if error,
 *      *prc ==  0 -> Skip file
 *      *prc == -1 -> Abort
 */
BOOL checkOverwrite(PSESSION  psess,
                    char     *pszFile,
                    PERROR    perr,
                    int      *prc)
{
    char            ch;
    BOOL            fGotReply;
    BOOL            fOverwrite;
    BOOL            fOverwriteAll;
    struct _stat    stat;

    //** Check to see if file already exists
    if (-1 == _stat(pszFile,&stat)) {   // File does not exist
        return TRUE;                    // Write it
    }

    //** Prompt if we're supposed to
    if (!psess->fOverwrite) {
        //** Display prompt -- no CR/LF
        MsgSet(psess->achMsg,pszEXT_OVERWRITE_PROMPT,"%s",pszFile);
        printf("%s",psess->achMsg);

        //** Get valid single character response and ENTER key;
        //      any illegal keys are just ignored
        fGotReply = FALSE;
        while (!fGotReply || (ch != '\r')) {
            ch = (char)_getch();              // Get a keystroke
            switch (toupper(ch)) {

            case chOVERWRITE_YES:
                fGotReply     = TRUE;
                fOverwrite    = TRUE;
                fOverwriteAll = FALSE;
                printf("%c\b",ch);      // Echo character and backspace over it
                break;

            case chOVERWRITE_NO:
                fGotReply     = TRUE;
                fOverwrite    = FALSE;
                fOverwriteAll = FALSE;
                printf("%c\b",ch);      // Echo character and backspace over it
                break;

            case chOVERWRITE_ALL:
                fGotReply     = TRUE;
                fOverwrite    = TRUE;
                fOverwriteAll = TRUE;
                printf("%c\b",ch);      // Echo character and backspace over it
                break;

            default:
                break;                  // Ignore character
            }
        }

        //** Do the line feed
        printf("\n");

        //** Respect user's wish
        if (!fOverwrite) {              // Don't overwrite file
            *prc = 0;                   // Indicate skip
            return FALSE;
        }
        else {                          // Overwrite once or all
            psess->fOverwrite = fOverwriteAll; // Set accordingly
        }
    }

    //** Make sure file is writeable, if it isn't already
    if (!(stat.st_mode & _S_IWRITE)) {   // File is not writeable
        _chmod(pszFile, _S_IREAD | _S_IWRITE);
        //** Ignore error code, because the open will fail and catch it
    }

    //** Done
    return TRUE;                        // Overwrite that file
} /* checkOverwrite() */


/***    updateCabinetInfo - update history of cabinets seen
 *
 *  Entry:
 *      psess - Session
 *      pfdin - FDI info structurue
 *
 *  Exit:
 *      Returns 0;
 */
int updateCabinetInfo(PSESSION psess, PFDINOTIFICATION pfdin)
{
    AssertSess(psess);

    //** Save older cabinet info
    psess->acab[0] = psess->acab[1];

    //** Save new cabinet info
    STRCPY(psess->acab[1].achCabPath     ,pfdin->psz3);
    STRCPY(psess->acab[1].achCabFilename ,pfdin->psz1);
    STRCPY(psess->acab[1].achDiskName    ,pfdin->psz2);
    psess->acab[1].setID    = pfdin->setID;
    psess->acab[1].iCabinet = pfdin->iCabinet;
    return 0;
}


/***    ensureCabinet - Make sure desired cabinet is available
 *
 *  Make sure requested cabinet is available.
 *
 *  Entry:
 *      psess       - Session
 *      pszPath     - Path buffer (modified if necessary on output)
 *      cbPath      - Size of path buffer
 *      pszFile     - Cabinet file name
 *      pszLabel    - Label for disk with cabinet file
 *      setID       - setID for cabinet
 *      iCabinet    - iCabinet for cabinet
 *      fLoop       - TRUE => Loop until right cabinet or user aborts
 *                    FALSE => Only try once
 *      fPromptOnly - TRUE => Caller knows cabinet is bad, just prompt
 *                    FALSE => Check cabinet, prompt if necessary
 *      perr        - Error structure
 *
 *  Exit-Success:
 *      Returns TRUE; desired cabinet is present
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in.
 *      Returns -1; user aborted
 */
BOOL ensureCabinet(PSESSION  psess,
                   char     *pszPath,
                   int       cbPath,
                   char     *pszFile,
                   char     *pszLabel,
                   USHORT    setID,
                   USHORT    iCabinet,
                   BOOL      fLoop,
                   BOOL      fPromptOnly,
                   PERROR    perr)
{
    char            ach[cbFILE_NAME_MAX];
    int             cch;
    int             cLoop=0;
    char            chDrive;
    BOOL            fCabinetExists;
    FDICABINETINFO  fdici;
    INT_PTR         hfCab;
    char            ch;
    int             i=0;

    AssertSess(psess);

    do {
        cLoop++;                        // Count loops
        ErrClear(perr);         // Make sure no error is set
        //** Construct fully qualified cabinet file path
        if (!catDirAndFile(ach,         // Buffer for output filespec
                           sizeof(ach), // Size of output buffer
                           pszPath,     // Path
                           pszFile,     // Filename
                           NULL,        // Don't have alternate name
                           perr)) {
            return FALSE;               // Abort with error
        }

        //** Check cabinet only if asked
        if (!fPromptOnly) {
            //** Make sure cabinet is the one we want
            if (-1 == (hfCab = wrap_open(ach,_O_BINARY | _O_RDONLY,0))) {
                ErrSet(perr,pszEXTERR_CANNOT_OPEN_FILE,"%s",ach);
            }
            else if (!FDIIsCabinet(psess->hfdi,hfCab,&fdici)) {
                if (!ErrIsError(perr)) {        // Have to set error message
                    ErrSet(perr,pszEXTERR_NOT_A_CABINET,"%s",ach);
                }
            }
            else if ((fdici.setID    != setID) ||
                     (fdici.iCabinet != iCabinet)) {
                ErrSet(perr,pszFDIERR_WRONG_CABINET,"%s",ach);
            }

            //** Close the cabinet file (if we got it opened)
            if (hfCab != -1) {
                wrap_close(hfCab);
                fCabinetExists = TRUE;
            }
            else {
                fCabinetExists = FALSE;
            }

            //** Did we get the cabinet we wanted?
            if (!ErrIsError(perr)) {
                return TRUE;                // Yup, return success
            }

            //** Don't show message if first time and cabinet not there,
            //   since this is the common case cabinets on separate floppy
            //   disks, and we don't want to whine before we ask them to
            //   insert the right floppy.
            //
            if ((cLoop > 1) || fCabinetExists) {
                MsgSet(psess->achMsg,pszEXTERR_ERROR,"%s",perr->ach);
                printf("\n%s\n",psess->achMsg);
            }
        }

        //** Tell user what we want
        if (IsPathRemovable(ach,&chDrive)) {
            MsgSet(psess->achMsg,pszEXT_FLOPPY_PROMPT,"%s%s%c",
                    pszFile,pszLabel,chDrive);
        }
        else {
            MsgSet(psess->achMsg,pszEXT_NOFLOPPY_PROMPT,"%s%s%c",
                    pszFile,pszLabel);
        }
        printf("%s\n",psess->achMsg);

        //** Get response
         do
         {
               ch = getchar();
               ach[i++]=ch;
               if( i >= cbFILE_NAME_MAX )
                   break;

          }while( ch!='\n' );
          ach[i-1]=0;
/*
        if (!gets(ach)) {                   // Error or EOF
            ErrSet(perr,pszEXTERR_ABORT);
            return -1;                      // User abort
        }
*/
        if (strlen(ach) > 0) {
            strcpy(pszPath,ach);            // Update path
            cch = strlen(pszPath);
            //** Make sure path has path separator, since FDI requires it
            cch += appendPathSeparator(&(pszPath[cch-1]));

            //** Update path for next FDICopy() call!
            if (cch >= sizeof(psess->achCabPath)) {
                Assert(0);
                return -1;              // Path too big
            }
            strcpy(psess->achCabPath,pszPath);
        }
    }
    while (fLoop);
    //** Did not guarantee desired cabinet
    return FALSE;
} /* ensureCabinet() */


/***    doGetNextCab - Get next cabinet
 *
 *  Make sure requested cabinet is available.
 *
 *  Entry:
 *      fdint - type of notification
 *      pfdin - data for notification
 *
 *  Exit-Success:
 *      Returns anything but -1;
 *
 *  Exit-Failure:
 *      Returns -1 => abort FDICopy() call.
 */
FNFDINOTIFY(doGetNextCab)
{
    char        ach[cbFILE_NAME_MAX];
    static int  cErrors=0;          // Count of errors for single attempt
    PERROR      perr;
    int         rc;

#ifdef SMALL_DOS
    PSESSION    psess=(PSESSION)(void *)(short)(long)pfdin->pv;
    static char szCabPath[cbFILE_NAME_MAX];
    static char szCabFile[cbFILE_NAME_MAX];
    static char szCabLabel[cbFILE_NAME_MAX];
#else
    PSESSION    psess=(PSESSION)pfdin->pv;
#endif

    AssertSess(psess);
    perr = psess->perr;

#ifdef SMALL_DOS
    _fstrcpy(psess->achCabinetFile,pfdin->psz1);
#else
    strcpy(psess->achCabinetFile,pfdin->psz1);
#endif

    //** Skip "starts in ..." messages for subsequent cabinets
    psess->fContinuationCabinet = TRUE;

    //** Keep track of GetNextCabinet calls so we can determine
    //   what cabinet to expect next.
    psess->fNextCabCalled = TRUE;

    //** If there is no problem to report, just let FDI do the checks
    if (pfdin->fdie == FDIERROR_NONE) {
        cErrors = 0;
        return 0;
    }

    //** If FDI didn't get the correct cabinet last time it called us,
    //   it calls us again with a specific error code.  Tell the user
    //   something intelligible.
    //
    //   pfdin->psz1 = cabinet filename
    //   pfdin->psz2 = disk user-readable name
    //   pfdin->psz3 = current cabinet path

#ifdef SMALL_DOS
    _fstrcpy(szCabFile ,pfdin->psz1);
    _fstrcpy(szCabLabel,pfdin->psz2);
    _fstrcpy(szCabPath ,pfdin->psz3);
#else
#define szCabFile  pfdin->psz1
#define szCabLabel pfdin->psz2
#define szCabPath  pfdin->psz3
#endif

    cErrors++;                          // Count of errors on this cabinet
    switch (pfdin->fdie) {
    case FDIERROR_USER_ABORT:
        Assert(0);  //** Should never be called with this error code
        break;

    default:
        //** Construct full path name of cabinet
        if (!catDirAndFile(ach,         // Buffer for output filespec
                           sizeof(ach), // Size of output buffer
                           szCabPath,   // Path
                           szCabLabel,  // Filename s/b szCabFile?
                           NULL,        // Don't have alternate name
                           perr)) {
            return -1;                  // Abort with error
        }
        //** Construct error string
        mapFDIError(perr,psess,ach,&(psess->erf));
        //** Reset error
        psess->erf.erfOper = FDIERROR_NONE;
    } /* switch */

    //** Tell user what the problem is, except in the case where the
    //   file was not found *and* this was the first try at finding
    //   the cabinet.
    if ((cErrors > 1) || (pfdin->fdie != FDIERROR_CABINET_NOT_FOUND)) {
        MsgSet(psess->achMsg,pszEXTERR_ERROR,"%s",perr->ach);
        printf("\n%s\n",psess->achMsg);
    }

    //** Tell user to swap disks or type in new path
    rc = ensureCabinet(psess,
                       szCabPath,       // cabinet path
                       cbFILE_NAME_MAX,
                       szCabFile,       // cabinet file name
                       szCabLabel,      // User-readable label
                       pfdin->setID,    // Required setID
                       pfdin->iCabinet, // Required iCabinet
                       FALSE,           // Do not loop
                       TRUE,            // Skip check, just prompt
                       perr);

#ifdef SMALL_DOS
    //** Copy possibly modified cabinet path back to FDI structure
    _fstrcpy(pfdin->psz3,szCabPath);
#endif

    //** Return result
    return rc;
} /* doGetNextCab() */


/***    fdiDecryptDir - Callback from FDICopy for decryption
 *
 *  <<< Just indicate calls made >>>
 *
 *  NOTE: See fdi.h for details.
 *
 *  Entry:
 *      pfdid - data for decryption
 *
 *  Exit-Success:
 *      Return TRUE;
 *
 *  Exit-Failure:
 *      Return -1;
 */
FNFDIDECRYPT(fdiDecryptDir)
{
    PERROR      perr;
#ifdef SMALL_DOS
    PSESSION    psess=(PSESSION)(void *)(short)(long)pfdid->pvUser;
#else
    PSESSION    psess=(PSESSION)pfdid->pvUser;
#endif

    AssertSess(psess);
    perr = psess->perr;

    //** Bail out if we're not supposed to show info
    if (!psess->fShowReserveInfo) {
        return TRUE;
    }

    switch (pfdid->fdidt) {
        case fdidtNEW_CABINET:
            MsgSet(psess->achMsg,pszEXT_DECRYPT_HEADER,
                   "%08lx%u%x%d",
                   pfdid->cabinet.pHeaderReserve,
                   pfdid->cabinet.cbHeaderReserve,
                   pfdid->cabinet.setID,
                   pfdid->cabinet.iCabinet);
            printf("%s\n",psess->achMsg);
            break;

        case fdidtNEW_FOLDER:
            MsgSet(psess->achMsg,pszEXT_DECRYPT_FOLDER,
                   "%08lx%u%d",
                   pfdid->folder.pFolderReserve,
                   pfdid->folder.cbFolderReserve,
                   pfdid->folder.iFolder);
            printf("%s\n",psess->achMsg);
            break;

        case fdidtDECRYPT:
            MsgSet(psess->achMsg,pszEXT_DECRYPT_DATA,
                   "%08lx%u%08lx%u%d%u",
                   pfdid->decrypt.pDataReserve,
                   pfdid->decrypt.cbDataReserve,
                   pfdid->decrypt.pbData,
                   pfdid->decrypt.cbData,
                   pfdid->decrypt.fSplit,
                   pfdid->decrypt.cbPartial);
            printf("%s\n",psess->achMsg);
            break;

        default:
            printf("UNKNOWN DECRYPT COMMAND: %d\n",pfdid->fdidt);
            return -1;                      // Abort
    };
    return TRUE;
} /* fdiDecryptDir() */


/***    fdiDecryptExt - Callback from FDICopy for real decryption
 *
 *  NOTE: See fdi.h for details.
 *
 *  Entry:
 *      pfdid - data for decryption
 *
 *  Exit-Success:
 *      Return TRUE;
 *
 *  Exit-Failure:
 *      Return -1;
 */
FNFDIDECRYPT(fdiDecryptExt)
{
    return fdiDecryptDir(pfdid);
} /* fdiDecryptExt() */


/***    checkWildMatchs - Check filespec against list of filespec patterns
 *
 *  Entry:
 *      psess   - SESSION -- has list of filespec patterns
 *      pszFile - Filespec to test (may have path characters)
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE, pszFile matched a pattern
 *
 *  Exit-Failure:
 *      Returns FALSE, pszFile did not match a pattern -or- an error occurred.
 *      Use ErrIsError(perr) to determine if an error occured.
 *
 *  11/12/99 msliger Added PatternMatch().  For backwards compatibility,
 *      if the given wildspec contained no path separators, use only the
 *      base filename/extension.  If path separators exist in the
 *      wildspec, use the full pathname from the cab.
 *      FEATURE: PatternMatch is not MBCS-enabled.  But then, even with the
 *      CharIncr() refinements, the existing IsWildMatch didn't work either
 *      (trail bytes were not compared.)
 */
BOOL checkWildMatches(PSESSION psess, char *pszFile, PERROR perr)
{
    HFILESPEC   hfspec;                 // Use to walk list of file patterns
    char       *pszNameExt;             // Name.Ext piece
    char       *pszWild;                // Filespec pattern
    int         fAllowImpliedDot;       // TRUE iff no dot in base name
    char       *psz;                    // either pszNameExt or pszFile

    //** Get name.ext piece
    pszNameExt = getJustFileNameAndExt(pszFile,perr);
    if (!pszNameExt) {
        return FALSE;                   // perr already filled in
    }

    if (strchr(pszNameExt, '.') == NULL)
    {
        fAllowImpliedDot = TRUE;        // allows *.* to match "hosts"
    }
    else
    {
        fAllowImpliedDot = FALSE;       // base name has it's own dot
    }

    //** Loop through list of filespec patterns
    hfspec = FLFirstFile(psess->hflist);
    Assert(hfspec != NULL);             // Skip over cabinet filespec
    hfspec = FLNextFile(hfspec);
    Assert(hfspec != NULL);             // First wildcard spec
    while (hfspec != NULL) {            // Check patterns
        pszWild = FLGetSource(hfspec);
        Assert(pszWild!=NULL);
        Assert(*pszWild);
        if (strchr(pszWild, '\\') == NULL) { // path in wildspec?
            psz = pszNameExt;           // no path, match base name
        } else {
            psz = pszFile;              // path given, match full name
            if (*pszWild == '\\') {
                pszWild++;              // implied leading '\' in CAB
            }
        }
        if (PatternMatch(psz,pszWild,fAllowImpliedDot)) {
            return TRUE;                // Got a match!
        }
        hfspec = FLNextFile(hfspec);    // Try next pattern
    }

    //** Failure -- none of the patterns matched
    return FALSE;
} /* checkWildMatches() */


/***    fdiAlloc - memory allocator for FDI
 *
 *  Entry:
 *      cb - size of block to allocate
 *
 *  Exit-Success:
 *      returns non-NULL pointer to block of size at least cb.
 *
 *  Exit-Failure:
 *      returns NULL
 */
FNALLOC(fdiAlloc)
{
    void HUGE *pv;

    //** Do allocation
#ifdef  BIT16
    pv = _halloc(cb,1);     // Use 16-bit function
#else // !BIT16
    pv = malloc(cb);        // Use 32-bit function
#endif // !BIT16

    //** Remember if error occured, to improve quality of error messages
    if (pv == NULL) {
        psessG->se = seNOT_ENOUGH_MEMORY;
    }

    //** Return buffer (or failure indication)
    return pv;
} /* fdiAlloc() */


/***    fdiFree - memory free function for FDI
 *
 *  Entry:
 *      pv - memory allocated by fciAlloc to be freed
 *
 *  Exit:
 *      Frees memory
 */
FNFREE(fdiFree)
{
#ifdef  BIT16
    //** Use 16-bit function
    _hfree(pv);
#else // !BIT16
    //** Use 32-bit function
    free(pv);
#endif // !BIT16
}


/***    STATELOC - States for /L (location) parsing
 *
 */
typedef enum {
    slNONE,                         // No /L seen
    slEXPECTING,                    // Just saw /L, need a location
    slGOT,                          // We have parsed "/L location"
} STATELOC; /* sl */


/***    parseCommandLine - Parse the command line arguments
 *
 *  Entry:
 *      psess   - SESSION
 *      cArg    - Count of arguments, including program name
 *      apszArg - Array of argument strings
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE, psess filled in.
 *
 *  Exit-Failure:
 *      Returns actBAD, perr filled in with error.
 */
BOOL parseCommandLine(PSESSION psess, int cArg, char *apszArg[], PERROR perr)
{
    int         cFile=0;        // Count of non-directive file names seen
    int         ch;             // Switch value
    int         i;
    char       *pch;
    STATELOC    sl=slNONE;      // Location parsing state

    AssertSess(psess);
    psess->act = actDEFAULT;            // We don't know what we are doing; yet
    psess->achLocation[0] = '\0';       // Default to current directory

    //** Empty file handle table
    for (i=0; i<cMAX_CAB_FILE_OPEN; i++) {
        psess->ahfSelf[i] = -1;     // No open handle
    }

    //** See if we are a self-extracting cabinet
    if (!checkSelfExtractingCab(psess,cArg,apszArg,perr)) {
        return FALSE;                   // An error occurred, perr filled in
    }
    if (psess->fSelfExtract) {
        if ((cArg < 2) && (psess->cArgv > 1)) {
            cArg = psess->cArgv;
            apszArg = psess->pArgv;
        }
        if (addFileSpec(psess,psess->achSelf,perr) == NULL) {
            ErrSet(perr,pszEXTERR_COULD_NOT_ADD_FILE,"%s",psess->achSelf);
            return FALSE;
        }
        cFile++;                        // Count files

    }

    //** Parse args, skipping program name
    for (i=1; i<cArg; i++) {
        if ((apszArg[i][0] == chSWITCH1) ||
            (apszArg[i][0] == chSWITCH2) ) {
            //** Have a switch to parse, make sure switch is OK here
            if (sl == slEXPECTING) {
                ErrSet(perr,pszEXTERR_MISSING_LOCATION);
                return FALSE;
            }

            //** Process switches (support string to ease typing)
            for (pch=&apszArg[i][1]; *pch; pch++) {
                ch = toupper(*pch);         // Switch character
                switch (ch) {
                    case chSWITCH_HELP:
                        psess->act = actHELP;       // Show help
                        return TRUE;

                    case chSWITCH_ALL:
                        psess->fAllCabinets = TRUE;
                        break;

                    case chSWITCH_COPY:
                        if (psess->act != actDEFAULT) {
                            ErrSet(perr,pszEXTERR_CONFLICTING_SWITCH,"%c",*pch);
                            return FALSE;
                        }
                        psess->act = actCOPY;
                        break;

                    case chSWITCH_DIRECTORY:
                        if (psess->act != actDEFAULT) {
                            ErrSet(perr,pszEXTERR_CONFLICTING_SWITCH,"%c",*pch);
                            return FALSE;
                        }
                        psess->act = actDIRECTORY;
                        break;

                    case chSWITCH_EXTRACT:
                        if (psess->act != actDEFAULT) {
                            ErrSet(perr,pszEXTERR_CONFLICTING_SWITCH,"%c",*pch);
                            return FALSE;
                        }
                        psess->act = actEXTRACT;
                        break;

                    case chSWITCH_LOCATION:
                        //** Make sure we only got location once
                        if (sl == slGOT) {
                            ErrSet(perr,pszEXTERR_LOCATION_TWICE);
                            return FALSE;
                        }
                        sl = slEXPECTING;
                        break;

                    case chSWITCH_OVERWRITE:
                        psess->fOverwrite = TRUE;
                        break;

                    case chSWITCH_RESERVE:
                        psess->fShowReserveInfo = TRUE;
                        break;

                    case chSWITCH_ZAP:
                        pch++;
                        if (*pch == '\0')
                        {
                            if ((i+1) < cArg)
                            {
                                pch = apszArg[++i];
                            }
                            else
                            {
                                ErrSet(perr,pszEXTERR_MISSING_LOCATION);
                                return(FALSE);
                            }
                        }
                        strcpy(psess->achZap,pch);
                        pch = " ";  // continue parse on next arg
                        break;

                    case chSWITCH_ONCE:
                        psess->fDestructive++;  // will require "/###"
                        break;

                    default:
                        ErrSet(perr,pszEXTERR_BAD_SWITCH,"%s",apszArg[i]);
                        return FALSE;
                        break;
                }
            }
        }
        //** Not a command line switch
        else if (sl == slEXPECTING) {
            //** Get the location (output directory)
            STRCPY(psess->achLocation,apszArg[i]);  // Save location
            sl = slGOT;                 // Done eating location
        }
        else {
            //** We have a file name, add it to our list
            if (addFileSpec(psess,apszArg[i],perr) == NULL) {
                ErrSet(perr,pszEXTERR_COULD_NOT_ADD_FILE,"%s",apszArg[i]);
                return FALSE;
            }
            cFile++;                    // Count files
        }
    }

    if (psess->fDestructive < 3) {      // require 3 #'s to activate
        psess->fDestructive = FALSE;
    }

    if (psess->fSelfExtract) {
        psess->fDestructive = FALSE;    // can't do it in self-extractor
    }

    //** If no arguments and not self-extracting, show help
    if ((cArg == 1) && !psess->fSelfExtract) {
        psess->act = actHELP;           // Show help
        return TRUE;
    }

    //** Make sure no trailing /L without location
    if (sl == slEXPECTING) {
        ErrSet(perr,pszEXTERR_MISSING_LOCATION);
        return FALSE;
    }

    //** Make sure we got right number of arguments for COPY case
    if ((psess->act == actCOPY) && (cFile != 2)) {
        //** General purpose error, to minimize localization effort
        ErrSet(perr,pszEXTERR_BAD_PARAMETERS);
        return FALSE;
    }

    //** Make sure we got at least one filespec
    if (cFile == 0) {
        ErrSet(perr,pszEXTERR_MISSING_CABINET);
        return FALSE;
    }

    //** Special processing for self-extract
    if (psess->fSelfExtract) {
        psess->fAllCabinets = TRUE;     // Always do all cabinets
        //** Force EXTRACT if no /E or /D specified
        if (psess->act == actDEFAULT) {
            psess->act = actEXTRACT;
        }
    }

    //** Success
    return TRUE;
}

/***    checkSelfExtractingCab - See if we are a self-extracting cabinet
 *
 *  Entry:
 *      psess   - SESSION
 *      cArg    - Count of arguments, including program name
 *      apszArg - Array of argument strings
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE, psess filled in.
 *          psess->fSelfExtract set to TRUE if self-extracting
 *          psess->cbSelfExtract set to EXE size if self-extracting (this is
 *              the offset to the start of the cabinet file header).
 *          psess->cbSelfExtractSize set to the CAB size if self-extractor
 *          psess->achSelf set to the EXE file's name
 *
 *  Exit-Failure:
 *      Returns actBAD, perr filled in with error.
 *
 *  Notes:
 *      The strategy is to get the EXE file size indicated in the appropriate
 *      EXE header, and if the actual size of our EXE file is larger than that,
 *      we assume that there is a cabinet file tacked on to the end, and we
 *      extract the files from that!
 *
 *  Refer to the XIMPLANT source for details on the workings of the XIMPLANT
 *  implementation.
 */
BOOL checkSelfExtractingCab(PSESSION  psess,
                            int       cArg,
                            char     *apszArg[],
                            PERROR    perr)
{
    long    cbFile;                     // EXE file size
    long    cbFromHeader;               // Size indicated by EXE header
    INT_PTR hf;
    DWORD   signature;                  // should be "MSCF"
    DWORD   alignment;                  // file structure alignment, ie, 512
#ifdef BIT16
    long    info;
#else // !BIT16
    char    achFile[cbFILE_NAME_MAX];
    IMAGE_DOS_HEADER   idh;             // MS-DOS header
    IMAGE_NT_HEADERS   inh;             // Complete PE header
    IMAGE_SECTION_HEADER ish;           // section header
    WORD    iSection;
    struct
    {
        unsigned long signature;
        unsigned long reserved;
        unsigned long cbArgv;
        unsigned long cbCabinet;
    } magic;
    DWORD   offDebug;                   // file offset of debug info
    DWORD   cbDebug;                    // size of debug info
    IMAGE_DEBUG_DIRECTORY idd;          // debug descriptor

#define IMPLANT_SECTION_NAME "Ext_Cab1" /* must be 8 chars */

#endif // !BIT16

// jforbes: removed SFX CAB checking for when generating
// debug executable for extract, since it thinks the debug
// exe is a cab file
#ifdef BIT16
#ifdef _DEBUG
   psess->fSelfExtract = FALSE;
   return TRUE;
#endif
#endif


    //** Open our EXE file
#ifdef BIT16

    hf = wrap_open(apszArg[0],_O_BINARY | _O_RDONLY,0);
#else

    if (!GetModuleFileName(NULL,achFile,sizeof(achFile))) {
        return TRUE;
    }

    hf = wrap_open(achFile,_O_BINARY | _O_RDONLY,0);
#endif
    if (hf == -1) {
        return TRUE;                    // Something is bogus, just skip selfex
    }

    //** Get the expected EXE file size
#ifdef BIT16
    //** Do it the MS-DOS way

    if (-1 == wrap_lseek(hf,2,SEEK_SET)) {
        goto Exit;
    }
    if (sizeof(info) != wrap_read(hf,&info,sizeof(info))) {
        goto Exit;
    }
    //** OK, we've got the page count and count of bytes in the last page;
    //      convert to a file size.
    cbFromHeader = ((info>>16)-1)*512 + (info&0xFFFF);
     alignment = 16;
#else // !BIT16
    //** Do it the Win32 way
    //** Get MS-DOS header
    if (sizeof(idh) != wrap_read(hf,&idh,sizeof(idh))) {
        goto Exit;
    }

    //** Seek to and read NT header
    if (-1 == wrap_lseek(hf,idh.e_lfanew,SEEK_SET)) {
        goto Exit;
    }

    if (sizeof(inh) != wrap_read(hf,&inh,sizeof(inh))) {
        goto Exit;
    }

    //** Seek to first section header
    if (-1 == wrap_lseek(hf,idh.e_lfanew + sizeof(DWORD) +
            sizeof(IMAGE_FILE_HEADER) + inh.FileHeader.SizeOfOptionalHeader,
            SEEK_SET)) {
        goto Exit;
    }

    cbFromHeader = 0;
    iSection = inh.FileHeader.NumberOfSections;
    offDebug = 0;
    cbDebug = inh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
    alignment = inh.OptionalHeader.FileAlignment;

    while (iSection--) {
        //** Read this section header
        if (sizeof(ish) != wrap_read(hf,&ish,sizeof(ish))) {
            goto Exit;
        }

        if (memcmp(ish.Name,IMPLANT_SECTION_NAME,sizeof(ish.Name)) == 0)
        {
            /* found an implanted section, use the magic */
            if ((wrap_lseek(hf,ish.PointerToRawData,SEEK_SET) == -1) ||
                (wrap_read(hf,&magic,sizeof(magic)) != sizeof(magic))) {
                goto Exit;
            }

            if (magic.signature == 0x4E584653) {
                psess->fSelfExtract = TRUE;
                psess->cbSelfExtract = ish.PointerToRawData + sizeof(magic) + magic.cbArgv;
                psess->cbSelfExtractSize = magic.cbCabinet;

                if (magic.cbArgv) {
                    psess->pArgv = MemAlloc(magic.cbArgv);
                    if ((psess->pArgv != NULL) &&
                        (wrap_read(hf,psess->pArgv,magic.cbArgv) == magic.cbArgv)) {
                        psess->cArgv = 1;   /* for [0], which is NULL */
                        while (psess->pArgv[psess->cArgv] != NULL) {
                            psess->pArgv[psess->cArgv] += (LONG_PTR) psess->pArgv;
                            (psess->cArgv)++;
                        }
                    }
                }
                break;
            }
        }

        if ((ish.PointerToRawData != 0) &&
            (ish.SizeOfRawData != 0) &&
            (cbFromHeader < (long)
                (ish.PointerToRawData + ish.SizeOfRawData))) {
            cbFromHeader = (long)
                (ish.PointerToRawData + ish.SizeOfRawData);
        }

        if (cbDebug != 0)
        {
            if ((ish.VirtualAddress <=
                    inh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress) &&
                ((ish.VirtualAddress + ish.SizeOfRawData) >
                    inh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress)) {

                offDebug = inh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress
                    - ish.VirtualAddress + ish.PointerToRawData;
            }
        }
    }

    if (!psess->fSelfExtract && (offDebug != 0)) {
        if (-1 == wrap_lseek(hf,offDebug,SEEK_SET)) {
            goto Exit;
        }

        while (cbDebug >= sizeof(idd)) {
            if (sizeof(idd) != wrap_read(hf,&idd,sizeof(idd))) {
                goto Exit;
            }

            if ((idd.PointerToRawData != 0) &&
                (idd.SizeOfData != 0) &&
                (cbFromHeader < (long)
                    (idd.PointerToRawData + idd.SizeOfData))) {
                cbFromHeader = (long)
                    (idd.PointerToRawData + idd.SizeOfData);
            }

            cbDebug -= sizeof(idd);
        }
    }

#endif // !BIT16

    if (!psess->fSelfExtract)
    {
        //** Get actual file size
        cbFile = wrap_lseek(hf,0,SEEK_END);

        //** Modify state IF we are doing self-extract
        if (cbFile > cbFromHeader) {
            if ((cbFromHeader == wrap_lseek(hf,cbFromHeader,SEEK_SET)) &&
                (sizeof(signature) == wrap_read(hf,&signature,sizeof(signature))) &&
                (signature == 0x4643534DLU)) {

                psess->fSelfExtract = TRUE;
                psess->cbSelfExtract = cbFromHeader;
                psess->cbSelfExtractSize = cbFile - cbFromHeader;
            }
            else if ((cbFromHeader % alignment) != 0) {
                cbFromHeader += (alignment - 1);
                cbFromHeader -= (cbFromHeader % alignment);

                if ((cbFromHeader == wrap_lseek(hf,cbFromHeader,SEEK_SET)) &&
                    (sizeof(signature) == wrap_read(hf,&signature,sizeof(signature))) &&
                    (signature == 0x4643534DLU)) {

                    psess->fSelfExtract = TRUE;
                    psess->cbSelfExtract = cbFromHeader;
                    psess->cbSelfExtractSize = cbFile - cbFromHeader;
                }
            }
        }
    }

    if (psess->fSelfExtract)
    {
        //** Save our file name and use it as the cabinet file name
#ifdef BIT16
        strcpy(psess->achSelf,apszArg[0]);  // Save our name
#else
        strcpy(psess->achSelf,achFile);     // Save our name
#endif
    }

    //** Success
Exit:
    wrap_close(hf);
    return TRUE;
} /* checkSelfExtractingCab() */



/***    addFileSpec - Add filename to session list
 *
 *  Entry:
 *      psess  - Session to update
 *      pszArg - File name to add
 *      perr   - ERROR structure
 *
 *  Exit-Success:
 *      Returns HFILESPEC, psess updated.
 *
 *  Exit-Failure:
 *      Returns NULL, perr filled in with error.
 */
HFILESPEC addFileSpec(PSESSION psess, char *pszArg, PERROR perr)
{
    HFILESPEC   hfspec;

    AssertSess(psess);
    //** Make sure a list exists
    if (psess->hflist == NULL) {
        if (!(psess->hflist = FLCreateList(perr))) {
            return FALSE;
        }
    }

    //** Add file to list
    if (!(hfspec = FLAddFile(psess->hflist, pszArg, NULL, perr))) {
        return NULL;
    }

    //** Success
    return hfspec;
} /* addFileSpec() */


#ifdef ASSERT
/***    fnafReport - Report assertion failure
 *
 *      NOTE: See asrt.h for entry/exit conditions.
 */
FNASSERTFAILURE(fnafReport)
{
        printf("\n%s:(%d) Assertion Failed: %s\n",pszFile,iLine,pszMsg);
        exit(1);
}
#endif // ASSERT


/***    printError - Display error on stdout
 *
 *  Entry
 *      perr - ERROR structure to print
 *
 *  Exit-Success
 *      Writes error message to stdout.
 */
void printError(PSESSION psess, PERROR perr)
{
    WCHAR   szTemp[MAX_MESSAGE_SIZE];
    //** Make sure error starts on a new line
    if (psess)
    {
        if (psess->fNoLineFeed) {
            fwprintf(stdout, L"\n");
            psess->fNoLineFeed = FALSE;
        }
    }

    //** General error
    Assert(perr->pszFile == NULL);
    MsgSet(psess->achMsg,pszEXTERR_ERROR,"%s",perr->ach);
    MultiByteToWideChar( CP_THREAD_ACP, 0, psess->achMsg, strlen(psess->achMsg),
                             szTemp, MAX_MESSAGE_SIZE);
    *(szTemp+strlen(psess->achMsg)) = '\0';
    fwprintf( stderr, szTemp );


} /* printError() */


/***    pszFromMSDOSTime - Convert MS-DOS file date/time to string
 *
 *  Entry:
 *      psz  - Buffer to receive formatted date/time
 *      cb   - Length of psz buffer
 *      date - MS-DOS FAT file system date format (see below)
 *      time - MS-DOS FAT file system time format (see below)
 *
 *  Exit:
 *      *psz filled in
 *
 *  NOTE: This is the interpretation of the MS-DOS date/time values:
 *
 *      Time Bits cBits Meaning
 *      --------- ----- ----------------------------------------
 *       0 -  4     5   Number of two-second increments (0 - 29)
 *       5 - 10     6   Minutes (0 - 59)
 *      11 - 15     5   Hours (0 - 23)
 *
 *      Date Bits cBits Meaning
 *      --------- ----- ----------------------------------------
 *       0 -  4     5   Day (1 - 31)
 *       5 -  8     4   Month (1 - 12)
 *       9 - 15     7   Year since 1980 (for example, 1994 is stored as 14)
 */
void pszFromMSDOSTime(char *psz, int cb, WORD date, WORD time)
{
    int     sec;
    int     min;
    int     hour;
    int     day;
    int     month;
    int     year;
    char   *pszAMPM;                    // AM/PM string

    sec   = (time & 0x1f) << 1;         // 0, 2, ..., 58
    min   = (time >>  5) & 0x3f;        // 0, 1, ..., 59
    hour  = (time >> 11) & 0x1f;        // 0, 1, ..., 23

    //** Determine 12-hour vs. 24-hour clock
    if (strlen(pszEXT_TIME_PM) == 0) {
        //** 24 hour clock
        Assert(strlen(pszEXT_TIME_AM) == 0);
        pszAMPM = pszEXT_TIME_PM;
    }
    else {
        //** Get am/pm extension, and map 0 to 12
        if (hour >= 12) {
            pszAMPM = pszEXT_TIME_PM;
            hour -= 12;
        }
        else {
            pszAMPM = pszEXT_TIME_AM;
        }
        if (hour == 0) {
            hour = 12;
        }
    }

    day   = (date & 0x1f);
    month = (date >> 5) & 0x0f;
    year  = ((date >> 9) & 0x7f) + 1980;

    MsgSet(psz,pszEXT_DATE_TIME, "%02d%02d%02d%2d%02d%02d%s",
            month, day, year, hour, min, sec, pszAMPM);
} /* pszFromMSDOSTime() */


/***    pszFromAttrFAT - Convert FAT file attributes to string
 *
 *  Entry:
 *      attrFAT - file attributes
 *
 *  Exit:
 *      *psz filled in  "----".."A-R-".."AHRS"
 */
void pszFromAttrFAT(char *psz, int cb, WORD attrFAT)
{
    STRCPY(psz,"----");
    if (attrFAT & _A_ARCH)
        psz[0] = 'A';
    if (attrFAT & _A_HIDDEN)
        psz[1] = 'H';
    if (attrFAT & _A_RDONLY)
        psz[2] = 'R';
    if (attrFAT & _A_SYSTEM)
        psz[3] = 'S';
    return;
} /* pszFromAttrFAT() */


/***    mapFDIError - Create error message from FDI error codes
 *
 *  Entry:
 *      perr       - ERROR structure to recieve message
 *      psess      - Our context
 *      pszCabinet - Cabinet file being processed
 *      perf       - FDI error structure
 *
 *  Exit:
 *      perr filled in with formatted message
 */
void mapFDIError(PERROR perr,PSESSION psess, char *pszCabinet, PERF perf)
{
    switch (perf->erfOper) {

    case FDIERROR_NONE:
        Assert(0);
        break;

    case FDIERROR_CABINET_NOT_FOUND:
        ErrSet(perr,pszFDIERR_CAB_NOT_FOUND,"%s",pszCabinet);
        break;

    case FDIERROR_NOT_A_CABINET:
        ErrSet(perr,pszFDIERR_NOT_A_CABINET,"%s",pszCabinet);
        break;

    case FDIERROR_UNKNOWN_CABINET_VERSION:
        ErrSet(perr,pszFDIERR_BAD_CAB_VER,"%s%04x",pszCabinet,perf->erfType);
        break;

    case FDIERROR_CORRUPT_CABINET:
        ErrSet(perr,pszFDIERR_CORRUPT_CAB,"%s",pszCabinet);
        break;

    case FDIERROR_ALLOC_FAIL:
        ErrSet(perr,pszFDIERR_ALLOC_FAIL,"%s",pszCabinet);
        break;

    case FDIERROR_BAD_COMPR_TYPE:
        ErrSet(perr,pszFDIERR_BAD_COMPR_TYPE,"%s",pszCabinet);
        break;

    case FDIERROR_MDI_FAIL:
        //** Improve detail of failure message

        switch (psess->se) {

        case seNONE:
            //** Some other decompression error (corrupted data?)
            ErrSet(perr,pszFDIERR_MDI_FAIL,"%s",pszCabinet);
            break;

        case seNOT_ENOUGH_MEMORY:
            //** Not enough RAM for decompressor itself
            ErrSet(perr,pszFDIERR_ALLOC_FAIL,"%s",pszCabinet);
            break;

        case seCANNOT_CREATE:
            //** Could not create a Quantum temporary spill file
            ErrSet(perr,pszFDIERR_SPILL_CREATE,"%s%s",pszCabinet,achSpillFile);
            break;

        case seNOT_ENOUGH_SPACE:
            //** TMP directory did not have enough space for Quantum
            //   spill file.
            ErrSet(perr,pszFDIERR_SPILL_SIZE,"%s%s%ld",pszCabinet,
                                                       achSpillFile,
                                                       psess->cbSpill);
            break;

        default:
            Assert(0);
        }
        break;

    case FDIERROR_TARGET_FILE:
        ErrSet(perr,pszFDIERR_TARGET_FILE,"%s%s",psess->achFile,pszCabinet);
        break;

    case FDIERROR_RESERVE_MISMATCH:
        ErrSet(perr,pszFDIERR_RESERVE_MISMATCH,"%s",pszCabinet);
        break;

    case FDIERROR_WRONG_CABINET:
        ErrSet(perr,pszFDIERR_WRONG_CABINET,"%s",pszCabinet);
        break;

    case FDIERROR_USER_ABORT:
        ErrSet(perr,pszFDIERR_USER_ABORT,"%s",pszCabinet);
        break;

    default:
        ErrSet(perr,pszFDIERR_UNKNOWN_ERROR,"%d%s",perf->erfOper,pszCabinet);
        break;
    }
} /* mapFDIError() */


/***    wrap_close - close an open file
 *
 */
int  FAR DIAMONDAPI wrap_close(INT_PTR fh)
{
    int     i;
    int     rc;

#ifdef SMALL_DOS
    rc = _dos_close((HFILE)fh);
    if (rc != 0) {          // Map random MS-DOS error code to -1 failure
        rc = -1;
    }
#else
    rc = _close((HFILE)fh);
#endif

    //** See if we have to destroy the spill file
    if (fh == hfSpillFile) {
        _unlink(achSpillFile);          // Delete spill file
        hfSpillFile = -1;               // Remember spill file is gone
    }

    //** Take handle off list if we are self-extracting
    if (psessG->fSelfExtract) {
        //** See if this is a handle to our EXE/cabinet file;
        for (i=0;
             (i<cMAX_CAB_FILE_OPEN) && (psessG->ahfSelf[i] != (HFILE)fh);
             i++) { ; }
        if (i < cMAX_CAB_FILE_OPEN) {   // Found a match
            psessG->ahfSelf[i] = -1;    // Take it off our list
            dbg( printf("\nDBG: Close self as handle %d (slot %d)\n",(HFILE)fh,i) );
        }
    }

#ifdef WIN32GUI
    if (fh == hCabFile1) {
        hCabFile1 = hCabFile2;
        ibCabFilePosition1 = ibCabFilePosition2;
        hCabFile2 = -1;
        if (hCabFile1 == -1) {
            cbCabFileTotal = 0;
            cbCabFileMax = 0;
            iPercentLast = -1;
        }
    }
    else if (fh == hCabFile2) {
        hCabFile2 = -1;
    }
#endif

    //** Done
    dbg( printf("DBG: %d=CLOSE on handle %d\n",rc,(HFILE)fh) );
    return  rc;
} /* wrap_close */


/***    wrap_lseek - seek on a file
 *
 */
long FAR DIAMONDAPI wrap_lseek(INT_PTR fh, long pos, int func)
{
    long    cbAdjust=0;                 // Assume file is 0-based
    int     i;
    long    rc;
    long    cbLimit=0;                  // assume no length clipping

    //** See if we are self-extracting
    if (psessG->fSelfExtract) {
        //** See if this is a handle to our EXE/cabinet file;
        for (i=0;
             (i<cMAX_CAB_FILE_OPEN) && (psessG->ahfSelf[i] != (HFILE)fh);
             i++) { ; }
        if (i < cMAX_CAB_FILE_OPEN) {   // Found a match
            cbAdjust = psessG->cbSelfExtract; // So return value gets adjusted
            cbLimit = psessG->cbSelfExtractSize; // known CAB image size
            if (func == SEEK_SET) {     // Need to adjust absolute position
                pos += cbAdjust;            // Shift up to account for EXE
                dbg(printf("\nDBG: Seek self to %ld as handle %d (slot %d)\n",pos,(HFILE)fh,i));
            }
        }
    }

#ifdef SMALL_DOS
    rc = _dos_seek((HFILE)fh,pos,func);
#else
    rc = _lseek((HFILE)fh,pos,func);
#endif
    //** If seek didn't fail, adjust return value for self-extract case
    if (rc != -1) {
        rc -= cbAdjust;
        if ((cbLimit != 0) && (rc > cbLimit)) {
            rc = cbLimit;
        }
    }

#ifdef WIN32GUI
    if (fh == hCabFile1) {
        ibCabFilePosition1 = rc;
    }
    else if (fh == hCabFile2) {
        ibCabFilePosition2 = rc;
    }
#endif

    dbg( printf("DBG: %ld=LSEEK on handle %d, pos=%ld, func=%d\n",rc,(HFILE)fh,pos,func) );
    return rc;
} /* wrap_lseek() */


/***    wrap_open - open a file
 *
 */
INT_PTR  FAR DIAMONDAPI wrap_open(char FAR *sz, int mode, int share)
{
    int             i;
    int             rc;
    char FAR       *psz;
    PFDISPILLFILE   pfdisf;             // FDI spill file info
#ifdef SMALL_DOS
    int     ignore;
    char    szLocal[cbFILE_NAME_MAX];
#endif

    //** See if FDI is asking for a spill file (for Quantum)
    if (*sz == '*') {                   // Yes, we need to create a spill file
        Assert(hfSpillFile == -1);      // Only support one at a time
        achSpillFile[0] = '\0';         // No name constructed, yet
        pfdisf = (PFDISPILLFILE)sz;     // Get pointer to spill file size
        //** Try boot drive if no TEMP variable defined
        //   NOTE: We assume the boot drive is more likely to be writeable
        //         than the current directory, since the customer may be
        //         running EXTRACT.EXE off a write-protected floppy (which
        //         also wouldn't have enough space), or a read-only network
        //         drive.
        psz = _tempnam(getBootDrive(),"esf"); // Get a temporary file name
        if (psz == NULL) {
            psessG->se = seCANNOT_CREATE;
            return -1;                  // Could not create
        }
        strcpy(achSpillFile,psz);       // Remember name for wrap_close
        free(psz);                      // Free temporary name buffer

        mode = _O_CREAT | _O_BINARY | _O_RDWR; // Force open mode
        psz = achSpillFile;             // Use spill file name
    }
    else {
        psz = (char FAR *)sz;           // Use passed-in name
    }

    //** Open/create file
#ifdef SMALL_DOS
    _fstrcpy(szLocal,psz);
    if (mode & _O_CREAT) {
        ignore = _dos_creat(szLocal,_A_NORMAL,&rc);
    }
    else {
        //** Keep only relevant bits for _dos_open!
        mode &= _O_RDONLY | _O_WRONLY | _O_RDWR;
        ignore = _dos_open(szLocal,mode,&rc);
    }
    if (ignore != 0) {
        rc = -1;
    }
#else
    rc = _open(psz,mode,share);
#endif

    //** If this is the spill file, make sure the file was created,
    //   make sure it is the requested size, and save the handle.
    //   If we cannot do this, we set a flag to remember what the
    //   problem was, so that we can report the error intelligently.
    if (*sz == '*') {                   // Need to size spill file
        if (-1 == rc) {                 // Could not create it
            psessG->se = seCANNOT_CREATE;
            return (INT_PTR)rc;
        }
        //** Remember file handle, so that wrap_close can do the delete
        hfSpillFile = rc;

        //** Don't need to seek/write if zero length requested
        if (pfdisf->cbFile > 0) {
            //** Seek to size minus 1
            if (-1L == wrap_lseek(rc,pfdisf->cbFile-1,SEEK_SET)) {
                psessG->se = seNOT_ENOUGH_SPACE;
                psessG->cbSpill = pfdisf->cbFile;
                wrap_close(rc);             // Close and destroy spill file
                return -1;
            }

            //** Write one byte
            if (1 != wrap_write(rc,"b",1)) {
                psessG->se = seNOT_ENOUGH_SPACE;
                psessG->cbSpill = pfdisf->cbFile;
                wrap_close(rc);
                return -1;
            }
        }
        //** Spill file created successfully
        psessG->se = seNONE;                // No error
    }
#ifndef BIT16
#define _fstricmp(a,b) stricmp(a,b)
#endif
    else if (psessG->fSelfExtract && !_fstricmp(sz,psessG->achSelf)) {
        //** Self-extracting and this is our EXE/cabinet file;
        //   Find a slot to store the file handle.
        for (i=0;
             (i<cMAX_CAB_FILE_OPEN) && (psessG->ahfSelf[i] != -1);
             i++) { ; }
        if (i >= cMAX_CAB_FILE_OPEN) {
            Assert(0);
            wrap_close(rc);
            return -1;
        }
        dbg( printf("\nDBG: Opened self (%s) as handle %d (slot %d)\n",sz,rc,i) );

        //** Save the new handle
        psessG->ahfSelf[i] = rc;

        //** Position the file handle to the start of the cabinet file header!
        //   NOTE: Since we just added the handle to the list, wrap_lseek()
        //         will know to do the EXE size adjustment!
        wrap_lseek(rc,0,SEEK_SET);
    }

#ifdef WIN32GUI
    if ((mode == (_O_RDONLY|_O_BINARY)) && (rc != -1))  {
        //* If this is the CAB file, track it's handle and get the file's size

        //  REARCHITECT: this is done this way in the interest of development time.
        //  I'm using _O_RDONLY to identify that it's the CAB file being
        //  opened, and I'm depending upon there being no more than two such
        //  handles.

        if (hCabFile1 == -1) {
            hCabFile1 = rc;
            if (psessG->fSelfExtract)
            {
                cbCabFileTotal = psessG->cbSelfExtractSize;
            }
            else
            {
                cbCabFileTotal = _filelength((HFILE)hCabFile1);
            }
            cbCabFileMax = 0;
            ibCabFilePosition1 = 0;
            cbCabFileScale = 1;
            while (cbCabFileTotal > 10000000)
            {
                cbCabFileTotal /= 10;
                cbCabFileScale *= 10;
            }
            iPercentLast = -1;
            if (g_hwndProgress == NULL)
            {
                g_hwndProgress = CreateDialog(g_hinst,
                        MAKEINTRESOURCE(DLG_PROGRESS), NULL, ProgressWndProc);
            }
        }
        else if (hCabFile2 == -1) {
            hCabFile2 = rc;
            ibCabFilePosition2 = 0;
        }
    }
#endif

    //** Done
    dbg( printf("DBG: %d=OPEN file %s, mode=%d, share=%d\n",rc,sz,mode,share) );
    return (INT_PTR)rc;
} /* wrap_open() */


/***    wrap_read - read a file
 *
 */
UINT FAR DIAMONDAPI wrap_read(INT_PTR fh, void FAR *pb, unsigned int cb)
{
    int     rc;

#ifdef SMALL_DOS
    UINT ignore;
    ignore = _dos_read((HFILE)fh,pb,cb,&rc);
    if (ignore != 0) {
        rc = -1;
    }
#else
    rc = _read((HFILE)fh,pb,cb);
#endif

#ifdef WIN32GUI
    if (fh == hCabFile1) {
        ibCabFilePosition1 += rc;
        if (ibCabFilePosition1 > cbCabFileMax) {
            cbCabFileMax = ibCabFilePosition1;
            ProgressReport(cbCabFileMax);
        }
    }
    else if (fh == hCabFile2) {
        ibCabFilePosition2 += rc;
        if (ibCabFilePosition2 > cbCabFileMax) {
            cbCabFileMax = ibCabFilePosition2;
            ProgressReport(cbCabFileMax);
        }
    }
#endif

    dbg( printf("DBG: %d=READ on handle %d, pb=%08lx, cb=%u\n",rc,(HFILE)fh,pb,cb) );
    return rc;
} /* wrap_read() */


/***    wrap_write - write a file
 *
 *  Iff cb == 0, truncate the file at the current position.
 *  (Needed for FDITruncateCabinet.)
 */
UINT FAR DIAMONDAPI wrap_write(INT_PTR fh, void FAR *pb, unsigned int cb)
{
    int     rc;

#ifdef SMALL_DOS
    UINT ignore;
    ignore = _dos_write((HFILE)fh,pb,cb,&rc);
    if (ignore != 0) {
        rc = -1;
    }
#else
    if (cb == 0) {
        rc = _chsize((HFILE)fh,_lseek((HFILE)fh,0,SEEK_CUR));
    }
    else {
        rc = _write((HFILE)fh,pb,cb);
    }
#endif
    dbg( printf("DBG: %d=WRITE on handle %d, pb=%08lx, cb=%u\n",rc,(HFILE)fh,pb,cb) );
    return rc;
} /* wrap_write() */


/***    getBootDrive - Returns boot drive path (e.g., "C:\")
 *
 *  Entry:
 *      none
 *
 *  Exit:
 *      Returns pointer to static buffer with bootdrive ("C:\")
 */
char *getBootDrive(void)
{
   char         ch;
   char        *psz;
   static char  szBootDrive[]="C:\\";

   //** Default to Drive C
   *szBootDrive = 'C';

   //** Get COMSPEC -- we're assuming it's drive letter is the boot drive!
   psz = getenv("COMSPEC");
   if ( psz               &&            // COMSPEC exists
        *psz              &&            // It is not empty
        (*(psz+1) == ':')) {            // Has the right format -- "?:..."
        //** We could try to validate that this is really the boot drive,
        //   but we'll just trust that COMSPEC is correct.  A test for the
        //   drive being in the range A..C would work for the US, but in
        //   Japan the boot drive can be anything between A..G, and maybe
        //   even higher.  So, we'll just make sure it's a drive letter.
        ch = (char)tolower(*psz);
        if (('a' <= ch) && (ch <= 'z')) {
            *szBootDrive = ch;          // Use COMSPEC drive letter
        }
    }

   //** Return path of root of boot drive
   return szBootDrive;
} /* getBootDrive() */


#ifdef BIT16
//** Get Changeline fix code
//APPCOMPAT: 14-Dec-1994 bens Include *.c file to avoid makefile change!
#include "fixchg.c"
#endif


#ifdef WIN32GUI

int WINAPI WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nShowCmd)
{
    int result;
    char *pchCommand;
    char *argv[50];
    int argc;
    enum { WHITESPACE, UNQUOTED, QUOTED } eState = WHITESPACE;

    g_hinst = hInstance;

    pchCommand = strdup(lpCmdLine);    /* work on a copy */

    argv[0] = "";                       /* no EXE name supplied */
    argc = 1;                           /* that was one */

    if (pchCommand)
    {
        while (*pchCommand)                 /* walk the string */
        {
            switch (eState)
            {

            case WHITESPACE:
                if (*pchCommand <= ' ')
                {
                    /* ignore it */
                }
                else if (*pchCommand == '\"')
                {
                    argv[argc++] = pchCommand + 1;  /* skip quote */

                    eState = QUOTED;
                }
                else
                {
                    argv[argc++] = pchCommand;

                    eState = UNQUOTED;
                }
                break;

            case UNQUOTED:
                if (*pchCommand <= ' ')
                {
                    *pchCommand = '\0';      /* nul-terminate */

                    eState = WHITESPACE;
                }
                else
                {
                    /* keep moving up */
                }
                break;

            case QUOTED:
                if (*pchCommand == '\"')
                {
                    *pchCommand = '\0';      /* turn quote to a nul */

                    eState = WHITESPACE;
                }
                else
                {
                    /* keep moving up */
                }
                break;
            }

            pchCommand++;
        }
    }

    argv[argc] = NULL;                  /* NULL-terminate the list */

    InitCommonControls();

    result = main(argc, argv);          /* run Extract */

    if (g_hwndProgress != NULL)
    {
        DestroyWindow(g_hwndProgress);
        g_hwndProgress = NULL;
    }

    return(result);                     /* return the result */
}


static void ProgressReport(unsigned long cbCabFileMax)
{
    MSG msg;
    int iPercent;

    if ((cbCabFileTotal > 0) && (g_hwndProgress != NULL))
    {
        cbCabFileMax /= cbCabFileScale;

        if (cbCabFileMax > cbCabFileTotal)
        {
            cbCabFileMax = cbCabFileTotal;
        }

        cbCabFileMax *= 100;

        iPercent = (int) (cbCabFileMax / cbCabFileTotal);

        if (iPercent != iPercentLast)
        {
            SendDlgItemMessage(g_hwndProgress, IDC_PROGRESS, PBM_SETPOS,
                iPercent, 0);

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                DispatchMessage(&msg);
            }

            iPercentLast = iPercent;
        }
    }
}


LRESULT CALLBACK ProgressWndProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, 99));
            EnableMenuItem(GetSystemMenu(hdlg, FALSE), SC_CLOSE, MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
            return TRUE;
    }

    return 0;
}

#endif /* WIN32GUI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\fileutil.c ===
/***    fileutil.c - Utility routines for dealing with files
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1997
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      20-Feb-1994 bens    Initial version (code from diamond.c)
 *      21-Feb-1994 bens    Add IsWildPath()
 *      24-Feb-1994 bens    Added tempfile functions
 *      23-Mar-1994 bens    Added Win32<->MS-DOS file attribute mapping
 *      03-Jun-1994 bens    VER.DLL support
 *      07-Jun-1994 bens    Move VER.DLL stuff to filever.c
 *      14-Dec-1994 bens    Fix bug in IsWildPath()
 *      02-Feb-1996 msliger Reduced bogosity in pattern matcher
 *      26-Feb-1997 msliger Avoid NULL deref in catDirAndFile()
 *      04-Mar-1997 msliger Close file before applying attributes to avoid
 *                          setting the archive bit.
 *      01-Apr-1997 msliger Avoid bounds error in ensureDirectory.
 */

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <malloc.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <errno.h>
#include <direct.h>

#ifdef BIT16
#include <dos.h>
#else // !BIT16

//** Get minimal Win32 definitions

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#undef ERROR    // Override "#define ERROR 0" in wingdi.h
#endif // !BIT16

#include "types.h"
#include "asrt.h"
#include "error.h"
#include "mem.h"
#include "message.h"

#include "fileutil.h"

#include <fileutil.msg> // LOCALIZED for EXTRACT.EXE -- specify "cl /Ipath"



/** TEMPFILE definitions
 *
 */
typedef struct {  /* tmp */
#ifdef ASSERT
    SIGNATURE     sig;  // structure signature sigTEMPFILE
#endif
    FILE   *pfile;      // Stream pointer (fopen,fread,fwrite,fclose,...)
    char   *pszFile;    // Constructed filename (MemFree to free)
    char   *pszDesc;    // Description of tempfile
} TEMPFILE;
typedef TEMPFILE *PTEMPFILE; /* ptmp */

#ifdef ASSERT
#define sigTEMPFILE MAKESIG('T','M','P','F')  // TEMPFILE signature
#define AssertTmp(ptmp) AssertStructure(ptmp,sigTEMPFILE);
#else // !ASSERT
#define AssertTmp(ptmp)
#endif // !ASSERT


#define PTMPfromHTMP(htmp) ((PTEMPFILE)(htmp))
#define HTMPfromPTMP(ptmp) ((HTEMPFILE)(ptmp))

#ifdef BIT16
#define CharIncr(psz) (psz = psz + 1)
#else
#define CharIncr(psz) (psz = CharNextExA(CP_ACP, psz, 0))
#endif


/***    TmpCreate - Create a temporary file
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
HTEMPFILE TmpCreate(char *pszDesc, char *pszPrefix, char *pszMode, PERROR perr)
{
#define cTMP_RETRY  5                   // Number of tempfile retries
    int         cFailure=0;
    FILE       *pfile=NULL;
    char       *pszTmpName;
    PTEMPFILE   ptmp;

    //** Try to create a temp file (give it 6 tries for good luck)
    while (pfile == NULL) {
        pszTmpName = _tempnam("",pszPrefix); // Get a name
        if (pszTmpName != NULL) {
            pfile = fopen(pszTmpName,pszMode); // Create the file
        }
        if (pfile == NULL) {            // Name or create failed
            cFailure++;                 // Count failures
            if (cFailure > cTMP_RETRY) { // Failure, select error message
                if (pszTmpName == NULL) {   // Name create failed
                    ErrSet(perr,pszFILERR_CANT_CREATE_TMP,"%s",pszDesc);
                }
                else {                  // File create failed
                    ErrSet(perr,pszFILERR_CANT_CREATE_FILE,"%s%s",
                                    pszDesc,pszTmpName);
                    free(pszTmpName);   //BC6 cr
                }
                return NULL;
            }
            if (pszTmpName != NULL) {   //BC6 cr
                free(pszTmpName);
            }
        }
    }

    //** File create worked, allocate our tempfile structure and fill it in
    if (!(ptmp = MemAlloc(sizeof(TEMPFILE)))) {
        ErrSet(perr,pszFILERR_OUT_OF_MEMORY,"%s",pszDesc);
        goto error;
    }
    ptmp->pszFile = NULL;
    ptmp->pszDesc = NULL;
    if (!(ptmp->pszFile = MemStrDup(pszTmpName))) {
        ErrSet(perr,pszFILERR_OUT_OF_MEMORY,"%s",pszDesc);
        goto error;
    }
    if (!(ptmp->pszDesc = MemStrDup(pszDesc))) {
        ErrSet(perr,pszFILERR_OUT_OF_MEMORY,"%s",pszDesc);
        goto error;
    }
    ptmp->pfile = pfile;
    SetAssertSignature(ptmp,sigTEMPFILE);
    free(pszTmpName);                   //BC6
    return HTMPfromPTMP(ptmp);          // Success

error:
    if (ptmp) {
        if (ptmp->pszDesc != NULL) {
            MemFree(ptmp->pszDesc);
        }
        if (ptmp->pszFile != NULL) {
            MemFree(ptmp->pszFile);
        }
        MemFree(ptmp);
    }
    fclose(pfile);
    free(pszTmpName);
    return NULL;                        // Failure
} /* createTempFile() */


/***    TmpGetStream - Get FILE* from HTEMPFILE, to perform I/O
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
FILE *TmpGetStream(HTEMPFILE htmp, PERROR perr)
{
    PTEMPFILE   ptmp;

    ptmp = PTMPfromHTMP(htmp);
    AssertTmp(ptmp);

    return ptmp->pfile;
} /* TmpGetStream() */


/***    TmpGetDescription - Get description of temporary file
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
char *TmpGetDescription(HTEMPFILE htmp, PERROR perr)
{
    PTEMPFILE   ptmp;

    ptmp = PTMPfromHTMP(htmp);
    AssertTmp(ptmp);

    return ptmp->pszDesc;
} /* TmpGetDescription() */


/***    TmpGetFileName - Get filename of temporary file
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
char *TmpGetFileName(HTEMPFILE htmp, PERROR perr)
{
    PTEMPFILE   ptmp;

    ptmp = PTMPfromHTMP(htmp);
    AssertTmp(ptmp);

    return ptmp->pszFile;
} /* TmpGetFileName() */


/***    TmpClose - Close a temporary file stream, but keep tempfile handle
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL TmpClose(HTEMPFILE htmp, PERROR perr)
{
    PTEMPFILE   ptmp;

    ptmp = PTMPfromHTMP(htmp);
    AssertTmp(ptmp);

    //** Only close if it is open
    if (ptmp->pfile != NULL) {
        if (fclose(ptmp->pfile) == EOF) {   // Close it
            ErrSet(perr,pszFILERR_CANT_CLOSE_TMP,ptmp->pszDesc);
            return FALSE;
        }
        ptmp->pfile = NULL;             // Remember stream is closed
    }

    return TRUE;
} /* TmpClose() */


/***    TmpOpen - Open the stream for a temporary file
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 *  Entry:
 *      htmp    - Handle to temp file
 *      pszMode - Mode string passed to fopen ("wt", "wb", "rt", etc.)
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; stream opened
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in
 */
BOOL TmpOpen(HTEMPFILE htmp, char *pszMode, PERROR perr)
{
    PTEMPFILE   ptmp;

    ptmp = PTMPfromHTMP(htmp);
    AssertTmp(ptmp);

    Assert(ptmp->pfile == NULL);        // Can't open if already open
    ptmp->pfile = fopen(ptmp->pszFile,pszMode); // Open the file
    if (!ptmp->pfile) {
        ErrSet(perr,pszFILERR_CANNOT_OPEN_TMP,"%s%s",
                                ptmp->pszDesc,ptmp->pszFile);
    }
    return (ptmp->pfile != NULL);       // Indicate success/failure
} /* TmpOpen() */


/***    TmpDestroy - Delete tempfil and destroy handle
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL TmpDestroy(HTEMPFILE htmp, PERROR perr)
{
    PTEMPFILE   ptmp;

    ptmp = PTMPfromHTMP(htmp);
    AssertTmp(ptmp);

    //** Make sure file is closed
    if (ptmp->pfile != NULL) {
        fclose(ptmp->pfile);
    }

    //** Delete tempfile
    if (remove(ptmp->pszFile) != 0) {
        ErrSet(perr,pszFILERR_CANT_DELETE_TMP,"%s%s",
                                    ptmp->pszDesc,ptmp->pszFile);
    }

    //** Free Memory
    if (ptmp->pszDesc != NULL) {
        MemFree(ptmp->pszDesc);
    }
    if (ptmp->pszFile != NULL) {
        MemFree(ptmp->pszFile);
    }
    ClearAssertSignature(ptmp);
    MemFree(ptmp);

    //** Success
    return TRUE;
} /* TmpDestroy() */


/***    getFileSize - Get size of a file
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
long getFileSize(char *pszFile, PERROR perr)
{
    struct _stat    statbuf;            // Buffer for _stat()

    //** Get file status
    if (_stat(pszFile,&statbuf) == -1) {
        //** Could not get file status
        ErrSet(perr,pszFILERR_FILE_NOT_FOUND,"%s",pszFile);
        return -1;
    }

    //** Make sure it is a file
    if (statbuf.st_mode & (_S_IFCHR | _S_IFDIR)) { // device or directory
        ErrSet(perr,pszFILERR_NOT_A_FILE,"%s",pszFile);
        return -1;
    }

    //** Success
    return statbuf.st_size;
} /* getFileSize() */


/***    appendPathSeparator - Append a path separator only if necessary
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
int appendPathSeparator(char *pszPathEnd)
{
    //** Add path separator if necessary
    if ((*pszPathEnd != '\0')        && // Path is not empty
        (*pszPathEnd != chPATH_SEP1) && // Not a path separator
        (*pszPathEnd != chPATH_SEP2) && // Not a path separator
        (*pszPathEnd != chDRIVE_SEP) ) { // Not a drive separator
        *(++pszPathEnd) = chPATH_SEP1; // Add path separator
        *(++pszPathEnd) = '\0';     // Terminate path
        return 1;                   // Account for path separator
    }
    //** No separator added
    return 0;
} /* appendPathSeparator() */


/***    catDirAndFile - Concatenate a possibly empty dir and file name
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL catDirAndFile(char * pszResult,
                   int    cbResult,
                   char * pszDir,
                   char * pszFile,
                   char * pszFileDef,
                   PERROR perr)
{
    int     cch;
    char   *pch;

//FEATURE: 14-Feb-1994 bens Need to add pszName to say what field was bad

    //** Handle directory
    pszResult[0] = '\0';                // No filespec, yet
    cch = strlen(pszDir);               // Get length of dir
    if (cch != 0) {                     // Have to concatenate path
        strcpy(pszResult,pszDir);       // Copy destination dir to buffer
        cbResult -= cch;                // Account for dir
        //** Add path separator if necessary, adjust remaining size
        cbResult -= appendPathSeparator(&(pszResult[cch-1]));
        if (cbResult <= 0) {
            ErrSet(perr,pszFILERR_PATH_TOO_LONG,"%s",pszDir);
            return FALSE;
        }
    }

    //** Append file name, using default if primary one not supplied
    if (*pszFile == '\0') {             // Need to construct file name
        if ((pszFileDef == NULL) ||     // Don't deref NULL
               (*pszFileDef == '\0')) { // Empty default name, too
            return TRUE;                // We're done!
        }
        pch = getJustFileNameAndExt(pszFileDef,perr); // Get default name
        if (pch == NULL) {
            return FALSE;               // perr already filled in
        }
    }
    else {
        pch = pszFile;                  // Use supplied name
    }
    strcat(pszResult,pch);              // Append file name
    cbResult -= strlen(pch);            // Update remaining size
    if (cbResult <= 0) {
        ErrSet(perr,pszFILERR_PATH_TOO_LONG,"%s",pch);
        return FALSE;
    }

    //** Success
    return TRUE;
} /* catDirAndFile() */


/***    ensureDirectory - Ensure directory exists (creating as needed)
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL ensureDirectory(char *pszPath, BOOL fHasFileName, PERROR perr)
{
    char    achDir[cbFILE_NAME_MAX];    // Partial directory buffer
    int     cErrors;
    int     cch;
    int     cchNoPathSep;
    int     i;                          // Temp file name count
    int     fh;             // File handle
    char   *pch;
    char   *pchCurr;                    // Current path separator
    char   *pchNext;                    // Next path separator

    //** Find first path separator, if any.
    //   NOTE: Have to handle case of "d:foo" specially!
    //
    for (pch=pszPath;
         *pch &&                        // Not end of string
         (*pch!=chPATH_SEP1) &&         // Not path separator 1
         (*pch!=chPATH_SEP2) &&         // Not path separator 2
         ((*pch!=chDRIVE_SEP) || ((*(pch+1)==chPATH_SEP1) || // Not "d:\"
                                  (*(pch+1)==chPATH_SEP2)));
         CharIncr(pch)) {
        ; //
    }

    //** Set correct starting point for first directory component (if any)
    achDir[0] = '\0';                   // Assume current directory
    if ((*pch == '\0') &&               // No path separators
        fHasFileName) {                 // Just a file name
        //** Do nothing; for loop below will be skipped because *pch == \0
    }
    else {
        //** Have to consider whole path
        pch = pszPath;                  // Need to ensure directories
    }

    //** Make sure directories on path exist (create them all)
    //   We need to identify successive components and create directory
    //   tree one component at a time.  Since the directory may already
    //   exist, we do the final test of creating a file there to make
    //   sure we can do the write.

    for (pchCurr=pch, pchNext=pch;      // Process path components
         *pchNext && *pchCurr;          // Until no more    //BC6
         pchCurr=pchNext+1) {           // Skip over last path separator
        //** Find next path separator
        for (pch=pchCurr;
             *pch &&
             (*pch!=chPATH_SEP1) &&
             (*pch!=chPATH_SEP2) &&
             ((*pch!=chDRIVE_SEP) || ((*(pch+1)==chPATH_SEP1) || // Not "d:\"
                                      (*(pch+1)==chPATH_SEP2)));
             CharIncr(pch)) {
            ; //
        }
        pchNext = pch;                  // Location of next path separator

        //** Don't process last component if caller said it was a filename
        if ((*pchNext != '\0') || !fHasFileName) {
            //** We have a partial path; make sure directory exists
            cch = (int)(pchNext - pszPath);      // Length of partial path
            if ((cch>0) &&
                ((*pchNext == chDRIVE_SEP) || (*(pchNext-1) == chDRIVE_SEP))) {
                //** Have "d:xxx" or "d:\xxx", so need to include ":" or "\"!
                cch++;
            }
            strncpy(achDir,pszPath,cch);
            achDir[cch] = '\0';         // Terminate path
            _mkdir(achDir);             // Ignore any error
        }
    }

    //** Check for special case of root directory: "\" or "\xxx.yyy"
    if ((strlen(achDir) == 0) &&
        (strlen(pszPath) > 0) &&
        ((*pszPath == chPATH_SEP1) || (*pszPath == chPATH_SEP2))) {
        achDir[0] = *pszPath;
        achDir[1] = '\0';
    }

    //** Make sure there is an appropriate separator
    cch = strlen(achDir);
    cchNoPathSep = cch;                 // For error reporting
    if (cch > 0)
    {
        cch += appendPathSeparator(&(achDir[cch-1]));
    }

    //** Make sure we can write to the directory
    //   achDir = Has path of directory to test
    cErrors = 0;                        // No errors, so far
    for (i=0; i<999; i++) {
        //** Form full file name
        sprintf(&achDir[cch],"CAB%5.5d.TMP",GetCurrentProcessId()+i);

        //** Make sure file does not exist, and can be created and written to
        fh = _open(achDir,
                   _O_CREAT | _O_EXCL | _O_RDWR,  // Must not exist, read/write
                   _S_IREAD | _S_IWRITE);       // Read & Write permission

        //** Figure out what happened
        if (fh == -1) {
            switch (errno) {
                case EACCES:            // Was a dir, or read-only
                    cErrors++;
                    if (cErrors < 5) {  // Tolerate this a few times
                        continue;       // Try next temp file name
                    }
                    achDir[cchNoPathSep] = '\0'; // Remove temp file name
                    ErrSet(perr,pszFILERR_DIR_NOT_WRITEABLE,"%s",achDir);
                    return FALSE;

                case EEXIST:            // File already exists -- good sign!
                    continue;           // Try next temp file name

                case EMFILE:            // Out of file handles
                    achDir[cchNoPathSep] = '\0'; // Remove temp file name
                    ErrSet(perr,pszFILERR_NO_MORE_FILE_HANDLES,"%s",achDir);
                    return FALSE;

                case EINVAL:            // oflag and/or pmode args are bad
                    if (_doserrno == ERROR_DELETE_PENDING) {
                        continue;
                    }

                    // fall through

                case ENOENT:            // File/Path not found
                default:
                    printf("EnsureDirectory: Cant create file: %s, errno=%d, _doserrno=%d, GLE=%d\n",
                           achDir, errno, _doserrno, GetLastError() );
                    achDir[cchNoPathSep] = '\0'; // Remove temp file name

                    ErrSet(perr,pszFILERR_CANT_MAKE_DIR,"%s%d%d",
                           achDir, errno, _doserrno);
                    return FALSE;
            }
        }

        //** File was created, close it, delete it, and we're golden
        _close(fh);         // Done with file
        _unlink(achDir);        // Get rid of it
        return TRUE;                    // Success
    }

    //** Ran out of temp file names
    achDir[cchNoPathSep] = '\0';        // Remove temp file name
    ErrSet(perr,pszFILERR_OUT_OF_TMP_FILE_NAMES,"%d%s",i,achDir);
    return FALSE;
} /* ensureDirectory() */


/***    ensureFile - Ensure a file can be created
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL ensureFile(char *pszFile, char *pszDesc, PERROR perr)
{
    int fh;
    //** Make sure directory is present
    if (!ensureDirectory(pszFile,TRUE,perr)) {
        //** Override error message with more meaningful one
        ErrSet(perr,pszFILERR_CANT_CREATE_FILE,"%s%s",pszDesc,pszFile);
        return FALSE;
    }

    //** Make sure file can be created
    fh = _open(pszFile,
               _O_CREAT | _O_RDWR,      // Create if necessary, read/write
               _S_IREAD | _S_IWRITE);   // Read & Write permission
    if (fh == -1) {
        switch (errno) {
            case EMFILE:                // Out of file handles
                ErrSet(perr,pszFILERR_NO_MORE_FILE_HANDLES,"%s",pszFile);
                return FALSE;

            case EACCES:                // Was a dir, or read-only
            case ENOENT:                // File/Path not found
            case EINVAL:                // oflag and/or pmode args are bad
            default:
                ErrSet(perr,pszFILERR_CANT_CREATE_FILE,"%s%s",pszDesc,pszFile);
                return FALSE;
        }
    }

    //** File was created; close it, delete it, and we're golden
    _close(fh);                         // Done with file
    _unlink(pszFile);                   // Get rid of it

    return TRUE;
} /* ensureFile() */


/***    getJustFileNameAndExt - Get last component in filespec
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
char *getJustFileNameAndExt(char *pszPath, PERROR perr)
{
    char   *pch=pszPath;
    char   *pchStart=pszPath;           // Assume filespec is just a name[.ext]

    //** Find last path separator
    while (*pch) {
        switch (*pch) {
            case chPATH_SEP1:
            case chPATH_SEP2:
            case chDRIVE_SEP:
                pchStart = pch+1;       // Name starts after path/drive separator
                break;
        }
        CharIncr(pch); // Check next character
    }

    //** Make sure file name is not empty
    if (*pchStart == '\0') {            // Empty file name
        ErrSet(perr,pszFILERR_EMPTY_FILE_NAME,"%s",pszPath);
        return NULL;                    // Failure
    }
    else {
        return pchStart;                // Success
    }
} /* getJustFileNameAndExt() */


/***    IsWildMatch - Test filespec against wild card specification
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL IsWildMatch(char *pszPath, char *pszWild, PERROR perr)
{
    char    chNext;
    char   *psz;
    char   *psz1;                       // Walks through filespec
    char   *psz2;                       // Walks through pattern

    // 10/24/96 jforbes Make *.* match everything, even i.have.many.dots
    if (!strcmp(pszWild, pszALL_FILES))
        return TRUE;

    psz1 = pszPath;                     // Filespec to test
    psz2 = pszWild;                     // Test pattern

        // While there is pattern to account for keep going
    while (*psz2) {
        switch (*psz2) {                // Handle wild card chars in pattern

        case chWILD_RUN:
            //** Find next non-wildcard character => treat run of */? as 1 *
            for (psz=psz2+1;
                 (*psz == chWILD_RUN) || (*psz == chWILD_CHAR);
                 CharIncr(psz)) {
                ; //** Skip through pattern string
            }
            //** *psz is either EOL, or not a wildcard
            chNext = *psz;              // Character to terminate run
            //** Span until run terminates -- either
            while ((*psz1 != '\0') &&   // Don't run off filespec
                   (*psz1 != chNext) && // Stop at run terminator
                   (*psz1 != chNAME_EXT_SEP)) { // "." not allowed to match
                CharIncr(psz1);
            }
            //** At this point, we've matched as much as we could;
            //      If there is a failure, the next iteration through the
            //      loop will find it;  So, just update the pattern position.
            psz2 = psz;
            break;

        case chWILD_CHAR:
            if (*psz1 == chNAME_EXT_SEP) { // Match anything but "."
                return FALSE;           // Found point of mismatch
            }
            if (*psz1)
                CharIncr(psz1);    // Next position in filespec
            CharIncr(psz2);        // Next position in pattern
            break;

        case chNAME_EXT_SEP:
            if (*psz1 == chNAME_EXT_SEP)  {
                psz1++;
                CharIncr(psz2);
            } else if (*psz1 == '\0')  {
                CharIncr(psz2);
            } else {
                return FALSE;
            }
            break;

        default:
            if (toupper(*psz1) != toupper(*psz2)) { // Still match
                return FALSE;           // Found point of mismatch
            }
            if (*psz1)
                CharIncr(psz1);                     // Next position in filespec
            CharIncr(psz2);                     // Next position in pattern
            break;
        }
    }

    //** We have a match if *both* strings were fully consumed
    return ((*psz1 == '\0') && (*psz2 == '\0'));
} /* IsWildMatch() */


#pragma optimize("",off)    // Avoid optimizer warning on in-line ASM
/***    IsPathRemovable - See if path refers to a removable media drive
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL IsPathRemovable(char *pszPath, char *pchDrive)
{
    char   ach[4]="x:\\";       // Buffer for "x:\"
    BOOL   fRemovable;
    char   iDrive;

    //** Get drive for path
    if ((strlen(pszPath) >= 2) &&
        isalpha(pszPath[0])    &&
        (pszPath[1] == chDRIVE_SEP)) {
        iDrive = toupper(pszPath[0]) - 'A' + 1;
    }
    else {
    iDrive = (char)_getdrive();
    }
    *pchDrive = 'A' + iDrive - 1;       // Return drive letter

#ifdef BIT16
    //** Do it the MS-DOS way
    _asm {
        mov     fRemovable,0    ; Assume not removable
        mov     bl,iDrive       ; (0=default; 1=A, ...)
        mov     ax,4408h        ; IOCTL Get Removable Media
        int     21h             ; Call MS-DOS
        jc      not_removable   ; Error, assume not removable

        or      ax,ax           ; Test removability flag
        jne     not_removable

        mov     fRemovable,1    ; Drive is removable

    not_removable:
    }
#else // !BIT16
    //** Do it the Win32 way
    ach[0] = *pchDrive;         // Construct path to root of drive to test
    fRemovable = GetDriveType(ach) == DRIVE_REMOVABLE;
#endif
    return fRemovable;                  // Return removability
} /* IsPathRemovable() */
#pragma optimize("",on)     // Restore previous Optimization settings


/***    GetFileTimeAndAttr - Get date, time, and attributes from a file
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL GetFileTimeAndAttr(PFILETIMEATTR pfta, char *pszFile, PERROR perr)
{
#ifdef BIT16
    //** Do it the MS-DOS way
    int     hf;

    hf = _open(pszFile, _O_RDONLY | _O_BINARY);
    if (hf == -1) {
        ErrSet(perr,pszFILERR_OPEN_FAILED,"%s",pszFile);
        return FALSE;
    }
//WARNING: 30-Mar-1994 bens Ignore errors???
    _dos_getftime(hf,&pfta->date,&pfta->time);
    _close(hf);
    _dos_getfileattr(pszFile,&pfta->attr);
    return TRUE;

#else // !BIT16
    //** Do it the Win32 way
    BOOL        rc;
    FILETIME    ft;
    FILETIME    ftUTC;      // Win32 returns Universal Time Code
    HANDLE  hfQuery;

    hfQuery = CreateFile(pszFile,       // open again with Win32
                 GENERIC_READ,  // Just to read
                 FILE_SHARE_READ,// Coexist with previous open
                 NULL,      // No security
                 OPEN_EXISTING, // Must exist
             0L,        // We're not setting any attributes
                 NULL);     // No template handle
    if (hfQuery == INVALID_HANDLE_VALUE) {
        ErrSet(perr,pszFILERR_OPEN_FAILED,"%s",pszFile);
        return FALSE;
    }

    //** Get date/time and convert it
    rc = GetFileTime(hfQuery,NULL,NULL,&ftUTC);
    rc |= FileTimeToLocalFileTime(&ftUTC,&ft); // Apply timezone
    rc |= FileTimeToDosDateTime(&ft,&pfta->date,&pfta->time);
    CloseHandle(hfQuery);

    //** Get attributes and convert them
    pfta->attr = AttrFATFromAttr32(GetFileAttributes(pszFile));
    if (!rc) {
        ErrSet(perr,pszFILERR_CANNOT_GET_FILE_INFO,"%s",pszFile);
        return FALSE;
    }
    return TRUE;
#endif
} /* GetFileTimeAndAttr() */


/***    SetFileTimeAndAttr - Set date, time, and attributes of a file
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL SetFileTimeAndAttr(char *pszFile, PFILETIMEATTR pfta, PERROR perr)
{
#ifdef BIT16
    //** Do it the MS-DOS way

    int     hf;

    hf = _open(pszFile,_O_WRONLY | _O_BINARY);
    if (hf == -1) {
        ErrSet(perr,pszFILERR_OPEN_FAILED,"%s",pszFile);
        return FALSE;
    }

    _dos_setftime(hf,pfta->date,pfta->time);
    _close(hf);
    _dos_setfileattr(pszFile,pfta->attr);
    return TRUE;

#else // !BIT16
    //** Do it the Win32 way
    HANDLE  hfSet;
    FILETIME    ft;
    FILETIME    ftUTC;      // Win32 needs Universal Time Code
    BOOL        rc;

    hfSet = CreateFile(pszFile,       // open with Win32
                       GENERIC_WRITE, // Need to be able to modify properties
                       0,             // Deny all
                       NULL,          // No security
                       OPEN_EXISTING, // Must exist
                       0L,            // We're not setting any attributes
                       NULL);         // No template handle
    if (hfSet == INVALID_HANDLE_VALUE) {

        //  Changed this to retry because NT 4.0 occasionally returns a
        //  sharing violation even though we've just closed the file.
        //  Although this always worked in testing, also made it non-fatal so
        //  that if the retry doesn't work it won't abort the extraction.

        Sleep(100);     // give OS opportunity to sort it out

        hfSet = CreateFile(pszFile,   // open with Win32
                       GENERIC_WRITE, // Need to be able to modify properties
                       0,             // Deny all
                       NULL,          // No security
                       OPEN_EXISTING, // Must exist
                       0L,            // We're not setting any attributes
                       NULL);         // No template handle

        if (hfSet == INVALID_HANDLE_VALUE) {
            return TRUE;
        }
    }

    rc = DosDateTimeToFileTime(pfta->date,pfta->time,&ft);
    rc |= LocalFileTimeToFileTime(&ft, &ftUTC); // Apply timezone
    rc |= SetFileTime(hfSet,NULL,NULL,&ftUTC);
    CloseHandle(hfSet);
    rc |= SetFileAttributes(pszFile,Attr32FromAttrFAT(pfta->attr));
    if (!rc) {
        ErrSet(perr,pszFILERR_CANNOT_SET_FILE_INFO,"%s",pszFile);
        return FALSE;
    }
    return TRUE;
#endif // !BIT16
} /* SetFileTimeAndAttr() */


/***    CopyOneFile - Make a faithful copy of a file
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
BOOL CopyOneFile(char                      *pszDst,
                 char                      *pszSrc,
                 BOOL                       fCopy,
                 UINT                       cbBuffer,
                 PFNOVERRIDEFILEPROPERTIES  pfnofp,
                 void                      *pv,
                 PERROR                     perr)
{
    UINT            cbRead;
    UINT            cbWritten;
    BOOL            fSuccess = FALSE;   // Assume failure
    FILETIMEATTR    fta;
    int             hfDst    = -1;
    int             hfSrc    = -1;
    char           *pbuf     = NULL;

    //** Open source
    hfSrc = _open(pszSrc, _O_RDONLY | _O_BINARY);
    if (hfSrc == -1) {
        ErrSet(perr,pszFILERR_OPEN_FAILED,"%s",pszSrc);
        goto cleanup;
    }

    //** Get file date, time, and attributes for source file
    if (!GetFileTimeAndAttr(&fta,pszSrc,perr)) {
        goto cleanup;
    }

    //** Permit caller to override date/time/attr
    if (pfnofp != NULL) {
        if (!(*pfnofp)(&fta,pv,perr)) { // Call override function
            goto cleanup;               // Error, go cleanup
        }
    }

    //** Early out if we were just merging file date/time/attr values
    if (!fCopy) {
        fSuccess = TRUE;                // Success
        goto cleanup;                   // Go close source and exit
    }

    //** Get copy buffer
    if (!(pbuf = MemAlloc(cbBuffer))) {
        ErrSet(perr,pszFILERR_NO_MEMORY_FOR_BUFFER,"%s%s",pszSrc,pszDst);
        goto cleanup;
    }

    //** Open destination
    hfDst = _open(pszDst,
                  _O_BINARY | _O_WRONLY | _O_CREAT | _O_TRUNC, // No translation, R/W
                  _S_IREAD | _S_IWRITE); // Attributes when file is closed
    if (hfDst == -1) {
        ErrSet(perr,pszFILERR_OPEN_FAILED,"%s",pszDst);
        goto cleanup;
    }

    //** Copy data
    while (!_eof(hfSrc)) {
        //** Read chunk
        cbRead = _read(hfSrc,pbuf,cbBuffer);
        if (cbRead == -1) {
            ErrSet(perr,pszFILERR_READ_FILE,"%s",pszSrc);
            goto cleanup;
        }
        else if (cbRead != 0) {     // Not at EOF
            //** Write it
            cbWritten = _write(hfDst,pbuf,cbRead);
            if (cbWritten != cbRead) {
                ErrSet(perr,pszFILERR_WRITE_FILE,"%s",pszSrc);
                goto cleanup;
            }
        }
    }
    //** Done copying, close destination file handle
    _close(hfDst);
    hfDst = -1;                         // Avoid unnecessary close in cleanup

    //** Set file date, time, and attributes
    if (!SetFileTimeAndAttr(pszDst,&fta,perr)) {
        goto cleanup;
    }

    //** Success!
    fSuccess = TRUE;

cleanup:
    if (hfDst != -1) {
        _close(hfDst);
    }
    if (hfSrc != -1) {
        _close(hfSrc);
    }
    if (pbuf) {
        MemFree(pbuf);
    }

    return fSuccess;
} /* CopyOneFile() */


#ifndef BIT16
//** Win32 stuff

/***    Attr32FromAttrFAT - Convert FAT file attributes to Win32 form
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
DWORD Attr32FromAttrFAT(WORD attrMSDOS)
{
    //** Quick out for normal file special case
    if (attrMSDOS == _A_NORMAL) {
        return FILE_ATTRIBUTE_NORMAL;
    }

    //** Otherwise, mask off read-only, hidden, system, and archive bits
    //   NOTE: These bits are in the same places in MS-DOS and Win32!
    //
    Assert(_A_RDONLY == FILE_ATTRIBUTE_READONLY);
    Assert(_A_HIDDEN == FILE_ATTRIBUTE_HIDDEN);
    Assert(_A_SYSTEM == FILE_ATTRIBUTE_SYSTEM);
    Assert(_A_ARCH   == FILE_ATTRIBUTE_ARCHIVE);
    return attrMSDOS & (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
}


/***    AttrFATFromAttr32 - Convert Win32 file attributes to FAT form
 *
 *  NOTE: See fileutil.h for entry/exit conditions.
 */
WORD AttrFATFromAttr32(DWORD attr32)
{
    //** Quick out for normal file special case
    if (attr32 & FILE_ATTRIBUTE_NORMAL) {
        return _A_NORMAL;
    }

    //** Otherwise, mask off read-only, hidden, system, and archive bits
    //   NOTE: These bits are in the same places in MS-DOS and Win32!
    //
    Assert(_A_RDONLY == FILE_ATTRIBUTE_READONLY);
    Assert(_A_HIDDEN == FILE_ATTRIBUTE_HIDDEN);
    Assert(_A_SYSTEM == FILE_ATTRIBUTE_SYSTEM);
    Assert(_A_ARCH   == FILE_ATTRIBUTE_ARCHIVE);
    return ((WORD)attr32) & (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
}

#endif // !BIT16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\fileutil.h ===
/***    fileutil.h - Utility routines for dealing with files
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      20-Feb-1994 bens    Initial version (code from diamond.c)
 *      23-Feb-1994 bens    Added createTempFile()
 *      23-Feb-1994 bens    Added richer tempfile routines
 *      23-Mar-1994 bens    Added Win32<->MS-DOS file attribute mapping
 *      03-Jun-1994 bens    VER.DLL support
 *      07-Jun-1994 bens    Move VER.DLL stuff to filever.c
 *      14-Dec-1994 bens    Update list of exported functions
 *
 *  Exported Functions:
 *      CopyOneFile           - Make a faithful copy of a file
 *      getFileSize           - Get size of a file
 *      GetFileTimeAndAttr    - Get date, time, and attributes from a file
 *      SetFileTimeAndAttr    - Set date, time, and attributes of a file
 *      appendPathSeparator   - Append a path separator only if necessary
 *      catDirAndFile         - Concatenate a possibly empty dir and file name
 *      ensureDirectory       - Ensure directory exists (creating as needed)
 *      ensureFile            - Ensure a file can be created
 *      getJustFileNameAndExt - Get last component in filespec
 *      Attr32FromAttrFAT     - Convert FAT file attributes to Win32 form
 *      AttrFATFromAttr32     - Convert Win32 file attributes to FAT form
 *      IsWildMatch           - Test filespec against wild card specification
 *      IsPathRemovable       - See if path refers to a removable media drive
 *      TmpCreate             - Create a temporary file
 *      TmpGetStream          - Get FILE* from HTEMPFILE, to perform I/O
 *      TmpGetDescription     - Get description of temporary file
 *      TmpGetFileName        - Get filename of temporary file
 *      TmpClose              - Close temporary file, but keep tempfile handle
 *      TmpOpen               - Open the stream for a temporary file
 *      TmpDestroy            - Delete tempfil and destroy handle
 */

#ifndef INCLUDED_FILEUTIL
#define INCLUDED_FILEUTIL 1

#include "error.h"
#include <stdio.h>

typedef void *HTEMPFILE;

//** Maximum path length
#define cbFILE_NAME_MAX     256     // Maximum filespec length

#define pszALL_FILES      "*.*" // Match all files

//** File name characters & wild card characters
#define chPATH_SEP1     '\\'    // Character to separate file path components
#define chPATH_SEP2      '/'    // Character to separate file path components
                                //  Ex: one<\>two<\>foo.dat

#define chNAME_EXT_SEP   '.'    // Character that separates file name and ext
                                //  Ex: one\two\foo<.>dat

#define chDRIVE_SEP      ':'    // Character that separates drive letter
                                //  Ex: a<:>\foo.dat

#define chWILD_RUN       '*'    // Wild card character that matches a run

#define chWILD_CHAR      '?'    // Wild card character that matches single char


/***    FILETIMEATTR - Lowest common denominator file date/time/attributes
 *
 *  The format of these match the MS-DOS FAT file system.
 */
typedef struct {
    USHORT  date;                       // file date
    USHORT  time;                       // file time
    USHORT  attr;                       // file attibutes
} FILETIMEATTR; /* fta */
typedef FILETIMEATTR *PFILETIMEATTR; /* pfta */


/***    PFNOVERRIDEFILEPROPERTIES - Function type for CopyOneFile override
 ***    FNOVERRIDEFILEPROPERTIES - macro to help define CopyOneFile override
 *
 *  Entry:
 *      pfta        - File date/time/attr structure
 *      pv          - Client context pointer
 *      perr        - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE, pfta structure may have been modified.
 *
 *  Exit-Failure:
 *      Returns FALSE,
 *      ERROR structure filled in with details of error.
 */
typedef BOOL (*PFNOVERRIDEFILEPROPERTIES)(PFILETIMEATTR  pfta,  /* pfnofp */
                                          void          *pv,
                                          PERROR         perr);
#define FNOVERRIDEFILEPROPERTIES(fn) BOOL fn(PFILETIMEATTR  pfta,   \
                                             void          *pv,     \
                                             PERROR         perr)


/***    CopyOneFile - Make a faithful copy of a file
 *
 *  Entry:
 *      pszDst   - Name of destination file
 *      pszSrc   - Name of source file
 *      fCopy    - TRUE => copy file; FALSE => open src, call pfnofp to
 *                 merge file date/time/attr values, but skip COPY!
 *      cbBuffer - Amount of temporary buffer space to use for copying
 *      pfnofp   - Function to override file properties; called with the
 *                  file date/time/attributes for pszSrc to permit client
 *                  to override these values.  Pass NULL if no override
 *                  desired.
 *      pv       - Client context pointer
 *      perr     - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; file copied successfully
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in
 */
BOOL CopyOneFile(char                      *pszDst,
                 char                      *pszSrc,
                 BOOL                       fCopy,
                 UINT                       cbBuffer,
                 PFNOVERRIDEFILEPROPERTIES  pfnofp,
                 void                      *pv,
                 PERROR                     perr);


/***    getFileSize - Get size of a file
 *
 *  Entry:
 *      pszFile - Filespec
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns size of file.
 *
 *  Exit-Failure:
 *      Returns -1; perr filled in with error.
 */
long getFileSize(char *pszFile, PERROR perr);


/***    GetFileTimeAndAttr - Get date, time, and attributes from a file
 *
 *  Entry:
 *      pfta    - Structure to receive date, time, and attributes
 *      pszFile - Name of file to inspect
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; pfta filled in
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in
 */
BOOL GetFileTimeAndAttr(PFILETIMEATTR pfta, char *pszFile, PERROR perr);


/***    SetFileTimeAndAttr - Set date, time, and attributes of a file
 *
 *  Entry:
 *      pszFile - Name of file to modify
 *      pfta    - Structure to receive date, time, and attributes
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; pfta filled in
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in
 */
BOOL SetFileTimeAndAttr(char *pszFile, PFILETIMEATTR pfta, PERROR perr);


/***    appendPathSeparator - Append a path separator only if necessary
 *
 *  Entry:
 *      pszPathEnd - Pointer to last character in a path string
 *                      (will be NULL byte if path is empty).
 *                   Buffer is assumed to have room for one more character!
 *
 *  Exit:
 *      Returns 1 if a path separator was appended
 *      Returns 0 if no path separator was appended:
 *          1) Path was empty -or-
 *          2) Last character of path was '\', '/', or ':'
 */
int appendPathSeparator(char *pszPathEnd);


/***    catDirAndFile - Concatenate a possibly empty dir and file name
 *
 *  Note: pszFile/pszFileDef can actually have path characters, and do not
 *        need to be file names.  Essentially, this function just concatenates
 *        two strings together, ensuring a path separator is between them!
 *
 *  Entry:
 *      pszResult  - Buffer to receive concatentation
 *      cbResult   - Size of pszResult
 *      pszDir     - Possibly empty directory string
 *      pszFile    - Possibly empty file string
 *      pszFileDef - Path string to use if pszFile is empty; if NULL, then
 *                      pszFile must NOT be empty.  If not NULL, and pszFile
 *                      is empty, then pszFileDef is examined, any path
 *                      prefixes are removed, and the base filename.ext
 *                      is used.
 *      perr       - ERROR structure to fill in
 *
 *  Exit-Success:
 *      Returns TRUE; pszResult filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in with error.
 */
BOOL catDirAndFile(char * pszResult,
                   int    cbResult,
                   char * pszDir,
                   char * pszFile,
                   char * pszFileDef,
                   PERROR perr);


/***    ensureDirectory - Ensure directory exists (creating as needed)
 *
 *  Entry:
 *      pszPath      - File spec with directory names to ensure exist
 *      fHasFileName - TRUE if pszPath has file name at end.  In this case
 *                          the last component of pszPath is ignored.
 *      perr         - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; directory exists
 *
 *  Exit-Failure:
 *      Returns FALSE; could not create directory, perr filled in with error.
 */
BOOL ensureDirectory(char *pszPath, BOOL fHasFileName, PERROR perr);


/***    ensureFile - Ensure a file can be created
 *
 *  Creates any directories that are needed, then creates file and deletes it.
 *
 *  Entry:
 *      pszPath - File spec with directory names to ensure exist
 *      pszDesc - Description of type of file (for error message).
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; file can be created
 *
 *  Exit-Failure:
 *      Returns FALSE; could not create file, perr filled in with error.
 */
BOOL ensureFile(char *pszFile, char *pszDesc, PERROR perr);


/***    getJustFileNameAndExt - Get last component in filespec
 *
 *  Entry:
 *      pszPath - Filespec to parse
 *      perr    - ERROR structure to fill in
 *
 *  Exit-Success:
 *      Returns pointer into pszPath where last component starts
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in with error.
 */
char *getJustFileNameAndExt(char *pszPath, PERROR perr);


/***    Attr32FromAttrFAT - Convert FAT file attributes to Win32 form
 *
 *  Entry:
 *      attrMSDOS - MS-DOS (FAT file system) file attributes
 *
 *  Exit:
 *      Returns equivalent attributes in Win32 format.
 */
DWORD Attr32FromAttrFAT(WORD attrMSDOS);


/***    AttrFATFromAttr32 - Convert Win32 file attributes to FAT form
 *
 *  Entry:
 *      attrMSDOS - MS-DOS (FAT file system) file attributes
 *
 *  Exit:
 *      Returns equivalent attributes in Win32 format.
 */
WORD AttrFATFromAttr32(DWORD attr32);


/***    IsWildMatch - Test filespec against wild card specification
 *
 *  Entry:
 *      pszPath - Filespec to test; Must not have path characters -- use
 *                  getJustFileNameAndExt() to get rid of them.
 *      pszWild - Pattern to test against (may have wild cards)
 *      perr    - ERROR structure to fill in
 *
 *  Exit-Success:
 *      Returns TRUE; pszPath matches pszWild
 *
 *  Exit-Failure:
 *      Returns FALSE; no match; use ErrIsError(perr) to see if error
 *          occured.
 */
BOOL IsWildMatch(char *pszPath, char *pszWild, PERROR perr);


/***    IsPathRemovable - See if path refers to a removable media drive
 *
 *  Entry:
 *      pszPath  - Path to test
 *      pchDrive - Pointer to character to receive drive letter
 *
 *  Exit-Success:
 *      Returns TRUE; path refers to removable media
 *
 *  Exit-Failure:
 *      Returns FALSE; path is not removable
 *          occured.
 */
BOOL IsPathRemovable(char *pszPath, char *pchDrive);


/***    TmpCreate - Create a temporary file
 *
 *  Entry:
 *      pszDesc   - Description of temp file (for error reporting)
 *      pszPrefix - Filename prefix
 *      pszMode   - Mode string passed to fopen ("wt", "wb", "rt", etc.)
 *      perr      - ERROR structure
 *
 *  Exit-Success:
 *      Returns non-null HTEMPFILE; temp file created and open
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in
 */
HTEMPFILE TmpCreate(char *pszDesc, char *pszPrefix, char *pszMode, PERROR perr);


/***    TmpGetStream - Get FILE* from HTEMPFILE, to perform I/O
 *
 *  Entry:
 *      htmp - Handle to temp file
 *      perr - ERROR structure
 *
 *  Exit-Success:
 *      Returns non-null FILE*
 *
 *  Exit-Failure:
 *      Returns NULL; If ErrIsError(perr) indicates no error, then the
 *          stream had simply been closed with TmpClose().  Else, perr has
 *          error details.
 */
FILE *TmpGetStream(HTEMPFILE htmp, PERROR perr);


/***    TmpGetDescription - Get description of temporary file
 *
 *  Entry:
 *      htmp - Handle to temp file
 *      perr - ERROR structure
 *
 *  Exit-Success:
 *      Returns non-null pointer to description
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in
 */
char *TmpGetDescription(HTEMPFILE htmp, PERROR perr);


/***    TmpGetFileName - Get filename of temporary file
 *
 *  Entry:
 *      htmp - Handle to temp file
 *      perr - ERROR structure
 *
 *  Exit-Success:
 *      Returns non-null pointer to temp filename
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in
 */
char *TmpGetFileName(HTEMPFILE htmp, PERROR perr);


/***    TmpClose - Close a temporary file stream, but keep tempfile handle
 *
 *  Entry:
 *      htmp - Handle to temp file;
 *             NOTE: This call is a NOP if the stream is already closed.
 *      perr - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; stream closed
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in
 */
BOOL TmpClose(HTEMPFILE htmp, PERROR perr);


/***    TmpOpen - Open the stream for a temporary file
 *
 *  Entry:
 *      htmp    - Handle to temp file
 *      pszMode - Mode string passed to fopen ("wt", "wb", "rt", etc.)
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; stream opened
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in
 */
BOOL TmpOpen(HTEMPFILE htmp, char *pszMode, PERROR perr);


/***    TmpDestroy - Delete tempfil and destroy handle
 *
 *  Entry:
 *      htmp    - Handle to temp file
 *      perr    - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE; tempfile destroyed
 *
 *  Exit-Failure:
 *      Returns NULL; perr filled in
 */
BOOL TmpDestroy(HTEMPFILE htmp, PERROR perr);


#endif // !INCLUDED_FILEUTIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\fixchg.h ===
/* fixchg.h */

/*  Inoperative changelines usually cause problems when switching between   */
/*  1.44Mb diskettes and 1.68Mb DMF diskettes.  FixChangeline() tries to    */
/*  assure that drives A: and B: will not depend upon proper operation of   */
/*  the drive's changeline.                                                 */

#ifndef INCLUDED_FIXCHG
#define INCLUDED_FIXCHG
extern void FixChangelines(void);
#endif //INCLUDED_FIXCHG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\fixchg.c ===
/* fixchg.c */

/*  Inoperative changelines frequenly cause problems when switching between */
/*  1.44Mb diskettes and 1.68Mb DMF diskettes.  FixChangeline() tries to    */
/*  assure that drives A: and B: will not depend upon proper operation of   */
/*  the drive's changeline.  If these efforts fail, it's no big deal; we    */
/*  do this without even knowing whether the changeline works or not.       */

#include "fixchg.h"             /* prototype verification */

/* --- definitions -------------------------------------------------------- */

/*  See Microsoft MS-DOS Programmer's Reference V6.0, p.38, 312, 319 */

typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;

#pragma pack (1)

typedef struct
{
    WORD    tklSectorNum;       /* this physical position's sector number */
    WORD    tklSectorSize;      /* size of this sector in bytes */
} NUMSIZE;

typedef struct
{
    WORD    tklSectors;         /* number of sectors in the layout */
    NUMSIZE tklNumSize[1];      /* don't need much of this, not used here */
} TRACKLAYOUT;

typedef struct
{
    WORD    dpBytesPerSec;      /* bytes per sector */
    BYTE    dpSecPerClust;      /* sectors per cluster */
    WORD    dpResSectors;       /* reserved sectors */
    BYTE    dpFATs;             /* number of copies of the FAT */
    WORD    dpRootDirEnts;      /* number of entries in the root directory */
    WORD    dpSectors;          /* total # of sectors, 0->more than 64k */
    BYTE    dpMedia;            /* media descriptor byte */
    WORD    dpFATsecs;          /* sectors per copy of the FAT */
    WORD    dpSecPerTrack;      /* sectors per track */
    WORD    dpHeads;            /* number of heads */
    DWORD   dpHiddenSecs;       /* sectors hidden before boot sector */
    DWORD   dpHugeSectors;      /* number of sectors if > 64k sectors */
    WORD    reserved[3];
} BPB;

typedef struct
{
    BYTE    dpSpecFunc;         /* special functions */
    BYTE    dpDevType;          /* device type, 7=1.44Mb, 9=2.88Mb, etc. */
    WORD    dpDevAttr;          /* device's attributes */
    WORD    dpCylinders;        /* number of cylinders */
    BYTE    dpMediaType;        /* media type, more like density code */
    BPB     dpBPB;              /* the BPB (default or current) */
    TRACKLAYOUT dpTrackLayout;  /* track layout field appended for set call */
} DEVICEPARAMS, far *PFDEVICEPARAMS;

#pragma pack()

#define     SPECIAL_GET_DEFAULT 0   /* get information for default media */
#define     SPECIAL_SET_DEFAULT 4   /* set default media, good track layout */

#define     ATTR_NONREMOVABLE   1   /* attr bit for non-removable device */
#define     ATTR_CHANGELINE     2   /* attr bit for changeline supported */

/* --- FixChangelines() --------------------------------------------------- */

#pragma warning(disable:4704)  /* no in-line balking */

void FixChangelines(void)
{
    WORD dosVersion;
    DEVICEPARAMS dp;
    PFDEVICEPARAMS pfDp;
    WORD drive;
    WORD owner;

    _asm    mov     ah,30h          ; get DOS version
    _asm    int     21h
    _asm    xchg    ah,al
    _asm    mov     dosVersion,ax


    /*  these IoCtls were new to MS-DOS 3.2.  (But then, 1.44Mb drives      */
    /*  weren't supported until 3.3, so needing this is pretty unlikely.)   */

    if (dosVersion < (0x300 + 20))
    {
        return;     /* prior versions don't need help */
    }

    pfDp = &dp;     /* make a far pointer to DEVICEPARAMS structure */

    for (drive = 1; drive <= 2; drive++)        /* do A: and B: */
    {
        /*  get drive owner so we can restore it                            */

        _asm    mov     owner,0         ; assume not shared
        _asm    mov     ax,440Eh        ; Get Logical Drive Map
        _asm    mov     bx,drive        ; drive number
        _asm    int     21h             ; execute DOS request
        _asm    jc      no_owner        ;   if failed
        _asm    mov     owner,ax        ; save owner (AL)

        /*  set drive owner to suppress "Insert diskette for drive..."      */

        _asm    mov     ax,440Fh        ; Set Logical Drive Map
        _asm    mov     bx,drive        ; drive number
        _asm    int     21h             ; execute DOS request

        /*  MS-DOS 5.0 added query Ioctl, to see if the calls we need are   */
        /*  supported.  This is highly unlikely to fail.                    */

no_owner:

        if (dosVersion >= 0x500)
        {
            _asm    mov     ax,4411h    ; Query Ioctl device
            _asm    mov     bx,drive    ; drive number
            _asm    mov     cx,0840h    ; check on SET DEVICE PARAMETERS
            _asm    int     21h         ; execute DOS request
            _asm    jc      failed      ;   if not supported

            _asm    mov     ax,4411h    ; Query Ioctl device
            _asm    mov     bx,drive    ; drive number
            _asm    mov     cx,0860h    ; check on GET DEVICE PARAMETERS
            _asm    int     21h         ; execute DOS request
            _asm    jc      failed      ;   if not supported
        }


        /*  get information about this physical device */

        dp.dpSpecFunc = SPECIAL_GET_DEFAULT;

        _asm    push    ds              ; preserve data selector
        _asm    mov     ax,440Dh        ; generic IoCtl
        _asm    mov     bx,drive        ; drive number 1=A: 2=B:
        _asm    mov     cx,0860h        ; DISK / GET DEVICE PARAMETERS
        _asm    lds     dx,pfDp         ; pointer to DEVICEPARAMS structure
        _asm    int     21h             ; execute DOS request
        _asm    pop     ds              ; restore data selector
        _asm    jc      failed          ;   if error


        /*  is this device is removable and claims changeline is supported? */

        if ((dp.dpDevAttr & (ATTR_NONREMOVABLE | ATTR_CHANGELINE)) ==
                ATTR_CHANGELINE)        /* if removable with changeline: */
        {
            /*  modify device to "changeline not supported" */

            dp.dpSpecFunc = SPECIAL_SET_DEFAULT;
            dp.dpDevAttr &= ~ATTR_CHANGELINE;   /* disable changeline */
            dp.dpTrackLayout.tklSectors = 0;    /* no layout being sent */
            dp.dpBPB.reserved[0] = 0;
            dp.dpBPB.reserved[1] = 0;
            dp.dpBPB.reserved[2] = 0;

            _asm    push    ds          ; preserve data selector
            _asm    mov     ax,440Dh    ; generic IoCtl
            _asm    mov     bx,drive    ; drive number 1=A: 2=B:
            _asm    mov     cx,0840h    ; DISK / SET DEVICE PARAMETERS
            _asm    lds     dx,pfDp     ; pointer to DEVICEPARAMS structure
            _asm    int     21h         ; execute DOS request
            _asm    pop     ds          ; restore data selector
        }

failed:
        /*  restore initial drive owner  */

        _asm    mov     ax,440Fh        ; Set Logical Drive Map
        _asm    mov     bx,owner        ; drive number
        _asm    or      bx,bx           ; is it shared?
        _asm    jz      nextdrive       ;   if not shared
        _asm    int     21h             ; execute DOS request

nextdrive:
        continue;   /* C labels require some statement */
    }

    return;
}

/* --- stand-alone test stub ---------------------------------------------- */

#ifdef  STANDALONE

void main(void)
{
    FixChangelines();
}

#endif

/* ------------------------------------------------------------------------ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\oldnames.h ===
/***    oldnames.h - Conversion of non-standard C runtime names
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *      History:
 *          01-Sep-1998 v-sbrend  Initial version
 */

#ifndef INCLUDED_OLDNAMES
#define INCLUDED_OLDNAMES 1

//
// If this isn't a 16-bit generation define some of the older C
// runtime routines as their ANSI counterparts.  This must be included
// after the header file that defines the non-standard routine.
//
// This will alleviate the need to link with oldnames.lib
//

#ifndef BIT16

#define stricmp     _stricmp
#define strnicmp    _strnicmp
#define strdup      _strdup
#define lseek       _lseek
#define read        _read
#define write       _write
#define open        _open
#define close       _close
#define getch       _getch

#endif  // BIT16



#endif  // INCLUDED_OLDNAMES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\mem.h ===
/***    mem.h - Definitions for Memory Manager
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  The Memory Manager is a very thin layer on top of the native memory
 *  heap functions, allowing strong assertion checking and pointer
 *  validation in debug builds.
 *
 *  Author:
 *  Benjamin W. Slivka
 *
 *  History:
 *  10-Aug-1993 bens    Initial version
 *  11-Aug-1993 bens    Lift code from STOCK.EXE win app
 *  12-Aug-1993 bens    Improved comments
 *      18-Mar-1994 bens    strdup() now called _strdup(); renamed
 *      18-May-1994 bens    Allow turning off MemCheckHeap() in debug build
 *                              (it can really, really slow things down!)
 *
 *  Functions:
 *  MemAlloc  - Allocate memory block
 *  MemFree   - Free memory block
 *  MemStrDup - Duplicate string to new memory block
 *
 *  Functions available in ASSERT build:
 *      MemAssert       - Assert that pointer was allocated by MemAlloc
 *      MemCheckHeap    - Check entire memory heap
 *      MemListHeap     - List all heap entries (to stdout)
 *      MemGetSize      - Return allocated size of memory block
 *      MemSetCheckHeap - Control whether MemCheckHeap is done on every
 *                          every MemAlloc and MemFree!
 */

#ifndef INCLUDED_MEMORY
#define INCLUDED_MEMORY 1

#ifdef ASSERT

#define MemAlloc(cb)    MMAlloc(cb,__FILE__,__LINE__)
#define MemFree(pv)     MMFree(pv,__FILE__,__LINE__)
#define MemStrDup(pv)   MMStrDup(pv,__FILE__,__LINE__)

#define MemAssert(pv)   MMAssert(pv,__FILE__,__LINE__)
#define MemCheckHeap()  MMCheckHeap(__FILE__,__LINE__)
#define MemListHeap()   MMListHeap(__FILE__,__LINE__)
int MemGetSize(void *pv);

void *MMAlloc(unsigned cb, char *pszFile, int iLine);
void  MMFree(void *pv, char *pszFile, int iLine);
void  MMAssert(void *pv, char *pszFile, int iLine);
void  MMCheckHeap(char *pszFile, int iLine);
void  MMListHeap(char *pszFile, int iLine);
char *MMStrDup(char *pv, char *pszFile, int iLine);
void  MemSetCheckHeap(BOOL f);

#else // !ASSERT

#include <malloc.h>     // Get malloc()/free()
#include <string.h>     // Get _strdup()


//** No Asserts

#define MemAlloc(cb)        malloc(cb)
#define MemFree(pv)         free(pv)
#define MemStrDup(pv)       _strdup(pv)

#define MemAssert(pv)
#define MemCheckHeap()
#define MemListHeap()
#define MemGetSize(pv)
#define MemSetCheckHeap(f)

#endif // !ASSERT

#endif // !INCLUDED_MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\message.c ===
/***    message.c - Message Manager
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      10-Aug-1993 bens    Initial version
 *      13-Aug-1993 bens    Implemented message formatting
 *      21-Feb-1994 bens    Return length of formatted string
 */

#include <ctype.h>
#include <memory.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "types.h"
#include "asrt.h"
#include "mem.h"
#include "message.h"

#include "message.msg"


#ifdef BIT16

//** 16-bit build
#ifndef HUGE
#define HUGE huge
#endif

#ifndef FAR
#define FAR far
#endif

#else // !BIT16

//** Define away for 32-bit (NT/Chicago) build
#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#endif // !BIT16


typedef enum {
    atBAD,
    atSHORT,
    atINT,
    atLONG,
    atFLOAT,
    atDOUBLE,
    atLONGDOUBLE,
    atSTRING,
    atFARSTRING,
} ARGTYPE;  /* at */


int     addCommas(char *pszStart);
ARGTYPE ATFromFormatSpecifier(char *pch);
int     doFinalSubstitution(char *ach, char *pszMsg, char *apszValue[]);
int     getHighestParmNumber(char *pszMsg);


/***    MsgSet - Set a message
 *
 *  NOTE: See message.h for entry/exit conditions.
 */
int __cdecl MsgSet(char *ach, char *pszMsg, ...)
{
    int     cch;

    va_list marker;                     // For walking through function arguments
    char   *pszFmtList;                 // Format string

    Assert(ach!=NULL);
    Assert(pszMsg!=NULL);

    va_start(marker,pszMsg);            // Initialize variable arguments
    pszFmtList = (char *)va_arg(marker,char *); // Assume format string

    cch = MsgSetWorker(ach,pszMsg,pszFmtList,marker);
    va_end(marker);                     // Done with variable arguments
    return cch;
}


/***    MsgSetWorker - Set Message after va_start already called
 *
 *  NOTE: See message.h for entry/exit conditions.
 *
 *  Technique:
 *      1) Find highest parameter number in pszMsg
 *
 *    If at least one parameter:
 *      2) Parse 3rd argument to get sprintf() format strings.
 *      3) Pick up each argument and format with sprintf into array
 *
 *    Regardless of parameter count:
 *      4) Copy bytes from pszMsg to ach, replacing %N by corresponding
 *         formatted parameter.
 */
int MsgSetWorker(char *ach, char *pszMsg, char *pszFmtList, va_list marker)
{
    char    achFmt[32];                 // Temp buffer for single format specifier
    char    achValues[cbMSG_MAX];       // Buffer of formatted values
    ARGTYPE at;                         // Argument type
    char   *apszValue[cMSG_PARM_MAX];   // Pointers into achValues
    int     cch;                        // Length of format specifier
    int     cParm;                      // Highest parameter number
    BOOL    fCommas;                    // TRUE=>use Commas
    int     iParm;                      // Parameter index
    char   *pch;                        // Last character of format specifier
    char   *pchFmtStart;                // Start of single format specifier
    char   *pszNextValue;               // Location in achValues for next value
    char   *pszStart;

    //** (1) See if we have parameters to retrieve and format
    cParm = getHighestParmNumber(pszMsg);
    if (cParm > 0) {                    // Need to get values
        //** (2) Parse 3rd argument to get sprintf() format strings.
        pszNextValue = achValues;       // Start filling at front
        pch = pszFmtList;               // Start at front of format specifiers
        for (iParm=0; iParm<cParm; iParm++) { // Retrieve and format values
            apszValue[iParm] = pszNextValue; // Store pointer to formatted value
            pchFmtStart = pch;          // Remember start of specifier
            if (*pch != '%') {          // Did not get a format specifier
                // Only way to report problem is in output message buffer
                strcpy(ach,pszMSGERR_BAD_FORMAT_SPECIFIER);
                AssertErrPath(pszMSGERR_BAD_FORMAT_SPECIFIER,__FILE__,__LINE__);
                return 0;               // Failure
            }
            //** Find end of specifier
            pch++;
            while ((*pch != '\0') && (*pch != chMSG)) {
                pch++;
            }
            cch = (int)(pch - pchFmtStart);    // Length of specifier
            if (cch < 2) {              // Need at least % and one char for valid specifier
                // Only way to report problem is in output message buffer
                strcpy(ach,pszMSGERR_SPECIFIER_TOO_SHORT);
                AssertErrPath(pszMSGERR_SPECIFIER_TOO_SHORT,__FILE__,__LINE__);
                return 0;               // Failure
            }

            //** (3) Pick up each argument and format with sprintf into array

            //** Get specifier for sprintf() - we need a NULL terminator
            fCommas = pchFmtStart[1] == ',';
            if (fCommas) {               // Copy format, deleting comma
                achFmt[0] = pchFmtStart[0]; // Copy '%'
                memcpy(achFmt+1,pchFmtStart+2,cch-2); // Get rest after ','
                achFmt[cch-1] = '\0';    // Terminate specifier
            }
            else {
                memcpy(achFmt,pchFmtStart,cch); // Copy to specifier buffer
                achFmt[cch] = '\0';         // Terminate specifier
            }

            //** Format value, based on last character of format specifier
            at = ATFromFormatSpecifier(pch-1); // Get argument type
            pszStart = pszNextValue;    // Save start of value (for commas)
            switch (at) {
                case atSHORT:   pszNextValue += sprintf(pszNextValue,achFmt,
                                      va_arg(marker,unsigned short)) + 1;
                    break;

                case atINT:     pszNextValue += sprintf(pszNextValue,achFmt,
                                      va_arg(marker,unsigned int)) + 1;
                    break;

                case atLONG:    pszNextValue += sprintf(pszNextValue,achFmt,
                                      va_arg(marker,unsigned long)) + 1;
                    break;

                case atLONGDOUBLE: pszNextValue += sprintf(pszNextValue,achFmt,
#ifdef BIT16
                                      va_arg(marker,long double)) + 1;
#else // !BIT16
                //** in 32-bit mode, long double == double
                                      va_arg(marker,double)) + 1;
#endif // !BIT16
                    break;

                case atDOUBLE:  pszNextValue += sprintf(pszNextValue,achFmt,
                                      va_arg(marker,double)) + 1;
                    break;

                case atSTRING:  pszNextValue += sprintf(pszNextValue,achFmt,
                                      va_arg(marker,char *)) + 1;
                    break;

                case atFARSTRING: pszNextValue += sprintf(pszNextValue,achFmt,
                                      va_arg(marker,char FAR *)) + 1;
                    break;

                default:
                    strcpy(ach,pszMSGERR_UNKNOWN_FORMAT_SPECIFIER);
                    AssertErrPath(pszMSGERR_UNKNOWN_FORMAT_SPECIFIER,__FILE__,__LINE__);
                    return 0;           // Failure
            } /* switch */

            //**
            if (fCommas) {
                switch (at) {
                    case atSHORT:
                    case atINT:
                    case atLONG:
                        pszNextValue += addCommas(pszStart);
                        break;
                }
            }
        } /* for */
    } /* if - parameters were present */

    //** (4) Copy bytes from pszMsg to ach, replacing %N parameters with values
    return doFinalSubstitution(ach,pszMsg,apszValue);
}


/***    addCommas - Add thousand separators to a number
 *
 *  Entry:
 *      pszStart - Buffer with number at end (NULL terminated)
 *                 NOTE:  White space preceding or following number are
 *                        assumed to be part of the field width, and will
 *                        be consumed for use by any commas that are
 *                        added.  If there are not enough blanks to account
 *                        for the commas, all the blanks will be consumed,
 *                        and the field will be effectively widened to
 *                        accomodate all of the commas.
 *  Exit:
 *      Returns number of commas added (0 or more)
 */
int addCommas(char *pszStart)
{
    char    ach[20];                    // Buffer for number
    int     cb;
    int     cbBlanksBefore;
    int     cbBlanksAfter;
    int     cbFirst;
    int     cCommas;
    char   *psz;
    char   *pszSrc;
    char   *pszDst;

    //** Figure out if there are any blanks
    cbBlanksBefore = strspn(pszStart," ");  // Count blanks before number
    psz = strpbrk(pszStart+cbBlanksBefore," "); // Skip over number
    if (psz) {
        cbBlanksAfter = strspn(psz," ");    // Count blanks after number
        cb = (int)(psz - (pszStart + cbBlanksBefore)); // Length of number itself
    }
    else {
        cbBlanksAfter = 0;                  // No blanks after number
        cb = strlen(pszStart+cbBlanksBefore); // Length of number itself
    }

    //** Quick out if we don't need to add commas
    if (cb <= 3) {
        return 0;
    }
    //** Figure out how many commas we need to add
    Assert(cb < sizeof(ach));
    strncpy(ach,pszStart+cbBlanksBefore,cb); // Move number to a safe place
    cCommas = (cb - 1) / 3;             // Number of commas we need to add

    //** Figure out where to place modified number in buffer
    if ((cbBlanksBefore > 0) && (cbBlanksBefore >= cCommas)) {
        //** Eat some (but not all) blanks at front of buffer
        pszDst = pszStart + cbBlanksBefore - cCommas;
    }
    else {
        pszDst = pszStart;              // Have to start number at front of buffer
    }

    //** Add commas to the number
    cbFirst = cb % 3;                   // Number of digits before first comma
    if (cbFirst == 0) {
        cbFirst = 3;
    }
    pszSrc = ach;
    strncpy(pszDst,pszSrc,cbFirst);
    cb -= cbFirst;
    pszDst += cbFirst;
    pszSrc += cbFirst;
    while (cb > 0) {
        *pszDst++ = chTHOUSAND_SEPARATOR; // Place comma
        strncpy(pszDst,pszSrc,3);       // Copy next 3 digits
        cb -= 3;
        pszDst += 3;
        pszSrc += 3;
    }

    //** Figure out if we need to add trailing NUL
    if (cbBlanksBefore+cbBlanksAfter <= cCommas) {
        //** There were no trailing blanks to preserve, so we need to
        //   make sure the string is terminated.
        *pszDst++ = '\0';                   // Terminate string
    }

    //** Success
    return cCommas;
} /* addCommas() */


/***    ATFromFormatSpecifier - Determine argument type from sprintf format
 *
 *  Entry:
 *      pch - points to last character (type) of sprintf format specifier
 *
 *  Exit-Success:
 *      Returns ARGTYPE indicated by format specifier.
 *
 *  Exit-Failure:
 *      Returns atBAD -- could not determine type.
 */
ARGTYPE ATFromFormatSpecifier(char *pch)
{
    switch (*pch) {
        case 'c':
        case 'd':
        case 'i':
        case 'u':
        case 'o':
        case 'x':
        case 'X':
            // Check argument size character
            switch (*(pch-1)) {
                case 'h':   return atSHORT;
                case 'l':   return atLONG;
                default:    return atINT;
            }
            break;

        case 'f':
        case 'e':
        case 'E':
        case 'g':
        case 'G':
            // Check argument size character
            switch (*(pch-1)) {
                case 'L':   return atLONGDOUBLE;
                default:    // double size
// 13-Aug-1993 bens Should "%f" take a float, and "%lf" take a double?
//  The VC++ docs say that "%f" takes a double, but the "l" description says double,
//  and that omitting it cause float.  I'm confused!
                    return atDOUBLE;
            }
            break;

        case 's':
            // Check argument size character
            switch (*(pch-1)) {
                case 'F':   return atFARSTRING;
                case 'N':   return atSTRING;
                default:    return atSTRING;
            }
            break;

        default:
            return atBAD;
    } /* switch */
} /* ATFromFormatSpecifier */


/***    doFinalSubstitution - Replace %1, %2, etc. with formatted values
 *
 *  Entry:
 *      ach       - Buffer to receive final output
 *      pszMsg    - Message string, possibly with %1, %2, etc.
 *      apszValue - Values for %1, %2, etc.
 *
 *  Exit-Success:
 *      Returns length of final text (not including NUL terminator);
 *      ach filled in with substituted final text.
 *
 *  Exit-Failure:
 *      ach filled in with explanation of problem.
 */
int doFinalSubstitution(char *ach, char *pszMsg, char *apszValue[])
{
    int     i;
    char   *pch;
    char   *pszOut;

    Assert(ach!=NULL);
    Assert(pszMsg!=NULL);

    pch = pszMsg;                       // Start scanning message at front
    pszOut = ach;                       // Fill output buffer from front
    while (*pch != '\0') {
        if (*pch == chMSG) {            // Could be the start of a parameter
            pch++;                      // Skip %
            if (isdigit(*pch)) {        // We have a parameter!
                i = atoi(pch);          // Get number
                while ( (*pch != '\0') &&  // Skip to end of string
                        isdigit(*pch) ) {  // or end of number
                    pch++;              // Skip parameter
                }
                strcpy(pszOut,apszValue[i-1]); // Copy value
                pszOut += strlen(apszValue[i-1]); // Advance to end of value
            }
            else {                      // Not a digit
                *pszOut++ = chMSG;      // Copy %
                if (*pch == chMSG) {    // "%%"
                    pch++;              // Replace "%%" with single "%"
                }
                else {                  // Some other character
                    *pszOut++ = *pch++; // Copy it
                }
            }
        }
        else {                          // Not a parameter
            *pszOut++ = *pch++;         // Copy character
        }
    }
    *pszOut = '\0';                     // Terminate output buffer
    return (int)(pszOut - ach);         // Size of final string (minus NUL)
}


/***    getHighestParmNumber - Get number of highest %N string
 *
 *  Entry:
 *      pszMsg - String which may contain %N (%0, %1, etc.) strings
 *
 *  Exit-Success:
 *      Returns highest N found in %N string.
 */
int getHighestParmNumber(char *pszMsg)
{
    int     i;
    int     iMax;
    char   *pch;

    Assert(pszMsg!=NULL);

    iMax = 0;                       // No parameter seen so far
    pch = pszMsg;
    while (*pch != '\0') {
        if (*pch == chMSG) {        // Could be the start of a parameter
            pch++;                  // Skip %
            if (isdigit(*pch)) {    // We have a parameter!
                i = atoi(pch);      // Get number
                if (i > iMax)       // Remember highest parameter number
                    iMax = i;
                while ( (*pch != '\0') &&  // Skip to end of string
                        isdigit(*pch) ) {  // or end of number
                    pch++;          // Skip parameter
                }
            }
            else {                  // Not a digit
                pch++;              // Skip it
            }
        }
        else {                      // Not a parameter
            pch++;                  // Skip it
        }
    }
    return iMax;                    // Return highest parameter seen
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\pch.h ===
#ifndef __PCH_H
#define __PCH_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once

//
// public Windows header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <Security.h>
#include <SecExt.h>

#include <windows.h>
#include <wchar.h>
#include <io.h>
#include <sys/stat.h>
#include <limits.h>
#include "Shlwapi.h"
#include "winbase.h"

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <dbghelp.h>
#include <psapi.h>
#include <ntexapi.h>


//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
#include <Winioctl.h>
#include <Rpcdce.h>
#include <crtdbg.h>
#include <diskguid.h>
#include <rpc.h>
#include <errno.h>

//#include "cmdline.h"
//#include "cmdlineres.h"

//extract related include files

//#include "message.h"

//
// private Common header files
//


#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\mem.c ===
/***    mem.c - Memory Manager
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      10-Aug-1993 bens    Initial version
 *      11-Aug-1993 bens    Lift code from STOCK.EXE win app
 *      12-Aug-1993 bens    Get strings from memory.msg
 *      01-Sep-1993 bens    Add NULL pointer checks to MMAssert and MMStrDup
 *      18-Mar-1994 bens    Make sure non-assert build works; rename
 *      18-May-1994 bens    Allow turning off MemCheckHeap() in debug build
 *                              (it can really, really slow things down!)
 *
 *  Functions:
 *      MemAlloc  - Allocate memory block
 *      MemFree   - Free memory block
 *      MemStrDup - Duplicate string to new memory block
 *
 *  Functions available in ASSERT build:
 *      MemAssert       - Assert that pointer was allocated by MemAlloc
 *      MemCheckHeap    - Check entire memory heap
 *      MemListHeap     - List all heap entries
 *      MemGetSize      - Return allocated size of memory block
 *      MemSetCheckHeap - Control whether MemCheckHeap is done on every
 *                          every MemAlloc and MemFree!
 */

#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <malloc.h>

#include "types.h"
#include "asrt.h"

#ifdef ASSERT   // Must be after asrt.h!

#include "mem.h"
#include "mem.msg"


/***    MEMSIG - memory signature
 *
 *  This is placed at the front and end of every dynamic memory
 *  alloction in DEBUG builds.  The pointer has to be unaligned for
 *  RISC machines.
 */
typedef ULONG MEMSIG;    /* ms - memory signature */
typedef MEMSIG UNALIGNED *PMEMSIG; /* pms */

#define msHEAD  0x12345678L     // Head signature
#define msTAIL  0x87654321L     // Tail signature
#define msBAD   0L              // Bad signature
#define cmsTAIL 2               // Number of tail signatures


typedef struct mh_t {
    MEMSIG       ms;            // Head signature (msHEAD)
    unsigned     cb;            // Size of user block
    struct mh_t *pmhNext;       // Next block
    struct mh_t *pmhPrev;       // Previous block
    // char      ach[?];        // User block; length is cb
    // MEMSIG    ms[cmsTAIL];   // Tail signature area (msTAIL...)
} MEMHDR;   /* mh - memory header */
typedef MEMHDR *PMEMHDR; /* pmh */


#define PMHFromPV(pv)  ((PMEMHDR)((char *)pv - sizeof(MEMHDR)))
#define PVFromPMH(pmh) ((void *)((char *)pmh+sizeof(MEMHDR)))


STATIC PMEMHDR pmhList=NULL;    // List of memory blocks
STATIC BOOL    fDoCheckHeap=TRUE; // TRUE => check heap regularly


void MemSetCheckHeap(BOOL f)
{
    fDoCheckHeap = f;
}


void MMCheckHeap(char *pszFile, int iLine)
{
    PMEMHDR pmh;
    PMEMHDR pmhPrev = NULL;

    for (pmh = pmhList; pmh != NULL; pmh = pmh->pmhNext) {
        MMAssert(PVFromPMH(pmh),pszFile,iLine);
        AssertSub(pmh->pmhPrev==pmhPrev,pszFile,iLine);
        pmhPrev = pmh;
    }
}


void  MMListHeap(char *pszFile, int iLine)
{
    PMEMHDR pmh;

    if (fDoCheckHeap) {
        if (pmhList != NULL) {
            printf("\n");
            for (pmh = pmhList; pmh != NULL; pmh = pmh->pmhNext) {
                printf("alloc at %08lX is %d bytes\n", PVFromPMH(pmh), pmh->cb);
            }
            MMCheckHeap(pszFile,iLine);
            printf("\n");
        }
    }
}


void MMAssert(void *pv, char *pszFile, int iLine)
{
    int       i;
    PMEMHDR   pmh;
    PMEMSIG   pms;

    AssertSub(pv!=NULL,pszFile,iLine);
    pmh = PMHFromPV(pv);
    if ((void *)pmh > pv) {                     // Pointer wrapped
        AssertForce(pszMEMERR_NULL_POINTER,pszFile,iLine);
    }

    // Test head signature
    if (pmh->ms != msHEAD) {
        AssertForce(pszMEMERR_BAD_HEAD_SIG,pszFile,iLine);
    }

    // Test tail signatures
    pms = (PMEMSIG)( (char *)pmh + sizeof(MEMHDR) + pmh->cb );
    for (i=0; i<cmsTAIL; i++) {
        if (*pms++ != msTAIL) {
            AssertForce(pszMEMERR_BAD_HEAD_SIG,pszFile,iLine);
        }
    }
} /* MMAssert */


void MMFree(void *pv, char *pszFile, int iLine)
{
    PMEMHDR pmh;

    MMAssert(pv,pszFile,iLine);

    //** Check heap if enabled
    if (fDoCheckHeap) {
        MMCheckHeap(pszFile,iLine);
    }

    pmh = PMHFromPV(pv);

    // Make previous block point to next block
    if (pmh->pmhPrev != NULL) {         // pmh is not at front of list
        // before: a->p->?
        pmh->pmhPrev->pmhNext = pmh->pmhNext;
        // after:  a->?
    }
    else {                              // pmh is at front of list
        // before: list->p->?
        pmhList = pmh->pmhNext;
        // after: list->?
    }

    // Make next block point to previous block
    if (pmh->pmhNext != NULL) {         // pmh is not at end of list
        // before: ?<-p<->a
        pmh->pmhNext->pmhPrev = pmh->pmhPrev;
        // after:  ?<-a
    }

    // Obliterate signature
    pmh->ms = msBAD;

    // Free memory
    free((char *)pmh);
}


void *MMAlloc(unsigned cb, char *pszFile, int iLine)
{
    unsigned    cbAlloc;
    int         i;
    PMEMHDR     pmh;
    PMEMSIG     pms;

    if (fDoCheckHeap) {
        MMCheckHeap(pszFile,iLine);
    }

    // Solves alignment problems on the RISCs
    cb = (cb+3) & ~3;

    cbAlloc = cb+sizeof(MEMHDR)+sizeof(MEMSIG)*cmsTAIL;
    pmh = malloc(cbAlloc);
    if (pmh != NULL) {
        pmh->ms = msHEAD;           // Store head signature
        pmh->cb = cb;               // Store size of user block

        // Add block to front of list (Easiest code!)
        if (pmhList != NULL) {      // List is not empty
            pmhList->pmhPrev = pmh; // Point old top block back at us
        }
        pmh->pmhNext = pmhList;     // Next element is old top block
        pmh->pmhPrev = NULL;        // We are first, so no prev block
        pmhList = pmh;              // Make ourselves first

        // Fill in tail signatures
        pms = (PMEMSIG)( (char *)pmh + sizeof(MEMHDR) + pmh->cb );
        for (i=0; i<cmsTAIL; i++) {
            *pms++ = msTAIL;
        }
        return PVFromPMH(pmh);
    }
    else {
        AssertForce(pszMEMERR_OUT_OF_MEMORY,pszFile,iLine);
/*
        printf("panic: out of memory in MMAlloc\n");
            printf("\n");
            printf("Dump of heap (newest alloc to oldest)\n");
            printf("\n");
            printf("Size  Addr Content\n");
            printf("----- ---- -------\n");
            for (pmh = pmhList; pmh != NULL; pmh = pmh->pmhNext) {
                pch = PVFromPMH(pmh);
            printf("%5d %04x %s\n",pmh->cb,(unsigned)pch,pch);
        }
        return NULL;
*/
    }
}


char *MMStrDup(char *pch, char *pszFile, int iLine)
{
    unsigned    cb;
    char       *pchDst;

    //** Make sure pointer is not null.
    //   NOTE: pch does not have to be a string we dynamically allocated!
    AssertSub(pch!=NULL,pszFile,iLine);

    cb = strlen(pch)+1;                 // Count NUL terminator
    pchDst = MMAlloc(cb,pszFile,iLine); // Alloc new copy
    if (pchDst != NULL) {               // Success
        memcpy(pchDst,pch,cb);          // Copy string
    }
    return pchDst;                      // Return string copy
}


int  MemGetSize(void *pv)
{
    PMEMHDR pmh;

    MMAssert(pv,__FILE__,__LINE__);

    pmh = PMHFromPV(pv);
    return pmh->cb;
}
#endif // !ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\message.h ===
/***    message.h - Definitions for Message Manager
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      10-Aug-1993 bens    Initial version
 *      12-Aug-1993 bens    Implemented message formatting
 *      14-Aug-1993 bens    Add MsgSetWorker() for call by ErrSet()
 *      21-Feb-1994 bens    Return length of formatted string
 */

//#ifndef INCLUDED_MESSAGE
#define INCLUDED_MESSAGE    1

#include <stdarg.h>

//** chMSG - replaceable message character (%1, %2, etc.)
#define chMSG   '%'

//** cbMSG_MAX - Length of largest formatted message
#define cbMSG_MAX   512

//** cMSG_PARM_MAX - Maximum number of replaceable parameters
#define cMSG_PARM_MAX  10


/***    MsgSet - Set a message
 *
 *  Entry
 *      ach    - Buffer to receive formatted message
 *      pszMsg - Message string, possibly including %1, %2, ... replaceable
 *               parameters.  The highest parameter number indicates how
 *               many sprintf() formatting strings are present in pszFmt.
 *               If no parameter strings (%1, etc.) are present, then
 *               pszFmt is not processed.
 *
 *      Remaining arguments are optional, and depend upon presence of %N
 *      replaceable parameters in pszMsg:
 *      pszFmt - If at least one %N string in pszMsg, then this contains
 *               sprintf() formatting strings.  There must be at least as
 *               many formatting strings as the highest parameter string
 *               number.  Excess formatting strings are ignored.
 *               NOTE: To get thousand separators (,) in numbers, include
 *                     a comma (",") immediately after the "%" for %d
 *                     format specifiers!
 *      Arg1   - Value for %1.
 *      Arg2   - Value for %2.
 *      ...
 *
 *  Exit-Success
 *      Returns length of string in ach (not including NUL terminator)
 *      ach filled in with formatted message.
 *          Arg1 is formatted according to the first sprintf format in
 *          pszFmt, and replaces the %1 in pszMsg.  Similar treatment for
 *          any other arguments.
 *
 *  Exit-Failure
 *      Returns 0;
 *      ach filled in with message describing bad arguments.
 *
 *  Notes:
 *      (1) "%%" is copied to ach as "%".
 *      (2) If "%" is not followed by a digit, it is copied to ach.
 *
 *
 *  Examples:
 *      (1) MsgSet(ach,"%1 is %2 months old %3.","%s%d%s","Joe",3,"today");
 *          RESULT: ach = "Joe is 3 months old today"
 *
 *      (2) MsgSet(ach,"%3 is %1 months old %2.","%d%s%s",3,"today","Joe");
 *          RESULT: ach = "Joe is 3 months old today"
 *
 *      (3) MsgSet(ach,"%1 bytes","%,d",123456789L);
 *          RESULT: ach = "123,456,789 bytes"
 */
int __cdecl MsgSet(char *ach, char *pszMsg, ...);


/***    MsgSetWorker - Set Message after va_start already called
 *
 *  NOTE: See MsgSet for other details about behavior.
 *
 *  Entry
 *      ach    - Buffer to receive formatted message
 *      pszMsg - Message string (see MsgSet);
 *      pszFmt - Format string (see MsgSet);
 *      marker - Initialized by call to va_start
 *
 *  Exit-Success
 *      Returns length of string in ach (not including NUL terminator)
 *      ach filled in with formatted message.
 *          Arg1 is formatted according to the first sprintf format in
 *          pszFmt, and replaces the %1 in pszMsg.  Similar treatment for
 *          any other arguments.
 *
 *  Exit-Failure
 *      Returns 0;
 *      perr filled in with message describing bad arguments.
 *          RESULT: ach = "Joe is 3 months old today"
 */
int MsgSetWorker(char *ach, char *pszMsg, char *pszFmtList, va_list marker);

//#endif // !INCLUDED_MESSAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\types.h ===
/***    types.h - Convenient type definitions
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *      History:
 *          10-Aug-1993 bens    Initial version
 *      15-Aug-1993 bens    Added USHORT, ULONG
 *          23-Mar-1994 bens    Added DWORD, changed NULL to void*
 *          01-Apr-1994 bens    UNALIGNED - define NEEDS_ALIGNMENT for RISC
 */

#ifndef INCLUDED_TYPES
#define INCLUDED_TYPES 1

typedef int        BOOL;    /* f */
typedef unsigned char  BYTE;    /* b */
typedef unsigned short USHORT;  /* us */
typedef unsigned short WORD;    /* w  */
typedef unsigned int   UINT;    /* ui */
typedef unsigned long  ULONG;   /* ul */
typedef unsigned long  DWORD;   /* dw */


#ifdef _DEBUG
// don't hide statics from map during debugging
#define STATIC
#else // !_DEBUG
#define STATIC static
#endif // !_DEBUG

#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL   ((void*)0)
#endif

#ifdef NEEDS_ALIGNMENT

#ifndef UNALIGNED
#define UNALIGNED __unaligned
#endif

#else // !NEEDS_ALIGNMENT

#ifndef UNALIGNED
#define UNALIGNED
#endif

#endif // !NEEDS_ALIGNMENT

#endif // !INCLUDED_TYPES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\wildcard.c ===
#include "wildcard.h"       /* prototype verification */

#ifndef TRUE
#define TRUE    (1)
#endif

#ifndef FALSE
#define FALSE   (0)
#endif

#define WILDCARD    '*'     /* zero or more of any character */
#define WILDCHAR    '?'     /* one of any character (does not match END) */
#define END         '\0'    /* terminal character */
#define DOT         '.'     /* may be implied at end ("hosts" matches "*.") */


#ifdef STANDALONE

#include <stdio.h>
#include <windows.h>

struct
{
    char *String;
    char *Pattern;
    int Expected;
    int ExpectedWithImpliedDots;
}
    testcase[] =
{
    //
    //  empty patterns
    //

    { "",       "",         TRUE,   TRUE    },
    { "a",      "",         FALSE,  FALSE   },

    //
    //  single character patterns
    //

    { "",       "a",        FALSE,  FALSE   },
    { "a",      "a",        TRUE,   TRUE    },
    { "b",      "a",        FALSE,  FALSE   },
    { "aa",     "a",        FALSE,  FALSE   },
    { "ab",     "a",        FALSE,  FALSE   },

    //
    //  multiple character patterns
    //

    { "",       "aa",       FALSE,  FALSE   },
    { "b",      "aa",       FALSE,  FALSE   },
    { "a",      "aa",       FALSE,  FALSE   },
    { "ab",     "aa",       FALSE,  FALSE   },
    { "aa",     "aa",       TRUE,   TRUE    },
    { "b",      "ab",       FALSE,  FALSE   },
    { "a",      "ab",       FALSE,  FALSE   },
    { "ab",     "ab",       TRUE,   TRUE    },
    { "abc",    "ab",       FALSE,  FALSE   },
    { "acb",    "ab",       FALSE,  FALSE   },

    //
    //  wildchar patterns
    //

    { "",       "?",        FALSE,  TRUE    },
    { "a",      "?",        TRUE,   TRUE    },
    { "",       "?a",       FALSE,  FALSE   },
    { "a",      "?a",       FALSE,  FALSE   },
    { "aa",     "?a",       TRUE,   TRUE    },
    { "ab",     "?a",       FALSE,  FALSE   },
    { "ba",     "?a",       TRUE,   TRUE    },
    { "bb",     "?a",       FALSE,  FALSE   },
    { "aac",    "?a",       FALSE,  FALSE   },
    { "aba",    "?a",       FALSE,  FALSE   },
    { "bac",    "?a",       FALSE,  FALSE   },
    { "bbc",    "?a",       FALSE,  FALSE   },
    { "",       "a?",       FALSE,  FALSE   },
    { "a",      "a?",       FALSE,  TRUE    },
    { "aa",     "a?",       TRUE,   TRUE    },
    { "ab",     "a?",       TRUE,   TRUE    },
    { "ba",     "a?",       FALSE,  FALSE   },
    { "bb",     "a?",       FALSE,  FALSE   },
    { "aac",    "a?",       FALSE,  FALSE   },
    { "aba",    "a?",       FALSE,  FALSE   },
    { "",       "a?b",      FALSE,  FALSE   },
    { "a",      "a?b",      FALSE,  FALSE   },
    { "aa",     "a?b",      FALSE,  FALSE   },
    { "ab",     "a?b",      FALSE,  FALSE   },
    { "baa",    "a?b",      FALSE,  FALSE   },
    { "abb",    "a?b",      TRUE,   TRUE    },
    { "aab",    "a?b",      TRUE,   TRUE    },
    { "aabc",   "a?b",      FALSE,  FALSE   },
    { "abc",    "a?b",      FALSE,  FALSE   },
    { "bab",    "a?b",      FALSE,  FALSE   },
    { "bbb",    "a?b",      FALSE,  FALSE   },

    //
    //  wildcard patterns
    //

    { "",       "*a",       FALSE,  FALSE   },
    { "a",      "*a",       TRUE,   TRUE    },
    { "ba",     "*a",       TRUE,   TRUE    },
    { "bab",    "*ab",      TRUE,   TRUE    },
    { "baa",    "*ab",      FALSE,  FALSE   },
    { "bac",    "*ab",      FALSE,  FALSE   },
    { "ab",     "*ab",      TRUE,   TRUE    },
    { "aa",     "*ab",      FALSE,  FALSE   },
    { "aa",     "*ab",      FALSE,  FALSE   },
    { "aab",    "*ab",      TRUE,   TRUE    },
    { "b",      "*a",       FALSE,  FALSE   },
    { "",       "a*",       FALSE,  FALSE   },
    { "a",      "a*",       TRUE,   TRUE    },
    { "ba",     "a*",       FALSE,  FALSE   },
    { "bab",    "a*b",      FALSE,  FALSE   },
    { "baa",    "a*b",      FALSE,  FALSE   },
    { "bac",    "a*b",      FALSE,  FALSE   },
    { "ab",     "a*b",      TRUE,   TRUE    },
    { "aa",     "a*b",      FALSE,  FALSE   },
    { "aa",     "a*b",      FALSE,  FALSE   },
    { "aab",    "a*b",      TRUE,   TRUE    },
    { "b",      "a*",       FALSE,  FALSE   },

    //
    //  wildcards with false matches
    //

    { "ab",     "*a",       FALSE,  FALSE   },
    { "aa",     "*a",       TRUE,   TRUE    },
    { "baa",    "*a",       TRUE,   TRUE    },

    //
    //  mixed wildcard patterns
    //

    { "",       "*?",       FALSE,  TRUE    },
    { "a",      "*?",       TRUE,   TRUE    },
    { "a",      "*?a",      FALSE,  FALSE   },
    { "aba",    "*?a",      TRUE,   TRUE    },
    { "ba",     "*?a",      TRUE,   TRUE    },
    { "ab",     "*?b",      TRUE,   TRUE    },
    { "",       "*",        TRUE,   TRUE    },
    { "a",      "*",        TRUE,   TRUE    },
    { "a",      "**",       TRUE,   TRUE    },
    { "a",      "*?*?",     FALSE,  TRUE    },
    { "aa",     "*?*?",     TRUE,   TRUE    },
    { "aaa",    "*?*?",     TRUE,   TRUE    },
    { "abbbc",  "a*?c",     TRUE,   TRUE    },

    //
    //  Tom's
    //

    { "abc",    "abc",      TRUE,   TRUE    },
    { "abcd",   "abc",      FALSE,  FALSE   },
    { "ab",     "abc",      FALSE,  FALSE   },
    { "abc",    "a?c",      TRUE,   TRUE    },
    { "ac",     "a?c",      FALSE,  FALSE   },
    { "abc",    "ab?",      TRUE,   TRUE    },
    { "ab",     "ab?",      FALSE,  TRUE    },
    { "az",     "a*z",      TRUE,   TRUE    },
    { "abcdefz", "a*z",     TRUE,   TRUE    },
    { "ab",     "ab*",      TRUE,   TRUE    },
    { "abcdefg", "ab*",     TRUE,   TRUE    },
    { "ab",     "*ab",      TRUE,   TRUE    },
    { "abc",    "*ab",      FALSE,  FALSE   },
    { "123ab",  "*ab",      TRUE,   TRUE    },
    { "a",      "*a*",      TRUE,   TRUE    },
    { "123abc", "*a*",      TRUE,   TRUE    },
    { "abcdef", "abc*?def", FALSE,  FALSE   },
    { "abcxdef", "abc*?def", TRUE,  TRUE    },
    { "abcxyzdef", "abc*?def", TRUE, TRUE   },
    { "abc123", "*ab?12*",  TRUE,   TRUE    },
    { "abcabc123", "*ab?12*", TRUE, TRUE    },

    //
    //  filename handling
    //

    { "host",   "*.",       FALSE,  TRUE    },
    { "host.",  "*.",       TRUE,   TRUE    },
    { "host.s", "*.",       FALSE,  FALSE   },
    { "a",      "**",       TRUE,   TRUE    },
    { "a",      "*.",       FALSE,  TRUE    },
    { "a",      "*?.",      FALSE,  TRUE    },
    { "a",      "?*.",      FALSE,  TRUE    },
    { "a",      "*.*",      FALSE,  TRUE    },
    { "a",      "*.**",     FALSE,  TRUE    },
    { "a",      "*.*.*",    FALSE,  FALSE   },
    { "a.b",    "*.*.*",    FALSE,  FALSE   }
};

#define COUNT(a)    (sizeof(a) / sizeof(a[0]))


int __cdecl main(int argc, char *argv[])
{
    int iCase, iResult;
    int fAllowImpliedDot;
    char *psz;

    //
    //  run test cases
    //

    for (iCase = 0; iCase < COUNT(testcase); iCase++)
    {
        fAllowImpliedDot = TRUE;

        for (psz = testcase[iCase].String; *psz != END; psz++)
        {
            if (*psz == DOT)
            {
                fAllowImpliedDot = FALSE;
                break;
            }
        }

        if (PatternMatch(testcase[iCase].String, testcase[iCase].Pattern, FALSE) !=
                testcase[iCase].Expected)
        {
            printf("PatternMatch() failed: string \"%s\", pattern \"%s\" expected %s (implied=FALSE)\n",
                    testcase[iCase].String,
                    testcase[iCase].Pattern,
                    testcase[iCase].Expected ? "TRUE" : "FALSE");
        }

        if (PatternMatch(testcase[iCase].String, testcase[iCase].Pattern, fAllowImpliedDot) !=
                testcase[iCase].ExpectedWithImpliedDots)
        {
            printf("PatternMatch() failed: string \"%s\", pattern \"%s\" expected %s (implied=TRUE)\n",
                    testcase[iCase].String,
                    testcase[iCase].Pattern,
                    testcase[iCase].ExpectedWithImpliedDots ? "TRUE" : "FALSE");
        }
    }

    //
    //  run user cases
    //

    if (argc > 1)
    {
        fAllowImpliedDot = TRUE;

        for (psz = argv[1]; *psz != END; psz++)
        {
            if (*psz == DOT)
            {
                fAllowImpliedDot = FALSE;
                break;
            }
        }

        for (iCase = 2; iCase < argc; iCase++)
        {
            iResult = PatternMatch(argv[1], argv[iCase], FALSE);

            printf("string \"%s\", pattern \"%s\" -> %s (implied=FALSE)\n",
                argv[1],
                argv[iCase],
                iResult ? "TRUE" : "FALSE");

            if (fAllowImpliedDot)
            {
                iResult = PatternMatch(argv[1], argv[iCase], fAllowImpliedDot);

                printf("string \"%s\", pattern \"%s\" -> %s (implied=TRUE)\n",
                    argv[1],
                    argv[iCase],
                    iResult ? "TRUE" : "FALSE");
            }
        }
    }

    return(0);
}

#endif


static int __inline Lower(c)
{
    if ((c >= 'A') && (c <= 'Z'))
    {
        return(c + ('a' - 'A'));
    }
    else
    {
        return(c);
    }
}


static int __inline CharacterMatch(char chCharacter, char chPattern)
{
    if (Lower(chCharacter) == Lower(chPattern))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


int __stdcall PatternMatch(const char *pszString,const char *pszPattern,int fImplyDotAtEnd)
{
    /* RECURSIVE */

    //
    //  This function does not deal with 8.3 conventions which might
    //  be expected for filename comparisons.  (In an 8.3 environment,
    //  "alongfilename.html" would match "alongfil.htm")
    //
    //  This code is NOT MBCS-enabled
    //

    for ( ; ; )
    {
        switch (*pszPattern)
        {

        case END:

            //
            //  Reached end of pattern, so we're done.  Matched if
            //  end of string, no match if more string remains.
            //

            return(*pszString == END);

        case WILDCHAR:

            //
            //  Next in pattern is a wild character, which matches
            //  anything except end of string.  If we reach the end
            //  of the string, the implied DOT would also match.
            //

            if (*pszString == END)
            {
                if (fImplyDotAtEnd == TRUE)
                {
                    fImplyDotAtEnd = FALSE;
                }
                else
                {
                    return(FALSE);
                }
            }
            else
            {
                pszString++;
            }

            pszPattern++;

            break;

        case WILDCARD:

            //
            //  Next in pattern is a wildcard, which matches anything.
            //  Find the required character that follows the wildcard,
            //  and search the string for it.  At each occurence of the
            //  required character, try to match the remaining pattern.
            //
            //  There are numerous equivalent patterns in which multiple
            //  WILDCARD and WILDCHAR are adjacent.  We deal with these
            //  before our search for the required character.
            //
            //  Each WILDCHAR burns one non-END from the string.  An END
            //  means we have a match.  Additional WILDCARDs are ignored.
            //

            for ( ; ; )
            {
                pszPattern++;

                if (*pszPattern == END)
                {
                    return(TRUE);
                }
                else if (*pszPattern == WILDCHAR)
                {
                    if (*pszString == END)
                    {
                        if (fImplyDotAtEnd == TRUE)
                        {
                            fImplyDotAtEnd = FALSE;
                        }
                        else
                        {
                            return(FALSE);
                        }
                    }
                    else
                    {
                        pszString++;
                    }
                }
                else if (*pszPattern != WILDCARD)
                {
                    break;
                }
            }

            //
            //  Now we have a regular character to search the string for.
            //

            while (*pszString != END)
            {
                //
                //  For each match, use recursion to see if the remainder
                //  of the pattern accepts the remainder of the string.
                //  If it does not, continue looking for other matches.
                //

                if (CharacterMatch(*pszString, *pszPattern) == TRUE)
                {
                    if (PatternMatch(pszString + 1, pszPattern + 1, fImplyDotAtEnd) == TRUE)
                    {
                        return(TRUE);
                    }
                }

                pszString++;
            }

            //
            //  Reached end of string without finding required character
            //  which followed the WILDCARD.  If the required character
            //  is a DOT, consider matching the implied DOT.
            //
            //  Since the remaining string is empty, the only pattern which
            //  could match after the DOT would be zero or more WILDCARDs,
            //  so don't bother with recursion.
            //

            if ((*pszPattern == DOT) && (fImplyDotAtEnd == TRUE))
            {
                pszPattern++;

                while (*pszPattern != END)
                {
                    if (*pszPattern != WILDCARD)
                    {
                        return(FALSE);
                    }

                    pszPattern++;
                }

                return(TRUE);
            }

            //
            //  Reached end of the string without finding required character.
            //

            return(FALSE);
            break;

        default:

            //
            //  Nothing special about the pattern character, so it
            //  must match source character.
            //

            if (CharacterMatch(*pszString, *pszPattern) == FALSE)
            {
                if ((*pszPattern == DOT) &&
                    (*pszString == END) &&
                    (fImplyDotAtEnd == TRUE))
                {
                    fImplyDotAtEnd = FALSE;
                }
                else
                {
                    return(FALSE);
                }
            }

            if (*pszString != END)
            {
                pszString++;
            }

            pszPattern++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\extract\wildcard.h ===
/* wildcard.h */

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Compare a string against a pattern, without regard to case.
 *  Case-insensitivity is confined to A-Z vs. a-z.
 *
 *  This function does not deal with 8.3 conventions which might
 *  be expected for filename comparisons.  (In an 8.3 environment,
 *  "longfilename.html" would match "longfile.htm".)
 *
 *  This code is NOT MBCS-enabled.
 *
 *  fAllowImpliedDot, when set, allows the code to pretend there
 *  is a dot at the end of pszString if it will help.  This is set
 *  to allow strings like "hosts" to match patterns like "*.*".
 *  Usually, the caller will scan pszString to see if any real
 *  dots are present before setting this flag.  If pszString has a
 *  path, ie, "..\hosts", the caller might want to scan only the
 *  base string ("hosts").
 */

extern int __stdcall PatternMatch(
    const char *pszString,
    const char *pszPattern,
    int fAllowImpliedDot);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\execcommand.h ===
/*++

  Copyright (c) Microsoft Corporation

  Module Name:

      ExecCommand.h

  Abstract:

      Contains function prototypes and macros.

  Author:

      V Vijaya Bhaskar

  Revision History:

      14-Jun-2001 : Created by V Vijaya Bhaskar ( Wipro Technologies ).

--*/

#ifndef     __EXEC_COMMAND__H
#define     __EXEC_COMMAND__H

/***************************************************************************
** For a command to execute we have to replace some tokens with           **
** some required information .                                            **
***************************************************************************/

// NOTE: Check 'szValue' declaration when this value is changed.
#define     TOTAL_FLAGS                         9

// Flags that can be used with command to execute.
#define     FILE_NAME                       L"@file"
#define     FILE_WITHOUT_EXT                L"@fname"
#define     EXTENSION                       L"@ext"
#define     FILE_PATH                       L"@path"
#define     RELATIVE_PATH                   L"@relpath"
#define     IS_DIRECTORY                    L"@isdir"
#define     FILE_SIZE                       L"@fsize"
#define     FILE_DATE                       L"@fdate"
#define     FILE_TIME                       L"@ftime"
#define     IS_HEX                  L"0x"

#define     NOT_WIN32_APPL              GetResString( IDS_NOT_WIN32_APPL )

#define     ASCII_0                         48
#define     ASCII_9                         57
#define     ASCII_A                         65
#define     ASCII_F                         70
#define     ASCII_a                         97
#define     ASCII_f                         102

#define     US_ENG_CODE_PAGE                437
// Define for replacing flags with '%NUMBER' string.
#define     REPLACE_PERC_CHAR( FIRSTLOOP, FLAG_NAME, INDEX )\
            if(  TRUE == FIRSTLOOP )\
            {\
                if( FALSE == ReplaceString( FLAG_NAME, ( INDEX + 1 ) ) ) \
                {\
                    ReleaseFlagArray( INDEX + 1 );\
                    return FALSE ;\
                }\
            }\
            1

/* Function prototypes for world . */
BOOL
ExecuteCommand(
    void
    ) ;

BOOL
ReplaceSpacedDir(
    void
    );

BOOL
ReplaceTokensWithValidValue(
    LPWSTR lpszPathName ,
    WIN32_FIND_DATA wfdFindFile
    ) ;

BOOL
ReplaceHexToChar(
    LPWSTR lpszCommand
    )  ;

void
ReleaseStoreCommand(
    void
    ) ;

#endif  //__EXEC_COMMAND__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\filedate.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    FileDate.c

Abstract:

    This file validate whether a date is valid and if valid then
    generates date according to context( Context refers to whether
    + or - is specifed . )

Author:

    V Vijaya Bhaskar

Revision History:

    14-Jun-2001 : Created by V Vijaya Bhaskar ( Wipro Technologies ).

--*/

#include "Global.h"
#include "FileDate.h"

// Days present in tweleve months . In a leap year there are 29 days in FEB .
DWORD DAYS_IN_A_MONTH[] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 ,
                          31 , 30 , 31 } ;

/******************************************************************************
**                  Function Prototypes Local To This File                   **
******************************************************************************/
BOOL
GetValidDate(
    DWORD *dwDateGreater ,
    LPWSTR lpszDate ,
    PValid_File_Date pvfdValidFileDate
    ) ;

BOOL
DayFrom1900(
    PValid_File_Date pvfdValidFileDate
    ) ;

BOOL
DayOfTheYear(
    PValid_File_Date pvfdValidFileDate
    ) ;

BOOL
GetDate(
    PValid_File_Date pvfdValidFileDate ,
    DWORD dwDate
    ) ;

BOOL
IsValidDate(
    LPWSTR lpszDate ,
    PValid_File_Date pvfdValidFileDate
    ) ;


/*************************************************************************
/*      Function Definition starts from here .                          **
*************************************************************************/

BOOL
ValidDateForFile(
    OUT DWORD *pdwDateGreater ,
    OUT PValid_File_Date pvfdValidFileDate ,
    IN  LPWSTR lpszDate
    )
/*++

Routine Description:

    Checks whether the specified date is valid or not . If specified date is
    valid , then converts it to a proper date ( dd-mm-yyyy ) .

Arguments:

      [ OUT ] *dwDateGreater - Contains value which specifies whether to find a file
                       created on a date less or greater than the current date .

      [ OUT ] pvfdValidFileDate - Contains a date .

      [ IN ] lpszDate      - Date specified at the command prompt .

Return value:

      BOOL .

--*/

{
    DWORD dwLength = 0 ;

    // Check for memory insufficient.
    if( ( NULL == pdwDateGreater ) ||
        ( NULL == pvfdValidFileDate ) ||
        ( NULL == lpszDate ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE;
    }

    /* Valid date must be have less('-') or greater('+')
       character .  */
    switch( *lpszDate )
    {
        case MINUS :                /* Less than the current date . */
            *pdwDateGreater = SMALLER_DATE ;
            break ;
        case PLUS  :
            *pdwDateGreater = GREATER_DATE ;   /* Greater than the current date .*/
            break ;
        default    :
                DISPLAY_INVALID_DATE();
                return FALSE ;
    }

    /* The date should be in either "DD" or "MM/DD/YYYY" . */
    if( NULL != FindAChar( lpszDate, _T( '/' ) ) )
    {
        // Date is in "MM/DD/YYYY". Get length of the date string.
        dwLength = StringLength( lpszDate, 0 );
        // Check
        // (1) date string should be morethan 9 and less than 11
        // (2) Should not have double slashes.
        // (3) Should be a valid date. Check by IsValidDate() function.
        if( ( MIN_DATE_LENGTH > dwLength ) ||
            ( MAX_DATE_LENGTH < dwLength ) ||
            ( NULL != FindSubString( lpszDate, L"//" ) ) ||
            ( FALSE == IsValidDate( lpszDate , pvfdValidFileDate ) ) )
        {
            DISPLAY_INVALID_DATE();
            return FALSE ;
        }
    }
    else
    {
        /* Date is in "DD" format . */
        if( FALSE == GetValidDate( pdwDateGreater , lpszDate , pvfdValidFileDate ) )
        {
            /* Specified date is not a valid date . "DD" specified date must
               be in the range of including 0 - 32768 . */
            return FALSE ;  /* Invalid date specified . */
        }
    }
    /* Date specified is valid .*/
    return TRUE ;
}


BOOL
FileDateValid(
    IN DWORD dwDateGreater ,
    IN Valid_File_Date vfdValidFileDate ,
    IN FILETIME ftFileCreation
    )
/*++

Routine Description:

    Checks whether the specified file is created on a date which is before or after
    or equal to the specified date .

Arguments:

      [ IN ] dwDateGreater - Contains value which tells whether to find a file
                            who's creation date is smaller or greater than the
                            current date .

      [ IN ] vfdValidFileDate - Contains a date .

      [ IN ] ftFileCreation  - Holds obtained file's creation time .

Return value:

      BOOL .

--*/
{
    /* Local variables */
    DWORD dwDay  = 0 ;  /* Holds file creation date . */
    DWORD dwTime = 0 ;  /* Holds file creation time . */
    FILETIME ftFileTime ;

    // Convert file time to local file time.
    if( FALSE == FileTimeToLocalFileTime( &ftFileCreation , &ftFileTime ) )
    {   // Display error.
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE;
    }

    /* Convert FILETIME format to DOS time format . */
    if( FALSE == FileTimeToDosDateTime(  &ftFileTime , (LPWORD) &dwDay ,
                     (LPWORD) &dwTime ) )
    { /* Failed to convert the FILETIME to DATETIME */
        SaveLastError() ;   /* Save last error occured . */
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    /* Check whether the file was created on a date specified by user */
    switch( dwDateGreater )
    {
    case SMALLER_DATE : /* File must be created before user specified date. */
        /* If current year is smaller or equal to specified year . */
        if( vfdValidFileDate.m_dwYear >= ( ( ( dwDay & 0xFE00 ) >> 9 ) + 1980 ) )
        {
            /* If file creation year is equal to specified year , then check
               for month is it smaller or equal to specified month . */
            if( vfdValidFileDate.m_dwYear == ( ( ( dwDay & 0xFE00 ) >> 9 ) + 1980 ) )
            {
                if( vfdValidFileDate.m_dwMonth >= ( ( dwDay & 0x01E0 ) >> 5 ) )
                {
                    /* If file creation month is equal to specified month ,then
                       check for day is it smaller or equal to specified day .*/
                    if( vfdValidFileDate.m_dwMonth == ( ( dwDay & 0x01E0 ) >> 5 ) )
                    {
                        if( vfdValidFileDate.m_dwDay >= ( dwDay & 0x001F ) )
                        {   // If file creation day is smaller than or equal
                            // to specified day .
                            return TRUE ;
                        }
                        else
                        {  // If file creation day is smaller to specified day .
                            return FALSE ;
                        }
                    }
                    else
                    {   // Control will come here only when file creation year is smaller or
                        // equal to specified year .
                        return TRUE ;
                    }
                }
            }
            else
            {   // Control will come here only when file creation year is smaller or equal
                // to specified year .
                return TRUE ;
            }
        }
        break ;
    case GREATER_DATE :
        // If file creation year is greater or equal to specified year .
        if( vfdValidFileDate.m_dwYear <= ( ( ( dwDay & 0xFE00 ) >> 9 ) + 1980 ) )
        {
            // If file creation year is equal to specified year ,
            // Then check for month is it greater or equal to specified month .
            if( vfdValidFileDate.m_dwYear == ( ( ( dwDay & 0xFE00 ) >> 9 ) + 1980 ) )
            {
                if( vfdValidFileDate.m_dwMonth <= ( ( dwDay & 0x01E0 ) >> 5 ) )
                {
                    // If file creation month is equal to specified month ,
                    // Then check for day is it greater or equal to specified day .
                    if( vfdValidFileDate.m_dwMonth == ( ( dwDay & 0x01E0 ) >> 5 ) )
                    {
                        if( vfdValidFileDate.m_dwDay <= ( dwDay & 0x001F ) )
                        {
                            return TRUE ; // If file creation day is greater than or equal
                                          // to specified day .
                        }
                        else
                        {
                            return FALSE ; // If file creation day is greater to specified day .
                        }
                    }
                    else
                    {   // Control will come here only when file creation month is greater or
                        // equal to specified year .
                        return TRUE ;
                    }
                }
            }
            else
            {   // Control will come here only when file creation year is greater or
                // equal to specified year .
                return TRUE ;
            }
        }
        break ;
    default:
        // Display error message since by default '+' should be present.
        // Control should never come here.
        DISPLAY_INVALID_DATE();
        return FALSE ;
    }

    // Control should never come here.
    return FALSE ;
}


BOOL
IsValidDate(
    IN LPWSTR lpszDate ,
    OUT PValid_File_Date pvfdValidFileDate
    )
/*++

Routine Description:

    Returns a valid date if specified date is in {+|-}ddmmyyyy format .

Arguments:

      [ IN ] lpszDate - Contains a date either in "ddmmyyyy" or "dd" format .

      [ OUT ] pvfdValidFileDate - Contains a valid date .

Return value:

      BOOL .

--*/
{
    LPWSTR lpTemp = NULL;
    LPWSTR lpTemp1 = NULL;
    WCHAR szDate[ 10 ] ;

    // Check for NULL and date string should be between 9 and 11 characters.
    if( ( ( NULL == lpszDate ) ? TRUE :
                    ( ( 11 < StringLength( lpszDate, 0 ) ) ||
                      (  9 > StringLength( lpszDate, 0 ) ) ) ) ||
        ( NULL == pvfdValidFileDate ) )
    {
        return FALSE;
    }

    SecureZeroMemory( szDate, 10 * sizeof( WCHAR ) );

    // Move pointer to beyond '+' or '-' in "{+|-}MM/dd/yyyy.
    lpTemp = lpszDate + 1;

    // Fetching month part from specified date.
    // Only first 4 characters( MM/ ) are copied.
    StringCopy( szDate, lpTemp, 4 );

    // If no '/' is found then display  an error.
    if( NULL != FindAChar( szDate, _T('/') ) )
    {
        if( _T( '/' ) == *szDate )
        {
            return FALSE;
        }
        // Search for '/' since its the seperating character between MM/dd.
        // move 'lpTemp' pointer to point after '/'.
        if( _T( '/' ) == *( szDate + 1 ) )
        {
            // If M/dd is specified.
            lpTemp += 2;
            szDate[ 1 ] = _T( '\0' );
        }
        else
        {
            // If MM/dd is specified.
            lpTemp += 3;
            szDate[ 2 ] = _T( '\0' );
        }
    }
    else
    {
        return FALSE;
    }
    // Check whether '//' is not present.
    if( NULL != FindAChar( szDate, _T('/') ) )
        return FALSE;

    // Save month.
    lpTemp1 = NULL;
    pvfdValidFileDate->m_dwMonth = _tcstoul( szDate, &lpTemp1, 10 ) ;

    if( 0 != StringLength( lpTemp1, 0 ) )
    {
        return FALSE;
    }

    // Fetching date part from specified date.
    // Only 4 characters( DD/ ) are copied.
    StringCopy( szDate, lpTemp, 4 );

    // If no '/' is found then display  an error.
    if( NULL != FindAChar( szDate, _T('/') ) )
    {
        if( _T( '/' ) == *szDate )
        {
            return FALSE;
        }
        // Search for '/' since its the seperating character between MM/dd.
        // move 'lpTemp' pointer to point after '/'.
        if( _T( '/' ) == *( szDate + 1 ) )
        {
            // If d/yyyy is specified.
            lpTemp += 2;
            szDate[ 1 ] = _T( '\0' );
        }
        else
        {
            // If dd/yyyy is specified.
            lpTemp += 3;
            szDate[ 2 ] = _T( '\0' );
        }
    }
    else
    {
        return FALSE;
    }

    lpTemp1 = NULL;
    pvfdValidFileDate->m_dwDay =  _tcstoul( szDate, &lpTemp1, 10 ) ;
    // if 'lpTemp1' length is not zero then 'szDate' contains some other
    // character other than numbers.
    if( 0 != StringLength( lpTemp1, 0 ) )
    {
        return FALSE;
    }

    // Fetching year part from specified date.
    if( 4 != StringLength( lpTemp, 0 ) )
    {   // Date contains other than 'yyyy'.
        return FALSE;
    }
    // Copy 'yyyy'.
    StringCopy( szDate, lpTemp, 5 );

    lpTemp1 = NULL;
    pvfdValidFileDate->m_dwYear =  _tcstoul( szDate, &lpTemp1 , 10 ) ;
    // if 'lpTemp1' length is not zero then 'szDate' contains some other
    // character other than numbers.
    if( 0 != StringLength( lpTemp1, 0 ) )
    {
        return FALSE;
    }

    // Check whether the day or month or year is zero  .
    if( ( pvfdValidFileDate->m_dwDay <= 0 )   ||
        ( pvfdValidFileDate->m_dwMonth <= 0 ) ||
        ( pvfdValidFileDate->m_dwYear <= 0 ) )
    {
        // No need to display any error , since control will go to GetValidDate .
        // If specified date is wrong then error is displayed in GetValidDate() .
        return FALSE ;
    }

    // Check whether the current year is a leap year , if yes then check whether
    // the current month is februrary.
    if( ( IS_A_LEAP_YEAR( pvfdValidFileDate->m_dwYear ) ) &&
        ( FEB == pvfdValidFileDate->m_dwMonth  ) )
    {
        // For leap year number of days is 29 . Check for same .
        if( pvfdValidFileDate->m_dwDay > DAYS_INFEB_LEAP_YEAR )
        {
        // No need to display any error here , since control will go to GetValidDate .
        // If specified date is wrong then error is displayed in GetValidDate() .
                return FALSE ;      // Specified date is invalid .
        }
        else
        {
                return TRUE ;       // Specified date is valid .
        }
    }

    // Since all extra validations are over , so check for other months .
    switch( pvfdValidFileDate->m_dwMonth )
    {
        // Months having 31 days .
        case JAN :
        case MAR :
        case MAY :
        case JUL :
        case AUG :
        case OCT :
        case DEC :
            // Month have only 31 days but specified date is greater than that, display error .
            if( pvfdValidFileDate->m_dwDay > THIRTYONE )
            {
                return FALSE ;
            }
            return TRUE ;
        // Month having only 28 days .
        case FEB :
           // Month have only 28 days but specified date is greater than that , display error.
            if( pvfdValidFileDate->m_dwDay > DAYS_INFEB )
            {
                return FALSE ;
            }
            return TRUE ;
        // Months having 30 days .
        case APR :
        case JUN :
        case SEP :
        case NOV :
            // Month have only 30 days but specified date is greater than that, display error .
            if( pvfdValidFileDate->m_dwDay > THIRTY )
            {
                return FALSE ;
            }
            return TRUE ;
        // If not a valid month .
        default :
            return FALSE ;
    }
}


BOOL
GetValidDate(
    IN DWORD *pdwDateGreater ,
    IN LPWSTR lpszDate ,
    OUT PValid_File_Date pvfdValidFileDate
    )
/*++

Routine Description:

      Returns a valid date if specified date is in {+|-}dd format .

Arguments:

      [ IN ] *pdwDateGreater - Contains value which tells whether to find a file
                              who's creation date is smaller or greater than the
                              current date .

      [ IN ] lpszDate - Contains a date in "dd" format . Must be in range of
                 1 - 32768 .

      [ OUT ] pvfdValidFileDate - Contains a valid date .

Return value:

      BOOL returning TRUE or FALSE .

--*/

{
    // Local variables.
    DWORD dwDate = 0 ;  // Stores the date specified .
    SYSTEMTIME  stDateAndTime ;

    // Check for memory insufficient.
    if( ( NULL == pdwDateGreater ) ||
        ( NULL == pvfdValidFileDate ) ||
        ( NULL == lpszDate ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE;
    }

    // Convert date from string to number .
    dwDate =_tcstoul( ( lpszDate + 1 ) , NULL , 10 ) ;

    // Is date specified is in limis .
    if( dwDate > 32768 )
    {
        DISPLAY_INVALID_DATE();
        return FALSE ;
    }

    // Fetch current date and time .
    GetLocalTime( &stDateAndTime ) ;

    pvfdValidFileDate->m_dwDay   = stDateAndTime.wDay  ;
    pvfdValidFileDate->m_dwMonth = stDateAndTime.wMonth ;
    pvfdValidFileDate->m_dwYear  = stDateAndTime.wYear  ;
    // If date to compare is zero then return TRUE , as their
    // is nothing to calculate .
    if( dwDate == 0 )
    {
        return TRUE ;
    }

    // Find how many days are over in current year .
    if( FALSE == DayOfTheYear( pvfdValidFileDate ) )
    {
        return FALSE ;
    }
    // Find how many days are over from year 1900 .
    if( FALSE == DayFrom1900( pvfdValidFileDate ) )
    {
        return FALSE ;
    }


    if( *pdwDateGreater == SMALLER_DATE )
    {// If files created before the current date is needed then
     // subtract days to current date  .
        if( pvfdValidFileDate->m_dwDay < dwDate )
        {   // Control should not come here.
            SetLastError( ERROR_FILE_NOT_FOUND ) ;
            SaveLastError() ;
            DISPLAY_GET_REASON() ;
            return FALSE ;
        }
        pvfdValidFileDate->m_dwDay -= dwDate ;
    }
    else
    {// If files created after the current date is needed then
     // add days to current date .
        if( *pdwDateGreater == GREATER_DATE )
        {
            pvfdValidFileDate->m_dwDay += dwDate ;
        }
        else
        { // Return False .
            DISPLAY_INVALID_DATE();
            return FALSE ;
        }
    }
    // If everything is fine then get date from which to start searching file ,
    // whether to find files below or above created date .
    // 'GetDate' function always returns you a number , should check for return value ,
    // is it overflowing or not or getting some negative numbers .
    if( FALSE == GetDate( pvfdValidFileDate , pvfdValidFileDate->m_dwDay ) )
    {
        return FALSE ;
    }

    return TRUE ;
}

BOOL
DayOfTheYear(
    OUT PValid_File_Date pvfdValidFileDate
    )
/*++

Routine Description:

      Returns the current day of the year .

Arguments:

      [ OUT ] pvfdValidFileDate - Will contain a valid date .

Return value:

      void is return .

--*/
{
    // Check for memory insufficient.
    if( NULL == pvfdValidFileDate )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE;
    }

    // Is current year a leap year .
    if( IS_A_LEAP_YEAR( pvfdValidFileDate->m_dwYear ) )
    {   // Add one day , as a Leap year have 366 days instead of 365 days .
        if( 2 < pvfdValidFileDate->m_dwMonth )
        {
            pvfdValidFileDate->m_dwDay += 1 ;
        }
    }

    // Go on adding number of days in a month from current month to JAN .
    for( pvfdValidFileDate->m_dwMonth ;
         pvfdValidFileDate->m_dwMonth != 1 ;
         pvfdValidFileDate->m_dwMonth-- )
    {
        pvfdValidFileDate->m_dwDay += DAYS_IN_A_MONTH[ pvfdValidFileDate->m_dwMonth - 2 ] ;
    }
    pvfdValidFileDate->m_dwDay -= 1 ;
    return TRUE;
}


BOOL
DayFrom1900(
    OUT PValid_File_Date pvfdValidFileDate
    )
/*++

Routine Description:

      Returns the current day of the year .

Arguments:

      [ OUT ] pvfdValidFileDate - Gives days elapsed in current year and
                          returns days elapsed from 1900 .

Return value:

      void is return .

--*/
{
        DWORD dwTemp = 0;   // Holds the number of days .
        // Check for memory insufficient.
        if( NULL == pvfdValidFileDate )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            SaveLastError() ;
            DISPLAY_GET_REASON() ;
            return FALSE;
        }

        // ( Current Year - 1900 ) * 365 will be days between 1900 and current
        // year , include Leap year date also .
        dwTemp = ( pvfdValidFileDate->m_dwYear - YEAR ) * DAY_IN_A_YEAR ;
        // Check whether current year is a leap year . If yes don't add one .
        // Its Because : I am taking ( current year - 1900 ) , from 01-JAN.
        // On this date their won't be any extra day , its added only after FEB 29 .
        if( IS_A_LEAP_YEAR( pvfdValidFileDate->m_dwYear ) )
        {
            dwTemp += (( pvfdValidFileDate->m_dwYear - YEAR ) / LEAP_YEAR )  ;
        }
        // else add one to it . Since a leap year is gone and 1900 is a leap year .
        else
        {
            dwTemp += (( pvfdValidFileDate->m_dwYear - YEAR ) / LEAP_YEAR ) + 1 ;
        }

        // Add obtained days to days already over in current year .
        pvfdValidFileDate->m_dwDay += dwTemp ;

        return TRUE;
}


BOOL
GetDate(
    OUT PValid_File_Date pvfdValidFileDate ,
    IN  DWORD dwDate
    )
/*++

Routine Description:

      Returns the date which was after or before the current date.
      If today 29-Jun-2001 , then day 20 days before was 09-jun-2001 .

Arguments:

      [ OUT ] pvfdValidFileDate - Contains date .

Return value:

      void is return .

--*/
{
    DWORD dwTemp = 0 ;

    // Check for memory insufficient.
    if( NULL == pvfdValidFileDate )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE;
    }

    pvfdValidFileDate->m_dwYear = YEAR;
    while( 0 != dwDate )
    {
        if( IS_A_LEAP_YEAR( pvfdValidFileDate->m_dwYear ) )
        {
            if( dwDate <= 366 )
            {
                break;
            }
            else
            {
                dwDate -= 366;
            }
        }
        else
        {
            if( dwDate <= 365 )
            {
                break;
            }
            else
            {
                dwDate -= 365;
            }

        }
        pvfdValidFileDate->m_dwYear += 1;       
    }

    // Loop till don't get a valid date .
    for( dwTemp = 0 ; dwDate != 0 ; dwTemp++ )
    {
        // Is a leap year and is it a FEB month . Extra care must
        // be taken for Leap years .
        if( ( IS_A_LEAP_YEAR( pvfdValidFileDate->m_dwYear ) ) && ( ( dwTemp + 1 ) == FEB ) )
        {   // Check whether have enough days to spend on LEAP YEAR FEB month .
            // Add an extra  day for Leap Year .
            if( dwDate > ( DAYS_IN_A_MONTH[ dwTemp ] + 1 ) )
            {   // Increment month . Decrement days that are in that month .
                pvfdValidFileDate->m_dwMonth += 1 ;
                dwDate -= DAYS_IN_A_MONTH[ dwTemp ] + 1 ;
            }
            else
            {   // Found date .
                pvfdValidFileDate->m_dwDay = dwDate ;
                dwDate = 0 ;
            }
        }// end if
        else
        {   // Check whether have enough days to spend on a month .
            if( dwDate > ( DAYS_IN_A_MONTH[ dwTemp ] ) )
            {   // Increment month . Decrement days that are in that month .
                pvfdValidFileDate->m_dwMonth += 1 ;
                dwDate -= DAYS_IN_A_MONTH[ dwTemp ] ;
            }
            else
            {   // Found date .
                pvfdValidFileDate->m_dwDay = dwDate ;
                dwDate = 0 ;
            }

        }// end else
    }// end for

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\execcommand.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ExecCommand.c

Abstract:

    Command having hexadecimal values are converted to their respective ASCII characters ,
    flags that are present in the command string are replaced by their values and
    the command formed after the replacement of hexadecimal values and flags is
    executed .

Author:

    V Vijaya Bhaskar

Revision History:

    14-Jun-2001 : Created by V Vijaya Bhaskar ( Wipro Technologies ).

--*/

#include "Global.h"
#include "ExecCommand.h"

// Declared in ForFiles.cpp , holds starting node memory location .
// No need to free this variable here, it will be freed in calling function
extern LPWSTR g_lpszFileToSearch ;
// Declared in ForFiles.cpp , holds path name specified at command prompt .
extern LPWSTR g_lpszStartPath  ;
// Stores values of flags specified at command prompt.
static WCHAR *szValue[ TOTAL_FLAGS ] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL } ;
// Stores the command to execute.
static LPWSTR g_f_lpszStoreCommand = NULL ;

/******************************************************************************
**                  Function Prototypes Local To This File                   **
******************************************************************************/
BOOL
IsHex(
    IN WCHAR tIsNum
    ) ;

DWORD
CharToNum(
    OUT DWORD dwNumber
    ) ;

BOOL
ReplaceString(
    IN OUT LPWSTR lpszString ,
    IN DWORD dwIndex
    ) ;

BOOL
ReplacePercentChar(
    void
    ) ;

void
ReleaseFlagArray(
    IN DWORD dwTotalFlags
    ) ;

BOOL
FormatMessageString(
   IN DWORD dwIndex
    ) ;

BOOL
SeperateFileAndArgs(
    IN OUT LPWSTR* lpszArguments,
    OUT    LPWSTR* lpszFileName
    ) ;

/*************************************************************************
/*      Function Definition starts from here .                          **
*************************************************************************/

BOOL
ReplaceHexToChar(
    OUT LPWSTR lpszCommand
    )
/*++

Routine Description:

    Replaces all hexadecimal values in a string to their ASCII characters .

Arguments:

      [ OUT ] lpszCommand : Contains string in which hexadecimal values
                            are to be converted to ASCII characters.

Return value:

      FALSE : Memory is insufficient.
      TRUE

--*/
{
    WCHAR *szTemp = NULL ;  // Memory  pointer .
    unsigned char cHexChar[ 5 ];     // Contains ASCII character.
    WCHAR wszHexChar[ 5 ]; // Contains UNICODE character.

    SecureZeroMemory( wszHexChar, 5 * sizeof( WCHAR ) );
    SecureZeroMemory( cHexChar, 5 * sizeof( unsigned char ) );

    if( NULL == lpszCommand )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON();
        return FALSE ;
    }

    szTemp = lpszCommand ;  // Initialized.

    // Continue while there are any hex character left .
    do
    {
        szTemp = FindSubString( szTemp , IS_HEX ) ;
        if( ( NULL != szTemp ) &&
            ( TRUE == IsHex( *( szTemp + 2 ) ) ) &&
            ( TRUE == IsHex( *( szTemp + 3 ) ) ) )
        {
            // An integer value of a hex "0x( HIGH_VALUE )( LOW_VALUE )" can
            // be obtained by ( HIGH_VALUE *16 + LOW_VALUE )  .
            cHexChar[ 0 ] = ( unsigned char )( ( CharToNum( *( szTemp + 2 ) ) * 16 ) +
                                   CharToNum( *( szTemp + 3 ) ) ) ;
            cHexChar[ 1 ] = '\0';

            // Code page is static.
            MultiByteToWideChar( US_ENG_CODE_PAGE, 0, (LPCSTR)cHexChar, -1, wszHexChar, 5 );

            *szTemp = ( WCHAR ) wszHexChar[0];

            // Copy STRING[0] = 0 , STRING[1] = x , STRING[2] = 1 , STRING[3] = a
            // To , STRING[0] = VALID_CHAR .
            StringCopy( ( szTemp + 1 ) , ( szTemp + 4 ), StringLength( ( szTemp + 1 ), 0 ) ) ;
            szTemp += 1 ;
        }
        else
        {
            /* Suppose the string contains 0xP then control should come here ,
               and this is the main purpose of this else block. */
               if( NULL != szTemp )
               {
                    szTemp += 2 ;
               }
            // Now 'szTemp' is pointing to
        }
    } while( NULL != szTemp ) ;

    return TRUE;
}


BOOL
IsHex(
    IN WCHAR wIsNum
    )
/*++

Routine Description:

    Checks whether the character falls in rangeof
    hex or not ( To fall in the range of hex a character
    must be either between 0 to 9 or a to f ).

Arguments:

      [ IN ] tIsNum : Conatins a character which is to be checked for hex range .

Return value:

     BOOL .

--*/
{
    if( ( ( _T( '0' ) <= wIsNum ) && ( _T( '9' ) >= wIsNum ) )  ||
        ( ( _T( 'A' ) <= wIsNum ) && ( _T( 'F' ) >= wIsNum ) )  ||
        ( ( _T( 'a' ) <= wIsNum ) && ( _T( 'f' ) >= wIsNum ) ) )
    {
        return TRUE ;  // Character is in the range of hex . "
    }
    else
    {
        return FALSE ;
    }
}


DWORD
CharToNum(
    OUT DWORD dwNumber
    )
/*++

Routine Description:

    Converts a character to number in HEX .
    It can be 0 - 9 or A - F .

Arguments:

      [ OUT ] dwNumber : Conatins an ASCII value .

Return value:

     DWORD .

--*/
{
    if( ( ASCII_0 <= dwNumber ) &&
        ( ASCII_9 >= dwNumber ) )
    { // Character is between 0 - 9 .
        dwNumber -= ASCII_0 ;
    }
    else
    {
        if( ( ASCII_a <= dwNumber ) &&
            ( ASCII_f >= dwNumber ) )
        { // Character is between a - f .In hex a = 10.
            dwNumber -= 87 ;
        }
        else
        {
            if( ( ASCII_A <= dwNumber ) &&
                ( ASCII_F >= dwNumber ) )
            { // Character is between A - F . In hex A = 10.
                dwNumber -= 55 ;
            }
        }
    }

    return dwNumber ;  // Return the obtained HEX number .
}


BOOL
ExecuteCommand(
    void
    )
/*++

Routine Description:

    Executes a command .

Arguments:
    NONE

Return value:

     BOOL .

--*/
{
    STARTUPINFO             stInfo ;
    PROCESS_INFORMATION     piProcess ;
    LPWSTR                  lpwszFileName = NULL;
    LPWSTR                  lpwszPathName = NULL;
    LPWSTR                  lpwFilePtr = NULL;
    DWORD                   dwFilePathLen = 0;
    DWORD                   dwTemp = 0;

    if( NULL == g_lpszFileToSearch )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON();
        return FALSE ;
    }

    // Initialize Process Info Structure With 0's
    SecureZeroMemory( &piProcess, sizeof( PROCESS_INFORMATION ) );

    // Initialize Startup Info Structure With 0's
    SecureZeroMemory( &stInfo, sizeof( STARTUPINFO ) );
    stInfo.cb = sizeof( stInfo ) ;

    if( FALSE == SeperateFileAndArgs( &g_lpszFileToSearch, &lpwszFileName ) )
    { // Error is displayed by called function.
        DISPLAY_MEMORY_ALLOC_FAIL();
        FREE_MEMORY( lpwszFileName );
        return FALSE;
    }

    dwFilePathLen = SearchPath( NULL, lpwszFileName, L".exe",
                                                           dwTemp, lpwszPathName, &lpwFilePtr );
    if( 0 == dwFilePathLen )
    {
        SetLastError( GetLastError() );
        SaveLastError();
        DISPLAY_GET_REASON();
        FREE_MEMORY( lpwszFileName );
        return FALSE;
    }

    ASSIGN_MEMORY( lpwszPathName , WCHAR , dwFilePathLen + EXTRA_MEM ) ;
    if( NULL == lpwszPathName )
    {
        DISPLAY_MEMORY_ALLOC_FAIL();
        FREE_MEMORY( lpwszFileName );
        return FALSE;
    }

    dwTemp = SearchPath( NULL, lpwszFileName, L".exe",
                         dwFilePathLen + EXTRA_MEM - 1,
                         lpwszPathName, &lpwFilePtr );
    if( 0 == dwTemp )
    {
        SetLastError( GetLastError()  );
        SaveLastError();
        DISPLAY_GET_REASON();
        FREE_MEMORY( lpwszFileName );
        FREE_MEMORY( lpwszPathName );
        return FALSE;
    }

    // Create a new process .
    if( FALSE == CreateProcess(  lpwszPathName, g_lpszFileToSearch , NULL , NULL , FALSE ,
                        0 , NULL , NULL , &stInfo , &piProcess ) )
     {
        if( ERROR_BAD_EXE_FORMAT == GetLastError() )
        {
            ShowMessageEx( stderr, 5, FALSE, L"%1 %2%3%4%5", TAG_ERROR_DISPLAY,
                           DOUBLE_QUOTES_TO_DISPLAY, _X3( lpwszFileName ),
                           DOUBLE_QUOTES_TO_DISPLAY, NOT_WIN32_APPL ) ;
        }
        else
        {
            SaveLastError() ;
            DISPLAY_GET_REASON();
        }
        FREE_MEMORY( lpwszFileName );
        FREE_MEMORY( lpwszPathName );
        return FALSE;
    }

    // Wait infinitly for the object just executed to terminate .
    WaitForSingleObject( piProcess.hProcess , INFINITE ) ;
    CloseHandle( piProcess.hProcess ) ; // Close handle of process .
    CloseHandle( piProcess.hThread ) ;  // Close handle of thread .
    FREE_MEMORY( lpwszPathName );
    FREE_MEMORY( lpwszFileName );
    return TRUE ;
}

BOOL
ReplaceTokensWithValidValue(
    IN LPWSTR lpszPathName ,
    IN WIN32_FIND_DATA wfdFindFile
    )
/*++

Routine Description:

    Replaces tokens such as @flag , @path etc. with appropriate value .

Arguments:
        [ IN ] lpszPathName - Contains current processes path name or CurrentDirectory .
        [ IN ] wfdFindFile  - Conatins information about current file being opened .
Return value:

     BOOL is returned  .

--*/
{
    static BOOL bFirstLoop = TRUE ;
    DWORD dwLength = 0;  // Contains length of a buffer.
    DWORD dwIndex = 0 ;  // Contains number of flags for which space is allocated.
    LPWSTR pwTemporary = NULL ; // Temporary data . Points to a memory location .
    SYSTEMTIME stFileTime ;     // Stores current file creation date and time information .
    FILETIME ftFileTime ;
    WCHAR szwCharSize[ MAX_PATH ] ;
    WCHAR szwCharSizeTemp[ MAX_PATH * 2 ] ;
    unsigned _int64 uint64FileSize = 0 ; // Used store data of 64 int .
    LCID lcidCurrentUserLocale  = 0; // Stores current user locale.
    BOOL bLocaleChanged = FALSE ;

    if( ( NULL == lpszPathName ) ||
        ( NULL == g_lpszFileToSearch ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON();
        return FALSE ;
    }

    SecureZeroMemory( szwCharSize, MAX_PATH * sizeof( WCHAR ) );
    SecureZeroMemory( szwCharSizeTemp, MAX_PATH * 2 * sizeof( WCHAR ) );
    SecureZeroMemory( &stFileTime, sizeof( SYSTEMTIME ) );
    SecureZeroMemory( &ftFileTime, sizeof( FILETIME ) );

    // Replacement of '%NUMBER' to '%%NUMBER' is done once only.
    if(  TRUE == bFirstLoop )
    {
        if( FALSE == ReplacePercentChar() )
        {
            return FALSE ;
        }
    }
    // Search for @fname.
    if( NULL != ( FindSubString( g_lpszFileToSearch, FILE_WITHOUT_EXT ) ) )
    {
        REPLACE_PERC_CHAR( bFirstLoop, FILE_WITHOUT_EXT, dwIndex );
        dwLength = StringLength( wfdFindFile.cFileName, 0 ) + EXTRA_MEM;
        // Assign memory to the buffer.
        ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
        dwIndex += 1;
        // Check whether memory allocation is successful.
        if( NULL == szValue[ dwIndex - 1 ] )
        {
            // Memory allocation failed.
            // Release buffers.
            DISPLAY_MEMORY_ALLOC_FAIL() ;
            ReleaseFlagArray( dwIndex );
            return FALSE ;
        }
        // Copy file name to the buffer.
        StringCopy( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;
        // ConCat file name .
        StringConcat( szValue[ dwIndex - 1 ] , wfdFindFile.cFileName, dwLength ) ;

        // Search for a '.' which separetes a file name with extension and put '\0' at '.' .
        if( NULL != ( pwTemporary =StrRChr( szValue[ dwIndex - 1 ] , NULL, _T( '.' ) ) ) )
        {
             *pwTemporary = L'\0' ;
        }
        StringConcat( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;  // Copy file name .
    }

    // Search for @file.
    if( NULL != ( FindSubString( g_lpszFileToSearch, FILE_NAME ) ) )
    {
        REPLACE_PERC_CHAR( bFirstLoop, FILE_NAME, dwIndex );
        dwLength = StringLength( wfdFindFile.cFileName, 0 ) + EXTRA_MEM ;
        // Assign memory to the buffer.
        ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
        dwIndex += 1;
        // Check whether memory allocation is successful.
        if( NULL == szValue[ dwIndex - 1 ] )
        {
            // Memory allocation failed.
            // Release buffers.
            DISPLAY_MEMORY_ALLOC_FAIL() ;
            ReleaseFlagArray( dwIndex );
            return FALSE ;
        }
        // Copy file name to the buffer.
        StringCopy( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;
        StringConcat( szValue[ dwIndex - 1 ], wfdFindFile.cFileName, dwLength );
        StringConcat( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;
    }

    // Search for @ext.
    if( NULL != ( FindSubString( g_lpszFileToSearch, EXTENSION ) ) )
    {
        REPLACE_PERC_CHAR( bFirstLoop, EXTENSION, dwIndex );
        // Check '.' character exist or not.
        // Check for '.' and replace ext .
        if( NULL != StrRChr( wfdFindFile.cFileName, NULL, _T( '.' ) ) )
        {
            dwLength = StringLength( StrRChr( wfdFindFile.cFileName, NULL, _T( '.' ) ), 0 ) + EXTRA_MEM;
            // Assign memory to the buffer.
            ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
            dwIndex += 1;
            // Check whether memory allocation is successful.
            if( NULL == szValue[ dwIndex - 1 ] )
            {
                // Memory allocation failed.
                // Release buffers.
                DISPLAY_MEMORY_ALLOC_FAIL() ;
                ReleaseFlagArray( dwIndex );
                return FALSE ;
            }

            // If number of characters appearing after '.' is zero, than assign '\0'.
            if( StringLength( ( StrRChr( wfdFindFile.cFileName, NULL, _T( '.' ) ) + 1 ), 0 ) > 0 )
            {
                StringCopy( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;
                StringConcat( szValue[ dwIndex - 1 ] ,
                                   ( StrRChr( wfdFindFile.cFileName, NULL, _T( '.' ) ) + 1 ), dwLength ) ;
                StringConcat( szValue[ dwIndex - 1 ] , L"\"", dwLength) ;
            }
            else
            { // If the filename has a '.' at the end , no extension . EX: File.
                StringCopy( szValue[ dwIndex - 1 ], L"\"\"", dwLength );
            }
        }
        else
        {
            dwLength = EXTRA_MEM + StringLength( L"\"\"", 0 );
            // Assign memory to the buffer.
            ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength  ) ;
            dwIndex += 1;
            // Check whether memory allocation is successful.
            if( NULL == szValue[ dwIndex - 1 ] )
            {
                // Memory allocation failed.
                // Release buffers.
                DISPLAY_MEMORY_ALLOC_FAIL() ;
                ReleaseFlagArray( dwIndex );
                return FALSE ;
            }
            StringCopy( szValue[ dwIndex - 1 ], L"\"\"", dwLength );
        }
    }

    // Search for @path.
    if( NULL != ( FindSubString( g_lpszFileToSearch, FILE_PATH ) ) )
    {
        REPLACE_PERC_CHAR( bFirstLoop, FILE_PATH, dwIndex );
        dwLength = StringLength( lpszPathName, 0 ) + StringLength( wfdFindFile.cFileName, 0 )+ EXTRA_MEM ;
        // Assign memory to the buffer.
        ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
        dwIndex += 1;
        // Check whether memory allocation is successful.
        if( NULL == szValue[ dwIndex - 1 ] )
        {
            // Memory allocation failed.
            // Release buffers.
            DISPLAY_MEMORY_ALLOC_FAIL() ;
            ReleaseFlagArray( dwIndex );
            return FALSE ;
        }
        // Copy path to the buffer. Path copied should be enclosed in '\"' .
        StringCopy( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;
        StringConcat( szValue[ dwIndex - 1 ] , lpszPathName, dwLength ) ;
        StringConcat( szValue[ dwIndex - 1 ] , wfdFindFile.cFileName, dwLength ) ;
        StringConcat( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;
    }

    // Search for @relpath.
    if( NULL != ( FindSubString( g_lpszFileToSearch, RELATIVE_PATH ) ) )
    {
        REPLACE_PERC_CHAR( bFirstLoop, RELATIVE_PATH, dwIndex );
        StringCopy( szwCharSizeTemp , lpszPathName, MAX_PATH * 2 ) ;
        StringConcat( szwCharSizeTemp , wfdFindFile.cFileName, MAX_PATH * 2 ) ;

        // Obtain relative path to the current file.
        if( FALSE == PathRelativePathTo( szwCharSize , g_lpszStartPath ,
                                        FILE_ATTRIBUTE_DIRECTORY ,
                                        szwCharSizeTemp ,   wfdFindFile.dwFileAttributes  ) )
        {
            // Failed to find relative path.
            SaveLastError() ;
            DISPLAY_GET_REASON();
            ReleaseFlagArray( dwIndex );
            return FALSE ;
        }

        dwLength = StringLength( szwCharSize, 0 ) + EXTRA_MEM;
        // Assign memory to the buffer.
        ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
        dwIndex += 1;
        // Check whether memory allocation is successful.
        if( NULL == szValue[ dwIndex - 1 ] )
        {
            // Memory allocation failed.
            // Release buffers.
            DISPLAY_MEMORY_ALLOC_FAIL() ;
            ReleaseFlagArray( dwIndex );
            return FALSE ;
        }
        // Copy relative path.
        StringCopy( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;
        StringConcat( szValue[ dwIndex - 1 ] , szwCharSize, dwLength ) ;
        StringConcat( szValue[ dwIndex - 1 ] , L"\"", dwLength ) ;

    }

    // Search for @ext
    if( NULL != ( FindSubString( g_lpszFileToSearch, IS_DIRECTORY ) ) )
    {
        REPLACE_PERC_CHAR( bFirstLoop, IS_DIRECTORY, dwIndex );
        if( 0 != ( wfdFindFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
        {
            dwLength = StringLength( GetResString( IDS_TRUE ), 0 ) + EXTRA_MEM ;
            // Assign memory to the buffer.
            ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
            dwIndex += 1;
            // Check whether memory allocation is successful.
            if( NULL == szValue[ dwIndex - 1 ] )
            {
                // Memory allocation failed.
                // Release buffers.
                DISPLAY_MEMORY_ALLOC_FAIL() ;
                ReleaseFlagArray( dwIndex );
                return FALSE ;
            }

            StringCopy( szValue[ dwIndex - 1 ] , GetResString( IDS_TRUE ), dwLength ) ;

        }
        else
        {
            dwLength = StringLength( GetResString( IDS_FALSE ), 0 ) + EXTRA_MEM;
            // Assign memory to the buffer.
            ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
            dwIndex += 1;
            // Check whether memory allocation is successful.
            if( NULL == szValue[ dwIndex - 1 ] )
            {
                // Memory allocation failed.
                // Release buffers.
                DISPLAY_MEMORY_ALLOC_FAIL() ;
                ReleaseFlagArray( dwIndex );
                return FALSE ;
            }
            // Copy 'false' to the buffer.
            StringCopy( szValue[ dwIndex - 1 ] , GetResString( IDS_FALSE ), dwLength ) ;
        }
    }

    // Search for @fsize
    if( NULL != ( FindSubString( g_lpszFileToSearch, FILE_SIZE ) ) )
    {
        REPLACE_PERC_CHAR( bFirstLoop, FILE_SIZE, dwIndex );

         uint64FileSize = wfdFindFile.nFileSizeHigh  * MAXDWORD ;
         uint64FileSize += wfdFindFile.nFileSizeHigh + wfdFindFile.nFileSizeLow ;

        #if _UNICODE                // If Unicode .
            _ui64tow( uint64FileSize , ( WCHAR * )szwCharSize , 10 ) ;
        #else                   // If Multibyte .
            _ui64toa( uint64FileSize , ( WCHAR * )szwCharSize , 10 ) ;
        #endif

        dwLength = StringLength( szwCharSize, 0 )+ EXTRA_MEM ;
        // Assign memory to the buffer.
        ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
        dwIndex += 1;
        // Check whether memory allocation is successful.
        if( NULL == szValue[ dwIndex - 1 ] )
        {
            // Memory allocation failed.
            // Release buffers.
            DISPLAY_MEMORY_ALLOC_FAIL() ;
            ReleaseFlagArray( dwIndex );
            return FALSE ;
        }

        StringCopy( szValue[ dwIndex - 1 ] , ( WCHAR * )szwCharSize, dwLength ) ;
    }

    // Convert obtained file date time information to user locale .
    // Convert file date time to SYSTEMTIME structure.
    if( ( TRUE == FileTimeToLocalFileTime( &wfdFindFile.ftLastWriteTime , &ftFileTime ) ) &&
        ( TRUE == FileTimeToSystemTime( &ftFileTime , &stFileTime ) ) )
    {

        // verify whether console supports the current locale 100% or not
        lcidCurrentUserLocale = GetSupportedUserLocale( &bLocaleChanged ) ;


        // Check whether @fdate exist in the user specified string.
        if( NULL != ( FindSubString( g_lpszFileToSearch, FILE_DATE ) ) )
        {
            REPLACE_PERC_CHAR( bFirstLoop, FILE_DATE, dwIndex );

            if( 0 == GetDateFormat( lcidCurrentUserLocale , DATE_SHORTDATE , &stFileTime ,
                                    ((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL) ,
                                    szwCharSize , MAX_STRING_LENGTH ) )
            {
                SaveLastError() ;
                DISPLAY_GET_REASON();
                ReleaseFlagArray( dwIndex );
                return FALSE ;
            }
            dwLength = StringLength( szwCharSize, 0 )+ EXTRA_MEM;
            // Assign memory to the buffer.
            ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
            dwIndex += 1;
            // Check whether memory allocation is successful.
            if( NULL == szValue[ dwIndex - 1 ] )
            {
                // Memory allocation failed.
                // Release buffers.
                DISPLAY_MEMORY_ALLOC_FAIL() ;
                ReleaseFlagArray( dwIndex );
                return FALSE ;
            }

            StringCopy( szValue[ dwIndex - 1 ] , szwCharSize, dwLength ) ;

        }

        // Check whether @ftime exist in the user specified string.
        if( NULL != ( FindSubString( g_lpszFileToSearch, FILE_TIME ) ) )
        {
            REPLACE_PERC_CHAR( bFirstLoop, FILE_TIME, dwIndex );

            if( 0 == GetTimeFormat( LOCALE_USER_DEFAULT , 0 , &stFileTime ,
                                    ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL) ,
                                    szwCharSize , MAX_STRING_LENGTH ) )
            {
                SaveLastError() ;
                DISPLAY_GET_REASON();
                ReleaseFlagArray( dwIndex );
                return FALSE ;
            }
            dwLength = StringLength( szwCharSize, 0 )+ EXTRA_MEM ;
            // Assign memory to the buffer.
            ASSIGN_MEMORY( szValue[ dwIndex ] , WCHAR , dwLength ) ;
            dwIndex += 1;
            // Check whether memory allocation is successful.
            if( NULL == szValue[ dwIndex - 1 ] )
            {
                // Memory allocation failed.
                // Release buffers.
                DISPLAY_MEMORY_ALLOC_FAIL() ;
                ReleaseFlagArray( dwIndex );
                return FALSE ;
            }

            StringCopy( szValue[ dwIndex - 1 ] , szwCharSize, dwLength ) ;
        }
    }

    if( TRUE == bFirstLoop )
    {
        dwLength = StringLength( g_lpszFileToSearch, 0 ) + EXTRA_MEM ;
        REALLOC_MEMORY( g_f_lpszStoreCommand , WCHAR , dwLength ) ;
        if( NULL == g_f_lpszStoreCommand )
        {
          DISPLAY_MEMORY_ALLOC_FAIL() ;
          ReleaseFlagArray( dwIndex );
          return FALSE ;
        }
        StringCopy( g_f_lpszStoreCommand, g_lpszFileToSearch, dwLength );
    }

    // Make 'bFirstLoop' flase, so we don't have to replace @FLAG for
    // command store in 'g_f_lpszStoreCommand' in '%NUMBER' format for furthur loops.
    bFirstLoop = FALSE ;


    if( FALSE == FormatMessageString( dwIndex ) )
    {
      ReleaseFlagArray( dwIndex );
      return FALSE ;
    }

    ReleaseFlagArray( dwIndex );
    return TRUE ;
}


BOOL
ReplaceString(
    IN OUT LPWSTR lpszString ,
    IN DWORD dwIndex
    )
/*++

Routine Description:

    This function replaces flags with '%NUMBER' string so to
    make FormatMEssage() comaptible.

Arguments:
        [ IN OUT ] lpszString - Contains string which is a command to execute
                                having flags which will be replace by "%NUMBER".
        [ IN ] dwIndex -        Conatins a number which will form 'NUMBER' of '%NUMBER'.
Return value:

    If success returns TRUE else FALSE.

--*/
{
    DWORD dwLength = 0;             // Contains length of a buffer.
    DWORD dwNumOfChars = 0 ;        // Contains index from where search has to be started.
    LPWSTR lpszStoreData  = NULL ;  // Temporary variable to hold data.
    // Conatins number in string format which forms 'NUMBER' of '%NUMBER'.
    // 15 is because a number or DWORD cannot be more than 10 digits.
    WCHAR szStoreIndex[ 15 ] ;
    WCHAR *pwTemporary = NULL ;     // Temporary variable, points to an index in a buffer.
    #ifdef _WIN64
        __int64 dwStringLen = 0 ;
    #else
        DWORD dwStringLen = 0 ;
    #endif

    if( ( NULL == g_lpszFileToSearch ) ||
        ( NULL == lpszString ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON();
        return FALSE ;
    }

    SecureZeroMemory( szStoreIndex, 15 * sizeof( WCHAR ) );
    // If Unicode .
    _ultow( dwIndex, ( WCHAR * )szStoreIndex, 10 );

    // Loops till @FLAG to be searched doesn't get replaced by a '%NUMBER' string.
    while( NULL != ( pwTemporary = FindSubString( g_lpszFileToSearch + dwNumOfChars , lpszString ) ) )
    {
        dwLength = StringLength( pwTemporary, 0 ) + EXTRA_MEM;
        // Get memory in which to store the data present after the @FLAG.
        ASSIGN_MEMORY( lpszStoreData , WCHAR , dwLength ) ;

        // Check whether memory allocation was successful.
        if( NULL == lpszStoreData )
        {   // Memory allocation was unsuccessful.
            DISPLAY_MEMORY_ALLOC_FAIL();
            return FALSE ;
        }
        // Copy data appering after @FLAG into temporary variable.
        StringCopy( lpszStoreData , ( pwTemporary + StringLength( lpszString, 0 ) ), dwLength ) ;
        // Replace @FLAG with '%NUMBER' string.
        if( NULL != ( pwTemporary = FindSubString( g_lpszFileToSearch + dwNumOfChars , lpszString ) ) )
        {
            dwStringLen = pwTemporary - g_lpszFileToSearch;
            // Copy '%' character.
            StringCopy( pwTemporary , L"%",
                        ( ( GetBufferSize( g_lpszFileToSearch )/ sizeof( WCHAR ) ) - (DWORD)dwStringLen ) ) ;
            // Copy 'NUMBER' string into buffer.
            StringConcat( pwTemporary , szStoreIndex,
                          ( ( GetBufferSize( g_lpszFileToSearch )/ sizeof( WCHAR ) ) - (DWORD)dwStringLen ) ) ;
        }
        // Get index from where to start search for next @FLAG.
        dwNumOfChars = StringLength( g_lpszFileToSearch, 0 ) ;
        // Concat data which was appearing after replaced @FLAG.
        StringConcat( g_lpszFileToSearch , lpszStoreData,
                      ( GetBufferSize( g_lpszFileToSearch )/sizeof( WCHAR ) ) ) ;
        // Free memory.
        FREE_MEMORY( lpszStoreData ) ;
    }
    return TRUE;
}

BOOL
ReplacePercentChar(
    void
    )
/*++

Routine Description:

    This function replaces '%' characters with '%%' string.
    This is needed to distinguish between '%NUMBER' character which
    is replaced by FormatMessageString() .

Arguments:

Return value:

    If success returns TRUE else FALSE.

--*/

{
    DWORD dwLength = 0; //Contains length of a buffer.
    DWORD dwReallocLength = 0;
    DWORD dwPercentChar = 0 ;    // Keep record of number '%' char to be replaced.

    #ifdef _WIN64
        __int64 dwNumOfChars = 0 ;
    #else
        DWORD dwNumOfChars = 0 ; // Keep record of position or index from where to start next search.
    #endif


    LPWSTR lpszStoreData  = NULL ;      // Temporary variable to store data.
    WCHAR *pwTemporary = NULL ;         // Temporary pointer.

    // Check whether variable is valid.
    if( NULL == g_lpszFileToSearch )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON();
        return FALSE ;
    }

    // Check number of '%' characters to replace with '%%'.
    while( NULL != ( pwTemporary = StrPBrk( g_lpszFileToSearch + dwNumOfChars , L"%" ) ) )
    {
        dwPercentChar += 1;

        // Point index to present char plus 2.
        dwNumOfChars =  pwTemporary - g_lpszFileToSearch + 1 ;

    }

    dwNumOfChars = 0 ; // Initialize variable to zero.
    dwReallocLength = StringLength( g_lpszFileToSearch, 0 ) + dwPercentChar + EXTRA_MEM;
    // Reallocate the orginal buffer and copy path to traverse .
    REALLOC_MEMORY( g_lpszFileToSearch , WCHAR , dwReallocLength ) ;
    if( NULL == g_lpszFileToSearch  )
    { // Reallocation failed .'g_lpszFileToSearch' will be freed in calling function.
        DISPLAY_MEMORY_ALLOC_FAIL() ;
        return FALSE ;
    }

    // Loop till '%' character exist.
    while( NULL != ( pwTemporary = StrPBrk( g_lpszFileToSearch + dwNumOfChars , L"%" ) ) )
    {
        dwLength = StringLength( pwTemporary, 0 ) + EXTRA_MEM;
        // Assign memory.
        ASSIGN_MEMORY( lpszStoreData , WCHAR , dwLength  ) ;
        // Check is memory allocation successful.
        if( NULL == lpszStoreData )
        {
            // Memory allocation failed.
            DISPLAY_MEMORY_ALLOC_FAIL() ;
            return FALSE ;
        }
        // Copy data appearing after '%'.
        StringCopy( lpszStoreData , ( pwTemporary + StringLength( L"%", 0 ) ), dwLength ) ;

        // Replace '%' with '%%'.
        if( NULL != ( pwTemporary = FindSubString( g_lpszFileToSearch + dwNumOfChars ,  L"%" ) ) )
        {
            StringCopy( pwTemporary , L"%%",
                        ( ( GetBufferSize( g_lpszFileToSearch )/ sizeof( WCHAR ) ) - (LONG)dwNumOfChars ) );
        }
        // Point index to position which is not searched till.
        dwNumOfChars = StringLength( g_lpszFileToSearch, 0 ) ;
        // Concat data appearing after '%'.
        StringConcat( g_lpszFileToSearch , lpszStoreData, dwReallocLength ) ;
        FREE_MEMORY( lpszStoreData ) ;
    }
return TRUE;
}

void
ReleaseStoreCommand(
    void
    )
/*++

Routine Description:

    Releases 'g_f_lpszStoreCommand' global variable to this file.

Arguments:

Return value:

    VOID is returned.

--*/

{
    FREE_MEMORY( g_f_lpszStoreCommand ) ;
    return;
}

void
ReleaseFlagArray(
    IN DWORD dwTotalFlags
    )
/*++

Routine Description:

    Releases variables used to store values replacing @FLAG.

Arguments:

    [ IN ] dwTotalFlags - Contains index of an array till which memory is assigned.

Return value:

    VOID is returned.

--*/

{
    DWORD i = 0 ;

    for( i = 0 ; i < dwTotalFlags ; i++ )
    {
        FREE_MEMORY( szValue[ i ] ) ;
    }
    return ;
}

BOOL
FormatMessageString(
    DWORD dwIndex
    )
/*++

Routine Description:

   Replaces '%NUMBER' with its appropriate values.

Arguments:

    [ IN ] dwIndex - Contains index of an array till which memory is assigned.

Return value:

    FALSE is returned when memory allocation failed else TRUE is returned..

--*/
{
    DWORD dwLength = 0 ; //Contains length of a string.
    DWORD dwTemp = 0 ;
    DWORD dwNumber = 0 ; // Stores 'NUMBER' %NUMBER to replace.

    // Keep record of position or index from where to start next search.
    #ifdef _WIN64
        __int64 dwLocation = 0 ;
    #else
        DWORD dwLocation = 0 ;
    #endif

    LPWSTR lpszTempStr = NULL ;
    LPWSTR lpszTempStr1 = NULL ;
    LPWSTR lpszDataToStore = NULL ;

    if( NULL == g_f_lpszStoreCommand )
    {
      SetLastError( ERROR_INVALID_PARAMETER );
      SaveLastError();
      DISPLAY_GET_REASON();
      return FALSE ;
    }

    dwLength = StringLength( g_f_lpszStoreCommand, 0 ) + EXTRA_MEM ;
    // Realloc memory.
    REALLOC_MEMORY( g_lpszFileToSearch , WCHAR , dwLength ) ;
    if( NULL == g_lpszFileToSearch )
    {
      DISPLAY_MEMORY_ALLOC_FAIL() ;
      return FALSE ;
    }

    StringCopy( g_lpszFileToSearch, g_f_lpszStoreCommand, dwLength );

    // Loop until no more '%' are left.
    while( NULL != ( lpszTempStr = FindAChar( ( g_lpszFileToSearch + dwLocation ), _T( '%' ) ) ) )
    {
        // Check whether '%' or 'NUMBER' is present after '%'.
        if( _T( '%' ) == *( lpszTempStr + 1 ) )
        {
            // If '%%' is present then replace it with '%'.
            dwLocation = lpszTempStr - g_lpszFileToSearch ;
            // Set pointer to point to first '%'
            lpszTempStr1 = lpszTempStr;
            // Move pointer to point to second '%'.
            lpszTempStr += 1 ;
            // Copy.
            StringCopy( lpszTempStr1, lpszTempStr, ( dwLength - ( DWORD ) dwLocation ) ) ;
            dwLocation += 1 ;
        }
        else
        {
            // Replace '%NUMBER' with appropriate value.
            dwNumber = *( lpszTempStr + 1 ) - 48 ;

            if( dwIndex >= dwNumber )
            {
                ASSIGN_MEMORY( lpszDataToStore , WCHAR ,
                               StringLength( lpszTempStr, 0 ) + EXTRA_MEM ) ;
                if( NULL == lpszDataToStore )
                {   // No need to worry for 'g_lpszFileToSearch',
                    // will be freed in calling function.
                    DISPLAY_MEMORY_ALLOC_FAIL() ;
                    return FALSE ;
                }

                dwTemp  = StringLength( szValue[ dwNumber - 1 ], 0 ) ;
                dwLength = StringLength( g_lpszFileToSearch, 0 ) + dwTemp + EXTRA_MEM ;
                REALLOC_MEMORY( g_lpszFileToSearch , WCHAR , dwLength ) ;
                if( NULL == g_lpszFileToSearch )
                {
                    FREE_MEMORY( lpszDataToStore ) ;
                    DISPLAY_MEMORY_ALLOC_FAIL() ;
                    return FALSE ;
                }

                // Check for '%' in the string after reallocation.
                if( NULL != ( lpszTempStr = FindAChar( ( g_lpszFileToSearch + dwLocation ), _T( '%' ) ) ) )
                {
                    // Store data after '%NUMBER' into a different string.
                    StringCopy( lpszDataToStore, ( lpszTempStr + 2 ),
                                ( GetBufferSize( lpszDataToStore )/ sizeof( WCHAR ) ) );
                    // Copy value to be replaced by '%NUMBER'.
                    dwLocation = lpszTempStr - g_lpszFileToSearch;
                    StringCopy( lpszTempStr, szValue[ dwNumber - 1 ], ( dwLength - ( DWORD ) dwLocation ) );
                    // Copy string present after '%NUMBER' to origiinal strnig.
                    StringConcat( lpszTempStr, lpszDataToStore,
                                       ( dwLength - ( DWORD ) dwLocation ) );
                    dwLocation = ( lpszTempStr - g_lpszFileToSearch ) + dwTemp ;
                }
                FREE_MEMORY( lpszDataToStore ) ;
            }
            else
            {
                dwLocation += 1 ;
            }
        }
    }
    return TRUE;
}


BOOL
SeperateFileAndArgs(
    IN OUT LPWSTR* lpszArguments,
    OUT    LPWSTR* lpszFileName
    )
/*++

Routine Description:

   Separates EXE and ARGUMENTS from a command line argument.

Arguments:

    [ IN OUT ] *lpszArguments - Contains command line arguments.
    [ IN ]     *lpszFileName  - Contains file name to execute.

Return value:

    FALSE is returned when memory allocation failed els TRUE is returned..

--*/
{
    LPWSTR lpTemp = NULL;
    LPWSTR lpDummy = NULL;
    DWORD  dwLength = 0;

    // Check for invalid parameter.
    if( ( NULL == lpszArguments ) ||
        ( NULL == *lpszArguments ) ||
        ( NULL == lpszFileName ) ||
        ( NULL != *lpszFileName ) )
    {
      SetLastError( ERROR_INVALID_PARAMETER );
      SaveLastError();
      DISPLAY_GET_REASON();
      return FALSE ;
    }

    // Initialize.
    lpTemp = *lpszArguments;
    // Remove any spaces appearing before the EXE.
    if( _T( ' ' ) == lpTemp[ 0 ] )
    {
        TrimString2( lpTemp, _T( " " ), TRIM_LEFT );
    }

    // Search for end of the EXE
    if( _T( '\"' ) == lpTemp[ 0 ] )
    {   // EXE is wrapped in quotes.
        lpTemp += 1;
        lpDummy = FindAChar( lpTemp, _T( '\"' ) );
    }
    else
    {   // Assumed that EXE is not wrapped in quotes.
        lpDummy = FindAChar( lpTemp, _T( ' ' ) );
    }

    // Get length of buffer to allocate.
    if( NULL == lpDummy )
    {
        dwLength = StringLength( lpTemp, 0 );
    }
    else
    {
        dwLength = ( DWORD ) ( DWORD_PTR ) ( lpDummy - lpTemp );
    }

    // Assign memory.
    ASSIGN_MEMORY( *lpszFileName , WCHAR , dwLength + EXTRA_MEM ) ;
    if( NULL == *lpszFileName )
    {
        DISPLAY_MEMORY_ALLOC_FAIL();
        return FALSE;
    }

    // '+1' for null termination.
    StringCopy( *lpszFileName, lpTemp, dwLength + 1 );

    if( NULL == lpDummy )
    {
        StringCopy( lpTemp, _T( "" ), StringLength( lpTemp, 0 ) );
    }
    else
    {
        if( _T( '\"' ) == *lpDummy )
        {
            StringCopy( lpTemp, lpTemp + dwLength + 2, StringLength( lpTemp, 0 ) );
        }
        else
        {
            StringCopy( lpTemp, lpTemp + dwLength + 1, StringLength( lpTemp, 0 ) );
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\filedate.h ===
/*++

  Copyright (c) Microsoft Corporation

  Module Name:

      FileDate.h

  Abstract:

      Contains function prototypes , structure and macros.

  Author:

      V Vijaya Bhaskar

  Revision History:

      14-Jun-2001 : Created by V Vijaya Bhaskar ( Wipro Technologies ).

--*/

#ifndef __FILE_DATE__H
#define __FILE_DATE__H

// Character Found In The Start Of A Specified Date .
#define     PLUS                            _T( '+' )
#define     MINUS                           _T( '-' )

/* Date Specified In <+|->MM/DD/YYYY , Which Are Nine Characters . */
#define LENGTH_DDMMYYYY 11

/* Month In A Year */
#define     JAN                             1
#define     FEB                             2
#define     MAR                             3
#define     APR                             4
#define     MAY                             5
#define     JUN                             6
#define     JUL                             7
#define     AUG                             8
#define     SEP                             9
#define     OCT                             10
#define     NOV                             11
#define     DEC                             12

/* Constants And Max And Min Dates */
#define     MOD_LEAP_YEAR                   4  // Leap Year Has 29 Days .

// Days In Feb Month In A Lep Year .
#define     DAYS_INFEB_LEAP_YEAR            29

// Days In Feb When It Is Not A Leap Year .
#define     DAYS_INFEB                      28

// Normay A Month Have Either 31 Or 30 Days .
#define     THIRTYONE                       31
#define     THIRTY                          30

// Year Considered When Date Is To Be Calculated From A Given Date .
#define     YEAR                            1900

// Days In An Year , Except A Leap Year Where There Are 366 Days .
#define     DAY_IN_A_YEAR                   365

#define     MIN_DATE_LENGTH                 9
#define     MAX_DATE_LENGTH                 11

//
#define     LEAP_YEAR                       4

// If File Creation Date Should Be Less Than The Date Specified .
#define     SMALLER_DATE                    0

// If File Creation Date Should Be Greater Than The Date Specified .
#define     GREATER_DATE                    1

#define     NO_RESTRICTION_DATE             2

// Condition for a leap year.
#define     IS_A_LEAP_YEAR( DATE )         ( 0 == ( DATE % 400 ) ) ||  \
                                           ( ( 0 == ( DATE % 4 ) ) && \
                                             ( 0 != ( DATE % 100 ) ) )

//Errors .
#define   ERROR_INVALID_DATE            GetResString( IDS_ERROR_INVALID_DATE )

// Structure Used To Store A Date From Which Files Are To Be Displayed .
typedef struct __VALID_FILE_DATE
{
    DWORD m_dwDay   ;
    DWORD m_dwMonth ;
    DWORD m_dwYear  ;
} Valid_File_Date , *PValid_File_Date ;

/* Function Prototypes For World . */
BOOL
FileDateValid(
    IN DWORD dwDateGreater ,
    IN Valid_File_Date vfdValidFileDate ,
    IN FILETIME ftFileCreation
    ) ;

BOOL ValidDateForFile(
    OUT DWORD *dwDateGreater ,
    OUT PValid_File_Date pvfdValidFileDate ,
    IN LPWSTR lpszDate
    ) ;

#endif  // __FILE_DATE__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\forfiles.h ===
/*++

  Copyright (c) Microsoft Corporation

  Module Name:

      ForFiles.h

  Abstract:

      Contains function prototypes and macros.

  Author:

      V Vijaya Bhaskar

  Revision History:

      14-Jun-2001 : Created by V Vijaya Bhaskar ( Wipro Technologies ).

--*/

#ifndef __FOR_FILES__H
#define __FOR_FILES__H

#define     DEFAULT_SEARCH_MASK     _T( "*" )
#define     DEFAULT_COMMAND         _T( "cmd /c echo @file" )
#define     SINGLE_SLASH            _T( "\\" )
#define     DOUBLE_SLASH            _T( "\\\\" )
#define     TRIPLE_SLASH            _T( "\\\\\\" )
#define     SINGLE_DOT              _T( "." )
#define     DOUBLE_DOT              _T( ".." )

#define     DATE_FORMAT             L"%d%s%d%s%d"
#define     MAX_COLUMNS             1

#define   ERROR_INVALID_SYNTAX          GetResString( IDS_ERROR_INVALID_SYNTAX )
#define   ERROR_NOFILE_FOUND            GetResString( IDS_ERROR_NOFILE_FOUND )
#define   ERROR_NOFILE_FOUND1           GetResString( IDS_ERROR_NOFILE_FOUND1 )
#define   TAG_ERROR_ACCESS_DENIED       GetResString( IDS_TAG_ERROR_ACCESS_DENIED )
#define   APPEND_AT_END                 GetResString( IDS_APPEND_AT_END )
#define   ERROR_CRITERIA_MISMATCHED     GetResString( IDS_ERROR_FILE_NOT_FOUND )
#define   ERROR_DIRECTORY_INVALID       GetResString( IDS_DIRECTORY_INVALID )
#define   ERROR_UNC_PATH_NAME           GetResString( IDS_ERROR_UNC_PATH_NAME )


#define   FORMAT_0                      GetResString( IDS_DATE_FORMAT_0 )
#define   FORMAT_1                      GetResString( IDS_DATE_FORMAT_1 )
#define   FORMAT_2                      GetResString( IDS_DATE_FORMAT_2 )
#define   FORMAT_3                      GetResString( IDS_DATE_FORMAT_3 )
#define   FORMAT_4                      GetResString( IDS_DATE_FORMAT_4 )
#define   FORMAT_5                      GetResString( IDS_DATE_FORMAT_5 )

/***********************************************************
/*      Defines Related Command Line Inputs               **
/**********************************************************/
#define     MAX_OPTIONS     6

#define OPTION_USAGE            _T( "?"  )                      // 1
#define OPTION_PATH             _T( "p" )                       // 2
#define OPTION_SEARCHMASK       _T( "m"  )                      // 3
#define OPTION_COMMAND          _T( "c"  )                      // 4
#define OPTION_DATE             _T( "d"  )                      // 5
#define OPTION_RECURSE          _T( "s" )                       // 6


// indexes
#define OI_USAGE                0
#define OI_PATH                 1
#define OI_SEARCHMASK           2
#define OI_COMMAND              3
#define OI_DATE                 4
#define OI_RECURSE              5

#define CLOSE_FILE_HANDLE( FILE_HANDLE ) \
            if( 0 != FILE_HANDLE ) \
            { \
                    FindClose( FILE_HANDLE ) ;  \
                    FILE_HANDLE = 0 ;  \
            } \
            1
#endif  //__FOR_FILES__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\forfiles.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ForFiles.c

Abstract:

    This file finds files present in a directory and subdirectory and
    calls appropriate function to perform the rest of task.

Author:

    V Vijaya Bhaskar

Revision History:

    14-Jun-2001 : Created by V Vijaya Bhaskar ( Wipro Technologies ).

--*/

#include "Global.h"
#include "FileDate.h"
#include "ExecCommand.h"
#include "Forfiles.h"

 PStore_Path_Name    g_pPathName = NULL ;       // Holds path name from where started .
 PStore_Path_Name    g_pFollowPathName = NULL ; // Holds information about a subdirectory .
 LPWSTR g_lpszFileToSearch = NULL; // Holds information about directories and subdirectories .
 LPWSTR g_lpszStartPath = NULL ;

/******************************************************************************
**                  Function Prototypes                                      **
******************************************************************************/
BOOL
ProcessOptions(
    IN DWORD argc ,
    IN LPCWSTR *argv ,
    OUT LPWSTR lpszPathName ,
    OUT LPWSTR lpszSearchMask ,
    OUT LPWSTR lpszCommand ,
    OUT LPWSTR lpszDate ,
    OUT BOOL *pbRecurse ,
    OUT BOOL *pbUsage  ,
    OUT BOOL *pbSearchFilter
    ) ;

BOOL
DisplayUsage(
    IN DWORD dwStartUsage ,
    IN DWORD dwEndUsage
    )  ;

BOOL
DisplayMatchedFiles(
    IN LPWSTR lpszPathName ,
    IN LPWSTR lpszSearchMask ,
    IN LPWSTR lpszCommand ,
    IN Valid_File_Date vfdValidFileDate ,
    IN DWORD dwDateGreater ,
    IN BOOL bRecurse ,
    IN BOOL bSearchFilter
    ) ;

BOOL
Push(
    IN LPWSTR lpszPathName
    ) ;

BOOL
Pop(
    void
    ) ;

BOOL
DisplayFile(
    IN OUT BOOL *pbHeader ,
    IN LPWSTR lpszPathName ,
    IN DWORD dwDateGreater ,
    IN LPWSTR lpszCommand ,
    IN Valid_File_Date vfdValidFileDate ,
    IN OUT BOOL *pbReturn ,
    IN LPWSTR lpszSearchMask ,
    IN     BOOL bRecurse
    ) ;

BOOL
FindAndReplaceString(
    IN OUT LPWSTR lpszString,
    IN LPWSTR lpszFlag
    ) ;

BOOL
InitStartPath(
    LPWSTR lpszPathName,
    LPWSTR lpszCommand
    ) ;

BOOL
CheckDateLocalized(
    LPWSTR lpwszDate,
    DWORD* pdwDateFormat,
    LPWSTR lpszDateSep
    );

BOOL
PatternMatch(
      IN LPWSTR szPat,
      IN LPWSTR szFile
      );

/*************************************************************************
/*      Function Definition starts from here .                          **
*************************************************************************/


DWORD
__cdecl _tmain(
    IN DWORD argc ,
    IN LPCWSTR argv[]
    )
/*++

Routine Description:

    This is the main entry point to this code . Input supplied is
    read and appropriate function is called to achieve the functionality .

Arguments:

      [ IN ] argc - Contains number of arguments passed at command prompt .
      [ IN ] argv - Contains value of each argument in string format .

Return value:

    0 if tool succedded and 1 if tool failed .

--*/
{

    // Variables to be passed to other functions .
    DWORD dwDateGreater   = 2 ;
    DWORD dwOldErrorMode  = 0;
    Valid_File_Date vfdValidFileDate ;

    // Variables required to hold command line inputs .
    WCHAR  szPathName[ MAX_STRING_LENGTH * 2 ] ;
    WCHAR  szCommand[ MAX_STRING_LENGTH ] ;
    BOOL   bRecurse        =    FALSE;
    BOOL   bUsage          =    FALSE;
    BOOL   bSearchFilter   =    TRUE ;

    // Variables required to hold command line inputs .
    // Variables to be passed to other functions but are to be
    // removed  or freed when they are not needed .
    LPWSTR  lpszDate       =    NULL ;
    LPWSTR  lpszSearchMask =    NULL ;

    // Initialize to zero.
    SecureZeroMemory( &vfdValidFileDate, sizeof( Valid_File_Date ) );
    SecureZeroMemory( szPathName, MAX_STRING_LENGTH * 2 * sizeof( WCHAR ) );
    SecureZeroMemory( szCommand, MAX_STRING_LENGTH * sizeof( WCHAR ) );

    // Allocate memory to these variables .
    ASSIGN_MEMORY( lpszDate , WCHAR , MAX_STRING_LENGTH ) ;
    ASSIGN_MEMORY( lpszSearchMask , WCHAR , MAX_STRING_LENGTH ) ;

    // Check whether memory allocation was successfully .
    if( ( NULL == lpszSearchMask ) || ( NULL == lpszDate ) )
    {   // Memory Allocation Failed .
        DISPLAY_MEMORY_ALLOC_FAIL();
        FREE_MEMORY( lpszDate ) ;
        FREE_MEMORY( lpszSearchMask ) ;
        ReleaseGlobals() ;
        return EXIT_FAILURE ; // 1 errorlevel
    }

    dwOldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );
    // Check out whether arguments passed are valid and is the syntax right .
    if( FALSE == ProcessOptions( argc, argv, szPathName, lpszSearchMask, szCommand, lpszDate,
                        &bRecurse, &bUsage, &bSearchFilter ) )
    { // Some error occured , free memory allocated , and exit .
        FREE_MEMORY( lpszDate ) ;
        FREE_MEMORY( lpszSearchMask ) ;
        ReleaseGlobals() ;
        SetErrorMode( dwOldErrorMode );
        return EXIT_FAILURE ;  // 1 errorlevel
    }

    // Check whether /? was specified at command prompt .
    if( TRUE == bUsage  )
    {   // Free variable , and display help .
        // Since 'dwDateGreater' is no more used, it is used for
        // return value only in this block.
        dwDateGreater = EXIT_SUCCESS;
        if( FALSE == DisplayUsage( IDS_HELP_START , IDS_HELP_END ) )
        {
            dwDateGreater = EXIT_FAILURE;
        }
        FREE_MEMORY( lpszDate ) ;
        FREE_MEMORY( lpszSearchMask ) ;
        ReleaseGlobals() ;
        SetErrorMode( dwOldErrorMode );
        return dwDateGreater ; // 0 or 1 errorlevel.
    }

    if( TRUE == SetCurrentDirectory( szPathName ) )
    { // Sets process directory to supplied directory .
        if( TRUE == InitStartPath( szPathName, szCommand ) )
        {// Start path is intialized.
            if( TRUE == Push( szPathName ) )
            { // Push the current directory .
                // 'bUsage' is not needed anymore. Can be used for other purpose.
                bUsage = TRUE;
                if( 0 != StringLength( lpszDate, 0 ) )
                {
                    bUsage = ValidDateForFile( &dwDateGreater , &vfdValidFileDate , lpszDate );
                }
                if( TRUE == bUsage )
                { // Get date from where to display files .
                    FREE_MEMORY( lpszDate ) ;
                    if( TRUE == DisplayMatchedFiles( szPathName , lpszSearchMask , szCommand ,
                                 vfdValidFileDate , dwDateGreater , bRecurse , bSearchFilter ) )
                        {
                            FREE_MEMORY( g_lpszStartPath ) ;
                            FREE_MEMORY( lpszSearchMask ) ;
                            ReleaseStoreCommand();
                            ReleaseGlobals() ;
                            SetErrorMode( dwOldErrorMode );
                            return EXIT_SUCCESS ;
                        }
                }
            }
        }
    }
    else
    {   // Path supplied was wrong .
        dwDateGreater = GetLastError();
        switch( dwDateGreater )
        {
            case ERROR_BAD_NET_NAME:
            case ERROR_BAD_NETPATH:
                SetLastError( ERROR_INVALID_NAME ) ;
                SaveLastError() ;
                DISPLAY_GET_REASON() ;
                break;
            case ERROR_ACCESS_DENIED:
                SetLastError( ERROR_ACCESS_DENIED );
                SaveLastError() ;
                DISPLAY_GET_REASON() ;
                break;
            case ERROR_INVALID_NAME:
                SetLastError( ERROR_DIRECTORY );
                SaveLastError() ;
                DISPLAY_GET_REASON() ;
                break;
            default:
                ShowMessageEx( stderr, 2, FALSE, L"%1 %2",TAG_ERROR_DISPLAY,
                               ERROR_DIRECTORY_INVALID ) ;
        }
    }

    // Free nodes in a linked list .
    while( NULL != g_pPathName )
    {
        // More than one node is present .
        g_pFollowPathName = g_pPathName ;
        g_pPathName = g_pFollowPathName->NextNode ;
        FREE_MEMORY( g_pFollowPathName->pszDirName ) ;
        FREE_MEMORY( g_pFollowPathName ) ;
    }

    FREE_MEMORY( g_lpszStartPath ) ;
    FREE_MEMORY( lpszSearchMask ) ;
    FREE_MEMORY( lpszDate ) ;
    ReleaseStoreCommand();
    ReleaseGlobals() ;
    SetErrorMode( dwOldErrorMode );
    return EXIT_FAILURE ;
}


BOOL
ProcessOptions(
    IN DWORD argc ,
    IN LPCWSTR *argv ,
    OUT LPWSTR lpszPathName ,
    OUT LPWSTR lpszSearchMask ,
    OUT LPWSTR lpszCommand ,
    OUT LPWSTR lpszDate ,
    OUT BOOL *pbRecurse ,
    OUT BOOL *pbUsage  ,
    OUT BOOL *pbSearchFilter
    )
/*++

Routine Description:

    Arguments supplied at command line are checked in this function for syntax
    or boundary or invalid command etc .

Arguments:

      [ IN ] argc            - Contains number of arguments passed at command prompt .
      [ IN ] *argv           - Contains value of each argument in tring format .
      [ OUT ] lpszPathName   - Contain path of a directory , if /pa option
                               is specified .
      [ OUT ] lpszSearchMask - Contain search mask with which a file is to be
                               searched , if /m option is specified .
      [ OUT ] lpszCommand    - Contain command to execute , if /c option is specified .
      [ OUT ] lpszDate       - Contain date , if /d option is specifed .
      [ OUT ] *pbRecurse     - Whether to recurse into subdirectories ,
                               if /sd option specifed .
      [ OUT ] *pbUsage       - Display help usage , if /? is specifed .
      [ OUT ] *pbSearchFilter- Search Filter /m option is specified or not .

Return value:

    TRUE if syntax and arguments supplied to option are right else FALSE .

--*/
{
    // local variables
    LPWSTR lpCharTemp = NULL ;         // Pointer To Memory Location .
    PTCMDPARSER2     pcmdOption = NULL;
    TCMDPARSER2      cmdOptions[ MAX_OPTIONS ];
    // If user supplied file name is of 255 characters , then need some extra
    // space for copying the directory into it .
    WCHAR lpszTemp[ MAX_STRING_LENGTH * 2 ];

    if( ( NULL == argv ) ||
        ( NULL == lpszPathName ) ||
        ( NULL == lpszSearchMask ) ||
        ( NULL == lpszCommand ) ||
        ( NULL == lpszDate ) ||
        ( NULL == pbRecurse ) ||
        ( NULL == pbUsage ) ||
        ( NULL == pbSearchFilter ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    // prepare the command options
    SecureZeroMemory( cmdOptions, sizeof( TCMDPARSER2 ) * MAX_OPTIONS );
    SecureZeroMemory( lpszTemp, MAX_STRING_LENGTH * 2 * sizeof( WCHAR ) );

    // -?
    pcmdOption = &cmdOptions[ OI_USAGE ] ;

    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwType  = CP_TYPE_BOOLEAN;
    pcmdOption->pwszOptions = OPTION_USAGE;
    pcmdOption->pwszFriendlyName = NULL;
    pcmdOption->pwszValues = NULL;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwCount = 1;
    pcmdOption->dwActuals = 0;
    pcmdOption->pValue = pbUsage;
    pcmdOption->dwLength  = 0;
    pcmdOption->pFunction = NULL;
    pcmdOption->pFunctionData = NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;

    // -p
    pcmdOption = &cmdOptions[ OI_PATH ] ;

    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwType  = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_PATH;
    pcmdOption->pwszFriendlyName = NULL;
    pcmdOption->pwszValues = NULL;
    pcmdOption->dwFlags = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdOption->dwCount = 1;
    pcmdOption->dwActuals = 0;
    pcmdOption->pValue = lpszPathName;
    pcmdOption->dwLength  = ( MAX_STRING_LENGTH * 2 );
    pcmdOption->pFunction = NULL;
    pcmdOption->pFunctionData = NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;

    // -m
    pcmdOption = &cmdOptions[ OI_SEARCHMASK ] ;

    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwType  = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_SEARCHMASK;
    pcmdOption->pwszFriendlyName = NULL;
    pcmdOption->pwszValues = NULL;
    pcmdOption->dwFlags = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdOption->dwCount = 1;
    pcmdOption->dwActuals = 0;
    pcmdOption->pValue = lpszSearchMask;
    pcmdOption->dwLength  = MAX_STRING_LENGTH;
    pcmdOption->pFunction = NULL;
    pcmdOption->pFunctionData = NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;

    // -c
    pcmdOption = &cmdOptions[ OI_COMMAND ] ;

    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwType  = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_COMMAND;
    pcmdOption->pwszFriendlyName = NULL;
    pcmdOption->pwszValues = NULL;
    pcmdOption->dwFlags = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdOption->dwCount = 1;
    pcmdOption->dwActuals = 0;
    pcmdOption->pValue = lpszCommand;
    pcmdOption->dwLength  = MAX_STRING_LENGTH;
    pcmdOption->pFunction = NULL;
    pcmdOption->pFunctionData = NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;

    // -d
    pcmdOption = &cmdOptions[ OI_DATE ] ;

    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwType  = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_DATE;
    pcmdOption->pwszFriendlyName = NULL;
    pcmdOption->pwszValues = NULL;
    pcmdOption->dwFlags = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdOption->dwCount = 1;
    pcmdOption->dwActuals = 0;
    pcmdOption->pValue = lpszDate;
    /*************************************************************
    ** If '+' or '-' is not specified then one character buffer **
    ** extra is needed. That's why 1 less buffer is passed. If  **
    ** -1 is removed then overflow of buffer occurs which       **
    ** incorrect information.                                   **
    *************************************************************/
    pcmdOption->dwLength  = MAX_STRING_LENGTH - 1;
    pcmdOption->pFunction = NULL;
    pcmdOption->pFunctionData = NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;

    // -s
    pcmdOption = &cmdOptions[ OI_RECURSE ] ;

    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwType  = CP_TYPE_BOOLEAN;
    pcmdOption->pwszOptions = OPTION_RECURSE;
    pcmdOption->pwszFriendlyName = NULL;
    pcmdOption->pwszValues = NULL;
    pcmdOption->dwFlags = 0;
    pcmdOption->dwCount = 1;
    pcmdOption->dwActuals = 0;
    pcmdOption->pValue = pbRecurse;
    pcmdOption->dwLength  = 0;
    pcmdOption->pFunction = NULL;
    pcmdOption->pFunctionData = NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;

    // Do the parsing of supplied input .
    if( FALSE == DoParseParam2( argc , argv , -1, SIZE_OF_ARRAY( cmdOptions ),
                                cmdOptions, 0 ) )
    { // Invalid synatx .
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    // If /? is specified .
    if( TRUE == *pbUsage )
    {
        if( argc > 2 )   // If some other option is specified with the /? .
        {
            ShowMessageEx( stderr, 3, FALSE, L"%1 %2%3",TAG_ERROR_DISPLAY,
                           ERROR_INVALID_SYNTAX, ERROR_DISPLAY_HELP ) ;
            return FALSE ;
        }
        else
        {   // No need of furthur checking , display Help .
            return TRUE ;
        }
    }

    // Empty path is not valid
    if( 0 == cmdOptions[ OI_PATH ].dwActuals )
    {
        StringCopy( lpszPathName, _T( "." ), MAX_STRING_LENGTH );
    }

/******************************************************************************
/*      If option not specified then add a default value if required .       **
/*****************************************************************************/

    // If UNC path is specified then display error and return.
    if( ( _T( '\\' ) == lpszPathName[ 0 ] ) &&
        ( _T( '\\' ) == lpszPathName[ 1 ] ))
    {
        // Check whether specified path is in \\machine\share format.
        lpCharTemp = FindAChar( ( lpszPathName + 2 ), _T('\\') );
        if( ( NULL == lpCharTemp ) ||
            ( ( _T( '\0' ) == lpCharTemp[ 1 ] ) ||
              ( _T( '\\' ) == lpCharTemp[ 1 ] ) ) )
        {
            SetLastError( ERROR_DIRECTORY );
            SaveLastError();
            DISPLAY_GET_REASON() ;
            return FALSE;
        }
        ShowMessageEx( stderr, 2, FALSE, L"%1 %2", TAG_ERROR_DISPLAY,
                       ERROR_UNC_PATH_NAME );
        return FALSE;
    }
    else
    {
        // Check does path name have more than '\' in the specified string.
        // Check does path name have any '/' in the specified string.
        if( ( NULL != FindSubString( lpszPathName, _T("...") ) ) ||
            ( NULL != FindSubString( lpszPathName, DOUBLE_SLASH ) ) ||
            ( NULL != FindSubString( lpszPathName, _T( "/" ) ) ) )
        {
            SetLastError( ERROR_DIRECTORY );
            SaveLastError();
            DISPLAY_GET_REASON() ;
            return FALSE;
        }
    }

    // Check Whether -m Is Specified At Command Prompt , If Not Initialize It To "*"
    if( 0 == cmdOptions[ OI_SEARCHMASK ].dwActuals )
    {
        StringCopy( lpszSearchMask , DEFAULT_SEARCH_MASK, MAX_STRING_LENGTH ) ;
        *pbSearchFilter = FALSE ;
    }

    // Check whether -c is specified at command prompt.
    // If not initialize it to "cmd /c echo @file".
    if( 0 == cmdOptions[ OI_COMMAND ].dwActuals )
    {
        StringCopy( lpszCommand , DEFAULT_COMMAND, MAX_STRING_LENGTH ) ;
    }
    else
    {
        // Replace Any Hex Value In String To An ASCII Character .
        if( FALSE == ReplaceHexToChar( lpszCommand ) )
        { // Error is displayed by the called function.
            return FALSE;
        }
        // All flags are converted to lower case.
        if( ( FALSE == FindAndReplaceString( lpszCommand, FILE_NAME ) ) ||
            ( FALSE == FindAndReplaceString( lpszCommand, FILE_WITHOUT_EXT ) ) ||
            ( FALSE == FindAndReplaceString( lpszCommand, EXTENSION ) ) ||
            ( FALSE == FindAndReplaceString( lpszCommand, FILE_PATH ) ) ||
            ( FALSE == FindAndReplaceString( lpszCommand, RELATIVE_PATH ) ) ||
            ( FALSE == FindAndReplaceString( lpszCommand, IS_DIRECTORY ) ) ||
            ( FALSE == FindAndReplaceString( lpszCommand, FILE_SIZE ) ) ||
            ( FALSE == FindAndReplaceString( lpszCommand, FILE_DATE ) ) ||
            ( FALSE == FindAndReplaceString( lpszCommand, FILE_TIME ) ) )
        { // Error is displayed by the called function.
            return FALSE;
        }
    }

    // Check whether -d is specified.
    if( 0 != cmdOptions[ OI_DATE ].dwActuals )
    {
        // First character must be '+' or '-' .
        if( ( PLUS != *lpszDate ) && ( MINUS != *lpszDate ) )
        {
            StringCopy( lpszTemp, lpszDate, MAX_STRING_LENGTH * 2 );
            StringCopy( lpszDate, L"+", MAX_STRING_LENGTH );
            StringConcat( lpszDate, lpszTemp, MAX_STRING_LENGTH );
        }
        // Now string length of 'lpszDate' should be more than 1.
        if( ( ( ( PLUS != *lpszDate ) && ( MINUS != *lpszDate ) ) ||
            ( 1 >= StringLength( lpszDate, 0 ) ) ) )
        {  // Invalid Date Specified .
            DISPLAY_INVALID_DATE();
            return FALSE ;
        }

        if( FALSE == CheckDateLocalized( lpszDate, NULL, NULL ) )
        { // Error is displayed by the called function.
            return FALSE ;
        }

        if( NULL != FindAChar( ( lpszDate + 1 ), _T('/') ) )
        { // 'lpszDate' is in '{+|-}MM/dd/yyyy' format.
            return TRUE;
        }
    }
    return TRUE ;
}


BOOL
DisplayMatchedFiles(
    IN LPWSTR lpszPathName ,
    IN LPWSTR lpszSearchMask ,
    IN LPWSTR lpszCommand ,
    IN Valid_File_Date vfdValidFileDate ,
    IN DWORD dwDateGreater ,
    IN BOOL bRecurse ,
    IN BOOL bSearchFilter
    )
/*++

Routine Description:

    Path to search for a file is retrived and passed to functions
    for furthur processing.

Arguments:

      [ IN ] lpszPathName   - Contains path of a directory from where files
                              matching a criteria are to be displayed .
      [ IN ] lpszSearchMask - Contains search mask with which a file is to be
                              searched .
      [ IN ] lpszCommand    - Contains command to execute .
      [ IN ] vfdValidFileDate - Contains a date files created before or after
                                this date are to be displayed .
      [ IN ] dwDateGreater  - File created before or after is decided by this
                              variable .
      [ IN ] bRecurse       - Whether to recurse into subdirectories .
      [ IN ] bSearchFilter  - Whether search filter was specified at command
                              prompt or not .

Return value:

    TRUE if succeded in displaying the the obtained files else FALSE .

--*/
{
    BOOL bHeader = FALSE ; // Check for whether first item is displayed.
    DWORD dwLength = 0;    // Length of reallocted string.
    BOOL bReturn = FALSE;  // Contains return value.

    // Loop until data strycture( stack) has no item left in it .
    while( NULL != g_pPathName )
    {
        // Pop a directory from stack which has to be traveresed .
        if( FALSE == Pop( ) )
        { // Control should come here only when linkedlist have no node to POP .
            FREE_MEMORY( g_lpszFileToSearch ) ; // Error message is already displayed .
            return FALSE ;
        }
        // Copy path name to variable which is the only source to get the current working directory .
        StringCopy( lpszPathName , g_lpszFileToSearch, MAX_STRING_LENGTH * 2 ) ;


        // Sets process directory to supplied directory .
        if( FALSE == SetCurrentDirectory( lpszPathName ) )
        {
            if( ERROR_ACCESS_DENIED == GetLastError())
            {
                ShowMessageEx( stderr, 6 , FALSE, L"%1 %2%3%4%5%6", TAG_ERROR_DISPLAY,
                               TAG_ERROR_ACCESS_DENIED, DOUBLE_QUOTES_TO_DISPLAY,
                               lpszPathName, DOUBLE_QUOTES_TO_DISPLAY, APPEND_AT_END ) ;
            }
            else
            {
                SaveLastError() ;
                DISPLAY_GET_REASON() ;
            }

            FREE_MEMORY( g_lpszFileToSearch ) ;
            continue ;
        }
        dwLength = StringLength( g_lpszFileToSearch, 0 ) +
                   StringLength( lpszSearchMask, 0 ) + EXTRA_MEM ;

        // Reallocate to copy search mask to original buffer .
        REALLOC_MEMORY( g_lpszFileToSearch , WCHAR , dwLength ) ;
        if( NULL == g_lpszFileToSearch )
        {
            DISPLAY_MEMORY_ALLOC_FAIL() ;
            return FALSE ;
        }

        StringConcat( g_lpszFileToSearch , DEFAULT_SEARCH_MASK, dwLength ) ;

        if( FALSE == DisplayFile( &bHeader , lpszPathName , dwDateGreater ,
                                  lpszCommand , vfdValidFileDate , &bReturn ,
                                  lpszSearchMask , bRecurse ) )
        {
            FREE_MEMORY( g_lpszFileToSearch ) ;
            return FALSE ;
        }
        // Free memory.
        FREE_MEMORY( g_lpszFileToSearch ) ;
    }

    // If nothing is displayed on to the stdout then display error stderr .
    if( FALSE == bHeader )
    {
        // If some search criteria is specified.
        if( NO_RESTRICTION_DATE != dwDateGreater )
        {
            ShowMessageEx( stderr, 2, FALSE, L"%1 %2", TAG_ERROR_DISPLAY,
                           ERROR_CRITERIA_MISMATCHED ) ;
        }
        else
        {   // Search criteria is 'search mask' only.
            if(  TRUE == bSearchFilter )
            {
                ShowMessageEx( stderr, 6, FALSE, L"%1 %2%3%4%5%6", TAG_ERROR_DISPLAY,
                       ERROR_NOFILE_FOUND, DOUBLE_QUOTES_TO_DISPLAY,
                       _X3(lpszSearchMask), DOUBLE_QUOTES_TO_DISPLAY,
                       ERROR_NOFILE_FOUND1 ) ;
            }
            else
            {
                // Displays output as invalid handle , changed to file not found .
                switch( GetLastError() )
                {
                case ERROR_NO_MORE_FILES:
                case ERROR_INVALID_HANDLE:
                    SetLastError( ERROR_FILE_NOT_FOUND ) ;
                    SaveLastError() ;
                    DISPLAY_GET_REASON() ;
                    break;
                default:
                    SaveLastError() ;
                    DISPLAY_GET_REASON() ;
                }
            }
        }
        bReturn =  FALSE ;
    }

    FREE_MEMORY( g_lpszFileToSearch ) ;
    return bReturn ;
}


BOOL
DisplayFile(
    IN OUT BOOL *pbHeader ,
    IN     LPWSTR lpszPathName ,
    IN     DWORD dwDateGreater ,
    IN     LPWSTR lpszCommand ,
    IN     Valid_File_Date vfdValidFileDate ,
    IN OUT BOOL *pbReturn ,
    IN     LPWSTR lpszSearchMask ,
    IN     BOOL bRecurse
    )
/*++

Routine Description:

    Find subdirectories and files present in a directory and is passed to
    functions for furthur processing, such as , file was created between
    specified date or not , and replace the flags present in command
    with appropriate values etc.

Arguments:

    [ IN OUT ]  *pbHeader        - Contains value to display errormessage if
                                   nothing is displayed .
    [ IN ]      lpszPathName     - Contains path of a directory from where files
                                   matching a criteria are to be displayed .
    [ IN ]      dwDateGreater    - File created before or after is decided by this
                                   variable .
    [ IN ]      lpszCommand      - Contains command to execute .
    [ IN ]      vfdValidFileDate - Contains a date files created before or after
                                   this date are to be displayed .
    [ IN OUT ]  *pbReturn        - Contains exit value .
    [ IN ]      lpszSearchMask   - Contains search mask with which a file is to be
                                   searched .
    [ IN ]      bRecurse         - Contains TRUE when child directories are also to
                                   be searched else FALSE.


Return value:

    TRUE if succeded in executing the command and finding a file falling in
    range of specified date else FALSE .

--*/
{
    HANDLE hFindFile = NULL ;      // Handle to a file .
    WIN32_FIND_DATA  wfdFindFile ; // Structure keeping information about the found file .
    DWORD dwLength = 0;

    if( ( NULL == pbHeader ) ||
        ( NULL == pbReturn ) ||
        ( NULL == lpszPathName ) ||
        ( NULL == lpszSearchMask ) ||
        ( NULL == lpszCommand ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    SecureZeroMemory( &wfdFindFile , sizeof( WIN32_FIND_DATA ) ) ;
    // From here onwards directory and file information should be displayed .
    if( INVALID_HANDLE_VALUE !=
        ( hFindFile = FindFirstFile( g_lpszFileToSearch , &wfdFindFile ) ) )
    {
        do  // Loop until files are present in the directory to display .
        {
            // Check whether files are "." or "..".
            if( ( 0 == StringCompare( wfdFindFile.cFileName , SINGLE_DOT, TRUE, 0 ) ) ||
                ( 0 == StringCompare( wfdFindFile.cFileName , DOUBLE_DOT, TRUE, 0 ) ) )
            {
                continue ;
            }

            // Check again whether obtained handle points to a directory or file .
            // If directory then check whether files in subdir are to be displayed .
            if( ( TRUE == bRecurse ) &&
                ( 0 != ( wfdFindFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ) )
            {
                dwLength = StringLength( lpszPathName, 0 ) +
                           StringLength( wfdFindFile.cFileName, 0 ) + EXTRA_MEM ;
                // Reallocate memory .
                REALLOC_MEMORY( g_lpszFileToSearch , WCHAR , dwLength ) ;
                if( NULL == g_lpszFileToSearch  )
                { // Reallocation failed .
                    DISPLAY_MEMORY_ALLOC_FAIL() ;
                    CLOSE_FILE_HANDLE( hFindFile ) ;
                    return FALSE ;
                }
                // Copy Path, Concat FileName, Concat '\' as it is required .
                StringCopy( g_lpszFileToSearch , lpszPathName, dwLength ) ;
                StringConcat( g_lpszFileToSearch , wfdFindFile.cFileName, dwLength ) ;
                StringConcat( g_lpszFileToSearch , SINGLE_SLASH, dwLength ) ;
                // Copy current path name and store it .
                if( FALSE == Push( g_lpszFileToSearch ) )
                {   // Control comes here when memory allocation fails .
                    CLOSE_FILE_HANDLE( hFindFile ) ;
                    return FALSE ;
                } // Push Is Over .
            }

            // Check out whether the file matches pattern specified and if yes then
            // file obtained is created on a valid date as specified by user.
            if( ( TRUE == PatternMatch( lpszSearchMask, wfdFindFile.cFileName ) ) &&
                ( ( NO_RESTRICTION_DATE == dwDateGreater ) ||
                  ( TRUE == FileDateValid( dwDateGreater , vfdValidFileDate ,
                                           wfdFindFile.ftLastWriteTime ) ) ) )
            {
                // Execute a command specified at command prompt .
                // Reallocate memory .
                dwLength = StringLength( lpszCommand, 0 ) + EXTRA_MEM;
                REALLOC_MEMORY( g_lpszFileToSearch , WCHAR , dwLength ) ;
                if( NULL == g_lpszFileToSearch )
                { // Reallocation failed .
                    DISPLAY_MEMORY_ALLOC_FAIL() ;
                    CLOSE_FILE_HANDLE( hFindFile ) ;
                    return FALSE ;
                }
                // Contains original command to execute .
                StringCopy( g_lpszFileToSearch , lpszCommand, dwLength ) ;
                // Value can be anything , Filename , Extension name , PathName etc.
                if( TRUE == ReplaceTokensWithValidValue( lpszPathName ,
                                                         wfdFindFile ) )
                { // Tokens are replaced , know execute this command .
                    if( FALSE == *pbHeader )
                    {
                        ShowMessage( stdout , _T( "\n" ) ) ;
                    }
                    if( TRUE == ExecuteCommand( ) )
                    {
                        *pbReturn = TRUE ;
                    }
                    // Make header TRUE because it tell us :
                    // a) No need to display header .
                    // b) If FindFirstFile() returns invalidHandle then ,
                    //    display error if Handle == FALSE .
                    *pbHeader = TRUE ;
                }
                else
                {  // Failed to replace tokens , might be memory insuffcient .
                    *pbReturn = FALSE ;
                    CLOSE_FILE_HANDLE( hFindFile ) ;
                    return FALSE ;
                }
            }
            // Continue till no files are present to display.
        } while( 0 != FindNextFile( hFindFile , &wfdFindFile ) ) ;
    }

    CLOSE_FILE_HANDLE( hFindFile ) ;    // Close open find file handle .
    g_pFollowPathName = NULL ;
    return TRUE ;
}


BOOL
Push(
    IN LPWSTR szPathName
    )
/*++

Routine Description:

    Store the path of obtained subdirectory .

Arguments:

      [ IN ] szPathName - Contains path of a subdirectory .

Return value:

    TRUE if succedded in storing  a path else FALSE if failed to get memory.

--*/
{
    // Get a temporary variable .
    PStore_Path_Name    pAddPathName = NULL;
    DWORD dwLength = 0;

    if( NULL == szPathName )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    // Assign memory To Temporary Variable .
    ASSIGN_MEMORY( pAddPathName , struct __STORE_PATH_NAME , 1 ) ;
    if( NULL == pAddPathName ) // Check memory allocation is successful.
    { // Memory allocation is unsuccessful .
        DISPLAY_MEMORY_ALLOC_FAIL() ;
        return FALSE ;
    }

    dwLength = StringLength( szPathName, 0 ) + EXTRA_MEM ;
    // Assign memory to string variable which is going to store full path name
    // of a valid directory .
    ASSIGN_MEMORY(  pAddPathName->pszDirName , WCHAR , dwLength ) ;
    if( NULL == pAddPathName->pszDirName ) // Check memory allocation is successful.
    { // Memory allocation was unsuccessful .
        DISPLAY_MEMORY_ALLOC_FAIL() ;
        FREE_MEMORY( pAddPathName ) ;
        return FALSE ;
    }

    // Copy path name to memory allocated string variable .
    StringCopy( ( LPWSTR ) pAddPathName->pszDirName , szPathName, dwLength ) ;
    pAddPathName->NextNode = NULL ;  // Assign null , had only one subdirectory stored.

    // Check global variable is NULL or not .
    if( NULL == g_pPathName )
    {   // Add memory to store path of subdirectory .
        g_pPathName = pAddPathName ;
        g_pFollowPathName = g_pPathName ;
    }
    else
    {
        if( NULL == g_pFollowPathName )
        {   // Store first obtained subdirectory .
            pAddPathName->NextNode = g_pPathName ;
            g_pPathName = pAddPathName ;
            g_pFollowPathName = g_pPathName ;
        }
        else
        {
            // Stroe subdirectory in the middle
            pAddPathName->NextNode = g_pFollowPathName->NextNode ;
            g_pFollowPathName->NextNode =  pAddPathName ;
            g_pFollowPathName = pAddPathName ;
        }
    }
    return TRUE ;
}


BOOL
Pop(
    void
    )
/*++

Routine Description:

    Get a subdirectory which has to be searched for a file matching a user
    specified criteria .

Arguments:

Return value:

    TRUE if successful in getting a path else FALSE if failed to get memory or
    if no path is stored .

--*/
{
    // Linked list has more than 1 node .
    PStore_Path_Name    pDelPathName = g_pPathName ;
    DWORD dwLength = 0;

    // Check whether linked list is having any nodes .
    if( NULL == g_pPathName )
    { // No nodes present , return False ,
      // Should not happen ever . Control should not come here .
        DISPLAY_MEMORY_ALLOC_FAIL() ;
        return FALSE ;
    }

    dwLength = StringLength( g_pPathName->pszDirName, 0 ) + EXTRA_MEM;
    // Realloc memory and give buffer space in which path name can fix .
    ASSIGN_MEMORY( g_lpszFileToSearch , WCHAR , dwLength ) ;
    if( NULL == g_lpszFileToSearch )
    { // Memory reallocation failed .
        DISPLAY_MEMORY_ALLOC_FAIL() ;
        return FALSE ;
    }

    g_pPathName = pDelPathName->NextNode ;
    // Memory allocation successful. Copy pathname to the buffer.
    StringCopy( g_lpszFileToSearch, pDelPathName->pszDirName, dwLength ) ;
    // Free node.
    FREE_MEMORY( pDelPathName->pszDirName ) ;
    FREE_MEMORY( pDelPathName ) ;
    return TRUE ;
}


BOOL
DisplayUsage(
    IN DWORD dwStartUsage ,
    IN DWORD dwEndUsage
    )
/*++

Routine Description:

    This function displays help on this tool .

Arguments:

      [ IN ] dwStartUsage - Start Resource String ID  in Resiurce file for help usage .
      [ IN ] dwEndUsage   - End Resource String ID  in Resiurce file for help usage .

Return value:

    If success returns TRUE else FALSE .

--*/
{
    DWORD dwLoop = 0 ;
    WCHAR wszDisplayStr[ 256 ]; // Contains string to display.
    WCHAR wszDateFormat[ 20 ];  // Contains date format w.r.t locale.
    WCHAR wszString[ 5 ];       // Contains date seperator w.r.t locale.
    WCHAR wszDateDisplay[ 50 ]; // Contains date w.r.t locale for examples in help.
    WCHAR wszStaticDateDisplay[ 50 ]; // Contains date w.r.t locale for examples in help.
    SYSTEMTIME sysTimeAndDate ;
    DWORD dwDateFormat = 0 ;

    SecureZeroMemory( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ) * sizeof( WCHAR ) );
    SecureZeroMemory( wszDateFormat, SIZE_OF_ARRAY( wszDateFormat ) * sizeof( WCHAR ) );
    SecureZeroMemory( wszString, SIZE_OF_ARRAY( wszString ) * sizeof( WCHAR ) );
    SecureZeroMemory( wszDateDisplay, SIZE_OF_ARRAY( wszDateDisplay ) * sizeof( WCHAR ) );
    SecureZeroMemory( wszStaticDateDisplay, SIZE_OF_ARRAY( wszStaticDateDisplay ) * sizeof( WCHAR ) );
    SecureZeroMemory( &sysTimeAndDate, sizeof( SYSTEMTIME ) );

    if( FALSE == CheckDateLocalized( NULL, &dwDateFormat, wszString ) )
    {   // Error is displayed by the called function.
        return FALSE;
    }

    // 'void' is returned so need to check return value.
    GetLocalTime( &sysTimeAndDate );

    // Fill up all the strings with required values.
    switch( dwDateFormat )
    {
        // 'MM/yyyy/dd' format.
        case 1:
            StringCchPrintfW( wszDateFormat, SIZE_OF_ARRAY( wszDateFormat ),
                              FORMAT_1, wszString, wszString );
            StringCchPrintfW( wszStaticDateDisplay, SIZE_OF_ARRAY( wszStaticDateDisplay ),
                              L"01%s2001%s01", wszString, wszString );
            StringCchPrintfW( wszDateDisplay,  SIZE_OF_ARRAY( wszDateDisplay ),
                              DATE_FORMAT, sysTimeAndDate.wMonth, wszString,
                              sysTimeAndDate.wYear, wszString,
                              sysTimeAndDate.wDay );
            break;

        // 'dd/MM/yyyy' format.
        case 2:
            StringCchPrintfW( wszDateFormat, SIZE_OF_ARRAY( wszDateFormat ),
                              FORMAT_2, wszString, wszString );
            StringCchPrintfW( wszStaticDateDisplay, SIZE_OF_ARRAY( wszStaticDateDisplay ),
                              L"01%s01%s2001", wszString, wszString );
            StringCchPrintfW( wszDateDisplay,  SIZE_OF_ARRAY( wszDateDisplay ),
                              DATE_FORMAT, sysTimeAndDate.wDay, wszString,
                              sysTimeAndDate.wMonth, wszString,
                              sysTimeAndDate.wYear  );
            break;

        // 'dd/yyyy/MM' format.
        case 3:
            StringCchPrintfW( wszDateFormat, SIZE_OF_ARRAY( wszDateFormat ),
                              FORMAT_3, wszString, wszString );
            StringCchPrintfW( wszStaticDateDisplay, SIZE_OF_ARRAY( wszStaticDateDisplay ),
                              L"01%s2001%s01", wszString, wszString );
            StringCchPrintfW( wszDateDisplay,  SIZE_OF_ARRAY( wszDateDisplay ),
                              DATE_FORMAT, sysTimeAndDate.wDay, wszString,
                              sysTimeAndDate.wYear, wszString,
                              sysTimeAndDate.wMonth );
            break;

        // 'yyyy/dd/MM' format.
        case 4:
            StringCchPrintfW( wszDateFormat, SIZE_OF_ARRAY( wszDateFormat ),
                              FORMAT_4, wszString, wszString );
            StringCchPrintfW( wszStaticDateDisplay, SIZE_OF_ARRAY( wszStaticDateDisplay ),
                              L"2001%s01%s01", wszString, wszString );
            StringCchPrintfW( wszDateDisplay,  SIZE_OF_ARRAY( wszDateDisplay ),
                              DATE_FORMAT, sysTimeAndDate.wYear, wszString,
                              sysTimeAndDate.wDay, wszString,
                              sysTimeAndDate.wMonth );
            break;

        // 'yyyy/MM/dd' format.
        case 5:
            StringCchPrintfW( wszDateFormat, SIZE_OF_ARRAY( wszDateFormat ),
                              FORMAT_5, wszString, wszString );
            StringCchPrintfW( wszStaticDateDisplay, SIZE_OF_ARRAY( wszStaticDateDisplay ),
                              L"2001%s01%s01", wszString, wszString );
            StringCchPrintfW( wszDateDisplay,  SIZE_OF_ARRAY( wszDateDisplay ),
                              DATE_FORMAT, sysTimeAndDate.wYear, wszString,
                              sysTimeAndDate.wMonth, wszString,
                              sysTimeAndDate.wDay );
            break;

        // 'MM/dd/yyyy' format.
        default:
            StringCchPrintfW( wszDateFormat, SIZE_OF_ARRAY( wszDateFormat ),
                              FORMAT_0, wszString, wszString );
            StringCchPrintfW( wszStaticDateDisplay, SIZE_OF_ARRAY( wszStaticDateDisplay ),
                              L"01%s01%s2001", wszString, wszString );
            StringCchPrintfW( wszDateDisplay,  SIZE_OF_ARRAY( wszDateDisplay ),
                              DATE_FORMAT, sysTimeAndDate.wMonth, wszString,
                              sysTimeAndDate.wDay, wszString,
                              sysTimeAndDate.wYear );
            break;
    }

    // Keep on displaying the help.
    for( dwLoop = dwStartUsage ; dwLoop <= dwEndUsage ; dwLoop++ )
    {
        switch( dwLoop )
        {
        case IDS_HELP_SYNTAX2 :
            SecureZeroMemory( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ) );
            StringCchPrintfW( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ),
                              GetResString( dwLoop ), wszDateFormat );
            ShowMessage( stdout , _X(wszDisplayStr) ) ;
            break;
        case IDS_HELP_D1:
        case IDS_HELP_D2:
        case IDS_HELP_D3:
        case IDS_HELP_D4:
        case IDS_HELP_D5:
        case IDS_HELP_D6:
        case IDS_HELP_D7:
        case IDS_HELP_D8:
        case IDS_HELP_D9:
        case IDS_HELP_D10:
            SecureZeroMemory( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ) );
            StringCchPrintfW( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ),
                              GetResString( dwLoop ), wszDateFormat );
            ShowMessage( stdout , _X(wszDisplayStr) ) ;
            break;
        case IDS_HELP_E8:
            SecureZeroMemory( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ) );
            StringCchPrintfW( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ),
                              GetResString( dwLoop ),
                              wszStaticDateDisplay );
            ShowMessage( stdout , _X(wszDisplayStr) ) ;
            break;
        case IDS_HELP_E10:
            SecureZeroMemory( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ) );
            StringCchPrintfW( wszDisplayStr, SIZE_OF_ARRAY( wszDisplayStr ),
                              GetResString( dwLoop ), wszDateDisplay );
            ShowMessage( stdout , _X(wszDisplayStr) ) ;
            break;
        default:
            ShowMessage( stdout , GetResString( dwLoop ) ) ;
        }
    }

    // Successful.
    return TRUE;
}


BOOL
FindAndReplaceString(
    IN OUT LPWSTR lpszString,
    IN LPWSTR lpszFlag
    )
/*++

Routine Description:

    This function finds flags ( Eg: @file, @path etc.) given by user in any case
    and converts them to lowercase.

Arguments:

      [ IN ] lpszString - String in which to replace flags to lowercase .
      [ IN ] lpszFlag   - Flag to be replaced .

Return value:

    Returns FALSE if memory allocation fails else returns TRUE .

--*/
{
    DWORD dwLength = 0 ;
    DWORD dwIndex = 0 ;
    LPWSTR lpszTemp = NULL ;
    LPWSTR lpszDup = NULL ;

    // Keep record of position or index from where to start next search.
    #ifdef _WIN64
        __int64 dwLocation = 0 ;
    #else
        DWORD dwLocation = 0 ;
    #endif

    if( ( NULL == lpszString ) ||
        ( NULL == lpszFlag ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    // Get a duplicate string.
    lpszDup = StrDup( lpszString );

    if( NULL == lpszDup )
    {
        DISPLAY_MEMORY_ALLOC_FAIL() ;
        return FALSE ;
    }
    // Convert duplicate string to lowercase.
    CharLower( lpszDup );

    lpszTemp = lpszDup ;
    // Get Length of duplicate string.
    dwLength = StringLength( lpszFlag, 0 ) ;

    // Loop until all the strings "FLAG" are note replaced.
    // Here string replaced is of original string, duplicate string
    // used to get the index or location of flag.
    while( NULL != ( lpszTemp = FindSubString( lpszTemp, lpszFlag ) ) )
    {
        // Get the index from where the "FLAG" is starting.
        dwLocation = lpszTemp - lpszDup ;
        // Add length of the flag to the string pointer to get ready
        // for next iteration.
        lpszTemp += dwLength ;
        // Check is the character to be replaced is in uppercase.
        for( dwIndex = 1 ; dwIndex < dwLength ; dwIndex++ )
        {
            // Character to be replaced is in uppercase.
            if( ( 65 <= (DWORD)*( lpszString + dwLocation + dwIndex ) ) &&
                ( 90 >= (DWORD)*( lpszString + dwLocation + dwIndex ) ) )
            {
                // Add 32 to convert uppercase letter to lowercase.
                *( lpszString + dwLocation + dwIndex ) += 32 ;
            }
        }
    }
    LocalFree( lpszDup );
    return TRUE ;
}


BOOL
InitStartPath(
    LPWSTR lpszPathName,
    LPWSTR lpszCommand
    )
/*++

Routine Description:

    This function copies start path to global variable.

Arguments:

      [ IN ] lpszPathName - Current process path.
      [ IN ] lpszCommand  - Command to execute.

Return value:

    Returns FALSE if memory allocation fails else returns TRUE .

--*/
{
    DWORD dwLength = 0;

    if( ( NULL == lpszPathName ) ||
        ( NULL == lpszCommand ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    // If not specified then get current directory path.
    if( 0 == GetCurrentDirectory( ( MAX_STRING_LENGTH * 2 ) , lpszPathName ) )
    {
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }
    if( _T( '\\' ) != lpszPathName[ StringLength( lpszPathName, 0 ) - 1 ]  )
    {   // String should contain a '\' in end. EX: "c:\windows\"
        StringConcat( lpszPathName, _T( "\\" ), MAX_STRING_LENGTH * 2 );
    }

    // Set only if '@relpath' is specified in the command to execute.
    if( NULL != FindSubString( lpszCommand , RELATIVE_PATH ) )
    {
        dwLength = StringLength( lpszPathName, 0 ) + EXTRA_MEM;
        // Allocate memory to global variable .
        ASSIGN_MEMORY( g_lpszStartPath , WCHAR , dwLength ) ;
        // Check whether memory allocation was successfully .
        if( NULL == g_lpszStartPath )
        {   // Memory Allocation Failed .
            DISPLAY_MEMORY_ALLOC_FAIL() ;
            return FALSE ;
        }

        // Copied path to global variable .
        StringCopy( g_lpszStartPath , lpszPathName, dwLength ) ;
    }
    return TRUE;
}


BOOL
CheckDateLocalized(
    LPWSTR lpwszDate,
    DWORD* pdwDateFormat,
    LPWSTR lpszDateSep
    )
/*++

Routine Description:

    This function converts a date in accordance with locale to mm/dd/yyyy format.
    If date is in {+|-}dd format then some validation is also done.

Arguments:

      [ IN ] lpwszDate      - Contains date.
      [ OUT ] pdwDateFormat - Contains date format being used by current locale.
      [ OUT ] lpszDateSep   - Contains seperator.

Return value:

    Return FALSE if date does not have the separator as locale settings.
    Return TRUE if date is converted to MM/dd/yyyy format successfully.

--*/
{
    WCHAR wszString[ MAX_STRING_LENGTH ];
    LCID lcidCurrentUserLocale = 0 ; // Stores current user locale.
    BOOL bLocaleChanged = TRUE;
    LPWSTR lpTemp = NULL;
    LPWSTR lpTemp1 = NULL;
    DWORD dwInteger = 0 ;

    if((( NULL == lpwszDate ) && ( NULL == pdwDateFormat ) && ( NULL == lpszDateSep )) ||
       (( NULL == lpwszDate ) && ( NULL != pdwDateFormat ) && ( NULL == lpszDateSep )) ||
       (( NULL == lpwszDate ) && ( NULL == pdwDateFormat ) && ( NULL != lpszDateSep )))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    SecureZeroMemory( wszString, MAX_STRING_LENGTH * sizeof( WCHAR ) );

    // verify whether console supports the current locale 100% or not
    lcidCurrentUserLocale = GetSupportedUserLocale( &bLocaleChanged ) ;

    // Get date seperator.
    dwInteger = GetLocaleInfo( lcidCurrentUserLocale, LOCALE_SDATE, wszString,
                               SIZE_OF_ARRAY( wszString ));

    if( 0 == dwInteger )
    {
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    // Date seperator is obtained.
    if( NULL != lpszDateSep )
    {   // Get date seperator.
        // Date seperator
        StringCopy( lpszDateSep, wszString, 5 );
    }
    else
    {
        // Date seperator is known.
        // Check whether the string contains any
        lpTemp = FindSubString( ( lpwszDate + 1 ), wszString );
        // Replace locale date seperator by '/'.
        if( NULL == lpTemp )
        {
            // Check whether only number is present or some string is present.
            if( FALSE == IsNumeric( lpwszDate, 10, TRUE ) )
            {
                DISPLAY_INVALID_DATE();
                return FALSE ;
            }
            return TRUE;
        }
        else
        {
            *lpTemp = _T( '/' );
            if( 1 < StringLength( wszString, 0 ) )
            {
               StringCopy( ( lpTemp + 1 ), ( lpTemp + StringLength( wszString, 0 ) ),
                           1 + StringLength( ( lpTemp + StringLength( wszString, 0 ) ),
                           0 ) );
            }

            lpTemp1 = FindSubString( lpTemp, wszString );
            if( NULL == lpTemp1 )
            {
                DISPLAY_INVALID_DATE();
                return FALSE ;
            }
            else
            {
                *lpTemp1 = _T( '/' );
                if( 1 < StringLength( wszString, 0 ) )
                {
                    StringCopy( ( lpTemp1 + 1 ), ( lpTemp1 + StringLength( wszString, 0 ) ),
                                1 + StringLength( ( lpTemp1 + StringLength( wszString, 0 ) ),
                                0 ) );
                }
            }
        }
    }

    // Get type of date format. 'wszString' should not contain characters more than 80.
    dwInteger = GetLocaleInfo( lcidCurrentUserLocale, LOCALE_IDATE, wszString,
                               SIZE_OF_ARRAY( wszString ));

    if( 0 == dwInteger )
    {
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }
    // Jump to type of date format.
    switch( wszString[ 0 ] )
    {
        case _T( '0' ):
            dwInteger = GetLocaleInfo( lcidCurrentUserLocale, LOCALE_SSHORTDATE,
                                       wszString, SIZE_OF_ARRAY( wszString ));
            if( 0 == dwInteger )
            {
                SaveLastError() ;
                DISPLAY_GET_REASON() ;
                return FALSE ;
            }
            lpTemp = StrPBrkW( wszString, L"dy" );

            if( NULL == lpTemp )
            {
                DISPLAY_INVALID_DATE();
                return FALSE ;
            }

            if( _T( 'y' ) == lpTemp[ 0 ] )
            {
                if( NULL != pdwDateFormat )
                {
                    *pdwDateFormat = 1;
                    return TRUE;
                }

                // Will work only for MM/yyyy/dd.
                StringCopy( wszString, lpwszDate, MAX_STRING_LENGTH );
                // Get dd from MM/yyyy/dd.
                lpTemp = StrRChrW( lpwszDate, NULL, L'/' );
                lpTemp1 = FindAChar( lpwszDate, _T( '/' ) );
                if( ( NULL == lpTemp ) || ( NULL == lpTemp1 ) )
                {
                    DISPLAY_INVALID_DATE();
                    return FALSE ;
                }

                StringCopy( ( lpTemp1 + 1 ),( lpTemp + 1 ),
                            1 + StringLength( ( lpTemp1 + 1 ), 0 ) );

                StringConcat( lpwszDate, _T( "/" ), MAX_STRING_LENGTH );

                // Now date string is MM/dd/
                lpTemp = StrRChrW( wszString, NULL, _T( '/' ) );
                if( NULL == lpTemp )
                {
                    DISPLAY_INVALID_DATE();
                    return FALSE ;
                }
                *lpTemp = _T( '\0' );
                // Copy 'yyyy'.
                dwInteger = StringLength( wszString, 0 );
                StringConcat( lpwszDate, ( wszString + dwInteger - 4 ),
                              MAX_STRING_LENGTH );
            }
            else
            {
                if( NULL != pdwDateFormat )
                {
                    *pdwDateFormat = 0;
                    return TRUE;
                }
            }
            return TRUE;

        case _T( '1' ):
            dwInteger = GetLocaleInfo( lcidCurrentUserLocale, LOCALE_SSHORTDATE,
                                       wszString, SIZE_OF_ARRAY( wszString ));

            if( 0 == dwInteger )
            {
                SaveLastError() ;
                DISPLAY_GET_REASON() ;
                return FALSE ;
            }
            lpTemp = StrPBrkW( wszString, L"My" );

            if( NULL == lpTemp )
            {
                DISPLAY_INVALID_DATE();
                return FALSE ;
            }

            if( _T( 'M' ) == lpTemp[ 0 ] )
            {
                if( NULL != pdwDateFormat )
                {
                    *pdwDateFormat = 2;
                    return TRUE;
                }

                // Will work only for dd/MM/yyyy
                StringCopy( wszString, lpwszDate, MAX_STRING_LENGTH );
                // Get
                // Pointing at "yyyy"
                lpTemp = StrRChrW( wszString, NULL, _T( '/' ) );
                // Pointing at "MM"
                lpTemp1 = FindAChar( wszString, _T( '/' ) );
                if( ( NULL == lpTemp ) || ( NULL == lpTemp1 ) )
                {
                    DISPLAY_INVALID_DATE();
                    return FALSE ;
                }
                StringCopy( ( lpwszDate + 1 ), ( lpTemp1 + 1 ), MAX_STRING_LENGTH - 1 );

                StringCopy( lpTemp1, lpTemp,
                            MAX_STRING_LENGTH - (DWORD)(DWORD_PTR)(lpTemp1 - wszString));
                lpTemp = FindAChar( lpwszDate, _T( '/' ) );
                if( NULL == lpTemp )
                {
                    DISPLAY_INVALID_DATE();
                    return FALSE ;
                }

                StringCopy( ( lpTemp + 1 ), ( wszString + 1 ),
                            MAX_STRING_LENGTH - (DWORD)(DWORD_PTR)(lpTemp - lpwszDate));
            }
            else
            {
                if( NULL != pdwDateFormat )
                {
                   *pdwDateFormat = 3;
                    return TRUE;
                }

                // Will work only for dd/yyyy/MM
                StringCopy( wszString, lpwszDate, MAX_STRING_LENGTH );
                // Get MM.
                lpTemp = StrRChr( wszString, NULL, _T( '/' ) );
                if( NULL == lpTemp )
                {
                    DISPLAY_INVALID_DATE();
                    return FALSE ;
                }
                StringCopy( ( lpwszDate + 1 ), ( lpTemp + 1 ), MAX_STRING_LENGTH - 1 );
                *lpTemp = _T( '\0' );
                // Date string is MM.
                StringConcat( lpwszDate , _T( "/" ), MAX_STRING_LENGTH );
                StringConcat( lpwszDate, ( wszString + 1 ), MAX_STRING_LENGTH );
            }
            return TRUE;

        case _T( '2' ):
            dwInteger = GetLocaleInfo( lcidCurrentUserLocale, LOCALE_SSHORTDATE,
                                       wszString, SIZE_OF_ARRAY( wszString ));

            if( 0 == dwInteger )
            {
                SaveLastError() ;
                DISPLAY_GET_REASON() ;
                return FALSE ;
            }

            lpTemp = StrPBrkW( wszString, L"Md" );

            if( NULL == lpTemp )
            {
                DISPLAY_INVALID_DATE();
                return FALSE ;
            }
            // Make modification to the date string.
            if( _T( 'd' ) == lpTemp[ 0 ] )
            {
                if( NULL != pdwDateFormat )
                {
                    *pdwDateFormat = 4;
                    return TRUE;
                }

                // Will work only for yyyy/dd/MM.
                StringCopy( wszString, lpwszDate, MAX_STRING_LENGTH );
                // Get MM
                lpTemp = StrRChr( wszString, NULL, _T( '/' ) );
                if( NULL == lpTemp )
                {
                    DISPLAY_INVALID_DATE();
                    return FALSE ;
                }
                StringCopy( ( lpwszDate + 1 ), ( lpTemp + 1 ), MAX_STRING_LENGTH -1 );
                StringConcat( ( lpwszDate + 1 ), _T( "/" ), MAX_STRING_LENGTH );
                *lpTemp = _T( '\0' ) ;
                // Get dd, date string contains "yyyy/dd" only.
                lpTemp = StrRChr( wszString, NULL, _T( '/' ) );
                if( NULL == lpTemp )
                {
                    DISPLAY_INVALID_DATE();
                    return FALSE ;
                }
                StringConcat( lpwszDate, ( lpTemp + 1 ), MAX_STRING_LENGTH );
                StringConcat( ( lpwszDate + 1 ), _T( "/" ), MAX_STRING_LENGTH );
                *lpTemp = _T( '\0' ) ;
                // Get
                StringConcat( lpwszDate, ( wszString + 1 ), MAX_STRING_LENGTH );
            }
            else
            {
                if( NULL != pdwDateFormat )
                {
                    *pdwDateFormat = 5;
                    return TRUE;
                }

                // Will work only for yyyy/MM/dd.
                StringCopy( wszString, lpwszDate, MAX_STRING_LENGTH );
                StringCopy( lpwszDate + 1, ( wszString + 6 ),MAX_STRING_LENGTH - 1 );
                wszString[ 5 ] = _T( '\0' );
                StringConcat( lpwszDate, _T( "/" ), MAX_STRING_LENGTH );
                StringConcat( lpwszDate, ( wszString + 1 ), MAX_STRING_LENGTH );
            }
            return TRUE;

        default:
            DISPLAY_INVALID_DATE();
            return FALSE ;
    }
}



BOOL
PatternMatch(
      IN LPWSTR szPat,
      IN LPWSTR szFile
      )
/*++
        Routine Description     :   This routine is used to check whether file is mathced against
                                    pattern or not.

        [ IN ]  szPat           :   A string variable pattern against which the file name to be matched.

        [ IN ]  szFile          :   A pattern string which specifies the file name to be matched.


        Return Value        :   BOOL
            Returns successfully if function is success other wise return failure.
--*/

{
    if( ( NULL == szPat ) ||
        ( NULL == szFile ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError() ;
        DISPLAY_GET_REASON() ;
        return FALSE ;
    }

    // Apply recursive pattern match.
    switch( *szPat )
    {
        case '\0':
            return ( *szFile == L'\0' );

        case '?':
            return ( ( *szFile != L'\0' ) && PatternMatch( szPat + 1, szFile + 1 ) );

        case '*':
            do
            {
                if( TRUE == PatternMatch( szPat + 1, szFile ) )
                {
                    return TRUE;
                }
            } while( *szFile++ );
            return FALSE;

        default:
            return ( ( toupper( *szFile ) == toupper( *szPat ) ) &&
                     PatternMatch( szPat + 1, szFile + 1 ) );
    }
}


LPWSTR
FindAChar(
      IN LPWSTR szString,
      IN WCHAR  wCharToFind
      )
/*++
        Routine Description     :   This routine is used to find a case sensitive
                                    character in a string.

        [ IN ]  szString        :   String in which to search for a character.

        [ IN ]  wCharTofind     :   Char to search for.


        Return Value            :   LPWSTR
            If found a character then memory location of that character will
            be returned else NULL is returned.
--*/
{
    if( NULL == szString )
    {
        return NULL;
    }

    return ( StrChrW( szString, wCharToFind ) );
}


LPWSTR
FindSubString(
      IN LPWSTR szString,
      IN LPWSTR szSubString
      )
/*++
        Routine Description     :  This routine is used to find a case sensitive
                                   substring in a string.

        [ IN ]  szString        :   String in which to search for a substring.

        [ IN ]  szSubString     :   SubString to search for.


        Return Value            :   LPWSTR
            If found a character then memory location of that character will
            be returned else NULL is returned.
--*/
{
    if( ( NULL == szString ) ||
        ( NULL == szSubString ) )
    {
        return NULL;
    }

    return ( StrStrW( szString, szSubString ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\global.h ===
/*++

  Copyright (c) Microsoft Corporation

  Module Name:

      Global.h

  Abstract:

      Contains function prototypes , structures and macros.

  Author:

      V Vijaya Bhaskar

  Revision History:

      14-Jun-2001 : Created by V Vijaya Bhaskar ( Wipro Technologies ).

--*/

#ifndef     __GLOBAL__H
#define     __GLOBAL__H

#pragma once

// Include .h files .
#include "pch.h"
#include "resource.h"

#define     EXTRA_MEM               10

#define   TAG_ERROR_DISPLAY             GetResString( IDS_TAG_ERROR_DISPLAY )
#define   TAG_DISPLAY_WARNING           GetResString( IDS_TAG_DISPLAY_WARNING )
#define   ERROR_DISPLAY_HELP            GetResString( IDS_ERROR_DISPLAY_HELP )
#define   DOUBLE_QUOTES_TO_DISPLAY      GetResString( IDS_DOUBLE_QUOTES )

#define   DISPLAY_GET_REASON()          ShowMessageEx( stderr, 2, FALSE, L"%1 %2", \
                                                       TAG_ERROR_DISPLAY, GetReason() )

#define   DISPLAY_MEMORY_ALLOC_FAIL()   SetLastError( (DWORD) E_OUTOFMEMORY ); \
                                        SaveLastError(); \
                                        DISPLAY_GET_REASON(); \
                                        1


#define   DISPLAY_INVALID_DATE()        ShowMessageEx( stderr, 3, FALSE, L"%1 %2%3", \
                                                       TAG_ERROR_DISPLAY, ERROR_INVALID_DATE, \
                                                       ERROR_DISPLAY_HELP )

// Free Memory Allocated Earlier , Afetr Freeing Assign Null To The Pointer .
#define FREE_MEMORY( VARIABLE ) \
            FreeMemory( &( VARIABLE ) ) ; \
            1

#define ASSIGN_MEMORY( VARIABLE , TYPE , VALUE ) \
            if( NULL == ( VARIABLE ) ) \
            { \
                ( VARIABLE ) = ( TYPE * ) AllocateMemory( ( VALUE ) * sizeof( TYPE ) ) ; \
            } \
            else \
            { \
                FREE_MEMORY( VARIABLE ); \
            } \
            1

extern LPWSTR lpwszTempDummyPtr;

#define REALLOC_MEMORY( VARIABLE , TYPE , VALUE ) \
            if( NULL == ( VARIABLE ) ) \
            { \
                ASSIGN_MEMORY( VARIABLE, TYPE, VALUE ); \
            } \
            else \
            { \
                if( FALSE == ReallocateMemory( &( VARIABLE ), ( VALUE ) * sizeof( TYPE ) ) ) \
                { \
                     FREE_MEMORY( ( VARIABLE ) ); \
                } \
            } \
            1

typedef struct __STORE_PATH_NAME
{
    LPTSTR pszDirName ;
    struct  __STORE_PATH_NAME  *NextNode ;
} Store_Path_Name , *PStore_Path_Name ;


LPWSTR
FindAChar(
      IN LPWSTR szString,
      IN WCHAR  wCharToFind
      );

LPWSTR
FindSubString(
      IN LPWSTR szString,
      IN LPWSTR szSubString
      );

#endif      //__GLOBAL__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\pch.h ===
/*++

  Copyright (c) Microsoft Corporation

  Module Name:

        pch.h

  Abstract:

        Pre-compiled header declaration files that has to be pre-compiled
        into .pch file .

  Author:

        V Vijaya Bhaskar

  Revision History:

        14-Jun-2001 : Created by V Vijaya Bhaskar ( Wipro Technologies ).

--*/

#ifndef __PCH__H
#define __PCH__H

#define CMDLINE_VERSION  200

#ifdef __cplusplus
extern "C" {
#endif

#pragma once                // include header file only once

/*************************************************************
 *          Public Windows Header Files                      *
 *************************************************************/
#include <windows.h>
#include <winerror.h>
#include <shlwapi.h>

/*************************************************************
 *          C Header Files                                   *
 *************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <wchar.h>
#include <time.h>
#include <malloc.h>
#include <strsafe.h>

/*************************************************************
 *          Common Header Files                              *
 *************************************************************/
#include "cmdline.h"
#include "cmdlineres.h"

#include "resource.h"

#ifdef __cplusplus
}
#endif

#endif  // __PCH__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\forfiles\resource.h ===
#define IDS_HELP_START                          201
#define IDS_HELP_SYNTAX1                        202
#define IDS_HELP_SYNTAX2                        203
#define IDS_HELP_DESCRIPTION1                   204
#define IDS_HELP_DESCRIPTION2                   205
#define IDS_HELP_DESCRIPTION3                   206
#define IDS_HELP_PARAMETER                      207
#define IDS_HELP_P1                             208
#define IDS_HELP_P2                             209
#define IDS_HELP_P3                             210
#define IDS_HELP_M1                             211
#define IDS_HELP_M2                             212
#define IDS_HELP_S1                             213
#define IDS_HELP_S2                             214
#define IDS_HELP_C1                             215
#define IDS_HELP_C2                             216
#define IDS_HELP_C3                             217
#define IDS_HELP_C4                             218
#define IDS_HELP_C5                             219
#define IDS_HELP_C6                             220
#define IDS_HELP_C7                             221
#define IDS_HELP_C8                             222
#define IDS_HELP_C9                             223
#define IDS_HELP_C10                            224
#define IDS_HELP_C11                            225
#define IDS_HELP_C12                            226
#define IDS_HELP_C13                            227
#define IDS_HELP_C14                            228
#define IDS_HELP_C15                            229
#define IDS_HELP_C16                            230
#define IDS_HELP_C17                            231
#define IDS_HELP_C18                            232
#define IDS_HELP_C19                            233
#define IDS_HELP_C20                            234
#define IDS_HELP_C21                            235
#define IDS_HELP_C22                            236
#define IDS_HELP_C23                            237
#define IDS_HELP_C24                            238
#define IDS_HELP_C25                            239
#define IDS_HELP_C26                            240
#define IDS_HELP_C27                            241
#define IDS_HELP_D1                             242
#define IDS_HELP_D2                             243
#define IDS_HELP_D3                             244
#define IDS_HELP_D4                             245
#define IDS_HELP_D5                             246
#define IDS_HELP_D6                             247
#define IDS_HELP_D7                             248
#define IDS_HELP_D8                             249
#define IDS_HELP_D9                             250
#define IDS_HELP_D10                            251
#define IDS_HELP_H1                             252
#define IDS_HELP_E0                             253
#define IDS_HELP_E1                             254
#define IDS_HELP_E2                             255
#define IDS_HELP_E3                             256
#define IDS_HELP_E4                             257
#define IDS_HELP_E5                             258
#define IDS_HELP_E6                             259
#define IDS_HELP_E7                             260
#define IDS_HELP_E8                             261
#define IDS_HELP_E9                             262
#define IDS_HELP_E10                            263
#define IDS_HELP_E11                            264
#define IDS_HELP_E12                            265
#define IDS_HELP_E13                            266
#define IDS_HELP_END                            267
#define IDS_ERROR_DISPLAY_HELP                  151
#define IDS_ERROR_INVALID_SYNTAX                152
#define IDS_ERROR_INVALID_DATE                  154
#define IDS_ERROR_FILE_NOT_FOUND                155
#define IDS_ERROR_NOFILE_FOUND                  161
#define IDS_ERROR_NOFILE_FOUND1                 162
#define IDS_NOT_WIN32_APPL                      163
#define IDS_TRUE                                164
#define IDS_FALSE                               165
#define IDS_TAG_ERROR_ACCESS_DENIED             167
#define IDS_APPEND_AT_END                       169
#define IDS_DOUBLE_QUOTES                       170
#define IDS_DIRECTORY_INVALID                   171
#define IDS_ERROR_UNC_PATH_NAME                 172
#define IDS_DATE_FORMAT_0                       173
#define IDS_DATE_FORMAT_1                       174
#define IDS_DATE_FORMAT_2                       175
#define IDS_DATE_FORMAT_3                       176
#define IDS_DATE_FORMAT_4                       177
#define IDS_DATE_FORMAT_5                       178

#define IDS_TAG_ERROR_DISPLAY                   IDS_TAG_ERROR
#define IDS_TAG_DISPLAY_WARNING                 IDS_TAG_WARNING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\freedisk\freedisk.h ===
#include "resource.h"
#include <direct.h>

#define MAX_OPTIONS         6

#define CMDOPTION_SERVER    L"S"
#define CMDOPTION_USER      L"U"
#define CMDOPTION_PASSWORD  L"P"
#define CMDOPTION_DRIVE     L"D"
#define CMDOPTION_DEFAULT   L""
#define CMDOPTION_USAGE     L"?"
#define CMDOPTION_OTHERS    L"S|U|P|D|?"


#define OI_SERVER       0
#define OI_USER         1
#define OI_PASSWORD     2
#define OI_DRIVE        3
#define OI_DEFAULT      4
#define OI_USAGE        5
#define OI_OTHERS       6

#define KB              L"KB"
#define MB              L"MB"
#define GB              L"GB"
#define TB              L"TB"
#define PB              L"PB"
#define EB              L"EB"
#define ZB              L"ZB"
#define YB              L"YB"
#define EMPTY_SPACE     L" "
#define NEWLINE         L"\n"

#define     SAFE_CLOSE_CONNECTION(szServer, bFlag ) \
                  if( StringLengthW(szServer, 0)!=0 && !bLocalSystem && FALSE == bFlagRmtConnectin) \
                  { \
                        CloseConnection( szServer ); \
                  } \
                  1
#define  SIZE_OF_ARRAY_IN_CHARS(x) \
               GetBufferSize((LPVOID)x)/sizeof(WCHAR)

DWORD ValidateDriveType( LPWSTR lpszPathName );
ULONGLONG GetDriveFreeSpace( LPCWSTR lpszRootPathName);
DWORD ProcessValue( IN  LPWSTR szValue, OUT long double *dfValue );
DWORD  ConvertintoLocale( IN LPWSTR szNumber, OUT LPWSTR szOutputStr );
DWORD DisplayHelpUsage();
DWORD ProcessOptions( IN  DWORD argc, 
                      IN  LPCWSTR argv[],
                      OUT LPWSTR *lpszServer,
                      OUT LPWSTR *lpszUser,
                      OUT LPWSTR lpszPasswd,
                      OUT LPWSTR *szDrive,
                      OUT LPWSTR szValue,
                      OUT PBOOL pbUsage,
                      OUT PBOOL pbNeedPasswd
                     );
DWORD DisplayOutput( IN long double AllowedDisk,
                     IN ULONGLONG lfTotalNumberofFreeBytes,
                     IN LPWSTR szDrive 
                     );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\freedisk\freedisk.cpp ===
/*++

    Copyright(c) Microsoft Corporation

    Module Name:
          Freedisk.cpp

    Abstract:

      This file is intended to return whehter there is specified free disk
      space is available or not.

    Author:


    Modification:

        Wipro Technologies, 22/6/2001.

    Revision History:


--*/

#include "pch.h"
#include "freedisk.h"
#include <strsafe.h>


DWORD _cdecl wmain(
    IN DWORD argc,
    IN LPCWSTR argv[]
    )
/*++

    Routine description : Main function which calls all the other
                          functions depending on the options specified
                          through command line.

    Arguments:
          [in] argc     : argument count specified in the command line.
          [in] argv     : arguments specified in the command line.

    Return Value        : DWORD
          EXIT_SUCCESS  : If there is enough free disk space.
          EXIT_FAILURE  : If there is not enough free disk space.
--*/
{

    DWORD       dwStatus = 0;
    LPWSTR      szServer                    =   NULL;
    LPWSTR      szUser                      =   NULL;
    WCHAR       szPasswd[MAX_RES_STRING]    =   NULL_STRING;
    LPWSTR      szDrive                     =   NULL;
    WCHAR       szValue[MAX_RES_STRING]     =   NULL_STRING;
    long double AllowedDisk                 =   0;
    ULONGLONG   lfTotalNumberofFreeBytes    =   0;
    LPWSTR      szTempDrive                 =   NULL;
    LPWSTR      szTemp1Drive                =   NULL;
    LPWSTR      szFullPath                  =   NULL;
    LPWSTR      szFilePart                  =   NULL;

    BOOL        bUsage                      =   FALSE;
    BOOL        bStatus                     =   FALSE;
    BOOL        bFlagRmtConnectin           =   FALSE;
    BOOL        bNeedPasswd                 =   FALSE;
    DWORD       dwCurdrv                    =   0;
    DWORD       dwAttr                      =   0;
    BOOL        bLocalSystem                =   FALSE;
    DWORD       dwSize                      =   0;


    //Process the options and get the drive name and amount of free space required
    dwStatus = ProcessOptions( argc, argv,
                             &szServer,
                             &szUser,
                             szPasswd,
                             &szDrive,
                             szValue,
                             &bUsage,
                             &bNeedPasswd
                             );

    if( EXIT_FAILURE == dwStatus  )
    {
        ShowLastErrorEx( stderr, SLE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return(EXIT_FAILURE);
    }

    //if usage is specified display usage
    if( TRUE == bUsage )
    {
      DisplayHelpUsage();
      FreeMemory( (LPVOID *) &szServer );
      FreeMemory( (LPVOID *) &szUser );
      FreeMemory( (LPVOID *) &szDrive );
      ReleaseGlobals();
      return EXIT_SUCCESS;
    }

    // now process the value of free space
    if( EXIT_FAILURE == ProcessValue( szValue, &AllowedDisk ))
    {
        ShowLastErrorEx( stderr, SLE_ERROR | SLE_INTERNAL );
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        FreeMemory( (LPVOID *) &szDrive );
        ReleaseGlobals();
        return(EXIT_FAILURE);
    }

    //Check whether local credentials supplied
    //before establishing connection
    bLocalSystem = IsLocalSystem(IsUNCFormat(szServer)?szServer+2:szServer);
        
    //establish the connection to remote sytem
    if( StringLengthW(szServer, 0) != 0  && !bLocalSystem )
    {

        bStatus = EstablishConnection( szServer,
                                       szUser,
                                       (StringLength(szUser,0) !=0)?SIZE_OF_ARRAY_IN_CHARS(szUser):MAX_STRING_LENGTH,
                                       szPasswd,
                                       MAX_STRING_LENGTH,
                                       bNeedPasswd );

        SecureZeroMemory( szPasswd, SIZE_OF_ARRAY(szPasswd) );

        //if establish connection fails get the reason and display error
        if( FALSE == bStatus )
        {
            ShowLastErrorEx( stderr, SLE_ERROR | SLE_INTERNAL);
            FreeMemory( (LPVOID *) &szUser );
            FreeMemory( (LPVOID *) &szServer );
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        //set whether to close the connection if it is opened by this program only
        switch( GetLastError() )
        {
            case I_NO_CLOSE_CONNECTION :
                 bFlagRmtConnectin = TRUE;
                 break;

            case ERROR_SESSION_CREDENTIAL_CONFLICT:

            case E_LOCAL_CREDENTIALS:
                    ShowLastErrorEx( stderr, SLE_TYPE_WARNING | SLE_INTERNAL );
                    bFlagRmtConnectin = TRUE;
        }
    }

    //if no drive specified, consider it as current drive/volume
    if( StringLengthW(szDrive, 0) == 0 )
    {
        dwSize = GetCurrentDirectory( 0, szTemp1Drive );
        if( 0 == dwSize )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            SAFE_CLOSE_CONNECTION(szServer, bFlagRmtConnectin );
            FreeMemory((LPVOID *) &szServer );
            FreeMemory((LPVOID *) &szUser );
            FreeMemory( (LPVOID *) &szDrive );
            ReleaseGlobals();
            return (EXIT_FAILURE);
        }
        szTemp1Drive = (LPWSTR) AllocateMemory((dwSize+10)*sizeof(WCHAR));
        if( NULL == szTemp1Drive )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SAFE_CLOSE_CONNECTION(szServer, bFlagRmtConnectin );
            FreeMemory((LPVOID *) &szServer );
            FreeMemory((LPVOID *) &szUser );
            ReleaseGlobals();
            return (EXIT_FAILURE);
        }
        SecureZeroMemory( (LPVOID)szTemp1Drive, GetBufferSize(szTemp1Drive) );

        if( FALSE == GetCurrentDirectory( dwSize+10, szTemp1Drive ) )
        {
            ShowLastErrorEx( stderr, SLE_ERROR | SLE_SYSTEM );
        }

        dwAttr = GetFileAttributes( szTemp1Drive );             //if the file is not root_dir check again
        if( -1!=dwAttr && !(dwAttr & FILE_ATTRIBUTE_REPARSE_POINT) ) // attributes  for reparse point
        {
            dwCurdrv = _getdrive();
            StringCchPrintf( szTemp1Drive, dwSize, L"%c:", L'A'+dwCurdrv-1 );
        }

        //copy null if no drive specified to full path, it is only for display purpose
        szFullPath = (WCHAR *) AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szFullPath )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return( EXIT_FAILURE );
        }
        StringCopy( szFullPath, NULL_STRING, SIZE_OF_ARRAY_IN_CHARS(szFullPath) );
    }
    else
    {
        //get the fullpath of Drive, this is for display purpose only
        dwSize=GetFullPathName(szDrive, 0, szFullPath, &szFilePart );
        if(  dwSize != 0  )
        {

            szFullPath = (WCHAR *) AllocateMemory( (dwSize+10)*sizeof(WCHAR) );
            if( NULL == szFullPath )
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                return( EXIT_FAILURE );
            }

            dwSize=GetFullPathName(szDrive, (DWORD) dwSize+5, szFullPath, &szFilePart );
        }

        szTemp1Drive = (LPWSTR) AllocateMemory((StringLengthW(szDrive, 0)+10)*sizeof(WCHAR));
        if( NULL == szTemp1Drive )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SAFE_CLOSE_CONNECTION(szServer, bFlagRmtConnectin );
            FreeMemory((LPVOID *) &szServer );
            FreeMemory((LPVOID *) &szUser );
            FreeMemory( (LPVOID *) &szDrive );
            ReleaseGlobals();
            return (EXIT_FAILURE);
        }
        StringCopy( szTemp1Drive, szDrive, SIZE_OF_ARRAY_IN_CHARS(szTemp1Drive));
    }
    
    szTempDrive = (LPWSTR) AllocateMemory((StringLengthW(szTemp1Drive, 0)+StringLengthW(szServer, 0)+20)*sizeof(WCHAR));
    if( NULL == szTempDrive )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFE_CLOSE_CONNECTION(szServer, bFlagRmtConnectin );
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        FreeMemory( (LPVOID *) &szDrive );
        FreeMemory((LPVOID *) &szTemp1Drive );
        FreeMemory((LPVOID *) &szFullPath );
        ReleaseGlobals();
        return (EXIT_FAILURE);
    }

    StringCopy( szTempDrive, szTemp1Drive, SIZE_OF_ARRAY_IN_CHARS(szTempDrive) );

    //if the remote system is specified build the path name
    if( bStatus )
    {

        if( szTemp1Drive[1]== L':' )
            szTemp1Drive[1]=L'$';

         if( IsUNCFormat( szServer ) == FALSE )
         {
            StringCchPrintf( szTempDrive, SIZE_OF_ARRAY_IN_CHARS(szTempDrive), L"\\\\%s\\%s\\",  szServer,  szTemp1Drive  );
         }
         else
         {
             StringCchPrintf( szTempDrive, SIZE_OF_ARRAY_IN_CHARS(szTempDrive), L"\\\\%s\\%s\\",  szServer+2,  szTemp1Drive );
         }
    }

    //free the memory, no need
    FreeMemory( (LPVOID *) &szTemp1Drive );
//    FreeMemory( (LPVOID *) &szDrive );
    
    //check the given drive is valid drive or not
    if(EXIT_FAILURE == ValidateDriveType( szTempDrive ) )
    {
        ShowLastErrorEx( stderr, SLE_ERROR | SLE_INTERNAL );
        SAFE_CLOSE_CONNECTION(szServer, bFlagRmtConnectin );
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        FreeMemory( (LPVOID *) &szTempDrive );
        FreeMemory( (LPVOID *) &szDrive );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    //get the drive space
    lfTotalNumberofFreeBytes = GetDriveFreeSpace( szTempDrive );
    if( (ULONGLONG)(-1) == lfTotalNumberofFreeBytes )
    {

        ShowLastErrorEx( stderr, SLE_ERROR | SLE_INTERNAL );
        SAFE_CLOSE_CONNECTION(szServer, bFlagRmtConnectin );
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        FreeMemory( (LPVOID *) &szTempDrive );
        FreeMemory( (LPVOID *) &szDrive );
        ReleaseGlobals();
        return(EXIT_FAILURE);
    }

    //output the warning if it matches with the local creadentials
    if( StringLengthW(szUser, 0) != 0 && bLocalSystem)
    {
        ShowMessage( stderr, NEWLINE );
        ShowMessage( stderr, GetResString( IDS_LOCAL_CREDENTIALS ) );
    }

    if( IsLocalSystem( szServer ) )
    {
        dwStatus = DisplayOutput( AllowedDisk, lfTotalNumberofFreeBytes, szFullPath );
    }
    else
    {
        dwStatus = DisplayOutput( AllowedDisk, lfTotalNumberofFreeBytes, szDrive );
    }
    
    SAFE_CLOSE_CONNECTION(szServer, bFlagRmtConnectin );
   
    FreeMemory( (LPVOID *) &szServer );
    FreeMemory( (LPVOID *) &szUser );
    FreeMemory( (LPVOID *) &szTempDrive );
    FreeMemory( (LPVOID *) &szDrive );
    ReleaseGlobals();

    return(dwStatus );

}

DWORD ProcessOptions(
    IN DWORD argc,
    OUT LPCWSTR argv[],
    OUT LPWSTR *lpszServer,
    OUT LPWSTR *lpszUser,
    OUT LPWSTR lpszPasswd,
    OUT LPWSTR *szDrive,
    OUT LPWSTR szValue,
    OUT PBOOL pbUsage,
    OUT PBOOL pbNeedPasswd
    )
/*++

    Routine Description : Function used to process the main options

    Arguments:
         [ in  ]  argc         : Number of command line arguments

         [ in  ]  argv         : Array containing command line arguments

         [ out ]  lpszServer   : Pointer to string which returns remote system
                                 name if remote system is specified in the command line.

         [ out ]  lpszUser     : Pointer to string which returns User name
                                 if the user name is specified in the command line.

         [ out ]  lpszPasswd   : Pointer to string which returns Password
                                 if the password is specified in the command line.

         [ out ]  szDrive    : Pointer to string which returns Drive name
                                 specified in the command line.

         [ out ]  szValue      : Pointer to string which returns the default value
                                 specified in the command line.

         [ out ]  pbUsage      : Pointer to boolean variable returns true if
                                 usage option specified in the command line.

  Return Type      : DWORD
        A Integer value indicating EXIT_SUCCESS on successful parsing of
                command line else EXIT_FAILURE

--*/
{
    TCMDPARSER2  cmdOptions[MAX_OPTIONS];
    PTCMDPARSER2 pcmdOption;
    LPWSTR      szTemp                      =   NULL;
    BOOL        bOthers                     =   FALSE;

    StringCopy( lpszPasswd, L"*", MAX_STRING_LENGTH );

    // help option
    pcmdOption  = &cmdOptions[OI_USAGE] ;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP_USAGE ;
    pcmdOption->pValue = pbUsage ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = 0;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=CMDOPTION_USAGE;
    StringCopyA(cmdOptions[OI_USAGE].szSignature, "PARSER2", 8 );



    //server name option
    pcmdOption  = &cmdOptions[OI_SERVER] ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->pValue = NULL ;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwLength = 0;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pwszOptions=CMDOPTION_SERVER; // _T("s")
    StringCopyA(cmdOptions[OI_SERVER].szSignature, "PARSER2", 8 );

    //domain\user option
    pcmdOption  = &cmdOptions[OI_USER] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL ;
    pcmdOption->pValue = NULL;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwLength = 0;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=CMDOPTION_USER; // _T("u")
    StringCopyA(cmdOptions[OI_USER].szSignature, "PARSER2", 8 );
    
    //password option
    pcmdOption  = &cmdOptions[OI_PASSWORD] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->pValue = lpszPasswd;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwLength = MAX_RES_STRING;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pwszOptions=CMDOPTION_PASSWORD;  // _T("p")
    StringCopyA(cmdOptions[OI_PASSWORD].szSignature, "PARSER2", 8 );
    
    //drive option
    pcmdOption  = &cmdOptions[OI_DRIVE] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL ;
    pcmdOption->pValue = NULL;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwLength = 0;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszOptions=CMDOPTION_DRIVE; // _T("d")
    StringCopyA(cmdOptions[OI_DRIVE].szSignature, "PARSER2", 8 );

    //default option
    pcmdOption  = &cmdOptions[OI_DEFAULT] ;
    pcmdOption->dwCount = 1 ;
    pcmdOption->dwActuals = 0;
    pcmdOption->dwFlags = CP2_DEFAULT;
    pcmdOption->pValue = szValue;
    pcmdOption->pFunction = NULL ;
    pcmdOption->pFunctionData = NULL ;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwLength = MAX_RES_STRING;
    pcmdOption->dwReserved = 0;
    pcmdOption->pReserved1 = NULL;
    pcmdOption->pReserved2 = NULL;
    pcmdOption->pReserved3 = NULL;
    pcmdOption->pwszValues=NULL;
    pcmdOption->pwszFriendlyName=NULL;
    pcmdOption->pwszOptions=CMDOPTION_DEFAULT;  // _T("")
    StringCopyA(cmdOptions[OI_DEFAULT].szSignature, "PARSER2", 8 );


    //process the command line options and display error if it fails
    if( DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) == FALSE )
    {
        return( EXIT_FAILURE );
    }

    //if usage specified with any other value display error and return with failure
    if( (( TRUE == *pbUsage ) && ( argc > 2 ) ) || TRUE == bOthers )
    {
        SetReason( GetResString(IDS_INVALID_SYNTAX) );
        return( EXIT_FAILURE );
    }

    *lpszServer = (LPWSTR)cmdOptions[OI_SERVER].pValue;
    *lpszUser = (LPWSTR)cmdOptions[OI_USER].pValue;
    *szDrive = (LPWSTR)cmdOptions[OI_DRIVE].pValue;

    if( TRUE == *pbUsage )
    {
        return( EXIT_SUCCESS);
    }

    TrimString( *lpszServer, TRIM_ALL);
    TrimString( *lpszUser, TRIM_ALL);
    TrimString( *szDrive, TRIM_ALL);


    //validate the value for null string or spaces
    if( StringLengthW( szValue, 0 ) != 0 )
    {
        StrTrim( szValue, L" ");
        if( StringLengthW(szValue, 0) == 0 )
        {
            SetReason(GetResString(IDS_INVALID_BYTES));
            return( EXIT_FAILURE );
        }
    }

    if( cmdOptions[OI_DRIVE].dwActuals != 0 && StringLengthW(*szDrive, 0) == 0 )
    {
        SetReason(GetResString(IDS_ERROR_NULL_DRIVE) );
        return EXIT_FAILURE;
    }

/*
    //if drive is more than two letters and is having a trailing slash at end then failure
    //this is because the API for validating drive will pass for paths like a:\.
    if( *(szDrive+StringLengthW( *szDrive, 0 )-1) == L'\\' || (szTemp = FindString(szDrive, L"/", 0) )!= NULL)
    {
        DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_DRIVE));
        return( EXIT_FAILURE );
    }
*/
    //if drive is having a trailing slash at end then failure
    //this is because the API for validating drive will pass for paths like a:/.
    if( (szTemp = (LPWSTR)FindString(*szDrive, L"/", 0) )!= NULL)
    {
        SetReason(GetResString(IDS_INVALID_DRIVE));
        return( EXIT_FAILURE );
    }
    
    //check if user has specified without specifying remote system
    if( cmdOptions[OI_SERVER].dwActuals == 0 && StringLengthW(*lpszUser, 0) != 0 )
    {
        SetReason(GetResString(IDS_USER_WITHOUT_SERVER) );
        return( EXIT_FAILURE );
    }

    //check if password has specified without specifying user name
    if( cmdOptions[OI_USER].dwActuals == 0  && cmdOptions[OI_PASSWORD].dwActuals != 0 )
    {
        SetReason(GetResString(IDS_PASSWD_WITHOUT_USER) );
        return( EXIT_FAILURE );
    }

    //check if null server is specified
    if( cmdOptions[OI_SERVER].dwActuals!=0 && StringLengthW(IsUNCFormat(*lpszServer)?*lpszServer+2:*lpszServer, 0) == 0 )
    {
        SetReason(GetResString(IDS_ERROR_NULL_SERVER) );
        return( EXIT_FAILURE );
    }

    //check if remote machine specified but drive name is not specified
    if( cmdOptions[OI_SERVER].dwActuals !=0 && (0 == cmdOptions[OI_DRIVE].dwActuals || StringLength(*szDrive,0) == 0) )
    {
        SetReason(GetResString(IDS_REMOTE_DRIVE_NOT_SPECIFIED) );
        return( EXIT_FAILURE );
    }

    //check if /d with null value specified
    if( 0 != cmdOptions[OI_DRIVE].dwActuals && StringLengthW(*szDrive, 0) == 0)
    {
        SetReason(GetResString(IDS_INVALID_DRIVE));
        return( EXIT_FAILURE );
    }
    
    if(IsLocalSystem( *lpszServer ) == FALSE )
    {
        // set the bNeedPassword to True or False .
        if ( cmdOptions[ OI_PASSWORD ].dwActuals != 0 &&
             lpszPasswd != NULL && StringCompare( lpszPasswd, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            *pbNeedPasswd = TRUE;
        }
        else if ( cmdOptions[ OI_PASSWORD ].dwActuals == 0 &&
                ( cmdOptions[ OI_SERVER ].dwActuals != 0 || cmdOptions[ OI_USER ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            *pbNeedPasswd = TRUE;
            if ( lpszPasswd != NULL )
            {
                StringCopy( lpszPasswd, _T( "" ), MAX_STRING_LENGTH );
            }
        }

        //allocate memory if /u is not specified 
        if( NULL == *lpszUser )
        {
            *lpszUser = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
            if( NULL == *lpszUser )
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                return (EXIT_FAILURE);
            }
        }
    }

   return( EXIT_SUCCESS );
}

DWORD DisplayOutput( IN long double AllowedDisk,
                     IN ULONGLONG  lfTotalNumberofFreeBytes,
                    IN LPWSTR  szDrive
                  )
/*++

    Routine Description : This displays the output whether specified amount
                          disk space is available in drive or not.

    Arguments:
         [ in  ]  lAllowedDisk:  A pointer to string specifying the drive path.
         [ in  ]  szDrive     :  Drive name to be displayed.

    Return Type    : void
        
--*/

{

    WCHAR szOutputStr[MAX_STRING_LENGTH] = NULL_STRING;
    WCHAR szTempBuf[MAX_STRING_LENGTH] = NULL_STRING;

    //display new line
    ShowMessage( stdout, NEWLINE );

    //check if it is only to know the amount of free space on the disk
    //then display the free space
    if( (long double)-1 == AllowedDisk )
    {
        //format the number into string
        StringCchPrintf( szTempBuf, SIZE_OF_ARRAY(szTempBuf)-1, L"%I64d", lfTotalNumberofFreeBytes );

        //convert into locale
        ConvertintoLocale(  szTempBuf, szOutputStr );
        
        //if drive name is not specified display for current drive
        if( StringLengthW(szDrive, 0) == 0 )
        {
            ShowMessageEx( stdout, 1, TRUE, GetResString( IDS_AVAILABLE_DISK_SPACE1),_X(szOutputStr) );
        }
        else
        {
            ShowMessageEx( stdout, 2, TRUE, GetResString( IDS_AVAILABLE_DISK_SPACE ), _X(szOutputStr), _X2( CharUpper( szDrive ) ) );
        }

    }
    else   //check the specified space is available or not
    {
        if (lfTotalNumberofFreeBytes < AllowedDisk)
        {
            //if drive letter is  specified display as it is otherwise display it as currrent drive
            if( StringLengthW(szDrive,0) != 0 )
            {
                ShowMessageEx( stdout, 1, TRUE, GetResString(IDS_TOO_SMALL), _X(CharUpper(szDrive)) );
            }
            else
            {
                ShowMessage(stdout, GetResString(IDS_TOO_SMALL1));
            }
      
            return( EXIT_FAILURE );
        }
        else
        {

            //format the number into string
            StringCchPrintf( szTempBuf, SIZE_OF_ARRAY(szTempBuf)-1, L"%lf", AllowedDisk );

            //convert into locale
            ConvertintoLocale( szTempBuf, szOutputStr );

            //if drive name is not specified display it as current drive
            if( StringLength(szDrive, 0) == 0 )
            {
                ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OK1), _X(szOutputStr) );
            }
            else
            {
                ShowMessageEx(stdout, 2, TRUE, GetResString(IDS_OK), _X(szOutputStr), _X2(CharUpper(szDrive)) );
            }

        }
    }
    return( EXIT_SUCCESS );
}


ULONGLONG
GetDriveFreeSpace(
                  IN LPCWSTR lpszRootPathName
                )
/*++

    Routine Description : Function used to Check the specified free space available
                          in the specified disk.

    Arguments:
         [ in  ]  lpszRootPathName  :  A pointer to string specifying the drive path.

    Return Type    : ULONGLONG
        A longlong value returns the no.of free bytes available on disk, if success.
        otherwise returns -1 value
--*/
{
    DWORD       dwRetCode                   =   0;
    ULONGLONG   lpFreeBytesAvailable        =   0;
    ULONGLONG   lpTotalNumberofBytes        =   0;
    ULONGLONG   lpTotalNumberofFreeBytes    =   (ULONGLONG)-1;


    //this error mode is not to display the message box
    //if drive is not currently available
    SetErrorMode( SEM_FAILCRITICALERRORS);

    //get the total free disk space using the API
    dwRetCode=GetDiskFreeSpaceEx(lpszRootPathName,
                           (PULARGE_INTEGER) &lpFreeBytesAvailable,
                           (PULARGE_INTEGER) &lpTotalNumberofBytes,
                           (PULARGE_INTEGER) &lpTotalNumberofFreeBytes );

    //if it fails display the reason and exit with error
    if( 0 == dwRetCode  )
    {
        switch( GetLastError() )
        {
            case ERROR_PATH_NOT_FOUND   :
            case ERROR_BAD_NETPATH      :
            case ERROR_INVALID_NAME     :
                SetReason(GetResString(IDS_INVALID_DRIVE) );
                break;
            case ERROR_INVALID_PARAMETER :
                    SetReason( GetResString(IDS_CANT_FIND_DISK));
                    break;

            default :
                SaveLastError();
                break;
        }

    }
    
    //reset back the critical error
    SetErrorMode(0);

    return( lpTotalNumberofFreeBytes );

}

DWORD
  ValidateDriveType( LPWSTR szRootPathName )
/*++

    Routine Description : Function used to Check the specified drive is valid or not
    Arguments:
         [ in  ]  lpszRootPathName  :  A pointer to string specifying the drive path.

    Return Type    : ULONGLONG
        returns EXIT_SUCCESS if the drive type is valid, returns EXIT_FAILURE otherwise
--*/
{
    DWORD       dwCode                          =   0;
    DWORD       dwAttr                          =   0xffffffff;
    
    dwCode = GetDriveType( szRootPathName );
    switch( dwCode )
    {
        case DRIVE_UNKNOWN  :
//      case DRIVE_NO_ROOT_DIR  :
            //if the file is not not check again for reparse point
            dwAttr = GetFileAttributes( szRootPathName );
            if( (DWORD)-1!=dwAttr  && (dwAttr & FILE_ATTRIBUTE_REPARSE_POINT) ) 
            {
                // attributes  for reparse point
                return EXIT_SUCCESS;
            }
            else
            {
                switch( GetLastError() )
                {

                case ERROR_ACCESS_DENIED :
                    SaveLastError();
                    return EXIT_FAILURE;
                case ERROR_INVALID_PARAMETER :
                    SetReason( GetResString(IDS_CANT_FIND_DISK));
                default :
                    SetReason(GetResString(IDS_INVALID_DRIVE) );
                   return EXIT_FAILURE;
                }

            }
    }
    return( EXIT_SUCCESS );
}


DWORD
  ProcessValue( IN  LPWSTR szValue,
                OUT long double *dfValue
              )
/*++
    Routine Description : This function process the szValue and returns
                          its decimal number.

    Arguments:
         [ in  ]  szValue  :  A pointer to string specifying the drive path.
         [ out ]  dfValue  :  A pointer to long double which returns the numeric value
                              of the value specified in szValue.


    Return Type    : DWORD
        A Integer value indicating EXIT_SUCCESS on success,
        EXIT_FAILURE on failure

--*/
{
    LPWSTR      pszStoppedString        =   NULL;
    double      dfFactor                =   1.0;
    LPWSTR      szTemp                  =   NULL;
    WCHAR       szDecimalSep[MAX_RES_STRING] = NULL_STRING;

    //if free space value is not specified consider it as -1
    if( StringLength(szValue,0) == 0 )
    {
          *dfValue = -1;
    }
    else
    {
        //check for language regional settings
        if( 0 == GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecimalSep, MAX_RES_STRING ) )
        {
            SaveLastError();
            return EXIT_FAILURE;
        }

        //check if decimal point(.) is also specified along with the decimal seperator
        if( StringCompare(szDecimalSep, L".", TRUE, 0) != 0 && (szTemp = (LPWSTR)FindString( szValue, L".", 0)) != NULL)
        {
            SetReason(GetResString(IDS_INVALID_BYTES) );
            return(EXIT_FAILURE);
        }

        if( (szTemp = (LPWSTR)FindString( szValue, szDecimalSep, 0 )) != NULL )
            szTemp[0] = L'.';


        //read the numeric value
        *dfValue = wcstod( szValue, &pszStoppedString );


        //check for negative value specified
        if( *dfValue < 0 )
        {
            SetReason(GetResString(IDS_INVALID_BYTES) );
            return(EXIT_FAILURE);
        }

        //now check for whether Units are specified or not
        //if specified take the multiplying facter as to that value
        StrTrim(pszStoppedString, L" ");
        if( StringLengthW(pszStoppedString, 0) )
        {
            if( StringCompare( pszStoppedString, KB, TRUE, 0) == 0 )
            {
                dfFactor = 1024;
            }
            else
              if( StringCompare( pszStoppedString, MB, TRUE, 0) == 0 )
              {
                 dfFactor = 1024*1024;
              }
              else
                 if( StringCompare( pszStoppedString, GB, TRUE, 0) == 0 )
                 {
                    dfFactor = 1024*1024*1024;
                 }
                 else
                    if( StringCompare( pszStoppedString, TB, TRUE, 0) == 0 )
                    {
                      dfFactor = (long double)1024*1024*1024*1024;
                    }
                    else
                     if( StringCompare( pszStoppedString, PB, TRUE, 0) == 0 )
                     {
                        dfFactor = (long double)1024*1024*1024*1024*1024;
                     }
                     else
                        if( StringCompare( pszStoppedString, EB, TRUE, 0) == 0 )
                        {
                           dfFactor = (long double)1024*1024*1024*1024*1024*1024;
                        }
                        else
                           if( StringCompare( pszStoppedString, ZB, TRUE, 0) == 0 )
                           {
                              dfFactor = (long double)1024*1024*1024*1024*1024*1024*1024;
                           }
                           else
                              if( StringCompare( pszStoppedString, YB, TRUE, 0) == 0 )
                              {
                                 dfFactor = (long double)1024*1024*1024*1024*1024*1024*1024*1024;
                              }
                              else
                              {
                                  SetReason(GetResString( IDS_INVALID_BYTES ) );
                                  return( EXIT_FAILURE );
                               }
            

          //check if only units are specified without any value like KB, MB etc.
         if( StringCompare( pszStoppedString, szValue, TRUE, 0 ) == 0 )
         {
                    *dfValue = 1;
         }
                
        }

        *dfValue *= dfFactor;

        //check if no units are specified but fractional value is specified
        if( (1.0 == dfFactor) && (szTemp=(LPWSTR)FindString( szValue, L".", 0))!=NULL )
        {
          SetReason(GetResString( IDS_INVALID_BYTES ) );
          return( EXIT_FAILURE );
        }
    }
    return( EXIT_SUCCESS );
}


DWORD
 ConvertintoLocale( IN LPWSTR szNumberStr,
                    OUT LPWSTR szOutputStr )
/*++
    Routine Description : This function converts string into locale format

    Arguments:
         [ in  ]  szNumberStr  :  A pointer to string specifying input string to convert.
         [ out ]  szOutputStr  :  A pointer to a string specifying output string in locale format.


    Return Type    : DWORD
        A Integer value indicating EXIT_SUCCESS on success,
        EXIT_FAILURE on failure

--*/
{
    NUMBERFMT numberfmt;
    WCHAR   szGrouping[MAX_RES_STRING]      =   NULL_STRING;
    WCHAR   szDecimalSep[MAX_RES_STRING]    =   NULL_STRING;
    WCHAR   szThousandSep[MAX_RES_STRING]   =   NULL_STRING;
    WCHAR   szTemp[MAX_RES_STRING]          =   NULL_STRING;
    LPWSTR  szTemp1                         =   NULL;
    LPWSTR  pszStoppedString                =   NULL;
    DWORD   dwStatus                        =   0;
    DWORD   dwGrouping                      =   3;

    //make the fractional digits and leading zeros to nothing
    numberfmt.NumDigits = 0;
    numberfmt.LeadingZero = 0;


    //get the decimal seperate character
    if( FALSE == GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecimalSep, MAX_RES_STRING ) )
    {
       StringCopy(szDecimalSep, L",", SIZE_OF_ARRAY(szDecimalSep));
    }
    numberfmt.lpDecimalSep = szDecimalSep;
    
    //get the thousand seperator
    if(FALSE == GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandSep, MAX_RES_STRING ) )
    {
        StringCopy(szThousandSep, L",", SIZE_OF_ARRAY(szThousandSep)  );
    }
    numberfmt.lpThousandSep = szThousandSep;

    if( GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, MAX_RES_STRING ) )
    {
        szTemp1 = wcstok( szGrouping, L";");
        do
        {
            STRING_CONCAT_STATIC( szTemp, szTemp1);
            szTemp1 = wcstok( NULL, L";" );
        }while( szTemp1 != NULL && StringCompare( szTemp1, L"0", TRUE, 0) != 0);
        dwGrouping = wcstol( szTemp, &pszStoppedString, 10);
    }
    else
        dwGrouping = 33;  //set the default grouping

    numberfmt.Grouping = (UINT)dwGrouping ;

    numberfmt.NegativeOrder = 2;

    dwStatus = GetNumberFormat( LOCALE_USER_DEFAULT, 0, szNumberStr, &numberfmt, szOutputStr, MAX_RES_STRING);

    return(EXIT_SUCCESS);
}



DWORD
  DisplayHelpUsage()
/*++

    Routine Description : Function used to to display the help usage.

    Arguments:


    Return Type    : DWORD
        A Integer value indicating EXIT_SUCCESS on success else
        EXIT_FAILURE on failure
--*/
{

    for( DWORD dw=IDS_MAIN_HELP_BEGIN; dw<=IDS_MAIN_HELP_END; dw++)
    {
            ShowMessage(stdout,GetResString(dw) );
    }
    return(EXIT_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\freedisk\resource.h ===
#define IDS_MAIN_HELP_BEGIN             101
#define IDS_HELP_LINE2                  102
#define IDS_HELP_LINE3                  103
#define IDS_HELP_LINE4                  104
#define IDS_HELP_LINE5                  105
#define IDS_HELP_LINE6                  106
#define IDS_HELP_LINE7                  107
#define IDS_HELP_LINE8                  108
#define IDS_HELP_LINE9                  109
#define IDS_HELP_LINE10                 110
#define IDS_HELP_LINE11                 111
#define IDS_HELP_LINE12                 112
#define IDS_HELP_LINE13                 113
#define IDS_HELP_LINE14                 114
#define IDS_HELP_LINE15                 115
#define IDS_HELP_LINE16                 116
#define IDS_HELP_LINE17                 117
#define IDS_HELP_LINE18                 118
#define IDS_HELP_LINE19                 119
#define IDS_HELP_LINE20                 120
#define IDS_HELP_LINE21                 121
#define IDS_HELP_LINE22                 122
#define IDS_HELP_LINE23                 123
#define IDS_HELP_LINE24                 124
#define IDS_HELP_LINE25                 125
#define IDS_HELP_LINE26                 126
#define IDS_HELP_LINE27                 127
#define IDS_HELP_LINE28                 128
#define IDS_HELP_LINE29                 129
#define IDS_HELP_LINE30                 130
#define IDS_HELP_LINE31                 131
#define IDS_HELP_LINE32                 132
#define IDS_HELP_LINE33                 133
#define IDS_HELP_LINE34                 134
#define IDS_MAIN_HELP_END               135

#define IDS_INVALID_DRIVE               30
#define IDS_INVALID_BYTES               31
#define IDS_TOO_SMALL                   32
#define IDS_OK                          33
#define IDS_INVALID_SYNTAX              37
#define IDS_USER_WITHOUT_SERVER         38
#define IDS_PASSWD_WITHOUT_USER         39
#define IDS_NUMBER_OVERFLOW             40
#define IDS_LOCAL_CREDENTIALS           41
#define IDS_ERROR_NULL_SERVER           42
#define IDS_ERROR_NULL_DRIVE            43
#define IDS_AVAILABLE_DISK_SPACE        44
#define IDS_REMOTE_DRIVE_NOT_SPECIFIED  45
#define IDS_OK1                         46
#define IDS_TOO_SMALL1                  47
#define IDS_AVAILABLE_DISK_SPACE1       48
#define IDS_CANT_FIND_DISK              49
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\freedisk\pch.h ===
#ifndef __PCH_H
#define __PCH_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once

//
// public Windows header files
//
#include <tchar.h>
#include <windows.h>
#include <shlwapi.h>

//
// public C header files
//
#include <stdio.h>

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\getmac\connectwmi.cpp ===
/*++
    Copyright (c) Microsoft Corporation

Module Name:
    CONNECTWMI.cpp

Abstract:
    Contains functions to connect to wmi.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 26-sep-2k : Created It.  
--*/

// Include files
#include "pch.h"
#include "getmac.h"
#include "resource.h"

// messages

#define INPUT_PASSWORD      GetResString( IDS_STR_INPUT_PASSWORD )

// error constants

#define E_SERVER_NOTFOUND           0x800706ba

// function prototypes

BOOL
IsValidUserEx(
    IN LPCWSTR pwszUser
    );

HRESULT
GetSecurityArguments(
    IN IUnknown *pInterface, 
    OUT DWORD&   dwAuthorization,
    OUT DWORD&   dwAuthentication
    );

HRESULT
SetInterfaceSecurity(
    IN IUnknown       *pInterface,
    IN LPCWSTR        pwszUser,
    IN LPCWSTR        pwszPassword,
    OUT COAUTHIDENTITY **ppAuthIdentity
    );

HRESULT
WINAPI SetProxyBlanket(
    IN IUnknown  *pInterface,
    IN DWORD     dwAuthnSvc,
    IN DWORD     dwAuthzSvc,
    IN LPWSTR    pwszPrincipal,
    IN DWORD     dwAuthLevel,
    IN DWORD     dwImpLevel,
    IN RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
    IN DWORD     dwCapabilities
    );

HRESULT
WINAPI WbemAllocAuthIdentity(
    IN LPCWSTR pwszUser,
    IN LPCWSTR pwszPassword, 
    IN LPCWSTR pwszDomain,
    OUT COAUTHIDENTITY **ppAuthIdent
    );

BOOL
PropertyGet(
    IN IWbemClassObject  *pWmiObject,
    IN LPCWSTR           pwszProperty, 
    OUT CHString&         strValue,
    IN LPCWSTR           pwszDefault = V_NOT_AVAILABLE
    );

BOOL
PropertyGet(
    IN IWbemClassObject* pWmiObject,
    IN LPCWSTR pwszProperty,
    OUT CHString& strValue,
    IN LPCWSTR pwszDefault
    );

HRESULT
PropertyGet(
    IN IWbemClassObject* pWmiObject,
    IN LPCWSTR pwszProperty,
    OUT _variant_t& varValue
    );

BOOL
IsValidUserEx(
    IN LPCWSTR pwszUser
    )
/*++
Routine Description:
    Validates the user name.

Arguments:
    [IN] pwszUser  - Holds the user name to be validated.    

Return Value:
    returns TRUE if user name is a valid user else FALSE.
--*/
{
    // local variables
    CHString strUser;
    LONG lPos = 0;

    if ( ( NULL == pwszUser ) )
    {
        return TRUE;
    }
    if( 0 == StringLength( pwszUser, 0 ) )
    {
        return TRUE;
    }

    try
    {
        // get user into local memory
        strUser = pwszUser;

        // user name should not be just '\'
        if ( 0 == strUser.CompareNoCase( L"\\" ) )
        {
            return FALSE;
        }
        // user name should not contain invalid characters
        if ( -1 != strUser.FindOneOf( L"/[]:|<>+=;,?*" ) )
        {
            return FALSE;
        }
        lPos = strUser.Find( L'\\' );
        if ( -1 != lPos )
        {
            // '\' character exists in the user name
            // strip off the user info upto first '\' character
            // check for one more '\' in the remaining string
            // if it exists, invalid user
            strUser = strUser.Mid( lPos + 1 );
            lPos = strUser.Find( L'\\' );
            if ( -1 != lPos )
            {
                return FALSE;
            }
        }

    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // user name is valid
    return TRUE;
}


BOOL
IsValidServerEx(
    IN LPCWSTR pwszServer,
    OUT BOOL &bLocalSystem
    )
/*++
Routine Description: 
    Checks whether the server name is a valid server name or not.

Arguments:
    [IN] pwszServer     - Server name to be validated.
    [OUT] bLocalSystem  - Set to TRUE if server specified is local system.

Return Value: 
    TRUE if server is valid else FALSE.
--*/
{
    // local variables
    CHString strTemp;

    if( NULL == pwszServer )
    {
        return FALSE;
    }

    if( 0 == StringLength( pwszServer, 0 ) )
    {
        bLocalSystem = TRUE;
        return TRUE;
    }
    bLocalSystem = FALSE;
    try
    {
        // get a local copy
        strTemp = pwszServer;

        if( TRUE == IsNumeric( pwszServer, 10, FALSE ) )
        {
            return FALSE;
        }

        // remove the forward slashes (UNC) if exist in the begining of the server name
        if ( TRUE == IsUNCFormat( strTemp ) )
        {
            strTemp = strTemp.Mid( 2 );
            if ( 0 == strTemp.GetLength() )
            {
                return FALSE;
            }
        }
        if ( -1 != strTemp.FindOneOf( L"`~!@#$^&*()+=[]{}|\\<>,?/\"':;" ) )
        {
            return FALSE;
        }

        // now check if any '\' character appears in the server name. If so error
        if ( -1 != strTemp.Find( L'\\' ) )
        {
            return FALSE;
        }

        // now check if server name is '.' only which represent local system in WMI
        // else determine whether this is a local system or not
        if ( 0 == strTemp.CompareNoCase( L"." ) )
        {
            bLocalSystem = TRUE;
        }
        else
        {
            bLocalSystem = IsLocalSystem( strTemp );
        }
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // valid server name
    return TRUE;
}

BOOL
ConnectWmi(
    IN IWbemLocator    *pLocator,
    OUT IWbemServices   **ppServices, 
    IN LPCWSTR         pwszServer,
    OUT LPCWSTR         pwszUser,
    OUT LPCWSTR         pwszPassword, 
    OUT COAUTHIDENTITY  **ppAuthIdentity, 
    IN BOOL            bCheckWithNullPwd,
    IN LPCWSTR         pwszNamespace,
    OUT HRESULT         *phRes,
    OUT BOOL            *pbLocalSystem
    )
/*++
Routine Description:
    Connects to wmi.

Arguments:
    [IN] pLocator      - Pointer to the IWbemLocator object.
    [OUT] ppServics    - Pointer to IWbemServices object.
    [IN] pwszServer    - Holds the server name to connect to.
    [OUT] pwszUser     - Holds the user name.
    [OUT] pwszPassword - Holds the password.
    [OUT] ppAuthIdentity  - Pointer to authentication structure.
    [IN] bCheckWithNullPwd   - Specifies whether to connect through null password.
    [IN] pwszNamespace       - Specifies the namespace to connect to.
    [OUT] hRes           - Holds the error value.
    [OUT] pbLocalSystem  - Holds the boolean value to represent whether the server
                           name is local or not.
Return Value:
    TRUE if successfully connected, FALSE if not.
--*/
{
    // local variables
    HRESULT hRes = 0;
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;
    _bstr_t bstrServer;
    _bstr_t bstrNamespace;
    _bstr_t bstrUser;
    _bstr_t bstrPassword;

    // clear the error
    SetLastError( WBEM_S_NO_ERROR );

    if ( NULL != pbLocalSystem )
    {
        *pbLocalSystem = FALSE;
    }
    if ( NULL != phRes )
    {
        *phRes = WBEM_S_NO_ERROR;
    }

    // check whether locator object exists or not
    // if not exists, return
    if ( ( NULL == pLocator ) ||
         ( NULL == ppServices ) ||
         ( NULL != *ppServices ) ||
         ( NULL == pwszNamespace ) ||
         ( NULL == pbLocalSystem ) )
    {
        if ( NULL != phRes )
        {
            *phRes = WBEM_E_INVALID_PARAMETER;
        }
        // return failure
        return FALSE;
    }

    try
    {
        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // validate the server name
        // NOTE: The error being raised in custom define for '0x800706ba' value
        //       The message that will be displayed in "The RPC server is unavailable."
        if ( FALSE == IsValidServerEx( pwszServer, bLocalSystem ) )
        {
            _com_issue_error( E_SERVER_NOTFOUND );
        }
        // validate the user name
        if ( FALSE == IsValidUserEx( pwszUser ) )
        {
            _com_issue_error( ERROR_NO_SUCH_USER );
        }
        // prepare namespace
        bstrNamespace = pwszNamespace;              // name space
        if ( ( NULL != pwszServer ) && ( FALSE == bLocalSystem ) )
        {
            // get the server name
            bstrServer = pwszServer;

            // prepare the namespace
            // NOTE: check for the UNC naming format of the server and do
            if ( TRUE == IsUNCFormat( pwszServer ) )
            {
                bstrNamespace = bstrServer + L"\\" + pwszNamespace;
            }
            else
            {
                bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
            }

            // user credentials
            if ( ( NULL != pwszUser ) && ( 0 != StringLength( pwszUser, 0 ) ) )
            {
                // copy the user name
                bstrUser = pwszUser;

                // if password is empty string and if we need to check with
                // null password, then do not set the password and try
                bstrPassword = pwszPassword;
                if ( ( TRUE == bCheckWithNullPwd ) && ( 0 == bstrPassword.length() ) )
                {
                    bstrPassword = (LPWSTR) NULL;
                }
            }
        }

        // connect to the remote system's WMI
        // there is a twist here ... 
        // do not trap the ConnectServer function failure into exception
        // instead handle that action manually
        // by default try the ConnectServer function as the information which we have
        // in our hands at this point. If the ConnectServer is failed, 
        // check whether password variable has any contents are not ... if no contents
        // check with "" (empty) password ... this might pass in this situation ..
        // if this call is also failed ... nothing is there that we can do ... throw the exception
        hRes = pLocator->ConnectServer( bstrNamespace, 
            bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
        if ( FAILED( hRes ) )
        {
            //
            // special case ...
    
            // check whether password exists or not
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'

            if ( E_ACCESSDENIED == hRes )
            {
                // check if we tried to connect to the system using null password
                // if so, then try connecting to the remote system with empty string
                if ( bCheckWithNullPwd == TRUE &&
                     bstrUser.length() != 0 && bstrPassword.length() == 0 )
                {
                    // now invoke with ...
                    hRes = pLocator->ConnectServer( bstrNamespace, 
                        bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
                }
            }
            else if ( WBEM_E_LOCAL_CREDENTIALS == hRes )
            {
                // credentials were passed to the local system. 
                // So ignore the credentials and try to reconnect
                bLocalSystem = TRUE;
                bstrUser = (LPWSTR) NULL;
                bstrPassword = (LPWSTR) NULL;
                bstrNamespace = pwszNamespace;              // name space
                hRes = pLocator->ConnectServer( bstrNamespace, 
                    NULL, NULL, 0L, 0L, NULL, NULL, ppServices );
                
                // check the result
                if ( SUCCEEDED( hRes ) && NULL != phRes )
                {
                    // set the last error
                    *phRes = WBEM_E_LOCAL_CREDENTIALS;
                }
            }
         else if ( REGDB_E_CLASSNOTREG == hRes )
         {
            SetReason( ERROR_REMOTE_INCOMPATIBLE );
            *phRes = REGDB_E_CLASSNOTREG;
            bResult = FALSE;
            return bResult;
         }

            // now check the result again .. if failed .. ummmm..
            if ( FAILED( hRes ) )
            {
                _com_issue_error( hRes );
            }
            else
            {
                bstrPassword = L"";
            }
        }

        // set the security at the interface level also
        SAFE_EXECUTE( SetInterfaceSecurity( *ppServices,
                        bstrUser, bstrPassword, ppAuthIdentity ) );

        // connection to WMI is successful
        bResult = TRUE;

        // save the hr value if needed by the caller
        if ( NULL != phRes )
        {
            *phRes = WBEM_S_NO_ERROR;
        }
        if ( NULL != pbLocalSystem )
        {
            *pbLocalSystem = bLocalSystem;
        }
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the error
        WMISaveError( e );

        // save the hr value if needed by the caller
        if ( NULL != phRes )
        {
            *phRes = e.Error();
        }
        SAFE_RELEASE( *ppServices );
        bResult = FALSE;

    }

    return bResult;
}

BOOL
ConnectWmiEx(
    IN IWbemLocator    *pLocator, 
    OUT IWbemServices   **ppServices,
    IN LPCWSTR         strServer,
    OUT CHString        &strUserName,
    OUT CHString        &strPassword, 
    OUT COAUTHIDENTITY  **ppAuthIdentity,
    IN BOOL            bNeedPassword,
    IN LPCWSTR         pwszNamespace,
    OUT BOOL            *pbLocalSystem
    )
/*++
Routine Description:
    Connects to wmi.

Arguments:
    [IN] pLocator         - Pointer to the IWbemLocator object.
    [OUT] ppServices      - Pointer to IWbemServices object.
    [IN] strServer        - Holds the server name to connect to.
    [OUT] strUserName     - Holds the user name.
    [OUT] strPassword     - Holds the password.
    [OUT] ppAuthIdentity  - Pointer to authentication structure.
    [IN] bNeedPassword    - Specifies whether to prompt for password.
    [IN] pwszNamespace    - Specifies the namespace to connect to.
    [OUT] pbLocalSystem   - Holds the boolean value to represent whether the server
                            name is local or not.
Return Value:
    TRUE if successfully connected, FALSE if not.
--*/
{
    // local variables
    HRESULT hRes = 0;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszPassword = NULL;

    try
    {

        CHString strBuffer = L"\0";

        // clear the error .. if any
        SetLastError( WBEM_S_NO_ERROR );

        // sometime users want the utility to prompt for the password
        // check what user wants the utility to do
        if ( TRUE == bNeedPassword && 0 == strPassword.Compare( L"*" ) )
        {
            // user wants the utility to prompt for the password
            // so skip this part and let the flow directly jump the password acceptance part
        }
        else
        {
            // try to establish connection to the remote system with the credentials supplied
            if ( 0 == strUserName.GetLength() )
            {
                // user name is empty
                // so, it is obvious that password will also be empty
                // even if password is specified, we have to ignore that
                bResult = ConnectWmi( pLocator, ppServices, 
                    strServer, NULL, NULL, ppAuthIdentity, 
                    FALSE, pwszNamespace, &hRes, pbLocalSystem );
            }
            else
            {
                // credentials were supplied
                // but password might not be specified ... so check and act accordingly
                LPCWSTR pwszTemp = NULL;
                BOOL bCheckWithNull = TRUE;
                if ( FALSE == bNeedPassword )
                {
                    pwszTemp = strPassword;
                    bCheckWithNull = FALSE;
                }

                // ...
                bResult = ConnectWmi( pLocator, ppServices, strServer, strUserName,
                    pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hRes, pbLocalSystem );
            }

            // check the result ... if successful in establishing connection ... return
            if ( TRUE == bResult )
            {
                SetLastError( hRes );           // set the error code
                return TRUE;
            }
            // now check the kind of error occurred
            switch( hRes )
            {
                case E_ACCESSDENIED:
                     break;
                case WBEM_E_LOCAL_CREDENTIALS:
                    // needs to do special processing
                    break;

                case WBEM_E_ACCESS_DENIED:
                default:
                    // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
                    //       this error code says that user with the current credentials is not
                    //       having access permisions to the 'namespace'
                    WMISaveError( hRes );
                    return FALSE;       // no use of accepting the password .. return failure
            }

            // if failed in establishing connection to the remote terminal
            // even if the password is specifed, then there is nothing to do ... simply return failure
            if ( FALSE == bNeedPassword )
            {
                    return( FALSE );
            }
        }
        
        // check whether user name is specified or not
        // if not, get the local system's current user name under whose credentials, the process
        // is running
        if ( 0 == strUserName.GetLength() )
        {
            // sub-local variables
            LPWSTR pwszUserName = NULL;

            // get the required buffer
            pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );

            // get the user name
            DWORD dwUserLength = MAX_STRING_LENGTH;
            if ( FALSE == GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) )
            {
                // error occured while trying to get the current user info
                SaveLastError();
                return( FALSE );
            }

            // release the extra buffer allocated
            strUserName.ReleaseBuffer();
        }

        // get the required buffer
        pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );

        // accept the password from the user
        strBuffer.Format( INPUT_PASSWORD, strUserName );
        WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ), 
                       strBuffer, strBuffer.GetLength(), &dwSize, NULL );
        bResult = GetPassword( pwszPassword, 256 );
        if ( TRUE != bResult )
        {
            return FALSE;
        }

        // release the buffer allocated for password
        strPassword.ReleaseBuffer();

        // now again try to establish the connection using the currently
        // supplied credentials
        bResult = ConnectWmi( pLocator, ppServices, strServer,
            strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, &hRes, pbLocalSystem );

    }
    catch(CHeap_Exception)
    {   
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }
    // return the success
    return bResult;

}

HRESULT
GetSecurityArguments(
    IN IUnknown *pInterface,
    OUT DWORD& dwAuthorization,
    OUT DWORD& dwAuthentication
    )
/*++
Routine Description:
    Gets the security arguments for an interface.

Arguments:
    [IN] pInterface         - Pointer to interface stucture.
    [OUT] dwAuthorization   - Holds Authorization value.
    [OUT] dwAuthentication  - Holds the Authentication value.

Return Value:
    Returns HRESULT value. 
--*/
{
    // local variables
    HRESULT hRes = S_OK;
    DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
    IClientSecurity *pClientSecurity = NULL;

    if( NULL == pInterface )
    {
       return WBEM_E_INVALID_PARAMETER;
    }


    // try to get the client security services values if possible
    hRes = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
    if ( SUCCEEDED( hRes ) )
    {
        // got the client security interface
        // now try to get the security services values
        hRes = pClientSecurity->QueryBlanket( pInterface, 
            &dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
        if ( SUCCEEDED( hRes ) )
        {
            // we've got the values from the interface
            dwAuthentication = dwAuthnSvc;
            dwAuthorization = dwAuthzSvc;
        }

        // release the client security interface
        SAFE_RELEASE( pClientSecurity );
    }

    // return always success
    return hRes;
}

HRESULT
SetInterfaceSecurity(
    IN IUnknown *pInterface,
    IN LPCWSTR pwszUser,
    IN LPCWSTR pwszPassword,
    OUT COAUTHIDENTITY **ppAuthIdentity
    )
/*++
Routine Description:
    Sets interface security.

Arguments:
    [IN] pInterface       - Pointer to the interface to which security has to be set.
    [IN] pwszUser         - Holds the user name of the server.
    [IN] pwszPassword     - Hold the password of the user.
    [OUT] ppAuthIdentity  - Pointer to authentication structure.

Return Value:
    returns HRESULT value. 
--*/
{
    // local variables
    HRESULT hRes = S_OK;
    CHString strUser;
    CHString strDomain;
    LPCWSTR pwszUserArg = NULL;
    LPCWSTR pwszDomainArg = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    try
    {

        // check the interface
        if ( NULL == pInterface )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        // check the authentity strcuture ... if authentity structure is already ready
        // simply invoke the 2nd version of SetInterfaceSecurity
        if ( NULL != *ppAuthIdentity )
        {
            return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
        }
        // get the current security argument value
        // GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

        // If we are doing trivial case, just pass in a null authenication structure 
        // for which the current logged in user's credentials will be considered
        if ( NULL == pwszUser && NULL == pwszPassword )
        {
            // set the security
            hRes = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, 
                NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

            // return the result
            return hRes;
        }

        // parse and find out if the user name contains the domain name
        // if contains, extract the domain value from it
        LONG lPos = -1;
        strDomain = L"";
        strUser = pwszUser;
        if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
        {
            // user name contains domain name ... domain\user format
            strDomain = strUser.Left( lPos );
            strUser = strUser.Mid( lPos + 1 );
        }

        // get the domain info if it exists only
        if ( 0 != strDomain.GetLength() )
        {
            pwszDomainArg = strDomain;
        }
        // get the user info if it exists only
        if ( 0 != strUser.GetLength() )
        {
            pwszUserArg = strUser;
        }
        // check if authenication info is available or not ...
        // initialize the security authenication information ... UNICODE VERSION STRUCTURE
        if ( NULL == ppAuthIdentity )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        else if ( NULL == *ppAuthIdentity )
        {
            hRes = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
            if ( FAILED(hRes) )
            {
                return hRes;
            }
        }

        // set the security information to the interface
        hRes = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

    }
    catch(CHeap_Exception)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    // return the result
    return hRes;

}

HRESULT
SetInterfaceSecurity(
    IN IUnknown *pInterface,
    IN COAUTHIDENTITY *pAuthIdentity
    )
/*++
Routine Description:
    Sets the interface security for the interface.  

Arguments:
    [IN] pInterface   - pointer to the interface.
    [IN] pAuthIdentity  - pointer to authentication structure.

Return Value:
    returns HRESULT value. 
--*/
{
    // local variables
    HRESULT hRes = S_OK;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    if ( NULL == pInterface )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    // get the current security argument value
    hRes = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
   if ( FAILED( hRes ) )
    {
        return hRes;
    }
    // set the security information to the interface
    hRes = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

    // return the result
    return hRes;
}

HRESULT
WINAPI SetProxyBlanket(
    IN IUnknown *pInterface,
    IN DWORD dwAuthnSvc,
    IN DWORD dwAuthzSvc,
    IN LPWSTR pwszPrincipal,
    IN DWORD dwAuthLevel,
    IN DWORD dwImpLevel,
    IN RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
    IN DWORD dwCapabilities
    )
/*++
Routine Description:
    Sets proxy blanket for the interface.

Arguments:
    [IN] pInterface      - pointer to the inteface.
    [IN] dwAuthnsvc      - Authentication service to use.
    [IN] dwAuthzSvc      - Authorization service to use.
    [IN] pwszPricipal    - Server principal name to use with the authentication service.
    [IN] dwAuthLevel     - Authentication level to use.
    [IN] dwImpLevel      - Impersonation level to use.
    [IN] pAuthInfo       - Identity of the client.
    [IN] dwCapabilities  - Capability flags.

Return Value:
    Return HRESULT value.
--*/
{
    // local variables
    HRESULT hRes = S_OK;
    IUnknown *pUnknown = NULL;
    IClientSecurity *pClientSecurity = NULL;

    // Validate input arguments.
    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if( ( NULL == pInterface ) ||
        ( ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) ) &&
          ( NULL != pAuthInfo ) )
      )
    {
        return( WBEM_E_INVALID_PARAMETER );
    }

    // get the IUnknown interface ... to check whether this is a valid interface or not
    hRes = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( FAILED( hRes ) )
    {
        return hRes;
    }
    // now get the client security interface
    hRes = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( FAILED( hRes ) )
    {
        SAFE_RELEASE( pUnknown );
        return hRes;
    }

    // now set the security
    hRes = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

    if( FAILED( hRes ) )
    {
        SAFE_RELEASE( pUnknown );
        SAFE_RELEASE( pClientSecurity );
        return hRes;
    }

    // release the security interface
    SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( NULL != pAuthInfo )
    {
        hRes = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( SUCCEEDED( hRes ) )
        {
            // set security authentication
            hRes = pClientSecurity->SetBlanket( 
                pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal, 
                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

            // release
            SAFE_RELEASE( pClientSecurity );
        }
        else if ( E_NOINTERFACE == hRes )
        {
            hRes = S_OK;        // ignore no interface errors
        }
    }

    // release the IUnknown
    SAFE_RELEASE( pUnknown );

    // return the result
    return hRes;
}

HRESULT
WINAPI WbemAllocAuthIdentity(
    IN LPCWSTR pwszUser,
    IN LPCWSTR pwszPassword, 
    IN LPCWSTR pwszDomain,
    OUT COAUTHIDENTITY **ppAuthIdent
    )
/*++
Routine Description:
    Allocate memory for authentication variables.

Arguments:
    [IN] pwszUser      - User name.
    [IN] pwszPassword  - Password.
    [IN] pwszDomain    - Domain name.
    [OUT] ppAuthIdent   - Pointer to authentication structure.

Return Value:
    Returns HRESULT value.
--*/
{
    // local variables
    COAUTHIDENTITY *pAuthIdent = NULL;

    // validate the input parameter
    if ( NULL == ppAuthIdent )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( pAuthIdent == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    // init with 0's
    SecureZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

    //
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong

    // user
    if ( NULL != pwszUser )
    {
        // allocate memory for user
        LONG lLength = StringLength( pwszUser, 0 ); 
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->User )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        StringCopy( pAuthIdent->User, pwszUser, (lLength + 1) );
    }

    // domain
    if ( NULL != pwszDomain )
    {
        // allocate memory for domain
        LONG lLength = StringLength( pwszDomain, 0 ); 
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Domain )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        StringCopy( pAuthIdent->Domain, pwszDomain, (lLength + 1) );
    }

    // passsord
    if ( NULL != pwszPassword )
    {
        // allocate memory for passsord
        LONG lLength = StringLength( pwszPassword, 0 ); 
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( NULL == pAuthIdent->Password )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        StringCopy( pAuthIdent->Password, pwszPassword, (lLength + 1) );
    }

    // type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
    *ppAuthIdent = pAuthIdent;

    // return result
    return S_OK;
}

VOID
WINAPI WbemFreeAuthIdentity(
    IN COAUTHIDENTITY** ppAuthIdentity
    )
/*++
Routine Description:
    Frees the memory of authentication stucture variable.

Arguments:
    [IN] ppAuthIdentity  - Pointer to authentication structure.

Return Value:
    none. 
--*/
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( NULL != *ppAuthIdentity )
    {
        // free the memory allocated for user
        if ( NULL != (*ppAuthIdentity)->User )
        {
            CoTaskMemFree( (*ppAuthIdentity)->User );
            (*ppAuthIdentity)->User = NULL; 
        }
        // free the memory allocated for password
        if ( NULL != (*ppAuthIdentity)->Password )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Password );
            (*ppAuthIdentity)->Password = NULL;
        }
        // free the memory allocated for domain
        if ( NULL != (*ppAuthIdentity)->Domain )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Domain );
            (*ppAuthIdentity)->Domain = NULL;
        }
        // final the structure
        CoTaskMemFree( *ppAuthIdentity );
        *ppAuthIdentity = NULL;
    }
}

VOID
WMISaveError(
    IN HRESULT hResError
    )
/*++
Routine Description:
    Gets WMI error description.

Arguments:
    [IN] hResError  - Contain error value.

Return Value:
    none.
--*/
{
    // local variables
    HRESULT hRes;
    IWbemStatusCodeText *pWbemStatus = NULL;

    CHString strBuffer = L"\0";

    // if the error is win32 based, choose FormatMessage to get the message
    switch( hResError )
    {
    case E_ACCESSDENIED:            // Message: "Access Denied"
    case ERROR_NO_SUCH_USER:        // Message: "The specified user does not exist."
        {
            // change the error message to "Logon failure: unknown user name or bad password." 
            if ( E_ACCESSDENIED == hResError )
            {
                hResError = ERROR_LOGON_FAILURE;
            }
            // ...
            SetLastError( hResError );
            SaveLastError();
            return;
        }
    case REGDB_E_CLASSNOTREG:       // Message: Class not registered.
     {
         SetLastError( hResError );
         SetReason( ERROR_REMOTE_INCOMPATIBLE );
         return;
     }

    }

    try
    {
        // get the pointer to buffer
        LPWSTR pwszBuffer = NULL;
        pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

        // get the wbem specific status code text
        hRes = CoCreateInstance( CLSID_WbemStatusCodeText, 
            NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, ( LPVOID* ) &pWbemStatus );

        // check whether we got the interface or not
        if ( SUCCEEDED( hRes ) )
        {
            // get the error message
            BSTR bstr = NULL;
            hRes = pWbemStatus->GetErrorCodeText( hResError, 0, 0, &bstr );
            if ( SUCCEEDED( hRes ) )
            {
                // get the error message in proper format
                StringCopyW( pwszBuffer, bstr, MAX_STRING_LENGTH );

                // free the BSTR
                SysFreeString( bstr );
                bstr = NULL;

                // now release status code interface
                SAFE_RELEASE( pWbemStatus );
            }
            else
            {
                // failed to get the error message ... get the com specific error message
                _com_issue_error( hResError );
            }
        }
        else
        {
            // failed to get the error message ... get the com specific error message
            _com_issue_error( hResError );
        }

        // release the buffer
        strBuffer.ReleaseBuffer();
        // set the reason
        strBuffer += L"\n";
        SetReason( strBuffer );

    }
    catch( _com_error& e )
    {
        try
        {
            // get the error message
            strBuffer.ReleaseBuffer();
            if ( NULL != e.ErrorMessage() )
            {
                strBuffer = e.ErrorMessage();
            }
        }
        catch( CHeap_Exception )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            SaveLastError();
        }
    }
    catch(CHeap_Exception)
    {   
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        return;
    }
}

DWORD
GetTargetVersionEx(
    IN IWbemServices* pWbemServices,
    IN COAUTHIDENTITY* pAuthIdentity
    )
/*++
Routine Description:
    Get the OS version of the target machine.
Arguments:
    [IN] pWbemServices - Pointer to IWbemServices object.
    [IN] pAuthIdentity - Poointer to authentication structure.
Return Value:
    0 if failed to get version number, else non-zero value.
--*/
{
    // local variables
    HRESULT hRes = S_OK;
    LONG lPos = 0;
    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwVersion = 0;
    ULONG ulReturned = 0;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;
    CHString strVersion;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );

    // Check the input value
    if ( NULL == pWbemServices )
    {
        WMISaveError( WBEM_E_INVALID_PARAMETER );
        return 0;
    }

    try
    {

        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
            _bstr_t( CLASS_CIMV2_Win32_OperatingSystem ),
             WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time. 
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( 0 == ulReturned )
        {
            // release the interfaces
            WMISaveError( WBEM_S_FALSE );
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( FALSE == PropertyGet( pWbemObject, L"Version", strVersion ) )
        {
            // release the interfaces
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
    
        //
        // now determine the os version
        dwMajor = dwMinor = 0;

        // get the major version
        lPos = strVersion.Find( L'.' );
        if ( -1 == lPos )
        {
            // the version string itself is version ... THIS WILL NEVER HAPPEN
            if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
            {
                return 0;
            }
            dwMajor = AsLong( strVersion, 10 );
        }
        else
        {
            // major version
            if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
            {
                return 0;
            }

            dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

            // get the minor version
            strVersion = strVersion.Mid( lPos + 1 );
            lPos = strVersion.Find( L'.' );
            if ( -1 == lPos )
            {
                if( FALSE == IsNumeric( strVersion, 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion, 10 );
            }
            else
            {
                if( FALSE == IsNumeric( strVersion.Mid( 0, lPos ), 10, FALSE ) )
                {
                    return 0;
                }
                dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
            }
        }

        // mix the version info
        dwVersion = dwMajor * 1000 + dwMinor;
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }
    catch(CHeap_Exception)
    {   
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
        return 0;
    }

    // return 
    return dwVersion;
}

BOOL
PropertyGet(
    IN IWbemClassObject* pWmiObject,
    IN LPCWSTR pwszProperty,
    OUT CHString& strValue,
    IN LPCWSTR pwszDefault
    )
/*++
Routine Description:
    Gets the value of the property from the WMI class object in string format
Arguments:
    [IN] pWmiObject   : pointer to the WBEM class object
    [IN] pwszProperty : the name of the property to retrieve
    [OUT] strValue    : variable to hold the retrieved property
    [IN] pwszDefault  : string containing the default value for the property
Return Value:
    TRUE on success
    FALSE on failure
NOTE: THIS FUNCTION SAVES LAST ERROR OCCURED. IF FALSE IS RETURNED THEN ERROR
      OCCURED STRING CAN BE RETRIEVED BY CALLING 'GetReason()'.
--*/
{
    // local variables
    HRESULT hRes = S_OK;
    _variant_t var;

    // Clear any errors.
    SetLastError( WBEM_S_NO_ERROR );
    strValue.Empty();

    try
    {
        // first copy the default value
        strValue = pwszDefault;

        // Validate input arguments.
        if ( ( NULL == pWmiObject ) ||
             ( NULL == pwszProperty ) )
        {
            _com_issue_error( WBEM_E_INVALID_PARAMETER );
        }

        // get the property value
        hRes = PropertyGet( pWmiObject, pwszProperty, var );
        if ( FAILED( hRes ) )
        {
            _com_issue_error( hRes );
        }

        // Get the value
        // If 'var' does not contain value of requested type
        // then default value is returned.
        if ( VT_BSTR == V_VT( &var ) )
        {
            strValue = (LPCWSTR) _bstr_t( var );
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        WMISaveError( WBEM_E_OUT_OF_MEMORY );
        return FALSE;
    }

    // return
    return TRUE;
}

HRESULT
PropertyGet(
    IN IWbemClassObject* pWmiObject,
    IN LPCWSTR pwszProperty,
    OUT _variant_t& varValue
    )
/*++
Routine Description:
    Gets the value of the property from the WMI class object
Arguments:
    [IN] pWmiObject   : pointer to the WBEM class object
    [IN] pwszProperty : property name
    [OUT] varValue    : value of the property
Return Value:
    HRESULT
--*/
{
    // local variables
    HRESULT hRes = S_OK;
    VARIANT vtValue;

    // Validate input arguments.
    if ( ( NULL == pWmiObject ) ||
         ( NULL == pwszProperty ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // initialize the variant and then get the value of the specified property
        VariantInit( &vtValue );
        // Call 'Get' method to retireve the value from WMI.
        hRes = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
        if ( FAILED( hRes ) )
        {
            // Clear the variant variable
            VariantClear( &vtValue );
            // Return error.
            return hRes;
        }

        // set the value
        varValue = vtValue;
    }
    catch( _com_error& e )
    {
        hRes = e.Error();
    }

    // Clear the variables.
    VariantClear( &vtValue );
    // Return.
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\getmac\getmac.cpp ===
/*++
    Copyright (c) Microsoft Corporation

Module Name:
    GETMAC.CPP

Abstract:
    Get MAC addresses and the related information of the network
    adapters that exists either on a local system or on a remote system.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 26-sep-2k : Created It.
    Vasundhara .G 31-oct-2k : Modified It. 
                        Moved all hard coded string to header file.
--*/

// Include files
#include "pch.h"
#include "getmac.h"
#include "resource.h"

//  function prototypes
BOOL
ParseCmdLine(
    IN DWORD      argc,
    IN LPCTSTR    argv[],
    OUT CHString& strMachineName,
    OUT CHString& strUserName,
    OUT CHString& strPassword,
    OUT CHString& strFormat,
    OUT BOOL      *pbVerbose,
    OUT BOOL      *pbHeader,
    OUT BOOL      *pbUsage,
    OUT BOOL      *pbNeedPassword
    );

BOOL
DisplayUsage(
    );

BOOL
ComInitialize(
    OUT IWbemLocator **ppIWbemLocator
    );

BOOL
GetMacData(
    OUT TARRAY              arrMacData,
    IN LPCTSTR              lpMachineName,
    IN IEnumWbemClassObject *pAdapterConfig,
    IN COAUTHIDENTITY       *pAuthIdentity,
    IN IWbemServices        *pIWbemServiceDef,
    IN IWbemServices        *pIWbemServices,
    IN TARRAY               arrNetProtocol
    );

BOOL
GetW2kMacData(
    OUT TARRAY              arrMacData,
    IN LPCTSTR              lpMachineName, 
    IN IEnumWbemClassObject *pAdapterConfig,
    IN IEnumWbemClassObject *pAdapterSetting,
    IN IWbemServices        *pIWbemServiceDef,
    IN IWbemServices        *pIWbemServices,
    IN COAUTHIDENTITY       *pAuthIdentity,
    IN TARRAY               arrNetProtocol
    );

BOOL
GetTransName(
    IN IWbemServices  *pIWbemServiceDef,
    IN IWbemServices  *pIWbemServices,
    IN TARRAY         arrNetProtocol,
    OUT TARRAY        arrTransName,
    IN COAUTHIDENTITY *pAuthIdentity,
    IN LPCTSTR        lpMacAddr
    );

BOOL
GetConnectionName(
    OUT TARRAY              arrMacData,
    IN DWORD                dwIndex,
    IN LPCTSTR              lpFormAddr,
    IN IEnumWbemClassObject *pAdapterSetting,
    IN IWbemServices        *pIWbemServiceDef
    );

BOOL
GetNwkProtocol(
    OUT TARRAY              arrNetProtocol,
    IN IEnumWbemClassObject *pNetProtocol
    );

BOOL
FormatHWAddr(
    IN LPTSTR  lpRawAddr,
    OUT LPTSTR lpFormattedAddr,
    IN LPCTSTR lpFormatter
    );

BOOL
DisplayResults(
    IN TARRAY  arrMacData,
    IN LPCTSTR lpFormat,
    IN BOOL    bHeader,
    IN BOOL    bVerbose
    );

BOOL
CallWin32Api(
    OUT LPBYTE *lpBufptr,
    IN LPCTSTR lpMachineName,
    OUT DWORD  *pdwNumofEntriesRead
    );

BOOL
CheckVersion(
    IN BOOL           bLocalSystem,
    IN COAUTHIDENTITY *pAuthIdentity,
    IN IWbemServices  *pIWbemServices
    );

DWORD
_cdecl _tmain(
    IN DWORD   argc,
    IN LPCTSTR argv[]
    )
/*++
Routine Description:
    Main function which calls all the other functions depending on the
    option specified by the user.

Arguments:
    [IN] argc - Number of command line arguments.
    [IN] argv - Array containing command line arguments.

Return Value:
    EXIT_FAILURE if Getmac utility is not successful.
    EXIT_SUCCESS if Getmac utility is successful.
--*/
{
    //local variables
    HRESULT  hRes = WBEM_S_NO_ERROR;
    HRESULT  hResult = WBEM_S_NO_ERROR;

    TARRAY               arrMacData = NULL;
    TARRAY               arrNetProtocol = NULL;
    IWbemLocator         *pIWbemLocator = NULL;
     IWbemServices       *pIWbemServices = NULL;
    IWbemServices        *pIWbemServiceDef = NULL;
    IEnumWbemClassObject *pAdapterConfig = NULL;
    IEnumWbemClassObject *pNetProtocol = NULL;
    IEnumWbemClassObject *pAdapterSetting = NULL;
    COAUTHIDENTITY       *pAuthIdentity = NULL;

    BOOL bHeader = FALSE;
    BOOL bUsage = FALSE;
    BOOL bVerbose = FALSE;
    BOOL bFlag = FALSE;
    BOOL bNeedPassword = FALSE;
    BOOL bCloseConnection = FALSE;
    BOOL bLocalSystem = FALSE;

    if ( NULL == argv )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    try
    {
        CHString strUserName = L"\0";
        CHString strPassword = L"\0";
        CHString strMachineName = L"\0";
        CHString strFormat = L"\0";

        //initialize dynamic array
        arrMacData  = CreateDynamicArray();
        if( NULL == arrMacData )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        //parse the command line arguments
        bFlag = ParseCmdLine( argc, argv, strMachineName, strUserName,
              strPassword, strFormat, &bVerbose, &bHeader, &bUsage,
              &bNeedPassword );

        //if syntax of command line arguments is false display the error
        //and exit
        if( FALSE == bFlag )
        {
            DestroyDynamicArray( &arrMacData );
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        //if usage is specified at command line, display usage
        if( TRUE == bUsage )
        {
            DisplayUsage();
            DestroyDynamicArray( &arrMacData );
            ReleaseGlobals();
            return( EXIT_SUCCESS );
        }

        //initialize com library
        bFlag = ComInitialize( &pIWbemLocator );
        //failed to initialize com or get IWbemLocator interface
        if( FALSE == bFlag ) 
        {
            SAFERELEASE( pIWbemLocator );
            CoUninitialize();
            DestroyDynamicArray( &arrMacData );
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        // connect to CIMV2 name space
        bFlag = ConnectWmiEx( pIWbemLocator, &pIWbemServices, strMachineName,
                 strUserName, strPassword, &pAuthIdentity, bNeedPassword,
                 WMI_NAMESPACE_CIMV2, &bLocalSystem );

        //if unable to connect to wmi exit failure
        if( FALSE == bFlag )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SAFERELEASE( pIWbemLocator );
            SAFERELEASE( pIWbemServices );
            WbemFreeAuthIdentity( &pAuthIdentity );
            CoUninitialize();
            DestroyDynamicArray( &arrMacData );
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        // set the security on the obtained interface
        hRes = SetInterfaceSecurity( pIWbemServices, pAuthIdentity );
        ONFAILTHROWERROR( hRes );

        //connect to default namespace
        bFlag = ConnectWmi( pIWbemLocator, &pIWbemServiceDef, strMachineName,
                 strUserName, strPassword, &pAuthIdentity, bNeedPassword,
                 WMI_NAMESPACE_DEFAULT, &hResult, &bLocalSystem );
        ONFAILTHROWERROR( hResult );

        // set the security on the obtained interface
        hRes = SetInterfaceSecurity( pIWbemServiceDef, pAuthIdentity );
        ONFAILTHROWERROR( hRes );

        //get handle to win32_networkadapter class
        hRes = pIWbemServices->CreateInstanceEnum( 
                          _bstr_t( NETWORK_ADAPTER_CLASS ),
                          WBEM_FLAG_RETURN_IMMEDIATELY,
                          NULL, &pAdapterConfig );
        //if failed to enumerate win32_networkadapter class
        ONFAILTHROWERROR( hRes );

        // set the security on the obtained interface
        hRes = SetInterfaceSecurity( pAdapterConfig, pAuthIdentity );
        //if failed to set security throw error
        ONFAILTHROWERROR( hRes );

        // get handle to win32_networkprotocol
        hRes = pIWbemServices->CreateInstanceEnum( _bstr_t( NETWORK_PROTOCOL ),
                          WBEM_FLAG_RETURN_IMMEDIATELY,
                          NULL, &pNetProtocol );
        //if failed to enumerate win32_networkprotocol class
        ONFAILTHROWERROR( hRes );

        // set the security on the obtained interface
        hRes = SetInterfaceSecurity( pNetProtocol, pAuthIdentity );
        //if failed to set security throw error
        ONFAILTHROWERROR( hRes );

        //get handle to win32_networkadapterconfiguration class
        hRes = pIWbemServices->CreateInstanceEnum(
                          _bstr_t( NETWORK_ADAPTER_CONFIG_CLASS ),
                          WBEM_FLAG_RETURN_IMMEDIATELY,
                          NULL, &pAdapterSetting );
        //if failed to enumerate win32_networkadapterconfiguration class
        ONFAILTHROWERROR( hRes );

        // set the security on the obtained interface
        hRes = SetInterfaceSecurity( pAdapterSetting, pAuthIdentity );
        //if failed to set security throw error
        ONFAILTHROWERROR( hRes );

        arrNetProtocol  = CreateDynamicArray();
        if( NULL == arrNetProtocol )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SAFERELEASE( pIWbemLocator );
            SAFERELEASE( pIWbemServices );
            SAFERELEASE( pIWbemServiceDef );
            SAFERELEASE( pAdapterConfig );
            SAFERELEASE( pAdapterSetting );
            SAFERELEASE( pNetProtocol );
            WbemFreeAuthIdentity( &pAuthIdentity );
            CoUninitialize();
            DestroyDynamicArray( &arrMacData );
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }

        //enumerate all the network protocols
        bFlag =  GetNwkProtocol( arrNetProtocol, pNetProtocol );
        if( FALSE == bFlag )
        {
            SAFERELEASE( pIWbemLocator );
            SAFERELEASE( pIWbemServices );
            SAFERELEASE( pIWbemServiceDef );
            SAFERELEASE( pAdapterConfig );
            SAFERELEASE( pAdapterSetting );
            SAFERELEASE( pNetProtocol );
            WbemFreeAuthIdentity( &pAuthIdentity );
            CoUninitialize();
            DestroyDynamicArray( &arrMacData );
            DestroyDynamicArray( &arrNetProtocol );
            ReleaseGlobals();
            return( EXIT_FAILURE );
        }
        else if( 0 == DynArrayGetCount( arrNetProtocol ) )
        {
            ShowMessage( stdout, NO_NETWOK_PROTOCOLS );
            SAFERELEASE( pIWbemLocator );
            SAFERELEASE( pIWbemServices );
            SAFERELEASE( pIWbemServiceDef );
            SAFERELEASE( pAdapterConfig );
            SAFERELEASE( pAdapterSetting );
            SAFERELEASE( pNetProtocol );
            WbemFreeAuthIdentity( &pAuthIdentity );
            CoUninitialize();
        }
        else
        {
            //check whether the remote system under query is win2k or above
            if( TRUE == CheckVersion( bLocalSystem,
                                      pAuthIdentity, pIWbemServices ) )
            {
                // establish connection to remote system by using
                //win32api function
                if( FALSE == bLocalSystem )
                {
                    LPCWSTR pwszUser = NULL;
                    LPCWSTR pwszPassword = NULL;

                    // identify the password to connect to the remote system
                    if( NULL != pAuthIdentity )
                    {
                        pwszPassword = pAuthIdentity->Password;
                        if( 0 != strUserName.GetLength() )
                        {
                            pwszUser = strUserName;
                        }
                    }

                    // connect to the remote system
                    DWORD dwConnect = 0;
                    dwConnect = ConnectServer( strMachineName, pwszUser,
                                         pwszPassword );
                    // check the result
                    if( NO_ERROR != dwConnect )
                    {
                        //if session already exists display warning that
                        //credentials conflict and proceed
                        if( ERROR_SESSION_CREDENTIAL_CONFLICT == GetLastError() )
                        {
                            SetLastError( ERROR_SESSION_CREDENTIAL_CONFLICT );
                            SaveLastError();
                            ShowLastErrorEx( stderr, SLE_TYPE_WARNING | SLE_INTERNAL );
                        }
                        else if( ERROR_EXTENDED_ERROR == dwConnect )
                        {
                            ShowLastErrorEx( stdout, SLE_TYPE_ERROR | SLE_INTERNAL );
                            SAFERELEASE( pIWbemLocator );
                            SAFERELEASE( pIWbemServices );
                            SAFERELEASE( pAdapterConfig );
                            SAFERELEASE( pNetProtocol );
                            SAFERELEASE( pAdapterSetting );
                            SAFERELEASE( pIWbemServiceDef );
                            WbemFreeAuthIdentity( &pAuthIdentity );
                            CoUninitialize();
                            DestroyDynamicArray( &arrMacData );
                            DestroyDynamicArray( &arrNetProtocol );
                            ReleaseGlobals();
                            return( EXIT_SUCCESS );
                        }
                        else
                        {
                            SetLastError( dwConnect );
                            SaveLastError();
                            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                            SAFERELEASE( pIWbemLocator );
                            SAFERELEASE( pIWbemServices );
                            SAFERELEASE( pAdapterConfig );
                            SAFERELEASE( pNetProtocol );
                            SAFERELEASE( pAdapterSetting );
                            SAFERELEASE( pIWbemServiceDef );
                            WbemFreeAuthIdentity( &pAuthIdentity );
                            CoUninitialize();
                            DestroyDynamicArray( &arrMacData );
                            DestroyDynamicArray( &arrNetProtocol );
                            ReleaseGlobals();
                            return( EXIT_SUCCESS );
                        }
                    }
                    else
                    {
                        // connection needs to be closed
                        bCloseConnection = TRUE;
                     }
                }
                bFlag = GetW2kMacData( arrMacData, strMachineName, pAdapterConfig,
                            pAdapterSetting, pIWbemServiceDef, pIWbemServices,
                            pAuthIdentity, arrNetProtocol );

                //close the connection that is established by win32api
                if( TRUE == bCloseConnection )
                {
                    CloseConnection( strMachineName );
                }
            }
            else
            {
                bFlag = GetMacData( arrMacData, strMachineName, pAdapterConfig,
                            pAuthIdentity, pIWbemServiceDef, pIWbemServices,
                            arrNetProtocol );
            }
            // no more required
            WbemFreeAuthIdentity( &pAuthIdentity );
            SAFERELEASE( pIWbemLocator );
            SAFERELEASE( pIWbemServices );
            SAFERELEASE( pAdapterConfig );
            SAFERELEASE( pNetProtocol );
            SAFERELEASE( pAdapterSetting );
            SAFERELEASE( pIWbemServiceDef );
            CoUninitialize();

            // if getmacdata() function fails exit with failure code
            if( FALSE == bFlag )
            {
                DestroyDynamicArray( &arrMacData );
                DestroyDynamicArray( &arrNetProtocol );
                ReleaseGlobals();
                return( EXIT_FAILURE );
            }

            //show the results if atleast one entry exists in dynamic array

            if( 0 != DynArrayGetCount( arrMacData ) )
            {
                if( TRUE == bLocalSystem )
                {
                    if( 0 < strUserName.GetLength() )
                    {
                        ShowMessage( stderr, IGNORE_LOCALCREDENTIALS );
                    }
                }
                bFlag = DisplayResults( arrMacData, strFormat, bHeader, bVerbose );
                if( FALSE == bFlag )
                {
                    DestroyDynamicArray( &arrMacData );
                    DestroyDynamicArray( &arrNetProtocol );
                    ReleaseGlobals();
                    return( EXIT_FAILURE );
                }
            }
            else
            {
                ShowMessage( stdout, NO_NETWORK_ADAPTERS );
            }
        }
        //successfully retrieved the data then exit with EXIT_SUCCESS code
        DestroyDynamicArray( &arrMacData );
        DestroyDynamicArray( &arrNetProtocol );
        ReleaseGlobals();
        return( EXIT_SUCCESS );
    }
    catch(_com_error& e)
    {
        WMISaveError( e.Error() );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFERELEASE( pIWbemLocator );
        SAFERELEASE( pIWbemServices );
        SAFERELEASE( pIWbemServiceDef );
        SAFERELEASE( pAdapterConfig );
        SAFERELEASE( pAdapterSetting );
        SAFERELEASE( pNetProtocol );
        WbemFreeAuthIdentity( &pAuthIdentity );
        CoUninitialize();
        DestroyDynamicArray( &arrMacData );
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }
    catch( CHeap_Exception)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFERELEASE( pIWbemLocator );
        SAFERELEASE( pIWbemServices );
        SAFERELEASE( pAdapterConfig );
        SAFERELEASE( pNetProtocol );
        SAFERELEASE( pAdapterSetting );
        SAFERELEASE( pIWbemServiceDef );
        WbemFreeAuthIdentity( &pAuthIdentity );
        CoUninitialize();
        DestroyDynamicArray( &arrMacData );
        DestroyDynamicArray( &arrNetProtocol );
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }
}

BOOL
ParseCmdLine(
    IN DWORD     argc,
    IN LPCTSTR   argv[],
    OUT CHString& strMachineName,
    OUT CHString& strUserName,
    OUT CHString& strPassword,
    OUT CHString& strFormat,
    OUT BOOL      *pbVerbose,
    OUT BOOL      *pbHeader,
    OUT BOOL      *pbUsage,
    OUT BOOL      *pbNeedPassword
    )
/*++
Routine Description:
    This function parses the command line arguments which
    are obtained as input parameters and gets the values
    into the corresponding variables which are pass by address
    parameters to this function.

Arguments:
    [IN] argc                   - Number of command line arguments.
    [IN] argv                  - Array containing command line arguments.
    [OUT] strMachineName     - To hold machine name.
    [OUT] strUserName        - To hold User name.
    [OUT] strPassword        - To hold Password.
    [OUT] strFormat          - To hold the formatted string.
    [OUT] pbVerbose          - tells whether verbose option is specified.
    [OUT] pbHeader           - Header to required or not.
    [OUT] pbUsage            - usage is mentioned at command line.
    [OUT] pbNeedPassword     - Set to true if -p option is not specified
                               at cmdline.
Return Value:
    TRUE  if command parser succeeds.
    FALSE if command parser fails .
--*/
{
    //local varibles
    BOOL        bFlag = FALSE;
    TCMDPARSER2 tcmdOptions[MAX_OPTIONS];
    TCMDPARSER2 *pcmdParser = NULL;

    // temp variables
    LPWSTR pwszMachineName = NULL;
    LPWSTR pwszUserName = NULL;
    LPWSTR pwszPassword = NULL;
    LPWSTR pwszFormat = NULL;

    //validate input parameters
    if( ( NULL == pbVerbose ) || ( NULL == pbHeader )
          || ( NULL == pbUsage ) || ( NULL == pbNeedPassword ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return FALSE;
    }

    try
    {
        pwszMachineName = strMachineName.GetBufferSetLength( MAX_STRING_LENGTH );
        pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
        pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
        pwszFormat = strFormat.GetBufferSetLength( MAX_STRING_LENGTH );

        // init the password with '*'
        StringCopy( pwszPassword, L"*", MAX_STRING_LENGTH );
    }
    catch( ... )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return FALSE;
    }

    //Initialize the valid command line arguments

    //machine option
    pcmdParser = tcmdOptions + CMD_PARSE_SERVER;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_TEXT;
    pcmdParser->pwszOptions = CMDOPTION_SERVER;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pwszMachineName;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // username option
    pcmdParser = tcmdOptions + CMD_PARSE_USER;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_TEXT;
    pcmdParser->pwszOptions = CMDOPTION_USER;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pwszUserName;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // password option
    pcmdParser = tcmdOptions + CMD_PARSE_PWD;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_TEXT;
    pcmdParser->pwszOptions = CMDOPTION_PASSWORD;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = CP2_VALUE_OPTIONAL;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pwszPassword;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    // format option
    pcmdParser = tcmdOptions + CMD_PARSE_FMT;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_TEXT;
    pcmdParser->pwszOptions = CMDOPTION_FORMAT;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = FORMAT_TYPES;
    pcmdParser->dwFlags    = CP2_MODE_VALUES|CP2_VALUE_TRIMINPUT|CP2_VALUE_NONULL;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pwszFormat;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    //usage option
    pcmdParser = tcmdOptions + CMD_PARSE_USG;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = CMDOPTION_USAGE;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = CP2_USAGE;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbUsage;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    //header option
    pcmdParser = tcmdOptions + CMD_PARSE_HRD;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = CMDOPTION_HEADER;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbHeader;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;


    //verbose option
    pcmdParser = tcmdOptions + CMD_PARSE_VER;

    StringCopyA( pcmdParser->szSignature, "PARSER2\0", 8 );

    pcmdParser->dwType = CP_TYPE_BOOLEAN;
    pcmdParser->pwszOptions = CMDOPTION_VERBOSE;
    pcmdParser->pwszFriendlyName = NULL;
    pcmdParser->pwszValues = NULL;
    pcmdParser->dwFlags    = 0;
    pcmdParser->dwCount    = 1;
    pcmdParser->dwActuals  = 0;
    pcmdParser->pValue     = pbVerbose;
    pcmdParser->dwLength    = MAX_STRING_LENGTH;
    pcmdParser->pFunction     = NULL;
    pcmdParser->pFunctionData = NULL;
    pcmdParser->dwReserved = 0;
    pcmdParser->pReserved1 = NULL;
    pcmdParser->pReserved2 = NULL;
    pcmdParser->pReserved3 = NULL;

    //parse the command line arguments
    bFlag = DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(tcmdOptions), tcmdOptions, 0);

    // release buffers allocated for temp variables
    strMachineName.ReleaseBuffer();
    strUserName.ReleaseBuffer();
    strPassword.ReleaseBuffer();
    strFormat.ReleaseBuffer();

    //if syntax of command line arguments is false display the error and exit
    if( FALSE == bFlag )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return( FALSE );
    }

    //if usage is specified at command line, then check whether any other
    //arguments are entered at the command line and if so display syntax
    //error 
    if( ( TRUE == *pbUsage ) && ( 2 < argc ) )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ShowMessage( stderr, ERROR_TYPE_REQUEST );
        return( FALSE );
    }

    // return false if username is entered without machine name
    if ( ( 0 != tcmdOptions[ CMD_PARSE_USER ].dwActuals ) &&
            ( 0 == tcmdOptions[ CMD_PARSE_SERVER ].dwActuals ) )
    {
        ShowMessage( stderr, ERROR_USER_WITH_NOSERVER );
        return( FALSE );
    }

    //if password entered without username then return false
    if( ( 0 == tcmdOptions[ CMD_PARSE_USER ].dwActuals ) &&
            ( 0 != tcmdOptions[ CMD_PARSE_PWD ].dwActuals ) )
    {
        ShowMessage( stderr, ERROR_SERVER_WITH_NOPASSWORD );
        return( FALSE );
    }

    //if no header is specified with list format return FALSE else return TRUE
    if( ( 0 == ( StringCompare( GetResString( FR_LIST ), strFormat, TRUE, 0 ) ) )
                    && ( TRUE == *pbHeader ) ) 
    {
        ShowMessage( stderr, ERROR_INVALID_HEADER_OPTION );
        return( FALSE );
    }

    //if -s is entered with empty string
    if( ( 0 != tcmdOptions[ CMD_PARSE_SERVER ].dwActuals ) && 
                ( 0 == StringLength( strMachineName, 0 ) ) )
    {
        ShowMessage( stderr, ERROR_NULL_SERVER );
        return( FALSE );
    }

    //if -u is entered with empty string
    if( ( 0 != tcmdOptions[ CMD_PARSE_USER ].dwActuals ) &&
                ( 0 == StringLength( strUserName, 0 ) ) )
    {
        ShowMessage( stderr, ERROR_NULL_USER );
        return( FALSE );
    }

    if ( 0 != tcmdOptions[ CMD_PARSE_PWD ].dwActuals &&
        ( 0 == strPassword.Compare( L"*" ) ) )
    {
        // user wants the utility to prompt for the password before trying to connect
        *pbNeedPassword = TRUE;
    }
    else if ( ( 0 == tcmdOptions[ CMD_PARSE_PWD ].dwActuals ) && 
        ( 0 != tcmdOptions[ CMD_PARSE_SERVER ].dwActuals ||
          0 !=tcmdOptions[ CMD_PARSE_USER ].dwActuals ) )
    {
        // -s, -u is specified without password ...
        // utility needs to try to connect first and if it fails then prompt for the password
        *pbNeedPassword = TRUE;
        strPassword.Empty();
    }

    //return true
    return( TRUE );
}

BOOL
DisplayUsage(
    )
/*++
Routine Description:
    This function displays the usage of getmac.exe.

Arguments:
    None.

Return Value:
    TRUE 
--*/
{
    DWORD dwIndex = 0;

    //redirect the usage to the console
    for( dwIndex = IDS_USAGE_BEGINING; dwIndex <= USAGE_END; dwIndex++ )
    {
        ShowMessage( stdout, GetResString( dwIndex ) );
    }
    return (TRUE);
}

BOOL
ComInitialize(
    OUT IWbemLocator **ppIWbemLocator
    )
/*++
Routine Description:
    This function initializes the com and set security

Arguments:
    [OUT] ppIWbemLocator - pointer to IWbemLocator.

Return Value:
    TRUE if initialize is successful.
    FALSE if initialization fails.
--*/
{
    HRESULT  hRes = S_OK;

    try
    {
        hRes = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
        // COM initialization failed
        ONFAILTHROWERROR( hRes );

        // Initialize COM security for DCOM services, Adjust security to 
        // allow client impersonation
        hRes = CoInitializeSecurity( NULL, -1, NULL, NULL,
                            RPC_C_AUTHN_LEVEL_NONE, 
                            RPC_C_IMP_LEVEL_IMPERSONATE, 
                            NULL, EOAC_NONE, 0 );
        // COM security failed
        ONFAILTHROWERROR( hRes );

        //get IWbemLocator
        hRes = CoCreateInstance( CLSID_WbemLocator, 0, 
                  CLSCTX_INPROC_SERVER, IID_IWbemLocator,
                  (LPVOID *) ppIWbemLocator ); 
        //unable to get IWbemLocator
        ONFAILTHROWERROR( hRes );

    }
    catch( _com_error& e )
    {
        WMISaveError( e.Error() );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return( FALSE );
    }
    return( TRUE );
}

BOOL
GetMacData(
    OUT TARRAY             arrMacData,
    IN LPCTSTR          lpMachineName,
    IN IEnumWbemClassObject   *pAdapterConfig,
    IN COAUTHIDENTITY         *pAuthIdentity,
    IN IWbemServices        *pIWbemServiceDef,
    IN IWbemServices        *pIWbemServices,
    IN TARRAY               arrNetProtocol
    )
/*++
Routine Description:
    This function gets the media access control address of
    the network adapters which are there either in the local
    or on the remote network system of OS whistler and above.

Arguments:
    [OUT] arrMacData    - contains the MAC and other data of the
                          network adapter.
    [IN] lpMachineName     - holds machine name.
    [IN] pAdapterConfig    - interface to win32_networkadapter class.
    [IN] pAuthIdentity     - pointer to authentication structure.
    [IN] pIWbemServiceDef  - interface to default name space.
    [IN] pIWbemServices    - interface to cimv2 name space.
    [IN] arrNetProtocol    - interface to win32_networkprotocol class.

Return Value:
    TRUE if getmacdata is successful.
    FALSE if getmacdata failed.
--*/
{
    //local variables
    HRESULT           hRes = S_OK;
    IWbemClassObject  *pAdapConfig = NULL;
    DWORD          dwReturned  = 1;
    DWORD          i = 0;
    BOOL           bFlag = TRUE;
    TARRAY         arrTransName = NULL;

    VARIANT           varTemp;
    VARIANT           varStatus;

    //validate input parametrs
    if( ( NULL == arrMacData ) || ( NULL == lpMachineName ) ||
      ( NULL == pAdapterConfig ) || ( NULL == pIWbemServiceDef ) ||
         ( NULL == pIWbemServices ) || ( NULL == arrNetProtocol ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return FALSE;
    }

    //get the mac ,network adapter type and other details
    VariantInit( &varTemp );
    VariantInit( &varStatus );
    try
    {
        CHString strAType = L"\0";

        while ( ( 1 == dwReturned ) )
        {
            // Enumerate through the resultset.
            hRes = pAdapterConfig->Next( WBEM_INFINITE,
                            1,          
                            &pAdapConfig,  
                            &dwReturned ); 
            ONFAILTHROWERROR( hRes );
            if( 0 == dwReturned )
            {
                break;
            }
            hRes = pAdapConfig->Get( NETCONNECTION_STATUS, 0 , &varStatus,
                                                    0, NULL );
            ONFAILTHROWERROR( hRes );

            if ( VT_NULL == varStatus.vt )
            {
                continue;
            }
            DynArrayAppendRow( arrMacData, 0 );
            hRes = pAdapConfig->Get( HOST_NAME, 0 , &varTemp, 0, NULL );
            ONFAILTHROWERROR( hRes );
            if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
            {
                strAType = varTemp.bstrVal;
            }
            else
            {
                strAType = NOT_AVAILABLE; 
            }
            VariantClear( &varTemp );
            DynArrayAppendString2( arrMacData, i, strAType, 0 );//machine name

            hRes = pAdapConfig->Get( NETCONNECTION_ID, 0 , &varTemp, 0, NULL );
            ONFAILTHROWERROR( hRes );
            if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
            {
                strAType = varTemp.bstrVal;
            }
            else
            {
                strAType = NOT_AVAILABLE; 
            }
            VariantClear( &varTemp );
            DynArrayAppendString2( arrMacData, i, strAType, 0 );// connection name 

            hRes = pAdapConfig->Get( NAME, 0 , &varTemp, 0, NULL );
            ONFAILTHROWERROR( hRes );
            if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
            {
                strAType = varTemp.bstrVal;
            }
            else
            {
                strAType = NOT_AVAILABLE; 
            }
            VariantClear( &varTemp );
            DynArrayAppendString2( arrMacData, i, strAType, 0 );//Network adapter

            hRes = pAdapConfig->Get( ADAPTER_MACADDR, 0 , &varTemp, 0, NULL );
            ONFAILTHROWERROR( hRes );
            if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
            {
                strAType = varTemp.bstrVal;
                for( int j = 2; j < strAType.GetLength();j += 3 )
                {
                    strAType.SetAt( j, HYPHEN_CHAR );
                }
            }
            else if( 0 == varStatus.lVal )
            {
                strAType = DISABLED;
            }
            else
            {
                strAType = NOT_AVAILABLE; 
            }
            VariantClear( &varTemp );
            DynArrayAppendString2( arrMacData, i, strAType, 0 ); //MAC address

            arrTransName = CreateDynamicArray();
            if( NULL == arrTransName )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                VariantClear( &varTemp );
                VariantClear( &varStatus );
                SAFERELEASE( pAdapConfig );
                return( FALSE );
            }
            if( 2 == varStatus.lVal )
            {
                hRes = pAdapConfig->Get( DEVICE_ID, 0 , &varTemp, 0, NULL );
                ONFAILTHROWERROR( hRes );
                if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
                {
                    strAType = ( LPCWSTR ) _bstr_t( varTemp );
                }
                    bFlag = GetTransName( pIWbemServiceDef, pIWbemServices,
                      arrNetProtocol,   arrTransName,pAuthIdentity,   strAType );
                if( FALSE == bFlag )
                {
                    VariantClear( &varTemp );
                    VariantClear( &varStatus );
                    SAFERELEASE( pAdapConfig );
                    DestroyDynamicArray( &arrTransName );
                    return( FALSE );
                }
            }
            else
            { 
                switch(varStatus.lVal)
                {
                    case 0 :
                        strAType = GetResString( IDS_DISCONNECTED );
                        break;
                    case 1 :
                        strAType = GetResString( IDS_CONNECTING );
                        break;
                    case 3 :
                        strAType = GetResString( IDS_DISCONNECTING );
                        break;
                    case 4 :
                        strAType = GetResString( IDS_HWNOTPRESENT );
                        break;
                    case 5 :
                        strAType = GetResString( IDS_HWDISABLED );
                        break;
                    case 6 :
                        strAType = GetResString( IDS_HWMALFUNCTION );
                        break;
                    case 7 :
                        strAType = GetResString( IDS_MEDIADISCONNECTED );
                        break;
                    case 8 :
                        strAType = GetResString( IDS_AUTHENTICATION );
                        break;
                    case 9 :
                        strAType = GetResString( IDS_AUTHENSUCCEEDED );
                        break;
                    case 10 :
                        strAType = GetResString( IDS_AUTHENFAILED );
                        break;
                    default : 
                        strAType = NOT_AVAILABLE;
                        break;
                }//switch
                if( strAType == L"\0" )
                {
                    VariantClear( &varTemp );
                    VariantClear( &varStatus );
                    ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                    SAFERELEASE( pAdapConfig );
                    return( FALSE );
                }
                DynArrayAppendString( arrTransName, strAType, 0 );
            }//else
            //insert transport name array into results array
            DynArrayAppendEx2( arrMacData, i, arrTransName );
            i++;
            SAFERELEASE( pAdapConfig );
        }//while

    }//try

    catch( _com_error& e )
    {
        VariantClear( &varTemp );
        VariantClear( &varStatus );
        WMISaveError( e.Error() );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFERELEASE( pAdapConfig );
        return( FALSE );
    }
    catch( CHeap_Exception)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        VariantClear( &varTemp );
        VariantClear( &varStatus );
        SAFERELEASE( pAdapConfig );
        return( FALSE );
    }

    //if arrmacdata and not arrtransname then set transname to N/A
    if( 0 < DynArrayGetCount( arrMacData ) &&
                       DynArrayGetCount( arrTransName ) <= 0  )
    {
        DynArrayAppendString( arrTransName, NOT_AVAILABLE, 0 );
        DynArrayAppendEx2( arrMacData, i, arrTransName );
    }

    VariantClear( &varTemp );
    VariantClear( &varStatus );
    SAFERELEASE( pAdapConfig );
    return( TRUE );
}

BOOL
DisplayResults(
    IN TARRAY   arrMacData,
    IN LPCTSTR  lpFormat,
    IN BOOL     bHeader,
    IN BOOL     bVerbose
    )
/*++
Routine Description:
    This function display the results in the specified format.

Arguments:
    [IN] arrMacData  - Data to be displayed on to the  console.
    [IN] lpFormat    - Holds the formatter string in which the results
                       are to be displayed.
    [IN] bHeader     - Holds whether the header has to be dislpayed in the
                       results or not.
    [IN] bVerbose    - Hold whether verbose option is specified or not.

Return Value:
    TRUE if successful
    FALSE if failed to display results..
--*/
{
    //local variables
    DWORD       dwFormat = 0;
    TCOLUMNS tColumn[MAX_COLUMNS];

    //validate input parameters
    if( NULL == arrMacData )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return( FALSE );
    }

    for( DWORD i = 0; i < MAX_COLUMNS; i++ )
    {
        tColumn[i].pFunction = NULL;
        tColumn[i].pFunctionData = NULL;
        StringCopy( tColumn[i].szFormat, L"\0", MAX_STRING_LENGTH ); 
    }

    //host name
    tColumn[ SH_RES_HOST ].dwWidth = HOST_NAME_WIDTH;
    /*if( TRUE == bVerbose )
        tColumn[ SH_RES_HOST ].dwFlags = SR_TYPE_STRING;
    else*/
        tColumn[ SH_RES_HOST ].dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;

    StringCopy( tColumn[ SH_RES_HOST ].szColumn, RES_HOST_NAME, MAX_STRING_LENGTH );

    //connection name
    tColumn[ SH_RES_CON ].dwWidth = CONN_NAME_WIDTH;
    if( TRUE == bVerbose )
    {
        tColumn[ SH_RES_CON ].dwFlags = SR_TYPE_STRING;
    }
    else
    {
        tColumn[ SH_RES_CON ].dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
    }
    StringCopy( tColumn[ SH_RES_CON ].szColumn, RES_CONNECTION_NAME, MAX_STRING_LENGTH );

    //Adpater type
    tColumn[ SH_RES_TYPE ].dwWidth = ADAPT_TYPE_WIDTH;
    if( TRUE == bVerbose )
    {
        tColumn[ SH_RES_TYPE ].dwFlags = SR_TYPE_STRING;
    }
    else
    {
        tColumn[ SH_RES_TYPE ].dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
    }
    StringCopy( tColumn[ SH_RES_TYPE ].szColumn, RES_ADAPTER_TYPE, MAX_STRING_LENGTH );

    //mac address
    tColumn[ SH_RES_MAC ].dwWidth = MAC_ADDR_WIDTH;
    tColumn[ SH_RES_MAC ].dwFlags = SR_TYPE_STRING;
    StringCopy( tColumn[ SH_RES_MAC ].szColumn, RES_MAC_ADDRESS, MAX_STRING_LENGTH );

    //transport name
    tColumn[ SH_RES_TRAN ].dwWidth = TRANS_NAME_WIDTH;
    tColumn[ SH_RES_TRAN ].dwFlags = SR_ARRAY | SR_TYPE_STRING | SR_NO_TRUNCATION ;
    StringCopy( tColumn[ SH_RES_TRAN ].szColumn, RES_TRANS_NAME, MAX_STRING_LENGTH );

    //get the display results formatter string
    if( NULL == lpFormat )
    {
        dwFormat = SR_FORMAT_TABLE;
    }
    else if( 0 == StringCompare( GetResString( FR_LIST ), lpFormat, TRUE, 0 ) )
    {
        dwFormat = SR_FORMAT_LIST;
    }
    else if ( 0 == StringCompare( GetResString( FR_CSV ), lpFormat, TRUE, 0 ) )
    {
        dwFormat = SR_FORMAT_CSV;
    }
    else if( 0 == StringCompare( GetResString( FR_TABLE ), lpFormat, TRUE, 0 ) )
    {
        dwFormat = SR_FORMAT_TABLE;
    }
    else
    {
        dwFormat = SR_FORMAT_TABLE;
    }

    if( SR_FORMAT_CSV != dwFormat )
    {
        ShowMessage( stdout, NEW_LINE );
    }

    //look for header and display accordingly
    if( TRUE == bHeader )
    {
        ShowResults( 5, tColumn, dwFormat | SR_NOHEADER, arrMacData );
    }
    else
    {
        ShowResults( 5, tColumn, dwFormat, arrMacData );
    }
    return( TRUE );
}

BOOL
GetTransName(
    IN IWbemServices    *pIWbemServiceDef,
    IN IWbemServices     *pIWbemServices,
    IN TARRAY            arrNetProtocol,
    OUT TARRAY            arrTransName,
    IN COAUTHIDENTITY    *pAuthIdentity,
    IN LPCTSTR           lpDeviceId
    )
/*++
Routine Description:
    This function gets transport name of the network adapter.

Arguments:
    [IN] pIWbemServiceDef    - interface to default name space.
    [IN] pIWbemServices      - interface to CIMV2 name space.
    [IN] pNetProtocol        - interface to win32_networkprotocol.
    [OUT] arrTransName       - Holds the transport name.
    [IN] pAuthIdentity       - pointer to authentication structure.
    [IN] lpDeviceId          - Holds the device id.

Return Value:
    TRUE if successful.
    FALSE if failed to get transport name.
--*/
{
    BOOL           bFlag = FALSE;
    DWORD          dwCount = 0;
    DWORD          i = 0;
    DWORD          dwOnce = 0;
    HRESULT           hRes = 0;

    DWORD          dwReturned = 1;
    IWbemClassObject  *pSetting = NULL;
    IWbemClassObject  *pClass = NULL;
    IWbemClassObject *pOutInst = NULL;
    IWbemClassObject *pInClass = NULL;
    IWbemClassObject *pInInst = NULL;
    IEnumWbemClassObject *pAdapterSetting = NULL;

    VARIANT           varTemp;
    LPTSTR            lpKeyPath = NULL;
    SAFEARRAY           *safeArray = NULL;
    LONG                lLBound = 0;
    LONG                lUBound = 0;
    LONG           lIndex = 0;
    TCHAR          szTemp[ MAX_STRING_LENGTH ] = _T( "\0" );

    //validate input parameters
    if( ( NULL == pIWbemServiceDef ) || ( NULL == pIWbemServices ) ||
              ( NULL == arrNetProtocol ) || ( NULL == arrTransName ) ||
            ( NULL == lpDeviceId ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return FALSE;
    }

    VariantInit( &varTemp );
    try
    {
        CHString       strAType = L"\0";
        CHString       strSetId = L"\0";

        StringCopy( szTemp, ASSOCIATOR_QUERY, SIZE_OF_ARRAY( szTemp ) );
        StringConcat( szTemp, lpDeviceId, SIZE_OF_ARRAY( szTemp ) );
        StringConcat( szTemp, ASSOCIATOR_QUERY1, SIZE_OF_ARRAY( szTemp ) );
        hRes =  pIWbemServices->ExecQuery( _bstr_t( QUERY_LANGUAGE ), _bstr_t(szTemp),
                   WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pAdapterSetting );
        ONFAILTHROWERROR( hRes );

        hRes = SetInterfaceSecurity( pAdapterSetting, pAuthIdentity );
        //if failed to set security throw error
        ONFAILTHROWERROR( hRes );

        //get setting id
        while ( 1 == dwReturned )
        {
            // Enumerate through the resultset.
            hRes = pAdapterSetting->Next( WBEM_INFINITE,
                            1,       
                         &pSetting,  
                         &dwReturned ); 
            ONFAILTHROWERROR( hRes );
            if( 0 == dwReturned )
            {
                break;
            }
            hRes = pSetting->Get( SETTING_ID, 0 , &varTemp, 0, NULL );
            ONFAILTHROWERROR( hRes );
            if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
            {
                strSetId = ( LPCWSTR ) _bstr_t( varTemp );
                break;
            }                 
        }//while
        dwCount = DynArrayGetCount( arrNetProtocol );
        lpKeyPath = ( LPTSTR ) AllocateMemory( MAX_RES_STRING );
        if( NULL == lpKeyPath )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SAFERELEASE( pSetting );
			SAFERELEASE( pAdapterSetting );
            FreeMemory( (LPVOID*)&lpKeyPath );
            return( FALSE );
        }

        for( i = 0; i < dwCount; i++ )
        {
            if( 0 == StringCompare( ( DynArrayItemAsString( arrNetProtocol, i ) ),
                                       NETBIOS, TRUE, 0 ) )
            {
                continue;
            }
            hRes = pIWbemServiceDef->GetObject( _bstr_t( WMI_REGISTRY ), 0, NULL,
                                        &pClass, NULL );
            ONFAILTHROWERROR( hRes );
            hRes = pClass->GetMethod( WMI_REGISTRY_M_MSTRINGVALUE, 0,
                                        &pInClass, NULL ); 
            ONFAILTHROWERROR( hRes );
            hRes = pInClass->SpawnInstance(0, &pInInst);
            ONFAILTHROWERROR( hRes );
            varTemp.vt = VT_I4;
            varTemp.lVal = WMI_HKEY_LOCAL_MACHINE;
            hRes = pInInst->Put( WMI_REGISTRY_IN_HDEFKEY, 0, &varTemp, 0 );
            VariantClear( &varTemp );
            ONFAILTHROWERROR( hRes );

            StringCopy( lpKeyPath, TRANSPORT_KEYPATH,
                        ( GetBufferSize( lpKeyPath )/ sizeof( WCHAR ) ) );
            StringConcat( lpKeyPath, DynArrayItemAsString( arrNetProtocol, i ),
                        ( GetBufferSize( lpKeyPath )/ sizeof( WCHAR ) ) );
            StringConcat( lpKeyPath, LINKAGE,
                        ( GetBufferSize( lpKeyPath )/ sizeof( WCHAR ) ) );

            varTemp.vt = VT_BSTR;
            varTemp.bstrVal = SysAllocString( lpKeyPath );
            if( NULL == varTemp.bstrVal )
            {
                hRes = ERROR_NOT_ENOUGH_MEMORY;
                ONFAILTHROWERROR( hRes );
            }
            hRes = pInInst->Put( WMI_REGISTRY_IN_SUBKEY, 0, &varTemp, 0 );
            VariantClear( &varTemp );
            ONFAILTHROWERROR( hRes );

            varTemp.vt = VT_BSTR;
            varTemp.bstrVal = SysAllocString( ROUTE );
            if( NULL == varTemp.bstrVal )
            {
                hRes = ERROR_NOT_ENOUGH_MEMORY;
                ONFAILTHROWERROR( hRes );
            }

            hRes = pInInst->Put( WMI_REGISTRY_IN_VALUENAME, 0, &varTemp, 0 );
            VariantClear( &varTemp );
            ONFAILTHROWERROR( hRes );

            // Call the method.
            hRes = pIWbemServiceDef->ExecMethod( _bstr_t( WMI_REGISTRY ),
                         _bstr_t( WMI_REGISTRY_M_MSTRINGVALUE ), 0, NULL, pInInst,
                         &pOutInst, NULL );
            ONFAILTHROWERROR( hRes );

            varTemp.vt = VT_I4;
            hRes = pOutInst->Get( WMI_REGISTRY_OUT_RETURNVALUE, 0, &varTemp,
                                                     0, 0 );
            ONFAILTHROWERROR( hRes );

            if( 0 == varTemp.lVal )
            {
                VariantClear( &varTemp );
                varTemp.vt = VT_BSTR;
                hRes = pOutInst->Get( WMI_REGISTRY_OUT_VALUE, 0, &varTemp,
                                                       0, 0);
                ONFAILTHROWERROR( hRes );
                if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
                {
                    safeArray = (SAFEARRAY *)varTemp.parray;
                    //get the number of elements (subkeys)
                    if( NULL != safeArray )
                    {
                        hRes = SafeArrayGetLBound( safeArray, 1, &lLBound );
                        ONFAILTHROWERROR( hRes );
                        hRes = SafeArrayGetUBound( safeArray, 1, &lUBound );
                        ONFAILTHROWERROR( hRes );
                        bFlag = FALSE;
                        for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
                        {
                            hRes = SafeArrayGetElement( safeArray, &lIndex,
                                              &V_UI1( &varTemp ) );
                            ONFAILTHROWERROR( hRes );
                            strAType = V_BSTR( &varTemp );
                            LPTSTR lpSubStr = _tcsstr( strAType, strSetId );
                            if( NULL != lpSubStr )
                            {
                                bFlag = TRUE;
                                break;
                            }

                        }
                    }
                }
            }
            if( TRUE == bFlag )
            {
                varTemp.vt = VT_BSTR;
                varTemp.bstrVal = SysAllocString( EXPORT );
                hRes = pInInst->Put( WMI_REGISTRY_IN_VALUENAME, 0, &varTemp, 0 );
                VariantClear( &varTemp );
                ONFAILTHROWERROR( hRes );

                // Call the method.
                hRes = pIWbemServiceDef->ExecMethod( _bstr_t( WMI_REGISTRY ),
                         _bstr_t( WMI_REGISTRY_M_MSTRINGVALUE ), 0, NULL, pInInst,
                         &pOutInst, NULL );
                ONFAILTHROWERROR( hRes );

                varTemp.vt = VT_I4;
                hRes = pOutInst->Get( WMI_REGISTRY_OUT_RETURNVALUE, 0,
                                                 &varTemp, 0, 0 );
                ONFAILTHROWERROR( hRes );

                if( 0 == varTemp.lVal )
                {
                    VariantClear( &varTemp );
                    varTemp.vt = VT_BSTR;
                    hRes = pOutInst->Get( WMI_REGISTRY_OUT_VALUE, 0,
                                                 &varTemp, 0, 0);
                    ONFAILTHROWERROR( hRes );
                    if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
                    {
                        safeArray = varTemp.parray;
                        //get the number of elements (subkeys)
                        if( NULL != safeArray )
                        {
                            hRes = SafeArrayGetLBound( safeArray, 1, &lLBound );
                            ONFAILTHROWERROR( hRes );
                            hRes = SafeArrayGetUBound( safeArray, 1, &lUBound );
                            ONFAILTHROWERROR( hRes );
                            dwOnce = 0;
                            for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
                            {
                                hRes = SafeArrayGetElement( safeArray, &lIndex,
                                                 &V_UI1( &varTemp ) );
                                ONFAILTHROWERROR( hRes );
                                strAType = V_BSTR( &varTemp );
                                LPTSTR lpSubStr = _tcsstr( strAType, strSetId );
                                if( NULL != lpSubStr )
                                {
                                    dwOnce = 1;
                                    DynArrayAppendString( arrTransName, strAType, 0 );
                                    break;
                                }
                            }
                            if( 0 == dwOnce )
                            {
                                hRes = SafeArrayGetLBound( safeArray, 1, &lLBound );
                                for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
                                {
                                    hRes = SafeArrayGetElement( safeArray,
                                                    &lIndex, &V_UI1( &varTemp ) );
                                    ONFAILTHROWERROR( hRes );
                                    strAType = V_BSTR( &varTemp );
                                    DynArrayAppendString( arrTransName, strAType, 0 );
                                }
                            }

                        }
                    }
                }
            }
        }//for
    }//try
    catch( _com_error& e )
    {
        VariantClear( &varTemp );
        WMISaveError( e.Error() );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeMemory( (LPVOID*)&lpKeyPath );
        SAFERELEASE( pSetting );
        SAFERELEASE( pClass );
        SAFERELEASE( pOutInst );
        SAFERELEASE( pInClass );
        SAFERELEASE( pInInst );
		SAFERELEASE( pAdapterSetting );
        return( FALSE );
    }
    catch( CHeap_Exception)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        VariantClear( &varTemp );
        FreeMemory( (LPVOID*)&lpKeyPath );
        SAFERELEASE( pSetting );
        SAFERELEASE( pClass );
        SAFERELEASE( pOutInst );
        SAFERELEASE( pInClass );
        SAFERELEASE( pInInst );
		SAFERELEASE( pAdapterSetting );
        return( FALSE );
    }

    if( DynArrayGetCount( arrTransName ) <= 0 )
    {
        DynArrayAppendString( arrTransName, NOT_AVAILABLE, 0 );
    }
    FreeMemory( (LPVOID*)&lpKeyPath );
    SAFERELEASE( pSetting );
    SAFERELEASE( pClass );
    SAFERELEASE( pOutInst );
    SAFERELEASE( pInClass );
    SAFERELEASE( pInInst );
	SAFERELEASE( pAdapterSetting );
    return( TRUE );
}

BOOL
FormatHWAddr(
    IN LPTSTR  lpRawAddr,
    OUT LPTSTR lpFormattedAddr,
    IN LPCTSTR lpFormatter
    )
/*++
Routine Description:
    Format a 12 Byte Ethernet Address and return it as 6 2-byte
    sets separated by hyphen.

Arguments:
    [IN] lpRawAddr         - a pointer to a buffer containing the
                             unformatted hardware address.
    [OUT] LpFormattedAddr  - a pointer to a buffer in which to place
                             the formatted output.
    [IN] lpFormatter       - The Formatter string.

Return Value:
    TRUE if mac address is successfully formatted else
    FALSE.
--*/
{
    //local variables
    DWORD dwLength =0;
    DWORD i=0;
    DWORD j=0;
    TCHAR szTemp[MAX_STRING] = _T( "\0" );

    if( ( NULL == lpRawAddr ) || ( NULL == lpFormattedAddr ) ||
                            ( NULL == lpFormatter ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return( FALSE );
    }


    //initialize memory
    SecureZeroMemory( szTemp, MAX_STRING * sizeof( TCHAR ) );

    //get the length of the string to be formatted
    dwLength = StringLength( lpRawAddr, 0 );

    //loop through the address string and insert formatter string
    //after every two characters

    while( i <= dwLength )
    {
        szTemp[j++] = lpRawAddr[i++];
        szTemp[j++] = lpRawAddr[i++];
        if( i >= dwLength )
        {
            break;
        }
        szTemp[j++] = lpFormatter[0];
    }
    //insert null character at the end
    szTemp[j] = L'\0';

    //copy the formatted string from temporary variable into the
    //output string
    StringCopy( lpFormattedAddr, szTemp, MAX_STRING_LENGTH );

    return( TRUE );
}

BOOL
CallWin32Api(
    OUT LPBYTE  *lpBufptr,
    IN LPCTSTR lpMachineName,
    OUT DWORD   *pdwNumofEntriesRead
    )
/*++
Routine Description:
    This function gets data into a predefined structure from win32 api.

Arguments:
    [OUT] lpBufptr             - To hold MAc and Transport names of all
                                 network adapters.
    [IN] lpMachineName        - remote Machine name.
    [OUT] pdwNumofEntriesRead  - Contains number of network adpaters api
                                 has enumerated.

Return Value:
    TRUE if Win32Api function is successful.
    FALSE if win32api failed.
--*/
{
    //local variables
    NET_API_STATUS  err = NERR_Success;
    DWORD           dwNumofTotalEntries = 0;
    DWORD           dwResumehandle = 0;
    LPWSTR          lpwMName  = NULL;

    //validate input parameters
    if( NULL == lpMachineName )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return( FALSE );
    }

    //allocate memory
    lpwMName = ( LPWSTR )AllocateMemory( MAX_STRING_LENGTH );
    if( NULL == lpwMName )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return( FALSE );
    }

    if( 0 != StringLength( lpMachineName, 0 ) )
    {
        //get the machine name as wide character string
        StringCopyW( lpwMName, lpMachineName, MAX_STRING_LENGTH );
        //Call to an API function which enumerates the network adapters on the 
        //machine specified
        err = NetWkstaTransportEnum ( lpwMName,
                     0L,
                     lpBufptr,
                    (DWORD) -1,
                    pdwNumofEntriesRead,
                    &dwNumofTotalEntries,
                    &dwResumehandle );
    }
    else
    {
        //Call to an API function which enumerates the network adapters on the 
        //machine specified
        err = NetWkstaTransportEnum ( NULL,
                                         0L,
                                         lpBufptr,
                                         (DWORD) -1,
                                         pdwNumofEntriesRead,
                                         &dwNumofTotalEntries,
                                         &dwResumehandle );
    }

    FreeMemory( (LPVOID*)&lpwMName );
    //if error has been returned by the API then display the error message
    //just ignore the transport name and display the available data
    if ( NERR_Success != err ) 
    {    
        switch( GetLastError() )
        {
            case ERROR_IO_PENDING :
                ShowMessage( stdout, NO_NETWORK_ADAPTERS );
                return( FALSE );
            case ERROR_NOT_SUPPORTED :
                ShowMessage( stderr, ERROR_NOT_RESPONDING );
                return( FALSE );
            case ERROR_BAD_NETPATH :
                ShowMessage( stderr, ERROR_NO_MACHINE );
                return( FALSE );
            case ERROR_INVALID_NAME :
                ShowMessage( stderr, ERROR_INVALID_MACHINE );
                return( FALSE );
            case RPC_S_UNKNOWN_IF :
                ShowMessage( stderr, ERROR_WKST_NOT_FOUND );
                return( FALSE );
            case ERROR_ACCESS_DENIED :
            default :
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                return( FALSE );
        }
    } 

    return( TRUE );
}

BOOL
GetW2kMacData(
    OUT TARRAY             arrMacData,
    IN LPCTSTR              lpMachineName, 
    IN IEnumWbemClassObject *pAdapterConfig,
    IN IEnumWbemClassObject *pAdapterSetting,
    IN IWbemServices        *pIWbemServiceDef,
    IN IWbemServices        *pIWbemServices,
    IN COAUTHIDENTITY       *pAuthIdentity,
    IN TARRAY                arrNetProtocol
    )
/*++
Routine Description:
    This function gets the media access control address of
    the network adapters which are there on win2k or below.

Arguments:
    [OUT] arrMacData       - contains the MAC and other data of the network
                             adapter.
    [IN] lpMachineName     - holds machine name.
    [IN] pAdapterConfig    - interface to win32_networkadapter class.
    [IN] pAdapterSetting   - interface to win32_networkadapterconfiguration.
    [IN] pIWbemServiceDef  - interface to default name space.
    [IN] pIWbemServices    - interface to cimv2 name space.
    [IN] pAuthIdentity     - pointer to authentication structure.
    [IN] arrNetProtocol    - interface to win32_networkprotocol class

 Return Value:
    TRUE if getmacdata is successful.
    FALSE if getmacdata failed.
--*/
{
    //local variables
    HRESULT           hRes = S_OK;
    IWbemClassObject  *pAdapConfig = NULL;
    VARIANT           varTemp;
    DWORD          dwReturned  = 1;

    DWORD           i = 0;
    DWORD       dwIndex = 0;
    BOOL        bFlag = FALSE;

    DWORD                dwNumofEntriesRead = 0;
    LPWKSTA_TRANSPORT_INFO_0   lpAdapterData=NULL;
    LPBYTE                  lpBufptr = NULL;
    TARRAY                  arrTransName = NULL;
    LPTSTR                  lpRawAddr = NULL;
    LPTSTR                  lpFormAddr = NULL;

    //validate input parametrs
    if( ( NULL == arrMacData ) || ( NULL == lpMachineName ) ||
             ( NULL == pAdapterConfig ) || ( NULL == pIWbemServiceDef ) ||
            ( NULL == pIWbemServices ) || ( NULL == arrNetProtocol ) || 
            ( NULL == pAdapterSetting ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return FALSE;
    }

    try
    {
        CHString       strAType = L"\0";

        //callwin32api to get the mac address
        bFlag = CallWin32Api( &lpBufptr, lpMachineName, &dwNumofEntriesRead );
        if( FALSE == bFlag )
        {
            return( FALSE );
        }
        else
        {
            lpAdapterData = ( LPWKSTA_TRANSPORT_INFO_0 ) lpBufptr;
            lpRawAddr = ( LPTSTR )AllocateMemory( MAX_STRING );
            lpFormAddr = ( LPTSTR )AllocateMemory( MAX_STRING );

            if( NULL == lpRawAddr )
            {
                FreeMemory( (LPVOID*)&lpRawAddr );
                if( NULL != lpBufptr )
                {
                    NetApiBufferFree( lpBufptr );
                }
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                return( FALSE );
            }
            if ( NULL == lpFormAddr )
            {
                FreeMemory( (LPVOID*)&lpRawAddr );
                FreeMemory( (LPVOID*)&lpFormAddr );
                if( NULL != lpBufptr )
                {
                    NetApiBufferFree( lpBufptr );
                }
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                return( FALSE );
            }
            for ( i = 0; i < dwNumofEntriesRead; i++ )
            {      
                //get the mac address
                StringCopyW( lpRawAddr,
                        lpAdapterData[i].wkti0_transport_address, MAX_STRING );
                if( 0 == StringCompare( lpRawAddr, DEFAULT_ADDRESS, TRUE, 0 ) )
                {
                    continue;
                }

                bFlag = FormatHWAddr ( lpRawAddr, lpFormAddr, COLON_STRING ); 
                if( FALSE == bFlag )
                {
                    FreeMemory( (LPVOID*)&lpRawAddr );
                    FreeMemory( (LPVOID*)&lpFormAddr );
                    if( NULL != lpBufptr )
                    {
                        NetApiBufferFree( lpBufptr );
                    }
                    return( FALSE );
                }

                //get the network adapter type and other details
                VariantInit( &varTemp );
                bFlag = FALSE;
                hRes = pAdapterConfig->Reset();
                ONFAILTHROWERROR( hRes );
                while ( ( 1 == dwReturned ) && ( FALSE == bFlag ) )
                {
                    // Enumerate through the resultset.
                    hRes = pAdapterConfig->Next( WBEM_INFINITE,
                                   1,          
                                      &pAdapConfig,  
                                      &dwReturned ); 
                    ONFAILTHROWERROR( hRes );
                    if( 0 == dwReturned )
                    {
                        break;
                    }

                    hRes = pAdapConfig->Get( ADAPTER_MACADDR, 0 , &varTemp,
                                                           0, NULL );
                    ONFAILTHROWERROR( hRes );
                    if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
                    {
                        strAType = varTemp.bstrVal;
                        VariantClear( &varTemp ); 
                        if( 0 == StringCompare( lpFormAddr, strAType, TRUE, 0 ) )
                        {
                            bFlag = TRUE;
                            break;
                        }
                        else
                        {
                            continue;
                        }
                    }
                    else
                    {
                        continue;
                    }
                }  //while
                if ( TRUE == bFlag )
                {
                    FormatHWAddr ( lpRawAddr, lpFormAddr, HYPHEN_STRING );
                    LONG dwCount = DynArrayFindStringEx( arrMacData, 3,
                                                  lpFormAddr, TRUE, 0 );
                    if( 0 == dwCount )
                    {
                        hRes = pAdapterConfig->Reset();
                        ONFAILTHROWERROR( hRes );
                        continue;
                    }
                    DynArrayAppendRow( arrMacData, 0 );
                    //get host name
                    hRes = pAdapConfig->Get( HOST_NAME, 0 , &varTemp, 0, NULL );
                    ONFAILTHROWERROR( hRes );
                    if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
                    {
                        strAType = varTemp.bstrVal;
                    }
                    else
                    {
                        strAType = NOT_AVAILABLE; 
                    }
                    VariantClear( &varTemp );
                    DynArrayAppendString2( arrMacData, dwIndex, strAType, 0 );

                    FormatHWAddr ( lpRawAddr, lpFormAddr, COLON_STRING );
                    //get connection name
                    bFlag = GetConnectionName( arrMacData, dwIndex, lpFormAddr,
                                         pAdapterSetting, pIWbemServiceDef );
                    if( FALSE == bFlag )
                    {
                        FreeMemory( (LPVOID*)&lpRawAddr );
                        FreeMemory( (LPVOID*)&lpFormAddr );
                        SAFERELEASE( pAdapConfig );
                        if( NULL != lpBufptr )
                        {
                            NetApiBufferFree( lpBufptr );
                        }
                        return( FALSE );
                    }
                    //get adapter type   
                    hRes = pAdapConfig->Get( NAME, 0 , &varTemp, 0, NULL );
                    ONFAILTHROWERROR( hRes );
                    if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
                    {
                        strAType = varTemp.bstrVal;
                    }
                    else
                    {
                        strAType = NOT_AVAILABLE; 
                    }
                    VariantClear( &varTemp );
                    DynArrayAppendString2( arrMacData, dwIndex, strAType, 0 );

                    //get MAC address
                    hRes = pAdapConfig->Get( ADAPTER_MACADDR, 0 , &varTemp,
                                                           0, NULL );
                    ONFAILTHROWERROR( hRes );
                    strAType = varTemp.bstrVal;
                    for( int j = 2; j < strAType.GetLength();j += 3 )
                    {
                        strAType.SetAt( j, HYPHEN_CHAR );
                    }
                    VariantClear( &varTemp );
                    DynArrayAppendString2( arrMacData, dwIndex, strAType, 0 );

                    //get transport name
                    arrTransName = CreateDynamicArray();
                    if( NULL == arrTransName )
                    {
                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        SaveLastError();
                        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                        FreeMemory( (LPVOID*)&lpRawAddr );
                        FreeMemory( (LPVOID*)&lpFormAddr );
                        SAFERELEASE( pAdapConfig );
                        if( NULL != lpBufptr )
                        {
                            NetApiBufferFree( lpBufptr );
                        }
                        return( FALSE );
                    }
                    //get Device id   
                    hRes = pAdapConfig->Get( DEVICE_ID, 0 , &varTemp, 0, NULL );
                    ONFAILTHROWERROR( hRes );
                    if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
                    {
                        strAType = ( LPCWSTR ) _bstr_t( varTemp );
                    }
                    bFlag = GetTransName( pIWbemServiceDef, pIWbemServices,
                                arrNetProtocol,   arrTransName, pAuthIdentity,
                                strAType );
                    if( FALSE == bFlag )
                    {
                        FreeMemory( (LPVOID*)&lpRawAddr );
                        FreeMemory( (LPVOID*)&lpFormAddr );
                        SAFERELEASE( pAdapConfig );
                        if( NULL != lpBufptr )
                        {
                            NetApiBufferFree( lpBufptr );
                        }
                        DestroyDynamicArray( &arrTransName );
                        return( FALSE );
                    }
                    //insert transport name array into results array
                    DynArrayAppendEx2( arrMacData, dwIndex, arrTransName );
                    dwIndex++;
                }  //wmi data found
            }//for each entry in api
        }//if call api succeeded
    }
    catch( _com_error& e )
    {
        FreeMemory( (LPVOID*)&lpRawAddr );
        FreeMemory( (LPVOID*)&lpFormAddr );
        WMISaveError( e.Error() );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFERELEASE( pAdapConfig );
        if( NULL != lpBufptr )
        {
            NetApiBufferFree( lpBufptr );
        }
        return( FALSE );
    }
    catch( CHeap_Exception)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeMemory( (LPVOID*)&lpRawAddr );
        FreeMemory( (LPVOID*)&lpFormAddr );
        SAFERELEASE( pAdapConfig );
        if( NULL != lpBufptr )
        {
            NetApiBufferFree( lpBufptr );
        }
        return( FALSE );
    }

    if( NULL != lpBufptr )
    {
        NetApiBufferFree( lpBufptr );  
    }
    //if arrmacdata and not arrtransname then set transname to N/A
    if( DynArrayGetCount( arrMacData ) > 0 &&
                            DynArrayGetCount( arrTransName ) <= 0  )
    {
        DynArrayAppendString( arrTransName, NOT_AVAILABLE, 0 );
        DynArrayAppendEx2( arrMacData, dwIndex, arrTransName );
    }

    FreeMemory( (LPVOID*)&lpRawAddr );
    FreeMemory( (LPVOID*)&lpFormAddr );
    SAFERELEASE( pAdapConfig );
    return( TRUE );
}

BOOL
GetConnectionName(
    OUT TARRAY              arrMacData,
    IN DWORD               dwIndex,
    IN LPCTSTR          lpFormAddr,
    IN IEnumWbemClassObject   *pAdapterSetting,
    IN IWbemServices       *pIWbemServiceDef
    )
/*++
Routine Description:
    This function gets connection name of the network adapter.

Arguments:
    [OUT] arrMacData       - contains the MAC and other data of the network
                             adapter.
    [IN] dwIndex           - index for array.
    [IN] lpFormAddr        - Mac address for network adapter.
    [IN] pAdapterSetting   - interface to win32_networkadapterconfiguration.
    [IN] pIWbemServiceDef  - interface to default name space.

Return Value:
    TRUE if GetConnectionName  is successful.
    FALSE if GetConnectionName failed.
--*/
{
    DWORD          dwReturned = 1;
    HRESULT           hRes = 0;
    IWbemClassObject  *pAdapSetting = NULL;
    VARIANT           varTemp;
    BOOL           bFlag = FALSE;

    IWbemClassObject  *pClass = NULL;
    IWbemClassObject *pOutInst = NULL;
    IWbemClassObject *pInClass = NULL;
    IWbemClassObject *pInInst = NULL;
    LPTSTR            lpKeyPath = NULL;

    //validate input parameters
    if( ( NULL == arrMacData ) || ( NULL == lpFormAddr ) ||
          ( NULL == pAdapterSetting ) || ( NULL == pIWbemServiceDef ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return FALSE;
    }

    VariantInit( &varTemp );
    try
    {
        CHString       strAType = L"\0";
        hRes = pAdapterSetting->Reset();
        ONFAILTHROWERROR( hRes );
        while ( ( 1 == dwReturned ) && ( FALSE == bFlag ) )
        {
            // Enumerate through the resultset.
            hRes = pAdapterSetting->Next( WBEM_INFINITE,
                            1, 
                            &pAdapSetting,
                            &dwReturned );
            ONFAILTHROWERROR( hRes );
            if( 0 == dwReturned )
            {
                break;
            }
            hRes = pAdapSetting->Get( ADAPTER_MACADDR, 0 , &varTemp, 0, NULL );
            ONFAILTHROWERROR( hRes );
            if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
            {
                strAType = varTemp.bstrVal;
                VariantClear( &varTemp ); 
                if( 0 == StringCompare( lpFormAddr, strAType, TRUE, 0 ) )
                {
                    bFlag = TRUE;
                    break;
                }
            }
        }//while
        if( TRUE == bFlag )
        {
            hRes = pAdapSetting->Get( SETTING_ID, 0 , &varTemp, 0, NULL );
            ONFAILTHROWERROR( hRes );
            if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
            {
                strAType = varTemp.bstrVal;
                VariantClear( &varTemp ); 
                lpKeyPath = ( LPTSTR )AllocateMemory( 4 * MAX_RES_STRING );
                if( NULL == lpKeyPath )
                {
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    SaveLastError();
                    ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    SAFERELEASE( pAdapSetting );
                    return( FALSE );
                }
                hRes = pIWbemServiceDef->GetObject( _bstr_t( WMI_REGISTRY ), 0, NULL,
                                           &pClass, NULL );
                ONFAILTHROWERROR( hRes );
                hRes = pClass->GetMethod( WMI_REGISTRY_M_STRINGVALUE, 0,
                                         &pInClass, NULL ); 
                ONFAILTHROWERROR( hRes );
                hRes = pInClass->SpawnInstance(0, &pInInst);
                ONFAILTHROWERROR( hRes );
                varTemp.vt = VT_I4;
                varTemp.lVal = WMI_HKEY_LOCAL_MACHINE;
                hRes = pInInst->Put( WMI_REGISTRY_IN_HDEFKEY, 0, &varTemp, 0 );
                VariantClear( &varTemp );
                ONFAILTHROWERROR( hRes );

                StringCopy( lpKeyPath, CONNECTION_KEYPATH,
                        ( GetBufferSize( lpKeyPath )/ sizeof( WCHAR ) ) );
                StringConcat( lpKeyPath, strAType,
                        ( GetBufferSize( lpKeyPath )/ sizeof( WCHAR ) ) );
                StringConcat( lpKeyPath, CONNECTION_STRING,
                        ( GetBufferSize( lpKeyPath )/ sizeof( WCHAR ) ) );
                varTemp.vt = VT_BSTR;
                varTemp.bstrVal = SysAllocString( lpKeyPath );
                hRes = pInInst->Put( WMI_REGISTRY_IN_SUBKEY, 0, &varTemp, 0 );
                VariantClear( &varTemp );
                ONFAILTHROWERROR( hRes );

                varTemp.vt = VT_BSTR;
                varTemp.bstrVal = SysAllocString( REG_NAME );
                hRes = pInInst->Put( WMI_REGISTRY_IN_VALUENAME, 0,
                                      &varTemp, 0 );
                VariantClear( &varTemp );
                ONFAILTHROWERROR( hRes );

                // Call the method.
                hRes = pIWbemServiceDef->ExecMethod( _bstr_t( WMI_REGISTRY ),
                            _bstr_t( WMI_REGISTRY_M_STRINGVALUE ),   0, NULL, pInInst,
                            &pOutInst, NULL );
                ONFAILTHROWERROR( hRes );

                varTemp.vt = VT_I4;
                hRes = pOutInst->Get( WMI_REGISTRY_OUT_RETURNVALUE, 0,
                                              &varTemp, 0, 0 );
                ONFAILTHROWERROR( hRes );

                if( 0 == varTemp.lVal )
                {
                    VariantClear( &varTemp );
                    varTemp.vt = VT_BSTR;
                    hRes = pOutInst->Get( WMI_REGISTRY_OUT_VALUE, 0,
                                                     &varTemp, 0, 0);
                    ONFAILTHROWERROR( hRes );
                    if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
                    {
                        strAType = varTemp.bstrVal;
                        DynArrayAppendString2( arrMacData, dwIndex, strAType, 0 );
                    }
                }
                else
                {
                    DynArrayAppendString2( arrMacData, dwIndex, NOT_AVAILABLE, 0 );
                }
            }//setting id not null
            else
            {
                DynArrayAppendString2( arrMacData, dwIndex, NOT_AVAILABLE, 0 );
            }
        }//got match
        else
        {
            DynArrayAppendString2( arrMacData, dwIndex, NOT_AVAILABLE, 0 );
        }

    }//try
    catch( _com_error& e )
    {
        VariantClear( &varTemp );
        WMISaveError( e.Error() );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeMemory( (LPVOID*)&lpKeyPath );
        SAFERELEASE( pAdapSetting );
        SAFERELEASE( pClass );
        SAFERELEASE( pOutInst );
        SAFERELEASE( pInClass );
        SAFERELEASE( pInInst );
        return( FALSE );
    }
    catch( CHeap_Exception)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        VariantClear( &varTemp );
        FreeMemory( (LPVOID*)&lpKeyPath );
        SAFERELEASE( pAdapSetting );
        SAFERELEASE( pClass );
        SAFERELEASE( pOutInst );
        SAFERELEASE( pInClass );
        SAFERELEASE( pInInst );
        return( FALSE );
    }

    VariantClear( &varTemp );
    FreeMemory( (LPVOID*)&lpKeyPath );
    SAFERELEASE( pAdapSetting );
    SAFERELEASE( pClass );
    SAFERELEASE( pOutInst );
    SAFERELEASE( pInClass );
    SAFERELEASE( pInInst );
    return( TRUE );
}

BOOL
GetNwkProtocol(
    OUT TARRAY               arrNetProtocol,
    IN IEnumWbemClassObject  *pNetProtocol
    )
/*++
Routine Description:
    This function enumerates all the network protocols.

Arguments:
    [OUT] arrNetProtocol  - contains all the network protocols.
    [IN] pNetProtocol     - interface to win32_networkprotocol.

Return Value:
    TRUE if GetNwkProtocol  is successful.
    FALSE if GetNwkProtocol failed.
--*/
{
    HRESULT           hRes = 0;
    DWORD          dwReturned = 1;
    IWbemClassObject  *pProto = NULL;
    VARIANT           varTemp;

    VariantInit( &varTemp );
    try
    {
        CHString       strAType = L"\0";
        //get transport protocols
        while ( 1 == dwReturned )
        {
            // Enumerate through the resultset.
            hRes = pNetProtocol->Next( WBEM_INFINITE,
                            1, 
                            &pProto,
                            &dwReturned ); 
            ONFAILTHROWERROR( hRes );
            if( 0 == dwReturned )
            {
                break;
            }
            hRes = pProto->Get( CAPTION, 0 , &varTemp, 0, NULL );
            ONFAILTHROWERROR( hRes );
            if( VT_NULL != varTemp.vt && VT_EMPTY != varTemp.vt )
            {
                strAType = varTemp.bstrVal;
                VariantClear( &varTemp );
                if( 0 == DynArrayGetCount( arrNetProtocol ) )
                {
                    DynArrayAppendString( arrNetProtocol, strAType, 0 );
                }
                else
                {
                    LONG lFound =  DynArrayFindString( arrNetProtocol,
                                                  strAType, TRUE, 0 );
                    if( -1 == lFound )
                    {
                        DynArrayAppendString( arrNetProtocol, strAType, 0 );
                    }
                }
            }
        }//while
    }
    catch( _com_error& e )
    {
        VariantClear( &varTemp );
        WMISaveError( e.Error() );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFERELEASE( pProto );
        return( FALSE );
    }
    catch( CHeap_Exception)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        VariantClear( &varTemp );
        SAFERELEASE( pProto );
        return( FALSE );
    }

    VariantClear( &varTemp );
    SAFERELEASE( pProto );
    return( TRUE );
}

BOOL
CheckVersion(
    IN BOOL           bLocalSystem,
    IN COAUTHIDENTITY *pAuthIdentity,
    IN IWbemServices  *pIWbemServices
    )
/*++
Routine Description:
    This function checks whether tha target system is win2k or above.

Arguments:
    [IN] bLocalSystem   - Hold whether local system or not.
    [IN] pAuthIdentity  - pointer to authentication structure.
    [IN] pIWbemServices - pointer to IWbemServices.

Return Value:
    TRUE if target system is win2k.
    FALSE if target system is not win2k.
--*/
{
    if ( FALSE == bLocalSystem )
    {
        // check the version compatibility
        DWORD dwVersion = 0;
        dwVersion = GetTargetVersionEx( pIWbemServices, pAuthIdentity );
        if ( dwVersion <= 5000 )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\getmac\pch.h ===
/*++
    Copyright (c) Microsoft Corporation

Module Name:
    PCH.H

Abstract:
    Include file for standard system include files, or project specific
    include files that are used frequently, but  are changed infrequently.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 26-sep-2k : Created It.
    Vasundhara .G 31-oct-2k : Modified
--*/


#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#define CMDLINE_VERSION     200

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <Security.h>
#include <SecExt.h>

#include <windows.h>
#include <winsvc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <mbstring.h>
#include <tchar.h>

#include <winperf.h>
#include <shlwapi.h>
#include <lmcons.h>
#include <Lmapibuf.h>
#include <lmerr.h>
#include <winnetwk.h>
#include <common.ver>

#include <objbase.h>
#include <initguid.h>
#include <wbemidl.h>
#include <Wbemcli.h>
#include <wbemtime.h>

#include <wchar.h>
#include <lmwksta.h>
#include <comdef.h> 
#include <Lmwksta.h>
#include <Chstring.h>
#include <malloc.h>

#include "cmdline.h"
#include "cmdlineres.h"

#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\getmac\resource.h ===
#define RES_HOST                        2
#define RES_CONNECTION                  3
#define RES_ADAPTER                     4
#define RES_ADDRESS                     5
#define RES_TRANSNAME                   6
#define FR_LIST                         7
#define FR_CSV                          8
#define FR_TABLE                        9
#define IDS_HYPHEN_STRING               10
#define IDS_USAGE_BEGINING              11
#define IDS_USG_4                       12
#define IDS_USG_5                       13
#define IDS_USG_6                       14
#define IDS_USG_7                       15
#define IDS_USG_8                       16
#define IDS_USG_9                       17
#define IDS_USG_10                      18
#define IDS_USG_11                      19
#define IDS_USG_12                      20
#define IDS_USG_13                      21
#define IDS_USG_14                      22
#define IDS_USG_15                      23
#define IDS_USG_16                      24
#define IDS_USG_17                      25
#define IDS_USG_18                      26
#define IDS_USG_19                      27
#define IDS_USG_20                      28
#define IDS_USG_21                      29
#define IDS_USG_22                      30
#define IDS_USG_23                      31
#define IDS_USG_24                      32
#define IDS_USG_25                      33
#define IDS_USG_26                      34
#define IDS_USG_27                      35
#define IDS_USG_28                      36
#define IDS_USAGE_ENDING                37
#define IDS_HOST_NAME_WIDTH             38
#define IDS_CONN_NAME_WIDTH             39
#define IDS_ADAPT_TYPE_WIDTH            40
#define IDS_MAC_ADDR_WIDTH              41
#define IDS_TRANS_NAME_WIDTH            42
#define IDS_NOT_AVAILABLE               43
#define IDS_USER_NMACHINE               44
#define IDS_SERVER_NPASSWORD            45
#define IDS_ERROR_STRING                46
#define IDS_FORMAT_TYPES                47
#define IDS_NULL_USER                   48
#define IDS_INVALID_OPTIONS             49
#define IDS_DISCONNECTED                50
#define IDS_CONNECTING                  51
#define IDS_DISCONNECTING               52
#define IDS_HWNOTPRESENT                53
#define IDS_HWDISABLED                  54
#define IDS_HWMALFUNCTION               55
#define IDS_MEDIADISCONNECTED           56
#define IDS_AUTHENTICATION              57
#define IDS_AUTHENSUCCEEDED             58
#define IDS_AUTHENFAILED                59
#define IDS_ERROR_VERSION_MISMATCH      60
#define IDS_DISABLED            61
#define IDS_NO_NETWORK_ADAPTERS         62
#define IDS_IGNORE_LOCALCREDENTIALS     63
#define IDS_WARNING_STRING              64
#define IDS_NOT_RESPONDING      65
#define IDS_NO_MACHINE          66
#define IDS_INVALID_MACHINE             67
#define IDS_WKST_NOT_FOUND      68
#define IDS_NULL_SERVER         69
#define IDS_NEW_LINE            70
#define IDS_TYPE_REQUEST        71
#define IDS_COLON_STRING        72
#define IDS_NO_NETWOK_PROTOCOLS     73
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\getmac\getmac.h ===
/*++
    Copyright (c) Microsoft Corporation

Module Name:
    GETMAC.H

Abstract:
    Contains function prototypes and macros.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 26-sep-2k : Created It.
    Vasundhara .G 31-oct-2k : Modified.
                             Added macros and some #defines.
--*/

#ifndef __GETMAC_H
#define __GETMAC_H

// constants / defines / enumerations

#define MAX_STRING                      256
#define MAX_OPTIONS                     7
#define MAX_COLUMNS                     5
#define USAGE_END                       37

//Command line parser index
#define CMD_PARSE_SERVER                0
#define CMD_PARSE_USER                  1
#define CMD_PARSE_PWD                   2
#define CMD_PARSE_FMT                   3
#define CMD_PARSE_USG                   4
#define CMD_PARSE_HRD                   5
#define CMD_PARSE_VER                   6

//show results index
#define SH_RES_HOST                     0
#define SH_RES_CON                      1
#define SH_RES_TYPE                     2
#define SH_RES_MAC                      3
#define SH_RES_TRAN                     4

//wmi registry key value
#define WMI_HKEY_CLASSES_ROOT           2147483648 
#define WMI_HKEY_CURRENT_USER           2147483649
#define WMI_HKEY_LOCAL_MACHINE          2147483650
#define WMI_HKEY_USERS                  2147483651
#define WMI_HKEY_CURRENT_CONFIG         2147482652

// Error constants
#define ERROR_USER_WITH_NOSERVER        GetResString( IDS_USER_NMACHINE )
#define ERROR_SERVER_WITH_NOPASSWORD    GetResString( IDS_SERVER_NPASSWORD )
#define ERROR_NULL_SERVER               GetResString( IDS_NULL_SERVER )
#define ERROR_NULL_USER                 GetResString( IDS_NULL_USER )
#define ERROR_INVALID_HEADER_OPTION     GetResString( IDS_INVALID_OPTIONS )
#define ERROR_TYPE_REQUEST              GetResString( IDS_TYPE_REQUEST )
#define ERROR_STRING                    GetResString( IDS_ERROR_STRING )
#define ERROR_VERSION_MISMATCH          GetResString( IDS_ERROR_VERSION_MISMATCH )
#define ERROR_NOT_RESPONDING            GetResString( IDS_NOT_RESPONDING ) 
#define ERROR_NO_MACHINE                GetResString( IDS_NO_MACHINE )
#define ERROR_INVALID_MACHINE           GetResString( IDS_INVALID_MACHINE )
#define ERROR_WKST_NOT_FOUND            GetResString( IDS_WKST_NOT_FOUND )

//warning message
#define IGNORE_LOCALCREDENTIALS         GetResString( IDS_IGNORE_LOCALCREDENTIALS )
#define WARNING_STRING                  GetResString( IDS_WARNING_STRING )

//info message
#define NO_NETWORK_ADAPTERS             GetResString( IDS_NO_NETWORK_ADAPTERS )
#define NO_NETWOK_PROTOCOLS             GetResString( IDS_NO_NETWOK_PROTOCOLS )

//show results  column length
#define HOST_NAME_WIDTH                 AsLong(GetResString( IDS_HOST_NAME_WIDTH ),10 )
#define CONN_NAME_WIDTH                 AsLong(GetResString( IDS_CONN_NAME_WIDTH ),10 )
#define ADAPT_TYPE_WIDTH                AsLong(GetResString( IDS_ADAPT_TYPE_WIDTH ),10 )
#define MAC_ADDR_WIDTH                  AsLong(GetResString( IDS_MAC_ADDR_WIDTH ),10 )
#define TRANS_NAME_WIDTH                AsLong(GetResString( IDS_TRANS_NAME_WIDTH ),10 )

//output headers strings
#define RES_HOST_NAME                   GetResString( RES_HOST )
#define RES_CONNECTION_NAME             GetResString( RES_CONNECTION )
#define RES_ADAPTER_TYPE                GetResString( RES_ADAPTER )
#define RES_MAC_ADDRESS                 GetResString( RES_ADDRESS )
#define RES_TRANS_NAME                  GetResString( RES_TRANSNAME )

//general
#define NOT_AVAILABLE                   GetResString( IDS_NOT_AVAILABLE )
#define DISABLED                        GetResString( IDS_DISABLED )
#define HYPHEN_STRING                   GetResString( IDS_HYPHEN_STRING )
#define COLON_STRING                    GetResString( IDS_COLON_STRING )
#define NEW_LINE                        GetResString( IDS_NEW_LINE )
#define FORMAT_TYPES                    GetResString( IDS_FORMAT_TYPES )

//registry key names
#define DEFAULT_ADDRESS                 _T( "000000000000" )
#define CONNECTION_KEYPATH              _T( "SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\" )
#define TRANSPORT_KEYPATH               _T( "SYSTEM\\CurrentControlSet\\Services\\" )
#define LINKAGE                         _T( "\\Linkage" )
#define ROUTE                           _T( "route" )
#define EXPORT                          _T( "Export" )
#define CONNECTION_STRING               _T( "\\Connection" )
#define REG_NAME                        _T( "name" )
#define NETBIOS                         _T( "NetBIOS" )


//command line options
#define CMDOPTION_SERVER                _T( "s" )
#define CMDOPTION_USER                  _T( "u" )
#define CMDOPTION_PASSWORD              _T( "p" )
#define CMDOPTION_FORMAT                _T( "fo" )
#define CMDOPTION_USAGE                 _T( "?" )
#define CMDOPTION_HEADER                _T( "nh" )
#define CMDOPTION_VERBOSE               _T( "v" )
#define TOKEN_BACKSLASH2                _T( "\\\\" )
#define TOKEN_BACKSLASH3                _T( "\\\\\\" )

//wmi classes and property names
#define HYPHEN_CHAR                     L'-'
#define COLON_CHAR                      L':'
#define BACK_SLASHS                     L"\\\\"
#define BACK_SLASH                      L"\\"
#define NETCONNECTION_STATUS            L"NetConnectionStatus"
#define ADAPTER_MACADDR                 L"MACAddress"
#define NETCONNECTION_ID                L"NetConnectionID"
#define DEVICE_ID                       L"DeviceID"
#define NAME                            L"Name"
#define HOST_NAME                       L"SystemName"
#define SETTING_ID                      L"SettingID"
#define NETWORK_ADAPTER_CLASS           L"Win32_NetworkAdapter"
#define NETWORK_ADAPTER_CONFIG_CLASS    L"Win32_NetworkAdapterConfiguration"
#define NETWORK_PROTOCOL                L"Win32_NetworkProtocol"
#define CLASS_CIMV2_Win32_OperatingSystem   L"Win32_OperatingSystem"
#define QUERY_LANGUAGE                  L"WQL"
#define ASSOCIATOR_QUERY                _T( "ASSOCIATORS OF {Win32_NetworkAdapter.DeviceID=\"" )
#define ASSOCIATOR_QUERY1               _T( "\"} WHERE ResultClass=Win32_NetworkAdapterConfiguration" )
#define SUCCESS 0
#define FAILURE 1

#define WMI_NAMESPACE_CIMV2             L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT           L"root\\default"
#define WMI_CLAUSE_AND                  L"AND"
#define WMI_CLAUSE_OR                   L"OR"
#define WMI_CLAUSE_WHERE                L"WHERE"
#define WMI_REGISTRY                    L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE      L"GetStringValue"
#define WMI_REGISTRY_M_MSTRINGVALUE     L"GetMultiStringValue"
#define WMI_REGISTRY_IN_HDEFKEY         L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY          L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME       L"sValueName"
#define WMI_REGISTRY_OUT_VALUE          L"sValue"
#define WMI_REGISTRY_OUT_RETURNVALUE    L"ReturnValue"
#define CAPTION                         L"Caption"

#define SAFERELEASE( pIObj ) \
    if ( NULL != pIObj ) \
    { \
        pIObj->Release();   \
        pIObj = NULL;   \
    }

#define SAFEBSTRRELEASE( pIObj ) \
    if ( NULL != pIObj ) \
    { \
        SysFreeString( pIObj ); \
        pIObj = NULL;   \
    }

#define ONFAILTHROWERROR(hResult) \
    if (FAILED(hResult)) \
    {   \
        _com_issue_error(hResult); \
    }

#define SAFE_RELEASE( interfacepointer )    \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \
    1

#define SAFE_EXECUTE( statement )               \
    hRes = statement;       \
    if ( FAILED( hRes ) )   \
    {   \
        _com_issue_error( hRes );   \
    }   \
    1

//function prototype 

BOOL
ConnectWmi(
    IN IWbemLocator      *pLocator,
    OUT  IWbemServices     **ppServices, 
    IN LPCWSTR           pwszServer,
    OUT LPCWSTR           pwszUser,
    OUT LPCWSTR           pwszPassword, 
    OUT COAUTHIDENTITY    **ppAuthIdentity, 
    IN BOOL              bCheckWithNullPwd = FALSE, 
    IN LPCWSTR           pwszNamespace = WMI_NAMESPACE_CIMV2, 
    OUT HRESULT           *phRes = NULL,
    OUT BOOL              *pbLocalSystem = NULL
    );

BOOL
ConnectWmiEx(
    IN IWbemLocator     *pLocator, 
    OUT IWbemServices    **ppServices, 
    IN LPCWSTR          pwszServer,
    OUT CHString         &strUserName,
    OUT CHString         &strPassword, 
    OUT COAUTHIDENTITY   **ppAuthIdentity,
    IN BOOL             bNeedPassword = FALSE, 
    IN LPCWSTR          pszNamespace = WMI_NAMESPACE_CIMV2,
    OUT BOOL             *pbLocalSystem = NULL
    );

BOOL
IsValidServerEx(
    IN LPCWSTR       pwszServer,
    OUT BOOL         &bLocalSystem
    );

HRESULT
SetInterfaceSecurity(
    IN IUnknown          *pInterface,
    IN COAUTHIDENTITY    *pAuthIdentity
    );

VOID
WINAPI WbemFreeAuthIdentity(
    IN COAUTHIDENTITY    **ppAuthIdentity
    );

VOID
WMISaveError(
    IN HRESULT hResError
    );

DWORD
GetTargetVersionEx(
    IN IWbemServices* pWbemServices,
    IN COAUTHIDENTITY* pAuthIdentity
    );

// inline functions
inline VOID WMISaveError( _com_error  &e )
{
    WMISaveError( e.Error() );
}

#endif // __GETMAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gettype\pch.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

       pch.h

    Abstract:

        Pre-compiled header declaration
       files that has to be pre-compiled into .pch file

    Author:

      Partha Sarathi 23-July.-2001  (Created it)

    Revision History:

      Partha Sarathi (partha.sadasivuni@wipro.com)

--*/

#ifndef __PCH_H
#define __PCH_H

#pragma once    // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#define CMDLINE_VERSION         200
//
// public Windows header files
#include <tchar.h>
#include <windows.h>
#include <shlwapi.h>
#include "Dsrole.h"
#include <strsafe.h>
#include <errno.h>

//
// public C header files
//
#include <stdio.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

// End of file pch.h
#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gettype\gettype.c ===
/******************************************************************

Copyright (c) Microsoft Corporation

Module Name:Gettype.c

Abstract: This module calls the function to parse command line and call
the appropriate functions to execute the command of GetType.

Author:WiproTechnologies

Revision History:

*******************************************************************************/

#include "GetType.h"
#include "resource.h"
#include <lm.h>


/********************Function Prototypes that are used only in this file**************/
BOOL
ProcessOptions( IN DWORD argc,
               IN LPCWSTR argv[],
               OUT PBOOL  pbUsage,
               OUT PBOOL  pbOSRole,
               OUT PBOOL  pbServicePk,
               OUT PBOOL  pbVersion,
               OUT PBOOL  pbMinorVer,
               OUT PBOOL  pbMajorVer,
               OUT PBOOL  pbOSType,
               OUT PBOOL  pbBuildNumber,
               OUT LPTSTR* pszServer,
               OUT LPTSTR* pszUserName,
               OUT LPTSTR* pszPassword,
               OUT PBOOL  pbNeedPassword);
DWORD
ProcessType( IN LPWSTR pszServer,
            IN BOOL  bOSRole,
            IN BOOL  bServicePk,
            IN BOOL  bVersion,
            IN BOOL  bMinorVer,
            IN BOOL  bMajorVer,
            IN BOOL  bOSType,
            IN BOOL  bBuildNumber);

DWORD
ProcessTypeRemote(  IN LPWSTR pszRmtServer,
                    IN BOOL  bOSRole,
                    IN BOOL  bServicePk,
                    IN BOOL  bVersion,
                    IN BOOL  bMinorVer,
                    IN BOOL  bMajorVer,
                    IN BOOL  bOSType,
                    IN BOOL  bBuildNumber);

DWORD
DisplayOutputEx(IN OSVERSIONINFOEX *osvi,
                IN LPWSTR pszServerName,
                OUT LPWSTR pszOSName,
                OUT LPWSTR pszOSVersion,
                IN LPWSTR pszOSRole,
                IN LPWSTR pszOSComp,
                IN LPWSTR pszCurrBuildNumber,
                IN LPWSTR pszCurrServicePack,
                IN LPCWSTR pszOperatingSystem,
                IN LPWSTR pszOperatingSystemVersion);

DWORD
DisplayRemoteOutputEx(IN LPWSTR pszServerName,
                OUT LPWSTR pszOSName,
                IN LPWSTR pszOSRole,
                IN LPWSTR pszOSComp,
                IN LPWSTR pszCurrBuildNumber,
                IN LPWSTR pszCurrServicePack,
                IN LPCWSTR pszOperatingSystem,
                IN LPWSTR pszOperatingSystemVersion,
                //BOOL bServer,
                BOOL bDatacenterServer,
                BOOL bAdvancedServer,
                BOOL bPersonal,
                BOOL bWorkstation,
                BOOL bBladeServer,
			    BOOL bForSBSServer);


DWORD
GetTypeUsage();

BOOL
DisplayOutput(IN LPWSTR pszServerName,
              IN LPWSTR pszOSName,
              IN LPWSTR pszOSVersion,
              IN LPWSTR pszOSRole,
              IN LPWSTR pszOSComp);
/*DWORD
DisplayErrorMsg( IN DWORD dw );*/

BOOL
IsTerminalServer(LPWSTR szServer,
                 PBOOL pbTermServicesInstalled);



BOOL IsBladeServer(PBOOL pbBladeStatus,
                   LPWSTR lpszServer,
                   BOOL bLocal);
/********************Function definitions **************/

DWORD _cdecl
wmain( IN DWORD argc,
      IN LPCWSTR argv[] )
/*++
Routine Description:
    This is the Main function which calls all the other functions
    depending on the option specified by the user.

Arguments:
   [ IN ] argc - Number of command line arguments.
   [ IN ] argv - Array containing command line arguments.

Return Value:
   EXIT_FALSE if GetType utility is not successful.
   EXIT_TRUE if GetType utility is successful.
--*/
{
    DWORD dwMemorySize =0; // Memory needed for allocation.
    DWORD dwCleanExit = 0;
    BOOL bResult = TRUE;
    BOOL bUsage = FALSE;    // /? ( help )
    BOOL bOSRole = FALSE;
    BOOL bServicePk = FALSE;
    BOOL bVersion = FALSE;
    BOOL bMinorVer = FALSE;
    BOOL bMajorVer = FALSE;
    BOOL bOSType   = FALSE;
    BOOL bBuildNumber = FALSE;
    BOOL bNeedPassword = FALSE;
    BOOL    bCloseConnection = FALSE;
    UINT i = 0;
    LPWSTR pszServer = NULL;

    LPWSTR pszRmtServer = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    //LPWSTR pszHostAddr = NULL;



    // Following is a guess to allocate the memory for variables used
    // in many function. Guess is to allocate memory equals to Lenghth of
    // maximum command line argumant.
    for( i = 1;i < argc;i++)
    {
        //if(dwMemorySize < (DWORD)lstrlen(argv[i]))
        if(dwMemorySize < (DWORD)StringLengthW(argv[i], 0))
        {
            //dwMemorySize = lstrlen(argv[i]);
            dwMemorySize = StringLengthW(argv[i], 0);
        }
    }

    // Check for minimum memory required. If above logic gets memory size
    // less than MIN_MEMORY_REQUIRED, then make this to MIN_MEMORY_REQUIRED.

    dwMemorySize = ((dwMemorySize < MIN_MEMORY_REQUIRED)?
                                   MIN_MEMORY_REQUIRED:
                                   dwMemorySize);

    // host name in the output
    // Check if memory allocated to all variables properly
    pszServer = AllocateMemory( ( dwMemorySize + 1 ) * sizeof( WCHAR ) );

    if(NULL == pszServer)
    {
        // Some variable not having enough memory
        // Show Error----
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        ReleaseGlobals();
        return EXIT_FALSE;
    }

    SecureZeroMemory(pszServer, dwMemorySize );


    if(argc == 1)
    {
        if ( FALSE == GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, pszServer, &dwMemorySize ))
        {

            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            FREE_MEMORY(pszServer);
            FREE_MEMORY(pszRmtServer);
            FREE_MEMORY(pszUserName);
            FREE_MEMORY(pszPassword);
            ReleaseGlobals();
            return EXIT_FALSE;
        }

        dwCleanExit =  ProcessType( pszServer,
                                    FALSE,
                                    FALSE,
                                    FALSE,
                                    FALSE,
                                    FALSE,
                                    FALSE,
                                    FALSE);
    }
    else
    {

        bResult = ProcessOptions( argc,
                                argv,
                                &bUsage,
                                &bOSRole,
                                &bServicePk,
                                &bVersion,
                                &bMinorVer,
                                &bMajorVer,
                                &bOSType,
                                &bBuildNumber,
                                &pszRmtServer,
                                &pszUserName,
                                &pszPassword,
                                &bNeedPassword);

        if ( FALSE == bResult )
        {
            // invalid syntax
            // return from the function
            FREE_MEMORY(pszServer);
            FREE_MEMORY(pszRmtServer);
            FREE_MEMORY(pszUserName);
            FREE_MEMORY(pszPassword);
            ReleaseGlobals();
            return EXIT_FALSE;
        }


        if(TRUE == bUsage)
        {
            dwCleanExit = GetTypeUsage();
            FREE_MEMORY(pszServer);
            ReleaseGlobals();
            return ( dwCleanExit );

        }


        if(TRUE == IsLocalSystem(IsUNCFormat(pszRmtServer)?(pszRmtServer + 2) : (pszRmtServer)))
        {

           if((NULL != pszRmtServer) && (NULL != pszUserName))
           {
               if(StringLengthW(pszUserName, 0) > 0)
               {
                    ShowMessage(stderr, GetResString(IDS_IGNORE_LOCALCREDENTIALS ));
               }
           }

           if ( FALSE == GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, pszServer, &dwMemorySize ))
            {
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                FREE_MEMORY(pszServer);
                FREE_MEMORY(pszRmtServer);
                FREE_MEMORY(pszUserName);
                FREE_MEMORY(pszPassword);
                ReleaseGlobals();
                return EXIT_FALSE;
            }

           dwCleanExit = ProcessType(pszServer,
                                    bOSRole,
                                    bServicePk,
                                    bVersion,
                                    bMinorVer,
                                    bMajorVer,
                                    bOSType,
                                    bBuildNumber);

        }
        else
        {
            if(EstablishConnection( pszRmtServer,
                                    pszUserName,
                                    GetBufferSize(pszUserName) / sizeof(WCHAR),
                                    pszPassword,
                                    GetBufferSize(pszPassword) / sizeof(WCHAR),
                                    bNeedPassword )==FALSE)
            {

                // Connection to remote system failed , Show corresponding error
                // and exit from function.
                ShowMessage( stderr,GetResString(IDS_TAG_ERROR) );
                ShowMessage( stderr,SPACE );
                ShowMessage( stderr,GetReason() );
                //StringCopyW(pszPassword, cwszNullString, (GetBufferSize(pszPassword) / sizeof(WCHAR)) );

                //Release allocated memory safely
                FREE_MEMORY(pszServer);
                FREE_MEMORY(pszRmtServer);
                FREE_MEMORY(pszUserName);
                FREE_MEMORY(pszPassword);
                ReleaseGlobals();
                return EXIT_FALSE;
            }

            // determine whether this connection needs to disconnected later or not
            // though the connection is successfull, some conflict might have occured
            switch( GetLastError() )
            {
            case I_NO_CLOSE_CONNECTION:
                bCloseConnection = FALSE;
                break;

            case E_LOCAL_CREDENTIALS:
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                {
                    //
                    // some error occured ... but can be ignored

                    // connection need not be disconnected
                    bCloseConnection= FALSE;

                    // show the warning message
                    ShowLastErrorEx(stderr, SLE_TYPE_WARNING | SLE_SYSTEM);
                    break;
                }
            default:
                bCloseConnection = TRUE;

            }

            FREE_MEMORY(pszPassword);

            dwCleanExit = ProcessTypeRemote(pszRmtServer,
                                            bOSRole,
                                            bServicePk,
                                            bVersion,
                                            bMinorVer,
                                            bMajorVer,
                                            bOSType,
                                            bBuildNumber);

            if( TRUE == bCloseConnection )
            {
                CloseConnection( pszRmtServer );
            }
        }

    }

    FREE_MEMORY(pszServer);
    FREE_MEMORY(pszRmtServer);
    FREE_MEMORY(pszUserName);
    ReleaseGlobals();
    return dwCleanExit;
}

BOOL
ProcessOptions(IN DWORD argc,
               IN LPCWSTR argv[],
               OUT PBOOL  pbUsage,
               OUT PBOOL  pbOSRole,
               OUT PBOOL  pbServicePk,
               OUT PBOOL  pbVersion,
               OUT PBOOL  pbMinorVer,
               OUT PBOOL  pbMajorVer,
               OUT PBOOL  pbOSType,
               OUT PBOOL  pbBuildNumber,
               OUT LPTSTR* pszServer,
               OUT LPTSTR* pszUserName,
               OUT LPTSTR* pszPassword,
               OUT PBOOL  pbNeedPassword)


/*++

Routine Description:

This function takes command line argument and checks for correct syntax .


Arguments:

    [in]    argc            - Number of command line arguments
    [in]    argv            - Array containing command line arguments
    [out]   pbUsage         - The usage option
    [out]   pbOSRole        - Operating System Role
    [out]   pbServicePk     - Service Pack of the Operating System
    [out]   pbVersion       - Version of the Operating System
    [out]   pbMinorVer      - Minor Version of the Operating System
    [out]   pbMajorVer      - Major Version of the Operating system
    [out]   pbOSType        - Operating system Type
    [out]   pbBuildNumber   - Build Number of the Operating System
    [out]   pszServer       - Server to connect to
    [out]   pszUserName     - User name with which to connect to
    [out]   pszPassword     - Password with which to connect to
    [out]   pbNeedPassword  - Whether prompting for password is required or not


Returned Value:

     --TRUE if it succeeds
     -- FALSE if it fails.
--*/
{

    WCHAR wszBuffer[MAX_RES_STRING] ;

    // local variables
    TCMDPARSER2 cmdOptions[ MAX_OPTIONS ];//Variable to store command line

    const WCHAR*   wszOptionUsage          =     L"?"  ;  //OPTION_USAGE
    const WCHAR*   wszOptionOSRole         =     L"role"  ;//OPTION_OSROLE
    const WCHAR*   wszOptionServicePack    =     L"sp"   ;//OPTION_SERVICEPACK
    const WCHAR*   wszOptionMinorVersion   =     L"minv"  ;//OPTION_MINORVERSION
    const WCHAR*   wszOptionMajorVersion   =     L"majv"    ;//OPTION_MAJORVERSION
    const WCHAR*   wszOptionOSType         =     L"type"   ; //OPTION_OSTYPE
    const WCHAR*   wszOptionVersion        =     L"ver"    ; //OPTION_VERSION
    const WCHAR*   wszBuildNumber          =     L"build"    ; //OPTION_BUILDNUMBER
    const WCHAR*   wszServer               =     L"s"  ;  //OPTION_SERVER
    const WCHAR*   wszUserName             =     L"u"  ; //wszUserName
    const WCHAR*   wszOptionPassword       =     L"p"  ; //OPTION_PASSWORD


    SecureZeroMemory(wszBuffer, MAX_RES_STRING * sizeof(WCHAR));

    // /? option for help
    StringCopyA( cmdOptions[ OI_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_USAGE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_USAGE ].pwszOptions = wszOptionUsage;
    cmdOptions[ OI_USAGE ].pwszFriendlyName = NULL;
    cmdOptions[ OI_USAGE ].pwszValues = NULL;
    cmdOptions[ OI_USAGE ].dwCount = 1;
    cmdOptions[ OI_USAGE ].dwActuals = 0;
    cmdOptions[ OI_USAGE ].dwFlags = CP2_USAGE;
    cmdOptions[ OI_USAGE ].pValue = pbUsage;
    cmdOptions[ OI_USAGE ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_USAGE ].pFunction = NULL;
    cmdOptions[ OI_USAGE ].pFunctionData = NULL;
    cmdOptions[ OI_USAGE ].dwReserved = 0;
    cmdOptions[ OI_USAGE ].pReserved1 = NULL;
    cmdOptions[ OI_USAGE ].pReserved2 = NULL;
    cmdOptions[ OI_USAGE ].pReserved3 = NULL;

    // /role option for OSRole
    StringCopyA( cmdOptions[ OI_OSROLE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_OSROLE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_OSROLE ].pwszOptions = wszOptionOSRole;
    cmdOptions[ OI_OSROLE ].pwszFriendlyName = NULL;
    cmdOptions[ OI_OSROLE ].pwszValues = NULL;
    cmdOptions[ OI_OSROLE ].dwCount = 1;
    cmdOptions[ OI_OSROLE ].dwActuals = 0;
    cmdOptions[ OI_OSROLE ].dwFlags = 0;
    cmdOptions[ OI_OSROLE ].pValue = pbOSRole;
    cmdOptions[ OI_OSROLE ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_OSROLE ].pFunction = NULL;
    cmdOptions[ OI_OSROLE ].pFunctionData = NULL;
    cmdOptions[ OI_OSROLE ].dwReserved = 0;
    cmdOptions[ OI_OSROLE ].pReserved1 = NULL;
    cmdOptions[ OI_OSROLE ].pReserved2 = NULL;
    cmdOptions[ OI_OSROLE ].pReserved3 = NULL;

    // /sp option for Service Pack
    StringCopyA( cmdOptions[ OI_SERVICEPACK ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_SERVICEPACK ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_SERVICEPACK ].pwszOptions = wszOptionServicePack;
    cmdOptions[ OI_SERVICEPACK ].pwszFriendlyName = NULL;
    cmdOptions[ OI_SERVICEPACK ].pwszValues = NULL;
    cmdOptions[ OI_SERVICEPACK ].dwCount = 1;
    cmdOptions[ OI_SERVICEPACK ].dwActuals = 0;
    cmdOptions[ OI_SERVICEPACK ].dwFlags = 0;
    cmdOptions[ OI_SERVICEPACK ].pValue = pbServicePk;
    cmdOptions[ OI_SERVICEPACK ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_SERVICEPACK ].pFunction = NULL;
    cmdOptions[ OI_SERVICEPACK ].pFunctionData = NULL;
    cmdOptions[ OI_SERVICEPACK ].dwReserved = 0;
    cmdOptions[ OI_SERVICEPACK ].pReserved1 = NULL;
    cmdOptions[ OI_SERVICEPACK ].pReserved2 = NULL;
    cmdOptions[ OI_SERVICEPACK ].pReserved3 = NULL;

    // /ver option for Version
    StringCopyA( cmdOptions[ OI_VERSION ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_VERSION ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_VERSION ].pwszOptions = wszOptionVersion;
    cmdOptions[ OI_VERSION ].pwszFriendlyName = NULL;
    cmdOptions[ OI_VERSION ].pwszValues = NULL;
    cmdOptions[ OI_VERSION ].dwCount = 1;
    cmdOptions[ OI_VERSION ].dwActuals = 0;
    cmdOptions[ OI_VERSION ].dwFlags = 0;
    cmdOptions[ OI_VERSION ].pValue = pbVersion;
    cmdOptions[ OI_VERSION ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_VERSION ].pFunction = NULL;
    cmdOptions[ OI_VERSION ].pFunctionData = NULL;
    cmdOptions[ OI_VERSION ].dwReserved = 0;
    cmdOptions[ OI_VERSION ].pReserved1 = NULL;
    cmdOptions[ OI_VERSION ].pReserved2 = NULL;
    cmdOptions[ OI_VERSION ].pReserved3 = NULL;

    // /minv option for Minor Version
    StringCopyA( cmdOptions[ OI_MINOR_VERSION ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_MINOR_VERSION ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_MINOR_VERSION ].pwszOptions = wszOptionMinorVersion;
    cmdOptions[ OI_MINOR_VERSION ].pwszFriendlyName = NULL;
    cmdOptions[ OI_MINOR_VERSION ].pwszValues = NULL;
    cmdOptions[ OI_MINOR_VERSION ].dwCount = 1;
    cmdOptions[ OI_MINOR_VERSION ].dwActuals = 0;
    cmdOptions[ OI_MINOR_VERSION ].dwFlags = 0;
    cmdOptions[ OI_MINOR_VERSION ].pValue = pbMinorVer;
    cmdOptions[ OI_MINOR_VERSION ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_MINOR_VERSION ].pFunction = NULL;
    cmdOptions[ OI_MINOR_VERSION ].pFunctionData = NULL;
    cmdOptions[ OI_MINOR_VERSION ].dwReserved = 0;
    cmdOptions[ OI_MINOR_VERSION ].pReserved1 = NULL;
    cmdOptions[ OI_MINOR_VERSION ].pReserved2 = NULL;
    cmdOptions[ OI_MINOR_VERSION ].pReserved3 = NULL;

    // /majv option for Major Version
    StringCopyA( cmdOptions[ OI_MAJOR_VERSION ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_MAJOR_VERSION ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_MAJOR_VERSION ].pwszOptions = wszOptionMajorVersion;
    cmdOptions[ OI_MAJOR_VERSION ].pwszFriendlyName = NULL;
    cmdOptions[ OI_MAJOR_VERSION ].pwszValues = NULL;
    cmdOptions[ OI_MAJOR_VERSION ].dwCount = 1;
    cmdOptions[ OI_MAJOR_VERSION ].dwActuals = 0;
    cmdOptions[ OI_MAJOR_VERSION ].dwFlags = 0;
    cmdOptions[ OI_MAJOR_VERSION ].pValue = pbMajorVer;
    cmdOptions[ OI_MAJOR_VERSION ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_MAJOR_VERSION ].pFunction = NULL;
    cmdOptions[ OI_MAJOR_VERSION ].pFunctionData = NULL;
    cmdOptions[ OI_MAJOR_VERSION ].dwReserved = 0;
    cmdOptions[ OI_MAJOR_VERSION ].pReserved1 = NULL;
    cmdOptions[ OI_MAJOR_VERSION ].pReserved2 = NULL;
    cmdOptions[ OI_MAJOR_VERSION ].pReserved3 = NULL;

    // /type option for OSType
    StringCopyA( cmdOptions[ OI_OSTYPE ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_OSTYPE ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_OSTYPE ].pwszOptions = wszOptionOSType;
    cmdOptions[ OI_OSTYPE ].pwszFriendlyName = NULL;
    cmdOptions[ OI_OSTYPE ].pwszValues = NULL;
    cmdOptions[ OI_OSTYPE ].dwCount = 1;
    cmdOptions[ OI_OSTYPE ].dwActuals = 0;
    cmdOptions[ OI_OSTYPE ].dwFlags = 0;
    cmdOptions[ OI_OSTYPE ].pValue = pbOSType;
    cmdOptions[ OI_OSTYPE ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_OSTYPE ].pFunction = NULL;
    cmdOptions[ OI_OSTYPE ].pFunctionData = NULL;
    cmdOptions[ OI_OSTYPE ].dwReserved = 0;
    cmdOptions[ OI_OSTYPE ].pReserved1 = NULL;
    cmdOptions[ OI_OSTYPE ].pReserved2 = NULL;
    cmdOptions[ OI_OSTYPE ].pReserved3 = NULL;

    // /build option for build number
    StringCopyA( cmdOptions[ OI_BUILD ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_BUILD ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ OI_BUILD ].pwszOptions = wszBuildNumber;
    cmdOptions[ OI_BUILD ].pwszFriendlyName = NULL;
    cmdOptions[ OI_BUILD ].pwszValues = NULL;
    cmdOptions[ OI_BUILD ].dwCount = 1;
    cmdOptions[ OI_BUILD ].dwActuals = 0;
    cmdOptions[ OI_BUILD ].dwFlags = 0;
    cmdOptions[ OI_BUILD ].pValue = pbBuildNumber;
    cmdOptions[ OI_BUILD ].dwLength    = MAX_STRING_LENGTH;
    cmdOptions[ OI_BUILD ].pFunction = NULL;
    cmdOptions[ OI_BUILD ].pFunctionData = NULL;
    cmdOptions[ OI_BUILD ].dwReserved = 0;
    cmdOptions[ OI_BUILD ].pReserved1 = NULL;
    cmdOptions[ OI_BUILD ].pReserved2 = NULL;
    cmdOptions[ OI_BUILD ].pReserved3 = NULL;

    // -s  option remote system name
    StringCopyA( cmdOptions[ OI_SERVER ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_SERVER ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_SERVER ].pwszOptions = wszServer;
    cmdOptions[ OI_SERVER ].pwszFriendlyName = NULL;
    cmdOptions[ OI_SERVER ].pwszValues = NULL;
    cmdOptions[ OI_SERVER ].dwCount = 1;
    cmdOptions[ OI_SERVER ].dwActuals = 0;
    cmdOptions[ OI_SERVER ].dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    cmdOptions[ OI_SERVER ].pValue = NULL;
    cmdOptions[ OI_SERVER ].dwLength    = 0;
    cmdOptions[ OI_SERVER ].pFunction = NULL;
    cmdOptions[ OI_SERVER ].pFunctionData = NULL;
    cmdOptions[ OI_SERVER ].dwReserved = 0;
    cmdOptions[ OI_SERVER ].pReserved1 = NULL;
    cmdOptions[ OI_SERVER ].pReserved2 = NULL;
    cmdOptions[ OI_SERVER ].pReserved3 = NULL;

    // -u  option user name for the specified system
    StringCopyA( cmdOptions[ OI_USERNAME ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_USERNAME ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_USERNAME ].pwszOptions = wszUserName;
    cmdOptions[ OI_USERNAME ].pwszFriendlyName = NULL;
    cmdOptions[ OI_USERNAME ].pwszValues = NULL;
    cmdOptions[ OI_USERNAME ].dwCount = 1;
    cmdOptions[ OI_USERNAME ].dwActuals = 0;
    cmdOptions[ OI_USERNAME ].dwFlags =  CP2_VALUE_TRIMINPUT | CP2_ALLOCMEMORY | CP2_VALUE_NONULL;
    cmdOptions[ OI_USERNAME ].pValue = NULL;
    cmdOptions[ OI_USERNAME ].dwLength    = 0;
    cmdOptions[ OI_USERNAME ].pFunction = NULL;
    cmdOptions[ OI_USERNAME ].pFunctionData = NULL;
    cmdOptions[ OI_USERNAME ].dwReserved = 0;
    cmdOptions[ OI_USERNAME ].pReserved1 = NULL;
    cmdOptions[ OI_USERNAME ].pReserved2 = NULL;
    cmdOptions[ OI_USERNAME ].pReserved3 = NULL;

    // -p option password for the given username
    StringCopyA( cmdOptions[ OI_PASSWORD ].szSignature, "PARSER2\0", 8 );
    cmdOptions[ OI_PASSWORD ].dwType = CP_TYPE_TEXT;
    cmdOptions[ OI_PASSWORD ].pwszOptions = wszOptionPassword;
    cmdOptions[ OI_PASSWORD ].pwszFriendlyName = NULL;
    cmdOptions[ OI_PASSWORD ].pwszValues = NULL;
    cmdOptions[ OI_PASSWORD ].dwCount = 1;
    cmdOptions[ OI_PASSWORD ].dwActuals = 0;
    cmdOptions[ OI_PASSWORD ].dwFlags =  CP2_VALUE_OPTIONAL | CP2_ALLOCMEMORY ;
    cmdOptions[ OI_PASSWORD ].pValue = NULL;
    cmdOptions[ OI_PASSWORD ].dwLength    = 0;
    cmdOptions[ OI_PASSWORD ].pFunction = NULL;
    cmdOptions[ OI_PASSWORD ].pFunctionData = NULL;
    cmdOptions[ OI_PASSWORD ].dwReserved = 0;
    cmdOptions[ OI_PASSWORD ].pReserved1 = NULL;
    cmdOptions[ OI_PASSWORD ].pReserved2 = NULL;
    cmdOptions[ OI_PASSWORD ].pReserved3 = NULL;

    /*The OS version is set to 5 and above in order for the utility to run for windows 2000 and above*/
    if ( FALSE == SetOsVersion ( MAJOR_VER, MINOR_VER, SERVICE_PACK_MAJOR ) )
    {

        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return FALSE;
    }

    // do the command line parsing
    if ( DoParseParam2( argc,argv, -1, SIZE_OF_ARRAY(cmdOptions), cmdOptions, 0 ) == FALSE )
    {
        SecureZeroMemory(wszBuffer, MAX_RES_STRING);
        ShowMessage(stderr,GetResString(IDS_TAG_ERROR));
        ShowMessage(stderr,L" ");
        ShowMessage(stderr,GetReason());
        return FALSE;       // invalid syntax
    }

    *pszServer   = (LPWSTR)cmdOptions[OI_SERVER].pValue;
    *pszUserName = (LPWSTR)cmdOptions[OI_USERNAME].pValue;
    *pszPassword = (LPWSTR)cmdOptions[OI_PASSWORD].pValue;

    if ( *pszServer != NULL )
    {
        //
        // if -u is not specified, we need to allocate memory
        // in order to be able to retrive the current user name
        //
        // case 1: -p is not at all specified
        // as the value for this switch is optional, we have to rely
        // on the dwActuals to determine whether the switch is specified or not
        // in this case utility needs to try to connect first and if it fails
        // then prompt for the password -- in fact, we need not check for this
        // condition explicitly except for noting that we need to prompt for the
        // password
        //
        // case 2: -p is specified
        // but we need to check whether the value is specified or not
        // in this case user wants the utility to prompt for the password
        // before trying to connect
        //
        // case 3: -p * is specified

        // user name
        if ( *pszUserName == NULL )
        {
            *pszUserName = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *pszUserName == NULL )
            {
                SaveLastError();
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                return EXIT_FAILURE;
            }
        }

        // password
        if ( *pszPassword == NULL )
        {
            *pbNeedPassword = TRUE;
            *pszPassword = (LPWSTR)AllocateMemory( MAX_STRING_LENGTH * sizeof( WCHAR ) );
            if ( *pszPassword == NULL )
            {
                SaveLastError();
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                return EXIT_FAILURE;
            }
        }

        // case 1
        /*if ( cmdOptions[OPTION_PASSWORD].dwActuals == 0 )
        {
            // we need not do anything special here
        }*/
        if ( cmdOptions[OI_PASSWORD].pValue == NULL )
            {
                StringCopy( *pszPassword, L"*", GetBufferSize((LPVOID)(*pszPassword)));
            }
         else
           if ( StringCompareEx( *pszPassword, L"*", TRUE, 0 ) == 0 )
            {

                if ( ReallocateMemory( (LPVOID*)((pszPassword)),
                                       MAX_STRING_LENGTH * sizeof( WCHAR ) ) == FALSE )
                {
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    return EXIT_FAILURE;
                }

                *pbNeedPassword = TRUE;
            }

    }

    if((TRUE == *pbUsage) &&(argc > 2))
    {

        SetLastError((DWORD)MK_E_SYNTAX);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
        return FALSE;
    }

    if((TRUE == *pbOSRole)&&
        ((TRUE == *pbServicePk)||
        (TRUE == *pbVersion)||
        (TRUE == *pbMinorVer)||
        (TRUE == *pbMajorVer)||
        (TRUE == *pbOSType)||
        (TRUE == *pbBuildNumber)||
        (TRUE == *pbUsage))
        )
    {

        SetLastError((DWORD)MK_E_SYNTAX);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
        return FALSE;
    }
    else
        if((TRUE == *pbServicePk)&&
        ((TRUE == *pbOSRole)||
        (TRUE == *pbVersion)||
        (TRUE == *pbMinorVer)||
        (TRUE == *pbMajorVer)||
        (TRUE == *pbOSType)||
        (TRUE == *pbBuildNumber)||
        (TRUE == *pbUsage))
        )
        {

            SetLastError((DWORD)MK_E_SYNTAX);
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
            return FALSE;
        }
        else
            if((TRUE == *pbVersion)&&
            ((TRUE == *pbOSRole)||
            (TRUE == *pbServicePk)||
            (TRUE == *pbMinorVer)||
            (TRUE == *pbMajorVer)||
            (TRUE == *pbOSType)||
            (TRUE == *pbBuildNumber)||
            (TRUE == *pbUsage))
            )
            {

                SetLastError((DWORD)MK_E_SYNTAX);
                SaveLastError();
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
                return FALSE;
            }
            else
                if((TRUE == *pbMinorVer)&&
                ((TRUE == *pbOSRole)||
                (TRUE == *pbServicePk)||
                (TRUE == *pbVersion)||
                (TRUE == *pbMajorVer)||
                (TRUE == *pbOSType)||
                (TRUE == *pbBuildNumber)||
                (TRUE == *pbUsage))
                )
                {

                    SetLastError((DWORD)MK_E_SYNTAX);
                    SaveLastError();
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
                    return FALSE;
                }
                else
                    if((TRUE == *pbMajorVer)&&
                    ((TRUE == *pbOSRole)||
                    (TRUE == *pbServicePk)||
                    (TRUE == *pbVersion)||
                    (TRUE == *pbMinorVer)||
                    (TRUE == *pbOSType)||
                    (TRUE == *pbBuildNumber)||
                    (TRUE == *pbUsage))
                    )
                    {

                        SetLastError((DWORD)MK_E_SYNTAX);
                        SaveLastError();
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                        ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
                        return FALSE;
                    }
                    else
                        if((TRUE == *pbOSType)&&
                        ((TRUE == *pbOSRole)||
                        (TRUE == *pbServicePk)||
                        (TRUE == *pbVersion)||
                        (TRUE == *pbMinorVer)||
                        (TRUE == *pbMajorVer)||
                        (TRUE == *pbBuildNumber)||
                        (TRUE == *pbUsage))
                        )
                        {
                            SetLastError((DWORD)MK_E_SYNTAX);
                            SaveLastError();
                            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                            ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
                            return FALSE;
                        }
                        else
                            if((TRUE == *pbBuildNumber)&&
                            ((TRUE == *pbOSRole)||
                            (TRUE == *pbServicePk)||
                            (TRUE == *pbVersion)||
                            (TRUE == *pbMinorVer)||
                            (TRUE == *pbMajorVer)||
                            (TRUE == *pbOSType)||
                            (TRUE == *pbUsage))
                            )
                            {
                                SetLastError((DWORD)MK_E_SYNTAX);
                                SaveLastError();
                                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                                ShowMessage( stderr, GetResString(IDS_HELP_MESSAGE) );
                                return FALSE;
                            }



    // return false if username is entered without machine name
    if ( ( 0 != cmdOptions[ OI_USERNAME ].dwActuals ) &&
                ( 0 == cmdOptions[ OI_SERVER ].dwActuals ) )
    {
        ShowMessage( stderr, ERROR_USER_WITH_NOSERVER );
        return( FALSE );
    }

    //if password entered without username then return false
    if( ( 0 == cmdOptions[ OI_USERNAME ].dwActuals ) &&
                ( 0 != cmdOptions[ OI_PASSWORD ].dwActuals ) )
    {
        ShowMessage( stderr, ERROR_PASSWORD_WITH_NUSER );
        return( FALSE );
    }

    //if /s is entered with empty string
    if( ( 0 != cmdOptions[ OI_SERVER ].dwActuals != 0 ) &&
                                      ( 0 == StringLengthW( *pszServer, 0 ) ) )
                                    //( 0 == lstrlen( pszServer ) ) )
    {
        ShowMessage( stderr, ERROR_NULL_SERVER );
        return( FALSE );
    }

    //if /u is entered with empty string
    if( ( 0 != cmdOptions[ OI_USERNAME ].dwActuals ) &&
                                      ( 0 == StringLengthW( *pszUserName, 0 ) ) )
                                    //( 0 == lstrlen( pszUserName ) ) )
    {
        ShowMessage( stderr, ERROR_NULL_USER );
        return( FALSE );
    }

    //assign the data obtained from parsing to the call by address parameters
    if ( ( 0 != cmdOptions[ OI_PASSWORD ].dwActuals ) &&
                    ( 0 == StringCompare( *pszPassword, ASTERIX, TRUE, 0 ) ) )

    {
        // user wants the utility to prompt for the password before trying to connect
        *pbNeedPassword = TRUE;
    }
    else if ( 0 == cmdOptions[ OI_PASSWORD ].dwActuals &&
            ( 0 != cmdOptions[ OI_SERVER ].dwActuals || 0 != cmdOptions[ OI_USERNAME ].dwActuals ) )
    {
        // /s, /u is specified without password ...
        // utility needs to try to connect first and if it fails then prompt for the password
        *pbNeedPassword = TRUE;
        StringCopyW(*pszPassword, NULL_U_STRING, GetBufferSize(*pszPassword) / sizeof(WCHAR));
    }

    return TRUE;

}

DWORD
ProcessType(IN LPWSTR pszServer,
            IN BOOL  bOSRole,
            IN BOOL  bServicePk,
            IN BOOL  bVersion,
            IN BOOL  bMinorVer,
            IN BOOL  bMajorVer,
            IN BOOL  bOSType,
            IN BOOL  bBuildNumber)

/*++

Routine Description:

    This function gets the type of the Operating System by connecting to the registries


Arguments:

    [in]    pszServer       - Server Name
    [in]    bOSRole         - Operating system Role
    [in]    bServicePk      - Service pack installed
    [in]    bVersion        - Version of the Operating System
    [in]    bMinorVer       - Minor Version of the Operating System
    [in]    bMajorVer       - Major Version of the Operating System
    [in]    bOSType         - Type of the Operating System
    [in]    bBuildNumber    - Build Number of the Operating System


Returned Value:

    -- 0 if it succeeds
    -- 255 if it fails.
--*/

{
    OSVERSIONINFOEX osvi;
    BOOL bOsVersionInfoEx;
    BOOL bStatus = EXIT_FALSE;

    BOOL bBladeStatus = FALSE;

    WCHAR  szOSName[MAX_OS_FEATURE_LENGTH];
    WCHAR  szOSVersion[MAX_OS_FEATURE_LENGTH];
    WCHAR  szOSRole[MAX_OS_FEATURE_LENGTH];
    WCHAR szOSComp[MAX_OS_FEATURE_LENGTH];
    WCHAR szCurrBuildNumber[MAX_CURRBUILD_LENGTH];
    WCHAR* szComputerName = NULL;

    WCHAR szTempoServer[2*MAX_STRING_LENGTH];
    DWORD retValue = 0;

    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBuffer= NULL;

    BOOL bTermServicesInstalled = FALSE;

    SecureZeroMemory(szOSName, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szOSVersion, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szOSRole, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szOSComp, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szCurrBuildNumber, MAX_CURRBUILD_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szTempoServer, (2*MAX_STRING_LENGTH) * sizeof(WCHAR));




    StringCopyW( szTempoServer ,pszServer , 2*MAX_STRING_LENGTH );

    if(pszServer != NULL)
    {
        szComputerName = wcstok(szTempoServer,DOT);
        if(NULL == szComputerName)
        {
            SetLastError(IDS_INVALID_SERVER_NAME);
            SaveLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
            return EXIT_FALSE;
        }

    }

    /*Initialize the OS version structure to zero*/

    SecureZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi);

    if( !(bOsVersionInfoEx) )
    {
        osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) )
        {

            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            return EXIT_FALSE;

        }
    }

    if(osvi.dwMajorVersion < 5)
    {
        ShowMessage(stderr, GetResString(IDS_PREWINDOWS_2000));
        return EXIT_FALSE;
    }
    else
    {
        if((osvi.dwMajorVersion > 5) || (5 == osvi.dwMajorVersion  && osvi.dwMinorVersion > 2))
        {
            ShowMessage(stderr, GetResString(IDS_NEXT_VERSION));
            return EXIT_FALSE;
        }

    }


    if(1 == bBuildNumber )
    {

        return (osvi.dwBuildNumber);
    }


    if(1 == bMajorVer)    //return major version if /MAJV switch is typed
    {
        return ((OS_MULTPLN_FACTOR_1000)*(osvi.dwMajorVersion));
    }


    if(1 == bMinorVer)   //return minor version if /MINV switch is typed
    {
        return ((OS_MULTPLN_FACTOR_100)*(osvi.dwMinorVersion));
    }


    if(1 == bVersion)     //returns both major and minor version if /V switch is typed
    {
        return ((OS_MULTPLN_FACTOR_1000)*(osvi.dwMajorVersion)+(OS_MULTPLN_FACTOR_100)*(osvi.dwMinorVersion));
    }


    if(1 == bServicePk)   //returns the service pack if /SP switch is typed
    {
        if(StringLengthW(osvi.szCSDVersion, 0))
        {
            return (osvi.szCSDVersion[14- 1] - L'0');

        }
        else
        {
            return RETVALZERO;
        }
    }


    if(1 == bOSType)
    {
        if( osvi.wProductType == VER_NT_WORKSTATION )
        {
            if(osvi.wSuiteMask & VER_SUITE_PERSONAL) //The system is a Windows Personal
            {
                return (OS_FLAVOUR_PERSONAL);
            }
            else
            {
                return (OS_FLAVOUR_PROFESSIONAL);
            }
        }
        else
        {
            if(osvi.wSuiteMask & VER_SUITE_DATACENTER) //The system is a Windows Datacenter
            {
                return (OS_FLAVOUR_DATACENTER);
            }
            else
            {
                if(osvi.wSuiteMask & VER_SUITE_ENTERPRISE) //The system is a Windows Advanced Server
                {
                    return (OS_FLAVOUR_ADVANCEDSERVER);
                }
                else
                {
                    bStatus = IsBladeServer(&bBladeStatus,NULL,FALSE);
                    if(EXIT_TRUE == bStatus)
                    {
                        if(TRUE == bBladeStatus)
                        {
                            return (OS_FLAVOUR_WEBSERVER);
                        }
                        else
                        {
                            return (OS_FLAVOUR_SERVER);
                        }
                    }
                    else
                    {
                        return EXIT_FALSE;
                    }
                }
            }
        }
    }


    /* Convert the build number to string type */
    _ultow(osvi.dwBuildNumber,szCurrBuildNumber,10);

    if(0 == StringLengthW(szCurrBuildNumber, 0) )
    {
        SetLastError(IDS_VAL_NOT_CONVERT);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return EXIT_FALSE;

    }

    if(osvi.wProductType == VER_NT_DOMAIN_CONTROLLER) //The system is a Domain Controller
    {
        if(1 == bOSRole)
        {
            return (OS_ROLE_DC);
        }
        else
        {
            if(FALSE == bOSRole)
            {
                StringCopyW( szOSRole ,DOMAIN_CONTROLLER ,MAX_OS_FEATURE_LENGTH );
            }

        }

    }
    else
    {
        retValue = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic,(PBYTE *) &pBuffer );
        if (retValue == ERROR_SUCCESS)
        {
            if ((NULL != pBuffer) && ( pBuffer->MachineRole >= 0) )
              {
                switch ( pBuffer->MachineRole )
                {
                    case 0:
                    case 2: if(1 == bOSRole)
                            {
                                return (OS_ROLE_WORKGROUP);
                            }
                            else
                            {
                                if(FALSE == bOSRole)
                                {
                                    StringCopyW( szOSRole ,WORKGROUP ,MAX_OS_FEATURE_LENGTH );
                                }
                            }

                            break;


                    case 1:
                    case 3:
                    case 4: if(1 == bOSRole)
                            {
                                return (OS_ROLE_MEMBER_SERVER);
                            }
                            else
                            {
                                if(FALSE == bOSRole)
                                {
                                    StringCopyW( szOSRole, MEMBER_SERVER, MAX_OS_FEATURE_LENGTH );

                                }

                            }

                            break;

                    default: break;

                }
              }
        }
        else
        {

            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            return EXIT_FAILURE;

        }

        if(NULL != pBuffer)
        {
            DsRoleFreeMemory( pBuffer );
            pBuffer = NULL;
        }

    }

    if((osvi.wSuiteMask & VER_SUITE_BACKOFFICE) == VER_SUITE_BACKOFFICE) // the system installed backoffice components
    {
        StringCopyW( szOSComp ,BACKOFFICE ,MAX_OS_FEATURE_LENGTH );
        StringConcat(szOSComp, SPACE, MAX_OS_FEATURE_LENGTH);
    }

    if((osvi.wSuiteMask & VER_SUITE_SMALLBUSINESS) == VER_SUITE_SMALLBUSINESS) // The system installed SmallBusiness components
    {
        if(StringLengthW(szOSComp, 0) != 0)
        {
            StringConcat(szOSComp, SMALLBUSINESS, MAX_OS_FEATURE_LENGTH);

        }
        else
        {
            StringCopyW( szOSComp ,SMALLBUSINESS ,MAX_OS_FEATURE_LENGTH );
        }

        StringConcat(szOSComp, SPACE, MAX_OS_FEATURE_LENGTH);
    }

    if((osvi.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED) == VER_SUITE_SMALLBUSINESS_RESTRICTED) // The system installed Restricted Small Business  components
    {

        if(StringLengthW(szOSComp, 0) != 0)
        {

            StringConcat(szOSComp, RESTRICTED_SMALLBUSINESS, MAX_OS_FEATURE_LENGTH);

        }
        else
        {
            StringCopyW( szOSComp ,RESTRICTED_SMALLBUSINESS ,MAX_OS_FEATURE_LENGTH );
        }

        StringConcat(szOSComp, SPACE, MAX_OS_FEATURE_LENGTH);
    }

    if(EXIT_TRUE == IsTerminalServer(NULL, &bTermServicesInstalled))
        {
            if(TRUE == bTermServicesInstalled)
            {
                StringCopyW( szOSComp, TERMINAL_SERVER, MAX_OS_FEATURE_LENGTH );
            }
            else
            {
                StringCopyW( szOSComp, NOTAVAILABLE, MAX_OS_FEATURE_LENGTH );
            }
        }
        else
        {

            return EXIT_FALSE;
        }

    if(0 == StringLengthW(szOSComp, 0))              //The system did not install any components
    {
        StringCopyW( szOSComp, NOTAVAILABLE, MAX_OS_FEATURE_LENGTH );

    }

    if ( 5 == osvi.dwMajorVersion  && ((1 == osvi.dwMinorVersion) || (2 == osvi.dwMinorVersion)) )
    {
        if(1 == osvi.dwMinorVersion)
        {
            if( (osvi.wProductType == VER_NT_WORKSTATION) || (osvi.wSuiteMask & VER_SUITE_PERSONAL))
            {
                return (DisplayOutputEx(&osvi,szComputerName,szOSName,szOSVersion,szOSRole,szOSComp,szCurrBuildNumber,
                                        osvi.szCSDVersion, WINDOWS_XP, WINDOWS_VERSION_5001));
            }
            else
            {
                return (DisplayOutputEx(&osvi, szComputerName, szOSName, szOSVersion, szOSRole, szOSComp, szCurrBuildNumber,
                                        osvi.szCSDVersion, WINDOWS_DOTNET, WINDOWS_VERSION_5001));
            }
        }
        else
        {
            if( (osvi.wProductType == VER_NT_WORKSTATION) || (osvi.wSuiteMask & VER_SUITE_PERSONAL))
            {
                return (DisplayOutputEx(&osvi,szComputerName,szOSName,szOSVersion,szOSRole,szOSComp,szCurrBuildNumber,
                                        osvi.szCSDVersion, WINDOWS_XP, WINDOWS_VERSION_5002));
            }
            else
            {
                return (DisplayOutputEx(&osvi, szComputerName, szOSName, szOSVersion, szOSRole, szOSComp, szCurrBuildNumber,
                                        osvi.szCSDVersion, WINDOWS_DOTNET, WINDOWS_VERSION_5002));
            }

        }

    }
    else
    {
        if ( 5 == osvi.dwMajorVersion  && 0 == osvi.dwMinorVersion )
        {
            return (DisplayOutputEx(&osvi,szComputerName,szOSName,szOSVersion,szOSRole,szOSComp,szCurrBuildNumber,
                                    osvi.szCSDVersion,WINDOWS_2000,WINDOWS_VERSION_5000));
        }
        else
        {

            ShowMessage(stderr, GetResString(IDS_UNKNOWN_VERSION));
            return EXIT_FALSE;
        }

    }

}

DWORD
ProcessTypeRemote( IN LPWSTR pszRmtServer,
            IN BOOL  bOSRole,
            IN BOOL  bServicePk,
            IN BOOL  bVersion,
            IN BOOL  bMinorVer,
            IN BOOL  bMajorVer,
            IN BOOL  bOSType,
            IN BOOL  bBuildNumber)
/*++

Routine Description:

    This function gets the type of the Operating System by connecting to the registries


Arguments:

    [in]    pszRmtServer    - Remote Server Name
    [in]    bOSRole         - Operating system Role
    [in]    bServicePk      - Service pack installed
    [in]    bVersion        - Version of the Operating System
    [in]    bMinorVer       - Minor Version of the Operating System
    [in]    bMajorVer       - Major Version of the Operating System
    [in]    bOSType         - Type of the Operating System
    [in]    bBuildNumber    - Build Number of the Operating System


Returned Value:

    -- 0 if it succeeds
    -- 255 if it fails.
--*/
{

    BOOL bStatus2 = EXIT_FALSE;
    BOOL bBladeStatus = FALSE;
    BOOL bWorkstation = FALSE;
    BOOL bServer = FALSE;
    BOOL bAdvancedServer = FALSE;
    BOOL bDatacenterServer = FALSE;
    BOOL bPersonal = FALSE;
    BOOL bBladeServer = FALSE;
    BOOL bForSBSServer = FALSE;
	BOOL bTermServicesInstalled = FALSE;
    BOOL bValidIPAddress = FALSE;

    WCHAR  szOSName[MAX_OS_FEATURE_LENGTH] ;
    WCHAR  szOSRole[MAX_OS_FEATURE_LENGTH] ;
    WCHAR szOSComp[MAX_OS_FEATURE_LENGTH] ;
    WCHAR szHostAddr[2*MAX_STRING_LENGTH] ;
    //WCHAR szCurrVersion[MAX_OS_FEATURE_LENGTH] ;
    //WCHAR szCurrBuildNumber[MAX_OS_FEATURE_LENGTH] ;
    //WCHAR szCurrServicePack[MAX_OS_FEATURE_LENGTH] ;
    WCHAR szValue[128] ;
    WCHAR prodsuite[512] ;

    WCHAR* szCurrVersion = NULL;

    HANDLE  hMachine = NULL;
    HANDLE  hPID = NULL;

    DWORD   keyAccess = KEY_READ;
    DWORD   dwType = REG_SZ;
    DWORD retValue = 0;
    DWORD psType = 0;
    DWORD dwSize = MAX_OS_FEATURE_LENGTH;
    DWORD dwSize1 = MAX_OS_FEATURE_LENGTH;
    DWORD dwSize2 = 0;

    HKEY hKey = NULL;

    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBuff= NULL;

    LPWSTR lpProductsuite = NULL;
    LPWSTR  szTempoServer = NULL ;

    DOUBLE lVersion = 0;

    LONG lCurrBuildNumber = 0;
    LONG lngVersion = 0;
    LONG bStatus = EXIT_FALSE;

    WCHAR*  pszStopVersion = NULL;
    WCHAR*  szCurrBuildNumber =  NULL;
    WCHAR* szCurrServicePack = NULL;
    long lChkVersion = 0;


    SecureZeroMemory(szOSName, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szOSRole, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szOSComp, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    //SecureZeroMemory(szCurrBuildNumber, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    //SecureZeroMemory(szCurrServicePack, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    //SecureZeroMemory(szCurrVersion, MAX_OS_FEATURE_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szHostAddr, (2*MAX_STRING_LENGTH) * sizeof(WCHAR));
    SecureZeroMemory(szValue, (128) * sizeof(WCHAR));
    SecureZeroMemory(prodsuite, (512) * sizeof(WCHAR));


    szTempoServer = AllocateMemory((StringLengthW(pszRmtServer, 0) + 10) * sizeof(WCHAR));
    if(NULL == szTempoServer )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return EXIT_FALSE;

    }

    if (FALSE == IsUNCFormat( pszRmtServer )  )
    {

        StringCopyW( szTempoServer, L"\\\\", GetBufferSize(szTempoServer) / sizeof(WCHAR));
        StringConcat(szTempoServer, pszRmtServer, GetBufferSize(szTempoServer) / sizeof(WCHAR));

    }
    else
    {
        StringCopyW( szTempoServer, pszRmtServer, GetBufferSize(szTempoServer) / sizeof(WCHAR) );
    }

    bStatus = RegConnectRegistry( szTempoServer, HKEY_LOCAL_MACHINE, (struct HKEY__ **)&hMachine );

    if( bStatus != ERROR_SUCCESS )
    {
        ShowResMessage( stderr, IDS_ERROR_REGISTRY );
        FREE_MEMORY(szTempoServer);
        return EXIT_FALSE;
    }

    bStatus = RegOpenKeyEx((struct HKEY__ *)hMachine,
                        HKEY_SYSTEM_PRODUCTOPTIONS,
                        0,
                        keyAccess,
                        (struct HKEY__ ** )&hPID );

    if(ERROR_SUCCESS == bStatus)
    {
        bStatus = RegQueryValueEx((struct HKEY__ *)hPID,
                          PRODUCT_TYPE,
                              0,
                              &dwType,
                              (LPBYTE) szValue,
                              &dwSize);
        if(ERROR_SUCCESS != bStatus)
        {

            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
			// release handles
			if ( NULL != hPID )
			{
				RegCloseKey(hPID);
				hPID = NULL;
			}

			if ( NULL != hMachine )
			{
				RegCloseKey(hMachine);
				hMachine = NULL;
			}

            FREE_MEMORY(szTempoServer);
            return EXIT_FALSE;
        }

        bStatus = RegQueryValueEx((struct HKEY__ *)hPID,
                          PRODUCT_SUITE,
                              NULL,
                              &psType,
//                              NULL,
                              (LPBYTE) prodsuite,
                              &dwSize1);

        if(ERROR_SUCCESS != bStatus)
        {

            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            RegCloseKey(hPID);
            RegCloseKey(hMachine);
            FREE_MEMORY(szTempoServer);
            return EXIT_FALSE;
        }

        RegCloseKey(hPID);
    }
    else
    {
        RegCloseKey( hMachine );
        //DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_REGISTRY) );
        ShowMessage( stderr, GetResString(IDS_ERROR_REGISTRY) );
        FREE_MEMORY(szTempoServer);
        return EXIT_FALSE;
    }

    dwSize = 0;
        dwSize1 = 0;
        if(ERROR_SUCCESS == RegOpenKeyEx((struct HKEY__ *)hMachine,HKEY_SOFTWARE_CURRENTVERSION,0, KEY_READ, &hKey))
         {


            bStatus = RegQueryValueEx(hKey, CURRENT_SERVICE_PACK, 0, &dwType,
                        NULL, &dwSize);
            if(0 != dwSize)
            {

                szCurrServicePack = AllocateMemory(dwSize);
                if(NULL == szCurrServicePack)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    RegCloseKey(hKey);
                    RegCloseKey(hMachine);
                    FREE_MEMORY(szTempoServer);
                    return EXIT_FALSE;

                }

                SecureZeroMemory(szCurrServicePack, GetBufferSize(szCurrServicePack));

                bStatus = RegQueryValueEx(hKey, CURRENT_SERVICE_PACK, 0, &dwType,
                            (LPBYTE) szCurrServicePack, &dwSize);
            }

            bStatus = RegQueryValueEx(hKey, CURRENT_BUILD_NUMBER, 0, &dwType,
                        NULL, &dwSize1);
            if(0 != dwSize1)
            {
                szCurrBuildNumber = AllocateMemory(dwSize1);
                if(NULL == szCurrBuildNumber)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    RegCloseKey(hKey);
                    RegCloseKey(hMachine);
                    FREE_MEMORY(szTempoServer);
                    FREE_MEMORY(szCurrServicePack);
                    return EXIT_FALSE;

                }

                SecureZeroMemory(szCurrBuildNumber, GetBufferSize(szCurrBuildNumber));

                bStatus = RegQueryValueEx(hKey, CURRENT_BUILD_NUMBER, 0, &dwType,
                            (LPBYTE) szCurrBuildNumber, &dwSize1);

                if(ERROR_SUCCESS != bStatus)
                {

                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    RegCloseKey(hKey);
                    RegCloseKey(hMachine);
                    FREE_MEMORY(szTempoServer);
                    FREE_MEMORY(szCurrServicePack);
                    FREE_MEMORY(szCurrBuildNumber);
                    return EXIT_FALSE;
                }
            }
            else
            {
                ShowMessage(stderr, GetResString(IDS_UNKNOWN_VERSION));
                RegCloseKey(hKey);
                RegCloseKey(hMachine);
                FREE_MEMORY(szTempoServer);
                FREE_MEMORY(szCurrServicePack);

                return EXIT_FALSE;

            }


            bStatus = RegQueryValueEx(hKey, CURRENT_VERSION, 0, &dwType,
                         NULL, &dwSize2);
            if(0 != dwSize2)
            {
                szCurrVersion = AllocateMemory(dwSize2);
                if(NULL == szCurrVersion)
                {
                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                    RegCloseKey(hKey);
                    RegCloseKey(hMachine);
                    FREE_MEMORY(szTempoServer);
                    FREE_MEMORY(szCurrServicePack);
                    FREE_MEMORY(szCurrBuildNumber);
                    return EXIT_FALSE;

                }

                SecureZeroMemory(szCurrVersion, GetBufferSize(szCurrVersion));

                bStatus = RegQueryValueEx(hKey, CURRENT_VERSION, 0, &dwType,
                            (LPBYTE) szCurrVersion, &dwSize2);


                if(ERROR_SUCCESS != bStatus)
                {

                    ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
                    RegCloseKey(hKey);
                    RegCloseKey(hMachine);
                    FREE_MEMORY(szTempoServer);
                    FREE_MEMORY(szCurrVersion);
                    FREE_MEMORY(szCurrServicePack);
                    FREE_MEMORY(szCurrBuildNumber);
                    return EXIT_FALSE;
                }
            }
            else
            {
                ShowMessage(stderr, GetResString(IDS_UNKNOWN_VERSION));
                RegCloseKey(hKey);
                RegCloseKey(hMachine);
                FREE_MEMORY(szTempoServer);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                return EXIT_FALSE;

            }

            RegCloseKey(hKey);
            RegCloseKey(hMachine);
         }
         else
         {
            ShowMessage(stderr, GetResString(IDS_UNKNOWN_VERSION));
            RegCloseKey(hKey);
            RegCloseKey(hMachine);
            FREE_MEMORY(szTempoServer);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return EXIT_FALSE;

         }

        lVersion = wcstod(szCurrVersion, &pszStopVersion);

        if((errno == ERANGE) || ((NULL != pszStopVersion) && (StringLengthW(pszStopVersion, 0) != 0)))
        {

            ShowMessage(stderr,GetResString(IDS_INVALID_VERSION_NUMBER));
            FREE_MEMORY(szTempoServer);
            FREE_MEMORY(szCurrVersion);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return EXIT_FALSE;

        }

        lngVersion = wcstol(szCurrVersion,&pszStopVersion,10);

        if(errno == ERANGE)
        {

            DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_VERSION_NUMBER));
            FREE_MEMORY(szTempoServer);
            FREE_MEMORY(szCurrVersion);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return EXIT_FALSE;

        }

        lChkVersion = (long)(lVersion*OS_MULTPLN_FACTOR_1000 - lngVersion*OS_MULTPLN_FACTOR_1000);

		// check whether the major version is less than 5..If so, display an error message as
		// "Pre-Windows 2000 version is detected".
        if( lngVersion < 5 )
        {
            ShowMessage(stderr, GetResString(IDS_PREWINDOWS_2000));
            FREE_MEMORY(szTempoServer);
            FREE_MEMORY(szCurrVersion);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return EXIT_FALSE;
        }
        else
        {
            if(((long)((OS_MULTPLN_FACTOR_1000)*(lVersion)) - ((lVersion - lngVersion)*OS_MULTPLN_FACTOR_1000) > 5000) ||
                (((long)((OS_MULTPLN_FACTOR_1000)*(lVersion)) - ((lVersion - lngVersion)*OS_MULTPLN_FACTOR_1000) == 5000) &&
                (((long)(lVersion*OS_MULTPLN_FACTOR_1000 - lngVersion*OS_MULTPLN_FACTOR_1000) > 200))))
            {
                ShowMessage(stderr, GetResString(IDS_NEXT_VERSION));
                FREE_MEMORY(szTempoServer);
                FREE_MEMORY(szCurrVersion);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                return EXIT_FALSE;
            }
           else if(((long)((OS_MULTPLN_FACTOR_1000)*(lVersion)) - ((lVersion - lngVersion)*OS_MULTPLN_FACTOR_1000) == 5000) &&
               ((( lChkVersion> 100) &&  ( lChkVersion < 200)) || (( lChkVersion> 0) &&  ( lChkVersion < 100)) ))
            {
                ShowMessage(stderr, GetResString(IDS_UNKNOWN_VERSION));
                FREE_MEMORY(szTempoServer);
                FREE_MEMORY(szCurrVersion);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                return EXIT_FALSE;

            }

        }


        if(0 == StringCompare( szValue, SERVER_DOMAIN_CONTROLLER, TRUE, 0 ))

        {
            if(1 == bOSRole)
            {
                FREE_MEMORY(szTempoServer);
                FREE_MEMORY(szCurrVersion);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                return (OS_ROLE_DC);
            }
            else
            {
                if(FALSE == bOSRole)
                {
                    StringCopyW( szOSRole, DOMAIN_CONTROLLER, MAX_OS_FEATURE_LENGTH );
                }
            }
        }
        else
        {
            retValue = DsRoleGetPrimaryDomainInformation(pszRmtServer, DsRolePrimaryDomainInfoBasic,(PBYTE *) &pBuff );

            if (retValue == ERROR_SUCCESS)
            {
                if ((NULL != pBuff) && ( pBuff->MachineRole >= 0) )
                  {
                        switch ( pBuff->MachineRole )
                        {
                            case 0:
                            case 2: if(1 == bOSRole)
                                    {
                                        if(NULL != pBuff)
                                        {
                                            DsRoleFreeMemory( pBuff );
                                        }
                                        FREE_MEMORY(szTempoServer);
                                        FREE_MEMORY(szCurrServicePack);
                                        FREE_MEMORY(szCurrBuildNumber);
                                        FREE_MEMORY(szCurrVersion);
                                        return (OS_ROLE_WORKGROUP);
                                    }
                                    else
                                    {
                                        if(FALSE == bOSRole)
                                        {
                                            StringCopyW( szOSRole, WORKGROUP, MAX_OS_FEATURE_LENGTH );
                                        }
                                    }
                                    break;


                            case 1:
                            case 3:
                            case 4: if(1 == bOSRole)
                                    {
                                        if(NULL != pBuff)
                                        {
                                            DsRoleFreeMemory( pBuff );
                                        }

                                        FREE_MEMORY(szTempoServer);
                                        FREE_MEMORY(szCurrServicePack);
                                        FREE_MEMORY(szCurrBuildNumber);
                                        FREE_MEMORY(szCurrVersion);
                                        return (OS_ROLE_MEMBER_SERVER);
                                    }
                                    else
                                    {
                                        if(FALSE == bOSRole)
                                        {
                                            StringCopyW( szOSRole, MEMBER_SERVER, MAX_OS_FEATURE_LENGTH );
                                        }

                                    }

                        }
                  }
            }
            else
            {
                if(NULL != pBuff)
                {
                    DsRoleFreeMemory( pBuff );
                }

                FREE_MEMORY(szTempoServer);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                FREE_MEMORY(szCurrVersion);
                return EXIT_FALSE;
            }

            if(NULL != pBuff)
            {
                DsRoleFreeMemory( pBuff );
            }

        }


            if(0 == StringCompare( prodsuite, ENTERPRISE, TRUE, 0 ))
            {
                lpProductsuite = prodsuite;

                while(NULL != lpProductsuite && 0 != StringLengthW(lpProductsuite, 0))
                {
                    //if lpProductsuite is "Enterprise Datacenter server" which is REG_MULTISZ value , go to 2nd string ie "Datacenter"
                    lpProductsuite = lpProductsuite + StringLengthW(lpProductsuite, 0) + 1  ;

                    if((NULL != lpProductsuite) && (StringCompare( lpProductsuite, WIN_DATACENTER, TRUE, 0 ) == 0))
                    {
                        //if " GetType /type "  is asked....
                        if(1 == bOSType)
                        {
                            FREE_MEMORY(szTempoServer);
                            FREE_MEMORY(szCurrServicePack);
                            FREE_MEMORY(szCurrBuildNumber);
                            FREE_MEMORY(szCurrVersion);
                            return(OS_FLAVOUR_DATACENTER);
                        }
                        else
                        {
                            if(FALSE == bOSType)
                            {

                                bDatacenterServer = TRUE;
                                break;
                            }
                        }
                    }
                    else if((NULL != lpProductsuite) && (StringCompare( lpProductsuite, WINDOWS_SERVER, TRUE, 0 ) == 0))
                    {
                        if(1 == bOSType)
                        {
                            FREE_MEMORY(szTempoServer);
                            FREE_MEMORY(szCurrServicePack);
                            FREE_MEMORY(szCurrBuildNumber);
                            FREE_MEMORY(szCurrVersion);
                            return(OS_FLAVOUR_ADVANCEDSERVER);
                        }
                        else
                        {
                            if(FALSE == bOSType)
                            {

                                bAdvancedServer = TRUE;
                                break;
                            }
                        }

                    }

                }

            }
            else
                if(0 == StringCompare( szValue, NT_WORKSTATION, TRUE, 0 ))
                {
                    if(0 == StringCompare( prodsuite, WIN_PERSONAL, TRUE, 0 ))
                    {
                        if(1 == bOSType)
                        {
                            FREE_MEMORY(szTempoServer);
                            FREE_MEMORY(szCurrServicePack);
                            FREE_MEMORY(szCurrBuildNumber);
                            FREE_MEMORY(szCurrVersion);
                            return(OS_FLAVOUR_PERSONAL);
                        }
                        else
                        {
                            if(FALSE == bOSType)
                            {

                                bWorkstation = TRUE;
                                bPersonal = TRUE;
                            }
                        }
                    }
                    else
                    {
                        if(1 == bOSType)
                        {
                            FREE_MEMORY(szTempoServer);
                            FREE_MEMORY(szCurrServicePack);
                            FREE_MEMORY(szCurrBuildNumber);
                            FREE_MEMORY(szCurrVersion);
                            return(OS_FLAVOUR_PROFESSIONAL);
                        }
                        else
                        {
                            if(FALSE == bOSType)
                            {

                                bWorkstation = TRUE;
                            }
                        }
                    }
                }
                else
                {

                    bStatus2 = IsBladeServer(&bBladeStatus,szTempoServer,FALSE);


                    if(EXIT_TRUE == bStatus2)
                    {
                        if(TRUE == bBladeStatus)
                        {
                            if(1 == bOSType)
                            {
                                FREE_MEMORY(szTempoServer);
                                FREE_MEMORY(szCurrServicePack);
                                FREE_MEMORY(szCurrBuildNumber);
                                FREE_MEMORY(szCurrVersion);
                                return (OS_FLAVOUR_WEBSERVER);
                            }
                          else
                            if(FALSE == bOSType)
                            {

                                bBladeServer = TRUE;
                            }
                        }
                        else if(0 == StringCompare( prodsuite, WINDOWS_FORSBS_SERVER, TRUE, 0 ))
                        {
                            if(1 == bOSType)
                            {
                                FREE_MEMORY(szTempoServer);
                                FREE_MEMORY(szCurrServicePack);
                                FREE_MEMORY(szCurrBuildNumber);
                                FREE_MEMORY(szCurrVersion);
                                return(OS_FLAVOUR_FORSBSSERVER);
                            }
                            else
                            {
                                if(FALSE == bOSType)
                                {
                                    bForSBSServer = TRUE;
                                }
                            }
                        }
                        else if(0 == StringCompare( prodsuite, WINDOWS_SERVER, TRUE, 0 ))
                        {
                            if(1 == bOSType)
                            {
                                FREE_MEMORY(szTempoServer);
                                FREE_MEMORY(szCurrServicePack);
                                FREE_MEMORY(szCurrBuildNumber);
                                FREE_MEMORY(szCurrVersion);
                                return(OS_FLAVOUR_SERVER);
                            }
                            else
                            {
                                if(FALSE == bOSType)
                                {
                                    bServer = TRUE;
                                }
                            }
                        }

                    }
                    else
                    {
                        FREE_MEMORY(szTempoServer);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        FREE_MEMORY(szCurrVersion);
                        return EXIT_FALSE;
                    }
                }


        if(EXIT_TRUE == IsTerminalServer(szTempoServer,&bTermServicesInstalled))
        {
            if(TRUE == bTermServicesInstalled)
            {
                StringCopyW( szOSComp, TERMINAL_SERVER, MAX_OS_FEATURE_LENGTH );
            }
            else
            {
                StringCopyW( szOSComp, NOTAVAILABLE, MAX_OS_FEATURE_LENGTH );
            }
        }
        else
        {

            FREE_MEMORY(szTempoServer);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            FREE_MEMORY(szCurrVersion);
            return EXIT_FALSE;
        }

        FREE_MEMORY(szTempoServer);



        lCurrBuildNumber = wcstol(szCurrBuildNumber, &pszStopVersion, 10);

        if((errno == ERANGE) || (NULL != pszStopVersion && StringLengthW(pszStopVersion, 0)) != 0)
        {

            ShowMessage(stderr,GetResString(IDS_INVALID_BUILD_NUMBER));
            FREE_MEMORY(szCurrVersion);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return EXIT_FALSE;

        }

        if(1 == bVersion)     //returns both major and minor version if /V switch is typed
        {
            FREE_MEMORY(szCurrVersion);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return (long)((OS_MULTPLN_FACTOR_1000)*(lVersion));
        }

        if(1 == bBuildNumber)
        {
            FREE_MEMORY(szCurrVersion);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return (lCurrBuildNumber);
        }


        if(1 == bMajorVer)    //return major version if /MAJV switch is typed
        {
            FREE_MEMORY(szCurrVersion);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return (long)(((OS_MULTPLN_FACTOR_1000)*(lVersion)) - ((lVersion - lngVersion)*OS_MULTPLN_FACTOR_1000));
        }


        if(1 == bMinorVer)   //return minor version if /MINV switch is typed
        {
            FREE_MEMORY(szCurrVersion);
            FREE_MEMORY(szCurrServicePack);
            FREE_MEMORY(szCurrBuildNumber);
            return (long)(((lVersion*OS_MULTPLN_FACTOR_1000 - lngVersion*OS_MULTPLN_FACTOR_1000)));
        }


        if(1 == bServicePk)   //returns the service pack if /SP switch is typed
        {
            if(StringLengthW(szCurrServicePack, 0))
            {
                //FREE_MEMORY(szTempoServer);
                //StringCopy(szCurrServicePack, L"Service Pack 5",MAX_OS_FEATURE_LENGTH );
                //return (szCurrServicePack[lstrlen(szCurrServicePack)-1] - _T('0'));

                dwSize =  (szCurrServicePack[14 - 1] - L'0');
                FREE_MEMORY(szCurrVersion);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                return dwSize;
                //dwTemp = szCurrServicePack[StringLengthW(szCurrServicePack, 0) - 1];
                 //return(dwTemp-= L'0');

            }
            else
            {
                FREE_MEMORY(szCurrVersion);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                return RETVALZERO;
            }
        }

        if(TRUE == IsValidIPAddress(IsUNCFormat(pszRmtServer)?(pszRmtServer + 2) : (pszRmtServer)))
        {
            bValidIPAddress = TRUE;
            dwSize = SIZE_OF_ARRAY(szHostAddr);

            if(FALSE == GetHostByIPAddr(IsUNCFormat(pszRmtServer)?(pszRmtServer + 2) : (pszRmtServer), szHostAddr, (&dwSize), FALSE))
            {

                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
                FREE_MEMORY(szCurrVersion);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                return EXIT_FALSE;

            }

        }

        if((0 == StringCompare( szCurrVersion, WINDOWS_VERSION_5001, TRUE, 0 )) || (0 == StringCompare( szCurrVersion, WINDOWS_VERSION_5002, TRUE, 0 )))
        {
            if( bWorkstation == TRUE)
            {
                if(0 == StringCompare( szCurrVersion, WINDOWS_VERSION_5001, TRUE, 0 ))
                {
                    if(TRUE == bValidIPAddress)
                    {
                        retValue =  (DisplayRemoteOutputEx(szHostAddr, szOSName, szOSRole, szOSComp,
                                     szCurrBuildNumber,szCurrServicePack,WINDOWS_XP,WINDOWS_VERSION_5001,bDatacenterServer,
                                     bAdvancedServer,bPersonal,bWorkstation,bBladeServer,bForSBSServer));
                        FREE_MEMORY(szCurrVersion);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        return retValue;


                    }
                    else
                    {
                        retValue =  (DisplayRemoteOutputEx((IsUNCFormat(pszRmtServer)?(pszRmtServer + 2) : (pszRmtServer)),
                                      szOSName, szOSRole, szOSComp,szCurrBuildNumber,szCurrServicePack,
                                      WINDOWS_XP,WINDOWS_VERSION_5001,bDatacenterServer,bAdvancedServer,bPersonal,
                                      bWorkstation,bBladeServer,bForSBSServer));
                        FREE_MEMORY(szCurrVersion);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        return retValue;
                    }
                }
                else
                {
                    if(TRUE == bValidIPAddress)
                    {
                        retValue =  (DisplayRemoteOutputEx(szHostAddr, szOSName,szOSRole,szOSComp,
                                     szCurrBuildNumber,szCurrServicePack,WINDOWS_XP,WINDOWS_VERSION_5002,bDatacenterServer,
                                     bAdvancedServer,bPersonal,bWorkstation,bBladeServer,bForSBSServer));
                        FREE_MEMORY(szCurrVersion);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        return retValue;

                    }
                    else
                    {
                        retValue =  (DisplayRemoteOutputEx((IsUNCFormat(pszRmtServer)?(pszRmtServer + 2) : (pszRmtServer)),
                                     szOSName, szOSRole,szOSComp,szCurrBuildNumber,szCurrServicePack,
                                     WINDOWS_XP,WINDOWS_VERSION_5002,bDatacenterServer,bAdvancedServer,bPersonal,
                                     bWorkstation,bBladeServer,bForSBSServer));
                        FREE_MEMORY(szCurrVersion);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        return retValue;
                    }

                }

            }
            else
            {
                if(0 == StringCompare( szCurrVersion, WINDOWS_VERSION_5001, TRUE, 0 ))
                {
                    if(TRUE == bValidIPAddress)
                    {
                        retValue =  (DisplayRemoteOutputEx(szHostAddr,szOSName, szOSRole,szOSComp,szCurrBuildNumber,
                                     szCurrServicePack,WINDOWS_DOTNET,WINDOWS_VERSION_5001, bDatacenterServer, bAdvancedServer,
                                     bPersonal, bWorkstation, bBladeServer,bForSBSServer));
                        FREE_MEMORY(szCurrVersion);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        return retValue;
                    }
                    else
                    {
                        retValue =  (DisplayRemoteOutputEx((IsUNCFormat(pszRmtServer)?(pszRmtServer + 2) : (pszRmtServer)),
                                     szOSName, szOSRole,szOSComp,szCurrBuildNumber,szCurrServicePack,WINDOWS_DOTNET,
                                     WINDOWS_VERSION_5001, bDatacenterServer, bAdvancedServer, bPersonal, bWorkstation, bBladeServer,bForSBSServer));
                        FREE_MEMORY(szCurrVersion);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        return retValue;
                    }
                }
                else
                {
                    if(TRUE == bValidIPAddress)
                    {
                        retValue =  (DisplayRemoteOutputEx(szHostAddr,szOSName, szOSRole,szOSComp,szCurrBuildNumber,
                                     szCurrServicePack,WINDOWS_DOTNET,WINDOWS_VERSION_5002, bDatacenterServer, bAdvancedServer,
                                     bPersonal, bWorkstation, bBladeServer,bForSBSServer));
                        FREE_MEMORY(szCurrVersion);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        return retValue;
                    }
                    else
                    {
                        retValue =  (DisplayRemoteOutputEx((IsUNCFormat(pszRmtServer)?(pszRmtServer + 2) : (pszRmtServer)),
                                     szOSName, szOSRole,szOSComp,szCurrBuildNumber,szCurrServicePack,WINDOWS_DOTNET,
                                     WINDOWS_VERSION_5002, bDatacenterServer, bAdvancedServer, bPersonal, bWorkstation, bBladeServer,bForSBSServer));
                        FREE_MEMORY(szCurrVersion);
                        FREE_MEMORY(szCurrServicePack);
                        FREE_MEMORY(szCurrBuildNumber);
                        return retValue;
                    }

                }
            }
        }
        else
            if(0 == StringCompare( szCurrVersion, WINDOWS_VERSION_5000, TRUE, 0 ))
            {
                if(TRUE == bValidIPAddress)
                {
                     retValue =  (DisplayRemoteOutputEx(szHostAddr,szOSName, szOSRole, szOSComp,
                                  szCurrBuildNumber, szCurrServicePack, WINDOWS_2000,WINDOWS_VERSION_5000, bDatacenterServer,
                                  bAdvancedServer, bPersonal, bWorkstation, bBladeServer,bForSBSServer));
                     FREE_MEMORY(szCurrVersion);
                     FREE_MEMORY(szCurrServicePack);
                     FREE_MEMORY(szCurrBuildNumber);
                     return retValue;

                }
                else
                {
                    retValue =  (DisplayRemoteOutputEx((IsUNCFormat(pszRmtServer)?(pszRmtServer + 2) : (pszRmtServer)),
                                 szOSName, szOSRole, szOSComp, szCurrBuildNumber, szCurrServicePack, WINDOWS_2000,
                                 WINDOWS_VERSION_5000, bDatacenterServer, bAdvancedServer, bPersonal, bWorkstation,
                                 bBladeServer,bForSBSServer));
                    FREE_MEMORY(szCurrVersion);
                    FREE_MEMORY(szCurrServicePack);
                    FREE_MEMORY(szCurrBuildNumber);
                    return retValue;
                }

            }
            else
            {

                ShowMessage(stderr, GetResString(IDS_NEXT_VERSION));
                FREE_MEMORY(szCurrVersion);
                FREE_MEMORY(szCurrServicePack);
                FREE_MEMORY(szCurrBuildNumber);
                return EXIT_FALSE;

            }

}


BOOL
DisplayOutput(IN LPWSTR pszServerName,
              IN LPWSTR pszOSName,
              IN LPWSTR pszOSVersion,
              IN LPWSTR pszOSRole,
              IN LPWSTR pszOSComp)

/*++

Routine Description:

    Displays the results onto the screen

Arguments:

    [in]     pszServerName       --Server Name
    [in]     pszOSName           --Operating System Name
    [in]     pszOSVersion        --Operating System Version
    [in]     pszOSRole           --Operating System Role
    [in]     pszOSComp           --Operating System components that are installed

Returned Value:

    TRUE if the function succeeds
    FALSE if the function fails
--*/
{
    //Start displaying the output results
    LPWSTR  szBuffer = NULL;
    HRESULT hr;

    szBuffer = AllocateMemory((StringLengthW(pszServerName, 0) + StringLengthW(pszOSVersion, 0) + MAX_OS_FEATURE_LENGTH) * sizeof(WCHAR));
    if(NULL == szBuffer)
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return FALSE ;
    }

    hr = StringCchPrintf(szBuffer, GetBufferSize(szBuffer) / sizeof(WCHAR), GetResString(IDS_COL_HOSTNAME), _X( pszServerName ));

    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        FREE_MEMORY(szBuffer);
        return FALSE ;
    }

    ShowMessage(stdout, szBuffer);

    hr = StringCchPrintf(szBuffer, GetBufferSize(szBuffer) / sizeof(WCHAR), GetResString(IDS_COL_OSNAME), _X( pszOSName ));

    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        FREE_MEMORY(szBuffer);
        return FALSE ;
    }

    ShowMessage(stdout, szBuffer);

    hr = StringCchPrintf(szBuffer, GetBufferSize(szBuffer) / sizeof(WCHAR), GetResString(IDS_COL_OSVERSION), _X( pszOSVersion ));

    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        FREE_MEMORY(szBuffer);
        return FALSE ;
    }

    ShowMessage(stdout, szBuffer);

    hr = StringCchPrintf(szBuffer, GetBufferSize(szBuffer) / sizeof(WCHAR), GetResString(IDS_COL_OSROLE), _X( pszOSRole ));

    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        FREE_MEMORY(szBuffer);
        return FALSE ;
    }

    ShowMessage(stdout, szBuffer);
    hr = StringCchPrintf(szBuffer, GetBufferSize(szBuffer) / sizeof(WCHAR), GetResString(IDS_COL_OSCOMPONENT), _X( pszOSComp ));

    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        FREE_MEMORY(szBuffer);
        return FALSE ;
    }

    ShowMessage(stdout, szBuffer);
    FREE_MEMORY(szBuffer);
    return TRUE;
}


DWORD
GetTypeUsage()
/*++

Routine Description:

    Displays the help usage

Arguments:

    None

Returned Value:

    EXIT_TRUE for success
--*/
{
    // local variables
    DWORD dw = 0;

    // start displaying the usage
    for( dw = IDS_HELP_START; dw <= IDS_HELP_END; dw++ )
    {
        //DISPLAY_MESSAGE( stdout, GetResString( dw ) );
        ShowMessage( stdout, GetResString( dw ) );
    }
    return EXIT_TRUE;
}

DWORD
DisplayOutputEx(IN OSVERSIONINFOEX *osvi,
                IN LPWSTR pszServerName,
                OUT LPWSTR pszOSName,
                OUT LPWSTR pszOSVersion,
                IN LPWSTR pszOSRole,
                IN LPWSTR pszOSComp,
                IN LPWSTR pszCurrBuildNumber,
                IN LPWSTR pszCurrServicePack,
                IN LPCWSTR pszOperatingSystem,
                IN LPWSTR pszOperatingSystemVersion)

/*++

Routine Description:

    Displays the results of the type of the Operating System

Arguments:
[in]   *osvi                            OSVersion Information
[in]   pszServerName                    Server Name
[out]  pszOSName                        Operating System Name
[out]  pszOSVersion                     Operating System Version
[in]   pszOSRole                        Operating System Role
[in]   pszOSComp                        Operating system Component
[in]   pszCurrBuildNumber               Current Build Number
[in]   pszCurrServicePack               Current Service Pack
[in]   pszOperatingSystem               Operating System Name
[in]   pszOperatingSystemVersion        Operating System Version

Returned Value:

DWORD
--*/
{
    BOOL bBladeStatus = FALSE;
    BOOL bStatus = FALSE;

    StringCopyW( pszOSName, pszOperatingSystem, MAX_OS_FEATURE_LENGTH );

    if( (osvi->wProductType == VER_NT_WORKSTATION) && !(osvi->wSuiteMask & VER_SUITE_PERSONAL))
    {
        if (StringCompare(pszOperatingSystemVersion, WINDOWS_VERSION_4000, TRUE, 0 ) == 0)
        {
            StringConcat(pszOSName, WORKSTATION, MAX_OS_FEATURE_LENGTH);
        }
        else
        {
            StringConcat(pszOSName, PROFESSIONAL, MAX_OS_FEATURE_LENGTH);
        }
    }
    else
    {
        if(osvi->wSuiteMask & VER_SUITE_DATACENTER) //The OS is Windows DataCenter
        {
            StringConcat(pszOSName, DATACENTER, MAX_OS_FEATURE_LENGTH);
        }
        else
        {
            if(osvi->wSuiteMask & VER_SUITE_ENTERPRISE) //The OS is Windows Advanced Server
            {
                if ((StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_5001, TRUE, 0 ) == 0) ||
                    (StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_5002, TRUE, 0 ) == 0))
                {
                    StringConcat(pszOSName, ENTERPRISE_SERVER, MAX_OS_FEATURE_LENGTH);
                }
                else
                {
                    StringConcat(pszOSName, ADVANCED_SERVER, MAX_OS_FEATURE_LENGTH);
                }
            }
            else
            {
                if(osvi->wSuiteMask & VER_SUITE_PERSONAL)
                {
                    StringConcat(pszOSName, PERSONAL, MAX_OS_FEATURE_LENGTH);
                }
                else
                {
                    if ((StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_5001, TRUE, 0 ) == 0) ||
                        (StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_5002, TRUE, 0 ) == 0))
                    {
                        bStatus = IsBladeServer(&bBladeStatus, NULL, FALSE);
                        if(EXIT_TRUE == bStatus)
                        {
                            if(TRUE == bBladeStatus)
                            {
                                StringConcat(pszOSName, WEB_SERVER, MAX_OS_FEATURE_LENGTH);
                            }
                            else if(osvi->wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
                            {
                                StringConcat(pszOSName, SERVER_FOR_SBS, MAX_OS_FEATURE_LENGTH);
                            }
                            else
                            {
                                StringConcat(pszOSName, STANDARD_SERVER, MAX_OS_FEATURE_LENGTH);
                            }

                        }
                        else
                        {
                            return EXIT_FALSE;
                        }

                    }
                    else
                    {
                        StringConcat(pszOSName, SERVER, MAX_OS_FEATURE_LENGTH);
                    }
                }
            }
        }
    }

    StringCopyW( pszOSVersion, pszOperatingSystemVersion, MAX_OS_FEATURE_LENGTH );
    StringConcat(pszOSVersion, SPACE, MAX_OS_FEATURE_LENGTH);
    StringConcat(pszOSVersion, BUILD, MAX_OS_FEATURE_LENGTH);
    StringConcat(pszOSVersion, SPACE, MAX_OS_FEATURE_LENGTH);
    StringConcat(pszOSVersion, pszCurrBuildNumber, MAX_OS_FEATURE_LENGTH);
    StringConcat(pszOSVersion, SPACE, MAX_OS_FEATURE_LENGTH);
    StringConcat(pszOSVersion, pszCurrServicePack, MAX_OS_FEATURE_LENGTH);

    if(FALSE == DisplayOutput(pszServerName,pszOSName,pszOSVersion,pszOSRole,pszOSComp))
    {
        return EXIT_FALSE;
    }
    else
    {
        return RETVALZERO;
    }
}


DWORD
DisplayRemoteOutputEx(IN LPWSTR pszServerName,
                OUT LPWSTR pszOSName,
                IN LPWSTR pszOSRole,
                IN LPWSTR pszOSComp,
                IN LPWSTR pszCurrBuildNumber,
                IN LPWSTR pszCurrServicePack,
                IN LPCWSTR pszOperatingSystem,
                IN LPWSTR pszOperatingSystemVersion,
                //IN BOOL bServer,
                IN BOOL bDatacenterServer,
                IN BOOL bAdvancedServer,
                IN BOOL bPersonal,
                IN BOOL bWorkstation,
                IN BOOL bBladeServer,
			    IN BOOL bForSBSServer)


/*++

Routine Description:

    Displays the results of the type of the Operating System

Arguments:

[in]   pszServerName                    Server Name
[out]  pszOSName                        Operating System Name
[out]  pszOSVersion                     Operating System Version
[in]   pszOSRole                        Operating System Role
[in]   pszOSComp                        Operating System component
[in]   pszCurrBuildNumber               Current Build Number
[in]   pszCurrServicePack               Current Service Pack
[in]   pszOperatingSystem               Operating System Name
[in]   pszOperatingSystemVersion        Operating System Version
[in]   bServer                          Whether OS is Server type
[in]   bDatacenterServer                Whether OS is DatacenterServer type
[in]   bAdvancedServer                  Whether OS is AdvancedServer type
[in]   bPersonal                        Whether OS is Personal type
[in]   bWorkstation                     Whether OS is Workstation type
[in]   bBladeServer                     Whether OS is BladeServer type
[in]   bForSBSServer                    Whether OS is for Small Business Server type

Returned Value:

DWORD
--*/
{
    LPWSTR pszOSVersion = NULL;

    pszOSVersion = AllocateMemory(GetBufferSize(pszCurrBuildNumber) + GetBufferSize(pszCurrServicePack) + (MAX_OS_FEATURE_LENGTH * sizeof(WCHAR)));

    if(NULL == pszOSVersion)
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return EXIT_FALSE;

    }

    StringCopyW( pszOSName, pszOperatingSystem, MAX_OS_FEATURE_LENGTH );

    if( (TRUE == bWorkstation) && FALSE == bPersonal)
    {
        if (StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_4000, TRUE, 0 ) == 0)
        {
            StringConcat(pszOSName, WORKSTATION, MAX_OS_FEATURE_LENGTH);
        }
        else
        {
            StringConcat(pszOSName, PROFESSIONAL, MAX_OS_FEATURE_LENGTH);
        }
    }
    else
    {
        if(TRUE == bDatacenterServer) //The OS is Windows DataCenter
        {
            StringConcat(pszOSName, DATACENTER, MAX_OS_FEATURE_LENGTH);
        }
        else
        {
            if(TRUE == bAdvancedServer) //The OS is Windows Advanced Server
            {
                if ((StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_5001, TRUE, 0 ) == 0) ||
                    (StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_5002, TRUE, 0 ) == 0))
                {
                    StringConcat(pszOSName, ENTERPRISE_SERVER, MAX_OS_FEATURE_LENGTH);
                }
                else
                {
                    StringConcat(pszOSName, ADVANCED_SERVER, MAX_OS_FEATURE_LENGTH);
                }
            }
            else
            {
                if(TRUE == bPersonal)
                {
                    StringConcat(pszOSName, PERSONAL, MAX_OS_FEATURE_LENGTH);
                }
                else
                {
                    if ((StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_5001, TRUE, 0 ) == 0) ||
                        (StringCompare(pszOperatingSystemVersion,WINDOWS_VERSION_5002, TRUE, 0 ) == 0))
                    {
                        if(TRUE == bBladeServer)
                        {
                            StringConcat(pszOSName, WEB_SERVER, MAX_OS_FEATURE_LENGTH);
                        }
						else if(TRUE == bForSBSServer)
						{
							StringConcat(pszOSName, SERVER_FOR_SBS, MAX_OS_FEATURE_LENGTH);
						}
                        else
                        {
                            StringConcat(pszOSName, STANDARD_SERVER, MAX_OS_FEATURE_LENGTH);
                        }

                    }
                    else
                    {
                        StringConcat(pszOSName, SERVER, MAX_OS_FEATURE_LENGTH);
                    }
                }
            }
        }
    }

    StringCopyW( pszOSVersion, pszOperatingSystemVersion, GetBufferSize(pszOSVersion) );
    StringConcat(pszOSVersion, SPACE, GetBufferSize(pszOSVersion));
    StringConcat(pszOSVersion, BUILD, GetBufferSize(pszOSVersion));
    StringConcat(pszOSVersion, SPACE, GetBufferSize(pszOSVersion));
    StringConcat(pszOSVersion, pszCurrBuildNumber, GetBufferSize(pszOSVersion));
    StringConcat(pszOSVersion, SPACE, GetBufferSize(pszOSVersion));
    StringConcat(pszOSVersion, pszCurrServicePack, GetBufferSize(pszOSVersion));

    if(FALSE == DisplayOutput(pszServerName,pszOSName,pszOSVersion,pszOSRole,pszOSComp))
    {
     return EXIT_FALSE;
    }
    else
    {
         return RETVALZERO;
    }
}



BOOL
IsBladeServer(PBOOL pbBladeStatus,
              LPWSTR lpszServer,
              BOOL bLocal)
/*++

Routine Description:

    This function checks whether the server is web server or not


Arguments:

    [in/out]  pbBladeStatus   Blade Server Status
    [in]      lpszServer      Server to connect and get the status
    [in]      bLocal          whether local system or not

Returned Value:

    --EXIT_TRUE if it succeeds
    --EXIT_FALSE if it fails.
--*/
{
    HKEY    hMachine = NULL;
    DWORD   keyAccess = KEY_READ;
    DWORD   sts = 0;
    HKEY    hPID = NULL;
    WCHAR prodsuite[2 * MAX_STRING_LENGTH] ;
    DWORD psType = 0;
    DWORD dwSize1 = 512;
    LPWSTR lpProductsuite = NULL;


    SecureZeroMemory(prodsuite, (2 * MAX_STRING_LENGTH) * sizeof(WCHAR));

    if(TRUE == bLocal)
    {
        sts = RegConnectRegistry( NULL, HKEY_LOCAL_MACHINE, &hMachine );

    }
    else
    {
        sts = RegConnectRegistry( lpszServer, HKEY_LOCAL_MACHINE, &hMachine );

    }

    if( sts != ERROR_SUCCESS )
    {
        ShowMessage( stderr, GetResString(IDS_ERROR_REGISTRY) );
        return EXIT_FALSE;
    }

    sts = RegOpenKeyEx(hMachine,
                        HKEY_SYSTEM_PRODUCTOPTIONS,
                        0,
                        keyAccess,
                        &hPID );

    if(ERROR_SUCCESS == sts)
    {

        sts = RegQueryValueEx(hPID,
                              PRODUCT_SUITE,
                              NULL,
                              &psType,
//                              NULL,
                              (LPBYTE) prodsuite,
                              &dwSize1);
        if(ERROR_SUCCESS == sts)
        {

            if(StringCompare( prodsuite, BLADE, TRUE, 0 ) == 0)

            {
                *pbBladeStatus = TRUE;


            }
            else
            {
                lpProductsuite = prodsuite;
                while(NULL != lpProductsuite && 0 != StringLengthW(lpProductsuite, 0))
                {

                    lpProductsuite = lpProductsuite + StringLengthW(lpProductsuite, 0) + 1  ;

                    if((NULL != lpProductsuite) && (StringCompare( lpProductsuite, BLADE, TRUE, 0 ) == 0))
                    {
                        *pbBladeStatus = TRUE;
                        break;
                    }
                }
            }

            RegCloseKey( hMachine );
            RegCloseKey( hPID );
            return EXIT_TRUE;

        }
        else
        {
            RegCloseKey( hMachine );
            RegCloseKey( hPID );
            ShowMessage( stderr, GetResString(IDS_ERROR_REGISTRY) );
            return EXIT_FALSE;

        }

    }
    else
    {
        RegCloseKey( hMachine );
        ShowMessage( stderr, GetResString(IDS_ERROR_REGISTRY) );
        return EXIT_FALSE;
    }
}


BOOL
IsTerminalServer(LPWSTR szServer,
                 PBOOL pbTermServicesInstalled)
/*++

Routine Description:

    This function checks whether the server is web server or not


Arguments:


    [in]      szServer                         Server to connect and get the status
    [out]     pbTermServicesInstalled          Whether terminal services are installed or not

Returned Value:

    --EXIT_TRUE if it succeeds
    --EXIT_FALSE if it fails.
--*/
{
    DWORD dwLevel = 101;
    LPSERVER_INFO_101 pBuffer = NULL;
    NET_API_STATUS nStatus = FALSE;

    nStatus = NetServerGetInfo(szServer,dwLevel,(LPBYTE*)&pBuffer);

    if(nStatus == NERR_Success)
    {
        if( (pBuffer->sv101_type & SV_TYPE_TERMINALSERVER) ==  SV_TYPE_TERMINALSERVER)
        {
            *pbTermServicesInstalled = TRUE;
        }
        else
        {
            *pbTermServicesInstalled = FALSE;
        }
        if(pBuffer != NULL)
        {
            NetApiBufferFree(pBuffer);
            pBuffer = NULL;
        }
        return EXIT_TRUE;

    }
    else
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);

        if(pBuffer != NULL)
        {
            NetApiBufferFree(pBuffer);
            pBuffer = NULL;
        }

        return EXIT_FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gettype\gettype.h ===
/*****************************************************************************

Copyright (c)  Microsoft Corporation

Module Name: GetType.h

Abstract:
This module  contanins function definations required by gettype.c,
and all necessary Defines used in this project.

Author:Wipro Technologies

Revision History:

*******************************************************************************/

#ifndef _GETTYPE_H
#define _GETTYPE_H
#include "pch.h"
#include "resource.h"


#define MAX_OPTIONS              11

#define SPACE                       L" "
#define DOT                         L"."

#define WINDOWS_VERSION_4000       L"4.0"
#define WINDOWS_VERSION_4001       L"4.1"
#define WINDOWS_VERSION_5000       L"5.0"
#define WINDOWS_VERSION_5001       L"5.1"
#define WINDOWS_VERSION_5002       L"5.2"
#define WINDOWS_VERSION_5005       L"5.5"
#define WINDOWS_VERSION_6000       L"6.0"

#define NULL_U_STRING               L"\0"

#define ERROR_USER_WITH_NOSERVER        GetResString( IDS_USER_NMACHINE )
#define ERROR_PASSWORD_WITH_NUSER       GetResString( IDS_PASSWORD_NUSER )
#define ERROR_NULL_SERVER               GetResString( IDS_NULL_SERVER )
#define ERROR_NULL_USER                 GetResString( IDS_NULL_USER )

#define DOMAIN_CONTROLLER                GetResString(IDS_DOMAIN_CONTROLLER)
#define WORKGROUP                        GetResString(IDS_WORKGROUP)
#define MEMBER_SERVER                    GetResString(IDS_MEMBER_SERVER)

#define BUILD                            GetResString(IDS_BUILD)
#define NOTAVAILABLE                     GetResString(IDS_NOTAVAILABLE)

#define WINDOWS_NT                       GetResString(IDS_WINDOWS_NT)
#define WINDOWS_2000                     GetResString(IDS_WINDOWS_2000)
#define WINDOWS_XP                       GetResString(IDS_WINDOWS_XP)
#define WINDOWS_DOTNET                   GetResString(IDS_WINDOWS_DOTNET)
#define WINDOWS_LONGHORN                 GetResString(IDS_WINDOWS_LONGHORN)
#define WINDOWS_BLACKCOMB                GetResString(IDS_WINDOWS_BLACKCOMB)

#define WORKSTATION                      GetResString(IDS_WORKSTATION)
#define PROFESSIONAL                     GetResString(IDS_PROFESSIONAL)
#define SERVER                           GetResString(IDS_SERVER)
#define ADVANCED_SERVER                  GetResString(IDS_ADVANCED_SERVER)
#define DATACENTER                       GetResString(IDS_DATACENTER)
#define PERSONAL                         GetResString(IDS_PERSONAL)
#define ENTERPRISE_SERVER                GetResString(IDS_ENTERPRISE_SERVER)
#define STANDARD_SERVER                  GetResString(IDS_STANDARD_SERVER)
#define WEB_SERVER                       GetResString(IDS_WEB_SERVER)
#define SERVER_FOR_SBS			 		 GetResString(IDS_FORSBS_SERVER)


#define PRODUCT_SUITE                                   L"ProductSuite"
#define HKEY_SYSTEM_PRODUCTOPTIONS                      L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions"
#define PRODUCT_TYPE                                    L"ProductType"
#define HKEY_SOFTWARE_CURRENTVERSION                    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
#define CURRENT_VERSION                                 L"CurrentVersion"
#define CURRENT_BUILD_NUMBER                            L"CurrentBuildNumber"
#define CURRENT_SERVICE_PACK                            L"CSDVersion"

#define WINDOWS_SERVER                   L"Terminal Server"
#define WINDOWS_ADVANCED_SERVER          L"Enterprise Terminal Server"
#define WINDOWS_DATACENTER_SERVER        L"Enterprise DataCenter Terminal Server "
#define WINDOWS_FORSBS_SERVER            L"Small Business(Restricted)"
#define WIN_DATACENTER                       L"DATACENTER"
#define ENTERPRISE                       L"Enterprise"
#define WIN_PERSONAL                         L"personal"

#define SERVER_DOMAIN_CONTROLLER         L"LanmanNT"
#define SERVER_NONDOMAIN_CONTROLLER      L"ServerNT"
#define NT_WORKSTATION                   L"WinNT"

/*#define WINDOWS_VERSION_4000       L"4.0"
#define WINDOWS_VERSION_4001       L"4.1"
#define WINDOWS_VERSION_5000       L"5.0"
#define WINDOWS_VERSION_5001       L"5.1"
#define WINDOWS_VERSION_5005       L"5.5"
#define WINDOWS_VERSION_6000       L"6.0"*/

#define BACKOFFICE                                      GetResString(IDS_BACKOFFICE)
#define SMALLBUSINESS                                   GetResString(IDS_SMALLBUSINESS)
#define RESTRICTED_SMALLBUSINESS                        GetResString(IDS_RESTRICTED_SMALLBUSINESS)
#define TERMINAL_SERVER                                 GetResString(IDS_TERMINAL_SERVER)

#define BLADE               L"Blade"



#define EXIT_FALSE    255
#define EXIT_TRUE      0

#define OI_USAGE                        0
#define OI_OSROLE                       1
#define OI_SERVICEPACK                  2
#define OI_VERSION                      3
#define OI_MINOR_VERSION                4
#define OI_MAJOR_VERSION                5
#define OI_OSTYPE                       6
#define OI_BUILD                        7
#define OI_SERVER                       8
#define OI_USERNAME                         9
#define OI_PASSWORD                     10

#define MAJOR_VER           5
#define MINOR_VER           0
#define SERVICE_PACK_MAJOR  0

#define MIN_MEMORY_REQUIRED         256
#define MAX_OS_FEATURE_LENGTH       512
#define MAX_CURRBUILD_LENGTH        32
#define RETVALZERO                  0

/*#define FREE_MEMORY( VARIABLE ) \
if( VARIABLE != NULL ) \
{\
    free( VARIABLE ) ; \
    VARIABLE = NULL ; \
}\
    1   */

#define FREE_MEMORY( VARIABLE ) \
            FreeMemory(&VARIABLE); \
            1

/*#define ASSIGN_MEMORY( VARIABLE , TYPE , VALUE ) \
        VARIABLE = ( TYPE * ) calloc( VALUE , sizeof( TYPE ) ) ; \
        1  */

/*#define REALLOC_MEMORY( VARIABLE , TYPE , VALUE ) \
        VARIABLE = ( TYPE * ) realloc( VARIABLE , VALUE * sizeof( TYPE ) ) ; \
        1 */


//flags to set

#define OS_TYPE_NONE                            0x00000000          // 0000 0000 0000 0000 0000 0000 0000 0000 ( default )

#define OS_ROLE_DC                              0x00000001
#define OS_ROLE_MEMBER_SERVER                   0x00000002
#define OS_ROLE_WORKGROUP                       0x00000003

#define OS_MULTPLN_FACTOR_1000                      0x000003E8
#define OS_MULTPLN_FACTOR_100                       0x00000064

#define OS_SERVICEPACK_ZERO                     0x00000000

#define OS_MINORVERSION_BLACKCOMB               0x00000000
#define OS_MINORVERSION_LONGHORN                0x00005000
#define OS_MINORVERSION_WINDOWS_XP              0x00001000
#define OS_MINORVERSION_WINDOWS_2000            0x00001000
#define OS_MINORVERSION_WINDOWS_NT              0x00000000

#define OS_MAJORVERSION_BLACKCOMB               0x000C0000
#define OS_MAJORVERSION_LONGHORN                0x000A0000
#define OS_MAJORVERSION_WINDOWS_XP              0x000A0000
#define OS_MAJORVERSION_WINDOWS_2000            0x000A0000
#define OS_MAJORVERSION_WINDOWS_NT              0x00080000
#define OS_MAJORVERSION_WINDOWS_95              0x00080000

#define OS_FLAVOUR_PERSONAL                     0x00000001
#define OS_FLAVOUR_PROFESSIONAL                 0x00000002
#define OS_FLAVOUR_SERVER                       0x00000003
#define OS_FLAVOUR_ADVANCEDSERVER               0x00000004
#define OS_FLAVOUR_DATACENTER                   0x00000005
#define OS_FLAVOUR_WEBSERVER                    0x00000006
#define OS_FLAVOUR_FORSBSSERVER					0x00000007


#define OS_COMP_SMALLBUSINESS                   0x04000000
#define OS_COMP_RESTRICTED_SMALLBUSINESS                0x0C000000
#define OS_COMP_BACKOFFICE                      0x10000000
#define OS_COMP_TERMINALSERVER                  0x20000000
#define OS_NO_COMPONENT                         0x00000000
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gettype\resource.h ===
#define IDS_HELP_MESSAGE                    101

#define  IDS_COL_HOSTNAME                   201
#define  IDS_COL_OSNAME                     202
#define  IDS_COL_OSVERSION                  203
#define  IDS_COL_OSROLE                     204
#define  IDS_COL_OSCOMPONENT                205
#define  IDS_DOMAIN_CONTROLLER              206
#define  IDS_WORKGROUP                      207
#define  IDS_MEMBER_SERVER                  208
#define  IDS_BUILD                          209
#define  IDS_NOTAVAILABLE                   210
#define  IDS_WINDOWS_NT                     211
#define  IDS_WINDOWS_2000                   212
#define  IDS_WINDOWS_XP                     213
#define  IDS_WINDOWS_DOTNET                 214
#define  IDS_WINDOWS_LONGHORN               215
#define  IDS_WINDOWS_BLACKCOMB              216
#define  IDS_WORKSTATION                    217
#define  IDS_PROFESSIONAL                   218
#define  IDS_SERVER                         219
#define  IDS_ADVANCED_SERVER                220
#define  IDS_DATACENTER                     221
#define  IDS_PERSONAL                       222
#define  IDS_BACKOFFICE                     223
#define  IDS_SMALLBUSINESS                  224
#define  IDS_RESTRICTED_SMALLBUSINESS       225
#define  IDS_TERMINAL_SERVER                226
//#define  IDS_INVALID_ARGUMENT               227
#define  IDS_ENTERPRISE_SERVER              228
#define  IDS_STANDARD_SERVER                229
#define  IDS_WEB_SERVER                     230
#define  IDS_ERROR_REGISTRY                 231
#define  IDS_IGNORE_LOCALCREDENTIALS        232
#define IDS_USER_NMACHINE                   233
#define IDS_PASSWORD_NUSER                  234
#define IDS_NULL_SERVER                     235
#define IDS_NULL_USER                       236
#define IDS_INVALID_VERSION_NUMBER          237
#define IDS_INVALID_SERVER_NAME             238
#define IDS_VAL_NOT_CONVERT                 239
#define IDS_INVALID_BUILD_NUMBER            240
#define IDS_PREWINDOWS_2000                 241
#define IDS_NEXT_VERSION                    242
#define IDS_UNKNOWN_VERSION                 243
#define IDS_FORSBS_SERVER                   244


#define IDS_HELP_LINE1      501
#define IDS_HELP_LINE2      502
#define IDS_HELP_LINE3      503
#define IDS_HELP_LINE4      504
#define IDS_HELP_LINE5      505
#define IDS_HELP_LINE6      506
#define IDS_HELP_LINE7      507
#define IDS_HELP_LINE8      508
#define IDS_HELP_LINE9      509
#define IDS_HELP_LINE10     510
#define IDS_HELP_LINE11     511
#define IDS_HELP_LINE12     512
#define IDS_HELP_LINE13     513
#define IDS_HELP_LINE14     514
#define IDS_HELP_LINE15     515
#define IDS_HELP_LINE16     516
#define IDS_HELP_LINE17     517
#define IDS_HELP_LINE18     518
#define IDS_HELP_LINE19     519
#define IDS_HELP_LINE20     520
#define IDS_HELP_LINE21     521
#define IDS_HELP_LINE22     522
#define IDS_HELP_LINE23     523
#define IDS_HELP_LINE24     524
#define IDS_HELP_LINE25     525
#define IDS_HELP_LINE26     526
#define IDS_HELP_LINE27     527
#define IDS_HELP_LINE28     528
#define IDS_HELP_LINE29     529
#define IDS_HELP_LINE30     530
#define IDS_HELP_LINE31     531
#define IDS_HELP_LINE32     532
#define IDS_HELP_LINE33     533
#define IDS_HELP_LINE34     534
#define IDS_HELP_LINE35     535
#define IDS_HELP_LINE36     536
#define IDS_HELP_LINE37     537
#define IDS_HELP_LINE38     538
#define IDS_HELP_LINE39     539
#define IDS_HELP_LINE40     540
#define IDS_HELP_LINE41     541
#define IDS_HELP_LINE42     542
#define IDS_HELP_LINE43     543
#define IDS_HELP_LINE44     544
#define IDS_HELP_LINE45     545
#define IDS_HELP_LINE46     546
#define IDS_HELP_LINE47     547
#define IDS_HELP_LINE48     548
#define IDS_HELP_LINE49     549
#define IDS_HELP_LINE50     550
#define IDS_HELP_LINE51     551
#define IDS_HELP_LINE52     552
#define IDS_HELP_LINE53     553
#define IDS_HELP_LINE54     554
#define IDS_HELP_LINE55     555
#define IDS_HELP_LINE56     556
#define IDS_HELP_LINE57     557
#define IDS_HELP_LINE58     558
#define IDS_HELP_LINE59     559
#define IDS_HELP_LINE60     560
#define IDS_HELP_LINE61     561
#define IDS_HELP_LINE62     562
#define IDS_HELP_LINE63     563
#define IDS_HELP_LINE64     564
#define IDS_HELP_LINE65     565
#define IDS_HELP_LINE66     566
#define IDS_HELP_LINE67     567
#define IDS_HELP_LINE68     568
#define IDS_HELP_LINE69     569
#define IDS_HELP_LINE70     570
#define IDS_HELP_LINE71     571
#define IDS_HELP_LINE72     572
#define IDS_HELP_LINE73     573
#define IDS_HELP_LINE74     574
#define IDS_HELP_LINE75     575
#define IDS_HELP_LINE76     576
#define IDS_HELP_LINE77     577
#define IDS_HELP_LINE78     578
#define IDS_HELP_LINE79     579


#define IDS_HELP_START      IDS_HELP_LINE1
#define IDS_HELP_END        IDS_HELP_LINE79

//#define IDS_ID_SHOW_ERROR       IDS_TAG_ERROR
//#define IDS_ID_SHOW_WARNING     IDS_TAG_WARNING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\gpresult.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    GpResult.cpp

Abstract:

    This file contains the main entry point function for this tool and also the
    function to parse the command line arguments.

Author:

    Wipro Technologies

Revision History:

    20-Feb-2001 : Created It.

*********************************************************************************************/

#include "pch.h"
#include "GpResult.h"
#include "wmi.h"

/*********************************************************************************************
Routine Description:
  This is main entry point for this utility. Different function calls are made from here,
  depending on the command line parameters passed to this utility.

Arguments:
    [in] argc  : Number of Command line arguments.
    [in] argv  : Pointer to Command line arguments.

Return Value:
    Zero on success
    Corresponding error code on failure.
*********************************************************************************************/
DWORD _cdecl _tmain( DWORD argc, LPCWSTR argv[] )
{
    // local variables

    CGpResult       GpResult;

    BOOL            bResult = FALSE;
    BOOL            bNeedUsageMsg = FALSE;

    // initialize the GpResult utility
    if( GpResult.Initialize() == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        EXIT_PROCESS( ERROR_EXIT );
    }

    bResult = GpResult.ProcessOptions( argc, argv, &bNeedUsageMsg );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        if( bNeedUsageMsg == TRUE )
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString( IDS_TYPE_USAGE ), argv[ 0 ] );
        }

        EXIT_PROCESS( ERROR_EXIT );
    }

    // Check if help is specified in the commandline
    if( (argc == 2) && ( ( StringCompare ( argv[1], HELP_OPTION, FALSE, 0 ) == 0)
                           || (StringCompare ( argv[1], HELP_OPTION1, FALSE, 0 ) == 0) ) )
    {
        GpResult.DisplayUsage();
        EXIT_PROCESS( CLEAN_EXIT );
    }

    //   Call GetLoggingData to get the data for the Logging mode
    if( GpResult.GetLoggingData() == FALSE )
    {
        EXIT_PROCESS( ERROR_EXIT );
    }

    EXIT_PROCESS( CLEAN_EXIT );
}

/*********************************************************************************************
Routine Description
    This function displays the help for GpResult utility

Arguments:
    None.

Return Value
    None
*********************************************************************************************/
VOID CGpResult::DisplayUsage( void )
{
    DWORD dwIndex = 0;

    // Displaying main usage
    for( dwIndex = ID_HELP_START; dwIndex <= ID_HELP_END; dwIndex++ )
    {
        ShowMessage( stdout, GetResString( dwIndex ) );
    }
}

/*********************************************************************************************
Routine Description
    This function processes the command line for the main options

Arguments:
    [in] argc  : Number of Command line arguments.
    [in] argv  : Pointer to Command line arguments.

Return Value
    TRUE on success
    FALSE on failure

*********************************************************************************************/
BOOL CGpResult::ProcessOptions( DWORD argc, LPCWSTR argv[], BOOL *pbNeedUsageMsg )
{
    // local variables
    PTCMDPARSER2 pcmdOptions = NULL;
    __STRING_64 szScope = NULL_STRING;

    // temporary local variables
    LPWSTR pwszPassword = NULL;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszServerName = NULL;

    PTCMDPARSER2 pOption = NULL;
    PTCMDPARSER2 pOptionServer = NULL;
    PTCMDPARSER2 pOptionUserName = NULL;
    PTCMDPARSER2 pOptionPassword = NULL;
    PTCMDPARSER2 pOptionUser = NULL;
    PTCMDPARSER2 pOptionVerbose = NULL;
    PTCMDPARSER2 pOptionSuperVerbose = NULL;

    //
    // prepare the command options
    pcmdOptions = new TCMDPARSER2[ MAX_CMDLINE_OPTIONS ];
    if ( pcmdOptions == NULL )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    try
    {
        // get the memory
        pwszServerName = m_strServerName.GetBufferSetLength( MAX_STRING_LENGTH );
        pwszPassword = m_strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
        pwszUser =  m_strUser.GetBufferSetLength( MAX_STRING_LENGTH );

        // init the password value
        StringCopy( pwszPassword, _T( "*" ), MAX_STRING_LENGTH  );
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
		delete [] pcmdOptions;  // clear memory
        pcmdOptions = NULL;
        return FALSE;
    }

    // initialize to ZERO's
    SecureZeroMemory( pcmdOptions, MAX_CMDLINE_OPTIONS * sizeof( TCMDPARSER2 ) );

    // -?
    pOption = pcmdOptions + OI_USAGE;
    pOption->dwCount = 1;
    pOption->dwFlags = CP2_USAGE;
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pValue = &m_bUsage;
    pOption->pwszOptions= OPTION_USAGE;
    StringCopyA( pOption->szSignature, "PARSER2", 8 );

    // -s
    pOption = pcmdOptions + OI_SERVER;
    pOption->dwCount = 1;
    pOption->pValue = pwszServerName;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->dwFlags = CP_VALUE_MANDATORY;
    StringCopyA( pOption->szSignature, "PARSER2", 8 );
    pOption->pwszOptions=OPTION_SERVER;
    pOption->dwLength = MAX_STRING_LENGTH;

    // -u
    pOption = pcmdOptions + OI_USERNAME;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pOption->pValue = NULL;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    pOption->pwszOptions=OPTION_USERNAME;
    StringCopyA( pOption->szSignature, "PARSER2", 8 );

    // -p
    pOption = pcmdOptions + OI_PASSWORD;
    pOption->dwCount = 1;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->dwFlags = CP2_VALUE_OPTIONAL;
    pOption->pValue = pwszPassword;
    pOption->pwszOptions=OPTION_PASSWORD;
    pOption->dwLength = MAX_STRING_LENGTH;
    StringCopyA( pOption->szSignature, "PARSER2", 8 );

    // -v
    pOption = pcmdOptions + OI_VERBOSE;
    pOption->dwCount = 1;
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pValue = &m_bVerbose;
    pOption->pwszOptions=OPTION_VERBOSE;
    StringCopyA( pOption->szSignature, "PARSER2", 8 );

    // -z
    pOption = pcmdOptions + OI_SUPER_VERBOSE;
    pOption->dwCount = 1;
    pOption->dwType = CP_TYPE_BOOLEAN;
    pOption->pValue = &m_bSuperVerbose;
    pOption->pwszOptions=OPTION_SUPER_VERBOSE;
    StringCopyA( pOption->szSignature, "PARSER2", 8 );

    // -User
    pOption = pcmdOptions + OI_USER;
    pOption->dwCount = 1;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->dwFlags = CP_VALUE_MANDATORY;
    pOption->pValue = pwszUser;
    pOption->dwLength = MAX_STRING_LENGTH;
    pOption->pwszOptions=OPTION_USER;
    StringCopyA( pOption->szSignature, "PARSER2", 8 );

    // -scope
    pOption = pcmdOptions + OI_SCOPE;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwType = CP_TYPE_TEXT;
    pOption->dwFlags = CP_VALUE_MANDATORY | CP2_MODE_VALUES;
    pOption->pValue = szScope;
    pOption->dwLength = MAX_STRING_LENGTH;
    pOption->pwszValues=TEXT_SCOPE_VALUES;
    pOption->pwszOptions=OPTION_SCOPE;
    StringCopyA( pOption->szSignature, "PARSER2", 8 );
    

    //
    // do the parsing
    if( DoParseParam2( argc, argv, -1, MAX_CMDLINE_OPTIONS, pcmdOptions, 0 ) == FALSE )
    {
        delete [] pcmdOptions;  // clear memory
        pcmdOptions = NULL;
        return FALSE;           // invalid syntax
    }

    pOption = pcmdOptions+OI_USERNAME;
    m_strUserName =(LPCWSTR) pOption->pValue;

    // Do Parse Param succeded so set the flag to indicate that we have to
    // show an additional line alongwith the error message
    *pbNeedUsageMsg = TRUE;

    // release the buffers
    m_strServerName.ReleaseBuffer();
    m_strPassword.ReleaseBuffer();
    m_strUser.ReleaseBuffer();

    // check the usage option
    if( m_bUsage && ( argc > 2 ) )
    {
        // No options are accepted with -?
        SetReason( ERROR_USAGE );
        delete [] pcmdOptions;      // clear the cmd parser config info
        return FALSE;
    }
    else if( m_bUsage == TRUE )
    {
        // should not do the furthur validations
        delete [] pcmdOptions;      // clear the cmd parser config info
        return TRUE;
    }

    // Check what has been entered for the scope variable
    //  and set the flag appropriately
    if( StringCompare( szScope, TEXT_SCOPE_USER, TRUE, 0 ) == 0 )
    {
        m_dwScope = SCOPE_USER;
    }
    else if( StringCompare( szScope, TEXT_SCOPE_COMPUTER, TRUE, 0 ) == 0 )
    {
        m_dwScope = SCOPE_COMPUTER;
    }

    //
    // now, check the mutually exclusive options
    pOptionServer = pcmdOptions + OI_SERVER;
    pOptionUserName = pcmdOptions + OI_USERNAME;
    pOptionPassword = pcmdOptions + OI_PASSWORD;
    pOptionUser = pcmdOptions + OI_USER;
    pOptionVerbose = pcmdOptions + OI_VERBOSE;
    pOptionSuperVerbose = pcmdOptions + OI_SUPER_VERBOSE;

    // "-z" and "-v" are mutually exclusive options
    if( pOptionVerbose->dwActuals != 0 && pOptionSuperVerbose->dwActuals != 0 )
    {
        // invalid syntax
        SetReason( ERROR_VERBOSE_SYNTAX );
        delete [] pcmdOptions;      // clear the cmd parser config info
        return FALSE;           // indicate failure
    }

    // "-u" should not be specified without machine names
    if( pOptionServer->dwActuals == 0 && pOptionUserName->dwActuals != 0 )
    {
        // invalid syntax
        SetReason( ERROR_USERNAME_BUT_NOMACHINE );
        delete [] pcmdOptions;      // clear the cmd parser config info
        return FALSE;           // indicate failure
    }

    // "-p" should not be specified without "-u"
    if( pOptionUserName->dwActuals == 0 && pOptionPassword->dwActuals != 0 )
    {
        // invalid syntax
        SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
        delete [] pcmdOptions;      // clear the cmd parser config info
        return FALSE;
    }

    // empty server name is not valid
    if( pOptionServer->dwActuals != 0 && m_strServerName.GetLength() == 0 )
    {
        SetReason( ERROR_SERVERNAME_EMPTY );
        delete [] pcmdOptions;
        return FALSE;
    }

    // empty user is not valid
    if( pOptionUserName->dwActuals != 0 && m_strUserName.GetLength() == 0 )
    {
        SetReason( ERROR_USERNAME_EMPTY );
        delete [] pcmdOptions;
        return FALSE;
    }

    // empty user is not valid, for the target user
    if( pOptionUser->dwActuals != 0 && m_strUser.GetLength() == 0 )
    {
        SetReason( ERROR_TARGET_EMPTY );
        delete [] pcmdOptions;
        return FALSE;
    }

    // if user has specified -s (or) -u and no "-p", then utility should accept password
    // the user will be prompted for the password only if establish connection
    // fails without the credentials information
    m_bNeedPassword = FALSE;
    if ( pOptionPassword->dwActuals != 0 && m_strPassword.Compare( L"*" ) == 0 )
    {
        // user wants the utility to prompt for the password before trying to connect
        m_bNeedPassword = TRUE;
    }
    else if ( pOptionPassword->dwActuals == 0 &&
            ( pOptionServer->dwActuals != 0 || pOptionUserName->dwActuals != 0 ) )
    {
        // utility needs to try to connect first and if it fails then prompt for the password
        m_bNeedPassword = TRUE;
        m_strPassword.Empty();
    }

    // Check wether we are querying for the local system
    if( pOptionServer->dwActuals == 0 )
    {
        m_bLocalSystem = TRUE;
    }

    // command-line parsing is successfull
    // clear the cmd parser config info
    delete [] pcmdOptions;

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    CGpResult constructor

Arguments:

    NONE

Return Value:

    NONE

*********************************************************************************************/
CGpResult::CGpResult()
{
    // initialize the member variables to defaults
    m_pWbemLocator = NULL;
    m_pEnumObjects = NULL;
    m_pWbemServices = NULL;
    m_pAuthIdentity = NULL;
    m_pRsopNameSpace = NULL;

    m_strServerName = L"";
    m_strUserName = L"";
    m_strPassword = L"";
    m_strUser = L"";
    m_strADSIDomain = L"";
    m_strADSIServer = L"";

    m_pwszPassword = NULL;

    m_hOutput = NULL;

    m_bVerbose = FALSE;
    m_dwScope = SCOPE_ALL;
    m_bNeedPassword = FALSE;
    m_bLocalSystem = FALSE;
    m_bUsage = FALSE;

    m_szUserGroups = NULL;

    m_hMutex = NULL;
    m_NoOfGroups = 0;
    m_bPlanning = FALSE;
    m_bLogging = FALSE;
    m_bUsage   = FALSE;
}

/*********************************************************************************************
Routine Description:

    CGpResult destructor

Arguments:

    NONE

Return Value:

    NONE

*********************************************************************************************/
CGpResult::~CGpResult()
{
    //
    // release WMI / COM interfaces
    SAFE_RELEASE( m_pWbemLocator );
    SAFE_RELEASE( m_pWbemServices );
    SAFE_RELEASE( m_pEnumObjects );
    SAFE_RELEASE( m_pRsopNameSpace );

    if( m_szUserGroups != NULL )
    {
     for( DWORD dw=0;dw<=m_NoOfGroups;dw++ )
     {
         FreeMemory((LPVOID *) &m_szUserGroups[dw] );
     }
     FreeMemory((LPVOID *)&m_szUserGroups);
    }

    // free authentication identity structure
    // release the existing auth identity structure
    WbemFreeAuthIdentity( &m_pAuthIdentity );

    // un-initialize the COM library
    CoUninitialize();

    // Release the object
    if( m_hMutex != NULL )
    {
        CloseHandle( m_hMutex );
    }
}

/*********************************************************************************************
Routine Description:

    Initializes the GpResult utility

Arguments:

    NONE

Return Value:

    TRUE    : if filters are appropriately specified
    FALSE   : if filters are errorneously specified

*********************************************************************************************/
BOOL CGpResult::Initialize()
{
    // if at all an error occurs, we know that is because of the
    // failure in memory allocation, so set the error initially
    SetLastError((DWORD) E_OUTOFMEMORY );
    SaveLastError();

    // initialize the COM library
    if ( InitializeCom( &m_pWbemLocator ) == FALSE )
    {
        return FALSE;
    }

    //
    // Init the console scree buffer structure to zero's
    // and then get the console handle and screen buffer information
    //
    // prepare for status display.
    // for this get a handle to the screen output buffer
    // but this handle will be null if the output is being redirected. so do not check
    // for the validity of the handle. instead try to get the console buffer information
    // only in case you have a valid handle to the output screen buffer
    SecureZeroMemory( &m_csbi, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );

    if( IsConsoleFile(stdout) )
        m_hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    else if( IsConsoleFile(stderr) )
        m_hOutput = GetStdHandle( STD_ERROR_HANDLE );
       else
            m_hOutput = NULL;

    if ( m_hOutput != NULL )
    {
        GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
    }

    // initialization is successful
    SetLastError( NOERROR );                // clear the error
    SetReason( NULL_STRING );           // clear the reason
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Initializes the GpResult utility

Arguments:

    [in] HANDLE                                  :  Handle to the output console
    [in] LPCWSTR                                 :  String to display
    [in] const CONSOLE_SCREEN_BUFFER_INFO&       :  pointer to the screen buffer

Return Value:

    NONE

*********************************************************************************************/
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg,
                        const CONSOLE_SCREEN_BUFFER_INFO& csbi )
{
    // local variables
    COORD       coord;
    DWORD       dwSize = 0;
    WCHAR       wszSpaces[ 80 ] = L"";

    // check the handle. if it is null, it means that output is being redirected. so return
    if( hOutput == NULL )
    {
        return;
    }

    // set the cursor position
    coord.X = 0;
    coord.Y = csbi.dwCursorPosition.Y;

    // first erase contents on the current line
    SecureZeroMemory( wszSpaces, 80 );
    SetConsoleCursorPosition( hOutput, coord );
    WriteConsoleW( hOutput, Replicate( wszSpaces, L" ", 79, 79 ), 79, &dwSize, NULL );

    // now display the message ( if exists )
    SetConsoleCursorPosition( hOutput, coord );
    if( pwszMsg != NULL )
    {
        WriteConsoleW( hOutput, pwszMsg, lstrlen( pwszMsg ), &dwSize, NULL );
    }
}

BOOL CGpResult::CreateRsopMutex( LPWSTR szMutexName )
{
    BOOL bResult = FALSE;
    SECURITY_ATTRIBUTES sa;
    PSECURITY_DESCRIPTOR psd = NULL;

    //
    // first try to open the mutex object by its name
    // if that fails it means the mutex is not yet created and 
    // so create it now
    //
    m_hMutex = OpenMutex( SYNCHRONIZE, FALSE, szMutexName );
    if ( m_hMutex == NULL )
    {
        // check the error code why it failed to open
        if ( GetLastError() == ERROR_FILE_NOT_FOUND )
        {
            // create the security descriptor -- just set the 
            // Dicretionary Access Control List (DACL)
            // in order to provide security, we will deny WRITE_OWNER and WRITE_DAC
            // permission to Everyone except to the owner 
             bResult = ConvertStringSecurityDescriptorToSecurityDescriptor( 
                 L"D:(D;;WOWD;;;WD)(A;;GA;;;WD)", SDDL_REVISION_1, &psd, NULL );
            if ( bResult == FALSE )
            {
                // we encountered error while creating a security descriptor
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                return FALSE;
            }

            // initialize the SECURITY_ATTRIBUTES structure
            SecureZeroMemory( &sa, sizeof( SECURITY_ATTRIBUTES ) );
            sa.nLength = sizeof( SECURITY_ATTRIBUTES );
            sa.lpSecurityDescriptor = psd;
            sa.bInheritHandle = FALSE;

            // mutex doesn't exist -- so we need to create it now
            m_hMutex = CreateMutex( &sa, FALSE, szMutexName );
            if (m_hMutex == NULL )
            {
                // we are not able to create the mutex
                // cannot proceed furthur
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                return FALSE;
            }
            LocalFree(psd);
        }
        else
        {
            // we encounter some error 
            // cannot proceed furthur
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\gpresult.h ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    GpResult.h

Abstract:

    This module  contanins function definations required by GpResult.cpp,
    and all necessary Defines and header files used in this project.

Author:

    Wipro Technologies.

Revision History:

    20-Feb-2001 : Created It.

*********************************************************************************************/
#ifndef _GPRESULT_H
#define _GPRESULT_H

#include "Resource.h"
#include "aclapi.h"
#include "sddl.h"
//
// macro definitions

#define ADMINISTRATORS_SID  L"S-1-5-32-544"     //administrators group id

// Exit the program with appropriate error code after releasing the memory
#define EXIT_PROCESS( exitcode )    \
    ReleaseGlobals();   \
    return exitcode;    \
    1

// Macro to check for the returned hresult value
#define CHECK_HRESULT( hr )    \
    if( FAILED( hr ) ) \
    {   \
        _com_issue_error( hr ); \
    }\
    1

// Macro to check for the returned hresult value, this one cleans the status msg
#define CHECK_HRESULT_EX( hr )    \
    if( FAILED( hr ) ) \
    {   \
        PrintProgressMsg( m_hOutput, NULL, m_csbi );    \
        _com_issue_error( hr ); \
    }\
    1

// Macro to check for the returned hresult value
// It also sets the variant to VT_EMPTY
#define CHECK_HRESULT_VAR( hr, var )    \
    if( FAILED( hr ) ) \
    {   \
        V_VT( &var ) = VT_EMPTY; \
        VariantClear(&var);\
        _com_issue_error( hr ); \
    }\
    1

#define CHECK_BRESULT( bResult ) \
    if( bResult == FALSE )  \
    {   \
        _com_issue_error( STG_E_UNKNOWN ); \
    }   \
    1

//SAFEDELETE
#define SAFEDELETE( pObj ) \
    if (pObj) \
    {   \
        delete[] pObj; \
        pObj = NULL; \
    }\
    1

//SAFEIRELEASE
#define SAFEIRELEASE( pIObj )\
    if ( pIObj )\
    {\
        pIObj->Release();\
        pIObj = NULL;\
    }\
    1

// SAFEBSTRFREE
#define SAFEBSTRFREE( bstrVal ) \
    if ( bstrVal ) \
    {   \
        SysFreeString( bstrVal ); \
        bstrVal = NULL; \
    } \
    1

// CHECK_ALLOCATION
#define CHECK_ALLOCATION( allocation )\
    if( ( allocation ) == NULL )\
    {\
        _com_issue_error( E_OUTOFMEMORY ); \
    }\
    1

#define SAFE_DELETE( pointer )      \
    if ( (pointer) != NULL )    \
    {   \
        delete (pointer);   \
        (pointer) = NULL;   \
    }   \
    1

#define SAFE_DELETE_EX( pointer )       \
    if ( (pointer) != NULL )    \
    {   \
        delete [] (pointer);    \
        (pointer) = NULL;   \
    }   \
    1

#define DESTROY_ARRAY( array )  \
    if ( (array) != NULL )  \
    {   \
        DestroyDynamicArray( &(array) );    \
        (array) = NULL; \
    }   \
    1

#ifdef _DEBUG
#define TRACE_DEBUG( text )     _tprintf( _T("TRACE: ") ## text )
#else
#define TRACE_DEBUG( text )     1
#endif

//
//      Constants and Definitions

// Maximum Command Line  List
#define MAX_CMDLINE_OPTIONS         8
#define MAX_DATA                    6

#define MAX_QUERY_STRING            512

#define TIME_OUT_NEXT               5000
#define VERSION_CHECK               5000

// Defining the domain role of a PDC for LDAP purposes
#define DOMAIN_ROLE_PDC             5

// Define a constant to check for the True value returned from WMI
#define VAR_TRUE    -1

// Option indices
#define OI_USAGE                0
#define OI_SERVER               1
#define OI_USERNAME             2
#define OI_PASSWORD             3
#define OI_VERBOSE              4
#define OI_SUPER_VERBOSE        5
#define OI_USER                 6
#define OI_SCOPE                7
//#define OI_LOGGING              8
//#define OI_PLANNING             9


// Option values
#define OPTION_USAGE            _T( "?" )
#define OPTION_LOGGING          _T( "Logging" )
#define OPTION_PLANNING         _T( "Planning" )
#define OPTION_SERVER           _T( "s" )
#define OPTION_USERNAME         _T( "u" )
#define OPTION_PASSWORD         _T( "p" )
#define OPTION_USER             _T( "User" )
#define OPTION_SCOPE            _T( "Scope" )
#define OPTION_VERBOSE          _T( "v" )
#define OPTION_SUPER_VERBOSE    _T( "z" )

// Data Indices
#define DI_USER_SID             0
#define DI_USER_NAME            1
#define DI_LOCAL_PROFILE        2
#define DI_USER_SERVER          3
#define DI_USER_DOMAIN          4
#define DI_USER_SITE            5

// Exit values
#define CLEAN_EXIT              0
#define ERROR_EXIT              1

// Array column values
#define COL_DATA                0
#define COL_ORDER               1
#define COL_FILTER              1
#define COL_FILTER_ID           2
#define COL_MAX                 2
#define COL_MAX_FILTER          3

// General defines
#define ARRAYSIZE( a ) ( sizeof(a)/sizeof( a[0] ) )

#define MUTEX_NAME              _T( "Global\\RsopCreateSessionMutex" )
#define START_NAMESPACE         _T( "\\root\\rsop" )

#define DEFAULT_LINK_SPEED      _T( "500 kbps" )

#define HELP_OPTION             _T( "-?" )
#define HELP_OPTION1            _T( "/?" )
#define NEW_LINE                _T( "\n" )
#define TAB_TWO                 _T( "        " )
#define TAB_ONE                 _T( "    " )

#define SLASH                   _T( '\\' )
#define SEPARATOR_AT            _T( '@' )
#define SEPARATOR_DOT           _T( '.' )

// SID values
#define SID_NULL_SID            _T( "S-1-0-0" )
#define SID_EVERYONE            _T( "S-1-1-0" )
#define SID_LOCAL               _T( "S-1-2-0" )
#define SID_CREATOR_OWNER       _T( "S-1-3-0" )
#define SID_CREATOR_GROUP       _T( "S-1-3-1" )

// Scope (Computer/User/All)
#define SCOPE_ALL               0
#define SCOPE_USER              1
#define SCOPE_COMPUTER          2

#define TEXT_SCOPE_VALUES       _T( "USER|COMPUTER" )
#define TEXT_SCOPE_USER         _T( "USER" )
#define TEXT_SCOPE_COMPUTER     _T( "COMPUTER" )
#define TEXT_WILD_CARD          _T( "*" )
#define TEXT_BACKSLASH          _T( "\\" )
#define TEXT_COMMA_DC           _T( ", DC=" )
#define TEXT_DOLLAR             _T( "$" )

// Queries
#define QUERY_LOCAL             _T( "Select * from Win32_UserAccount where name = \"%s\"" )
#define QUERY_DOMAIN            _T( "Select * from Win32_UserAccount where name = \"%s\" and Domain = \"%s\" " )
#define QUERY_LANGUAGE          _T( "WQL" )
#define QUERY_WILD_CARD         _T( "Select * from Win32_UserAccount" )
#define QUERY_GPO_NAME          _T( "Select name from Rsop_Gpo WHERE id = \"%s\"" )
#define QUERY_DOMAIN_NAME       _T( "ASSOCIATORS OF {%s} WHERE ResultClass=Win32_Group" )
#define QUERY_USER_NAME         _T( "Select name, domain from Win32_UserAccount where SID = \"%s\"" )
#define QUERY_COMPUTER_FQDN     _T( "Select ds_distinguishedName from ds_computer" )
#define QUERY_USER_FQDN         _T( "Select ds_distinguishedName from ds_user where ds_SAMAccountName = \"%s\"" )
#define QUERY_TERMINAL_SERVER_MODE _T( "select * from Win32_TerminalServiceSetting where Servername = \"%s\"" )
#define OBJECT_PATH             _T( "Win32_SID.SID=\"%s\"" )
#define GPO_REFERENCE           _T( "RSOP_GPO.id=" )

// error messages
#define ERROR_USERNAME_BUT_NOMACHINE    GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME   GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_NODATA_AVAILABLE_REMOTE   GetResString( IDS_ERROR_NODATA_AVAILABLE_REMOTE )
#define ERROR_NODATA_AVAILABLE_LOCAL    GetResString( IDS_ERROR_NODATA_AVAILABLE_LOCAL )
#define ERROR_USERNAME_EMPTY            GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_SERVERNAME_EMPTY          GetResString( IDS_ERROR_SERVERNAME_EMPTY )
#define ERROR_NO_OPTIONS                GetResString( IDS_ERROR_NO_OPTIONS )
#define ERROR_USAGE                     GetResString( IDS_ERROR_USAGE )
#define ERROR_TARGET_EMPTY              GetResString( IDS_ERROR_TARGET_EMPTY )
#define ERROR_VERBOSE_SYNTAX            GetResString( IDS_ERROR_VERBOSE_SYNTAX )

//
// Mapping information of Win32_ComputerSystem's DomainRole property
// NOTE: Refer to the _DSROLE_MACHINE_ROLE enumeration values in DsRole.h header file
#define VALUE_STANDALONEWORKSTATION     GetResString( IDS_VALUE_STANDALONEWORKSTATION )
#define VALUE_MEMBERWORKSTATION         GetResString( IDS_VALUE_MEMBERWORKSTATION )
#define VALUE_STANDALONESERVER          GetResString( IDS_VALUE_STANDALONESERVER )
#define VALUE_MEMBERSERVER              GetResString( IDS_VALUE_MEMBERSERVER )
#define VALUE_BACKUPDOMAINCONTROLLER    GetResString( IDS_VALUE_BACKUPDOMAINCONTROLLER )
#define VALUE_PRIMARYDOMAINCONTROLLER   GetResString( IDS_VALUE_PRIMARYDOMAINCONTROLLER )

// Classes, providers and namespaces...
#define ROOT_NAME_SPACE             _T( "root\\cimv2" )
#define ROOT_RSOP                   _T( "root\\rsop" )
#define ROOT_DEFAULT                _T( "root\\default" )
#define ROOT_POLICY                 _T( "root\\policy" )
#define ROOT_LDAP                   _T( "root\\directory\\ldap" )

#define CLS_DIAGNOSTIC_PROVIDER     _T( "RsopLoggingModeProvider" )
#define CLS_STD_REGPROV             _T( "StdRegProv" )

#define CLS_WIN32_SITE              _T( "Win32_NTDomain" )
#define CLS_WIN32_OS                _T( "Win32_OperatingSystem" )
#define CLS_WIN32_CS                _T( "Win32_ComputerSystem" )
#define CLS_WIN32_UA                _T( "Win32_UserAccount" )
#define CLS_WIN32_C                 _T( "Win32_Computer" )
#define CLS_RSOP_GPO                _T( "Rsop_GPO" )
#define CLS_RSOP_GPOLINK            _T( "Rsop_GPLink" )
#define CLS_RSOP_SESSION            _T( "Rsop_Session" )

// Class Property Values
#define CPV_SID                     _T( "SID" )
#define CPV_NAME                    _T( "name" )
#define CPV_DOMAIN                  _T( "domain" )
#define CPV_SVALUE                  _T( "sValue" )
#define CPV_GPO_NAME                _T( "name" )
#define CPV_GPO_FILTER_STATUS       _T( "filterAllowed" )
#define CPV_GPO_FILTER_ID           _T( "filterId" )
#define CPV_GPO_SERVER              _T( "__SERVER" )
#define CPV_SITE_NAME               _T( "DcSiteName" )
#define CPV_DC_NAME                 _T( "DomainControllerName" )
#define CPV_USER_SID                _T( "userSid" )
#define CPV_DOMAIN_ROLE             _T( "DomainRole" )
#define CPV_OS_VERSION              _T( "Version" )
#define CPV_OS_CAPTION              _T( "Caption" )
#define CPV_SEC_GRPS                _T( "SecurityGroups" )
#define CPV_SLOW_LINK               _T( "slowLink" )
#define CPV_ACCOUNT_NAME            _T( "AccountName" )
#define CPV_USER_SIDS               _T( "userSids" )
#define CPV_APPLIED_ORDER           _T( "appliedOrder" )
#define CPV_GPO_REF                 _T( "GPO" )
#define CPV_ENABLED                 _T( "enabled" )
#define CPV_ACCESS_DENIED           _T( "accessDenied" )
#define CPV_VERSION                 _T( "version" )
#define CPV_FQDN                    _T( "ds_distinguishedName" )
#define CPV_LDAP_FQDN               _T( "distinguishedName" )
#define CPV_LDAP_SAM                _T( "sAMAccountName" )
#define CPV_TERMINAL_SERVER_MODE    _T( "TerminalServerMode" )
#define CPV_FLAGS                   _T( "flags" )
#define CPV_EXTENDEDINFO            _T( "ExtendedInfo" )


// Function return
#define FPR_VALUE_NAME              _T( "sValueName" )
#define FPR_LOCAL_VALUE             _T( "ProfileImagePath" )
#define FPR_ROAMING_VALUE           _T( "CentralProfile" )
#define FPR_SUB_KEY_NAME            _T( "sSubKeyName" )
#define FPR_HDEFKEY                 _T( "hDefKey" )
#define FPR_RSOP_NAME_SPACE         _T( "nameSpace" )
#define FPR_RETURN_VALUE            _T( "hResult" )
#define FPR_RSOP_NAMESPACE          _T( "nameSpace" )
#define FPR_SNAMES                  _T( "sNames" )
#define FPR_LINK_SPEED_VALUE        _T( "GroupPolicyMinTransferRate" )
#define FPR_APPLIED_FROM            _T( "DCName" )

// Paths in registry to retrieve info. from
#define PATH                        _T( "SOFTWARE\\MicroSoft\\Windows NT\\CurrentVersion\\ProfileList\\" )
#define GPRESULT_PATH               _T( "Software\\policies\\microsoft\\windows\\system" )
#define GROUPPOLICY_PATH            _T( "Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy" )
#define APPLIED_PATH                _T( "Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History" )

// Registry keys
#define HKEY_DEF                    2147483650
#define HKEY_CURRENT_USER_DEF       2147483649

// keys in registry whose info. is required
#define FN_GET_EXPAND_VAL           _T( "GetExpandedStringValue" )
#define FN_CREATE_RSOP              _T( "RsopCreateSession" )
#define FN_DELETE_RSOP              _T( "RsopDeleteSession" )
#define FN_ENUM_USERS               _T( "RsopEnumerateUsers" )
#define FN_ENUM_KEYS                _T( "EnumKey" )

// general defines
#define SEPARATOR                   _T("-")
#define DOUBLESLASH                 _T("\\\\")
#define ZERO                        _T("00000000000000.000000+000")
#define EXTRA                       _T('e')
#define LAST_TIME_OP                GetResString( IDS_LAST_TIME_OP )

// Structure to hold the User Information
typedef struct _USER_INFO
{
    CHString        strUserSid;             // Holds the SID value for the user.
    CHString        strUserName;            // Holds the Name of the user.
    CHString        strLocalProfile;        // Holds the local profile for the user.
    CHString        strRoamingProfile;      // Holds the roaming profile for the user.
    CHString        strUserServer;          // Holds the server name for the user.
    CHString        strComputerDomain;      // Holds the computer domain name.
    CHString        strUserDomain;          // Holds the user domain name.
    CHString        strUserSite;            // Holds the site name.
    CHString        strOsType;              // Holds the OS type
    CHString        strOsVersion;           // Holds the OS Version
    CHString        strOsConfig;            // Holds the OS Configuration
    CHString        strUserFQDN;            // Holds the FQDN of the user
    CHString        strComputerFQDN;        // Holds the FQDN of the computer
    CHString        strTerminalServerMode;  // Holds the Terminal Server Mode, code added on 03-sep-2001

}USERINFO, *PUSERINFO;


//
// CGpResult
//
class CGpResult
{
// constructor / destructor
public:
      CGpResult();
    ~CGpResult();

// data memebers
private:
    // WMI / COM interfaces
    IWbemLocator            *m_pWbemLocator;
    IWbemServices           *m_pWbemServices;
    IWbemServices           *m_pRsopNameSpace;
    IEnumWbemClassObject    *m_pEnumObjects;

    // WMI connectivity
    COAUTHIDENTITY          *m_pAuthIdentity;

    // command-line argument values
    CHString        m_strUserName;     // Stores the user name
    CHString        m_strPassword;     // Stores the password
    CHString        m_strUser;         // Stores the User for whom the data is to be retrieved
    CHString        m_strServerName;   // Stores the server name
    CHString        m_strDomainName;   // Stores the domain name, if specified with the user name

    LPWSTR          m_pwszPassword;    // Stores the password returned by the AUTHIDENTITY structure

    BOOL            m_bVerbose;        // is set to TRUE if the verbose information is to be displayed
    BOOL            m_bSuperVerbose;   // is set to TRUE if the super verbose information is to be displayed

    DWORD           m_dwScope;         // This gives the scope of information to be displayed

    // others
    BOOL            m_bNeedPassword;   // is set to TRUE if the password has to be prompted for
    BOOL            m_bLocalSystem;    // is set to TRUE if the local system has to be queried.

    HANDLE          m_hMutex;          // Handle to the mutex for the RsopCreateSession method

    CHString        m_strADSIDomain;   // Holds the domain name for the ADSI connection
    CHString        m_strADSIServer;   // Holds the server name for ADSI
    LPWSTR          *m_szUserGroups;       // Holds the all the groups that user belongs
    DWORD           m_NoOfGroups;

//   data members that we need to access directly
public:
    // main command line arguments
    BOOL            m_bLogging;        // set to TRUE if the logging mode data is to be displayed
    BOOL            m_bPlanning;       // set to TRUE if the planning mode data is to be displayed
    BOOL            m_bUsage;          // set to TRUE if the usage is to be displayed

    // progress message related
    HANDLE                              m_hOutput;
    CONSOLE_SCREEN_BUFFER_INFO          m_csbi;

private:
    BOOL DisplayCommonData( PUSERINFO pUserInfo );
    VOID DisplaySecurityGroups( IWbemServices *pNameSpace, BOOL bComputer );
    BOOL DisplayData( PUSERINFO pUserInfo, IWbemServices *pRsopNameSpace );
    BOOL DisplayVerboseComputerData( IWbemServices *pNameSpace );
    BOOL DisplayVerboseUserData( PUSERINFO pUserInfo, IWbemServices *pNameSpace );
    BOOL GetUserData( BOOL bAllUsers );
    BOOL GetUserProfile( PUSERINFO pUserInfo );
    BOOL GetDomainInfo( PUSERINFO pUserInfo );
    BOOL GetOsInfo( PUSERINFO pUserInfo );
    BOOL GetUserNameFromWMI( TCHAR szSid[], TCHAR szName[], TCHAR szDomain[] );
    BOOL DisplayThresholdSpeedAndLastTimeInfo( BOOL bComputer );
    BOOL GpoDisplay( IWbemServices *pNameSpace, LPCTSTR pszScopeName );
    VOID GetFQDNFromADSI( TCHAR szFQDN[], BOOL bComputer, LPCTSTR pszUserName );
    BOOL GetTerminalServerMode( PUSERINFO pUserInfo  );
    BOOL CreateRsopMutex( LPWSTR szMutexName );

public:
    VOID DisplayUsage();
    BOOL Initialize();
    BOOL ProcessOptions( DWORD argc, LPCWSTR argv[], BOOL *pbNeedUsageMsg );

    // functionality related
    BOOL GetLoggingData();
    BOOL Connect( LPCWSTR pszServer );
    VOID Disconnect();
};

// Function prototypes
VOID GetWbemErrorText( HRESULT hResult );
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg,
                                        const CONSOLE_SCREEN_BUFFER_INFO& csbi );
LCID GetSupportedUserLocale( BOOL& bLocaleChanged );

DWORD IsLogonDomainAdmin(IN LPWSTR szOwnerString, OUT PBOOL pbLogonDomainAdmin);
DWORD IsAdminGroup( BOOL *bStatus );
DWORD IsAdministratorsGroup(IN LPWSTR szGroupName, OUT PBOOL pbAdministratorsGroup);
BOOL  GetTokenHandle(OUT PHANDLE hTokenHandle);

#endif //#ifndef _GPRESULT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\loggingdata.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    LoggingData.cpp

Abstract:

    Collects and displays all the data related with the logging option.

Author:

    Wipro Technologies.

Revision History:

    22-Feb-2001 : Created It.

*********************************************************************************************/

#include "pch.h"
#include "GpResult.h"
#include "WMI.h"

// Local function prototypes
BOOL GetDomainType( LPTSTR lpszDomainName, BOOL * pbW2K, BOOL *pbLocalAccount );
BOOL RsopDeleteMethod( IWbemClassObject *pClass, CHString strNameSpace,
                                        IWbemServices *pNamespace );
VOID DisplayLinkSpeed( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity );
VOID SortAppliedData( TARRAY arrAppliedData );

/*********************************************************************************************
Routine Description:

    This function is the main entry point for collecting and displaying the data for logging mode

Arguments:

  None

Return Value:

    TRUE  on SUCCESS
    FALSE on ERROR
*********************************************************************************************/
BOOL  CGpResult::GetLoggingData()
{
    // Local declarations
    BOOL        bResult = FALSE;
    BOOL        bAllUsers = TRUE;
    DWORD       dwBufferSize = MAX_STRING_LENGTH;
    DWORD       dwPosition = 0xffffffff;


    // Connect to wmi...connecting to 'cimv2' and saving the pointer in a member variable
    bResult = ConnectWmiEx( m_pWbemLocator, &m_pWbemServices, m_strServerName,
                            m_strUserName, m_strPassword, &m_pAuthIdentity,
                            m_bNeedPassword, ROOT_NAME_SPACE, &m_bLocalSystem );

    if( bResult == FALSE )
    {
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
        return FALSE;
    }

    // check the remote system version and its compatiblity
    if ( m_bLocalSystem == FALSE )
    {
        // check the version compatibility
        DWORD dwVersion = 0;
        dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );

        // Check for the version W2K = 5000 and WindowsXP = 5001
        if ( dwVersion <= VERSION_CHECK )
        {
            // Display the appropriate error message
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, ERROR_OS_INCOMPATIBLE );
            return FALSE;
        }
    }

    // Set the password to the one got in the AUTHIDENTITY structure
    if( m_pAuthIdentity != NULL )
    {
        m_pwszPassword = m_pAuthIdentity->Password;
    }

    // check if it is the local system and the user credentials are specified....
    // if so display a warning message
    if( ( m_bLocalSystem == TRUE ) && ( m_strUserName.GetLength() != 0 ) )
    {
        ShowMessage( stderr, GetResString( IDS_WARNING ) );
        ShowMessage( stderr, GetResString( IDS_WARN_LOCAL ) );
        ShowMessage( stderr, NEW_LINE );

        // set the user name and password to NULL
        m_strUserName = L"";
        m_pwszPassword = NULL;

        // Get the new screen co-ordinates
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }

    // Connection part is over...check wether the user,for whom the RSOP data
    // has to be got has been specified.
    if( m_strUser.GetLength() == 0 )
    {
        // user is not specified....get the current logged on user
        LPWSTR pwszUserName = NULL;
        try
        {
            pwszUserName = m_strUser.GetBufferSetLength( dwBufferSize );
        }
        catch( ... )
        {
            // display the error message
            SetLastError((DWORD) E_OUTOFMEMORY );
            SaveLastError();
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetReason() );
        }

        if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwBufferSize ) == FALSE )
        {
            // error occured while trying to get the current user info
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            return FALSE;
        }

        // Release the buffer
        m_strUser.ReleaseBuffer();
    }

    // Separating the domain name from the user name for whom the data has to be retrieved
    if( m_strUser.Compare( TEXT_WILD_CARD ) != 0 )
    {
        bAllUsers = FALSE;
        dwPosition = m_strUser.Find( SLASH );
        try
        {
            if( dwPosition != -1 )
            {
                m_strDomainName = m_strUser.Left( dwPosition );
                m_strUser = m_strUser.Mid( ( dwPosition + 1 ), m_strUser.GetLength() );
            }
            else
            {
                // Try for the name@domain format (UPN format)
                dwPosition = m_strUser.Find( SEPARATOR_AT );
                if( dwPosition != -1 )
                {
                    m_strDomainName = m_strUser.Mid( ( dwPosition + 1 ), m_strUser.GetLength() );
                    m_strUser = m_strUser.Left( dwPosition );
                }

                // Remove the unwanted things in the domain name
                dwPosition = m_strDomainName.Find( SEPARATOR_DOT );
                if( dwPosition != -1 )
                {
                    m_strDomainName = m_strDomainName.Left( dwPosition );
                }
            }
        }
        catch( ... )
        {
            // display the error message
            SetLastError( (DWORD)E_OUTOFMEMORY );
            SaveLastError();
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetReason() );
        }
    }

    PrintProgressMsg( m_hOutput, GetResString( IDS_USER_DATA ), m_csbi );

    //
    // Start the retrieval of information....
    // Get the user information
    if( GetUserData( bAllUsers ) == FALSE )
    {
        return FALSE;
    }

    return TRUE;
}

/*********************************************************************************************
Routine Description:

     This function displays the non verbose data

Arguments:

    [in] USERINFO           :   pointer to the user information structure
    [in] IWBEMSERVICES      :   pointer to the namespace

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::DisplayData( PUSERINFO pUserInfo, IWbemServices *pRsopNameSpace )
{
    // local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bCreatedRsop = FALSE;

    ULONG                       ulReturn = 0;
    ULONG                       ulExtendedCode = 0;
    DWORD                       dwi = 0;

    DWORD                       dwFlags = 0;
    DWORD                       dwMutex = 0;

    CHString                    strTemp;
    CHString                    strNameSpace;



    IWbemClassObject            *pClass = NULL;
    IWbemClassObject            *pInClass = NULL;
    IWbemClassObject            *pInInst = NULL;
    IWbemClassObject            *pOutInst = NULL;
    IWbemServices               *pNameSpace = NULL;
    IEnumWbemClassObject        *pRsopClass = NULL;

    BOOL                        bW2KDomain  = FALSE;
    BOOL                        bLocalAccount = FALSE;
    WCHAR                       szMsgBuffer[MAX_RES_STRING] = NULL_STRING;
    WCHAR                       szMutexName[512] = MUTEX_NAME;

    try
    {
        if( pUserInfo == NULL || pRsopNameSpace == NULL )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            _com_issue_error( STG_E_UNKNOWN );
        }

        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_PROVIDER ), m_csbi );

        // Get the object for the RSOP diagnostic mode provider
        hResult = pRsopNameSpace->GetObject( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ),
                                                0, NULL, &pClass, NULL );
        CHECK_HRESULT_EX( hResult );

        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_METHOD ), m_csbi );

        // get the reqd. method....create an rsop session
        hResult = pClass->GetMethod( _bstr_t( FN_CREATE_RSOP ), 0, &pInClass, NULL );
        CHECK_HRESULT_EX( hResult );

        // spawn the instances....get a new instance of the provider
        hResult = pInClass->SpawnInstance( 0, &pInInst );
        CHECK_HRESULT_EX( hResult );

        // Put the user SID...
        PrintProgressMsg( m_hOutput, GetResString( IDS_PUT_SID ), m_csbi );

        hResult = PropertyPut( pInInst, CPV_USER_SID, pUserInfo->strUserSid );
        CHECK_HRESULT_EX( hResult );

        dwFlags = FLAG_FORCE_CREATENAMESPACE;
        if ( m_dwScope == SCOPE_COMPUTER )
        {
            dwFlags |= FLAG_NO_USER;
        }
        else if ( m_dwScope == SCOPE_USER )
        {
            dwFlags |= FLAG_NO_COMPUTER;
        }
        hResult = PropertyPut( pInInst, CPV_FLAGS, dwFlags );
        CHECK_HRESULT_EX( hResult );

        PrintProgressMsg( m_hOutput, GetResString( IDS_WAIT ), m_csbi );

        // We are ready to call the method to create a session
        // Check on the mutex to see if the call can be executed
        //create the mutex

        StringConcat( szMutexName, L"_", SIZE_OF_ARRAY(szMutexName));
        strTemp = pUserInfo->strUserName;
        LONG lPos = strTemp.Find(TEXT_BACKSLASH);
        if( lPos >= 0 && lPos <= strTemp.GetLength() )
        {
            strTemp.SetAt(lPos, L'_' );
        }

        StringConcat( szMutexName, strTemp, SIZE_OF_ARRAY(szMutexName) );
        if( FALSE == CreateRsopMutex( szMutexName ) )
        {
            ShowMessage(stdout, GetResString(IDS_INFO) );
            ShowMessage(stdout, GetResString(IDS_MUTEX_FAILED));

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pNameSpace );

            return TRUE;
        }
        dwMutex = WAIT_FAILED;
        if( NULL == m_hMutex )
        {
           PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage(stdout, GetResString(IDS_INFO) );
            ShowMessage(stdout, GetResString(IDS_ERROR_SESSION_CONFLICT));

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pNameSpace );

            return TRUE;
        }
        if( m_hMutex != NULL )
        {
            dwMutex = WaitForSingleObject( m_hMutex, INFINITE );
            if( dwMutex == WAIT_FAILED )
            {
                ShowLastErrorEx( stdout, SLE_TYPE_ERROR | SLE_SYSTEM );
            }
        }

retry:

        if( dwMutex != WAIT_FAILED )
        {
            // Print the progress message
            strTemp.Format( GetResString( IDS_CREATE_SESSION ), pUserInfo->strUserName );
            PrintProgressMsg( m_hOutput, strTemp, m_csbi );

            // All The required properties are set, so...execute method RSopCreateSession
            hResult = pRsopNameSpace->ExecMethod( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ),
                                                    _bstr_t( FN_CREATE_RSOP ),
                                                    0, NULL, pInInst, &pOutInst, NULL);
        }
        if( pOutInst == NULL )
        {
            hResult = E_FAIL;
        }
        if( FAILED( hResult ) )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            // display the error message
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pNameSpace );

            // Release the object
            ReleaseMutex( m_hMutex );
            return FALSE;
        }

        // Get the result value...
        bResult = PropertyGet( pOutInst, FPR_RETURN_VALUE, ulReturn, 0 );
        CHECK_BRESULT( bResult );

        if( ulReturn != 0 )
        {
            if ( ulReturn == WBEM_E_ACCESS_DENIED )
            {
                // check the extended error code to see why this is failed
                bResult = PropertyGet( pOutInst, CPV_EXTENDEDINFO, ulExtendedCode, 0 );
                CHECK_BRESULT( bResult );
            
                // ...
                if ( ulExtendedCode == RSOP_COMPUTER_ACCESS_DENIED )
                {
                    if ( m_dwScope != SCOPE_COMPUTER )
                    {
                        hResult = PropertyPut( pInInst, 
                            CPV_FLAGS, FLAG_FORCE_CREATENAMESPACE | FLAG_NO_COMPUTER );
                        CHECK_HRESULT_EX( hResult );

                        // change the scope parameter accordingly
                        m_dwScope = SCOPE_USER;

                        // retry the creation of namespace
                        goto retry;
                    }
                }
                else if ( ulExtendedCode == RSOP_USER_ACCESS_DENIED )
                {
                    if ( m_dwScope != SCOPE_USER )
                    {
                        hResult = PropertyPut( pInInst, 
                            CPV_FLAGS, FLAG_FORCE_CREATENAMESPACE | FLAG_NO_USER );
                        CHECK_HRESULT_EX( hResult );
    
                        // change the scope parameter accordingly
                        m_dwScope = SCOPE_COMPUTER;

                        // retry the creation of namespace
                        goto retry;
                    }
                }
            }

            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pNameSpace );

            // Release the object
            ReleaseMutex( m_hMutex );
            return FALSE;
        }

        // set the flag to indicate that the namespace has been created.
        bCreatedRsop = TRUE;

        // Get the resultant RSOP name space
        bResult = PropertyGet( pOutInst, FPR_RSOP_NAME_SPACE, strTemp, V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );
        
        // Check if we have got the output
        if( StringCompare( strTemp, V_NOT_AVAILABLE, FALSE, 0 ) == 0 )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the allocated variables
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pNameSpace );

            // Release the object
            ReleaseMutex( m_hMutex );
            return FALSE;
        }

        // Got the data so start displaying
        // Display the information common to both scopes
        DisplayCommonData( pUserInfo );

        // Get the string starting with 'R'...as that's where the RSOP namespace starts
        // This is done to remove the '\'s in the beginning of the string returned.
        lPos = 0;
        strTemp.MakeLower();
        lPos = strTemp.Find( START_NAMESPACE );
        if ( lPos != -1 )
        {
            strTemp = strTemp.Mid( lPos + 1 );
        }
        else
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // check if the computer information has to be displayed
        if( (m_dwScope == SCOPE_COMPUTER) || (m_dwScope == SCOPE_ALL) )
        {
            // connect to the resultant name space (computer)
            strNameSpace = strTemp + TEXT_BACKSLASH + TEXT_SCOPE_COMPUTER;

            ConnectWmi( m_pWbemLocator, &pNameSpace, m_strServerName,
                        m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                        FALSE, strNameSpace, &hResult );
            CHECK_HRESULT( hResult );

            // get the link speed information
            DisplayLinkSpeed( pNameSpace, m_pAuthIdentity );

            // Display the heading for the scope Computer
            ShowMessage( stdout, GetResString( IDS_GPO_COMPUTER ) );
            ShowMessage( stdout, NEW_LINE );
            for( dwi = StringLengthInBytes( GetResString( IDS_GPO_COMPUTER ) ); dwi > 1; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );


            // Display the FQDN for the computer
            ShowMessage( stdout, pUserInfo->strComputerFQDN );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            // Display the link speed threshold value for the computer
            DisplayThresholdSpeedAndLastTimeInfo( TRUE );


/************this code is moved from common data to display domain name and domain type on 18-oct-2001*****************/

            StringCopy( szMsgBuffer, pUserInfo->strComputerDomain, MAX_RES_STRING );
            if( StringLengthW( szMsgBuffer,0 ) != 0 )
            {
                StringCopy( szMsgBuffer, _tcstok( szMsgBuffer, GetResString( IDS_LAST_CHAR ) ), MAX_RES_STRING );
                StringCopy( szMsgBuffer, _tcstok( NULL, GetResString( IDS_LAST_CHAR ) ), MAX_RES_STRING );
            }
            // Get the domain type information
            GetDomainType (szMsgBuffer, &bW2KDomain, &bLocalAccount);

            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
            ShowMessage( stdout, GetResString( IDS_DOMAIN_NAME ) );
            ShowMessage( stdout, szMsgBuffer );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            ShowMessage( stdout, GetResString( IDS_DOMAIN_TYPE ) );

            // if it is a  win2k domain type
            if ( bW2KDomain )
            {
                ShowMessage( stdout, GetResString( IDS_W2K_DOMAIN ) );
            }
            else
            {
                if ( bLocalAccount ) // local account
                {
//                  ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, GetResString( IDS_LOCAL_COMP ) );
                }
                else    //win NT4
                {
                    ShowMessage( stdout, GetResString( IDS_NT4_DOMAIN ) );
                }
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
/*************************************************************************************************/

            // Display the heading for the Computer GPO's
            ShowMessage( stdout, GetResString( IDS_GPO_DISPLAY ) );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
            for( dwi = StringLengthInBytes( GetResString( IDS_GPO_DISPLAY ) ); dwi > 4; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );

            // Display the GPO data for computer
            GpoDisplay( pNameSpace, TEXT_SCOPE_COMPUTER );

            // Display the security groups for the system
            DisplaySecurityGroups( pNameSpace, TRUE );

            // check wether the verbose option is specified
            if( m_bVerbose == TRUE || m_bSuperVerbose == TRUE )
            {
                // display the verbose computer information
                DisplayVerboseComputerData( pNameSpace );
            }

            // release the interface pointer
            SAFEIRELEASE( pNameSpace );
        }

        // check for user...
        if( (m_dwScope == SCOPE_USER) || (m_dwScope == SCOPE_ALL) )
        {
            // connect to the resultant name space (user)
            strNameSpace = strTemp + TEXT_BACKSLASH + TEXT_SCOPE_USER;

            ConnectWmi( m_pWbemLocator, &pNameSpace, m_strServerName,
                        m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                        FALSE, strNameSpace, &hResult );
            CHECK_HRESULT( hResult );

            // if only the user scope has been specified then the link speed
            // information has not yet been displayed...display it
            if( m_dwScope == SCOPE_USER )
            {
                // Get the link speed information
                DisplayLinkSpeed( pNameSpace, m_pAuthIdentity );
            }

            // Display the heading for the scope User
            ShowMessage( stdout, GetResString( IDS_GPO_USER ) );
            ShowMessage( stdout, NEW_LINE );
            for( dwi = StringLengthInBytes( GetResString( IDS_GPO_USER ) ); dwi > 1; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            // Display the FQDN for the computer
            ShowMessage( stdout, pUserInfo->strUserFQDN );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            // Display the link speed threshold value for the user
            DisplayThresholdSpeedAndLastTimeInfo( FALSE );

/******this code is added to display domain name and domain type for the user**************/


            ShowMessage( stdout, GetResString(IDS_NEWLINE) );
            StringCopy( szMsgBuffer, pUserInfo->strUserDomain, MAX_RES_STRING );
            GetDomainType (szMsgBuffer, &bW2KDomain, &bLocalAccount);

            ShowMessage( stdout, TAB_ONE );
            ShowMessage( stdout, GetResString( IDS_USER_DOMAIN_NAME ) );
            ShowMessage( stdout, szMsgBuffer );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            ShowMessage( stdout, GetResString( IDS_USER_DOMAIN_TYPE ) );
            // if it is a  win2k domain type
            if ( bW2KDomain )
            {
                ShowMessage( stdout, GetResString( IDS_W2K_DOMAIN ) );
            }
            else
            {
                if ( bLocalAccount ) // local account
                {
//                  ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, GetResString( IDS_LOCAL_COMP ) );
                }
                else    //win NT4
                {
                    ShowMessage( stdout, GetResString( IDS_NT4_DOMAIN ) );
                }
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

/*****************************************************************************************/

            // Display the heading for the User GPO's
            ShowMessage( stdout, GetResString( IDS_GPO_DISPLAY ) );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
            for( dwi = StringLengthInBytes( GetResString( IDS_GPO_DISPLAY ) ); dwi > 4; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );

            // Display the GPO data for user
            GpoDisplay( pNameSpace, TEXT_SCOPE_USER );

            // Display the security groups for the user
            DisplaySecurityGroups( pNameSpace, FALSE );

            // check wether the verbose option is specified
            if( m_bVerbose == TRUE || m_bSuperVerbose == TRUE )
            {
                // display the verbose computer information
                DisplayVerboseUserData( pUserInfo, pNameSpace );
            }

            // release the interface pointer
            SAFEIRELEASE( pNameSpace );
        }

       // Delete the namespace created
        if( RsopDeleteMethod( pClass, strTemp, pRsopNameSpace ) == FALSE )
        {
            // release the allocated variables
            SAFEIRELEASE( pRsopNameSpace );
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );

            // Release the object
            ReleaseMutex( m_hMutex );

            return FALSE;
        }
    }
    catch(  _com_error & error )
    {
        // display the error message
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // Delete the name space if it has been created.
        if( bCreatedRsop == TRUE )
        {
            RsopDeleteMethod( pClass, strTemp, pRsopNameSpace );
        }

        // release the interface pointers and exit
        SAFEIRELEASE( pRsopClass );
        SAFEIRELEASE( pClass );
        SAFEIRELEASE( pInClass );
        SAFEIRELEASE( pInInst );
        SAFEIRELEASE( pOutInst );
        SAFEIRELEASE( pNameSpace );

        // Release the object
        ReleaseMutex( m_hMutex );

        return FALSE;
    }

    // release the interface pointers and exit
    SAFEIRELEASE( pRsopClass );
    SAFEIRELEASE( pClass );
    SAFEIRELEASE( pInClass );
    SAFEIRELEASE( pInInst );
    SAFEIRELEASE( pOutInst );
    SAFEIRELEASE( pNameSpace );

    // Release the object
    ReleaseMutex( m_hMutex );

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the user data and fills the structure with the same

Arguments:

    [in] BOOL   bAllUsers       :   Specifies that the Rsop data has to be retrieved
                                    for all the users.

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetUserData( BOOL bAllUsers )
{
    // Local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotDomainInfo = FALSE;
    BOOL                        bConnFlag = TRUE;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szServer[ MAX_STRING_LENGTH ];
    TCHAR                       szName[ MAX_STRING_LENGTH ];
    TCHAR                       szDomain[ MAX_STRING_LENGTH ];
    TCHAR                       szFQDN[ MAX_STRING_LENGTH ];
    TCHAR                       szAdsiBuffer[ MAX_STRING_LENGTH ];

    CHString                    strTemp = NULL_STRING;
    CHString                    strDisplay = NULL_STRING;

    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemServices               *pRsopNameSpace = NULL;
    IWbemClassObject            *pUserClass =  NULL;
    IWbemClassObject            *pInInst = NULL;
    IWbemClassObject            *pOutInst = NULL;

    ULONG                       ulReturn = 0;
    LONG                        lCount = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    DWORD                       dwName = MAX_STRING_LENGTH;
    DWORD                       dwDomain = MAX_STRING_LENGTH;
    DWORD                       dwBufSize = MAX_STRING_LENGTH;

    USERINFO                    *pUserInfo = new USERINFO;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    SAFEARRAY                   *safeArray = NULL;

    PSID                        pSid = NULL;
    SID_NAME_USE                *pSidNameUse = new SID_NAME_USE;


    try
    {
        // set the strings to NULL
        SecureZeroMemory( szTemp, MAX_STRING_LENGTH * sizeof( TCHAR ) );
        SecureZeroMemory( szName, MAX_STRING_LENGTH * sizeof( TCHAR ) );
        SecureZeroMemory( szServer, MAX_STRING_LENGTH * sizeof( TCHAR ) );
        SecureZeroMemory( szDomain, MAX_STRING_LENGTH * sizeof( TCHAR ) );
        SecureZeroMemory( szFQDN, MAX_STRING_LENGTH * sizeof( TCHAR ) );

        PrintProgressMsg( m_hOutput, GetResString( IDS_CONNECT_RSOP ), m_csbi );

        // connect to the RSOP namespace
        ConnectWmi( m_pWbemLocator, &pRsopNameSpace, m_strServerName,
                    m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                    FALSE, _bstr_t( ROOT_RSOP ), &hResult );
        CHECK_HRESULT( hResult );

        // Get the object for the RSOP diagnostic mode provider
        hResult = pRsopNameSpace->GetObject( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ),
                                                0, NULL, &pUserClass, NULL );
        CHECK_HRESULT( hResult );

        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_METHOD ), m_csbi );

        // get the reqd. method....to enumerate the users
        hResult = pUserClass->GetMethod( _bstr_t( FN_ENUM_USERS ), 0, &pInInst, NULL );
        CHECK_HRESULT( hResult );

        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_SID ), m_csbi );

        // Execute method RSopEnumerateUsers
        hResult = pRsopNameSpace->ExecMethod( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ),
                                                _bstr_t( FN_ENUM_USERS ),
                                                0, NULL, pInInst, &pOutInst, NULL);
        if( pOutInst == NULL )
        {
            hResult = E_FAIL;
        }
        if( FAILED( hResult ) )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopNameSpace );
            SAFEIRELEASE( pUserClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pEnumClass );

            SAFE_DELETE( pUserInfo );
            SAFE_DELETE( pSidNameUse );

            return FALSE;
        }

        // Get the result value...
        bResult = PropertyGet( pOutInst, FPR_RETURN_VALUE, ulReturn, 0 );
        CHECK_BRESULT( bResult );

        if( ulReturn != 0 )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopNameSpace );
            SAFEIRELEASE( pUserClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pEnumClass );

            SAFE_DELETE( pUserInfo );
            SAFE_DELETE( pSidNameUse );

            return FALSE;
        }

        VariantInit( &vVarVerbose );
        pOutInst->Get( _bstr_t( CPV_USER_SIDS ), 0, &vVarVerbose, 0, 0 );
        CHECK_HRESULT_VAR( hResult, vVarVerbose );
        if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
        {
            // get the type of the elements in the safe array
            vartype = (VARTYPE)(V_VT( &vVarVerbose ) & ~VT_ARRAY);

            //get the array of strings in to the safe array from the variant
            safeArray = (SAFEARRAY *)vVarVerbose.parray;

            //get the number of elements (subkeys)
            if( safeArray != NULL )
            {
                hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                CHECK_HRESULT( hResult );

                hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                CHECK_HRESULT( hResult );
                if( lUBound == 0xffffffff )
                {
                    // erase the last status message
                    PrintProgressMsg( m_hOutput, NULL, m_csbi );

                    ShowMessage( stdout, GetResString( IDS_INFO) );
                    ShowMessageEx( stdout, 1, TRUE, GetResString( IDS_USER_NO_RSOP1) );

                    // release the interface pointers and exit
                    SAFEIRELEASE( pRsopNameSpace );
                    SAFEIRELEASE( pUserClass );
                    SAFEIRELEASE( pInInst );
                    SAFEIRELEASE( pOutInst );
                    SAFEIRELEASE( pEnumClass );

                    SAFE_DELETE( pUserInfo );
                    SAFE_DELETE( pSidNameUse );

                    return TRUE;
                }
            }

            // If we have to get the information from a remote machine then...
            // connect to the remote machine.
            if ( m_bLocalSystem == FALSE )
            {
                StringCopy( szServer, m_strServerName, MAX_STRING_LENGTH );
                StringCopy( szName, m_strUserName, MAX_STRING_LENGTH );

                // erase the last status message
                PrintProgressMsg( m_hOutput, NULL, m_csbi );

                bResult = EstablishConnection( szServer, szName, MAX_STRING_LENGTH,
                                                m_pwszPassword, MAX_STRING_LENGTH, FALSE );
                if( bResult != TRUE )
                {
                    // erase the last status message
                    PrintProgressMsg( m_hOutput, NULL, m_csbi );

                    ShowMessage( stderr, GetResString( IDS_ERROR ) );
                    ShowMessage( stderr, GetReason() );

                    // release the interface pointers and exit
                    SAFEIRELEASE( pRsopNameSpace );
                    SAFEIRELEASE( pUserClass );
                    SAFEIRELEASE( pInInst );
                    SAFEIRELEASE( pOutInst );
                    SAFEIRELEASE( pEnumClass );

                    SAFE_DELETE( pUserInfo );
                    SAFE_DELETE( pSidNameUse );

                    return FALSE;
                }
                else
                {
                    switch( GetLastError() )
                    {
                        case I_NO_CLOSE_CONNECTION:
                            bConnFlag = FALSE;
                            break;

                        case E_LOCAL_CREDENTIALS:
                        case ERROR_SESSION_CREDENTIAL_CONFLICT:
                            bConnFlag = FALSE;
                            break;

                        default:
                            break;
                    }
                }

                // Get the new output co-ordinates
                if ( m_hOutput != NULL )
                {
                    GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
                }
            }

            for( lCount = lLBound ; lLBound <= lUBound; lLBound++ )
            {
                bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                CHECK_BRESULT( bResult );

                // Got the SID...save it in the structure
                pUserInfo->strUserSid = strTemp;

                PrintProgressMsg( m_hOutput, GetResString( IDS_GET_NAME ), m_csbi );

                // Get the User Name
                StringCopy( szTemp, strTemp, MAX_STRING_LENGTH );
                ConvertStringSidToSid( szTemp, &pSid );

                // Get the user name for the SID we have got
                bResult = LookupAccountSid( szServer, pSid, szName, &dwName, szDomain,
                                            &dwDomain, pSidNameUse );
                if( bResult == 0 )
                {
                    // Could not get the name from the API try to retrieve it from WMI
                    bResult = GetUserNameFromWMI( szTemp, szName, szDomain );
                    PrintProgressMsg( m_hOutput, NULL, m_csbi );
                    if( bResult == FALSE )
                    {
                        // Increment the count
                        lCount++;

                        // If the user was not found then display a message stating the same
                        if( lCount > lUBound )
                        {
                            strTemp = L"";
                            if( bAllUsers == FALSE )
                            {
                                // check if we need to append the domain name
                                if ( m_strDomainName.GetLength() != 0 )
                                {
                                    strTemp = m_strDomainName + _T( "\\" ) + m_strUser;
                                }
                                else
                                {
                                    strTemp = m_strUser;
                                }
                            }

                            // Form the display string
                            strDisplay.Format( GetResString( IDS_USER_NO_RSOP ), _X( strTemp ) );

                            ShowMessage( stdout, GetResString( IDS_INFO ) );
                            ShowMessage( stdout, strDisplay );
                        }

                        // could not get a name for this SID, so continue with the next SID.
                        continue;
                    }
                }

                // Free the pSid
                if( pSid != NULL )
                {
                    LocalFree( pSid );
                    pSid = NULL;
                }

                // Check wether the Rsop data has to be retrieved for this user name.
                if( bAllUsers == FALSE )
                {
                    if( StringCompare( szName, m_strUser, TRUE, 0 ) != 0
                        || ( StringCompare( szDomain, m_strDomainName, TRUE, 0 ) != 0
                                && m_strDomainName.GetLength() != 0 ) )
                    {
                        // erase the last status message
                        PrintProgressMsg( m_hOutput, NULL, m_csbi );

                        // re-set the buffer sizes
                        dwName = MAX_STRING_LENGTH;
                        dwDomain = MAX_STRING_LENGTH;

                        // Increment the count
                        lCount++;

                        // If the user was not found then display a message stating the same
                        if( lCount > lUBound )
                        {
                            // check if we need to append the domain name
                            if ( m_strDomainName.GetLength() != 0 )
                            {
                                strTemp = m_strDomainName + _T( "\\" ) + m_strUser;
                            }
                            else
                            {
                                strTemp = m_strUser;
                            }

                            // Form the display string
                            strDisplay.Format( GetResString( IDS_USER_NO_RSOP ), _X( strTemp ) );

                            ShowMessage( stdout, GetResString( IDS_INFO ) );
                            ShowMessage( stdout, strDisplay );
                        }

                        // No need to get the data for this user
                        continue;
                    }
                }

                // Store the user name into the structure.
                pUserInfo->strUserName = szName;

                // Append the domain name to the user name.
                StringConcat( szDomain, TEXT_BACKSLASH, MAX_STRING_LENGTH );
                StringConcat( szDomain, pUserInfo->strUserName, MAX_STRING_LENGTH );
                pUserInfo->strUserName = szDomain;

                PrintProgressMsg( m_hOutput, GetResString( IDS_GET_PROFILE ), m_csbi );

                // Get the user profile information
                if( GetUserProfile( pUserInfo ) == FALSE )
                {
                    // erase the last status message
                    PrintProgressMsg( m_hOutput, NULL, m_csbi );

                    // Display the error message
                    ShowMessage( stderr, GetResString( IDS_ERROR ) );
                    ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

                    // release the interface pointers and exit
                    SAFEIRELEASE( pRsopNameSpace );
                    SAFEIRELEASE( pUserClass );
                    SAFEIRELEASE( pInInst );
                    SAFEIRELEASE( pOutInst );
                    SAFEIRELEASE( pEnumClass );

                    SAFE_DELETE( pUserInfo );
                    SAFE_DELETE( pSidNameUse );

                    // if we have opened a connection then close the same.
                    if( m_bLocalSystem == FALSE  && bConnFlag == TRUE )
                    {
                        StringCopy( szServer, m_strServerName, MAX_STRING_LENGTH );
                        CloseConnection( szServer );
                    }

                    return FALSE;
                }

                if( bGotDomainInfo == FALSE )
                {
                    PrintProgressMsg( m_hOutput, GetResString( IDS_GET_COMMON ), m_csbi );

                    // Get the domain name and other related information
                    if( GetDomainInfo( pUserInfo ) == FALSE )
                    {
                        // erase the last status message
                        PrintProgressMsg( m_hOutput, NULL, m_csbi );

                        // Display the error message
                        ShowMessage( stderr, GetResString( IDS_ERROR ) );
                        ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

                        // release the interface pointers and exit
                        SAFEIRELEASE( pRsopNameSpace );
                        SAFEIRELEASE( pUserClass );
                        SAFEIRELEASE( pInInst );
                        SAFEIRELEASE( pOutInst );
                        SAFEIRELEASE( pEnumClass );

                        SAFE_DELETE( pUserInfo );
                        SAFE_DELETE( pSidNameUse );

                        // if we have opened a connection then close the same.
                        if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
                        {
                            StringCopy( szServer, m_strServerName, MAX_STRING_LENGTH );
                            CloseConnection( szServer );
                        }

                        return FALSE;
                    }

                    // Get the OS information
                    if( GetOsInfo( pUserInfo ) == FALSE )
                    {
                        // erase the last status message
                        PrintProgressMsg( m_hOutput, NULL, m_csbi );

                        // Display the error message
                        ShowMessage( stderr, GetResString( IDS_ERROR ) );
                        ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

                        // release the interface pointers and exit
                        SAFEIRELEASE( pRsopNameSpace );
                        SAFEIRELEASE( pUserClass );
                        SAFEIRELEASE( pInInst );
                        SAFEIRELEASE( pOutInst );
                        SAFEIRELEASE( pEnumClass );

                        SAFE_DELETE( pUserInfo );
                        SAFE_DELETE( pSidNameUse );

                        // if we have opened a connection then close the same.
                        if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
                        {
                            StringCopy( szServer, m_strServerName, MAX_STRING_LENGTH );
                            CloseConnection( szServer );
                        }

                        return FALSE;
                    }

                    // Get the FQDN of the computer
                    // PrintProgressMsg( m_hOutput, GetResString( IDS_GET_FQDN ), m_csbi );

                    if( m_bLocalSystem == TRUE )
                    {
                        // we have to get the FQDN for the local system
                        // use the GetComputerObjectName API
                        ulReturn = MAX_STRING_LENGTH;
                        GetComputerObjectName( NameFullyQualifiedDN, szFQDN, &ulReturn);
                    }
                    else
                    {
                        // Get the local computers domain name
                        GetComputerNameEx( ComputerNameDnsDomain, szAdsiBuffer, &dwBufSize );

                        StringCopy( szServer, m_strADSIServer, MAX_STRING_LENGTH );
                        StringConcat( szServer, TEXT_DOLLAR, MAX_STRING_LENGTH );

                        // Check if the machine we are querying is in the same domain
                        if( m_strADSIDomain.CompareNoCase( szAdsiBuffer ) == 0 )
                        {
                            // get the FQDN from the Translate name call
                            dwBufSize = MAX_STRING_LENGTH;
                            TranslateName( szServer, NameDisplay, NameFullyQualifiedDN,
                                            szFQDN, &dwBufSize );
                        }
                        else
                        {
                            // Get the FQDN from ADSI directory services
                            GetFQDNFromADSI( szFQDN, TRUE, szServer );
                        }
                    }

                    // Store the FQDN into the structure.
                    pUserInfo->strComputerFQDN = szFQDN;

                    // Set the flag to TRUE so that this code is not executed again and again
                    bGotDomainInfo = TRUE;
                }

                // Get the FQDN of the user
                if( ( m_bLocalSystem == TRUE )
                        || ( m_strADSIDomain.CompareNoCase( szAdsiBuffer ) == 0 ) )
                {
                    SecureZeroMemory( szFQDN, MAX_STRING_LENGTH * sizeof( TCHAR ) );
                    dwBufSize = MAX_STRING_LENGTH;
                    StringCopy( szName, pUserInfo->strUserName, MAX_STRING_LENGTH );

                    // get the FQDN from the Translate name call
                    TranslateName( szName, NameSamCompatible, NameFullyQualifiedDN,
                                    szFQDN, &dwBufSize );
                }
                else
                {
                    // Get the FQDN from ADSI directory services
                    StringCopy( szName, pUserInfo->strUserName, MAX_STRING_LENGTH );
                    GetFQDNFromADSI( szFQDN, FALSE, szName );
                }

                // Store the FQDN into the structure.
                pUserInfo->strUserFQDN = szFQDN;

                //get the terminal server mode
                GetTerminalServerMode(pUserInfo);

                // Now display the data
                PrintProgressMsg( m_hOutput, GetResString( IDS_STARTED_RETRIEVAL ), m_csbi );
                if( FALSE == DisplayData( pUserInfo, pRsopNameSpace ) )
                {
                    // release the interface pointers and exit
                    SAFEIRELEASE( pRsopNameSpace );
                    SAFEIRELEASE( pUserClass );
                    SAFEIRELEASE( pInInst );
                    SAFEIRELEASE( pOutInst );
                    SAFEIRELEASE( pEnumClass );
                    SAFE_DELETE( pUserInfo );
                    SAFE_DELETE( pSidNameUse );
                    return FALSE;
                }

                // Get the new output co-ordinates
                if ( m_hOutput != NULL )
                {
                    GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
                }

                // re-set the buffers and their sizes
                SecureZeroMemory( szTemp, MAX_STRING_LENGTH * sizeof( TCHAR ) );
                SecureZeroMemory( szName, MAX_STRING_LENGTH * sizeof( TCHAR ) );
                SecureZeroMemory( szServer, MAX_STRING_LENGTH * sizeof( TCHAR ) );
                SecureZeroMemory( szDomain, MAX_STRING_LENGTH * sizeof( TCHAR ) );

                dwName = MAX_STRING_LENGTH;
                dwDomain = MAX_STRING_LENGTH;
            }// for

            // if we have opened a connection then close the same.
            if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
            {
                StringCopy( szServer, m_strServerName, MAX_STRING_LENGTH );
                CloseConnection( szServer );
            }
        }
        else
        {
            // No classes were retrieved....display msg
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            // check if we need to append the domain name
            if ( m_strDomainName.GetLength() != 0 )
            {
                strTemp = m_strDomainName + _T( "\\" ) + m_strUser;
            }
            else
            {
                strTemp = m_strUser;
            }

            // Form the display string
            strDisplay.Format( GetResString( IDS_USER_NO_RSOP ), _X( strTemp ) );

            ShowMessage( stdout, GetResString( IDS_INFO ) );
            ShowMessage( stdout, strDisplay );
        }

        VariantClear(&vVarVerbose);
    }
    catch(  _com_error & error )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        // display the error msg
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the interface pointers and exit
        SAFEIRELEASE( pRsopNameSpace );
        SAFEIRELEASE( pUserClass );
        SAFEIRELEASE( pInInst );
        SAFEIRELEASE( pOutInst );
        SAFEIRELEASE( pEnumClass );

        SAFE_DELETE( pUserInfo );
        SAFE_DELETE( pSidNameUse );

        VariantClear(&vVarVerbose);

        return FALSE;
    }

    // release the interface pointers and exit
    SAFEIRELEASE( pRsopNameSpace );
    SAFEIRELEASE( pUserClass );
    SAFEIRELEASE( pInInst );
    SAFEIRELEASE( pOutInst );
    SAFEIRELEASE( pEnumClass );
 
    SAFE_DELETE( pUserInfo );
    SAFE_DELETE( pSidNameUse );
    
    VariantClear(&vVarVerbose);

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the user profile data and fills the array with the same

Arguments:

    [in] PUSERINFO      pUserInfo       :   Structure containing the user information.

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetUserProfile( PUSERINFO pUserInfo )
{
    // Local variables
    HRESULT                 hResult = S_OK;

    IWbemServices           *pDefaultNameSpace = NULL;

    TCHAR                   szTemp[ MAX_STRING_LENGTH ];

    try
    {
        // connect to the default namespace
        ConnectWmi( m_pWbemLocator, &pDefaultNameSpace, m_strServerName,
                    m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                    FALSE, _bstr_t( ROOT_DEFAULT ), &hResult );
        CHECK_HRESULT( hResult );

        // Set the sub key name
        StringCopy( szTemp, PATH, MAX_STRING_LENGTH );
        StringConcat( szTemp, pUserInfo->strUserSid, MAX_STRING_LENGTH );

        // Get the local profile
        RegQueryValueWMI( pDefaultNameSpace, HKEY_DEF, szTemp, FPR_LOCAL_VALUE,
                            pUserInfo->strLocalProfile, V_NOT_AVAILABLE );

        // Get the roaming profile
        RegQueryValueWMI( pDefaultNameSpace, HKEY_DEF, szTemp, FPR_ROAMING_VALUE,
                            pUserInfo->strRoamingProfile, V_NOT_AVAILABLE );
    }
    catch(  _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the allocated variables
        SAFEIRELEASE( pDefaultNameSpace );

        return FALSE;
    }

    // release the interface pointer
    SAFEIRELEASE( pDefaultNameSpace );

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the domain information and fills the array with the same

Arguments:

    [in] PUSERINFO      pUserInfo       :   Structure containing the user information.

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetDomainInfo( PUSERINFO pUserInfo )
{
    // Local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bDone = FALSE;

    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemClassObject            *pClass = NULL;

    ULONG                       ulReturn = 0;

    CHString                    strTemp;
    PSID                        psid = NULL;
    SID_NAME_USE                sidNameUse;
    WCHAR                       szTemp[MAX_RES_STRING]=NULL_STRING;
    DWORD                       dwSize=MAX_RES_STRING;
    DWORD                       dwSidSize=0;


    try
    {
        // print the progress message
        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_DOMAIN ), m_csbi );

        // Enumerate the instances to get the domain and site names of the Win32 NT domain
        hResult = m_pWbemServices->CreateInstanceEnum( _bstr_t( CLS_WIN32_SITE ),
                                                        WBEM_FLAG_FORWARD_ONLY |
                                                        WBEM_FLAG_RETURN_IMMEDIATELY,
                                                        NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // get the data
        //   since there may be more than one instance and we are looking for the instance
        //   with the domain controller and site name.....using a while loop and as soon as
        //   we get the instance we need break out of it
        hResult = WBEM_S_NO_ERROR;
        while( hResult == WBEM_S_NO_ERROR )
        {
            hResult = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &ulReturn );
            CHECK_HRESULT( hResult );

            if( ulReturn == 0 )
            {
                // no more data so break out of the loop
                break;
            }

            // get the server name
            if( bDone == FALSE )
            {
                bDone = TRUE;
                bResult = PropertyGet( pClass, CPV_GPO_SERVER, pUserInfo->strUserServer,
                                        V_NOT_AVAILABLE );
                CHECK_BRESULT( bResult );
            }

            // get the domain name
            bResult = PropertyGet( pClass, CPV_GPO_NAME, pUserInfo->strComputerDomain,
                                    V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            PrintProgressMsg( m_hOutput, GetResString( IDS_GET_SITE ), m_csbi );

            // get the site name
            bResult = PropertyGet( pClass, CPV_SITE_NAME, pUserInfo->strUserSite,
                                    V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            // get the domain controller name
            bResult = PropertyGet( pClass, CPV_DC_NAME, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            if( StringCompare( strTemp, V_NOT_AVAILABLE, FALSE, 0 ) != 0 )
            {
                // this enumeration has the domain controller name...
                //   we have got the enumeration we need so get the other data
                break;
            }
        }// while

/************this code is added to get the user domain on 19-oct-2001 **************/
		psid = NULL;
		dwSidSize = 0;
		
		// get the actual size of SID
        if ( FALSE == LookupAccountName( m_strServerName, pUserInfo->strUserName, psid, &dwSidSize, szTemp, &dwSize, &sidNameUse ) )
		{
			if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
			{
				SaveLastError();
				ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                SAFEIRELEASE( pClass );
                SAFEIRELEASE( pEnumClass );
				return FALSE;
			}
		}

		//Allocate memory for SID with the actual size of dwSidSize
		psid = (PSID) AllocateMemory( dwSidSize );
		if( NULL == psid )
		{
            SaveLastError();
			ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pEnumClass );
			return FALSE;
		}

		// Get the account name
		if( FALSE == LookupAccountName( m_strServerName, pUserInfo->strUserName, psid, &dwSidSize, szTemp, &dwSize, &sidNameUse ) )
        {
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR) );
            DISPLAY_MESSAGE( stderr, GetReason() );
			FreeMemory((LPVOID*) &psid);
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pEnumClass );
            return FALSE;
        }

        pUserInfo->strUserDomain = szTemp;

		//release memory
		FreeMemory((LPVOID*) &psid);

/**********************************************************************************/


    } //try
    catch(  _com_error & error )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        //release memory
	    FreeMemory((LPVOID*) &psid);

		// release the allocated variables
        SAFEIRELEASE( pEnumClass );
        SAFEIRELEASE( pClass );

        return FALSE;
    }

    // release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

	return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function returns the domain type

Arguments:

    [in]  lpDomainName     : domain name intends to view Rsop data.
    [out] pbW2K            : contain whether the domain type in W2K.
    [out] pbLocalAccount   : contain whether the account is local.

Return Value:

    TRUE  - if DC found/domain name is computer name
    FALSE - if DC not found
*********************************************************************************************/
BOOL GetDomainType( LPTSTR lpszDomainName, BOOL * pbW2K, BOOL *pbLocalAccount )
{
    PDOMAIN_CONTROLLER_INFO         pDCI;

    DWORD                           dwResult = 0;
    DWORD                           dwSize = 0;

    TCHAR                           szComputerName[ MAX_PATH ];

    // Check the incoming pointers
    if( lpszDomainName == NULL || pbW2K == NULL || pbLocalAccount == NULL )
    {
        return FALSE;
    }

    // Check this domain for a Domain Controller
    dwResult = DsGetDcName( NULL, lpszDomainName, NULL, NULL,
                            DS_DIRECTORY_SERVICE_PREFERRED, &pDCI );
    if ( dwResult == NO_ERROR )
    {
        // Found a DC, does it have a DS ?
        if ( pDCI->Flags & DS_DS_FLAG )
        {
            *pbW2K = TRUE;
        }

        NetApiBufferFree( pDCI );

        return TRUE;
    }

    // Check if the domain name is also the computer name (eg: local account)
    dwSize = ARRAYSIZE( szComputerName );
    if ( GetComputerName ( szComputerName, &dwSize )  != 0 )
    {
        if ( StringCompare( szComputerName, lpszDomainName, TRUE, 0 ) == 0 )
        {
            *pbLocalAccount = TRUE;
            return TRUE;
        }
    }

    return FALSE;
}

/*********************************************************************************************
Routine Description:

    This function displays the data common to both scopes

Arguments:

    [in] PUSERINFO      pUserInfo       :   Structure containing the user information.

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::DisplayCommonData( PUSERINFO pUserInfo )
{
    // Local variables
    TCHAR                   szMsgBuffer[ MAX_RES_STRING ];
    TCHAR                   szDate[ MAX_RES_STRING ];
    TCHAR                   szTime[ MAX_RES_STRING ];

    BOOL                    bLocaleChanged = FALSE;

    DWORD                   dwLength = 0;

    SYSTEMTIME              systime;

    LCID                    lcid;

    // erase the last status message
    PrintProgressMsg( m_hOutput, NULL, m_csbi );

    // Clear the Msg buffer
    SecureZeroMemory( szMsgBuffer, MAX_RES_STRING );

    // Start displaying the output
    ShowMessage( stdout, NEW_LINE );

    // Print the leagal information
    ShowMessage( stdout, GetResString( IDS_LEGAL_INFO1 ) );
    ShowMessage( stdout, GetResString( IDS_LEGAL_INFO2 ) );

    // Print the date and time this report is generated
    GetLocalTime( &systime );

    // verify whether console supports the current locale 100% or not
    lcid = GetSupportedUserLocale( &bLocaleChanged );

    // get the formatted date
    GetDateFormat( lcid, 0, &systime, ((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL),
                    szDate, SIZE_OF_ARRAY( szDate ) );

    // now format the date
    GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systime, ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL),
                    szTime, SIZE_OF_ARRAY( szTime ) );

    ShowMessageEx( stdout, 2, TRUE,  GetResString( IDS_CREATED_ON ), _X(szDate), _X1(szTime) );

    ShowMessage( stdout, NEW_LINE );

    // Display the common information....Domain Info
    ShowMessageEx( stdout, 2, TRUE,  GetResString( IDS_GPO_TITLE ), _X( pUserInfo->strUserName ), _X2( pUserInfo->strUserServer ) );
    ShowMessage( stdout, NEW_LINE );

    StringCchPrintf( szMsgBuffer, SIZE_OF_ARRAY( szMsgBuffer ), GetResString( IDS_GPO_TITLE ), _X( pUserInfo->strUserName ), _X2( pUserInfo->strUserServer ) );

    // Underline the above heading
    dwLength = StringLengthInBytes( szMsgBuffer );
    for( ; dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    ShowMessage( stdout, NEW_LINE );

    StringCopy( szMsgBuffer, pUserInfo->strComputerDomain, MAX_RES_STRING );
    if( StringLengthW( szMsgBuffer, 0 ) != 0 )
    {
        StringCopy( szMsgBuffer, _tcstok( szMsgBuffer, GetResString( IDS_LAST_CHAR ) ), MAX_RES_STRING );
        StringCopy( szMsgBuffer, _tcstok( NULL, GetResString( IDS_LAST_CHAR ) ), MAX_RES_STRING );
    }

    // Show the OS information
    ShowMessage( stdout, GetResString( IDS_OS_TYPE ) );
    ShowMessage( stdout, pUserInfo->strOsType );

    ShowMessage( stdout, GetResString( IDS_OS_CONFIG ) );
    ShowMessage( stdout, pUserInfo->strOsConfig );

    ShowMessage( stdout, GetResString( IDS_OS_VERSION ) );
    ShowMessage( stdout, pUserInfo->strOsVersion );


// This code is added on 4-sep-2001 to display Terminal server mode
    ShowMessage( stdout, NEW_LINE );
    ShowMessage( stdout, GetResString( IDS_TERMINAL_SERVER_MODE ) );
    ShowMessage( stdout, pUserInfo->strTerminalServerMode );

    // Display the Site name
    ShowMessage( stdout, NEW_LINE );
    ShowMessage( stdout, GetResString( IDS_SITE_NAME ) );
    ShowMessage( stdout, pUserInfo->strUserSite );

    // Display the roaming profile
    ShowMessage( stdout, NEW_LINE );
    ShowMessage( stdout, GetResString( IDS_ROAMING_PROFILE ) );
    ShowMessage( stdout, pUserInfo->strRoamingProfile );

    // Display the local profile
    ShowMessage( stdout, NEW_LINE );
    ShowMessage( stdout, GetResString( IDS_LOCAL_PROFILE ) );
    DISPLAY_MESSAGE( stdout, _X((LPCWSTR)pUserInfo->strLocalProfile) );
    ShowMessage( stdout, NEW_LINE );

    return TRUE;
}

/*********************************************************************************************
Routine Description:
    This function displays the GPO information from the rsop namespace created.

Arguments:

    [in] IEnumWbemClassObject   :   pointer to the Enumeration class object
    [in] LPCTSTR                :   string containing the scope( USER or COMPUTER )

Return Value:

    TRUE  - if SUCCESS
    FALSE - if ERROR
*********************************************************************************************/
BOOL CGpResult::GpoDisplay( IWbemServices *pNameSpace, LPCTSTR pszScopeName )
{
    HRESULT                 hResult = WBEM_S_NO_ERROR;

    BOOL                    bResult = FALSE;
    BOOL                    bFilterAllowed = FALSE;
    BOOL                    bLinkEnabled = FALSE;
    BOOL                    bGpoEnabled = FALSE;
    BOOL                    bAccessDenied = FALSE;
    BOOL                    bConnected = FALSE;

    ULONG                   ulReturn = 0;
    ULONG                   ulAppliedOrder = 0;
    ULONG                   ulVersion = 0;

    DWORD                   dwAppliedRow = 0;
    DWORD                   dwFilteredRow = 0;

    CHString                strTemp;

    IEnumWbemClassObject    *pRsopLinkClass = NULL;
    IWbemClassObject        *pRsopLinkObj = NULL;
    IWbemClassObject        *pRsopObj = NULL;
    IWbemClassObject        *pSomFilter = NULL;

    IWbemServices           *pPolicyNameSpace = NULL;

    TARRAY                  arrAppliedData = NULL;
    TARRAY                  arrFilteredData = NULL;
    BOOL                    bNobreak        = TRUE;

    try
    {
        if( pNameSpace == NULL || pszScopeName == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // Create the Dynamic Arrays
        arrAppliedData = CreateDynamicArray( );
        arrFilteredData = CreateDynamicArray( );

        // Check the memory allocations
        if( arrAppliedData == NULL || arrFilteredData == NULL )
        {
            _com_issue_error( E_OUTOFMEMORY );
        }

        // enumerate the instances of the RSOP GPLink class
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_RSOP_GPOLINK ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY,
                                                    NULL, &pRsopLinkClass );
        CHECK_HRESULT( hResult );

        // set the interface security
        hResult = SetInterfaceSecurity( pRsopLinkClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // Get the information from the enumerated classes
        do   
        {
            // Get the pointer to the next class
            hResult = pRsopLinkClass->Next( WBEM_INFINITE, 1, &pRsopLinkObj, &ulReturn );
            CHECK_HRESULT( hResult );
            if( ulReturn == 0 )
            {
                bNobreak = FALSE;
                break;
            }

            // Get the applied order for the link
            bResult = PropertyGet( pRsopLinkObj, CPV_APPLIED_ORDER, ulAppliedOrder, 0 );
            CHECK_BRESULT( bResult );

            // Get the link enabled property
            bResult = PropertyGet( pRsopLinkObj, CPV_ENABLED, bLinkEnabled, FALSE );
            CHECK_BRESULT( bResult );

            // Get the reference to the GPO class
            bResult = PropertyGet( pRsopLinkObj, CPV_GPO_REF, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            // Check wether the link has a GPO class
            if( strTemp.Find( GPO_REFERENCE ) != VAR_TRUE )
            {
                // Get the object for the GPO reference got
                hResult = pNameSpace->GetObject( _bstr_t( strTemp ), 0, NULL, &pRsopObj, NULL );
                if( FAILED( hResult ) )
                {
                    if( hResult == WBEM_E_NOT_FOUND )
                    {
                        continue;
                    }
                    _com_issue_error( hResult );
                }

                // Get the GPO name
                bResult = PropertyGet( pRsopObj, CPV_GPO_NAME, strTemp, V_NOT_AVAILABLE );
                CHECK_BRESULT( bResult );

                // Get the WMI filter status
                bResult = PropertyGet( pRsopObj, CPV_GPO_FILTER_STATUS, bFilterAllowed, FALSE );
                CHECK_BRESULT( bResult );

                // Get the Gpo enabled information
                bResult = PropertyGet( pRsopObj, CPV_ENABLED, bGpoEnabled, FALSE );
                CHECK_BRESULT( bResult );

                // Get the access denied information
                bResult = PropertyGet( pRsopObj, CPV_ACCESS_DENIED, bAccessDenied, FALSE );
                CHECK_BRESULT( bResult );

                // Get the version
                bResult = PropertyGet( pRsopObj, CPV_VERSION, ulVersion, 0 );
                CHECK_BRESULT( bResult );

                // If the applied order id not zero then this GPO is applied
                if( ulAppliedOrder > 0 )
                {
                    // Populate the applied Gpo array
                    DynArrayAppendRow( arrAppliedData, COL_MAX );
                    DynArraySetString2( arrAppliedData, dwAppliedRow, COL_DATA, strTemp, 0 );
                    DynArraySetDWORD2( arrAppliedData, dwAppliedRow, COL_ORDER, ulAppliedOrder );
                    dwAppliedRow++;
                }
                else if( bLinkEnabled != VAR_TRUE )
                {
                    // if the link is disabled...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER,
                                        GetResString( IDS_LINK_DISABLED ), 0 );
                    dwFilteredRow++;
                }
                else if( bGpoEnabled != VAR_TRUE )
                {
                    // if the GPO is disabled...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER,
                                        GetResString( IDS_GPO_DISABLED ), 0 );
                    dwFilteredRow++;
                }
                else if( bAccessDenied == VAR_TRUE )
                {
                    // if the access is denied...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER,
                                        GetResString( IDS_ACCESS_DENIED ), 0 );
                    dwFilteredRow++;
                }
                else if( bFilterAllowed != VAR_TRUE )
                {
                    // if the filter status is false...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX_FILTER );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER,
                                        GetResString( IDS_WMI_DENIED ), 0 );

                    // Get the filter ID
                    bResult = PropertyGet( pRsopObj, CPV_GPO_FILTER_ID, strTemp, V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    // Store it in the array
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER_ID, strTemp, 0 );

                    dwFilteredRow++;
                }
                else if( ulVersion == 0 )
                {
                    // if the version is zero...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER,
                                        GetResString( IDS_VERSION_ZERO ), 0 );
                    dwFilteredRow++;
                }
                else
                {
                    // the Gpo is not applied due to an unknown reason...
                    // populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER,
                                        GetResString( IDS_NOT_APPLIED ), 0 );
                    dwFilteredRow++;
                }
            }

        }while( TRUE == bNobreak );// while

        // Got the data...sort it
        SortAppliedData( arrAppliedData );

        // Display the applied data first
        dwAppliedRow = DynArrayGetCount( arrAppliedData );
        for( DWORD dwi = 0; dwi < dwAppliedRow; dwi++ )
        {
            ShowMessage( stdout, TAB_TWO );
            ShowMessage( stdout, DynArrayItemAsString2( arrAppliedData, dwi, COL_DATA ) );
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }

        // Check if there was any data displayed
        if( dwAppliedRow <= 0 )
        {
            ShowMessage( stdout, TAB_TWO );
            ShowMessage( stdout, V_NOT_AVAILABLE );
            ShowMessage( stdout, NEW_LINE );
        }

        // Display the filtered GPOs
        // Display the header...if there are any GPO's filtered out
        dwFilteredRow = DynArrayGetCount( arrFilteredData );
        if( dwFilteredRow > 0 )
        {
            ShowMessage( stdout, GetResString( IDS_GPO_FILTERED ) );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
            for( dwi = StringLengthInBytes( GetResString( IDS_GPO_FILTERED ) ); dwi > 4; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }
        else
        {
            // There are no filtered GPO's hence put a new line and continue
            // displaying the rest of the output
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }

        // display the data
        for( DWORD dwi = 0; dwi < dwFilteredRow; dwi++ )
        {
            ShowMessage( stdout, TAB_TWO );
            ShowMessage( stdout, DynArrayItemAsString2( arrFilteredData, dwi, COL_DATA ) );
            ShowMessage( stdout, GetResString( IDS_FILTERING ) );
            ShowMessage( stdout, DynArrayItemAsString2( arrFilteredData, dwi, COL_FILTER ) );

            // Check if we have to display the filter id for the WMI filter that evaluated to false
            if( StringCompare( DynArrayItemAsString2( arrFilteredData, dwi, COL_FILTER ),
                            GetResString( IDS_WMI_DENIED ), TRUE, 0 ) == 0 )
            {
                if( bConnected == FALSE )
                {
                    // we need to connect to Root\Policy
                    // connect to the default namespace
                    ConnectWmi( m_pWbemLocator, &pPolicyNameSpace, m_strServerName,
                                m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                                FALSE, _bstr_t( ROOT_POLICY ), &hResult );
                    CHECK_HRESULT( hResult );

                    bConnected = TRUE;
                }

                // Get the object
                hResult = pPolicyNameSpace->GetObject( _bstr_t( DynArrayItemAsString2(
                                                        arrFilteredData, dwi, COL_FILTER_ID ) ),
                                                        0, NULL, &pSomFilter, NULL );

                // check whether we got the object or not -- if at all error occured
                // ignore this and proceed
                if ( FAILED( hResult ) )
                {
                    if ( WBEM_E_NOT_FOUND == hResult )
                    {
                        // ignore this error -- proceed with the normal logic flow
                    }

                    // still ignore this error -- currently we are not trapping this error too
                }
                else
                {
                    // Get the name of the filter applied
                    bResult = PropertyGet( pSomFilter, CPV_NAME, strTemp, V_NOT_AVAILABLE );

                    // display the filter ID
                    ShowMessage( stdout, GetResString( IDS_GPO_FILTER_ID ) );
                    ShowMessage( stdout, strTemp );
                    ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
                }
            }

            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }

        // destroy the dynamic arrays
        DESTROY_ARRAY( arrAppliedData );
        DESTROY_ARRAY( arrFilteredData );
    }
    catch( _com_error & error )
    {
        // display the error message
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        SAFEIRELEASE( pRsopLinkObj );
        SAFEIRELEASE( pRsopLinkClass );
        SAFEIRELEASE( pRsopObj );
        SAFEIRELEASE( pSomFilter );
        SAFEIRELEASE( pPolicyNameSpace );

        // destroy the dynamic arrays
        DESTROY_ARRAY( arrAppliedData );
        DESTROY_ARRAY( arrFilteredData );

        return FALSE;
    }

    SAFEIRELEASE( pRsopLinkObj );
    SAFEIRELEASE( pRsopLinkClass );
    SAFEIRELEASE( pRsopObj );
    SAFEIRELEASE( pSomFilter );
    SAFEIRELEASE( pPolicyNameSpace );

    return TRUE;
}

/*********************************************************************************************
Routine Description:
     This function Will delete the Rsop namespace created by method RsopCreateSession.

Arguments:
    [in] pClass         :   pointer to IWbemServices.
    [in] CHString       :   string containing the RsopNamespace.
    [in] pObject        :   pointer to IWbemClassObject.

Return Value:
  TRUE  - if SUCCESS
  FALSE - if ERROR
*********************************************************************************************/
BOOL RsopDeleteMethod( IWbemClassObject *pClass, CHString strNameSpace,
                        IWbemServices *pNamespace )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult  = FALSE;

    IWbemClassObject            *pInClass = NULL;
    IWbemClassObject            *pInInst  = NULL;
    IWbemClassObject            *pOutInst = NULL;

    CHString                    strTemp;
    DWORD                        ulReturn=0;

    try
    {
        // Check the input Parameters
        if( pClass == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        //Delete the resultant RSOP namespace as the snap shot
        //of RSOP has been obtained
        hResult = pClass->GetMethod( _bstr_t( FN_DELETE_RSOP ), 0, &pInClass, NULL );
        CHECK_HRESULT( hResult );

        hResult = pInClass->SpawnInstance( 0, &pInInst );
        CHECK_HRESULT( hResult );

        //Put the input parameter
        hResult = PropertyPut( pInInst, FPR_RSOP_NAMESPACE, strNameSpace );
        CHECK_HRESULT( hResult );

        // All The required properties are set so, execute method RsopDeleteSession
        hResult = pNamespace->ExecMethod( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ),
                                            _bstr_t( FN_DELETE_RSOP ),
                                            0, NULL, pInInst, &pOutInst, NULL );
        if(pOutInst == NULL)
        {
            hResult = E_FAIL;
        }
        if( FAILED( hResult ) )
        {
            // display the error msg
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE(pInClass);
            SAFEIRELEASE(pInInst);
            SAFEIRELEASE(pOutInst);

            return FALSE;
        }
        //Get returned paramter to check whether the method was successfull
        bResult = PropertyGet( pOutInst, FPR_RETURN_VALUE, ulReturn, 0);
        CHECK_BRESULT( bResult );

        // Returns some ERROR code.
        if( ulReturn != 0 )
        {
            // Show Error Message
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );
            bResult = FALSE;
        }
        bResult = TRUE;
    }
    catch( _com_error & error )
    {
        // display the error message and set the return value to FALSE
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
        bResult = FALSE;
    }

    // release the interface pointers and exit
    SAFEIRELEASE(pInClass);
    SAFEIRELEASE(pInInst);
    SAFEIRELEASE(pOutInst);

    return bResult;
}

/*********************************************************************************************
Routine Description:

    This function gets the OS information and fills the array with the same

Arguments:

    [in] PUSERINFO      pUserInfo       :   Structure containing the user information.

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetOsInfo( PUSERINFO pUserInfo )
{
    // Local variables
    HRESULT                         hResult = S_OK;

    BOOL                            bResult = FALSE;

    IEnumWbemClassObject            *pEnumClass = NULL;
    IWbemClassObject                *pClass = NULL;

    ULONG                           ulReturn = 0;
    DWORD                           dwDomainRole = 0;

    CHString                        strTemp;

    try
    {
        // print the progress message
        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_OSINFO ), m_csbi );

        // Enumerate the instances to get the domain and site names of the Win32 NT domain
        hResult = m_pWbemServices->CreateInstanceEnum( _bstr_t( CLS_WIN32_OS ),
                                                        WBEM_FLAG_FORWARD_ONLY |
                                                        WBEM_FLAG_RETURN_IMMEDIATELY,
                                                        NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // get the data
        hResult = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &ulReturn );
        CHECK_HRESULT( hResult );

        // get the OS version
        bResult = PropertyGet( pClass, CPV_OS_VERSION, pUserInfo->strOsVersion,
                                V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        // get the OS type
        bResult = PropertyGet( pClass, CPV_OS_CAPTION, pUserInfo->strOsType,
                                V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        // enumerate the instances of Win32_ComputerSystem class
        SAFE_RELEASE( pEnumClass );
        hResult = m_pWbemServices->CreateInstanceEnum( _bstr_t( CLS_WIN32_CS ),
                                                        WBEM_FLAG_RETURN_IMMEDIATELY |
                                                        WBEM_FLAG_FORWARD_ONLY,
                                                        NULL, &pEnumClass );

        // check the result of enumeration
        CHECK_HRESULT( hResult );

        // set the security on the obtained interface
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time.
        hResult = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &ulReturn );
        CHECK_HRESULT( hResult );

        // get the OS config
        bResult = PropertyGet( pClass, CPV_DOMAIN_ROLE, dwDomainRole, 0 );
        CHECK_BRESULT( bResult );

        // get the domain name information for later use
        bResult = PropertyGet( pClass, CPV_DOMAIN, m_strADSIDomain );
        CHECK_BRESULT( bResult );

        // get the server name for future use by LDAP
        bResult = PropertyGet( pClass, CPV_NAME, m_strADSIServer );
        CHECK_BRESULT( bResult );

        //
        // Mapping information of Win32_ComputerSystem's DomainRole property
        // NOTE: Refer to the _DSROLE_MACHINE_ROLE enumeration values in DsRole.h header file
        switch( dwDomainRole )
        {
        case DsRole_RoleStandaloneWorkstation:
            pUserInfo->strOsConfig = VALUE_STANDALONEWORKSTATION;
            break;
        case DsRole_RoleMemberWorkstation:
            pUserInfo->strOsConfig = VALUE_MEMBERWORKSTATION;
            break;

        case DsRole_RoleStandaloneServer:
            pUserInfo->strOsConfig = VALUE_STANDALONESERVER;
            break;

        case DsRole_RoleMemberServer:
            pUserInfo->strOsConfig = VALUE_MEMBERSERVER;
            break;

        case DsRole_RoleBackupDomainController:
            pUserInfo->strOsConfig = VALUE_BACKUPDOMAINCONTROLLER;
            break;

        case DsRole_RolePrimaryDomainController:
            pUserInfo->strOsConfig = VALUE_PRIMARYDOMAINCONTROLLER;
            break;

        default:
            break;
        }
    }
    catch(  _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
        // release the allocated variables
        SAFEIRELEASE( pEnumClass );
        SAFEIRELEASE( pClass );
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        // display the error message
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        SAFEIRELEASE( pEnumClass );
        SAFEIRELEASE( pClass );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function displays the security groups for system and user

Arguments:

    IWbemServices       :   pointer to the name space
    BOOL                :   set to TRUE if the system o/p is to be displayed

Return Value:

    None
*********************************************************************************************/
VOID CGpResult::DisplaySecurityGroups( IWbemServices *pNameSpace, BOOL bComputer )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    DWORD                       dwLength = 0;

    IWbemClassObject            *pClass = NULL;
    IWbemClassObject            *pName = NULL;
    IWbemClassObject            *pDomain = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    IEnumWbemClassObject        *pEnumDomain = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString[ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    CHString                    strDomain;

    SAFEARRAY                   *safeArray = NULL;

    try
    {
        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Enumerate the classes for the user privelege rights
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_RSOP_SESSION ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY,
                                                    NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the security groups
            if( bComputer == TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_SYS_SG ) );
                ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
                for( dwLength = StringLengthInBytes( GetResString( IDS_SYS_SG ) ); dwLength > 4; dwLength-- )
                {
                    ShowMessage( stdout, GetResString( IDS_DASH ) );
                }
                ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_USER_SG ) );
                ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
                for( dwLength = StringLengthInBytes( GetResString( IDS_USER_SG ) ); dwLength > 4; dwLength-- )
                {
                    ShowMessage( stdout, GetResString( IDS_DASH ) );
                }
                ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
            }

            VariantInit( &vVarVerbose );

            hResult = pClass->Get( _bstr_t(CPV_SEC_GRPS), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = (VARTYPE)(V_VT( &vVarVerbose ) & ~VT_ARRAY);

                //get the array of strings in to the safe array from the variant
                safeArray = (SAFEARRAY *)vVarVerbose.parray;

                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }

                if( FALSE == bComputer  )
                {
                    //alllocate memory to store user groups
                    m_szUserGroups = (LPWSTR*) AllocateMemory( (lUBound+1)*sizeof(LPWSTR));
                    if( NULL == m_szUserGroups )
                    {
                        VariantClear(&vVarVerbose);
                        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                        SAFEIRELEASE( pClass );
                        SAFEIRELEASE( pName );
                        SAFEIRELEASE( pDomain );
                        SAFEIRELEASE( pEnumClass );
                        SAFEIRELEASE( pEnumDomain );
                        return;
                    }
                    m_NoOfGroups = lUBound;
                }
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );

                    //place the user security groups
                    if( FALSE == bComputer )
                    {
                        m_szUserGroups[lLBound] = (LPWSTR) AllocateMemory( (strTemp.GetLength()+10)*sizeof(WCHAR) );
                        if( NULL == m_szUserGroups[lLBound] )
                        {
                            VariantClear(&vVarVerbose);
                            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                            SAFEIRELEASE( pClass );
                            SAFEIRELEASE( pName );
                            SAFEIRELEASE( pDomain );
                            SAFEIRELEASE( pEnumClass );
                            SAFEIRELEASE( pEnumDomain );
                            return;
                        }
                        StringCopy( m_szUserGroups[lLBound], (LPCWSTR)strTemp, GetBufferSize(m_szUserGroups[lLBound])/sizeof(WCHAR) );
                    }

                    // Got a sid, now get it's coressponding name
                    // form the object path using the SID
                    //
                    // 
                    // if( strTemp.Right(4) == L"-513" )
                    //    continue;
                    //
                    //
                    StringCchPrintf( szTemp, MAX_STRING_LENGTH,  OBJECT_PATH, (LPCWSTR)strTemp );

                    // Get the object
                    hResult = m_pWbemServices->GetObject( _bstr_t( szTemp ), 0, NULL, &pName, NULL );
                    CHECK_HRESULT( hResult );

                    // Get the Account name
                    bResult = PropertyGet( pName, CPV_ACCOUNT_NAME, strTemp, V_NOT_AVAILABLE );

                    // Append the appropriate prefix
                    if( strTemp.Compare( _T( "ANONYMOUS LOGON" ) ) == 0
                                || strTemp.Compare( _T( "BATCH" ) ) == 0
                                || strTemp.Compare( _T( "DIALUP" ) ) == 0
                                || strTemp.Compare( _T( "INTERACTIVE" ) ) == 0
                                || strTemp.Compare( _T( "SERVICE" ) ) == 0
                                || strTemp.Compare( _T( "SYSTEM" ) ) == 0
                                || strTemp.Compare( _T( "TERMINAL SERVICE USER" ) ) == 0
                                || strTemp.Compare( _T( "PROXY" ) ) == 0
                                || strTemp.Compare( _T( "NETWORK" ) ) == 0
                                || strTemp.Compare( _T( "ENTERPRISE DOMAIN CONTROLLERS" ) ) == 0
                                || strTemp.Compare( _T( "Authenticated Users" ) ) == 0
                                || strTemp.Compare( _T( "RESTRICTED" ) ) == 0
                                || strTemp.Compare( _T( "SELF" ) ) == 0 )
                    {
                        ShowMessage( stdout, _T( "NT AUTHORITY\\" ) );
                    }
                    else if( strTemp.Compare( _T( "Administrators" ) ) == 0
                                || strTemp.Compare( _T( "Backup Operators" ) ) == 0
                                || strTemp.Compare( _T( "Guests" ) ) == 0
                                || strTemp.Compare( _T( "Power Users" ) ) == 0
                                || strTemp.Compare( _T( "Replicator" ) ) == 0
                                || strTemp.Compare( _T( "Pre-Windows 2000 Compatible Access" ) ) == 0
                                || strTemp.Compare( _T( "Users" ) ) == 0 )
                    {
                        ShowMessage( stdout, _T( "BUILTIN\\" ) );
                    }
                    if( strTemp.Compare( _T("") ) != 0)
                    {
                        ShowMessage( stdout, strTemp );
                        ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
                    }
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
                ShowMessage( stdout, NEW_LINE );
            }

            VariantClear(&vVarVerbose);
        }
    }

    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
        SAFEIRELEASE(pEnumClass);
        SAFEIRELEASE(pEnumDomain);
        SAFEIRELEASE(pClass);
        SAFEIRELEASE(pName);
        SAFEIRELEASE(pDomain);
        VariantClear(&vVarVerbose);
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pEnumDomain);
    SAFEIRELEASE(pClass);
    SAFEIRELEASE(pName);
    SAFEIRELEASE(pDomain);

    return;
}

/*********************************************************************************************
Routine Description:

    This function gets the link speed information

Arguments:

    IWbemServices       :   pointer to the name space.
    COAUTHIDENTITY      :   pointer to the AuthIdentity structure.

Return Value:

    None
*********************************************************************************************/
VOID DisplayLinkSpeed( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarTemp;

    try
    {
        // Get the pointer to ennumerate with
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_RSOP_SESSION ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY,
                                                    NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        // Enumerate the classes one by one and get the data
        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            VariantInit( &vVarTemp );
            hResult = pClass->Get( _bstr_t( CPV_SLOW_LINK ), 0, &vVarTemp, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarTemp );

            ShowMessage( stdout, GetResString( IDS_LINK_SPEED ) );
            if( vVarTemp.vt != VT_NULL )
            {
                bTemp = vVarTemp.boolVal;
                if( bTemp == VAR_TRUE )
                {
                    ShowMessage( stdout, GetResString( IDS_YES ) );
                }
                else
                {
                    ShowMessage( stdout, GetResString( IDS_NO ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }

            ShowMessage( stdout, NEW_LINE );
            VariantClear( &vVarTemp );
        }// while
    }
    catch(_com_error & error)
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear( &vVarTemp );
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);

    return;
}

/*********************************************************************************************
Routine Description:

     This function gets the User name and the domain name from WMI..

Arguments:

    [in]    szSid           :   string containing the SID
    [out]   szName          :   string to hold the user name
    [out]   szDomain        :   string to hold the domain name

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetUserNameFromWMI( TCHAR szSid[], TCHAR szName[], TCHAR szDomain[] )
{
    // Local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;

    TCHAR                       szQueryString[ MAX_QUERY_STRING ];
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    CHString                    strTemp = NULL_STRING;

    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemClassObject            *pClass =  NULL;

    ULONG                       ulReturn = 0;

    try
    {
        // set the strings to NULL
        SecureZeroMemory( szQueryString, MAX_QUERY_STRING * sizeof( TCHAR ));
        SecureZeroMemory( szTemp, MAX_STRING_LENGTH * sizeof( TCHAR ) );

        // Form the query string
        StringCopy( szTemp, QUERY_USER_NAME, MAX_STRING_LENGTH );
        StringCchPrintf( szQueryString, MAX_QUERY_STRING,  szTemp, szSid );

        // execute the respective query
        hResult = m_pWbemServices->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                                _bstr_t( szQueryString ),
                                                WBEM_FLAG_FORWARD_ONLY |
                                                WBEM_FLAG_RETURN_IMMEDIATELY,
                                                NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // set the security parameters
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // Get the user name
        hResult = pEnumClass->Next( TIME_OUT_NEXT, 1, &pClass, &ulReturn );
        CHECK_HRESULT( hResult );

        // if there are no classes to enumerate break out of the loop
        if( ulReturn == 0 )
        {
            // No classes were retrieved....display msg
            // release the interface pointers and exit
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pEnumClass );

            return FALSE;

        }

        // Get the class property(Name)
        bResult = PropertyGet( pClass, CPV_NAME, strTemp, V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        // Got the name...Store it.
        StringCopy( szName, (LPCWSTR)strTemp, MAX_STRING_LENGTH );

        // Get and add the domain name if it exists
        bResult = PropertyGet( pClass, CPV_DOMAIN, strTemp, V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        if( strTemp.Compare( V_NOT_AVAILABLE ) != 0 )
        {
            // Got the domain name...Store it.
            StringCopy( szDomain, (LPCWSTR)strTemp, MAX_STRING_LENGTH );
        }
    }
    catch(  _com_error & error )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        // display the error msg
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the interface pointers and exit
        SAFEIRELEASE( pClass );
        SAFEIRELEASE( pEnumClass );

        return FALSE;
    }

    // release the interface pointers and exit
    SAFEIRELEASE( pClass );
    SAFEIRELEASE( pEnumClass );

    return TRUE;
}
/*********************************************************************************************
Routine Description:

     This function gets the User name and the domain name from WMI..

Arguments:

    [in]    szSid           :   string containing the SID
    [out]   szName          :   string to hold the user name
    [out]   szDomain        :   string to hold the domain name

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetTerminalServerMode( PUSERINFO pUserInfo  )
{
    // Local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;

    TCHAR                       szQueryString[ MAX_QUERY_STRING ];
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    DWORD                       dwTerminalServerMode;

    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemClassObject            *pClass =  NULL;

    ULONG                       ulReturn = 0;

    try
    {
        // set the strings to NULL
        SecureZeroMemory( szQueryString, MAX_QUERY_STRING * sizeof( TCHAR ));
        SecureZeroMemory( szTemp, MAX_STRING_LENGTH * sizeof( TCHAR ) );

        // Form the query string
        StringCopy( szTemp, QUERY_TERMINAL_SERVER_MODE, MAX_STRING_LENGTH );
        StringCchPrintf( szQueryString, MAX_QUERY_STRING, szTemp, pUserInfo->strUserServer);

        // execute the respective query
        hResult = m_pWbemServices->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                                _bstr_t( szQueryString ),
                                                WBEM_FLAG_FORWARD_ONLY |
                                                WBEM_FLAG_RETURN_IMMEDIATELY,
                                                NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // set the security parameters
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // Get the Terminal server mode
        hResult = pEnumClass->Next( TIME_OUT_NEXT, 1, &pClass, &ulReturn );
        CHECK_HRESULT( hResult );

        // if there are no classes to enumerate break out of the loop
        if( ulReturn == 0 )
        {
            // No classes were retrieved....display msg
            // release the interface pointers and exit
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pEnumClass );

            return FALSE;

        }

        // Get the class property(Name)
        bResult = PropertyGet( pClass, CPV_TERMINAL_SERVER_MODE, dwTerminalServerMode, 0 );
        CHECK_BRESULT( bResult );

        // Got the terminal server mode ...Store it.
        if( 1 == dwTerminalServerMode )
        {
             pUserInfo->strTerminalServerMode=GetResString(IDS_TS_APPSERVER);
        }
        else if( 0 == dwTerminalServerMode )
        {
             pUserInfo->strTerminalServerMode=GetResString(IDS_TS_REMOTEADMIN);
        }
           else
            {
                 pUserInfo->strTerminalServerMode=GetResString(IDS_TS_REMOTEADMIN);
            }
    }
    catch(  _com_error & error )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        // display the error msg
          WMISaveError( error.Error() );
//        ShowMessage( stderr, GetResString( IDS_ERROR ) );
//        ShowMessage( stderr, GetReason() );

        // release the interface pointers and exit
        SAFEIRELEASE( pClass );
        SAFEIRELEASE( pEnumClass );

        return FALSE;
    }

    // release the interface pointers and exit
    SAFEIRELEASE( pClass );
    SAFEIRELEASE( pEnumClass );

    return TRUE;
}
/*********************************************************************************************
Routine Description:

    This function gets the threshold link speed information.

Arguments:

    [in] BOOL   :   set to TRUE if the information is to be retrieved for the computer.

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::DisplayThresholdSpeedAndLastTimeInfo( BOOL bComputer )
{
    // Local variables
    HRESULT                 hResult = S_OK;

    HKEY                    hKey = NULL;
    HKEY                    hRemoteKey = NULL;

    IWbemServices           *pDefaultNameSpace = NULL;

    TCHAR                   szTemp[ MAX_STRING_LENGTH ];
    TCHAR                   szServer[ MAX_STRING_LENGTH ];
    TCHAR                   szName[ MAX_STRING_LENGTH ];
    TCHAR                   szTime[ MAX_STRING_LENGTH ];
    TCHAR                   szDate[ MAX_STRING_LENGTH ];

    BOOL                    bResult = FALSE;
    BOOL                    bLocaleChanged = FALSE;
    BOOL                    bConnFlag = TRUE;

    CHString                strTemp;

    DWORD                   dwHkey = 0;
    DWORD                   dwValue;
    DWORD                   dwResult = 0;

    FILETIME                ftWrite;
    FILETIME                ftLocal;

    SYSTEMTIME              systime;

    LCID                    lcid;

    SecureZeroMemory( &ftWrite, sizeof(FILETIME) );
    SecureZeroMemory( &ftLocal, sizeof(FILETIME) );
    SecureZeroMemory( &systime, sizeof(SYSTEMTIME) );

    try
    {
        // If we have to get the information from a remote machine then...
        // connect to the remote machine for the last time execution information.
        if ( m_bLocalSystem == FALSE )
        {
            StringCopy( szServer, m_strServerName, MAX_STRING_LENGTH );
            StringCopy( szName, m_strUserName, MAX_STRING_LENGTH );

            bResult = EstablishConnection( szServer, szName, MAX_STRING_LENGTH,
                                            m_pwszPassword, MAX_STRING_LENGTH, FALSE );
            if( bResult != TRUE )
            {
                strTemp = V_NOT_AVAILABLE;
            }
            else
            {
                switch( GetLastError() )
                {
                    case I_NO_CLOSE_CONNECTION:
                        bConnFlag = FALSE;
                        break;

                    case E_LOCAL_CREDENTIALS:
                    case ERROR_SESSION_CREDENTIAL_CONFLICT:
                        bConnFlag = FALSE;
                        break;

                    default:
                        break;
                }
            }

            // Connect to the remote registry
            StringCopy( szServer , _T( "\\\\" ), MAX_STRING_LENGTH );
            StringConcat( szServer, m_strServerName, MAX_STRING_LENGTH );
            dwResult = RegConnectRegistry( szServer, bComputer ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                                            &hRemoteKey );
            if( dwResult != ERROR_SUCCESS )
            {
                strTemp = V_NOT_AVAILABLE;
            }
        }

        // Open the last time execution information key
        dwResult = RegOpenKeyEx (bComputer ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                                    GROUPPOLICY_PATH, 0, KEY_READ, &hKey);


        if( dwResult != ERROR_SUCCESS )
        {
            strTemp = V_NOT_AVAILABLE;
        }

        // Get the last time execution information
        dwResult = RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                                    NULL, &ftWrite );

        if( dwResult == ERROR_SUCCESS )
        {
            FileTimeToLocalFileTime( &ftWrite, &ftLocal );
            FileTimeToSystemTime( &ftLocal, &systime );


            // verify whether console supports the current locale 100% or not
            lcid = GetSupportedUserLocale( &bLocaleChanged );

            // get the formatted date
            GetDateFormat( lcid, 0, &systime, ((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL),
                            szDate, SIZE_OF_ARRAY( szDate ) );

            // now format the date
            GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systime, ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL),
                            szTime, SIZE_OF_ARRAY( szTime ) );

            StringCchPrintf( szTemp, SIZE_OF_ARRAY(szTemp), LAST_TIME_OP, _X( szDate ), _X2( szTime ) );
            strTemp = szTemp;
        }
        else
        {
            strTemp = V_NOT_AVAILABLE;
        }

        // Display the retrieved data
        ShowMessage( stdout, GetResString( IDS_LAST_TIME ) );
        ShowMessage( stdout, strTemp );
        ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

        // if we have opened a connection then close the same.
        if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
        {
            StringCopy( szServer, m_strServerName, MAX_STRING_LENGTH  );
            CloseConnection( szServer );
        }

        // Close the registry keys
        if( hKey != NULL )
        {
            RegCloseKey( hKey );
        }
        if( hRemoteKey != NULL )
        {
            RegCloseKey( hRemoteKey );
        }

        // connect to the default namespace
        ConnectWmi( m_pWbemLocator, &pDefaultNameSpace, m_strServerName,
                    m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                    FALSE, _bstr_t( ROOT_DEFAULT ), &hResult );
        CHECK_HRESULT( hResult );

        // form the key
        if( bComputer == TRUE )
        {
            dwHkey = HKEY_DEF;
        }
        else
        {
            dwHkey = HKEY_CURRENT_USER_DEF;
        }

        // Get the DC name from where the policy was applied last
        RegQueryValueWMI( pDefaultNameSpace, dwHkey, APPLIED_PATH, FPR_APPLIED_FROM,
                            strTemp, V_NOT_AVAILABLE );

        // remove the forward slashes (UNC) if exist in the begining of the server name
        if ( IsUNCFormat( strTemp ) == TRUE )
        {
            strTemp = strTemp.Mid( 2 );
        }

        // Display the retrieved data
        ShowMessage( stdout, GetResString( IDS_APPLIED_FROM ) );
        ShowMessage( stdout, strTemp );
        ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

        // Get the threshold link speed information
        RegQueryValueWMI( pDefaultNameSpace, dwHkey, GPRESULT_PATH, FPR_LINK_SPEED_VALUE, dwValue, (DWORD)-1 );
        if( dwValue == (DWORD)-1 )
        {
            strTemp = DEFAULT_LINK_SPEED;
        }
        else
        {
            StringCchPrintf( szTemp, MAX_STRING_LENGTH, _T( "%d kbps" ), dwValue );
            strTemp = szTemp;
        }

        // Display the retrieved data
        ShowMessage( stdout, GetResString( IDS_THRESHOLD_LINK_SPEED ) );
        ShowMessage( stdout, strTemp );

    }
    catch(  _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the allocated variables
        SAFEIRELEASE( pDefaultNameSpace );

        return FALSE;
    }
    catch( CHeap_Exception )
    {
        // display the error message
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
        SAFEIRELEASE( pDefaultNameSpace );
        return FALSE;
    }

    // release the interface pointer
    SAFEIRELEASE( pDefaultNameSpace );

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function sorts the applied Gpo data in the order applied.

Arguments:

    [in/out] TARRAY     :   Array to be sorted

Return Value:

    None
*********************************************************************************************/
VOID SortAppliedData( TARRAY arrAppliedData )
{
    // Local variables
    TARRAY          arrSortedData = NULL;

    DWORD           dwMax = 0;
    DWORD           dwCount = 0;
    DWORD           dwi = 0;
    DWORD           dwOrder = 0;
    DWORD           dwIndex = 0;
    BOOL            bNobreak = TRUE;

        // Create the dynamic array to hold the sorted data temporarily
    arrSortedData = CreateDynamicArray( );
    if( NULL == arrSortedData || NULL == arrAppliedData)
    {
        //simply return, at most it can print non sorted data, that's all
        SetLastError((DWORD)E_OUTOFMEMORY );
        return;
    }

    dwCount = DynArrayGetCount( arrAppliedData );

    // Get the max applied order in the array
    for( dwi = 0; dwi < dwCount; dwi++ )
    {
        dwOrder = DynArrayItemAsDWORD2( arrAppliedData, dwi, COL_ORDER );
        if( dwOrder > dwMax )
        {
            dwMax = dwOrder;
        }
    }

    // Create the sorted array in the descending order of the applied order
    for( dwi = 0; dwi < dwCount; dwi++ )
    {
        // re-set the index variable
        dwIndex = 0;

        // Get the index of the row whose order = dwMax
        while( bNobreak )
        {
            dwOrder = DynArrayItemAsDWORD2( arrAppliedData, dwIndex, COL_ORDER );
            if( dwOrder == dwMax )
            {
                break;
            }

            // increment the index
            dwIndex++;

            // Additional check...just in case the order does not exist
            // avoid an AV
            if( dwIndex == dwCount )
            {
                break;
            }
        }

        // Additional check...just in case the order does not exist
        // avoid an AV
        if( dwIndex == dwCount )
        {
            // could not find the index
            // decrement the max order
            dwMax--;

            continue;
        }

        // Store the contents of the row
        DynArrayAppendRow( arrSortedData, COL_MAX );
        DynArraySetString2( arrSortedData, dwi, COL_DATA,
                            DynArrayItemAsString2( arrAppliedData, dwIndex, COL_DATA ), 0 );
        DynArraySetDWORD2( arrSortedData, dwi, COL_ORDER, dwOrder );

        // decrement the max order
        dwMax--;
    }

    // copy the sorted data onto the applied data array
    for( dwi = 0; dwi < dwCount; dwi++ )
    {
        DynArraySetString2( arrAppliedData, dwi, COL_DATA,
                            DynArrayItemAsString2( arrSortedData, dwi, COL_DATA ), 0 );
        DynArraySetDWORD2( arrAppliedData, dwi, COL_ORDER,
                            DynArrayItemAsDWORD2( arrSortedData, dwi, COL_ORDER ) );
    }

    // destroy the temporarily created dynamic array
    DESTROY_ARRAY( arrSortedData );

    return;
}

/*********************************************************************************************
Routine Description:

    This function retrieves the FQDN from ADSI

Arguments:

    [out] TCHAR []      :   Array to hold the FQDN
    [in]  BOOL          :   flag to specify wether the FQDN is to be retrieved for
                            the computer or the user
    [in] LPCTSTR        :   The name for whom the FQDN is to be retrieved

Return Value:

    None
*********************************************************************************************/
VOID CGpResult::GetFQDNFromADSI( TCHAR szFQDN[], BOOL bComputer, LPCTSTR pszName )
{
    // Local variables
    HANDLE                  hDS = NULL;

    DWORD                   dwReturn = 0;

    DS_NAME_RESULT          *pNameResult = NULL;

    SecureZeroMemory( szFQDN, MAX_STRING_LENGTH * sizeof( TCHAR ) );



    // Bind to the ADSI directory service
    dwReturn = DsBindWithCred( NULL, m_strADSIDomain, m_pAuthIdentity, &hDS );
    if( dwReturn != NO_ERROR )
    {
        return;
    }

    // Get the FQDN information
    dwReturn = DsCrackNames( hDS, DS_NAME_NO_FLAGS,
                             bComputer ? DS_DISPLAY_NAME : DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME,
                             1, &pszName, &pNameResult );
    if( dwReturn != DS_NAME_NO_ERROR )
    {
        return;
    }

    // store the retrieved FQDN
    StringCopy( szFQDN, pNameResult->rItems->pName, MAX_STRING_LENGTH );

    // Free the handle to the ADSI directory services
    DsUnBind( &hDS );

    // Free the allocated memory
    DsFreeNameResult( pNameResult );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\resource.h ===
// Help
#define IDS_HELP_1                                      1
#define IDS_HELP_2                                      2
#define IDS_HELP_3                                      3
#define IDS_HELP_4                                      4
#define IDS_HELP_5                                      5
#define IDS_HELP_6                                      6
#define IDS_HELP_7                                      7
#define IDS_HELP_8                                      8
#define IDS_HELP_9                                      9
#define IDS_HELP_10                                     10
#define IDS_HELP_11                                     11
#define IDS_HELP_12                                     12
#define IDS_HELP_13                                     13
#define IDS_HELP_14                                     14
#define IDS_HELP_15                                     15
#define IDS_HELP_16                                     16
#define IDS_HELP_17                                     17
#define IDS_HELP_18                                     18
#define IDS_HELP_19                                     19
#define IDS_HELP_20                                     20
#define IDS_HELP_21                                     21
#define IDS_HELP_22                                     22
#define IDS_HELP_23                                     23
#define IDS_HELP_24                                     24
#define IDS_HELP_25                                     25
#define IDS_HELP_26                                     26
#define IDS_HELP_27                                     27
#define IDS_HELP_28                                     28
#define IDS_HELP_29                                     29
#define IDS_HELP_30                                     30
#define IDS_HELP_31                                     31
#define IDS_HELP_32                                     32
#define IDS_HELP_33                                     33
#define IDS_HELP_34                                     34
#define IDS_HELP_35                                     35
#define IDS_HELP_36                                     36
#define IDS_HELP_37                                     37
#define IDS_HELP_38                                     38
#define IDS_HELP_39                                     39
#define IDS_HELP_40                                     40

// General
#define IDS_INFO                                        51
#define IDS_ERROR                                       52
#define IDS_WARNING                                     53
#define IDS_DASH                                        54
#define IDS_NEWLINE_TAB                                 55
#define IDS_LAST_CHAR                                   56
#define IDS_NEWLINE                                     57
#define IDS_NEWLINE1                                    58
#define IDS_NEWLINETAB                                  59
#define IDS_NEWLINE_TABTHREE                            60
#define IDS_NEWLINE2                                    61

// Warning
#define IDS_WARN_LOCAL                                  65

// Info
#define IDS_USER_NO_RSOP                                75

// Error
#define IDS_ERROR_USERNAME_BUT_NOMACHINE                81
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME               82
#define IDS_ERROR_COM_ERROR                             83
#define IDS_ERROR_USERNAME_EMPTY                        84
#define IDS_ERROR_SERVERNAME_EMPTY                      85
#define IDS_ERROR_NO_OPTIONS                            86
#define IDS_ERROR_USAGE                                 87
#define IDS_TYPE_USAGE                                  88
#define IDS_ERROR_TARGET_EMPTY                          89
#define IDS_USER_NOT_VALID                              90
#define IDS_NO_USER                                     91
#define IDS_METHOD_FAILED                               92
#define IDS_ERROR_VERBOSE_SYNTAX                        93

// Display
#define IDS_GPO_USER                                    101
#define IDS_GPO_COMPUTER                                102
#define IDS_GPO_TITLE                                   103
#define IDS_COMPUTER_RESULT                             104
#define IDS_USER_RESULT                                 105
#define IDS_DOMAIN_NAME                                 106
#define IDS_DOMAIN_TYPE                                 107
#define IDS_SITE_NAME                                   108
#define IDS_OS_TYPE                                     109
#define IDS_OS_VERSION                                  110
#define IDS_OS_CONFIG                                   111
#define IDS_LOCAL_PROFILE                               112
#define IDS_GPO_DISPLAY                                 113
#define IDS_GPO_FILTERED                                114
#define IDS_GPO_FILTER_ID                               115
#define IDS_SW_SETTINGS                                 116
#define IDS_WS_SS_AP_PP                                 117
#define IDS_WS_SS_AP_ALP                                118
#define IDS_WS_SS_LP_AP                                 119
#define IDS_WS_SS_LP_URA                                120
#define IDS_WS_SS_LP_SO                                 121
#define IDS_WS_SSU                                      122
#define IDS_WS_SSD                                      123
#define IDS_WS_SS_EL                                    124
#define IDS_WS_SS_RG                                    125
#define IDS_WS_SS_SS                                    126
#define IDS_WS_SS_REG                                   127
#define IDS_WS_SS_FS                                    128
#define IDS_WS_SS_PKP                                   129
#define IDS_ADTS_RAS                                    130
#define IDS_ADTS_ERS                                    131
#define IDS_USERFR                                      132
#define IDS_IEPOLICY                                    133
#define IDS_FAVLINKORITEM                               134
#define IDS_IE_SECURITY                                 135
#define IDS_IE_PROGRAMS                                 136
#define IDS_PROXY                                       137
#define IDS_POLICY                                      138
#define IDS_COMPUTER_SETTING                            139
#define IDS_GPO                                         140
#define IDS_NAME                                        141
#define IDS_PARAMETERS                                  142
#define IDS_LASTEXECUTED                                143
#define IDS_SETTING                                     144
#define IDS_FR_SETTING                                  145
#define IDS_STATE                                       146
#define IDS_AUTOINSTALL                                 147
#define IDS_ORIGIN                                      148
#define IDS_OBJECTNAME                                  149
#define IDS_GROUPNAME                                   150
#define IDS_MEMBERS                                     151
#define IDS_SERVICENAME                                 152
#define IDS_STARTUP                                     153
#define IDS_PERMISSION                                  154
#define IDS_MEMBEROF                                    155
#define IDS_INSTALLATIONTYPE                            156
#define IDS_GRANTTYPE                                   157
#define IDS_MOVETYPE                                    158
#define IDS_REDIRECTINGGROUP                            159
#define IDS_REDIRECTEDPATH                              160
#define IDS_POLICYREMOVAL                               161
#define IDS_HOMEPAGEURL                                 162
#define IDS_BITMAPNAME                                  163
#define IDS_LOGOBITMAPNAME                              164
#define IDS_TITLEBARTEXT                                165
#define IDS_USERAGENTTEXT                               166
#define IDS_URL                                         167
#define IDS_AVAILABLE                                   168
#define IDS_VIEWABLESITES                               169
#define IDS_PASSWORDOVERRIDE                            170
#define IDS_HTTP_PROXY                                  171
#define IDS_SECURE_PROXY                                172
#define IDS_FTP_PROXY                                   173
#define IDS_GOPHER_PROXY                                174
#define IDS_SOCKS_PROXY                                 175
#define IDS_AUTO_CONFIG_ENABLE                          176
#define IDS_ENABLE_PROXY                                177
#define IDS_USE_SAME_PROXY                              178
#define IDS_APP_NAME                                    179
#define IDS_APP_VERSION                                 180
#define IDS_DEPLOY_STATE                                181
#define IDS_APP_SRC                                     182
#define IDS_LOG_NAME                                    183
#define IDS_USER_SG                                     184
#define IDS_SYS_SG                                      185
#define IDS_LINK_SPEED                                  186
#define IDS_THRESHOLD_LINK_SPEED                        187
#define IDS_LAST_TIME                                   188
#define IDS_APPLIED_FROM                                189
#define IDS_ROAMING_PROFILE                             190
#define IDS_SEARCHBARURL                                191
#define IDS_HELPPAGEURL                                 192
#define IDS_ZONE_SETTING                                193
#define IDS_PROGRAM_SETTING                             194
#define IDS_CONTENT_SETTING                             195
#define IDS_AUTH_SETTING                                196
#define IDS_TRUST_PUB                                   197
#define IDS_TOOL_BUTTONS                                198
#define IDS_FILTERING                                   199

// Display data
#define IDS_NO_AUDITING                                 251
#define IDS_AUTOMATIC                                   252
#define IDS_MANUAL                                      253
#define IDS_DISABLED                                    254
#define IDS_PUBLISHED                                   255
#define IDS_ASSIGNED                                    256
#define IDS_TRUE                                        257
#define IDS_FALSE                                       258
#define IDS_ARP                                         259
#define IDS_APPLICATION                                 260
#define IDS_REMOVED                                     261
#define IDS_NOPOLICY                                    262
#define IDS_BASIC                                       263
#define IDS_ADVANCED                                    264
#define IDS_MAXIMUM                                     265
#define IDS_YES                                         266
#define IDS_NO                                          267
#define IDS_VALUE_STANDALONEWORKSTATION                 268
#define IDS_VALUE_MEMBERWORKSTATION                     269
#define IDS_VALUE_STANDALONESERVER                      270
#define IDS_VALUE_MEMBERSERVER                          271
#define IDS_VALUE_BACKUPDOMAINCONTROLLER                272
#define IDS_VALUE_PRIMARYDOMAINCONTROLLER               273
#define IDS_STRING_COMPUTER                             274
#define IDS_STRING_USER                                 275
#define IDS_NULL_SID                                    276
#define IDS_EVERYONE                                    277
#define IDS_LOCAL                                       278
#define IDS_CREATOR_OWNER                               279
#define IDS_CREATOR_GROUP                               280
#define IDS_SYSTEM                                      281
#define IDS_SECURITY                                    282
#define IDS_APP_LOG                                     283
#define IDS_ENABLED                                     284
#define IDS_NOT_ENABLED                                 285
#define IDS_NOT_EXECUTED                                286
#define IDS_EXCLUSIVE                                   287
#define IDS_NOTEXCLUSIVE                                288
#define IDS_MOVED                                       289
#define IDS_NOTMOVED                                    290
#define IDS_LEAVEFOLDER                                 291
#define IDS_REDIRECT                                    292
#define IDS_W2K_DOMAIN                                  293
#define IDS_LOCAL_COMP                                  294
#define IDS_NT4_DOMAIN                                  295
#define IDS_MS_409                                      296
#define IDS_LEGAL_INFO1                                 297
#define IDS_LEGAL_INFO2                                 298
#define IDS_CREATED_ON                                  299
#define IDS_WMI_DENIED                                  300
#define IDS_LINK_DISABLED                               301
#define IDS_GPO_DISABLED                                302
#define IDS_ACCESS_DENIED                               303
#define IDS_VERSION_ZERO                                304
#define IDS_NOT_APPLIED                                 305

// Status messages
#define IDS_STARTED_RETRIEVAL                           351
#define IDS_CONNECT_CIMV2                               352
#define IDS_USER_DATA                                   353
#define IDS_CONNECT_RSOP                                354
#define IDS_GET_SID                                     355
#define IDS_GET_NAME                                    356
#define IDS_GET_PROFILE                                 357
#define IDS_GET_COMMON                                  358
#define IDS_GET_DOMAIN                                  359
#define IDS_GET_SITE                                    360
#define IDS_GET_PROVIDER                                361
#define IDS_GET_METHOD                                  362
#define IDS_PUT_SID                                     363
#define IDS_CREATE_SESSION                              364
#define IDS_DISPLAY_DATA                                365
#define IDS_WAIT                                        366
#define IDS_GET_OSINFO                                  367

//newly added resouce ids for adding registry settings value and vaule name, 14-Sep-2001
#define IDS_VALUENAME                                   368
#define IDS_VALUE                                       369
#define IDS_COMMA                                       370
#define IDS_WS_SLOGON                                   371
#define IDS_WS_SLOGOFF                                  372
#define IDS_USER_PRIV                                   373
#define IDS_USER_DOMAIN_NAME                            374
#define IDS_USER_DOMAIN_TYPE                            375
#define IDS_TERMINAL_SERVER_MODE                        376
#define IDS_LAST_TIME_OP                                377
#define IDS_TS_REMOTEADMIN                              378
#define IDS_TS_APPSERVER                                379
#define IDS_TS_NONE                                     380
#define IDS_NO_PERMISSIONS                              381
#define IDS_ERROR_SESSION_CONFLICT                      382
#define IDS_USER_NO_RSOP1                               383
#define IDS_MUTEX_FAILED                                384

#define ID_HELP_START                   IDS_HELP_1
#define ID_HELP_END                     IDS_HELP_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\pch.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      pch.h
//
//  Abstract:
//
//      pre-compiled header declaration
//      files that has to be pre-compiled into .pch file
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once        // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
    #include <Security.h>
    #include <SecExt.h>
}

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <wbemidl.h>
#include <chstring.h>
#include <comdef.h>
#include <wbemtime.h>
#include <tchar.h>
#include <wbemidl.h>
#include <wbemprov.h>
#include <winerror.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dsrole.h>                 // domain role information
#include <Sddl.h>                   // Sid conversion functions
#include <activeds.h>
#include <Ntdsapi.h>
#include <ntsecapi.h>
#include <strsafe.h>
#include <userenv.h>

//
// public C header files
//
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\verboseloggingdata.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    VerboseLoggingData.cpp

Abstract:

    The verbose data is displayed in this module.

Author:

    Wipro Technologies

Revision History:

    22-Feb-2001 : Created It.

*********************************************************************************************/

#include "pch.h"
#include "GpResult.h"
#include "WMI.h"
#include "VerboseLoggingData.h"

extern "C" {
    NTSTATUS
       NTAPI
       LsaEnumeratePrivileges(
        IN LSA_HANDLE PolicyHandle,
        OUT LSA_ENUMERATION_HANDLE * eHandle,
        OUT LPVOID * enumBuffer,
        IN ULONG prefMaxLen,
        OUT ULONG * countReturned
       );

};

BOOL 
CGpResult::DisplayVerboseComputerData(
                                       IN IWbemServices *pNameSpace 
                                      )
/*++

Routine Description:

     This function displays the verbose data for the  scope - computer

Arguments:

    [in]    IWbemServices   *pRsopNameSpace     :   interface pointer

Return Value:

    TRUE  on SUCCESS
    FALSE on FAILURE
--*/
{
    //sub-local variables
    DWORD           dwLength = 0;

    //
    // Display the verbose information for the scope - computer

    // Display the header
    ShowMessage( stdout, GetResString( IDS_COMPUTER_RESULT ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_COMPUTER_RESULT ) ); dwLength > 4; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    ShowMessage( stdout, NEW_LINE );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    // Display the software installations
    ShowMessage( stdout, GetResString( IDS_SW_SETTINGS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_SW_SETTINGS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplaySoftwareInstallations( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the start-up data
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SSU ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SSU ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayScripts( pNameSpace, TRUE, m_pAuthIdentity, m_bSuperVerbose );

    // Display the scripts data
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SSD ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    
    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SSD ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayScripts( pNameSpace, FALSE, m_pAuthIdentity, m_bSuperVerbose );

    // Display the password policy
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_AP_PP ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_AP_PP ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayPasswordPolicy( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the Audit Policy
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_LP_AP ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_LP_AP ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayAuditPolicy( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the user rights
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_LP_URA ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_LP_URA ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayUserRights( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the security options
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_LP_SO ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_LP_SO ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplaySecurityandEvents( pNameSpace, _bstr_t((LPCWSTR)(CLS_SECURITY_BOOLEAN)), m_pAuthIdentity, m_bSuperVerbose );
    DisplaySecurityandEvents( pNameSpace, _bstr_t((LPCWSTR)(CLS_SECURITY_STRING)), m_pAuthIdentity, m_bSuperVerbose );

    // Display the event log information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_EL ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_EL ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplaySecurityandEvents( pNameSpace, _bstr_t((LPCWSTR)(CLS_EVENTLOG_NUMERIC)), m_pAuthIdentity, m_bSuperVerbose );
    DisplaySecurityandEvents( pNameSpace, _bstr_t((LPCWSTR)(CLS_EVENTLOG_BOOLEAN)), m_pAuthIdentity, m_bSuperVerbose );

    // Display the restricted groups information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_RG ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_RG ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayRestrictedGroups( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the system services information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_SS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_SS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplaySystemServices( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the registry information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_REG ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_REG ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    //display registry information
    DisplayRegistryandFileInfo( pNameSpace, _bstr_t((LPCWSTR)(CLS_REGISTRY)), m_pAuthIdentity, m_bSuperVerbose );

    // Display the file information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_FS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_FS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    //display registry file infomration
    DisplayRegistryandFileInfo( pNameSpace, _bstr_t((LPCWSTR)(CLS_FILE)), m_pAuthIdentity, m_bSuperVerbose );

    // Display the public key policies
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_PKP ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_PKP ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
    ShowMessage( stdout, V_NOT_AVAILABLE );
    ShowMessage( stdout, NEW_LINE );

    // Display the administrative templates
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_ADTS_ERS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_ADTS_ERS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    //display templates
    DisplayTemplates( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    //return success
    return TRUE;
}


VOID 
DisplaySoftwareInstallations( 
                              IN IWbemServices *pNameSpace,
                              IN COAUTHIDENTITY *pAuthIdentity,
                              IN BOOL bSuperVerbose 
                              )
/*++
Routine Description

    This function displays the software installations for the system or user

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure.
    [in] BOOL               bSuperVerbose   :   is set to TRUE if the super verbose
                                                information is to be displayed.

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    CHString                    strTemp;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];

    ULONG                       ulReturned  = 0;
    DWORD                       dwTemp = 0;

    //set to zero..
    SecureZeroMemory (szTemp, sizeof (szTemp));
    SecureZeroMemory (szQueryString, sizeof (szQueryString));

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_SOFTWARE );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_SOFTWARE );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        // Enumerate the classes one by one and get the data
        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );
            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );

            // Display the GPO name
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Got the class.....get the name of the installable
            bResult = PropertyGet( pClass, CPV_APP_NAME, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_APP_NAME ) );
            ShowMessage( stdout, strTemp );

            // Get the version number
            bResult = PropertyGet( pClass, CPV_VER_HI, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            StringCchPrintf( szTemp, SIZE_OF_ARRAY(szTemp), L"%u", dwTemp );
            StringConcat( szTemp, _T( "." ), SIZE_OF_ARRAY(szTemp) );
            ShowMessage( stdout, GetResString( IDS_APP_VERSION ) );
            ShowMessage( stdout, _X(szTemp) );

            bResult = PropertyGet( pClass, CPV_VER_LO, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            StringCchPrintf( szTemp, SIZE_OF_ARRAY(szTemp), L"%u", dwTemp );
            ShowMessage( stdout, szTemp );

            // Get the Deployment state
            bResult = PropertyGet( pClass, CPV_DEPLOY_STATE, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_DEPLOY_STATE ) );
            switch( dwTemp )
            {
                case 1:      ShowMessage( stdout, GetResString( IDS_ASSIGNED ) );
                                break;
                case 2:     ShowMessage( stdout, GetResString( IDS_PUBLISHED ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }

            // Get the Deployment state
            bResult = PropertyGet( pClass, CPV_APP_SRC, strTemp, 0 );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_APP_SRC ) );
            ShowMessage( stdout, _X(strTemp) );

            // Get the auto-install information
            bResult = PropertyGet( pClass, CPV_AUTO_INSTALL, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_AUTOINSTALL ) );
            if( dwTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_TRUE ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_FALSE ) );
            }

            // Get the origin information
            ShowMessage( stdout, GetResString( IDS_ORIGIN ) );
            bResult = PropertyGet( pClass, CPV_ORIGIN, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            switch( dwTemp )
            {
                case 1:     ShowMessage( stdout, GetResString( IDS_APPLICATION ) );
                                break;
                case 2:     ShowMessage( stdout, GetResString( IDS_REMOVED ) );
                                break;
                case 3:     ShowMessage( stdout, GetResString( IDS_ARP ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID 
DisplayScripts( 
                    IN IWbemServices *pNameSpace,
                    IN BOOL bStartUp,
                    IN COAUTHIDENTITY *pAuthIdentity,
                    IN BOOL bSuperVerbose 
                    )
/*++
Routine Description

    This function displays the scripts policy setting for both start-up and
    shut-down.

Arguments:

    [in] IWbemServices      *pNamespace     :  pointer to IWbemServices.
    [in] BOOL               bScriptFlag     :   script type.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed..

Return Value:
    None
--*/

{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bLocaleChanged = FALSE;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemClassObject            *pScriptObject = NULL;

    VARIANT                     vVarScript;
    VARTYPE                     vartype;

    SAFEARRAY                   *safeArray = NULL;

    CHString                    strTemp;
    CHString                    strTemp1;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];

    ULONG                       ulReturned  = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    SYSTEMTIME                  SysTime;

    LCID                        lcid;

    try
    {

        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        if( bStartUp == TRUE )
        {
            StringCopy( szTemp, QUERY_START_UP, MAX_STRING_LENGTH );
        }
        else
        {
            StringCopy( szTemp, QUERY_SHUT_DOWN, MAX_STRING_LENGTH );
        }

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_SCRIPTS );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_SCRIPTS );
            StringConcat( szQueryString, QUERY_ADD_VERBOSE, MAX_STRING_LENGTH );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        // Enumerate the classes one by one and get the data
        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id...
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            // Display the GPO name
            StringCopy( szTemp, strTemp, MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp,  pAuthIdentity );

            // Get the script list
            VariantInit( &vVarScript );
            hResult = pClass->Get( _bstr_t( CPV_SCRIPTLIST ), 0, &vVarScript, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarScript );

            if( vVarScript.vt != VT_NULL && vVarScript.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = (VARTYPE)(V_VT( &vVarScript ) & ~VT_ARRAY);

                // Get the array of script objects into a safe array
                safeArray = ( SAFEARRAY * )vVarScript.parray;

                //get the number of subkeys
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }

                // Get the identifier values for each sub-key
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the script object interface pointer...
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, &pScriptObject, vartype );
                    CHECK_BRESULT( bResult );

                    // Get the script...
                    bResult = PropertyGet( pScriptObject, CPV_SCRIPT, strTemp, V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    ShowMessage( stdout, GetResString( IDS_NAME ) );
                    ShowMessage( stdout, strTemp );

                    // Get the arguments...
                    bResult = PropertyGet( pScriptObject, CPV_ARGUMENTS, strTemp,
                                            V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    ShowMessage( stdout, GetResString( IDS_PARAMETERS ) );
                    ShowMessage( stdout, strTemp );

                    // Get the execution time...
                    bResult = PropertyGet( pScriptObject, CPV_EXECTIME, strTemp,
                                                        V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    ShowMessage( stdout, GetResString( IDS_LASTEXECUTED ) );
                    // Check if the str is zero
                    if( strTemp.Compare( ZERO ) == 0 )
                    {
                        ShowMessage( stdout, GetResString( IDS_NOT_EXECUTED ) );
                    }
                    else
                    {
                        bResult = PropertyGet( pScriptObject, CPV_EXECTIME, SysTime );
                        CHECK_BRESULT( bResult );

                        // verify whether console supports the current locale 100% or not
                        lcid = GetSupportedUserLocale( &bLocaleChanged );

                        // now format the date
                        GetTimeFormat( LOCALE_USER_DEFAULT, 0,
                                        &SysTime, ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL),
                                        szTemp, SIZE_OF_ARRAY( szTemp ) );

                        ShowMessage( stdout, szTemp );
                    }
                    ShowMessage( stdout, NEW_LINE );
               }//end for safearray
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
                ShowMessage( stdout, NEW_LINE );

                V_VT( &vVarScript ) = VT_EMPTY;
            }

            VariantClear(&vVarScript);
        }// while
    }
    catch(_com_error & error)
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        /*ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );*/
        SAFEIRELEASE(pEnumClass);
        SAFEIRELEASE(pClass);
        SAFEIRELEASE(pScriptObject);
        VariantClear( &vVarScript );
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);
    SAFEIRELEASE(pScriptObject);
    return ;
}

VOID 
DisplayPasswordPolicy( 
                        IN IWbemServices *pNameSpace, 
                        IN COAUTHIDENTITY *pAuthIdentity,
                        IN BOOL bSuperVerbose 
                        )
/*++
Routine Description
 This function displays the password policy for the computer configuration

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed..

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;

    CHString                    strTemp;
    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];

    IWbemClassObject            *pClass         = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    SecureZeroMemory ( szTemp, sizeof (szTemp) );
    SecureZeroMemory ( szQueryString, sizeof (szQueryString) );

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_PASSWD_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_PASSWD_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        if(FAILED( hResult ) )
        {
            _com_issue_error( hResult );
        }

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            // Display the GPO name
            StringCopy( szTemp, strTemp, MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // get the key name
            bResult = PropertyGet( pClass, CPV_KEYNAME1, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage(stdout, GetResString( IDS_POLICY ) );
            ShowMessage(stdout, strTemp);

            // get the setting
            bResult = PropertyGet( pClass, CPV_SETTING1, ulReturned, 0 );
            CHECK_BRESULT( bResult );

            ShowMessage(stdout, GetResString( IDS_COMPUTER_SETTING ) );
            if( ulReturned == 0)
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }
            else
            {
                //DISPLAY_MESSAGE1( stdout, szTemp, _T( "%u" ), ulReturned );
                StringCchPrintf( szTemp, SIZE_OF_ARRAY(szTemp), _T( "%u" ), ulReturned );
                ShowMessage ( stdout, szTemp );
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID
DisplayAuditPolicy( 
                    IN IWbemServices *pNameSpace, 
                    IN COAUTHIDENTITY *pAuthIdentity,
                    IN BOOL bSuperVerbose 
                    )
/*++
Routine Description

    This function displays the Audit policy for the computer configuration.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed..

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    DWORD                       dwNoAuditing = 0;
    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    SecureZeroMemory ( szTemp, sizeof (szTemp) );
    SecureZeroMemory ( szQueryString, sizeof (szQueryString) );

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf ( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_AUDIT_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_AUDIT_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            // Get the GPO output
            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the category...
            bResult = PropertyGet( pClass, CPV_CATEGORY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_POLICY ) );
            ShowMessage( stdout, strTemp );
            ShowMessage( stdout, GetResString( IDS_COMPUTER_SETTING ) );

            // Get the success property
            bResult = PropertyGet( pClass, CPV_SUCCESS, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, CPV_SUCCESS );
            }
            else
            {
                dwNoAuditing++;
            }

            // Get the failure property
            bResult = PropertyGet( pClass, CPV_FAILURE, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                // Check if the success property is also set
                if ( dwNoAuditing == 0 )
                {
                    ShowMessage( stdout, _T( ", " ) );
                }
                ShowMessage( stdout, CPV_FAILURE );
            }
            else
            {
                dwNoAuditing++;
            }

            if( dwNoAuditing == 2 )
            {
                ShowMessage( stdout, GetResString( IDS_NO_AUDITING ) );
            }

            dwNoAuditing = 0;
            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }
    catch( CHeap_Exception )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);

    return;
}


VOID 
DisplayUserRights( 
                    IN IWbemServices *pNameSpace, 
                    IN COAUTHIDENTITY *pAuthIdentity,
                    IN BOOL bSuperVerbose 
                    )
/*++
Routine Description

    To get the User Rights Assignment policy for the output display-
    [Computer Configuration\Security Setting\Local Policies\User Rights Assignment]

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed..

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    SAFEARRAY                   *safeArray = NULL;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_USER_RIGHTS );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_USER_RIGHTS );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );

            // Display the GPO name
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the user rights
            VariantInit( &vVarVerbose );
            bResult = PropertyGet( pClass, CPV_USERRIGHT, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            strTemp = strTemp.Mid( ( strTemp.Find( EXTRA ) + 1 ), strTemp.GetLength() );
            ShowMessage( stdout, GetResString( IDS_POLICY ) );
            ShowMessage( stdout, strTemp );

            // Get the computer setting
            ShowMessage( stdout, GetResString( IDS_COMPUTER_SETTING ) );
            hResult = pClass->Get( _bstr_t( CPV_ACCOUNTLIST ), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = (VARTYPE)(V_VT( &vVarVerbose ) & ~VT_ARRAY);

                //get the array of strings in to the safe array from the variant
                safeArray = (SAFEARRAY *)vVarVerbose.parray;

                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the element from the safe array
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );

                    if( strTemp.GetLength() == 0 )
                    {
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                    }
                    else
                    {
                        ShowMessage( stdout, strTemp );
                    }
                    ShowMessage( stdout, GetResString( IDS_NEWLINE1 ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
                ShowMessage( stdout, NEW_LINE );
            }

            VariantClear(&vVarVerbose);
        }
    }

    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );

        VariantClear(&vVarVerbose);
    }
    catch( CHeap_Exception )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        VariantClear(&vVarVerbose);
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);

    return;
}


VOID 
GpoName(
            IN IWbemServices *pNameSpace,
            IN LPTSTR lpszGpoId,
            IN COAUTHIDENTITY *pAuthIdentity
            )
/*++
Routine Description

    To get the GPO name from the GPOID in the instance of any RSOP class

Arguments:

    [in] IWbemServices          *pNamespace     :   pointer to IWbemServices.
    [in] LPTSTR                     lpszGpoid               :   GPO id.
    [in] COAUTHIDENTITY *pAuthIdentity      :   pointer to the authorization structure

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                                    hResult = S_OK;

    BOOL                                           bResult = FALSE;

    IWbemClassObject                      *pClass = NULL;
    IEnumWbemClassObject               *pEnumClass = NULL;

    ULONG                                        ulReturned = 0;

    WCHAR                                         szQuery[ MAX_STRING_LENGTH ];
    CHString                                      strTemp;

    try
    {
        SecureZeroMemory( szQuery, sizeof( szQuery ) );

        // Form the query string
        StringCchPrintf( szQuery, SIZE_OF_ARRAY(szQuery), QUERY_GPO_NAME, lpszGpoId );

        // Eexecute the query to get the corressponding Gpo Name.
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                                                _bstr_t( szQuery ),
                                                                WBEM_FLAG_FORWARD_ONLY |
                                                                WBEM_FLAG_RETURN_IMMEDIATELY,
                                                                NULL, &pEnumClass);
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
        CHECK_HRESULT( hResult );

        if( ulReturned == 0 )
        {
            // Did not get the data we were looking for...
            // Display N/A if there were no classes
            ShowMessage( stdout, V_NOT_AVAILABLE );

            // Release the interface pointers
            SAFEIRELEASE(pEnumClass);
            SAFEIRELEASE(pClass);

            return;
        }

       // Found the GPO.....get the name
       bResult = PropertyGet( pClass, CPV_GPO_NAME, strTemp, V_NOT_AVAILABLE );
       CHECK_BRESULT( bResult );

       ShowMessage( stdout, strTemp );
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);

    return;
}


VOID
DisplaySecurityandEvents(
                            IN IWbemServices *pNameSpace,
                            IN BSTR pszClassName,
                            IN COAUTHIDENTITY *pAuthIdentity,
                            IN BOOL bSuperVerbose 
                        )
/*++
Routine Description

    This function displays the Security Options or Eventlog instances for the
    computer configuration.

Arguments:

    [in] pNamespace         :   pointer to IWbemServices.
    [in] pszClassName       :   classname to retrieve data from.
    [in] pAuthIdentity      :   pointer to the Authorization structure
    [in] BOOL               :   set to TRUE if the super verbose info is to be displayed

Return Value:

    None
--*/
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    DWORD                       dwTemp = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, pszClassName );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, pszClassName );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    // Check if this is the Security string class or the eventlog boolean class
                    // so that we can avoid multiple N/A's.
                    if( ( StringCompare( pszClassName, CLS_EVENTLOG_BOOLEAN, FALSE, 0 ) != 0 )
                            && ( StringCompare( pszClassName, CLS_SECURITY_STRING, FALSE, 0 ) != 0 ) )
                    {
                        ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                        ShowMessage( stdout, NEW_LINE );
                    }
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the key name
            bResult = PropertyGet( pClass, CPV_KEYNAME1, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage(stdout, GetResString( IDS_POLICY ) );
            ShowMessage( stdout, strTemp );

            // Get the setting
            if( StringCompare( pszClassName, CLS_SECURITY_STRING, FALSE, 0 ) == 0 )
            {
                bResult = PropertyGet( pClass, CPV_SETTING1, strTemp, V_NOT_AVAILABLE );
            }
            else
            {
                bResult = PropertyGet( pClass, CPV_SETTING1, dwTemp, 0 );
            }
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_COMPUTER_SETTING ) );
            if( StringCompare( pszClassName, CLS_EVENTLOG_NUMERIC, FALSE, 0 ) == 0 )
            {
                StringCchPrintf( szTemp, SIZE_OF_ARRAY(szTemp), L"%u", dwTemp );
                ShowMessage( stdout, szTemp );
            }
            else if( StringCompare( pszClassName, CLS_SECURITY_STRING, FALSE, 0 ) == 0 )
            {
                if( strTemp.Compare( V_NOT_AVAILABLE ) != 0 )
                {
                    ShowMessage( stdout, GetResString( IDS_ENABLED ) );
                }
                else
                {
                    ShowMessage( stdout, GetResString( IDS_NOT_ENABLED ) );
                }
            }
            else
            {
                if( dwTemp == VAR_TRUE )
                {
                    ShowMessage( stdout, GetResString( IDS_ENABLED ) );
                }
                else
                {
                    ShowMessage( stdout, GetResString( IDS_NOT_ENABLED ) );
                }
            }

            // Get the log name
            if( ( StringCompare( pszClassName, CLS_SECURITY_BOOLEAN, FALSE, 0 ) != 0 )
                    && ( StringCompare( pszClassName, CLS_SECURITY_STRING, FALSE, 0 ) != 0 ) )
            {
                bResult = PropertyGet( pClass, CPV_TYPE, dwTemp, 5 );
                CHECK_BRESULT( bResult );

                ShowMessage( stdout, GetResString( IDS_LOG_NAME ) );
                switch( dwTemp )
                {
                    case 0:      ShowMessage( stdout, GetResString( IDS_SYSTEM ) );
                                     break;
                    case 1:      ShowMessage( stdout, GetResString( IDS_SECURITY ) );
                                     break;
                    case 2:      ShowMessage( stdout, GetResString( IDS_APP_LOG ) );
                                     break;
                    default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                     break;
               }
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID
DisplayRestrictedGroups( 
                            IN IWbemServices *pNameSpace, 
                            IN COAUTHIDENTITY *pAuthIdentity,
                            IN BOOL bSuperVerbose
                        )
/*++
Routine Description

    Function to display the Restricted Groups policy for computer configuration

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure.
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed.

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    SAFEARRAY                   *safeArray      = NULL;


    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_RESTRICTED_GROUPS );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_RESTRICTED_GROUPS );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next instance
            hResult = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more instances to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the group name
            bResult = PropertyGet( pClass, CPV_GROUP, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_GROUPNAME ) );
            ShowMessage( stdout, strTemp );

            // Get the members of the group
            VariantInit( &vVarVerbose );
            ShowMessage( stdout, GetResString( IDS_MEMBERS ) );
            hResult = pClass->Get( _bstr_t( CPV_MEMBERS ), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = (VARTYPE) (V_VT( &vVarVerbose ) & ~VT_ARRAY);

                //get the array of strings in to the safe array from the variant
                safeArray = ( SAFEARRAY * )vVarVerbose.parray;

                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }

                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the element from the safe array
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );

                    if( strTemp.GetLength() == 0 )
                    {
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                    }
                    else
                    {
                        ShowMessage( stdout, strTemp );
                    }
                    ShowMessage( stdout, GetResString( IDS_NEWLINE2 ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }

            VariantClear( &vVarVerbose );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );

        VariantClear( &vVarVerbose );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID DisplaySystemServices( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose )
/*++
Routine Description

    This function displays the System Services policy for the computer configuration

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure.
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed.

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    DWORD                       dwTemp = 0;
    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_SYSTEM_SERVICES );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_SYSTEM_SERVICES );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next instance
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the service information
            bResult = PropertyGet( pClass, CPV_SERVICE, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage(stdout, GetResString( IDS_SERVICENAME ) );
            ShowMessage( stdout, strTemp );

            ShowMessage(stdout, GetResString( IDS_STARTUP ) );
            bResult = PropertyGet( pClass, CPV_STARTUP, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            switch( dwTemp )
            {
                case 2:     ShowMessage( stdout, GetResString( IDS_AUTOMATIC ) );
                                break;
                case 3:     ShowMessage( stdout, GetResString( IDS_MANUAL ) );
                                break;
                case 4:     ShowMessage( stdout, GetResString( IDS_DISABLED ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID 
DisplayRegistryandFileInfo( 
                            IN IWbemServices *pNameSpace, 
                            IN BSTR pszClassName,
                            IN COAUTHIDENTITY *pAuthIdentity, 
                            IN BOOL bSuperVerbose 
                            )
/*++
Routine Description

    This function displays the Registry policy or File System policy for the
    computer configuration.

Arguments:

    [in] pNamespace         :   pointer to IWbemServices.
    [in] pszClassName       :   classname to retrieve data from.
    [in] pAuthIdentity      :   pointer to the Authorization structure
    [in] BOOL               :   set to TRUE if the super verbose info is to be displayed

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, pszClassName );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, pszClassName );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next instance
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if(ulReturned == 0)
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the name
            bResult = PropertyGet( pClass, CPV_REG_FS, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_OBJECTNAME ) );
            ShowMessage( stdout, strTemp );
            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }
    catch( CHeap_Exception )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID
DisplayTemplates( 
                  IN IWbemServices *pNameSpace,
                  IN COAUTHIDENTITY *pAuthIdentity,
                  IN BOOL bSuperVerbose
                  )
/*++
Routine Description

    This function displays the Administrative Templates policy for the user and
    computer configurations.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure.
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed.


Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;
    DWORD                       dwTemp    = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    CHString                    strValueName;

    SAFEARRAY                   *psa;
    CHString                    strPropertyName = L"";;
    long                        lLBound = 0;
    long                        lUBound = 0;
    long                        i =0;
    WCHAR                       szBuffer[MAX_RES_STRING] = L"";
    VARIANT                     vtValue;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_ADMIN_TEMP, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_ADMIN );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_ADMIN_TEMP, MAX_STRING_LENGTH);
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_ADMIN );
            StringConcat( szQueryString, QUERY_ADD_VERBOSE, MAX_STRING_LENGTH );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );


         hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while(WBEM_S_NO_ERROR == hResult)
        {
//            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
//            CHECK_HRESULT( hResult );

            if(ulReturned == 0)
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, (LPCWSTR)strTemp, MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the registry value (string)
            bResult = PropertyGet( pClass, CPV_REGISTRY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );


/**********this code is added for displaying registry settings value and value name, 14-sep-2001***********/

            //get value name and append it to the key
            bResult = PropertyGet( pClass, CPV_VALUENAME, strValueName, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
            strTemp+=L"\\";
            strTemp+=strValueName;

            //display the registry value
            ShowMessage( stdout, GetResString( IDS_FR_SETTING ) );
            ShowMessage( stdout, strTemp );

/***************************************************************************************************************/

            // Get the state (Enabled/Disabled)
            bResult = PropertyGet( pClass, CPV_DELETED, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                // The deleted flag is set to TRUE for all the disabled templates
                ShowMessage( stdout, GetResString( IDS_STATE ) );
                ShowMessage( stdout, GetResString( IDS_DISABLED ) );
                ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
            }
            else
            {

/**********this code is added for displaying registry settings value and value name, 14-sep-2001***********/

                ShowMessage( stdout, GetResString( IDS_VALUE ) );
                VariantInit( &vtValue );
                hResult = pClass->Get( _bstr_t(CPV_VALUE), 0, &vtValue, NULL, NULL );
                psa = vtValue.parray;
                SafeArrayGetLBound( psa, 1, &lLBound );
                SafeArrayGetUBound( psa, 1, &lUBound );
                for( i=lLBound; i<=lUBound; i++ )
                {
                    SecureZeroMemory( szBuffer, MAX_RES_STRING );
                    dwTemp = 0;
                    SafeArrayGetElement( psa, &i, (void *)&dwTemp );
                    SecureZeroMemory( szBuffer, sizeof(szBuffer) );
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%ld", dwTemp );
                    ShowMessage( stdout, szBuffer );
                    if( i != lUBound )
                        ShowMessage( stdout, GetResString( IDS_COMMA ) );
                }
                VariantClear( &vtValue );




                //display state enabled
                ShowMessage( stdout, GetResString( IDS_STATE ) );
                ShowMessage( stdout, GetResString( IDS_ENABLED ) );
                ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
            }

/***************************************************************************************************************/

            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID 
DisplayFolderRedirection( 
                            IN IWbemServices *pNameSpace, 
                            IN COAUTHIDENTITY *pAuthIdentity,
                            IN BOOL bSuperVerbose 
                            )
/*++
Routine Description

    This function displays the Folder Redirection settings for the user configuration.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed.

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    DWORD                       dwTemp = 0;
    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    SAFEARRAY                   *safeArray = NULL;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_FOLDER_REDIRECTION );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_FOLDER_REDIRECTION );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if(ulReturned == 0)
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the folder re-direction information
            ShowMessage( stdout, GetResString( IDS_FR_SETTING ) );

            // Get the installation type
            ShowMessage( stdout, GetResString( IDS_INSTALLATIONTYPE ) );
            bResult = PropertyGet( pClass, CPV_FRINSTYPE, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            switch( dwTemp )
            {
                case 1:     ShowMessage( stdout, GetResString( IDS_BASIC ) );
                                break;
                case 2:     ShowMessage( stdout, GetResString( IDS_MAXIMUM ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }

            // Get the Grant Type
            ShowMessage( stdout, GetResString( IDS_GRANTTYPE ) );
            bResult = PropertyGet( pClass, CPV_FRGRANT, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_EXCLUSIVE ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NOTEXCLUSIVE ) );
            }

            // Get the Move type
            ShowMessage( stdout, GetResString( IDS_MOVETYPE ) );
            bResult = PropertyGet( pClass, CPV_FRMOVE, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_MOVED ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NOTMOVED ) );
            }

            // Get the removal policy
            ShowMessage( stdout, GetResString( IDS_POLICYREMOVAL ) );
            bResult = PropertyGet( pClass,  CPV_FRREMOVAL, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            switch( dwTemp )
            {
                case 1:     ShowMessage( stdout, GetResString( IDS_LEAVEFOLDER ) );
                                break;
                case 2:     ShowMessage( stdout, GetResString( IDS_REDIRECT ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }

            // Get the Redirecting group
            bResult = PropertyGet( pClass, CPV_FRSECGROUP, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_REDIRECTINGGROUP ) );
            // Compare the value got with the set of values and display the appropriate output
            if( strTemp.Compare( SID_EVERYONE ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_EVERYONE ) );
            }
            else if( strTemp.Compare( SID_NULL_SID ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_NULL_SID ) );
            }
            else if( strTemp.Compare( SID_LOCAL ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_LOCAL ) );
            }
            else if( strTemp.Compare( SID_CREATOR_OWNER ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_CREATOR_OWNER ) );
            }
            else if( strTemp.Compare( SID_CREATOR_GROUP ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_CREATOR_GROUP ) );
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }

            // Get the re-directed path
            VariantInit( &vVarVerbose );
            hResult = pClass->Get( _bstr_t( CPV_FRPATH ), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            ShowMessage( stdout, GetResString( IDS_REDIRECTEDPATH ) );
            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = (VARTYPE)(V_VT( &vVarVerbose ) & ~VT_ARRAY);

                //get the array of strings in to the safe array from the variant
                safeArray = ( SAFEARRAY * )vVarVerbose.parray;

                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the element from the Safe Array
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );

                    if( strTemp.GetLength() == 0)
                    {
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                    }
                    else
                    {
                        ShowMessage( stdout, strTemp );
                    }
                    ShowMessage( stdout, GetResString( IDS_NEWLINE1 ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }

            VariantClear( &vVarVerbose );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        VariantClear( &vVarVerbose );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


BOOL 
CGpResult::DisplayVerboseUserData( 
                                    IN PUSERINFO pUserInfo, 
                                    IN IWbemServices *pNameSpace )
/*++
Routine Description:

     This function displays the verbose data for the  scope - user

Arguments:

    [in]    IWbemServices   *pRsopNameSpace     :   interface pointer

Return Value:

  TRUE  on SUCCESS
  FALSE on FAILURE

--*/
{
    //sub-local variables
    DWORD           dwLength = 0;
    WCHAR           szName[MAX_RES_STRING]      =   L"";;
    WCHAR           szServer[MAX_RES_STRING]    =   L"";
    BOOL            bResult                     =   FALSE;
    CHString        strTemp;
    BOOL            bConnFlag                   =   FALSE;

/******this code is added to display user priviliges, 20-sep-2001***********/

    // If we have to get the information from a remote machine then...
    // connect to the remote machine for the last time execution information.
    if ( m_bLocalSystem == FALSE )
    {
        StringCopy( szServer, m_strServerName, MAX_STRING_LENGTH);
        StringCopy( szName, m_strUserName, MAX_STRING_LENGTH );

        bResult = EstablishConnection( szServer, szName, MAX_STRING_LENGTH,
                                        m_pwszPassword, MAX_STRING_LENGTH, FALSE );
        if( bResult != TRUE )
        {
            strTemp = V_NOT_AVAILABLE;
        }
        else
        {
            switch( GetLastError() )
            {
                case I_NO_CLOSE_CONNECTION:
                    bConnFlag = FALSE;
                    break;

                case E_LOCAL_CREDENTIALS:
                case ERROR_SESSION_CREDENTIAL_CONFLICT:
                    bConnFlag = FALSE;
                    break;

                default:
                    break;
            }
        }
    }


     //display the user priviliges
    ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
    ShowMessage( stdout, GetResString(IDS_USER_PRIV) );
    ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_USER_PRIV ) ); dwLength > 4; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
    DisplayUserPrivileges( (LPCWSTR)m_strServerName, pUserInfo->strUserSid, m_szUserGroups, m_NoOfGroups );
    ShowMessage( stdout, GetResString( IDS_NEWLINE ) );

    //now close the connection
    // if we have opened a connection then close the same.
    if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
    {
        CloseConnection( szServer );
    }




/**************************************************************************/
    //
    // Display the verbose information for the scope - user

    // Display the header
    ShowMessage( stdout, GetResString( IDS_USER_RESULT ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
    for( dwLength = StringLengthInBytes( GetResString( IDS_USER_RESULT ) ); dwLength > 4; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    ShowMessage( stdout, NEW_LINE );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    // Display the software installation data
    ShowMessage( stdout, GetResString( IDS_SW_SETTINGS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = StringLengthInBytes( GetResString( IDS_SW_SETTINGS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplaySoftwareInstallations( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

/******this code is added to display user logon and logoff scripts, 20-sep-2001***********/

    // Display the logging data
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SLOGON ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SLOGON ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayUserLogonScripts( pNameSpace, TRUE, m_pAuthIdentity, m_bSuperVerbose );

    // Display the scripts data
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SLOGOFF ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SLOGOFF ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayUserLogonScripts( pNameSpace, FALSE, m_pAuthIdentity, m_bSuperVerbose );

/***************************************************************************************************/

    // Display the public key policies
    // Displaying N/A for time being
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_PKP ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_WS_SS_PKP ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
    ShowMessage( stdout, V_NOT_AVAILABLE );
    ShowMessage( stdout, NEW_LINE );

    // Display the administrative template information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_ADTS_ERS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_ADTS_ERS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayTemplates( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the File Re-direction information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_USERFR ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = StringLengthInBytes( GetResString( IDS_USERFR ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayFolderRedirection( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the group policy for IE
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_IEPOLICY ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    for( dwLength = StringLengthInBytes( GetResString( IDS_IEPOLICY ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayIEPolicy( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the connection information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_PROXY ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    
    for( dwLength = StringLengthInBytes( GetResString( IDS_PROXY ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }

    DisplayIEProxySetting( pNameSpace, m_pAuthIdentity );

    // Display the IE Favorite Links or Items
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_FAVLINKORITEM ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = StringLengthInBytes( GetResString( IDS_FAVLINKORITEM ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayIEImpURLS( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    DisplayIEFavorites( pNameSpace, m_pAuthIdentity );

    // Display the security content ratings
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_IE_SECURITY ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = StringLengthInBytes( GetResString( IDS_IE_SECURITY ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayIESecurityContent( pNameSpace, m_pAuthIdentity );
    DisplayIESecurity( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the secutrity zone settings
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_IE_PROGRAMS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    
    for( dwLength = StringLengthInBytes( GetResString( IDS_IE_PROGRAMS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    
    DisplayIEPrograms( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    return TRUE;
}

VOID 
DisplayIEPolicy( 
                IN IWbemServices *pNameSpace,
                IN COAUTHIDENTITY *pAuthIdentity,
                IN BOOL bSuperVerbose 
                )
/*++
Routine Description

    This function displays the IE policy settings for the user configuration.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed.

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_IE_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_IE_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the bit-map name
            bResult = PropertyGet( pClass, CPV_BITMAPNAME, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_BITMAPNAME ) );
            ShowMessage( stdout, strTemp );

            // Get the Logo bitmap name
            bResult = PropertyGet( pClass, CPV_LOGOBITMAPNAME, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_LOGOBITMAPNAME ) );
            ShowMessage( stdout, strTemp );

            // Get the title bar text
            bResult = PropertyGet( pClass, CPV_TITLEBARTEXT, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_TITLEBARTEXT ) );
            ShowMessage( stdout, strTemp );

            // Get the user agent text
            bResult = PropertyGet( pClass, CPV_USERAGENTTEXT, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_USERAGENTTEXT ) );
            ShowMessage( stdout, strTemp );

            // Get the info., wether to delete the existing toolbar buttons
            bResult = PropertyGet( pClass, CPV_TOOL_BUTTONS, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_TOOL_BUTTONS ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }
    catch( CHeap_Exception )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID 
DisplayIEFavorites( 
                    IN IWbemServices *pNameSpace, 
                    IN  COAUTHIDENTITY *pAuthIdentity 
                    )
/*++
Routine Description

    This function displays the IE favorites information.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;

    ULONG                       ulReturned = 0;
    DWORD                       dwTemp = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );

        // Enumerate the classes
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_IE_FAVLINKORITEM ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY,
                                                    NULL, &pEnumClass);
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                break;
            }

            // Get the URL information
            bResult = PropertyGet( pClass, CPV_URL, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_URL ) );
            ShowMessage( stdout, strTemp );

            // Get the information on wether the site is available off line
            bResult = PropertyGet( pClass, CPV_AVAILOFFLINE, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_AVAILABLE ) );
            if( dwTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID
DisplayIESecurityContent( 
                            IN  IWbemServices *pNameSpace, 
                            IN COAUTHIDENTITY *pAuthIdentity 
                            )
/*++
Routine Description

    This function displays the IE security contents information.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    SAFEARRAY                   *safeArray = NULL;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );

        // enumerate the classes
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_IE_SECURITY_CONTENT ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY,
                                                    NULL, &pEnumClass);
        CHECK_HRESULT( hResult );

        // set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no instances in both the security classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }

            // Got a class...set the flag
            bGotClass = TRUE;

            // Get the viewable sites information
            VariantInit( &vVarVerbose );
            ShowMessage( stdout, GetResString( IDS_VIEWABLESITES ) );
            hResult = pClass->Get( _bstr_t( CPV_ALWAYSVIEW ), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = (VARTYPE)(V_VT( &vVarVerbose ) & ~VT_ARRAY);

                //get the array of strings in to the safe array from the variant
                safeArray = ( SAFEARRAY * )vVarVerbose.parray;

                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the element from the safe array
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );

                    if( strTemp.GetLength() == 0 )
                    {
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                    }
                    else
                    {
                        ShowMessage( stdout, strTemp );
                    }
                    ShowMessage( stdout, GetResString( IDS_NEWLINE1 ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }

            // Get the password over-ride information
            ShowMessage( stdout, GetResString( IDS_PASSWORDOVERRIDE ) );
            bResult = PropertyGet( pClass, CPV_ENABLEPASSWORD, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_TRUE ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_FALSE ) );
            }

            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );

            VariantClear(&vVarVerbose);
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        VariantClear(&vVarVerbose);
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID 
DisplayIESecurity( 
                    IN IWbemServices *pNameSpace,
                    IN COAUTHIDENTITY *pAuthIdentity,
                    IN BOOL bSuperVerbose 
                    )
/*++
Routine Description

    This function displays the IE security information.

Arguments:

    [in] IWbemServices      *pNamespace         :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity      :   pointer to the authorization structure


Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString,SIZE_OF_ARRAY(szQueryString), szTemp, CLS_IE_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_IE_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                break;
            }

            // Got a class...set the flag
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the Security content information
            bResult = PropertyGet( pClass, CPV_SEC_CONTENT, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_CONTENT_SETTING ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            // Get the Security zone information
            bResult = PropertyGet( pClass, CPV_SEC_ZONE, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_ZONE_SETTING ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            // Get the Authenticode information
            bResult = PropertyGet( pClass, CPV_AUTH_CODE, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_AUTH_SETTING ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            // Get the trusted publisher lock down information
            bResult = PropertyGet( pClass, CPV_TRUST_PUB, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_TRUST_PUB ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }
    catch( CHeap_Exception )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID 
DisplayIEProxySetting( 
                        IN IWbemServices *pNameSpace, 
                        IN COAUTHIDENTITY *pAuthIdentity 
                        )
/*++
Routine Description

    This function displays the IE proxy information.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure


Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    DWORD                       dwTemp = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );

        // Enumerate the classes
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_IE_CONNECTION ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY,
                                                    NULL, &pEnumClass);
        CHECK_HRESULT( hResult );

        // set the security interface
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the http proxy information
            bResult = PropertyGet( pClass, CPV_HTTP_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_HTTP_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the Secure proxy information
            bResult = PropertyGet( pClass, CPV_SECURE_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_SECURE_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the ftp proxy information
            bResult = PropertyGet( pClass, CPV_FTP_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_FTP_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the Gopher proxy information
            bResult = PropertyGet( pClass, CPV_GOPHER_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_GOPHER_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the socks proxy information
            bResult = PropertyGet( pClass, CPV_SOCKS_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_SOCKS_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the Auto config enable information
            ShowMessage( stdout, GetResString( IDS_AUTO_CONFIG_ENABLE ) );
            bResult = PropertyGet( pClass, CPV_AUTO_CONFIG_ENABLE, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            if( dwTemp == -1 )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            // Get the info on wether or not the proxy is enabled
            ShowMessage( stdout, GetResString( IDS_ENABLE_PROXY ) );
            bResult = PropertyGet( pClass, CPV_ENABLE_PROXY, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            if( dwTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            // Get the info on wether or not to use the same proxy
            ShowMessage( stdout, GetResString( IDS_USE_SAME_PROXY ) );
            bResult = PropertyGet( pClass, CPV_USE_SAME_PROXY, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            if( dwTemp == -1 )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID
DisplayIEPrograms(
                    IN IWbemServices *pNameSpace, 
                    IN COAUTHIDENTITY *pAuthIdentity,
                    IN BOOL bSuperVerbose
                    )
/*++
Routine Description

    This function displays the IE program settings for the user configuration.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed.

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_IE_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH);
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_IE_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the program information
            bResult = PropertyGet( pClass, CPV_PROGRAM, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_PROGRAM_SETTING ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID
DisplayIEImpURLS( 
                 IN IWbemServices *pNameSpace, 
                 IN COAUTHIDENTITY *pAuthIdentity,
                 IN BOOL bSuperVerbose 
                 )
/*++
Routine Description

    This function displays the information on the important URLs.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed.

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        SecureZeroMemory( szTemp, sizeof( szTemp ) );
        SecureZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            StringCopy( szTemp, QUERY_SUPER_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_IE_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            StringCopy( szTemp, QUERY_VERBOSE, MAX_STRING_LENGTH );
            StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_IE_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ),
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            StringCopy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ), MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the home page URL
            bResult = PropertyGet( pClass, CPV_HOMEPAGEURL, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_HOMEPAGEURL ) );
            ShowMessage( stdout, strTemp );

            // Get the search bar URL
            bResult = PropertyGet( pClass, CPV_SEARCHBARURL, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_SEARCHBARURL ) );
            ShowMessage( stdout, strTemp );

            // Get the Online Help Page URL
            bResult = PropertyGet( pClass, CPV_HELPPAGEURL, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_HELPPAGEURL ) );
            ShowMessage( stdout, strTemp );

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }
    catch( CHeap_Exception )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );

    return;
}


VOID
DisplayUserPrivileges(
                   LPCWSTR szServerName,
                   CHString strSid,
                   LPWSTR *szGroups,
                   DWORD   dwNoOfGroups
                   )
/*++
Routine Description

    This function is added to display user security priviliges

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed.

Return Value:

    None
--*/
{
    //sub-local variables
    DWORD                   dw                                      =   0;
    WCHAR                   szPrivilegeDisplayName[MAX_RES_STRING]  =   L"";
    DWORD                   dwDisplayNameSize                       =   MAX_RES_STRING;
    LSA_HANDLE              lsaPolicyHandle                         =   NULL;
    LSA_UNICODE_STRING      lsaSystemName;
    LSA_OBJECT_ATTRIBUTES   lsaObjectAttributes;
    PSID                    pSid                                    =   NULL;
    ULONG                   lRightsCount;
    NTSTATUS                ntStatus;
    WCHAR                   szBuffer[1024];
    DWORD                   dwLocaleid;
    LPWSTR                      szAccountName=NULL;
    LPLOCALGROUP_USERS_INFO_0   pBuffer=NULL;
    PLSA_UNICODE_STRING         pUserRights=NULL;
    LPWSTR                      szTraversedRights=NULL;
    DWORD                       cb=0;
    LPWSTR                      szTemp = NULL;

    
    SecureZeroMemory( &lsaSystemName, sizeof(LSA_UNICODE_STRING)); 
    if( StringLength(szServerName, 0)!=0 )
    {
        dw = StringLength(szServerName, 0);
        lsaSystemName.Length = (USHORT) dw*sizeof(WCHAR);
        lsaSystemName.MaximumLength = (USHORT)(dw+1)*sizeof(WCHAR);
        lsaSystemName.Buffer = (PWSTR)szServerName;
    }

    //intialize object attributes
    SecureZeroMemory( &lsaObjectAttributes, sizeof(lsaObjectAttributes) );

    ntStatus = LsaOpenPolicy( &lsaSystemName, &lsaObjectAttributes, POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION, &lsaPolicyHandle ) ;
    if( STATUS_SUCCESS != ntStatus)
    {
        SetLastError( LsaNtStatusToWinError(ntStatus) );
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return;
    }

    //convert string form of sid to sid structure
    if( 0 == ConvertStringSidToSid( (LPCWSTR)strSid, &pSid ) )
    {
        SaveLastError();
        SecureZeroMemory( szBuffer, sizeof(szBuffer) );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        LsaClose(lsaPolicyHandle);
        return;
    }

    for( dw=0;dw<dwNoOfGroups; dw++ )
    {
        //convert string form of sid to sid structure
        if( 0 == ConvertStringSidToSid( szGroups[dw], &pSid ) )
        {
            SaveLastError();
            SecureZeroMemory( szBuffer, sizeof(szBuffer) );
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            LsaClose(lsaPolicyHandle);
            return;
        }

        //enumerate the rights of user group
          ntStatus = LsaEnumerateAccountRights( lsaPolicyHandle,  pSid, &pUserRights, &lRightsCount );
          if(ntStatus == STATUS_SUCCESS )
          {
                for(DWORD dw1=0;dw1<lRightsCount;dw1++ )
                {
                    dwDisplayNameSize = MAX_RES_STRING;
                    LookupPrivilegeDisplayName( szServerName, pUserRights[dw1].Buffer, szPrivilegeDisplayName, &dwDisplayNameSize, &dwLocaleid );
                    cb+= StringLength(szPrivilegeDisplayName, 0)+10;
                    if( StringLengthW(szPrivilegeDisplayName, 0)!= 0 )
                    {
                        if( NULL == szTraversedRights  )
                        {
                            DISPLAY_MESSAGE( stdout, GetResString( IDS_NEWLINETAB ) );
                            DISPLAY_MESSAGE( stdout, szPrivilegeDisplayName );
                            szTraversedRights = (LPWSTR)AllocateMemory(cb*sizeof(WCHAR) );
                            if ( NULL == szTraversedRights)
                            {
                                ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                                return;
                            }
                            StringCopy( szTraversedRights, szPrivilegeDisplayName, GetBufferSize(szTraversedRights)/sizeof(WCHAR) );
                            SecureZeroMemory( szPrivilegeDisplayName, MAX_RES_STRING );
                        }
                        else
                        {
                            if( (szTemp=(LPWSTR)FindString(szTraversedRights, szPrivilegeDisplayName,0)) == NULL )
                            {
                                DISPLAY_MESSAGE( stdout, GetResString( IDS_NEWLINETAB ) );
                                DISPLAY_MESSAGE( stdout, szPrivilegeDisplayName );
                                if( FALSE == ReallocateMemory((LPVOID*)&szTraversedRights, cb*sizeof(WCHAR) ) )
                                {
                                    ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                                    return;
                                }
                                StringConcat( szTraversedRights, szPrivilegeDisplayName, GetBufferSize(szTraversedRights)/sizeof(WCHAR));
                                StringConcat( szTraversedRights, L" ", GetBufferSize(szTraversedRights)/sizeof(WCHAR));
                                SecureZeroMemory( szPrivilegeDisplayName, MAX_RES_STRING );
                            }
                        }
                    }
                }
          }
                
      LsaFreeMemory( pUserRights );
      LocalFree(pSid);
      pUserRights = NULL;
      lRightsCount = 0;
    }

    if( szTraversedRights != NULL )
    {
        FreeMemory ( (LPVOID*) &szTraversedRights );
    }

    if( pUserRights != NULL )
    {
        LsaFreeMemory( pUserRights );
    }

    if( 0 == ConvertStringSidToSid( (LPCWSTR)strSid, &pSid ) )
    {
            SaveLastError();
            SecureZeroMemory( szBuffer, sizeof(szBuffer) );
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            LsaClose(lsaPolicyHandle);
            return;
    }
/*
    // now bring the direct rights of user
      ntStatus = LsaEnumerateAccountRights( lsaPolicyHandle,  pSid, &pUserRights, &lRightsCount );
      if(ntStatus != STATUS_SUCCESS )
      {
        LsaClose(lsaPolicyHandle);
        NetApiBufferFree(pBuffer);
        LocalFree(pSid);
        return;
      }

      for( dw=0;dw<lRightsCount;dw++ )
        {
            DISPLAY_MESSAGE( stdout, GetResString( IDS_NEWLINETAB ) );
            dwDisplayNameSize = MAX_RES_STRING;
            LookupPrivilegeDisplayName( szServerName, pUserRights[dw].Buffer, szPrivilegeDisplayName, &dwDisplayNameSize, &dwLocaleid );
            DISPLAY_MESSAGE( stdout, szPrivilegeDisplayName );
        }
*/

     if( pUserRights != NULL )
    {
        LsaFreeMemory( pUserRights );
    }

    if( szAccountName != NULL )
    {
        FreeMemory ((LPVOID*) &szAccountName);
    }


    if( pBuffer != NULL )
    {
            NetApiBufferFree(pBuffer);
    }

    LocalFree(pSid);
    LsaClose(lsaPolicyHandle);
    return;

}

/**** this code is added to print the logon and logoff scripts, 15-sep-2001 ******/
VOID
DisplayUserLogonScripts( 
                            IN IWbemServices *pNameSpace,
                            IN BOOL bStartUp,
                            IN COAUTHIDENTITY *pAuthIdentity, 
                            IN BOOL bSuperVerbose 
                            )
/*++
Routine Description

    This function displays the scripts policy setting for both Logon and
    Logoff.

Arguments:

    [in] IWbemServices      *pNamespace     :  pointer to IWbemServices.
    [in] BOOL               bScriptFlag     :   script type.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose
                                                info is to be displayed..

Return Value:

    None
--*/
{
    //sub-local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bLocaleChanged = FALSE;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemClassObject            *pScriptObject = NULL;

    VARIANT                     vVarScript;
    VARTYPE                     vartype;

    SAFEARRAY                   *safeArray = NULL;

    CHString                    strTemp;
    CHString                    strTemp1;

    WCHAR                       szTemp[ MAX_STRING_LENGTH ];
    WCHAR                       szQueryString [ MAX_STRING_LENGTH ];

    ULONG                       ulReturned  = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    SYSTEMTIME                  SysTime;

    LCID                        lcid;

   try
   {

    StringCopy( szTemp, QUERY_USER_LOGON_SCRIPT,MAX_STRING_LENGTH );

    // Form the query string
    if( bSuperVerbose == TRUE )
    {
        // ennumerate all the classes
        StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString),  szTemp, CLS_SCRIPTS );
    }
    else
    {
        // ennumerate all the classes with precedance = 1
        StringCchPrintf( szQueryString, SIZE_OF_ARRAY(szQueryString), szTemp, CLS_SCRIPTS );
        StringConcat( szQueryString, QUERY_ADD_VERBOSE, MAX_STRING_LENGTH );
    }

    // Get the pointer to ennumerate with
    hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                        _bstr_t( szQueryString ),
                                        WBEM_FLAG_FORWARD_ONLY |
                                        WBEM_FLAG_RETURN_IMMEDIATELY,
                                        NULL, &pEnumClass );
    CHECK_HRESULT( hResult );

    // Set the interface security
    hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
    CHECK_HRESULT( hResult );

    // Enumerate the classes one by one and get the data
    hResult = WBEM_S_NO_ERROR;
    while( WBEM_S_NO_ERROR == hResult )
    {
        // Get the next class
        hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
        CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            
            bGotClass = TRUE;

            // Get the script id...
            bResult = PropertyGet( pClass, CPV_SCRIPT_ID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            if( bStartUp && -1 == strTemp.Find(L"Logon"))           //script to display is logon
            {
                    continue;
            }

            if( !bStartUp && -1 == strTemp.Find(L"Logoff"))
            {
                    continue;
            }


            // Get the GPO id...
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            // Display the GPO name
            StringCopy( szTemp, strTemp, MAX_STRING_LENGTH );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp,  pAuthIdentity );

            //get the script name
            // Get the script list
            VariantInit( &vVarScript );
            hResult = pClass->Get( _bstr_t( CPV_SCRIPTLIST ), 0, &vVarScript, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarScript );

            if( vVarScript.vt != VT_NULL && vVarScript.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = (VARTYPE)(V_VT( &vVarScript ) & ~VT_ARRAY);

                // Get the array of script objects into a safe array
                safeArray = ( SAFEARRAY * )vVarScript.parray;

                //get the number of subkeys
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }

                // Get the identifier values for each sub-key
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the script object interface pointer...
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, &pScriptObject, vartype );
                    CHECK_BRESULT( bResult );

                    // Get the script...
                    bResult = PropertyGet( pScriptObject, CPV_SCRIPT, strTemp, V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    ShowMessage( stdout, GetResString( IDS_NAME ) );
                    ShowMessage( stdout, strTemp );

                    // Get the arguments...
                    bResult = PropertyGet( pScriptObject, CPV_ARGUMENTS, strTemp,
                                            V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    ShowMessage( stdout, GetResString( IDS_PARAMETERS ) );
                    ShowMessage( stdout, strTemp );

                    // Get the execution time...
                    bResult = PropertyGet( pScriptObject, CPV_EXECTIME, strTemp,
                                                        V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    ShowMessage( stdout, GetResString( IDS_LASTEXECUTED ) );
                    // Check if the str is zero
                    if( strTemp.Compare( ZERO ) == 0 )
                    {
                        ShowMessage( stdout, GetResString( IDS_NOT_EXECUTED ) );
                    }
                    else
                    {
                        bResult = PropertyGet( pScriptObject, CPV_EXECTIME, SysTime );
                        CHECK_BRESULT( bResult );

                        // verify whether console supports the current locale 100% or not
                        lcid = GetSupportedUserLocale( &bLocaleChanged );

                        // now format the date
                        GetTimeFormat( LOCALE_USER_DEFAULT, 0,
                                        &SysTime, ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL),
                                        szTemp, SIZE_OF_ARRAY( szTemp ) );

                        ShowMessage( stdout, szTemp );
                    }
                    ShowMessage( stdout, NEW_LINE );
               }//end for safearray
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
                ShowMessage( stdout, NEW_LINE );

                V_VT( &vVarScript ) = VT_EMPTY;
            }

            VariantClear(&vVarScript);
        }// while
    }
    catch(_com_error & error)
    {
        WMISaveError( error.Error() );
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        VariantClear( &vVarScript );
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);
    SAFEIRELEASE(pScriptObject);


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\verboseloggingdata.h ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    VerboseLoggingData.h

Abstract:

    Header file containing the constants and function prototypes pertaining to the
    Verbose information display

Author:

    Wipro Technologies

Revision History:

    22-Feb-2001 : Created It.

*********************************************************************************************/
#ifndef _GVERBOSE_H
#define _GVERBOSE_H

//
// constants
// CLS stands for class
#define CLS_WIN32_DOMAIN            _T( "Win32_ComputerSystem" )
#define CLS_WIN32_USER              _T( "Win32_UserAccount" )
#define CLS_SOFTWARE                _T( "RSOP_ApplicationManagementPolicySetting" )
#define CLS_PASSWD_POLICY           _T( "RSOP_SecuritySettingNumeric" )
#define CLS_SECURITY_BOOLEAN        _T( "RSOP_SecuritySettingBoolean" )
#define CLS_SECURITY_STRING         _T( "RSOP_SecuritySettingString" )
#define CLS_SCRIPTS                 _T( "RSOP_ScriptPolicySetting" )
#define CLS_EVENTLOG_BOOLEAN        _T( "RSOP_SecurityEventLogSettingBoolean"  )
#define CLS_EVENTLOG_NUMERIC        _T( "RSOP_SecurityEventLogSettingNumeric"  )
#define CLS_USER_RIGHTS             _T( "RSOP_UserPrivilegeRight"  )
#define CLS_AUDIT_POLICY            _T( "RSOP_AuditPolicy"  )
#define CLS_RESTRICTED_GROUPS       _T( "RSOP_RestrictedGroup" )
#define CLS_SYSTEM_SERVICES         _T( "RSOP_SystemService" )
#define CLS_REGISTRY                _T( "RSOP_RegistryKey" )
#define CLS_FILE                    _T( "RSOP_File" )
#define CLS_ADMIN                   _T( "RSOP_RegistryPolicySetting" )
#define CLS_FOLDER_REDIRECTION      _T( "RSOP_FolderRedirectionPolicySetting" )
#define CLS_IE_FAVLINKORITEM        _T( "RSOP_IEFavoriteOrLinkItem" )
#define CLS_IE_SECURITY_CONTENT     _T( "RSOP_IESecurityContentRatings" )
#define CLS_IE_SECURITY_ZONE        _T( "RSOP_IESecurityZoneSettings" )
#define CLS_IE_CONNECTION           _T( "RSOP_IEConnectionSettings" )
#define CLS_IE_POLICY               _T( "RSOP_IEAKPolicySetting" )

// Class Property Value
#define CPV_ID                      _T( "id" )
#define CPV_GPOID                   _T( "GPOID" )
#define CPV_KEYNAME1                _T( "Keyname" )
#define CPV_SETTING1                _T( "Setting" )
#define CPV_TYPE                    _T( "Type" )
#define CPV_REG_FS                  _T( "Path" )
#define CPV_SCRIPTLIST              _T( "scriptList" )
#define CPV_USERRIGHT               _T( "UserRight" )
#define CPV_ACCOUNTLIST             _T( "AccountList" )
#define CPV_CATEGORY                _T( "Category" )
#define CPV_SUCCESS                 _T( "Success" )
#define CPV_FAILURE                 _T( "Failure" )
#define CPV_GROUP                   _T( "GroupName" )
#define CPV_MEMBERS                 _T( "Members" )
#define CPV_SERVICE                 _T( "Service" )
#define CPV_STARTUP                 _T( "StartupMode" )
#define CPV_PRECEDENCE              _T( "precedence" )
#define CPV_REGISTRY                _T( "registryKey" )
#define CPV_AUTO_INSTALL            _T( "DemandInstallable" )
#define CPV_ORIGIN                  _T( "EntryType" )
#define CPV_SCRIPT                  _T( "script" )
#define CPV_ARGUMENTS               _T( "arguments" )
#define CPV_EXECTIME                _T( "executionTime" )
#define CPV_DELETED                 _T( "deleted" )
#define CPV_VALUE                   _T( "Value" )
#define CPV_VALUENAME               _T( "valueName" )
#define CPV_SCRIPT_ID               _T( "id" )

// Properties for folder re-direction
#define CPV_FRINSTYPE               _T( "installationType" )
#define CPV_FRSECGROUP              _T( "redirectingGroup" )
#define CPV_FRPATH                  _T( "redirectedPaths" )
#define CPV_FRGRANT                 _T( "grantType" )
#define CPV_FRMOVE                  _T( "moveType" )
#define CPV_FRREMOVAL               _T( "policyRemoval" )

// Properties for IE settings
#define CPV_HOMEPAGEURL             _T( "homePageURL" )
#define CPV_SEARCHBARURL            _T( "searchBarURL" )
#define CPV_HELPPAGEURL             _T( "onlineHelpPageURL" )
#define CPV_BITMAPNAME              _T( "largeAnimatedBitmapName" )
#define CPV_LOGOBITMAPNAME          _T( "largeCustomLogoBitmapName" )
#define CPV_USERAGENTTEXT           _T( "userAgentText" )
#define CPV_TITLEBARTEXT            _T( "titleBarCustomText" )
#define CPV_ALWAYSVIEW              _T( "alwaysViewableSites" )
#define CPV_ENABLEPASSWORD          _T( "passwordOverrideEnabled" )
#define CPV_DISPLAY_NAME            _T( "displayName" )
#define CPV_ZONEMAPPINGS            _T( "zoneMappings" )
#define CPV_URL                     _T( "url" )
#define CPV_AVAILOFFLINE            _T( "makeAvailableOffline" )
#define CPV_HTTP_PROXY              _T( "httpProxyServer" )
#define CPV_SECURE_PROXY            _T( "secureProxyServer" )
#define CPV_FTP_PROXY               _T( "ftpProxyServer" )
#define CPV_GOPHER_PROXY            _T( "gopherProxyServer" )
#define CPV_SOCKS_PROXY             _T( "socksProxyServer" )
#define CPV_AUTO_CONFIG_ENABLE      _T( "autoConfigEnable" )
#define CPV_ENABLE_PROXY            _T( "enableProxy" )
#define CPV_USE_SAME_PROXY          _T( "useSameProxy" )
#define CPV_PROGRAM                 _T( "importProgramSettings" )
#define CPV_SEC_CONTENT             _T( "importContentRatingsSettings" )
#define CPV_SEC_ZONE                _T( "importSecurityZoneSettings" )
#define CPV_AUTH_CODE               _T( "importAuthenticodeSecurityInfo" )
#define CPV_TRUST_PUB               _T( "enableTrustedPublisherLockdown" )
#define CPV_TOOL_BUTTONS            _T( "deleteExistingToolbarButtons" )

// Software Installation
#define CPV_APP_NAME                _T( "name" )
#define CPV_VER_HI                  _T( "VersionNumberHi" )
#define CPV_VER_LO                  _T( "VersionNumberLo" )
#define CPV_DEPLOY_STATE            _T( "DeploymentType" )
#define CPV_APP_SRC                 _T( "PackageLocation" )

#define FPR_STARTUP                 _T( "startup" )
#define FPR_SHUTDOWN                _T( "shutdown" )

// Query Strings
#define QUERY_VERBOSE               _T( "SELECT * from %s WHERE precedence=1" )
#define QUERY_SUPER_VERBOSE         _T( "SELECT * from %s" )
#define QUERY_START_UP              _T( "Select * from %s WHERE ScriptType=3" )
#define QUERY_SHUT_DOWN             _T( "Select * from %s WHERE ScriptType=4" )
#define QUERY_LOGON_SCRIPT          _T( "Select * from %s WHERE ScriptType=1" )
#define QUERY_LOGOFF_SCRIPT         _T( "Select * from %s WHERE ScriptType=2" )
#define QUERY_USER_LOGON_SCRIPT     _T( "Select * from %s WHERE ScriptOrder=1" )
#define QUERY_ADMIN_TEMP            _T( "Select * from %s WHERE (valueType = 1 OR valueType = 4 OR Deleted = TRUE)" )
#define QUERY_ADD_VERBOSE           _T( " AND precedence=1" )

//
// function prototypes
VOID DisplaySoftwareInstallations( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                    BOOL bSuperVerbose );

VOID DisplayPasswordPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose );

VOID DisplayAuditPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose );

VOID DisplayUserRights( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose);

VOID DisplayFolderRedirection( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                BOOL bSuperVerbose );

VOID DisplayRestrictedGroups( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                BOOL bSuperVerbose );

VOID DisplaySystemServices( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose );

VOID DisplayScripts( IWbemServices *pNameSpace, BOOL bScriptFlag,
                        COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose );

VOID DisplaySecurityandEvents( IWbemServices *pNameSpace, BSTR pszClassName,
                                COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose );

VOID DisplayRegistryandFileInfo( IWbemServices *pNameSpace, BSTR pszClassName,
                                    COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose );

VOID DisplayTemplates( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

VOID GpoName( IWbemServices *pNameSpace, LPTSTR lpszGpoid,
                            COAUTHIDENTITY *pAuthIdentity );

VOID DisplayIEPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

VOID DisplayIEFavorites( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity );

VOID DisplayIESecurityContent( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity );

VOID DisplayIESecurity( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

VOID DisplayIEPrograms( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

VOID DisplayIEProxySetting( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity );

VOID DisplayIEImpURLS( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

//these functions is added to display logon and logoff scripts, 15-sep-2001

VOID DisplayUserLogonScripts( IWbemServices *pNameSpace, BOOL bStartUp,
                      COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose );

VOID DisplayUserPrivileges( LPCWSTR strServerName, CHString strSid, LPWSTR* szUserGroups, DWORD dwNoOfGroups );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\wmi.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//      WMI.h
//
//  Abstract:
//
//      Common functionality for WMI
//
//  Author:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//
//  Revision History:
//
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )    \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \
    1

#define SAFE_EXECUTE( statement )               \
    hr = statement;     \
    if ( FAILED( hr ) ) \
    {   \
        _com_issue_error( hr ); \
    }   \
    1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2     L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT   L"root\\default"

#define WMI_CLAUSE_AND          L"AND"
#define WMI_CLAUSE_OR           L"OR"
#define WMI_CLAUSE_WHERE        L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem   L"Win32_OperatingSystem"

#define WMI_REGISTRY                    L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE      L"GetStringValue"
#define WMI_REGISTRY_M_DWORDVALUE       L"GetDwordValue"

#define WMI_REGISTRY_IN_HDEFKEY         L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY          L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME       L"sValueName"
#define WMI_REGISTRY_OUT_VALUE          L"sValue"
#define WMI_REGISTRY_OUT_VALUE_DWORD    L"uValue"
#define WMI_REGISTRY_OUT_RETURNVALUE    L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT               2147483648
#define WMI_HKEY_CURRENT_USER               2147483649
#define WMI_HKEY_LOCAL_MACHINE              2147483650
#define WMI_HKEY_USERS                      2147483651
#define WMI_HKEY_CURRENT_CONFIG             2147482652

// messages
// #define ERROR_COM_ERROR                  GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator,
                 IWbemServices** ppServices,
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword,
                 COAUTHIDENTITY** ppAuthIdentity,
                 BOOL bCheckWithNullPwd = FALSE,
                 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2,
                 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator,
                   IWbemServices** ppServices,
                   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword,
                   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE,
                   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject,
                     LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,
                  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  BOOL& dwValue, BOOL bDefault = FALSE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey,
                       LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName,
                       CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices,
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName,
                       LPCWSTR pwszValueName, DWORD& dwValue, DWORD dwDefault = 0 );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, CHString& strValue,
                                VARTYPE vartype );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex,
                                IWbemClassObject **pScriptObject, VARTYPE vartype );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//
// Arguments:
//
// Return Value:
//
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
    WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\gpresult\wmi.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    WMI.cpp

Abstract:

    Common functionlity for dealing with WMI.

Author:

    Wipro Technologies

Revision History:

    22-Dec-2000 : Created It.
    24-Apr-2001 : Closing the review comments given by client.

*********************************************************************************************/

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD              GetResString( IDS_STR_INPUT_PASSWORD )

// error constants
#define E_SERVER_NOTFOUND           0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface,
                              DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface,
                              LPCWSTR pwszServer, LPCWSTR pwszUser,
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword,
                                      LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices,
                          LPCWSTR pwszMethod, DWORD dwHDefKey,
                          LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );

/*********************************************************************************************
Routine Description:

    Checks wether the User name is a valid one or not

Arguments:

    [in] LPCWSTR    :   String containing the user name

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
    // local variables
    CHString strUser;
    LONG lPos = 0;

    if ( pwszUser == NULL )
    {
        return TRUE;
    }

    try
    {
        // get user into local memory
        strUser = pwszUser;

        // user name should not be just '\'
        if ( strUser.CompareNoCase( L"\\" ) == 0 )
        {
            return FALSE;
        }

        // user name should not contain invalid characters
        if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
        {
            return FALSE;
        }

        // SPECIAL CHECK
        // check for multiple '\' characters in the user name
        lPos = strUser.Find( L'\\' );
        if ( lPos != -1 )
        {
            // '\' character exists in the user name
            // strip off the user info upto first '\' character
            // check for one more '\' in the remaining string
            // if it exists, invalid user
            strUser = strUser.Mid( lPos + 1 );
            lPos = strUser.Find( L'\\' );
            if ( lPos != -1 )
            {
                return FALSE;
            }
        }
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        return FALSE;
    }

    // user name is valid
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Checks wether the Server name is a valid one or not

Arguments:

    [in]  LPCWSTR   :   String containing the user name
    [out] BOOL      :   Is set to TRUE if the local system is being queried.

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem )
{
    // local variables
    CHString strTemp;

    if ( pwszServer == NULL )
    {
        return FALSE;
    }

    // kick-off
    bLocalSystem = FALSE;

    // get a local copy
    strTemp = pwszServer;

    // remove the forward slashes (UNC) if exist in the begining of the server name
    if ( IsUNCFormat( strTemp ) == TRUE )
    {
        strTemp = strTemp.Mid( 2 );
        if ( strTemp.GetLength() == 0 )
        {
            return FALSE;
        }
    }

    // now check if any '\' character appears in the server name. If so error
    if ( strTemp.Find( L'\\' ) != -1 )
    {
        return FALSE;
    }

    // now check if server name is '.' only which represent local system in WMI
    // else determine whether this is a local system or not
    if ( strTemp.CompareNoCase( L"." ) == 0 )
    {
        bLocalSystem = TRUE;
    }
    else
    {
        bLocalSystem = IsLocalSystem( strTemp );
    }

    // inform that server name is valid
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Initializes the COM library

Arguments:

    [in] IWbemLocator   :   pointer to the IWbemLocator

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL InitializeCom( IWbemLocator** ppLocator )
{
    // local variables
    HRESULT hr;
    BOOL bResult = FALSE;

    try
    {
        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // initialize the COM library
        SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED ) );

        // initialize the security
        SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

        // create the locator and get the pointer to the interface of IWbemLocator
        SAFE_RELEASE( *ppLocator );         // safe side
        SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

        // initialization successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the WMI error
        WMISaveError( e );
    }

    // return the result;
    return bResult;
}

/*********************************************************************************************
Routine Description:

    This function makes a connection to WMI.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL ConnectWmi( IWbemLocator* pLocator,
                 IWbemServices** ppServices,
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword,
                 COAUTHIDENTITY** ppAuthIdentity, BOOL bCheckWithNullPwd,
                 LPCWSTR pwszNamespace, HRESULT* phr, BOOL* pbLocalSystem )
{
    // local variables
    HRESULT hr;
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;
    _bstr_t bstrServer;
    _bstr_t bstrNamespace;
    _bstr_t bstrUser, bstrPassword;

    // kick-off
    if ( pbLocalSystem != NULL )
    {
        *pbLocalSystem = FALSE;
    }

    // ...
    if ( phr != NULL )
    {
        *phr = NO_ERROR;
    }

    try
    {
        // clear the error
        SetLastError( WBEM_S_NO_ERROR );

        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // check whether locator object exists or not
        // if not exists, return
        if ( pLocator == NULL )
        {
            if ( phr != NULL )
            {
                *phr = WBEM_E_INVALID_PARAMETER;
            }

            // return failure
            return FALSE;
        }

        // validate the server name
        // NOTE: The error being raised in custom define for '0x800706ba' value
        //       The message that will be displayed in "The RPC server is unavailable."
        if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
        {
            _com_issue_error( E_SERVER_NOTFOUND );
        }

        // validate the user name
        if ( IsValidUserEx( pwszUser ) == FALSE )
        {
            _com_issue_error( ERROR_NO_SUCH_USER );
        }

        // prepare namespace
        bstrNamespace = pwszNamespace;              // name space
        if ( pwszServer != NULL && bLocalSystem == FALSE )
        {
            // get the server name
            bstrServer = pwszServer;

            // prepare the namespace
            // NOTE: check for the UNC naming format of the server and do
            if ( IsUNCFormat( pwszServer ) == TRUE )
            {
                bstrNamespace = bstrServer + L"\\" + pwszNamespace;
            }
            else
            {
                bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
            }

            // user credentials
            if ( pwszUser != NULL && lstrlen( pwszUser ) != 0 )
            {
                // copy the user name
                bstrUser = pwszUser;

                // if password is empty string and if we need to check with
                // null password, then do not set the password and try
                bstrPassword = pwszPassword;
                if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
                {
                    bstrPassword = (LPWSTR) NULL;
                }
            }
        }

        // release the existing services object ( to be in safer side )
        SAFE_RELEASE( *ppServices );

        // connect to the remote system's WMI
        // there is a twist here ...
        // do not trap the ConnectServer function failure into exception
        // instead handle that action manually
        // by default try the ConnectServer function as the information which we have
        // in our hands at this point. If the ConnectServer is failed,
        // check whether password variable has any contents are not ... if no contents
        // check with "" (empty) password ... this might pass in this situation ..
        // if this call is also failed ... nothing is there that we can do ... throw the exception
        hr = pLocator->ConnectServer( bstrNamespace,
            bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
        if ( FAILED( hr ) )
        {
            //
            // special case ...

            // check whether password exists or not
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'
            if ( hr == E_ACCESSDENIED )
            {
                // check if we tried to connect to the system using null password
                // if so, then try connecting to the remote system with empty string
                if ( bCheckWithNullPwd == TRUE &&
                     bstrUser.length() != 0 && bstrPassword.length() == 0 )
                {
                    // now invoke with ...
                    hr = pLocator->ConnectServer( bstrNamespace,
                        bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
                }
            }
            else if ( hr == WBEM_E_LOCAL_CREDENTIALS )
            {
                // credentials were passed to the local system.
                // So ignore the credentials and try to reconnect
                bLocalSystem = TRUE;
                bstrUser = (LPWSTR) NULL;
                bstrPassword = (LPWSTR) NULL;
                bstrNamespace = pwszNamespace;              // name space
                hr = pLocator->ConnectServer( bstrNamespace,
                    NULL, NULL, 0L, 0L, NULL, NULL, ppServices );
            }

            // now check the result again .. if failed .. ummmm..
            if ( FAILED( hr ) )
            {
                _com_issue_error( hr );
            }
            else
            {
                bstrPassword = L"";
            }
        }

        // set the security at the interface level also
        SAFE_EXECUTE( SetInterfaceSecurity( *ppServices,
            pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

        // connection to WMI is successful
        bResult = TRUE;

        // save the hr value if needed by the caller
        if ( phr != NULL )
        {
            *phr = WBEM_S_NO_ERROR;
        }
    }
    catch( _com_error& e )
    {
        // save the error
        WMISaveError( e );

        // save the hr value if needed by the caller
        if ( phr != NULL )
        {
            *phr = e.Error();
        }
    }

    // ...
    if ( pbLocalSystem != NULL )
    {
        *pbLocalSystem = bLocalSystem;
    }

    // return the result
    return bResult;
}

/*********************************************************************************************
Routine Description:

    This function is a wrapper function for the ConnectWmi function.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL ConnectWmiEx( IWbemLocator* pLocator,
                   IWbemServices** ppServices,
                   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword,
                   COAUTHIDENTITY** ppAuthIdentity,
                   BOOL bNeedPassword, LPCWSTR pwszNamespace, BOOL* pbLocalSystem )
{
    // local variables
    HRESULT hr;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszPassword = NULL;
    CHString strBuffer = NULL_STRING;

    // clear the error .. if any
    SetLastError( WBEM_S_NO_ERROR );

    // sometime users want the utility to prompt for the password
    // check what user wants the utility to do
    if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
    {
        // user wants the utility to prompt for the password
        // so skip this part and let the flow directly jump the password acceptance part
    }
    else
    {
        // try to establish connection to the remote system with the credentials supplied
        if ( strUserName.GetLength() == 0 )
        {
            // user name is empty
            // so, it is obvious that password will also be empty
            // even if password is specified, we have to ignore that
            bResult = ConnectWmi( pLocator, ppServices,
                pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );
        }
        else
        {
            // credentials were supplied
            // but password might not be specified ... so check and act accordingly
            LPCWSTR pwszTemp = NULL;
            BOOL bCheckWithNull = TRUE;
            if ( bNeedPassword == FALSE )
            {
                pwszTemp = strPassword;
                bCheckWithNull = FALSE;
            }

            // ...
            bResult = ConnectWmi( pLocator, ppServices, pwszServer,
                strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem );
        }

        // check the result ... if successful in establishing connection ... return
        if ( bResult == TRUE )
        {
            return TRUE;
        }

        // now check the kind of error occurred
        switch( hr )
        {
        case E_ACCESSDENIED:
            break;

        case WBEM_E_LOCAL_CREDENTIALS:
            // needs to do special processing
            break;

        case WBEM_E_ACCESS_DENIED:
        default:
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'
            WMISaveError( hr );
            return FALSE;       // no use of accepting the password .. return failure
            break;
        }

        // if failed in establishing connection to the remote terminal
        // even if the password is specifed, then there is nothing to do ... simply return failure
        if ( bNeedPassword == FALSE )
        {
            return FALSE;
        }
    }

    // check whether user name is specified or not
    // if not, get the local system's current user name under whose credentials, the process
    // is running
    if ( strUserName.GetLength() == 0 )
    {
        // sub-local variables
        LPWSTR pwszUserName = NULL;

        try
        {
            // get the required buffer
            pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
        }
        catch( ... )
        {
            SetLastError((DWORD)E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // get the user name
        DWORD dwUserLength = MAX_STRING_LENGTH;
        if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) == FALSE )
        {
            // error occured while trying to get the current user info
            SaveLastError();
            return FALSE;
        }

        // release the extra buffer allocated
        strUserName.ReleaseBuffer();
    }

    try
    {
        // get the required buffer
        pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // accept the password from the user
    strBuffer.Format( INPUT_PASSWORD, strUserName );
    WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ),
        strBuffer, strBuffer.GetLength(), &dwSize, NULL );

    bResult = GetPassword( pwszPassword, MAX_PASSWORD_LENGTH );
    if ( bResult != TRUE )
    {
        return FALSE;
    }

    // release the buffer allocated for password
    strPassword.ReleaseBuffer();

    // now again try to establish the connection using the currently
    // supplied credentials
    bResult = ConnectWmi( pLocator, ppServices, pwszServer,
        strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, NULL, pbLocalSystem );

    // return the failure
    return bResult;
}

/*********************************************************************************************
Routine Description:

    This function gets the values for the security services.

Arguments:

    [in] IUnknown   :   pointer to the IUnkown interface
    [out] DWORD     :   to hold the authentication service value
    [out] DWORD     :   to hold the authorization service value

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT GetSecurityArguments( IUnknown* pInterface,
                              DWORD& dwAuthorization, DWORD& dwAuthentication )
{
    // local variables
    HRESULT hr;
    DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
    IClientSecurity* pClientSecurity = NULL;

    // try to get the client security services values if possible
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
    if ( SUCCEEDED( hr ) )
    {
        // got the client security interface
        // now try to get the security services values
        hr = pClientSecurity->QueryBlanket( pInterface,
            &dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
        if ( SUCCEEDED( hr ) )
        {
            // we've got the values from the interface
            dwAuthentication = dwAuthnSvc;
            dwAuthorization = dwAuthzSvc;
        }

        // release the client security interface
        SAFE_RELEASE( pClientSecurity );
    }

    // return always success
    return S_OK;
}

/*********************************************************************************************
Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] LPCWSTR            :   string containing the server name
    [in] LPCWSTR            :   string containing the User name
    [in] LPCWSTR            :   string containing the password
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT SetInterfaceSecurity( IUnknown* pInterface,
                              LPCWSTR pwszServer, LPCWSTR pwszUser,
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity )
{
    // local variables
    HRESULT hr;
    CHString strUser;
    CHString strDomain;
    LPCWSTR pwszUserArg = NULL;
    LPCWSTR pwszDomainArg = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;
    
    //for the time being
    UNREFERENCED_PARAMETER( pwszServer );

    // check the interface
    if ( pInterface == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // check the authentity strcuture ... if authentity structure is already ready
    // simply invoke the 2nd version of SetInterfaceSecurity
    if ( *ppAuthIdentity != NULL )
    {
        return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
    }

    // get the current security argument value
    /*hr = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
    if ( FAILED( hr ) )
    {
        return hr;
    }*/

    // If we are doing trivial case, just pass in a null authenication structure
    // for which the current logged in user's credentials will be considered
    if ( pwszUser == NULL && pwszPassword == NULL )
    {
        // set the security
        hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization,
            NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

        // return the result
        return hr;
    }

    // parse and find out if the user name contains the domain name
    // if contains, extract the domain value from it
    LONG lPos = -1;
    strDomain = L"";
    strUser = pwszUser;
    if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
    {
        // user name contains domain name ... domain\user format
        strDomain = strUser.Left( lPos );
        strUser = strUser.Mid( lPos + 1 );
    }
    else if ( ( lPos = strUser.Find( L'@' ) ) != -1 )
    {
        // NEED TO IMPLEMENT THIS ... IF NEEDED
        // This implementation needs to be done if WMI does not support
        // UPN name formats directly and if we have to split the
        // name(user@domain)
    }
    else
    {
        // server itself is the domain
        // NOTE: NEED TO DO SOME R & D ON BELOW COMMENTED LINE
        // strDomain = pwszServer;
    }

    // get the domain info if it exists only
    if ( strDomain.GetLength() != 0 )
    {
        pwszDomainArg = strDomain;
    }

    // get the user info if it exists only
    if ( strUser.GetLength() != 0 )
    {
        pwszUserArg = strUser;
    }

    // check if authenication info is available or not ...
    // initialize the security authenication information ... UNICODE VERSION STRUCTURE
    if ( ppAuthIdentity == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( *ppAuthIdentity == NULL )
    {
        hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
        if ( hr != S_OK )
        {
            return hr;
        }
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}

/*********************************************************************************************
Routine Description:

    This function sets the interface security parameters.

Arguments:

    [in] IUnknown           :   pointer to the IUnkown interface
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity )
{
    // local variables
    HRESULT hr;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    if ( pInterface == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // get the current security argument value
    hr = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}

/*********************************************************************************************
Routine Description:

    This function sets the authentication information (the security blanket)
    that will be used to make calls.

Arguments:

    [in] IUnknown                       :   pointer to the IUnkown interface
    [in] DWORD                          :   contains the authentication service to use
    [in] DWORD                          :   contains the authorization service to use
    [in] LPWSTR                         :   the server principal name to use
    [in] DWORD                          :   contains the authentication level to use
    [in] DWORD                          :   contains the impersonation level to use
    [in] RPC_AUTH_IDENTITY_HANDLE       :   pointer to the identity of the client
    [in] DWORD                          :   contains the capability flags

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities )
{
    // local variables
    HRESULT hr;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

    // get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hr != S_OK )
    {
        return hr;
    }

    // now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hr != S_OK )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
    {
        pAuthInfo = NULL;
    }

    // now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pUnknown );
        SAFE_RELEASE( pClientSecurity );
        return hr;
    }

    // release the security interface
    SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hr == S_OK )
        {
            // set security authentication
            hr = pClientSecurity->SetBlanket( pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

            // release
            SAFE_RELEASE( pClientSecurity );
        }
        else if ( hr == E_NOINTERFACE )
        {
            hr = S_OK;      // ignore no interface errors
        }
    }

    // release the IUnknown
    SAFE_RELEASE( pUnknown );

    // return the result
    return hr;
}

/*********************************************************************************************
Routine Description:

    This function allocates memory for the AUTHIDENTITY structure.

Arguments:

    [in] LPCWSTR            :   string containing the user name
    [in] LPCWSTR            :   string containing the password
    [in] LPCWSTR            :   string containing the domain name
    [out] COAUTHIDENTITY    :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword,
                                      LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent )
{
    // local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

    // validate the input parameter
    if ( ppAuthIdent == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // init with 0's
    SecureZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

    //
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong

    // user
    if ( pwszUser != NULL )
    {
        // allocate memory for user
        LONG lLength = StringLengthW( pwszUser, 0 );
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->User == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        StringCopy( pAuthIdent->User, pwszUser, StringLengthW(pwszUser, 0)+1 );
    }

    // domain
    if ( pwszDomain != NULL )
    {
        // allocate memory for domain
        LONG lLength = StringLengthW( pwszDomain, 0 );
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        StringCopy( pAuthIdent->Domain, pwszDomain, StringLengthW(pwszDomain,0)+1 );
    }

    // passsord
    if ( pwszPassword != NULL )
    {
        // allocate memory for passsord
        LONG lLength = StringLengthW( pwszPassword,0 );
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        StringCopy( pAuthIdent->Password, pwszPassword, StringLengthW(pwszPassword,0)+1 );
    }

    // type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
    *ppAuthIdent = pAuthIdent;

    // return result
    return S_OK;
}

/*********************************************************************************************
Routine Description:

    This function releases the memory allocated for the AUTHIDENTITY structure.

Arguments:

    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    None
*********************************************************************************************/
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
        // free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
        {
            CoTaskMemFree( (*ppAuthIdentity)->User );
        }

        // free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Password );
        }

        // free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Domain );
        }

        // final the structure
        CoTaskMemFree( *ppAuthIdentity );
    }

    // set to NULL
    *ppAuthIdentity = NULL;
}

/*********************************************************************************************
Routine Description:

    This function saves the description of the last error returned by WMI

Arguments:

    HRESULT     :   The last return value from WMI

Return Value:

    NONE
*********************************************************************************************/
VOID WMISaveError( HRESULT hrError )
{
    // local variables
    HRESULT hr;
    CHString strBuffer = NULL_STRING;
    IWbemStatusCodeText* pWbemStatus = NULL;

    // if the error is win32 based, choose FormatMessage to get the message
    switch( hrError )
    {
    case E_ACCESSDENIED:            // Message: "Access Denied"
    case ERROR_NO_SUCH_USER:        // Message: "The specified user does not exist."
        {
            // change the error message to "Logon failure: unknown user name or bad password."
            if ( hrError == E_ACCESSDENIED )
            {
                hrError = ERROR_LOGON_FAILURE;
            }

            // ...
            SetLastError( hrError );
            SaveLastError();
            return;
        }
    }

    try
    {
        // get the pointer to buffer
        LPWSTR pwszBuffer = NULL;
        pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

        //set the reason to incompatible os when no class is registered on remote mechine
        if( 0x80040154 == hrError )
        {
            StringCopy( pwszBuffer, GetResString(IDS_ERROR_REMOTE_INCOMPATIBLE), MAX_STRING_LENGTH );
            SetReason( strBuffer );
            return;
        }
        else
        {
            // get the wbem specific status code text
            hr = CoCreateInstance( CLSID_WbemStatusCodeText,
                NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, (LPVOID*) &pWbemStatus );

            // check whether we got the interface or not
            if ( SUCCEEDED( hr ) )
            {
                // get the error message
                BSTR bstr = NULL;
                hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0, &bstr );
                if ( SUCCEEDED( hr ) )
                {
                    // get the error message in proper format
                    GetCompatibleStringFromUnicode( bstr, pwszBuffer, MAX_STRING_LENGTH );

                    // free the BSTR
                    SysFreeString( bstr );
                    bstr = NULL;

                    // now release status code interface
                    SAFE_RELEASE( pWbemStatus );
                }
                else
                {
                    // failed to get the error message ... get the com specific error message
                    _com_issue_error( hrError );
                }
            }
            else
            {
                // failed to get the error message ... get the com specific error message
                _com_issue_error( hrError );
            }
        }

        // release the buffer
        strBuffer.ReleaseBuffer();
    }
    catch( _com_error& e )
    {
        try
        {
            // get the error message
            strBuffer.ReleaseBuffer();
            if ( e.ErrorMessage() != NULL )
                strBuffer = e.ErrorMessage();
        }
        catch( ... )
        {
            SetLastError((DWORD) E_OUTOFMEMORY );
            SaveLastError();
        }
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return;
    }

    // set the reason
    strBuffer += L"\n";
    SetReason( strBuffer );
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   property name
    [out] _variant_t            :   value of the property

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
    // local variables
    HRESULT hr;
    VARIANT vtValue;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // initialize the variant and then get the value of the specified property
        VariantInit( &vtValue );
        hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
        if ( FAILED( hr ) )
        {
            // clear the variant variable
            VariantClear( &vtValue );

            // failed to get the value for the property
            return hr;
        }

        // set the value
        varValue = vtValue;

        // clear the variant variable
        VariantClear( &vtValue );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return e.Error();
    }

    // inform success
    return S_OK;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in string format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] CHString              :   variable to hold the retrieved property
    [in] LPCWSTR                :   string containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty, CHString& strValue, LPCWSTR pwszDefault )
{
    // local variables
    HRESULT hr;
    _variant_t var;

    // first copy the default value
    strValue = pwszDefault;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the property value
    hr = PropertyGet( pWmiObject, pwszProperty, var );
    if ( FAILED( hr ) )
    {
        return FALSE;
    }

    try
    {
        // get the value
        if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
        {
            strValue = (LPCWSTR) _bstr_t( var );
        }
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in dword format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] DWORD                 :   variable to hold the retrieved property
    [in] DWORD                  :   dword containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault )
{
    // local variables
    HRESULT hr;
    _variant_t var;

    // first set the defaul value
    dwValue = dwDefault;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    hr = PropertyGet( pWmiObject, pwszProperty, var );
    if ( FAILED( hr ) )
    {
        return FALSE;
    }

    // get the process id from the variant
    if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
    {
        dwValue = (LONG) var;
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in bool format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] BOOL                  :   variable to hold the retrieved property
    [in] BOOL                   :   bool containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject,
                  LPCWSTR pwszProperty,  BOOL& bValue, BOOL bDefault )
{
    // local variables
    HRESULT hr;
    _variant_t var;

    // first set the default value
    bValue = bDefault;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    hr = PropertyGet( pWmiObject, pwszProperty, var );
    if ( FAILED( hr ) )
    {
        return FALSE;
    }

    // get the process id from the variant
    if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
    {
        bValue = var.boolVal;
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in ulongulong format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] ULONGULONG            :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue )
{
    // local variables
    CHString str;

    // first set the default value
    ullValue = 1;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
    {
        return FALSE;
    }

    // get the 64-bit value
    ullValue = _wtoi64( str );

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in wbemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime )
{
    // local variables
    CHString str;

    // Clear method sets the time in the WBEMTime object to an invalid time.
    wbemtime.Clear();

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
    {
        return FALSE;
    }

    try
    {
        // convert into the time value
        wbemtime = _bstr_t( str );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in systemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property

Return Value:

    TRUE on success
    FALSE on failure

*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime )
{
    // local variables
    CHString strTime;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    // 16010101000000.000000+000 is the default time
    if ( PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) == FALSE )
    {
        return FALSE;
    }

    // prepare the systemtime structure
    // yyyymmddHHMMSS.mmmmmmsUUU
    systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
    systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
    systime.wDayOfWeek = 0;
    systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
    systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
    systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
    systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
    systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Sets the value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] WBEMTime               :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
    // local variables
    HRESULT hr;
    VARIANT var;

    // check the input value
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // put the value
        var = varValue;
        hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        hr = e.Error();
    }

    // return the result
    return hr;
}

/*********************************************************************************************
Routine Description:

    Sets the string value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] LPCWSTR                :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue )
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varValue;

    // check the input value
    if ( pWmiObject == NULL || pwszProperty == NULL || pwszValue == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = pwszValue;
        PropertyPut( pWmiObject, pwszProperty, varValue );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        hr = e.Error();
    }

    // return
    return hr;
}

/*********************************************************************************************
Routine Description:

    Sets the dword value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] DWORD                  :   variable holding the property to set

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue )
{
    // local variables
    HRESULT hr=S_OK;
    _variant_t varValue;

    // check the input value
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = ( LONG ) dwValue;
        PropertyPut( pWmiObject, pwszProperty, varValue );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        hr = e.Error();
    }

    // return
    return hr;
}

/*********************************************************************************************
Routine Description:

    This function retrieves the value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] LPCWSTR                :   the name of the method to execute
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [in] _variant_t             :   variable holding the property value retrieved

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices,
                          LPCWSTR pwszMethod, DWORD dwHDefKey,
                          LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue )
{
    // local variables
    HRESULT hr;
    BOOL bResult = FALSE;
    DWORD dwReturnValue = 0;
    IWbemClassObject* pClass = NULL;
    IWbemClassObject* pMethod = NULL;
    IWbemClassObject* pInParams = NULL;
    IWbemClassObject* pInParamsInstance = NULL;
    IWbemClassObject* pOutParamsInstance = NULL;

    // check the input value
    if (pWbemServices == NULL || pwszMethod == NULL || pwszSubKeyName == NULL || pwszValueName == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // get the registry class object
        SAFE_EXECUTE( pWbemServices->GetObject(
            _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
        if ( pClass == NULL )                       // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // get the method reference required
        SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );
        if ( pInParams == NULL )                    // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // create the instance for the in parameters
        SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );
        if ( pInParamsInstance == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // set the input values
        PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey );
        PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName );
        PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName );

        // now execute the method
        SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
            _bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
        if ( pOutParamsInstance == NULL )           // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // now check the return value of the method from the output params object
        bResult = PropertyGet( pOutParamsInstance,
            _bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
        if ( bResult == FALSE || dwReturnValue != 0 )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // now everything is sucess .. get the required value
        if ( StringCompare( pwszMethod, WMI_REGISTRY_M_DWORDVALUE, TRUE, 0 ) == 0 )
        {
            PropertyGet( pOutParamsInstance, _bstr_t( WMI_REGISTRY_OUT_VALUE_DWORD ), varValue );
        }
        else
        {
            PropertyGet( pOutParamsInstance, _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue );
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return e.Error();
    }

    // release the interfaces
    SAFE_RELEASE( pClass );
    SAFE_RELEASE( pMethod );
    SAFE_RELEASE( pInParams );
    SAFE_RELEASE( pInParamsInstance );
    SAFE_RELEASE( pOutParamsInstance );

    // return success
    return S_OK;
}

/*********************************************************************************************
Routine Description:

    This function retrieves the string value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] CHString              :   variable holding the property value retrieved
    [in] LPCWSTR                :   the default value for this property

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL RegQueryValueWMI( IWbemServices* pWbemServices,
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName,
                       LPCWSTR pwszValueName, CHString& strValue, LPCWSTR pwszDefault )
{
    // local variables
    HRESULT hr;
    _variant_t varValue;

    try
    {
        // set the default value
        if ( pwszDefault != NULL )
        {
            strValue = pwszDefault;
        }

        // check the input
        if ( pWbemServices == NULL || pwszSubKeyName == NULL || pwszValueName == NULL )
        {
            return FALSE;
        }

        // get the value
        hr = RegQueryValueWMI( pWbemServices,
            WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            return FALSE;
        }

        // get the value from the variant
        // get the value
        if ( varValue.vt != VT_NULL && varValue.vt != VT_EMPTY )
        {
            strValue = (LPCWSTR) _bstr_t( varValue );
        }
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return success
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function retrieves the dword value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] DWORD                 :   variable holding the property value retrieved
    [in] DWORD                  :   the default value for this property

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL RegQueryValueWMI( IWbemServices* pWbemServices,
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName,
                       LPCWSTR pwszValueName, DWORD& dwValue, DWORD dwDefault )
{
    // local variables
    HRESULT hr;
    _variant_t varValue;

    try
    {
        // set the default value
        dwValue = dwDefault;

        // check the input
        if ( pWbemServices == NULL || pwszSubKeyName == NULL || pwszValueName == NULL )
        {
            return FALSE;
        }

        // get the value
        hr = RegQueryValueWMI( pWbemServices, WMI_REGISTRY_M_DWORDVALUE, dwHDefKey,
                                pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            return FALSE;
        }

        // get the value from the variant
        // get the value
        if ( varValue.vt != VT_NULL && varValue.vt != VT_EMPTY )
        {
            dwValue = (LONG) varValue;
        }
    }
    catch( ... )
    {
        SetLastError((DWORD) E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return success
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the version of the system from which we are trying to retrieve
    information from.

Arguments:

    [in] IWbemServices      :   pointer to the IWbemServices object
    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    DWORD   -   Target version of the machine
*********************************************************************************************/
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
    // local variables
    HRESULT hr;
    LONG lPos = 0;
    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwVersion = 0;
    ULONG ulReturned = 0;
    CHString strVersion;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;

    // check the input value
    if ( pWbemServices == NULL )
    {
        return 0;
    }

    try
    {
        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum(
            _bstr_t( CLASS_CIMV2_Win32_OperatingSystem ), 0, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time.
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( ulReturned == 0 )
        {
            // release the interfaces
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( PropertyGet( pWbemObject, L"Version", strVersion ) == FALSE )
        {
            // release the interfaces
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );

        //
        // now determine the os version
        dwMajor = dwMinor = 0;

        // get the major version
        lPos = strVersion.Find( L'.' );
        if ( lPos == -1 )
        {
            // the version string itself is version ... THIS WILL NEVER HAPPEN
            dwMajor = AsLong( strVersion, 10 );
        }
        else
        {
            // major version
            dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

            // get the minor version
            strVersion = strVersion.Mid( lPos + 1 );
            lPos = strVersion.Find( L'.' );
            if ( lPos == -1 )
            {
                dwMinor = AsLong( strVersion, 10 );
            }
            else
            {
                dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
            }
        }

        // mix the version info
        dwVersion = dwMajor * 1000 + dwMinor;
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return 0;
    }

    // return
    return dwVersion;
}

/*********************************************************************************************
Routine Description:

    This function retrieves a property from the safe array.

Arguments:

    [in] SAFEARRAY          :   pointer to the array of elements
    [in] LONG               :   index to retrieve the data from
    [out] CHString          :   variable to hold the return value
    [in] VARTYPE            :   The type of variable to retrieve from the array

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, CHString& strValue,
                                VARTYPE vartype )
{
    // check the inputs
    if ( pSafeArray == NULL )
    {
        return FALSE;
    }

    try
    {
        // sub-local variables
        VARIANT var;

        // get the value
        V_VT( &var ) = vartype;
        SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

        // add the information to the dynamic array
        switch( vartype )
        {
        case VT_BSTR:
            strValue = V_BSTR( &var );
            break;
        default:
            return FALSE;
        }
    }
    catch( ... )
    {
        return FALSE;   // failure
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function retrieves a property from the safe array.

Arguments:

    [in] SAFEARRAY          :   pointer to the array of elements
    [in] LONG               :   index to retrieve the data from
    [out] IWbemClassObject  :   variable to hold the return value
    [in] VARTYPE            :   The type of variable to retrieve from the array

Return Value:

    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex,
                                IWbemClassObject **pScriptObject, VARTYPE vartype )
{
    // check the inputs
    if ( pSafeArray == NULL )
    {
        return FALSE;
    }

    try
    {
        // sub-local variables
        VARIANT var;

        // get the value
        V_VT( &var ) = vartype;
        SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

        // add the information to the dynamic array
        switch( vartype )
        {
        case VT_UNKNOWN:
            *pScriptObject = (IWbemClassObject *) var.punkVal;
            break;
        default:
            return FALSE;
        }
    }
    catch( ... )
    {
        return FALSE;   // failure
    }

    // return
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\inuse\inuse.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    inuse.cpp

Abstract:

     This file can be used to replace the file which currently locked
     by the operating system.

Authors:

    Choudary - Wipro Technologies, 07-Aug-2001

Revision History:

    07-Aug-2001 : Created by  Wipro Technologies.

--*/

//common header files needed for this file

#include "pch.h"
#include "inuse.h"
#include "resource.h"

//Global variable
DWORD g_dwRetVal = 0;

VOID
DisplayHelp ( VOID )
/*++
   Routine Description:
    This function displays the help/usage for this utility.

   Arguments:
     None
   Return Value:
     None
--*/
{
    //sub-local variables
    WORD wCount = 0;

    // display the help/usage for this tool
    for ( wCount = IDS_INUSE_HLP_START; wCount <= IDS_INUSE_HLP_END ; wCount++ )
    {
        ShowMessage ( stdout, GetResString ( wCount ) );
    }

    return;
}


 DWORD __cdecl
 wmain(
     IN DWORD argc,
     IN LPCWSTR argv[]
     )
/*++
   Routine Description:
    This is the main entry for this utility. This function reads the input from
    console and calls the appropriate functions to achieve the functionality.

   Arguments:
        [IN] argc              : Command line argument count
        [IN] argv              : Command line argument

   Return Value:
         EXIT_FAILURE :   On failure
         EXIT_SUCCESS :   On success
--*/
     {

    // Local variables
    BOOL bUsage      = FALSE ;
    BOOL bConfirm    = FALSE;
    DWORD dwRetVal   = 0;

    LPWSTR   wszReplace = NULL;
    LPWSTR   wszDest = NULL;
    LPWSTR   wszBuffer = NULL;
    LPWSTR  wszFindStr = NULL;

    TARRAY arrValue = NULL ;
    DWORD dwDynCount = 0;
    LPWSTR wszTmpRFile = NULL;
    LPWSTR wszTmpDFile = NULL;
    LPWSTR wszTmpBuf1 = NULL;
    LPWSTR wszTmpBuf2 = NULL;
    LONG  lRetVal = 0;
    const WCHAR szArr[] = L"\\\\";
    const WCHAR szTokens[] = L"/";
    DWORD dwLength = 0;
    HANDLE HndFile = 0;
    LPWSTR szSystemName = NULL;

    //create a dynamic array
    arrValue  = CreateDynamicArray();

    //check if arrValue is empty
    if(arrValue == NULL )
    {
        // set the error with respect to the GetReason()
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        SaveLastError();
        // Display an error message with respect to GetReason()
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return (EXIT_FAILURE);
    }

    TCMDPARSER2 cmdInuseOptions[MAX_INUSE_OPTIONS];
    BOOL bReturn = FALSE;

    // /run sub-options
    const WCHAR szInuseHelpOpt[]       = L"?";
    const WCHAR szInuseConfirmOpt[]    = L"y";


    // set all the fields to 0
    SecureZeroMemory( cmdInuseOptions, sizeof( TCMDPARSER2 ) * MAX_INUSE_OPTIONS );

    //
    // fill the commandline parser
    //


    //  /? option
    StringCopyA( cmdInuseOptions[ OI_USAGE ].szSignature, "PARSER2\0", 8 );
    cmdInuseOptions[ OI_USAGE ].dwType       = CP_TYPE_BOOLEAN;
    cmdInuseOptions[ OI_USAGE ].pwszOptions  = szInuseHelpOpt;
    cmdInuseOptions[ OI_USAGE ].dwCount = 1;
    cmdInuseOptions[ OI_USAGE ].dwFlags = CP2_USAGE;
    cmdInuseOptions[ OI_USAGE ].pValue = &bUsage;

    //  /default arguments
    StringCopyA( cmdInuseOptions[ OI_DEFAULT ].szSignature, "PARSER2\0", 8 );
    cmdInuseOptions[ OI_DEFAULT ].dwType       = CP_TYPE_TEXT;
    cmdInuseOptions[ OI_DEFAULT ].pwszOptions  = NULL;
    cmdInuseOptions[ OI_DEFAULT ].dwCount = 2;
    cmdInuseOptions[ OI_DEFAULT ].dwFlags = CP2_MODE_ARRAY|CP2_DEFAULT;
    cmdInuseOptions[ OI_DEFAULT ].pValue =  &arrValue;

    //  /y option
    StringCopyA( cmdInuseOptions[ OI_CONFIRM ].szSignature, "PARSER2\0", 8 );
    cmdInuseOptions[ OI_CONFIRM ].dwType       = CP_TYPE_BOOLEAN;
    cmdInuseOptions[ OI_CONFIRM ].pwszOptions  = szInuseConfirmOpt;
    cmdInuseOptions[ OI_CONFIRM ].dwCount = 1;
    cmdInuseOptions[ OI_CONFIRM ].dwFlags = 0;
    cmdInuseOptions[ OI_CONFIRM ].pValue = &bConfirm;

    //parse command line arguments
    bReturn = DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(cmdInuseOptions), cmdInuseOptions, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        //display an error message
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // get the number of rows in a array
    dwDynCount = DynArrayGetCount(arrValue);

    // check for invalid syntax
    if( (argc == 1) ||
        ( ( TRUE == bUsage ) && ( argc > 2 ) ) ||
        ( ( FALSE == bUsage ) && ( dwDynCount < 2 ) ) ||
        ( ( TRUE == bConfirm ) && ( argc > 6 ) )
        )
    {
        //display an error message as specified syntax is invalid
        ShowMessage( stderr, GetResString(IDS_INVALID_SYNERROR ));
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // check whether /? is specified or not. If so, display the usage
    // for this utility.
    if ( TRUE == bUsage )
    {
        // display help/usage
        DisplayHelp();
        //release memory
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_SUCCESS;
    }


    // if count is 2 ..then get the values for Replacement and Destination

    // get the value for Replacement file
    wszReplace = (LPWSTR)DynArrayItemAsString( arrValue, 0 );
        
    // get the value for Destination file to be replaced
    wszDest = (LPWSTR)DynArrayItemAsString( arrValue, 1 );

    //check if replacement file is empty
    if ( 0 == StringLength (wszReplace, 0) )
    {
        // display an error message as .. empty value specified for Replacement file..
        ShowMessage ( stderr, GetResString ( IDS_SOURCE_NOT_NULL));
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    //check if destination file is empty
    if ( 0 == StringLength (wszDest, 0))
    {
        // display an error message as .. empty value specified for Destination file..
        ShowMessage ( stderr, GetResString ( IDS_DEST_NOT_NULL));
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // check whether replacement file consists special characters i.e. '/'
    if( wcspbrk(wszReplace,szTokens)  != NULL )
    {
        // display an error message as.. replacement file should not contain '/'
        ShowMessage ( stderr, GetResString ( IDS_INVALID_SOURCE ) );
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // check whether destination file consists special characters i.e. '/'
    if( wcspbrk(wszDest,szTokens)  != NULL )
    {
        // display an error message as.. destination file should not contain '/'
        ShowMessage ( stderr, GetResString ( IDS_INVALID_DEST ) );
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // get the actual length of full path for replacement file
    dwLength = GetFullPathNameW( wszReplace, 0, NULL, &wszTmpBuf1);
    if ( dwLength == 0)
    {
        // display an error message with respect to GetLastError()
        //DisplayErrorMsg (GetLastError());
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // allocate memory with the actual length for a replacement file
    wszTmpRFile = (LPWSTR) AllocateMemory ((dwLength+20) * sizeof (WCHAR));
    if ( NULL == wszTmpRFile )
    {
        // display an error message with respect to GetLastError()
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // Get full path for a replacement file
    if ( GetFullPathNameW( wszReplace, GetBufferSize(wszTmpRFile)/sizeof(WCHAR), wszTmpRFile, &wszTmpBuf1) == 0)
    {
        // display an error message with respect to GetLastError()
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        FreeMemory ((LPVOID*) &wszTmpRFile);
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // Get the actual length of full path for destination file
    dwLength = GetFullPathNameW( wszDest, 0, NULL, &wszTmpBuf2);
    if ( dwLength == 0)
    {
        // display an error message with respect to GetLastError()
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        FreeMemory ((LPVOID*) &wszTmpRFile);
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // allocate memory with the actual length for a destination file
    wszTmpDFile = (LPWSTR) AllocateMemory ((dwLength+20) * sizeof (WCHAR));
    if ( NULL == wszTmpDFile )
    {
        // display an error message with respect to GetLastError()
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        FreeMemory ((LPVOID*) &wszTmpRFile);
        DestroyDynamicArray(&arrValue);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // Get full path for destination file
    if ( GetFullPathNameW( wszDest, GetBufferSize(wszTmpDFile)/sizeof(WCHAR), wszTmpDFile, &wszTmpBuf2) == 0)
    {
        // display an error message with respect to GetLastError()
        ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        DestroyDynamicArray(&arrValue);
        FreeMemory ((LPVOID*) &wszTmpRFile);
        FreeMemory ((LPVOID*) &wszTmpDFile);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // get the file attributes of replacement file
    dwRetVal = GetFileAttributes( wszReplace );

    // check if the GetFileAttributes() failed
    if ( INVALID_FILE_ATTRIBUTES == dwRetVal )
    {
        wszBuffer = (LPWSTR) AllocateMemory (GetBufferSize(wszTmpRFile) + MAX_RES_STRING );
        if ( NULL == wszBuffer )
        {
            // display an error message with respect to GetLastError()
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            DestroyDynamicArray(&arrValue);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
        // format the message as .. replacement file not exists in the system.
        StringCchPrintf ( wszBuffer , GetBufferSize(wszBuffer)/sizeof(WCHAR),
                                 GetResString ( IDS_REPLACE_FILE_NOT_EXISTS), wszTmpRFile );
        // display the formatted message
        ShowMessage ( stderr, _X(wszBuffer) );
        DestroyDynamicArray(&arrValue);
        FreeMemory ((LPVOID*) &wszBuffer);
        FreeMemory ((LPVOID*) &wszTmpRFile);
        FreeMemory ((LPVOID*) &wszTmpDFile);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // check whether the source file is directory or not
    if ( dwRetVal & FILE_ATTRIBUTE_DIRECTORY )
    {
        wszBuffer = (LPWSTR) AllocateMemory (GetBufferSize(wszReplace) + MAX_RES_STRING );
        if ( NULL == wszBuffer )
        {
            // display an error message with respect to GetLastError()
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            DestroyDynamicArray(&arrValue);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }

        // format the message as .. replacement file is a directory.. not a file
        StringCchPrintf ( wszBuffer , GetBufferSize(wszBuffer)/sizeof(WCHAR),
                                 GetResString ( IDS_SOURCE_NOT_FILE), wszReplace );
        // display the formatted message
        ShowMessage ( stderr, _X(wszBuffer) );
        DestroyDynamicArray(&arrValue);
        FreeMemory ((LPVOID*) &wszBuffer);
        FreeMemory ((LPVOID*) &wszTmpRFile);
        FreeMemory ((LPVOID*) &wszTmpDFile);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // restrict the destination file with the UNC format
    lRetVal = StringCompare( wszDest, szArr , TRUE, 2  );
    if ( 0 == lRetVal )
    {
        // get the token till '\'
        wszFindStr = wcstok ( wszDest, BACK_SLASH);

        // check if failed
        if ( NULL != wszFindStr )
        {
            // get the token till '\'
            wszFindStr = wcstok ( wszDest, BACK_SLASH);

            // check if the specified is local or not
            if ( ( wszFindStr != NULL ) && ( IsLocalSystem ( wszFindStr ) == FALSE ) )
            {
                // display an error message as ..UNC format is not allowed for destinaton..
                ShowMessage ( stderr, GetResString (IDS_DEST_NOT_ALLOWED) );
                DestroyDynamicArray(&arrValue);
                FreeMemory ((LPVOID*) &wszTmpRFile);
                FreeMemory ((LPVOID*) &wszTmpDFile);
                ReleaseGlobals();
                return EXIT_FAILURE;
            }
        }
        else
        {
            // display an error message as ..UNC format is not allowed for destinaton..
            ShowMessage ( stderr, GetResString (IDS_DEST_NOT_ALLOWED) );
            DestroyDynamicArray(&arrValue);
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    // get the file attributes of destination file
    dwRetVal = GetFileAttributes( wszDest );

    // check if the GetFileAttributes() failed
    if ( INVALID_FILE_ATTRIBUTES == dwRetVal )
    {
        wszBuffer = (LPWSTR) AllocateMemory (GetBufferSize(wszTmpDFile) + MAX_RES_STRING );
        if ( NULL == wszBuffer )
        {
            // display an error message with respect to GetLastError()
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            DestroyDynamicArray(&arrValue);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }

        // format the message as .. destination file is not exists in the system.
        StringCchPrintf ( wszBuffer , GetBufferSize(wszBuffer)/sizeof(WCHAR),
                                 GetResString (IDS_DEST_FILE_NOT_EXISTS), wszTmpDFile );
        // display the formatted message
        ShowMessage ( stderr, _X(wszBuffer) );
        DestroyDynamicArray(&arrValue);
        FreeMemory ((LPVOID*) &wszBuffer);
        FreeMemory ((LPVOID*) &wszTmpRFile);
        FreeMemory ((LPVOID*) &wszTmpDFile);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // check whether the destination file is exist or not
    if ( dwRetVal & FILE_ATTRIBUTE_DIRECTORY )
    {
         wszBuffer = (LPWSTR) AllocateMemory (GetBufferSize(wszDest) + MAX_RES_STRING );
        if ( NULL == wszBuffer )
        {
            // display an error message with respect to GetLastError()
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            DestroyDynamicArray(&arrValue);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }

        // format the message as .. destination is a directory .. not a file.
        StringCchPrintf ( wszBuffer , GetBufferSize(wszBuffer)/sizeof(WCHAR), GetResString ( IDS_DEST_NOT_FILE), wszDest );
        // display the formatted message
        ShowMessage ( stderr, _X(wszBuffer) );
        DestroyDynamicArray(&arrValue);
        FreeMemory ((LPVOID*) &wszBuffer);
        FreeMemory ((LPVOID*) &wszTmpRFile);
        FreeMemory ((LPVOID*) &wszTmpDFile);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // check whether replacement and destination files are same or not
    // if same, display an error message..
    if ( ( (StringLength (wszTmpRFile, 0) != 0) && (StringLength (wszTmpDFile, 0) != 0) ) &&
        (StringCompare (wszTmpRFile, wszTmpDFile, TRUE, 0) == 0) )
    {
        // display an error message as.. replacement and destination cannot be same..
        ShowMessage ( stderr, GetResString ( IDS_NOT_REPLACE));
        DestroyDynamicArray(&arrValue);
        FreeMemory ((LPVOID*) &wszTmpRFile);
        FreeMemory ((LPVOID*) &wszTmpDFile);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    // check whether the replacement file accessible or not
    HndFile = CreateFile( wszReplace , 0, FILE_SHARE_READ , NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

    // check if CreateFile() is failed
    if ( INVALID_HANDLE_VALUE == HndFile )
    {
        wszBuffer = (LPWSTR) AllocateMemory (GetBufferSize(wszReplace) + MAX_RES_STRING );
        if ( NULL == wszBuffer )
        {
            // display an error message with respect to GetLastError()
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            DestroyDynamicArray(&arrValue);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }

        // format the message as .. destination is a directory .. not a file.
        StringCchPrintf ( wszBuffer , GetBufferSize(wszBuffer)/sizeof(WCHAR), GetResString (IDS_REPLACE_ACCESS_DENIED), wszReplace );
        // display the formatted message
        ShowMessage ( stderr, _X(wszBuffer) );

        FreeMemory ((LPVOID*) &wszBuffer);
        DestroyDynamicArray(&arrValue);

        //ShowMessage ( stderr, GetResString (IDS_REPLACE_ACCESS_DENIED) );
        return EXIT_FAILURE;
    }

    //close the handle
    CloseHandle (HndFile);

    // check whether the destination file accessible or not
    HndFile = CreateFile( wszDest , 0, FILE_SHARE_READ , NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

    // check if CreateFile() is failed
    if ( INVALID_HANDLE_VALUE == HndFile )
    {
        wszBuffer = (LPWSTR) AllocateMemory (GetBufferSize(wszDest) + MAX_RES_STRING );
        if ( NULL == wszBuffer )
        {
            // display an error message with respect to GetLastError()
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            DestroyDynamicArray(&arrValue);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }

        // format the message as .. destination is a directory .. not a file.
        StringCchPrintf ( wszBuffer , GetBufferSize(wszBuffer)/sizeof(WCHAR), GetResString (IDS_DEST_ACCESS_DENIED), wszDest );
        // display the formatted message
        ShowMessage ( stderr, _X(wszBuffer) );
        DestroyDynamicArray(&arrValue);

        FreeMemory ((LPVOID*) &wszBuffer);
        return EXIT_FAILURE;
    }

    //close the handle
    CloseHandle (HndFile);

    // Get the target system name of a source file
    lRetVal = StringCompare( wszReplace, szArr , TRUE, 2  );
    if ( 0 == lRetVal )
    {
        dwLength = StringLength (wszReplace, 0 );
        szSystemName = (LPWSTR) AllocateMemory ((dwLength+20) * sizeof(WCHAR));
        if ( NULL == szSystemName )
        {
            // display an error message with respect to GetLastError()
            //DisplayErrorMsg (GetLastError());
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            DestroyDynamicArray(&arrValue);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }

        StringCopy (szSystemName, wszReplace, GetBufferSize(szSystemName));

        // get the token till '\'
        wszFindStr = wcstok ( szSystemName, BACK_SLASH);

        // check if failed
        if ( NULL != wszFindStr )
        {
            wszFindStr = wcstok ( szSystemName, BACK_SLASH);

            // get the token till '\'
            StringCopy (szSystemName, wszFindStr, GetBufferSize(szSystemName));                        
        }  
    }

    
    // move the contents of the replacement file into destination file.
    // but changes will not effect until reboot
    if ( FALSE == ReplaceFileInUse( wszReplace, wszDest , wszTmpRFile, wszTmpDFile, bConfirm, szSystemName) )
    {
        // check if invalid input entered while confirming the input (y/n)
        if ( g_dwRetVal != EXIT_ON_ERROR )
        {
            // Display an error message with respect to GetReason()
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        }

        DestroyDynamicArray(&arrValue);
        FreeMemory ((LPVOID*) &wszTmpRFile);
        FreeMemory ((LPVOID*) &wszTmpDFile);
        FreeMemory ((LPVOID*) &szSystemName);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

     if ( g_dwRetVal != EXIT_ON_CANCEL )
     {
        wszBuffer = (LPWSTR) AllocateMemory (GetBufferSize(wszTmpRFile) +  GetBufferSize(wszTmpDFile) + 2 * MAX_RES_STRING );
        if ( NULL == wszBuffer )
        {
            // display an error message with respect to GetLastError()
            //DisplayErrorMsg (GetLastError());
            ShowLastErrorEx ( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            FreeMemory ((LPVOID*) &wszTmpRFile);
            FreeMemory ((LPVOID*) &wszTmpDFile);
            FreeMemory ((LPVOID*) &szSystemName);
            DestroyDynamicArray(&arrValue);
            ReleaseGlobals();
            return EXIT_FAILURE;
        }


        // format the message as .. copy done successfully....
        StringCchPrintf ( wszBuffer , GetBufferSize(wszBuffer)/sizeof(WCHAR), GetResString (IDS_COPY_DONE),
                                                         wszTmpRFile, wszTmpDFile );
        // display the formatted message
        ShowMessage ( stdout, _X(wszBuffer) );
        FreeMemory ((LPVOID*) &wszBuffer);
     }

    DestroyDynamicArray(&arrValue);
    FreeMemory ((LPVOID*) &wszTmpRFile);
    FreeMemory ((LPVOID*) &wszTmpDFile);
    FreeMemory ((LPVOID*) &szSystemName);
    ReleaseGlobals();
    return EXIT_SUCCESS;
}

BOOL
ReplaceFileInUse(
    IN LPWSTR pwszSource,
    IN LPWSTR pwszDestination ,
    IN LPWSTR pwszSourceFullPath,
    IN LPWSTR pwszDestFullPath,
    IN BOOL bConfirm,
    IN LPWSTR szSysName
    )
/*++
   Routine Description:
    This function moves the contents of replacement file into destination file

   Arguments:
        [IN] pwszSource              : Replacement fiele
        [IN] pwszDestination         : Destination file
        [IN] bConfirm                : confirm input

   Return Value:
         FALSE :   On failure
         TRUE  :   On success
--*/
{
    
    // local variables
    DWORD dwLength = 0;
    CHString strPath;
    CHString strFileName;
    LPWSTR wszTmpFileBuf = NULL;
    LPWSTR wszDestFileBuf = NULL;
    LPWSTR wszTmpFileName = NULL;

    WCHAR wszBuffer [MAX_RES_STRING];
    
#ifdef _WIN64
    INT64 dwPos ;
#else
    DWORD dwPos ;
#endif

    // initialize the variable
    SecureZeroMemory ( wszBuffer, SIZE_OF_ARRAY(wszBuffer) );

    // display the destination file related information
    if ( EXIT_FAILURE == DisplayFileInfo ( pwszDestination, pwszDestFullPath, TRUE ) )
    {
        return FALSE;
    }

    // display the replacement file related information
    if ( EXIT_FAILURE == DisplayFileInfo ( pwszSource, pwszSourceFullPath, FALSE ) )
    {
        return FALSE;
    }

    // check whether to prompt for confirmation or not.
    if ( FALSE == bConfirm )
    {
        // to be added the fn
        if ( (EXIT_FAILURE == ConfirmInput ()) || (EXIT_ON_ERROR == g_dwRetVal)  )
        {
            // could not get the handle so return failure
            return FALSE;
        }
        else if ( EXIT_ON_CANCEL == g_dwRetVal )
        {
            //operation has been cancelled.. so..return..
            return TRUE;
        }
    }


    // form the unique temp file name
    try
    {
        // sub-local variables
        DWORD dw = 0;
        LPWSTR pwsz = NULL;


        //
        // get the temporary file path location
        //

        // get the buffer to hold the temp. path information
        pwsz = strPath.GetBufferSetLength( MAX_PATH );

        // get the temp. path information
        dw = GetTempPath( MAX_PATH, pwsz );

        // check whether the buffer which we passed is sufficient or not
        if ( dw > MAX_PATH )
        {
            // the buffer we passed to the API is not sufficient -- need re-allocation
            // since the value in the dwLength variable is needed length -- just one more
            // call to the API function will suffice
            pwsz = strPath.GetBufferSetLength( dw + 2 ); // +2 is needed for NULL character

            // now get the temp. path once again
            dw = GetTempPath( dw, pwsz );
        }

        // check the result of the operation
        if ( dw == 0 )
        {
            // encountered problem
            SaveLastError();
            strPath.ReleaseBuffer();
            return FALSE;
        }

        // release the buffer
        pwsz = NULL;
        strPath.ReleaseBuffer();

        //
        // get the temporary file name
        //

        // get the buffer to hold the temp. path information
        pwsz = strFileName.GetBufferSetLength( MAX_PATH );

        // get the temp. file name
        dw = GetTempFileName( strPath, L"INUSE", 0, pwsz );

        // check the result
        if ( dw == 0 )
        {
            // encountered problem
            SaveLastError();
            strFileName.ReleaseBuffer();
            return FALSE;
        }

        // release the buffer
        pwsz = NULL;
        strFileName.ReleaseBuffer();
    }
    catch( ... )
    {
        SetLastError( (DWORD)E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }


    //1.Create a temp file in the destination directory and copy replacement file into a temp file.
    //2.Delete the destination file at the time of reboot and by using MoveFileEx api..
    //3.Copy temp file into destination file by using MoveFileEx api..So that temp file  
    //  would get deleted at the time of reboot.
    {
        StringCopy ( wszBuffer, strFileName, SIZE_OF_ARRAY(wszBuffer));

        //Get the temporary file name
        wszTmpFileName = StrRChr ( wszBuffer, NULL, L'\\' );
        if ( NULL == wszTmpFileName )
        {
            SetLastError( (DWORD)E_UNEXPECTED );
            SaveLastError();
            return FALSE;
        }

        // to be implemented
        wszTmpFileBuf = StrRChr ( pwszDestFullPath, NULL, L'\\' );
        if ( NULL == wszTmpFileBuf )
        {
            SetLastError( (DWORD)E_UNEXPECTED );
            SaveLastError();
            return FALSE;
        }

        // get the position
        dwPos = wszTmpFileBuf - pwszDestFullPath ;

        dwLength = StringLength ( pwszDestFullPath, 0 );

         // allocate memory with the actual length for a replacement file
        wszDestFileBuf = (LPWSTR) AllocateMemory ( dwLength + MAX_RES_STRING );
        if ( NULL == wszDestFileBuf )
        {
            // display an error message with respect to GetLastError()
            SetLastError( (DWORD)E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        //consider the destination file path as the file path for temporary file.
        StringCopy ( wszDestFileBuf, pwszDestFullPath, (DWORD) (dwPos + 1) );

        StringCchPrintf (wszDestFileBuf, GetBufferSize (wszDestFileBuf)/sizeof(WCHAR), L"%s%s", wszDestFileBuf, wszTmpFileName);

        // copy the source file as temporary file name
        if ( FALSE == CopyFile( pwszSource, wszDestFileBuf, FALSE ) )
        {
            if ( ERROR_ACCESS_DENIED == GetLastError () )
            {
                g_dwRetVal = EXIT_ON_ERROR;
                ShowMessage ( stderr, GetResString (IDS_DEST_DIR_DENIED) );
            }
            else
            {    
                SaveLastError();
            }

            FreeMemory ((LPVOID*) &wszDestFileBuf);
            return FALSE;
        }
        
        //
        //copy ACLs of destination file into a temp file
        //
        PSID sidOwner = NULL;
        PSID sidGroup =  NULL;
        PACL pOldDacl= NULL ;
        PACL pOldSacl = NULL ;
        PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
        DWORD dwError = 0;
        BOOL bResult = FALSE;
              
         // enable seSecurityPrivilege
         if (!SetPrivilege (szSysName))
        {
            SaveLastError();
            FreeMemory ((LPVOID*) &wszDestFileBuf);
            return FALSE;
        }


         // get the DACLs of source file
         dwError = GetNamedSecurityInfo ( pwszSource, SE_FILE_OBJECT, 
             DACL_SECURITY_INFORMATION |SACL_SECURITY_INFORMATION| GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
             &sidOwner,
             &sidGroup,
             &pOldDacl,
             &pOldSacl,
             &pSecurityDescriptor);

        //check for return value  
        if (ERROR_SUCCESS != dwError )
         {
            SaveLastError();
            FreeMemory ((LPVOID*) &wszDestFileBuf);
            return FALSE;
         }
    
         // Set the DACLs of source file to a temp file
         bResult = SetFileSecurity(wszDestFileBuf, 
                              DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION| GROUP_SECURITY_INFORMATION |OWNER_SECURITY_INFORMATION , 
                              pSecurityDescriptor);

        //check for return value 
        if (FALSE == bResult )
         {
            // continue to replace the file at the time of reboot...
         }

         //release the security descriptor 
       if ( NULL != pSecurityDescriptor)
          {
              LocalFree (&pSecurityDescriptor);
          }
                                    

        //
        // start replacing file
        //

        // now move this destination file -- means delete this file
        if ( FALSE == MoveFileEx( pwszDestination, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) )
        {
            // this will never occur since the operation result is not
            // known until the reboot happens
            SaveLastError();
            FreeMemory ((LPVOID*) &wszDestFileBuf);
            return FALSE;
        }

        // now move the temp. file as destination file
        if ( FALSE == MoveFileEx( wszDestFileBuf, pwszDestination, MOVEFILE_DELAY_UNTIL_REBOOT ) )
        {
            // this will never occur since the operation result is not
            // known until the reboot happens
            SetLastError( (DWORD)E_UNEXPECTED );
            SaveLastError();
            FreeMemory ((LPVOID*) &wszDestFileBuf);
            return FALSE;
        }

        // de-allocate the memory
        FreeMemory ((LPVOID*) &wszDestFileBuf);
        
    }
       

    // everything went well -- return success
    return TRUE;
}

DWORD
DisplayFileInfo (
    IN LPWSTR pwszFileName,
    IN LPWSTR pwszFileFullPath,
    BOOL bFlag
    )
/*++
   Routine Description:
    This function displays the information of replacement and destination files

   Arguments:
        [IN] pwszFileName            : Replacement/Destination file name
        [IN] pwszFileFullPath        : Replacement/Destination full path
        [IN] bFlag                   : TRUE for Destination file
                                       FALSE for Replacement file

   Return Value:
         EXIT_FAILURE :   On failure
         EXIT_SUCCESS  :   On success
--*/
{
    // sub-local variables
    DWORD dw = 0;
    DWORD dwSize = 0;
    UINT uSize = 0;
    WCHAR wszData[MAX_RES_STRING] = NULL_STRING;
    WCHAR wszSubBlock[MAX_RES_STRING] = L"";
    WCHAR wszBuffer[MAX_RES_STRING] = L"";
    WCHAR wszDate[MAX_RES_STRING] = L"";
    WCHAR wszTime[MAX_RES_STRING] = L"";
    WCHAR wszSize[MAX_RES_STRING] = L"";

    LPWSTR lpBuffer = NULL;
    BOOL   bVersion = TRUE;


    /////////////////////////////////////////////////////////////////////
    // Get the information of a file i.e. filename, version, created time,
    // Last modified time, last access time and size in bytes
    //////////////////////////////////////////////////////////////////////

    //
    // Get the version of a file
    //

    // get the size of file version
    dwSize = GetFileVersionInfoSize ( pwszFileFullPath, &dw );

    // get the file version file
    if ( 0 == dwSize )
    {
        bVersion = FALSE;
    }
    //retrieves version information for the file.
    else if ( FALSE == GetFileVersionInfo ( pwszFileFullPath , dw, dwSize, (LPVOID) wszData ) )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    //retrieves version information from the file version-information resource
    if ( ( bVersion == TRUE ) &&
         (FALSE == VerQueryValue(wszData, STRING_NAME1, (LPVOID*)&lpTranslate, &uSize)))
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    if ( bFlag == TRUE)
    {
        // display the heading before displaying the file information
        ShowMessage ( stdout, GetResString (IDS_INUSE_HEADING) );

        // display the column "Destination File:"
        ShowMessage ( stdout, _X(GetResString (IDS_EXT_FILE_NAME)) );
    }
    else
    {
        // display the column "Replacement File:"
        ShowMessage ( stdout, _X(GetResString (IDS_REP_FILE_NAME)) );
    }

    //
    // Display the file name with full path
    //

    // display name of the file
    ShowMessage ( stdout, _X(pwszFileFullPath) );

    ShowMessage ( stdout, L"\n" );

    if ( TRUE == bVersion )
    {
        // format the message for sub-block i.e. value to retrieve
        StringCchPrintf( wszSubBlock, SIZE_OF_ARRAY(wszSubBlock), STRING_NAME2, lpTranslate[0].wLanguage,
                                                                         lpTranslate[0].wCodePage);
    }

     // Retrieve file version for language and code page
     if ( ( bVersion == TRUE ) &&
          ( FALSE == VerQueryValue(wszData, wszSubBlock, (LPVOID *) &lpBuffer, &uSize) ) )
     {
        SaveLastError();
        return EXIT_FAILURE;
     }

    //
    //Display the version information of a file
    //

    // if version infomation is not available
    if ( FALSE == bVersion )
    {
        // copy the string as version is "Not available"
        StringCopy ( wszBuffer, GetResString ( IDS_VER_NA), SIZE_OF_ARRAY(wszBuffer) );
        // display the column name as "Version:"
        ShowMessage ( stdout, _X(GetResString (IDS_FILE_VER)) );
        //display the version information of file
        ShowMessage ( stdout, _X(wszBuffer) );
        ShowMessage ( stdout, L"\n" );
    }
    else
    {
        // display the column name as "Version:"
        ShowMessage ( stdout, _X(GetResString (IDS_FILE_VER)) );
        ShowMessage ( stdout, _X(lpBuffer) );
        ShowMessage ( stdout, L"\n" );
    }


    // Get File info
    //SECURITY_ATTRIBUTES SecurityAttributes;
    HANDLE HndFile;
    FILETIME  filetime = {0,0};
    BY_HANDLE_FILE_INFORMATION FileInformation ;
    SYSTEMTIME systemtime = {0,0,0,0,0,0,0,0};
    BOOL bLocaleChanged = FALSE;
    LCID lcid;
    int iBuffSize = 0;

    // opens an existing file
    HndFile = CreateFile( pwszFileName , 0, FILE_SHARE_READ , NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

    // check if CreateFile() is failed
    if ( INVALID_HANDLE_VALUE == HndFile )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // retrieve file information of a file
    if (FALSE == GetFileInformationByHandle(  HndFile , &FileInformation ))
    {
        // release handle
        if (FALSE == CloseHandle (HndFile))
        {
            SaveLastError();
            return EXIT_FAILURE;
        }
        SaveLastError();
        return EXIT_FAILURE;
    }

    // release handle
    if (FALSE == CloseHandle (HndFile))
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    ///
    // Get the information of a file creation time
    ///

    // convert file time to local file time
    if ( FALSE == FileTimeToLocalFileTime ( &FileInformation.ftCreationTime, &filetime ) )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // To get create time, convert local file time to system time
    if ( FALSE == FileTimeToSystemTime ( &filetime, &systemtime ) )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // verify whether console supports the current locale fully or not
    lcid = GetSupportedUserLocale( &bLocaleChanged );
    if ( 0 == lcid )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    //Retrieve the Date format for a current locale
    iBuffSize = GetDateFormat( lcid, 0, &systemtime,
        (( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL), wszDate, SIZE_OF_ARRAY( wszDate ) );

    //check if GetDateFormat() is failed
    if( 0 == iBuffSize )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // retrieve the time format for a current locale
    iBuffSize = GetTimeFormat( lcid, 0, &systemtime,
        (( bLocaleChanged == TRUE ) ? L"HH:mm:ss" : NULL), wszTime, SIZE_OF_ARRAY( wszTime ) );


    if( 0 == iBuffSize )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // format the message as ... "time, date"..
    StringConcat ( wszTime, COMMA_STR, SIZE_OF_ARRAY(wszTime) );
    StringConcat ( wszTime , wszDate, SIZE_OF_ARRAY(wszTime) );

    // display the column name as "Created Time:"
    ShowMessage ( stdout, _X(GetResString (IDS_FILE_CRT_TIME)) );
    ShowMessage ( stdout, _X(wszTime) );

    ShowMessage ( stdout, L"\n" );


    //
    // Get the information of Last modified time
    //

    // get the Last modified time for a file
    if ( FALSE == FileTimeToLocalFileTime ( &FileInformation.ftLastWriteTime, &filetime ) )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // get the last access time for a file
    if ( FALSE == FileTimeToSystemTime ( &filetime , &systemtime ) )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // get date format for a current locale
    iBuffSize = GetDateFormat( lcid, 0, &systemtime,
        (( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL), wszDate, SIZE_OF_ARRAY( wszDate ) );

    // check if GetDateFormat() is failed
    if( 0 == iBuffSize )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // check if GetTimeFormat() is failed
    iBuffSize = GetTimeFormat( lcid, 0,
            &systemtime, (( bLocaleChanged == TRUE ) ? L"HH:mm:ss" : NULL),
            wszTime, SIZE_OF_ARRAY( wszTime ) );

    // check if GetTimeFormat() is failed
    if( 0 == iBuffSize )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    //format the message as .."time, date"
    StringConcat ( wszTime, COMMA_STR, SIZE_OF_ARRAY(wszTime) );
    StringConcat ( wszTime , wszDate, SIZE_OF_ARRAY(wszTime)  );

    // display the column name as "Last Modified Time:"
    ShowMessage ( stdout, _X(GetResString (IDS_FILE_MOD_TIME)) );
    ShowMessage ( stdout, _X(wszTime) );

    // display the creation time of a file
    ShowMessage ( stdout, L"\n" );


    ///
    // Get the information of Last Access Time
    ///

    // convert file time to local file time
    if ( FALSE == FileTimeToLocalFileTime ( &FileInformation.ftLastAccessTime, &filetime ) )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // To get last access time, convert local file time to system time for a file
    if ( FALSE == FileTimeToSystemTime ( &filetime , &systemtime ) )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // get date format for a specified locale
    iBuffSize = GetDateFormat( lcid, 0, &systemtime,
        (( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL), wszDate, SIZE_OF_ARRAY( wszDate ) );

    // check if GetDateFormat is failed
    if( 0 == iBuffSize )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // get time format for a current locale
    iBuffSize = GetTimeFormat( lcid, 0,
            &systemtime, (( bLocaleChanged == TRUE ) ? L"HH:mm:ss" : NULL),
            wszTime, SIZE_OF_ARRAY( wszTime ) );

    // check if GetTimeFormat() is failed
    if( 0 == iBuffSize )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // format message as .. "time, date"
    StringConcat ( wszTime, COMMA_STR, SIZE_OF_ARRAY(wszTime) );
    StringConcat ( wszTime , wszDate, SIZE_OF_ARRAY(wszTime)  );

    // display the column name as "Last Access Time:"
    ShowMessage ( stdout, _X(GetResString (IDS_FILE_ACS_TIME)) );
    ShowMessage ( stdout, _X(wszTime) );

    // display the creation time of a file
    ShowMessage ( stdout, L"\n" );

    ///
    // Get the size of a file in bytes
    ///

    // sub-local variables
    NUMBERFMT numberfmt;
    WCHAR   szGrouping[MAX_RES_STRING]      =   NULL_STRING;
    WCHAR   szDecimalSep[MAX_RES_STRING]    =   NULL_STRING;
    WCHAR   szThousandSep[MAX_RES_STRING]   =   NULL_STRING;
    WCHAR   szTemp[MAX_RES_STRING]          =   NULL_STRING;
    LPWSTR  szTemp1                         =   NULL;
    LPWSTR  pszStoppedString                =   NULL;
    DWORD   dwGrouping                      =   3;

    //make the fractional digits and leading zeros to nothing
    numberfmt.NumDigits = 0;
    numberfmt.LeadingZero = 0;


    //get the decimal seperate character
    if( 0 == GetLocaleInfo( lcid, LOCALE_SDECIMAL, szDecimalSep, MAX_RES_STRING ) )
    {
       StringCopy(szDecimalSep, L",", SIZE_OF_ARRAY(szDecimalSep));
    }

    numberfmt.lpDecimalSep = szDecimalSep;

    // retrieve info about locale
    if(FALSE == GetLocaleInfo( lcid, LOCALE_STHOUSAND, szThousandSep, MAX_RES_STRING ) )
    {
        StringCopy(szThousandSep, L"," , SIZE_OF_ARRAY(szThousandSep));
    }

    numberfmt.lpThousandSep = szThousandSep;

    // retrieve info about locale
    if( GetLocaleInfo( lcid, LOCALE_SGROUPING, szGrouping, MAX_RES_STRING ) )
    {
        // get the token till ';'
        szTemp1 = wcstok( szGrouping, L";");
        if ( NULL == szTemp1 )
        {
            SaveLastError();
            return EXIT_FAILURE;
        }

        do
        {
            StringConcat( szTemp, szTemp1, SIZE_OF_ARRAY(szTemp) );
            // get the token till ';'
            szTemp1 = wcstok( NULL, L";" );
        }while( szTemp1 != NULL && StringCompare( szTemp1, L"0", TRUE, 0) != 0);

        // get the numeric value
        dwGrouping = wcstol( szTemp, &pszStoppedString, 10);
        if ( (errno == ERANGE) ||
            ((pszStoppedString != NULL) && (StringLength (pszStoppedString, 0) != 0 )))
        {
            SaveLastError();
            return EXIT_FAILURE;
        }
    }
    else
    {
        dwGrouping = 33;  //set the default grouping
    }

    numberfmt.Grouping = (UINT)dwGrouping ;

    numberfmt.NegativeOrder = 2;

    // get the file size
    StringCchPrintf (wszSize, SIZE_OF_ARRAY(wszSize), L"%d", FileInformation.nFileSizeLow );

    // get number format for a current locale
    iBuffSize = GetNumberFormat( lcid, 0,
            wszSize, &numberfmt, wszBuffer, SIZE_OF_ARRAY( wszBuffer ) );

    // check if GetNumberFormat() is failed
    if( 0 == iBuffSize )
    {
        SaveLastError();
        return EXIT_FAILURE;
    }

    // display the column name as "Size:"
    ShowMessage ( stdout, _X( GetResString (IDS_FILE_SIZE)) );
    // display the actual size in bytes for a file
    ShowMessage ( stdout, _X(wszBuffer) );
    ShowMessage ( stdout, GetResString (IDS_STR_BYTES) );
    // display the blank lines
    ShowMessage ( stdout, L"\n\n" );

    // return 0
    return EXIT_SUCCESS;
}

DWORD
ConfirmInput ( VOID )
/*++
   Routine Description:
    This function validates the input given by user.

   Arguments:
        None

   Return Value:
         EXIT_FAILURE :   On failure
         EXIT_SUCCESS  :   On success
--*/

{
    // sub-local variables
    DWORD   dwCharsRead = 0;
    DWORD   dwPrevConsoleMode = 0;
    HANDLE  hInputConsole = NULL;
    BOOL    bIndirectionInput   = FALSE;
    WCHAR ch = L'\0';
    WCHAR chTmp = L'\0';
    DWORD dwCharsWritten = 0;
    WCHAR szBuffer[MAX_RES_STRING];
    WCHAR szBackup[MAX_RES_STRING];
    WCHAR szTmpBuf[MAX_RES_STRING];
    DWORD dwIndex = 0 ;
    BOOL  bNoBreak = TRUE;

    SecureZeroMemory ( szBuffer, SIZE_OF_ARRAY(szBuffer));
    SecureZeroMemory ( szTmpBuf, SIZE_OF_ARRAY(szTmpBuf));
    SecureZeroMemory ( szBackup, SIZE_OF_ARRAY(szBackup));

    // Get the handle for the standard input
    hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
    if ( hInputConsole == INVALID_HANDLE_VALUE  )
    {
        SaveLastError();
        // could not get the handle so return failure
        return EXIT_FAILURE;
    }

    MessageBeep(MB_ICONEXCLAMATION);

    // display the message .. Do you want to continue? ...
    ShowMessage ( stdout, GetResString ( IDS_INPUT_DATA ) );

    // Check for the input redirect
    if( ( hInputConsole != (HANDLE)0x0000000F ) &&
        ( hInputConsole != (HANDLE)0x00000003 ) &&
        ( hInputConsole != INVALID_HANDLE_VALUE ) )
    {
        bIndirectionInput   = TRUE;
    }

    // if there is no redirection
    if ( bIndirectionInput == FALSE )
    {
        // Get the current input mode of the input buffer
        if ( FALSE == GetConsoleMode( hInputConsole, &dwPrevConsoleMode ))
        {
            SaveLastError();
            // could not set the mode, return failure
            return EXIT_FAILURE;
        }

        // Set the mode such that the control keys are processed by the system
        if ( FALSE == SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) )
        {
            SaveLastError();
            // could not set the mode, return failure
            return EXIT_FAILURE;
        }
    }

    // redirect the data into the console
    if ( bIndirectionInput  == TRUE )
    {
        do {
            //read the contents of file
            if ( ReadFile(hInputConsole, &chTmp, 1, &dwCharsRead, NULL) == FALSE )
            {
                SaveLastError();
                // could not get the handle so return failure
                return EXIT_FAILURE;
            }

            // check if number of characters read were zero.. or
            // any carriage return pressed..
            if ( dwCharsRead == 0 || chTmp == CARRIAGE_RETURN )
            {
                bNoBreak = FALSE;
                // exit from the loop
                break;
            }

            // write the contents to the console
            if ( FALSE == WriteFile ( GetStdHandle( STD_OUTPUT_HANDLE ), &chTmp, 1, &dwCharsRead, NULL ) )
            {
                SaveLastError();
                // could not get the handle so return failure
                return EXIT_FAILURE;
            }

            // copy the character
            ch = chTmp;

            StringCchPrintf ( szBackup, SIZE_OF_ARRAY(szBackup), L"%c" , ch );

            // increment the index
            dwIndex++;

        } while (TRUE == bNoBreak);

    }
    else
    {
        do {
            // Get the Character and loop accordingly.
            if ( ReadConsole( hInputConsole, &chTmp, 1, &dwCharsRead, NULL ) == FALSE )
            {
                SaveLastError();

                // Set the original console settings
                if ( FALSE == SetConsoleMode( hInputConsole, dwPrevConsoleMode ) )
                {
                    SaveLastError();
                }
                // return failure
                return EXIT_FAILURE;
            }

            // check if number of chars read were zero..if so, continue...
            if ( dwCharsRead == 0 )
            {
                continue;
            }

            // check if any carriage return pressed...
            if ( chTmp == CARRIAGE_RETURN )
            {
                bNoBreak = FALSE;
                // exit from the loop
                break;
            }

            ch = chTmp;

            if ( ch != BACK_SPACE )
            {
                StringCchPrintf ( szTmpBuf, SIZE_OF_ARRAY(szTmpBuf), L"%c" , ch );
                StringConcat ( szBackup, szTmpBuf , SIZE_OF_ARRAY(szBackup));
            }

            // Check id back space is hit
            if ( ch == BACK_SPACE )
            {
                if ( dwIndex != 0 )
                {
                    //
                    // Remove a asterix from the console

                    // move the cursor one character back
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BACK_SPACE );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ) )
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }


                    // replace the existing character with space
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BLANK_CHAR );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ))
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }

                    // now set the cursor at back position
                    StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , BACK_SPACE );
                    if ( FALSE == WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1,
                        &dwCharsWritten, NULL ))
                    {
                        SaveLastError();
                        // return failure
                        return EXIT_FAILURE;
                    }

                    szBackup [StringLength(szBackup, 0) - 1] = L'\0';
                    // decrement the index
                    dwIndex--;
                }

                // process the next character
                continue;
            }

            // write the contents onto console
            if ( FALSE == WriteFile ( GetStdHandle( STD_OUTPUT_HANDLE ), &ch, 1, &dwCharsRead, NULL ) )
            {
                SaveLastError();
                // return failure
                return EXIT_FAILURE;
            }

            // increment the index value
            dwIndex++;

        } while (TRUE == bNoBreak);

    }

    ShowMessage(stdout, _T("\n") );

    //StringCchPrintf( szBuffer, SIZE_OF_ARRAY(szBuffer), L"%c" , ch );

    // check if 'Y' or 'y' is pressed
    if ( ( dwIndex == 1 ) &&
         ( StringCompare ( szBackup, GetResString (IDS_UPPER_YES), TRUE, 0 ) == 0 ) )
    {
        return EXIT_SUCCESS;
    }
    // check if 'N' or 'n' is pressed
    else if ( ( dwIndex == 1 ) &&
              ( StringCompare ( szBackup, GetResString(IDS_UPPER_NO), TRUE, 0 ) == 0 ) )
    {
        // display a message as .. operation has been cancelled...
        ShowMessage ( stdout, GetResString (IDS_OPERATION_CANCELLED ) );
        // Already displayed the INFO message as above...There is no need to display any
        // success message now.. thats why assigning EXIT_ON_CALCEL flag to g_dwRetVal
        g_dwRetVal = EXIT_ON_CANCEL;
        return EXIT_SUCCESS;
    }
    else
    {
        // display an error message as .. wrong input specified...
        ShowMessage(stderr, GetResString( IDS_WRONG_INPUT ));
        // Already displayed the ERROR message as above...There is no need to display any
        // success message now.. thats why assigning EXIT_ON_ERROR flag to g_dwRetVal
        g_dwRetVal = EXIT_ON_ERROR;
        return EXIT_FAILURE;
    }

}



BOOL 
SetPrivilege( 
             IN LPWSTR szSystemName
             ) 
/*++
   Routine Description:
    This function enables seSecurityPrivilege.

   Arguments:
        [in] szSystemName: SystemName

   Return Value:
         FALSE :   On failure
         TRUE  :   On success
--*/
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tp;
    LUID luid;

    // Open current process token
    if( FALSE == OpenProcessToken ( GetCurrentProcess(),
                      TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES ,
                      &hToken )){
        //return WIN32 error code
        SaveLastError() ;
        return FALSE;
    }


    if ( !LookupPrivilegeValue( 
        szSystemName ,            // lookup privilege on system
        SECURITY_PRIV_NAME,   // privilege to lookup 
        &luid ) ) 
    {      // receives LUID of privilege
        SaveLastError();
        return FALSE; 
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // Enable the SeSecurityPrivilege 

    AdjustTokenPrivileges(
       hToken, 
       FALSE, 
       &tp, 
       sizeof(TOKEN_PRIVILEGES), 
       (PTOKEN_PRIVILEGES) NULL, 
       (PDWORD) NULL); 

    // Call GetLastError to determine whether the function succeeded.

    if (GetLastError() != ERROR_SUCCESS) { 
      SaveLastError();
      return FALSE; 
    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\inuse\resource.h ===
#define IDS_INUSE_HLP1          101
#define IDS_INUSE_HLP2          102
#define IDS_INUSE_HLP3          103
#define IDS_INUSE_HLP4          104
#define IDS_INUSE_HLP5          105
#define IDS_INUSE_HLP6          106
#define IDS_INUSE_HLP7          107
#define IDS_INUSE_HLP8          108
#define IDS_INUSE_HLP9          109
#define IDS_INUSE_HLP10         110
#define IDS_INUSE_HLP11         111
#define IDS_INUSE_HLP12         112
#define IDS_INUSE_HLP13         113
#define IDS_INUSE_HLP14         114
#define IDS_INUSE_HLP15         115
#define IDS_INUSE_HLP16         116
#define IDS_INUSE_HLP17         117
#define IDS_INUSE_HLP18         118
#define IDS_INUSE_HLP19         119
#define IDS_INUSE_HLP20         120
#define IDS_INUSE_HLP21         121
#define IDS_INUSE_HLP22         122

#define IDS_REPLACE_FILE_NOT_EXISTS 200
#define IDS_DEST_FILE_NOT_EXISTS    201
#define IDS_INVALID_SYNERROR        202
#define IDS_WRONG_INPUT             203
#define IDS_INPUT_DATA              204
#define IDS_COPY_DONE               205
#define IDS_SOURCE_NOT_NULL         206
#define IDS_DEST_NOT_NULL           207
#define IDS_OPERATION_CANCELLED     208
#define IDS_INUSE_HEADING           209
#define IDS_SOURCE_NOT_FILE         210
#define IDS_DEST_NOT_FILE           211
#define IDS_NOT_REPLACE             212
#define IDS_FORMAT_MSG_FAIL         213

#define IDS_REPLACE_ACCESS_DENIED   215
#define IDS_DEST_ACCESS_DENIED      216

#define IDS_EXT_FILE_NAME           251
#define IDS_REP_FILE_NAME           252
#define IDS_FILE_VER                253
#define IDS_FILE_CRT_TIME           254
#define IDS_FILE_MOD_TIME           255
#define IDS_FILE_ACS_TIME           256
#define IDS_FILE_SIZE               257
#define IDS_VER_NA                  258
#define IDS_STR_BYTES               259
#define IDS_DEST_NOT_ALLOWED        260
#define IDS_INVALID_SOURCE          261
#define IDS_INVALID_DEST            262

#define IDS_UPPER_YES                263
#define IDS_UPPER_NO                 264
#define IDS_DEST_DIR_DENIED          265


#define IDS_INUSE_HLP_START         IDS_INUSE_HLP1
#define IDS_INUSE_HLP_END           IDS_INUSE_HLP21
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\inuse\inuse.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    who.h

Abstract:

    This module contains the macros, user defined structures & function
    definitions needed by whoami.cpp, wsuser.cpp, wssid.cpp and
    wspriv.cppfiles.

Authors:

    Christophe Robert

Revision History:

    02-July-2001 : Updated by Wipro Technologies.

--*/

// Options

#define MAX_INUSE_OPTIONS 3

#define OI_USAGE        0
#define OI_DEFAULT      1
#define OI_CONFIRM      2


#define STRING_NAME1     L"\\VarFileInfo\\Translation"
#define STRING_NAME2     L"\\StringFileInfo\\%04x%04x\\FileVersion"
#define VER_NA           L"Not Applicable"

//#define TRIM_SPACES TEXT(" \0")

#define EXIT_SUCCESS        0
#define EXIT_FAILURE        1

#define EXIT_ON_CANCEL       3
#define EXIT_ON_ERROR        4

#define COL_FORMAT_STRING   L"%s"
#define COL_FORMAT_HEX      L"%d"
#define COMMA_STR           L", "
#define BACK_SLASH          L"\\"
#define SECURITY_PRIV_NAME  L"SeSecurityPrivilege"


struct LANGANDCODEPAGE {
  WORD wLanguage;
  WORD wCodePage;
} *lpTranslate;


// function prototypes
BOOL  ReplaceFileInUse( IN LPWSTR pwszSource, IN LPWSTR pwszDestination, IN LPWSTR pwszSourceFullPath, IN LPWSTR pwszDestFullPath, BOOL bConfirm, IN LPWSTR pwszSysName  );
DWORD DisplayFileInfo( IN LPWSTR pwszFile, IN LPWSTR pwszFileFullPath , BOOL bFlag);
DWORD ConfirmInput ( VOID );
BOOL SetPrivilege(IN LPWSTR szSystem);
//VOID DisplayErrorMsg(IN DWORD dw);
VOID DisplayHelp ( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\inuse\pch.h ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        pch.h

    Abstract:

        This header file is a precompiled header for this project.
        This module contains the common include files [ system,user defined ]
        which are not changed frequently.

    Author:

        Venu Gopal Choudary  10-July-2001 : Created it

    Revision History:


******************************************************************************/


#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000   // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// public Windows header files
//
#include <windows.h>

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <windows.h>
#include <crtdbg.h>
#include <shlwapi.h>
#include <chstring.h>
#include <winver.h>
#include <lm.h>
#include <Wincon.h>
#include <errno.h>
#include<aclapi.h>
#include <strsafe.h>

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\lib\cmdline.c ===
// ****************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//    cmdline.c
//
//  Abstract:
//
//    This modules implements common functionality for all the
//    command line tools.
//
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 01-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 01-Sep-2000 : Created It.
//
// ****************************************************************************

#include "pch.h"

// indexes to the internal array
#define INDEX_ERROR_TEXT                0
#define INDEX_RESOURCE_STRING           1
#define INDEX_QUOTE_STRING              2
#define INDEX_TEMP_BUFFER               3

// permanent indexes to the temporary buffers
#define INDEX_TEMP_SHOWMESSAGE          3
#define INDEX_TEMP_RESOURCE             4
#define INDEX_TEMP_REASON               5
#define INDEX_TEMP_PATTERN              6

//
// global variable(s)
//
BOOL g_bInitialized = FALSE;
BOOL g_bWinsockLoaded = FALSE;
static TARRAY g_arrData = NULL;
static DWORD g_dwMajorVersion = 5;
static DWORD g_dwMinorVersion = 1;
static WORD g_wServicePackMajor = 0;

//
// global constants
//
const WCHAR cwchNullChar = L'\0';
const WCHAR cwszNullString[ 2 ] = L"\0";

//
// internal structures
//
typedef struct __tagBuffer
{
    CHAR szSignature[ 7 ];         // "BUFFER\0"
    DWORD dwLength;
    LPWSTR pwszData;
} TBUFFER;

//
// private functions
//
BOOL InternalRecursiveMatchPatternEx( IN LPCWSTR pwszText, IN LPCWSTR pwszPattern,
                                      IN DWORD dwLocale, IN DWORD dwCompareFlags, IN DWORD dwDepth );

// prototypes
BOOL SetThreadUILanguage0( DWORD dwReserved );

__inline LPWSTR
GetTempBuffer(
              IN DWORD dwIndexNumber,
              IN LPCWSTR pwszText,
              IN DWORD dwLength,
              IN BOOL bNullify
              )
/*++
 Routine Description:

 NOTE: since every file will need the temporary buffers -- in order to see
       that their buffers wont be override with other functions, we are
       creating a for each file
       so, the temporary buffers in this file will range from index 0 to 5
       thisgives total of 6 temporary buffers for this file

 Arguments:
           [IN]      dwIndexNumber      : Index number
           [IN]      pwszText           : Text string
           [IN]      dwLength           : length of the text string
           [IN]      bNullify           : flag to specify either TRUE/FALSE

 Return Value:
         NULL     :   On failure
         LPWSTR   :   On success
--*/
{
    if ( dwIndexNumber >= TEMP_CMDLINE_C_COUNT )
    {
        return NULL;
    }

    // check if caller is requesting existing buffer contents
    if ( pwszText == NULL && dwLength == 0 && bNullify == FALSE )
    {
        // yes -- we need to pass the existing buffer contents
        return GetInternalTemporaryBufferRef( 
            dwIndexNumber + INDEX_TEMP_CMDLINE_C );
    }

    // ...
    return GetInternalTemporaryBuffer(
        dwIndexNumber + INDEX_TEMP_CMDLINE_C, pwszText, dwLength, bNullify );

}


BOOL
InitGlobals()
/*++
 Routine Description:
       Initializes the global variables

 Arguments: None

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check whether the initialization is already done or not
    if ( g_bInitialized == TRUE )
    {
        if ( IsValidArray( g_arrData ) == FALSE )
        {
            // some one corrupted the data
            UNEXPECTED_ERROR();
            return FALSE;
        }
        else
        {
            // just inform the caller that the function call is successful
            return TRUE;
        }
    }
    else if ( g_arrData != NULL )
    {
        UNEXPECTED_ERROR();
        return FALSE;
    }

    // create the dynamic array
    g_arrData = CreateDynamicArray();
    if ( IsValidArray( g_arrData ) == FALSE )
    {
        OUT_OF_MEMORY();
        return FALSE;
    }

    //
    // prepare for the data storage

    // error text
    if ( DynArrayAppendString(g_arrData, cwszNullString, 0) != INDEX_ERROR_TEXT ||
         DynArrayAppendRow( g_arrData, 3 ) != INDEX_RESOURCE_STRING ||
         DynArrayAppendRow( g_arrData, 3 ) != INDEX_QUOTE_STRING    ||
         DynArrayAppendRow( g_arrData, 3 ) != INDEX_TEMP_BUFFER )
    {
        OUT_OF_MEMORY();
        return FALSE;
    }

    // every thing went well -- return
    // though the rest of the code still needs to execute
    // we treat as initialized once we create the global data structure
    g_bInitialized = TRUE;

    //
    // initialize the thread specific resource information to use
    //
    // NOTE: since there is nothing much to do here,
    //       we are intentionally not checking the error code
    //
    if ( SetThreadUILanguage0( 0 ) == FALSE )
    {
        // SetThreadUILanguage0 is supposed to set the errro value
        return FALSE;
    }

    return TRUE;
}


LPWSTR
GetInternalTemporaryBufferRef( IN DWORD dwIndexNumber )
/*++
 Routine Description:

 Arguments:
           [IN]      dwIndexNumber      : Index number

 Return Value:
         NULL      :   On failure
         LPWSTR    :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    TBUFFER* pBuffer = NULL;
    const CHAR cszSignature[ 7 ] = "BUFFER";

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // initialize the global data structure
    if ( g_bInitialized == FALSE )
    {
        return NULL;
    }

    // get the temp buffer array
    dw = DynArrayGetCount2( g_arrData, INDEX_TEMP_BUFFER );
    if ( dw <= dwIndexNumber )
    {
        return NULL;
    }

    // check whether we need to allocate a new TBUFFER or we can use the
    // already allocated
    if ( DynArrayGetItemType2( g_arrData,
                               INDEX_TEMP_BUFFER,
                               dwIndexNumber ) != DA_TYPE_NONE )
    {
        // we can use the already created buffer
        pBuffer = DynArrayItem2( g_arrData, INDEX_TEMP_BUFFER, dwIndexNumber );
        if ( pBuffer == NULL )
        {
            // unexpected behavior
            return NULL;
        }
    }
    else
    {
        return NULL;
    }

    // verify the signature of the buffer
    // this is just to ensure that we have everything in right place
    if ( StringCompareA( pBuffer->szSignature, cszSignature, TRUE, 0 ) != 0 )
    {
        return NULL;
    }

    // return
    return pBuffer->pwszData;
}


LPWSTR
GetInternalTemporaryBuffer( IN DWORD dwIndexNumber,
                            IN OUT LPCWSTR pwszText,
                            IN DWORD dwLength,
                            IN BOOL bNullify )
/*++
 Routine Description:
       Get the temporary buffer by allocating the buffer dynamically

 Arguments:
           [IN]      dwIndexNumber      : Index number
           [IN]      pwszText           : Text string
           [IN]      dwLength           : length of the text string
           [IN]      bNullify           : flag to specify either TRUE/FALSE

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwNewLength = 0;
    TARRAY arrTemp = NULL;
    TBUFFER* pBuffer = NULL;
    const CHAR cszSignature[ 7 ] = "BUFFER";

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input
    if ( pwszText == NULL && dwLength == 0 )
    {
        // caller should pass either of them -- if not fail
        return NULL;
    }

    // initialize the global data structure
    if ( InitGlobals() == FALSE )
    {
        return NULL;
    }

    // get the temp buffer array
    dw = DynArrayGetCount2( g_arrData, INDEX_TEMP_BUFFER );
    if ( dw <= dwIndexNumber )
    {
        // add the some more buffers so that requirement can be satisfied
        arrTemp = DynArrayItem( g_arrData, INDEX_TEMP_BUFFER );
        if ( arrTemp == NULL ||
             DynArrayAddColumns( arrTemp, dwIndexNumber - dw + 1 ) == -1 )
        {
            return NULL;
        }
    }

    // check whether we need to allocate a new TBUFFER or we can use the
    // already allocated
    if ( DynArrayGetItemType2( g_arrData,
                               INDEX_TEMP_BUFFER,
                               dwIndexNumber ) != DA_TYPE_NONE )
    {
        // we can use the already created buffer
        pBuffer = DynArrayItem2( g_arrData, INDEX_TEMP_BUFFER, dwIndexNumber );
        if ( pBuffer == NULL )
        {
            // unexpected behavior
            return NULL;
        }
    }
    else
    {
        // we need to allocate temporary buffer
        pBuffer = (TBUFFER*) AllocateMemory( sizeof( TBUFFER ) );
        if ( pBuffer == NULL )
        {
            return NULL;
        }

        // initialize the block
        pBuffer->dwLength = 0;
        pBuffer->pwszData = NULL;
        StringCopyA( pBuffer->szSignature, cszSignature, SIZE_OF_ARRAY( pBuffer->szSignature ) );

        // save the buffer in array
        if ( DynArraySet2( g_arrData,
                           INDEX_TEMP_BUFFER,
                           dwIndexNumber, pBuffer ) == FALSE )
        {
            // failed to set the buffer -- release the newly allocated
            // and return
            FreeMemory( &pBuffer );
            return NULL;
        }

        //
        // once we save the newly allocated buffer in array -- we are set
        // we need to worry about the furthur return statements -- the memory
        // that is allocated in this section will be automatically released
        // by ReleaseGlobals
        //
    }

    // verify the signature of the buffer
    // this is just to ensure that we have everything in right place
    if ( StringCompareA( pBuffer->szSignature, cszSignature, TRUE, 0 ) != 0 )
    {
        return NULL;
    }

    // indentify the amount of memory required
    // we need extra space for NULL
    dwNewLength = ((pwszText == NULL) ? dwLength : (StringLength(pwszText, 0) + 1));

    // allocate memory for temporary buffer -- if needed
    // NOTE: we will re-allocate memory even if the two-time of current
    // requested buffer length is less than the buffer length that is
    // currently allocated on heap -- this we are doing to use the
    // heap effectively
    if ( dwNewLength > pBuffer->dwLength ||
         ( dwNewLength > 256 && (dwNewLength * 2) < pBuffer->dwLength ) )
    {
        // we need to toggle between allocate / reallocate based on the
        // current length of the string in the TBUFFER
        if ( pBuffer->dwLength == 0 )
        {
            pBuffer->pwszData = AllocateMemory( dwNewLength * sizeof( WCHAR ) );
            if ( pBuffer->pwszData == NULL )
            {
                return NULL;
            }
        }
        else
        {
            if ( ReallocateMemory( &pBuffer->pwszData,
                                   dwNewLength * sizeof( WCHAR ) ) == FALSE )
            {
                return NULL;
            }
        }

        // save the current length of the data
        pBuffer->dwLength = dwNewLength;
    }

    // safety check
    if ( pBuffer->pwszData == NULL )
    {
        return NULL;
    }

    // copy the data
    if ( pwszText != NULL )
    {
        StringCopy( pBuffer->pwszData, pwszText, dwNewLength );
    }
    else if ( bNullify == TRUE )
    {
        ZeroMemory( pBuffer->pwszData, dwNewLength * sizeof( WCHAR ) );
    }

    // return
    return pBuffer->pwszData;
}


BOOL
SetThreadUILanguage0( IN DWORD dwReserved )
/*++
 Routine Description:

      Complex scripts cannot be rendered in the console, so we
      force the English (US) resource.

 Arguments:
      [ in ] dwReserved  => must be zero

 Return Value:
      TRUE      : on Success
      FALSE     : On Failure
--*/
{
    // local variables
    UINT ui = 0;
    UINT uiSize = 0;
    OSVERSIONINFOEX osvi;
    LPWSTR pwszPath = NULL;
    LPCWSTR pwszLibPath = NULL;
    HMODULE hKernel32Lib = NULL;
    DWORDLONG dwlConditionMask = 0;
    const CHAR cszFunctionName[] = "SetThreadUILanguage";
    typedef BOOLEAN (WINAPI * FUNC_SetThreadUILanguage)( DWORD dwReserved );
    FUNC_SetThreadUILanguage pfnSetThreadUILanguage = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // Initialize the OSVERSIONINFOEX structure
    ZeroMemory( &osvi, sizeof( OSVERSIONINFOEX ) );
    osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    osvi.dwMajorVersion = 5;                    // WINDOWS 2000
    osvi.dwMinorVersion = 0;                    // ...
    osvi.wServicePackMajor = 0;                 // ...

    // Initialize the condition mask.
    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL );

    // now check if the current os version is 5.0
    if ( VerifyVersionInfo( &osvi,
                            VER_MAJORVERSION | VER_MINORVERSION,
                            dwlConditionMask ) == TRUE )
    {
        // currently os is W2K -- no need to proceed furthur
        // still the function didn't encounter any error
        // but return success as well as set the error code
        SetLastError( ERROR_OLD_WIN_VERSION );
        return TRUE;
    }

    //
    // get the system files path
    uiSize = MAX_PATH + 1;
    do
    {
        pwszPath = GetTempBuffer( 0, NULL, uiSize + 10, TRUE );
        if ( pwszPath == NULL )
        {
            OUT_OF_MEMORY();
            return FALSE;
        }

        // ...
        ui = GetSystemDirectory( pwszPath, uiSize );
        if ( ui == 0 )
        {
            return FALSE;
        }
        else if ( ui > uiSize )
        {
            // buffer is not sufficient -- need more buffer
            // but check whether this is the first time that
            // API is reported that the buffer is not sufficient
            // if not, then it is an error -- something is going wrong
            if ( uiSize != MAX_PATH + 1 )
            {
                uiSize = ui + 1;
                ui = 0;
            }
            else
            {
                UNEXPECTED_ERROR();
                return FALSE;
            }
        }
    } while ( ui == 0 );

    // we will make use of failure buffer to format the 
    // string for file path
    if ( SetReason2( 2, L"%s\\%s", pwszPath, L"kernel32.dll" ) == FALSE )
    {
        OUT_OF_MEMORY();
        return FALSE;
    }

    // try loading the kernel32 dynamic link library
    pwszLibPath = GetReason();
    hKernel32Lib = LoadLibrary( pwszLibPath );
    if ( hKernel32Lib != NULL )
    {
        // library loaded successfully ... now load the addresses of functions
        pfnSetThreadUILanguage =
            (FUNC_SetThreadUILanguage) GetProcAddress( hKernel32Lib, cszFunctionName );

        // we will keep the library loaded in memory only if all the
        // functions were loaded successfully
        if ( pfnSetThreadUILanguage == NULL )
        {
            // some (or) all of the functions were not loaded ... unload the library
            FreeLibrary( hKernel32Lib );
            hKernel32Lib = NULL;
            return FALSE;
        }
        else
        {
            // call the function
            ((FUNC_SetThreadUILanguage) pfnSetThreadUILanguage)( dwReserved );
        }

        // unload the library and return success
        FreeLibrary( hKernel32Lib );
        hKernel32Lib = NULL;
        pfnSetThreadUILanguage = NULL;
    }
    else
    {
        return FALSE;
    }

    // success
    return TRUE;
}


//
// public functions
//

LPCWSTR
GetReason()
/*++
 Routine Description:

      Get the reason depends on the GetLastError() (WIN32 API error code)
      set by the SaveLastError()

 Arguments:
      None

 Return Value:
      LPCWSTR      : on Success
      NULL_STRING : On Failure
--*/
{
    //
    // we should not clear the error code here
    //

    // check whether buffer is allocated or not ... if not, empty string
    if ( g_arrData == NULL || IsValidArray( g_arrData ) == FALSE )
    {
        return cwszNullString;
    }

    // returh the reason for the last failure
    return DynArrayItemAsString( g_arrData, INDEX_ERROR_TEXT );
}


BOOL
SetReason( LPCWSTR pwszReason )
/*++
 Routine Description:

      Set the reason depends on the GetLastError() (WIN32 API error code)
      set by the SaveLastError()

 Arguments:
      None

 Return Value:
      TRUE      : on Success
      FALSE     : On Failure
--*/
{
    // local variables
    DWORD dwLastError = 0;

    //
    // we should not clear the error code here
    //

    // preserve the last error
    dwLastError = GetLastError();

    // check the input value
    if ( pwszReason == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // initialize the global data structure
    if ( InitGlobals() == FALSE )
    {
        return FALSE;
    }

    // set the reason ..
    if ( DynArraySetString( g_arrData, INDEX_ERROR_TEXT, pwszReason, 0 ) == FALSE )
    {
        OUT_OF_MEMORY();
        return FALSE;
    }

    SetLastError( dwLastError );
    return TRUE;
}


BOOL
SetReason2( IN DWORD dwCount,
            IN LPCWSTR pwszFormat, ... )
/*++
 Routine Description:

      Saves text in memory
      Generally used for saving the reason for the failure but can be used
      in any context.

      This variant of SetReason accepts variable no. of arguments just as
      sprintf statements and does the formatting

 Arguments:
      [ in ] dwCount    :   Specifies no. of variable no. of arguments being
                            passed to this function
      [ in ] pwszFormat :   Specifies the format string -- to format the text
      [ in ] ...        :   Variable no. of arguments specification

 Return Value:
      TRUE      : on Success
      FALSE     : On Failure
--*/
{
    // local variables
    va_list vargs;
    DWORD dwBufferLength = 0;
    LPWSTR pwszBuffer = NULL;
    HRESULT hr = S_OK;

    //
    // we should not clear the error code here
    //

    // check the input
    if ( pwszFormat == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }
    else if ( dwCount == 0 )
    {
        SetReason( pwszFormat );
        return TRUE;
    }

    do
    {
        // get the variable args start position
        va_start( vargs, pwszFormat );
        if ( vargs == NULL )
        {
            UNEXPECTED_ERROR();
            return FALSE;
        }

        // we will start with buffer length of 256 bytes and then increment
        // the buffer by 256 bytes each time we run thru this loop
        dwBufferLength += 256;
        if ( (pwszBuffer = GetTempBuffer( INDEX_TEMP_REASON,
                                          NULL, dwBufferLength, TRUE )) == NULL )
        {
            OUT_OF_MEMORY();
            return FALSE;
        }

        // try the printf
        hr = StringCchVPrintfW( pwszBuffer, dwBufferLength, pwszFormat, vargs );

        // reset the va_list parameter
        va_end( vargs );
    } while ( hr == STRSAFE_E_INSUFFICIENT_BUFFER );

    // check the hr (vprintf might have failed for some other reason)
    if ( FAILED( hr ) )
    {
        SetLastError( HRESULT_CODE( hr ) );
        return FALSE;
    }

    // now save the reason
    return SetReason( pwszBuffer );
}


BOOL
SaveLastError()
/*++
 Routine Description:
       Format the message depends on GetLastError() error code and set the
       message to SetReason().

 Arguments: None

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    BOOL bResult = FALSE;
    LPVOID lpMsgBuf = NULL;     // pointer to handle error message

    //
    // we should not clear the error text here
    //

    // load the system error message from the windows itself
    dw = FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, GetLastError(), 0, (LPWSTR) &lpMsgBuf, 0, NULL );

    // check the function call succeeded or not
    if ( dw == 0 || lpMsgBuf == NULL )
    {
        // return
        if ( lpMsgBuf != NULL )
        {
            LocalFree( lpMsgBuf );

            // since there is a chance of last error to get clear
            // by LocalFree, set the last error once again
            OUT_OF_MEMORY();
        }

        // ...
        OUT_OF_MEMORY();
        return FALSE;
    }

    // save the error message
    bResult = SetReason( ( LPCWSTR ) lpMsgBuf );

    // Free the buffer ... using LocalFree is slow, but still, we are using ...
    //                     later on need to replaced with HeapXXX functions
    LocalFree( lpMsgBuf );
    lpMsgBuf = NULL;

    // return
    return bResult;
}


DWORD
WNetSaveLastError()
/*++
 Routine Description:
       Format the message depends on most recent extended error code and set the
       message to SetReason().

 Arguments: None

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
    DWORD dwResult = 0;
    DWORD dwErrorCode = 0;
    LPWSTR pwszMessage = NULL;      // handle error message
    LPWSTR pwszProvider = NULL;     // store the provider for error

    //
    // we should not clear error here
    //

    //
    // get the memory for message and provider buffers

    // message
    if ( (pwszMessage = GetTempBuffer( 0, NULL, 256, TRUE )) == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // provider
    if ( (pwszProvider = GetTempBuffer( 1, NULL, 256, TRUE )) == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // load the system error message from the windows itself
    dwResult = WNetGetLastError( &dwErrorCode,
        pwszMessage, (GetBufferSize( pwszMessage ) / sizeof( WCHAR )) - 1,
        pwszProvider, (GetBufferSize( pwszProvider ) / sizeof( WCHAR )) - 1 );

    // check whether the function succeeded or not
    if ( dwResult != NO_ERROR )
    {
        return dwResult;
    }

    // save the error
    if ( SetReason( pwszMessage ) == FALSE )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // return the error code obtained
    return dwErrorCode;
}


BOOL
ShowLastError( IN FILE* fp )
/*++
 Routine Description:
       Displays the message for most recent error code (GetLastError())
       based on the file pointer

 Arguments: None

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    //
    // we should not clear error here
    //

    // save the last error first
    if ( SaveLastError() == FALSE )
    {
        // error occured while trying to save the error message
        return FALSE;
    }

    // display error message on console screen ...
    if ( ShowMessage( fp, GetReason() ) == FALSE )
    {
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
ShowLastErrorEx( IN FILE* fp,
                 IN DWORD dwFlags )
/*++
 Routine Description:


 Arguments:


 Return Value:
--*/
{
    // check the input
    if ( NULL == fp || 0 == (dwFlags & SLE_MASK) )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // check whether to display the internal error message
    // or the system error
    if ( dwFlags & SLE_SYSTEM )
    {
        SaveLastError();
    }

    // check the flags and show the appropriate tag
    // NOTE: some times, caller even might not need the flag to show
    if ( dwFlags & SLE_TYPE_ERROR )
    {
        ShowMessageEx( fp, 1, TRUE, L"%s ", TAG_ERROR );
    }
    else if ( dwFlags & SLE_TYPE_WARNING )
    {
        ShowMessageEx( fp, 1, TRUE, L"%s ", TAG_WARNING );
    }
    else if ( dwFlags & SLE_TYPE_INFO )
    {
        ShowMessageEx( fp, 1, TRUE, L"%s ", TAG_INFORMATION );
    }
    else if ( dwFlags & SLE_TYPE_SUCCESS )
    {
        ShowMessageEx( fp, 1, TRUE, L"%s ", TAG_SUCCESS );
    }


    // show the actual error message
    ShowMessage( fp, GetReason() );

    return TRUE;
}


BOOL
ReleaseGlobals()
/*++
 Routine Description:
       De-allocate the memory for all the global variables

 Arguments: None

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwCount = 0;
    TBUFFER* pBuffer = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    //
    // memory is allocated then free memory
    // do this only if the memory is allocated

    if ( IsValidArray( g_arrData ) == TRUE )
    {
        // release memory allocated for temporary buffers
        dwCount = DynArrayGetCount2( g_arrData, INDEX_TEMP_BUFFER );
        for( dw = dwCount; dw != 0; dw-- )
        {
            if ( DynArrayGetItemType2( g_arrData,
                                       INDEX_TEMP_BUFFER, dw - 1 ) == DA_TYPE_GENERAL )
            {
                pBuffer = DynArrayItem2( g_arrData, INDEX_TEMP_BUFFER, dw - 1 );
                if ( pBuffer == NULL )
                {
                    // this is error condition -- still ignore
                    continue;
                }

                // release data first
                FreeMemory( &pBuffer->pwszData );

                // now release the memory
                FreeMemory( &pBuffer );

                // remove the item from dynamic array
                DynArrayRemoveColumn( g_arrData, INDEX_TEMP_BUFFER, dw - 1 );
            }
        }

        // free the memory allocated for global data storage
        DestroyDynamicArray( &g_arrData );
    }

    // if winsock module is loaded, release it
    if ( g_bWinsockLoaded == TRUE )
    {
        WSACleanup();
    }

    return TRUE;
}


BOOL
IsWin2KOrLater()
/*++
 Routine Description:
      Checks whether the OS version of target system is WINDOWS 2000 or later

 Arguments: None

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
    OSVERSIONINFOEX osvi;
    DWORDLONG dwlConditionMask = 0;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // Initialize the OSVERSIONINFOEX structure.
    ZeroMemory( &osvi, sizeof( OSVERSIONINFOEX ) );
    osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    osvi.dwMajorVersion = g_dwMajorVersion;
    osvi.dwMinorVersion = g_dwMinorVersion;
    osvi.wServicePackMajor = g_wServicePackMajor;

    // Initialize the condition mask.
    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL );

    // Perform the test.
    return VerifyVersionInfo( &osvi, VER_MAJORVERSION | VER_MINORVERSION, dwlConditionMask );
}

BOOL
IsCompatibleOperatingSystem( IN DWORD dwVersion )
/*++
 Routine Description:
      Checks whether the OS version of target system is compatible or not

 Arguments: None

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // OS version above windows 2000 is compatible
    return (dwVersion >= 5000);
}


BOOL
SetOsVersion( IN DWORD dwMajor,
              IN DWORD dwMinor,
              IN WORD wServicePackMajor )
/*++
 Routine Description:
      Sets the OS version of target system with the specified mask

 Arguments:
           [IN]      dwMajor      : Major version
           [IN]      dwMinor      : Minor version
           [IN]      wServicePackMajor    : Service pack major version

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
    static BOOL bSet = FALSE;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // we won't support below Windows 2000
    if ( dwMajor < 5 || bSet == TRUE )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // rest of information we need not bother
    bSet = TRUE;
    g_dwMajorVersion = dwMajor;
    g_dwMinorVersion = dwMinor;
    g_wServicePackMajor = wServicePackMajor;

    // return
    return TRUE;
}


LPCWSTR
GetResString( IN UINT uID )
/*++
 Routine Description:
      Sets the OS version of target system with the specified mask

 Arguments:
           [IN]      uID      : Resource ID

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    static DWORD dwCount = 0;

    dwCount++;
    return GetResString2( uID, 4 + (dwCount % 10) );
}


LPCWSTR
GetResString2( IN UINT uID,
               IN DWORD dwIndexNumber )
/*++
 Routine Description:
      Sets the OS version of target system with the specified mask

 Arguments:
           [IN]      uID      : Resource ID
           [IN]      dwIndexNumber     : Index number

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
    DWORD dwCount = 0;
    DWORD dwLength = 0;
    LPVOID pvBuffer = NULL;
    TARRAY arrTemp = NULL;
    LPWSTR pwszTemp = NULL;     // pointer to handle error message

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input value
    if ( uID == 0 )
    {
        INVALID_PARAMETER();
        return cwszNullString;
    }

    // initialize the gloabal data structure
    if ( InitGlobals() == FALSE )
    {
        return cwszNullString;
    }

    // check whether we have sufficient indexes or not
    dwCount = DynArrayGetCount2( g_arrData, INDEX_RESOURCE_STRING );
    if (  dwCount <= dwIndexNumber )
    {
        // requested index is more than existing
        // add new columns to the array so that request can be satisfied
        arrTemp = DynArrayItem( g_arrData, INDEX_RESOURCE_STRING );
        if ( arrTemp == NULL ||
             DynArrayAddColumns( arrTemp, dwIndexNumber - dwCount + 1 ) == -1 )
        {
            OUT_OF_MEMORY();
            return cwszNullString;
        }
    }

    //
    // we need to load the entire string that is defined string table
    // we will try to load the string incrementing our buffer by 128 bytes
    // at a time
    dwCount = 0;
    dwLength = 128;

    // ...
    do
    {
        // increment the buffer length by 256
        // we will always double the length we curretly have
        dwLength *= 2;

        //
        // LoadString will null terminate the string with null character
        // and will return the no. of characters read from string table
        // not including the null terminator -- so at all times, in order
        // make sure that we load the entire string from the string table
        // check the no. of characters returned with one less than the buffer
        // we have -- if that condition matches, we will loop once again
        // to load the rest of the string and we will continue this way
        // until we got the entire string into memory
        //

        // loading the string from resource file string table
        if ( (pwszTemp = GetTempBuffer( INDEX_TEMP_RESOURCE,
                                        NULL, dwLength, TRUE )) == NULL )
        {
            OUT_OF_MEMORY();
            return cwszNullString;
        }

        // try to load the string
        dwCount = LoadString( NULL, uID, pwszTemp, dwLength );
        if ( dwCount == 0 )
        {
            // check the last error
            if ( GetLastError() == ERROR_RESOURCE_NAME_NOT_FOUND )
            {
                // try if message exists in the message table
                dwCount = FormatMessageW( FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    NULL, uID, 0, (LPWSTR) &pvBuffer, 0, NULL );

                // check the result
                if ( dwCount != 0 )
                {
                    pwszTemp = (LPWSTR) pvBuffer;
                }
            }

            if ( dwCount == 0 )
            {
                // error occurred -- return
                return cwszNullString;
            }
        }
    } while ( dwCount >= (dwLength - 1) );


    // save the resource message
    // and check whether we are successful in saving the resource text or not
    if ( DynArraySetString2( g_arrData,
                             INDEX_RESOURCE_STRING,
                             dwIndexNumber, pwszTemp, 0 ) == FALSE )
    {
        OUT_OF_MEMORY();
        return cwszNullString;
    }

    // free the memory allocated with FormatMessage function
    if ( pvBuffer != NULL )
    {
        LocalFree( pvBuffer );
        pvBuffer = NULL;
    }

    // return
    return DynArrayItemAsString2( g_arrData, INDEX_RESOURCE_STRING, dwIndexNumber );
}


double
AsFloat( IN LPCWSTR pwszValue )
/*++
 Routine Description:
      Gets the float value for a given string

 Arguments:
           [IN]      pwszValue      : Input string

 Return Value:
       0.0f    :   On failure
       double value   :   On success
--*/
{
    // local variables
    double dblValue = 0.0f;
    LPWSTR pwszStopString = NULL;
    LPCWSTR pwszValueString = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input value
    if ( pwszValue == NULL || StringLength( pwszValue, 0 ) == 0 )
    {
        INVALID_PARAMETER();
        return 0.0f;
    }

    // initialize the global data structure
    if ( InitGlobals() == FALSE )
    {
        return 0.0f;
    }

    // get the temporary memory location
    pwszValueString = GetTempBuffer( 0, pwszValue, 0, FALSE );
    if ( pwszValueString == NULL )
    {
        OUT_OF_MEMORY();
        return 0.0f;
    }

    // convert the string value into double value and return the same
    dblValue = wcstod( pwszValueString, &pwszStopString );

    // determine whether the conversion took place properly or not
    // value is invalid if
    //      1. overflow / underflow occured
    //      2. pwszStopString's length is not equal to 0
    if ( errno == ERANGE ||
         ( pwszStopString != NULL && StringLength( pwszStopString, 0 ) != 0 ) )
    {
        INVALID_PARAMETER();
        return 0.0f;
    }

    // return the value
    return dblValue;
}


BOOL
IsFloatingPoint( IN LPCWSTR pwszValue )
/*++
 Routine Description:
      Checks whether the given string is float value or not

 Arguments:
           [IN]      pwszValue      : Input string

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // attempt to convert the value
    AsFloat( pwszValue );

    // check the error code
    return (GetLastError() == NO_ERROR);
}


LONG
AsLong( IN LPCWSTR pwszValue, 
        IN DWORD dwBase )
/*++
 Routine Description:
      Gets the long value for a given string

 Arguments:
           [IN]      pwszValue      : Input string
           [IN]      dwBase         : Base value


 Return Value:
       0L    :   On failure
       Long value    :   On success
--*/
{
    // local variables
    LONG lValue = 0L;
    LPWSTR pwszStopString = NULL;
    LPWSTR pwszValueString = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // validate the base
    // value should be in the range of 2 - 36 only
    if ( dwBase < 2 || dwBase > 36 || pwszValue == NULL )
    {
        INVALID_PARAMETER();
        return 0L;
    }

    // initialize the global data structure
    // and save the current value in global data structure
    if ( InitGlobals() == FALSE )
    {
        return 0L;
    }

    // get the temporary buffer
    pwszValueString = GetTempBuffer( 0, pwszValue, 0, FALSE );
    if ( pwszValueString == NULL )
    {
        OUT_OF_MEMORY();
        return 0L;
    }

	// trim the string
	TrimString2( pwszValueString, NULL, TRIM_ALL );
	if ( StringLength( pwszValueString, 0 ) == 0 )
	{
        INVALID_PARAMETER();
        return 0L;
	}

    // convert the string value into long value and return the same
	// based on the "sign" of the number choose the path
	if ( pwszValueString[ 0 ] == L'-' )
	{
		lValue = wcstol( pwszValueString, &pwszStopString, dwBase );
	}
	else
	{
		// NOTE: though we are not capturing the return value into 
		//       unsigned long we do need to call the unsigned long conversion function
		lValue = wcstoul( pwszValueString, &pwszStopString, dwBase );
	}

    // determine whether the conversion took place properly or not
    // value is invalid if
    //      1. overflow / underflow occured
    //      2. pwszStopString's length is not equal to 0
    if ( errno == ERANGE ||
         ( pwszStopString != NULL && StringLength( pwszStopString, 0 ) != 0 ) )
    {
        INVALID_PARAMETER();
        return 0L;
    }

    // return
    return lValue;
}


BOOL
IsNumeric( IN LPCWSTR pwszValue,
           IN DWORD dwBase,
           IN BOOL bSigned )
/*++
 Routine Description:
      Checks whether the given string is numeric or not

 Arguments:
           [IN]      pwszValue   : Input string
           [IN]      dwBase      : Base value
           [IN]      bSigned     : Sign Value (+/-)

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
	LPWSTR pwszNumber = NULL;
    LPWSTR pwszStopString = NULL;

	// check the input:
    // validate the base
    // value should be in the range of 2 - 36 only
    if ( dwBase < 2 || dwBase > 36 || pwszValue == NULL )
    {
        INVALID_PARAMETER();
        return 0L;
    }

	// to better validate the numeric values we need the TRIMmed string
	pwszNumber = GetTempBuffer( 0, pwszValue, 0, FALSE );
	if ( pwszNumber == NULL )
	{
        OUT_OF_MEMORY();
        return FALSE;
	}

	// trim the string contents
	TrimString2( pwszNumber, NULL, TRIM_ALL );

    // check the length
    if( StringLength( pwszNumber, 0 ) == 0 )
    {
        return FALSE; 
    }

	// validate the "sign"
	if ( bSigned == FALSE && pwszNumber[ 0 ] == L'-' )
	{
		return FALSE;
	}

    // convert the string value into long value and return the same
	if ( bSigned == TRUE )
	{
		wcstol( pwszNumber, &pwszStopString, dwBase );
	}
	else
	{
		wcstoul( pwszNumber, &pwszStopString, dwBase );
	}

    // determine whether the conversion took place properly or not
    // value is invalid if
    //      1. overflow / underflow occured
    //      2. pwszStopString's length is not equal to 0
    if ( errno == ERANGE ||
         ( pwszStopString != NULL && StringLength( pwszStopString, 0 ) != 0 ) )
    {
        return FALSE;
    }

    // value is valid numeric
    return TRUE;
}

LPCWSTR
FindChar( IN LPCWSTR pwszString,
          IN WCHAR wch,
          IN DWORD dwFrom )
/*++
 Routine Description:
      Searches a string for the first occurrence of a character that
      matches the specified character. The comparison is not case sensitive.

 Arguments:
           [IN]      pwszValue   : Address of the string to be searched.
           [IN]      wch         : Character to be used for comparison.
           [IN]      dwFrom      : to start from the location

 Return Value:
       NULL    :   On failure
       LPWSTR    :   On success
--*/
{
    // local variables
    LONG lIndex = 0;

    lIndex = FindChar2( pwszString, wch, TRUE, dwFrom );
    if ( lIndex == -1 )
    {
        return NULL;
    }

    return pwszString + lIndex;
}


LONG
FindChar2( IN LPCWSTR pwszString,
           IN WCHAR wch,
           IN BOOL bIgnoreCase,
           IN DWORD dwFrom )
/*++
 Routine Description:
      Searches a string for the first occurrence of a character that
      matches the specified character. The comparison either (case sensitive/in-sensitive)
      depends on the bIgoneCase value.

 Arguments:
           [IN]      pwszValue   : Address of the string to be searched.
           [IN]      wch         : Character to be used for comparison.
           [IN]      bIgnoreCase : Flag to check for case sensitive/in-sensitive
                                   If FALSE, case sensitive else in-sensitive
           [IN]      dwFrom      : to start from the location

 Return Value:
       0    :   On failure
       Long value    :   On success
--*/
{
    // local variables
    DWORD dwLength = 0;
    LPWSTR pwsz = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the inputs
    if ( pwszString == NULL )
    {
        INVALID_PARAMETER();
        return -1;
    }

    // check the length of the text that has to be find. if it is
    // more than the original it is obvious that it cannot be found
    dwLength = StringLength( pwszString, 0 );
    if ( dwLength == 0 || dwFrom >= dwLength )
    {
        SetLastError( ERROR_NOT_FOUND );
        return -1;
    }

    // search for the character
    if ( bIgnoreCase == TRUE )
    {
        pwsz = StrChrI( pwszString + dwFrom, wch );
    }
    else
    {
        pwsz = StrChr( pwszString + dwFrom, wch );
    }

    // check the result
    if ( pwsz == NULL )
    {
        SetLastError( ERROR_NOT_FOUND );
        return -1;
    }

    // determine the position and return
    return (LONG) (DWORD_PTR)(pwsz - pwszString);
}


BOOL
InString( IN LPCWSTR pwszString,
          IN LPCWSTR pwszList,
          IN BOOL bIgnoreCase )
/*++
 Routine Description:
      Checks for the first occurrence of one string within the list.

 Arguments:
           [IN]      pwszValue   : Address of the string
           [IN]      pwsz         : List of string to be searched for
           [IN]      bIgnoreCase : Flag to check for case sensitive/in-sensitive
                                   If FALSE, case sensitive else in-sensitive

 Return Value:
       FALSE    :   On failure
       TRUE    :   On success
--*/
{
    // local variables
    DWORD dwListLength = 0;
    DWORD dwStringLength = 0;
    LPWSTR pwszFmtList = NULL;
    LPWSTR pwszFmtString = NULL;
    HRESULT hr = S_OK;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input value
    if ( pwszString == NULL || pwszList == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    //
    // get memory for the temporary buffers
    // | + length of the original string ( list / string ) + | + NULL + NULL

    // format list
    dwListLength = StringLength( pwszList, 0 ) + 4;
    if ( (pwszFmtList = GetTempBuffer( 0,
                                       NULL,
                                       dwListLength, TRUE )) == NULL )
    {
        OUT_OF_MEMORY();
        return FALSE;
    }

    // format string
    dwStringLength = StringLength( pwszString, 0 ) + 4;
    if ( (pwszFmtString = GetTempBuffer( 1,
                                         NULL,
                                         dwStringLength, TRUE )) == NULL )
    {
        OUT_OF_MEMORY();
        return FALSE;
    }

    // prepare the strings for searching
    hr = StringCchPrintfW( pwszFmtList, dwListLength, L"|%s|", pwszList );
    if ( FAILED( hr ) )
    {
        SetLastError( HRESULT_CODE( hr ) );
        return FALSE;
    }

    hr = StringCchPrintfW( pwszFmtString, dwStringLength, L"|%s|", pwszString );
    if ( FAILED( hr ) )
    {
        SetLastError( HRESULT_CODE( hr ) );
        return FALSE;
    }

    // search for the string in the list and return result
    return (FindString2( pwszFmtList, pwszFmtString, bIgnoreCase, 0 ) != -1);
}


LPCWSTR
FindOneOf( IN LPCWSTR pwszText,
           IN LPCWSTR pwszTextToFind,
           IN DWORD dwFrom )
/*++
 Routine Description:
      Finds the first occurrence one of characters from a substring within a string.
      The comparison is not case sensitive.

 Arguments:
           [IN]      pwszText   : Address of the string being searched.
           [IN]      pwszTextToFind   : Substring to search for.
           [IN]      dwFrom : to start from the location


 Return Value:
       FALSE    :   On failure
       TRUE    :   On success
--*/
{
    // local variables
    LONG lIndex = 0;

    lIndex = FindOneOf2( pwszText, pwszTextToFind, TRUE, dwFrom );
    if ( lIndex == -1 )
    {
        return NULL;
    }

    return pwszText + lIndex;
}


LONG
FindOneOf2( IN LPCWSTR pwszText,
            IN LPCWSTR pwszTextToFind,
            IN BOOL bIgnoreCase,
            IN DWORD dwFrom )
/*++
 Routine Description:
      Finds the first occurrence one of characters from a substring within a string.
      The comparison is either case sensitive/in-sensitive depends on
      bIgnoreCase value.

Arguments:
           [IN]      pwszText   : Address of the string being searched.
           [IN]      pwszTextToFind   : Substring to search for.
           [IN]      bIgnoreCase : Flag to check for case sensitive/in-sensitive
                                   If FALSE, case sensitive else in-sensitive
           [IN]      dwFrom : to start from the location


 Return Value:
       0L   :   On failure
       Long value    :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    LONG lResult = 0;
    DWORD dwFindLength = 0;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the inputs
    if ( pwszText == NULL || pwszTextToFind == NULL )
    {
        INVALID_PARAMETER();
        return -1;
    }

    // get the length of the find string
    dwFindLength = StringLength( pwszTextToFind, 0 );

    // check the length of the text that has to be find. if it is
    // more than the original it is obvious that it cannot be found
    if ( dwFindLength == 0 ||
         StringLength( pwszText, 0 ) == 0 ||
         dwFrom >= (DWORD) StringLength( pwszText, 0 ) )
    {
        SetLastError( ERROR_NOT_FOUND );
        return -1;
    }

    // traverse thru the original text
    for( dw = 0; dw < dwFindLength; dw++ )
    {
        // search for the character
        lResult = FindChar2( pwszText, pwszTextToFind[ dw ], bIgnoreCase, dwFrom );
        if ( lResult != -1 )
        {
            return lResult;
        }
    }

    // string not found
    SetLastError( ERROR_NOT_FOUND );
    return -1;
}

LPCWSTR
FindString( IN LPCWSTR pwszText,
            IN LPCWSTR pwszTextToFind,
            IN DWORD dwFrom )
/*++
 Routine Description:
      Finds the first occurrence of a substring within a string.
      The comparison is not case sensitive.

Arguments:
           [IN]      pwszText   : Address of the string being searched.
           [IN]      pwszTextToFind   : Substring to search for.
           [IN]      dwFrom : to start from the location


 Return Value:
       0L   :   On failure
       Long value    :   On success
--*/
{
    // local variables
    LONG lIndex = 0;

    lIndex = FindString2( pwszText, pwszTextToFind, TRUE, dwFrom );
    if ( lIndex == -1 )
    {
        return NULL;
    }

    return pwszText + lIndex;
}


LONG
FindString2( IN LPCWSTR pwszText,
             IN LPCWSTR pwszTextToFind,
             IN BOOL bIgnoreCase,
             IN DWORD dwFrom )
/*++
 Routine Description:
      Finds the first occurrence of a substring within a string.
      The comparison is either case sensitive/in-sensitive depends on
      bIgnoreCase value.

Arguments:
           [IN]      pwszText   : Address of the string being searched.
           [IN]      pwszTextToFind   : Substring to search for.
           [IN]      bIgnoreCase : Flag to check for case sensitive/in-sensitive
                                   If FALSE, case sensitive else in-sensitive
           [IN]      dwFrom : to start from the location


 Return Value:
       0L   :   On failure
       Long value    :   On success
--*/
{
    // local variables
    DWORD dwLength = 0;
    DWORD dwFindLength = 0;
    LPWSTR pwsz = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the inputs
    if ( pwszText == NULL || pwszTextToFind == NULL )
    {
        INVALID_PARAMETER();
        return -1;
    }

    // get the lengths
    dwLength = StringLength( pwszText, 0 );
    dwFindLength = StringLength( pwszTextToFind, 0 );

    // check the length of the text that has to be find. if it is
    // more than the original it is obvious that it cannot be found
    if ( dwFindLength == 0 || dwLength == 0 ||
         dwFrom >= dwLength || (dwLength - dwFrom < dwFindLength) )
    {
        SetLastError( ERROR_NOT_FOUND );
        return -1;
    }

    // do the search
    if ( bIgnoreCase == TRUE )
    {
        pwsz = StrStrI( pwszText + dwFrom, pwszTextToFind );
    }
    else
    {
        pwsz = StrStr( pwszText + dwFrom, pwszTextToFind );
    }

    if ( pwsz == NULL )
    {
        // string not found
        SetLastError( ERROR_NOT_FOUND );
        return -1;
    }

    // determine the position an return
    return (LONG) (DWORD_PTR)(pwsz - pwszText);
}


LONG
StringLengthInBytes( IN LPCWSTR pwszText )
/*++
 Routine Description:
      Finds length of a given string

Arguments:
           [IN]      pwszText   : Address of the string being searched.

 Return Value:
       0L   :   On failure
       Long value    :   On success
--*/
{
    // local variables
    LONG lLength = 0;

    if ( NULL == pwszText || StringLength( pwszText, 0 ) == 0)
    {
        return 0;
    }

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // get the length of the string in bytes
    // since this function includes the count for null character also, ignore that information
    lLength = WideCharToMultiByte( _DEFAULT_CODEPAGE, 0, pwszText, -1, NULL, 0, NULL, NULL ) - 1;

    // return the length information
    return lLength;
}


LPCWSTR
TrimString( IN OUT LPWSTR pwszString,
            IN     DWORD dwFlags )
/*++
 Routine Description:
      Removes (trims) spaces/tabs from a string.

Arguments:
           [IN]      pwszString   : Address of the string to be trimmed.
           [IN]      dwFlags      : Flags to trim LEFT or RIGHT or both sides

 Return Value:
       0L   :   On failure
       Long value    :   On success
--*/
{
    return TrimString2( pwszString, NULL, dwFlags );

}


LPCWSTR
TrimString2( IN OUT LPWSTR pwszString,
             IN     LPCWSTR pwszTrimChars,
             IN     DWORD dwFlags )
/*++
 Routine Description:
      Removes (trims) specified leading and trailing characters from a string.

Arguments:
           [IN]      pwszString   : Address of the string to be trimmed.
           [IN]      pwszString   : characters will be trimmed from pwszString.
           [IN]      dwFlags      : Flags to trim LEFT or RIGHT or both sides

 Return Value:
       0L   :   On failure
       Long value    :   On success
--*/
{
    //sub-local variables
    LPWSTR psz = NULL;
    LPWSTR pszStartMeAt = NULL;
    LPWSTR pszMark = NULL;
    const WCHAR wszDefaultTrimChars[3] = L" \t";

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check for empty string
    if ( NULL == pwszString || StringLength( pwszString , 0 ) == 0 )
    {
        // there is no need to set any error here..
        // if string is empty.. then return the same.
        return cwszNullString;
    }

    // check for empty string.. if pwszTrimChars is empty,
    // by default it trims spaces and tabs
    if ( NULL == pwszTrimChars || StringLength( pwszTrimChars, 0 ) == 0 )
    {
        pwszTrimChars = wszDefaultTrimChars;

    }

    //
    // Trim leading characters.
    //
    psz = pwszString;

    //check whether to trim left or both side(s)
    if ( (dwFlags == TRIM_ALL) || (dwFlags == TRIM_LEFT) )
    {
        //search for character(s) to trim
        while (*psz && StrChrW(pwszTrimChars, *psz))
        {
            //increment the address
            psz++;
        }

        pszStartMeAt = psz;
    }

    //
    // Trim trailing characters.
    //

    //check whether to trim right or both side(s)
    if ( (dwFlags == TRIM_ALL) || (dwFlags == TRIM_RIGHT) )
    {
        if (dwFlags == TRIM_RIGHT)
        {
            psz = pwszString;
        }

        while (*psz)
        {
            //search for character(s) to trim
            if (StrChrW(pwszTrimChars, *psz))
            {
                if (!pszMark)
                {
                    pszMark = psz;
                }
            }
            else
            {
                pszMark = NULL;
            }

            //increment the address
            psz++;
        }

        // Any trailing characters to clip?
        if ( pszMark != NULL )
        {
            // Yes.. set NULL character..
            *pszMark = '\0';
        }

    }

    /* Relocate stripped string. */

    if (pszStartMeAt > pwszString)
    {
        /* (+ 1) for null terminator. */
        StringCopy ( pwszString, pszStartMeAt, StringLength(pszStartMeAt, 0) + 1 );
    }

    // return the trimmed string
    return pwszString;
}


LPCWSTR
QuoteMeta( IN LPCWSTR pwszText,
           IN DWORD dwQuoteIndex )
/*++
 Routine Description:
      Formats the string properly if the string contains any '%' characters

Arguments:
           [IN]      pwszString   : Address of the string.
           [IN]      dwQuoteIndex   : Index number

 Return Value:
       NULL   :   On failure
       LPWSTR    :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwIndex = 0;
    DWORD dwBufLen = 0;
    DWORD dwLength = 0;
    TARRAY arrQuotes = NULL;
    LPCWSTR pwszTemp = NULL;
    LPWSTR pwszQuoteText = NULL;
    const WCHAR pwszQuoteChars[] = L"%";

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the inputs
    if ( pwszText == NULL || dwQuoteIndex == 0 )
    {
        INVALID_PARAMETER();
        return cwszNullString;
    }

    // determine the length of the text that needs to be quoted
    dwLength = StringLength( pwszText, 0 );
    if ( dwLength == 0 )
    {
        return pwszText;
    }

    // check whether the special chacters do exist in the text or not
    // if not, simply return
    else if ( FindOneOf( pwszText, pwszQuoteChars, 0 ) == NULL )
    {
        return pwszText;
    }

    // initialize the global data structure
    if ( InitGlobals() == FALSE )
    {
        return cwszNullString;
    }

    // get the quotes array pointer
    arrQuotes = DynArrayItem( g_arrData, INDEX_QUOTE_STRING );
    if ( arrQuotes == NULL )
    {
        UNEXPECTED_ERROR();
        return cwszNullString;
    }

    // though the quote index needs to be > 0 when passing to this function,
    // internally we need this to be 1 less than the value passed -- so
    dwQuoteIndex--;

    // check whether needed indexes exist or not
    dwIndex = DynArrayGetCount( arrQuotes );
    if ( dwIndex <= dwQuoteIndex )
    {
        // add the needed no. of columns
        dw = DynArrayAddColumns( arrQuotes, dwQuoteIndex - dwIndex + 1 );

        // check whether columns were added or not
        if ( dw != dwQuoteIndex - dwIndex + 1 )
        {
            OUT_OF_MEMORY();
            return cwszNullString;
        }
    }

    // allocate the buffer ... it should twice the original
    dwBufLen = (dwLength + 1) * 2;
    pwszQuoteText = GetTempBuffer( 0, NULL, dwBufLen, TRUE );
    if ( pwszQuoteText == NULL )
    {
        OUT_OF_MEMORY();
        return cwszNullString;
    }

    // do the quoting ...
    dwIndex = 0;
    for( dw = 0; dw < dwLength; dw++ )
    {
        // check whether the current character is quote char or not
        // NOTE: for time being this function only suppresses the '%' character escape sequences
        if ( FindChar( pwszQuoteChars, pwszText[ dw ], 0 ) != NULL )
        {
            pwszQuoteText[ dwIndex++ ] = L'%';
        }

        // copy the character
        pwszQuoteText[ dwIndex++ ] = pwszText[ dw ];

        // it is obvious that we wont come into this condition
        // but, makes no difference if we are more cautious on this
        if ( dwIndex == dwBufLen - 1 )
        {
            // error, error -- we should never come here
            // this is because even if the original string is full of
            // '%' characters, we are allocating memory for two null characters
            // which means, the loop should be terminated before falling into
            // this condition
            break;
        }
    }

    // put the null character
    pwszQuoteText[ dwIndex ] = cwchNullChar;

    // save the quoted text in dynamic array
    if ( DynArraySetString( arrQuotes, dwQuoteIndex, pwszQuoteText, 0 ) == FALSE )
    {
        OUT_OF_MEMORY();
        return cwszNullString;
    }

    // get the text from the array
    pwszTemp = DynArrayItemAsString( arrQuotes, dwQuoteIndex );
    if ( pwszTemp == NULL )
    {
        UNEXPECTED_ERROR();
        return cwszNullString;
    }

    // return
    return pwszTemp;
}


LPCWSTR
AdjustStringLength( IN LPWSTR pwszValue,
                    IN DWORD dwLength,
                    IN BOOL bPadLeft )
/*++
 Routine Description:
      Adjusts the string length by padding spaces for displaying output in
      LIST, TABLE or CSV formats

Arguments:
           [IN]      pwszValue   : Address of the string.
           [IN]      dwLength   : Index number
           [IN]      bPadLeft   : Flag to pad left/right spaces

 Return Value:
       NULL   :   On failure
       LPWSTR    :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwTemp = 0;
    DWORD dwBufLen = 0;
    DWORD dwCurrLength = 0;
    LPWSTR pwszBuffer = NULL;
    LPWSTR pwszSpaces = NULL;
    WCHAR wszCharacter[ 3 ] = L"\0";    // two WCHAR's is enough -- but took 3

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input value
    if ( pwszValue == NULL )
    {
        INVALID_PARAMETER();
        return cwszNullString;
    }

    // determine the buffer length required
    // ( accomadate some extra space than the original buffer/required length -
    //   this will save us from crashes )
    dw = StringLengthInBytes( pwszValue );
    dwBufLen = (( dw > dwLength ) ? dw : dwLength ) + 10;

    // ...
    if ( (pwszBuffer = GetTempBuffer( 0, NULL, dwBufLen, TRUE )) == NULL )
    {
        OUT_OF_MEMORY();
        return cwszNullString;
    }

    // ...
    dwCurrLength = dw;

    // adjust the string value
    if ( dwCurrLength < dwLength )
    {
        //
        // length of the current value is less than the needed

        // get the pointers to the temporary buffers
        if ( (pwszSpaces = GetTempBuffer( 1, NULL, dwBufLen, TRUE )) == NULL )
        {
            OUT_OF_MEMORY();
            return cwszNullString;
        }

        // get the spaces for the rest of the length
        Replicate( pwszSpaces, L" ", dwLength - dwCurrLength, dwBufLen );

        // append the spaces either to the end of the value or begining of the value
        // based on the padding property
        if ( bPadLeft == TRUE )
        {
            // spaces first and then value
            StringCopy( pwszBuffer, pwszSpaces, dwBufLen );
            StringConcat( pwszBuffer, pwszValue, dwBufLen );
        }
        else
        {
            // value first and then spaces
            StringCopy( pwszBuffer, pwszValue, dwBufLen );
            StringConcat( pwszBuffer, pwszSpaces, dwBufLen );
        }
    }
    else
    {
        // copy only the characters of required length
        // copy character by character
        dwCurrLength = 0;
        for( dw = 0; dwCurrLength < dwLength; dw++ )
        {
            // get the character -- 1 + 1 ( character + NULL character )
            StringCopy( wszCharacter, pwszValue + dw, 2 );

            // determine whether character can be appended or not
            dwTemp = dwCurrLength + StringLengthInBytes( wszCharacter );
            if ( dwTemp <= dwLength )
            {
                StringConcat( pwszBuffer, wszCharacter, dwBufLen );
            }
            else if ( dwTemp > dwLength )
            {
                break;
            }

            // get the current string length
            dwCurrLength = dwTemp;
        }

        // target buffer might not got filled completely
        // so, add needed no. of spaces
        for( ; dwCurrLength < dwLength; dwCurrLength++ )
        {
            StringConcat( pwszBuffer, L" ", dwBufLen );
        }
    }

    // copy the contents back to the original buffer
    // NOTE: Buffer length assumed to be passed +1 to the length asked to adjust
    StringCopy( pwszValue, pwszBuffer, dwLength + 1 );

    // return the same buffer back to the caller
    return pwszValue;
}


LPCWSTR
Replicate( IN LPWSTR pwszBuffer,
           IN LPCWSTR pwszText,
           IN DWORD dwCount,
           IN DWORD dwLength )
/*++
 Routine Description:
      Adjusts the string length by padding spaces for displaying output in
      LIST, TABLE or CSV formats

Arguments:
           [IN]      pwszBuffer   : Address of the string to be replicated.
           [IN]      pwszText    : String used for replicate
           [IN]      dwCount     : Number of characters
           [IN]      dwLength    : Length of a string

 Return Value:
       NULL   :   On failure
       LPWSTR    :   On success
--*/
{
    // local variables
    DWORD dw = 0;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // validate the input buffers
    if ( pwszBuffer == NULL || pwszText == NULL )
    {
        INVALID_PARAMETER();
        return cwszNullString;
    }

    // form the string of required length
    StringCopy( pwszBuffer, cwszNullString, dwLength );
    for( dw = 0; dw < dwCount; dw++ )
    {
        // append the replication character
        if ( StringConcat( pwszBuffer, pwszText, dwLength ) == FALSE )
        {
            // not an error condition -- but might destination buffer
            // might have got filled
            break;
        }
    }

    // return the replicated buffer
    return pwszBuffer;
}

BOOL
IsConsoleFile( IN FILE* fp )
/*++
 Routine Description:
        checks whether the file handle passed is console file or not

Arguments:
           [IN]      fp   : File pointer

 Return Value:
       NULL   :   On failure
       LPWSTR    :   On success
--*/
{
    // local variables
    INT filenum = 0;
    LONG_PTR lHandle = 0;
    HANDLE hFile = NULL;
    DWORD dwType = 0;
    DWORD dwMode = 0;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input file pointer
    if ( fp == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // get internal file index
    filenum = (_fileno)( fp );      // forcing for the function version

    // now get the file handle from file index and then get the type of the file
    lHandle = _get_osfhandle( filenum );
    if ( lHandle == -1 || errno == EBADF )
    {
        // set the last error
        SetLastError( ERROR_INVALID_HANDLE );

        // return
        return FALSE;
    }

    // now get the type of the file handle
    dwType = GetFileType( ( HANDLE ) lHandle );

    // check the type of the file -- if it is not ANSI, we wont treat it as a console file
    if ( dwType != FILE_TYPE_CHAR )
    {
        // return -- this is not an error condition --
        // so we are not setting error
        return FALSE;
    }

    // now based on the file index, get the appropriate handle
    switch( filenum )
    {
    case 0:
        {
            // stdin
            hFile = GetStdHandle( STD_INPUT_HANDLE );
            break;
        }

    case 1:
        {
            // stdout
            hFile = GetStdHandle( STD_OUTPUT_HANDLE );
            break;
        }


    case 2:
        {
            // stderr
            hFile = GetStdHandle( STD_ERROR_HANDLE );
            break;
        }

    default:
        {
            hFile = NULL;
            break;
        }
    }

    // check the file handle
    if ( hFile == NULL )
    {
        // file internal index couldn't be found
        // this is also not an error check -- so no error
        return FALSE;
    }
    else if ( hFile == INVALID_HANDLE_VALUE )
    {
        // this is a failure case
        // GetStdHandle would have set the appropriate error
        return FALSE;
    }

    // get the console file mode
    if ( GetConsoleMode( hFile, &dwMode ) == FALSE )
    {
        // error occured in getting the console mode --
        // this means, it is not a valid console file
        // GetConsoleMode would have set the error code
        return FALSE;
    }

    // yes -- the file handle passed to this function is console file
    return TRUE;
}


LCID
GetSupportedUserLocale( IN OUT BOOL* pbLocaleChanged )
/*++
 Routine Description:
        check whether the current locale is supported by our tool or not

Arguments:
           [IN]      pbLocaleChanged   : Flag

 Return Value:
       0   :   On failure
       LCID    :   On success
--*/
{
    // local variables
    LCID lcid;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // get the current locale
    lcid = GetUserDefaultLCID();

    // check whether the current locale is supported by our tool or not
    // if not change the locale to the english which is our default locale
    if ( pbLocaleChanged != NULL )
    {
        *pbLocaleChanged = FALSE;
    }

    // ...
    if ( PRIMARYLANGID( lcid ) == LANG_ARABIC || PRIMARYLANGID( lcid ) == LANG_HEBREW ||
         PRIMARYLANGID( lcid ) == LANG_THAI   || PRIMARYLANGID( lcid ) == LANG_HINDI  ||
         PRIMARYLANGID( lcid ) == LANG_TAMIL  || PRIMARYLANGID( lcid ) == LANG_FARSI )
    {
        if ( pbLocaleChanged != NULL )
        {
            *pbLocaleChanged = TRUE;

        }

        // ...
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_DEFAULT ), SORT_DEFAULT ); // 0x409;
    }

    // return the locale
    return lcid;
}


BOOL
StringCopyA( IN OUT LPSTR pszDest,
             IN     LPCSTR pszSource,
             IN     LONG lSize )
/*++
 Routine Description:

 Copies static ANSI string to a buffer

 Arguments:
         [ in/out ] pszDest  => Destination buffer
         [ in ] pszSource  => Source buffer
         [ in ] lSize  => length of destination buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    HRESULT hr = S_OK;

    //
    // for historical reasons we neither clear the error
    // not set the error in this function
    //

    // validate the arguments
    if ( pszDest == NULL || pszSource == NULL || lSize <= 0 )
    {
        return FALSE;
    }

    // do the copy
    hr = StringCchCopyA( pszDest, lSize, pszSource );

    // check for hr value
    if ( FAILED( hr ) )
    {
        //set the error code
        SetLastError( HRESULT_CODE( hr ) );
        return FALSE;
    }

    // return success
    return TRUE;
}


BOOL
StringCopyW( IN OUT LPWSTR pwszDest,
             IN     LPCWSTR pwszSource,
             IN     LONG lSize )
/*++
 Routine Description:

Copies static UNICODE string to a buffer

 Arguments:
         [ in/out ] pwszDest  => Destination buffer
         [ in ] pszSource  => Source buffer
         [ in ] lSize  => length of destination buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    HRESULT hr = S_OK;

    //
    // for historical reasons we neither clear the error
    // not set the error in this function
    //

    // validate the arguments
    if ( pwszDest == NULL || pwszSource == NULL || lSize <= 0 )
    {
        return FALSE;
    }

    // do the copy
    hr = StringCchCopyW( pwszDest, lSize, pwszSource );

    // check for hr value
    if ( FAILED( hr ) )
    {
        //set the error code
        SetLastError( HRESULT_CODE( hr ) );
        return FALSE;
    }

    // return
    return TRUE;
}

BOOL
StringConcatA( IN OUT LPSTR pszDest,
               IN     LPCSTR pszSource,
               IN     LONG lSize )
/*++
 Routine Description:

Appends one static ANSI string to another

 Arguments:
         [ in/out ] pwszDest  => Destination buffer
         [ in ] pszSource  => Source buffer
         [ in ] lSize  => length of destination buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variable
    HRESULT hr = S_OK;

    //
    // for historical reasons we neither clear the error
    // not set the error in this function
    //

    // validate the arguments
    if ( pszDest == NULL || pszSource == NULL || lSize <= 0 )
    {
        return FALSE;
    }

    // get the current length of the current contents in the destination
    hr = StringCchCatA( pszDest, lSize, pszSource );

    // check for hr value
    if ( FAILED( hr ) )
    {
        //set the error code
        SetLastError( HRESULT_CODE( hr ) );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
StringConcatW( IN OUT LPWSTR pwszDest,
               IN     LPCWSTR pwszSource,
               IN     LONG lSize )
/*++
 Routine Description:

Appends one UNICODE string to another

 Arguments:
         [ in/out ] pwszDest  => Destination buffer
         [ in ] pszSource  => Source buffer
         [ in ] lSize  => length of destination buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variable
    HRESULT hr = S_OK;

    //
    // for historical reasons we neither clear the error
    // not set the error in this function
    //

    // validate the arguments
    if ( pwszDest == NULL || pwszSource == NULL || lSize <= 0 )
    {
        return FALSE;
    }

    // do the concatenation
    hr = StringCchCatW( pwszDest, lSize, pwszSource );

    // check for hr value
    if ( FAILED( hr ) )
    {
        //set the error code
        SetLastError( HRESULT_CODE( hr ) );
        return FALSE;
    }

    // return
    return TRUE;
}


BOOL
StringCopyExA( IN OUT LPSTR pszDest,
               IN LPCSTR pszSource )
/*++
 Routine Description:

Copies dynamic ANSI string to a buffer

 Arguments:
         [ in/out ] pszDest  => Destination buffer
         [ in ] pszSource  => Source buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    LONG lSize = 0;

    //
    // for historical reasons we neither clear the error
    // not set the error in this function
    //

    // validate the inputs
    if ( pszDest == NULL || pszSource == NULL )
    {
        // invalid arguments passed to the function
        return FALSE;
    }

    // get the size of the destination buffer
    lSize = GetBufferSize( pszDest );
    if ( lSize < 0 )
    {
        // the source buffer is not allocated on heap
        return FALSE;
    }
    else
    {
        // convert the size into TCHARs
        lSize /= sizeof( CHAR );
    }

    // do the copy and return
    return StringCopyA( pszDest, pszSource, lSize );
}


BOOL StringCopyExW( IN OUT LPWSTR pwszDest,
                    IN     LPCWSTR pwszSource )
/*++
 Routine Description:

Copies dynamic ANSI string to another

 Arguments:
         [ in/out ] pwszDest  => Destination buffer
         [ in ] pwszSource  => Source buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    LONG lSize = 0;

    //
    // for historical reasons we neither clear the error
    // not set the error in this function
    //

    // validate the inputs
    if ( pwszDest == NULL || pwszSource == NULL )
    {
        // invalid arguments passed to the function
        return FALSE;
    }

    // get the size of the destination buffer
    lSize = GetBufferSize( pwszDest );
    if ( lSize < 0 )
    {
        // the source buffer is not allocated on heap
        return FALSE;
    }
    else
    {
        // convert the size into TCHARs
        lSize /= sizeof( WCHAR );
    }

    // do the copy and return
    return StringCopyW( pwszDest, pwszSource, lSize );
}


BOOL
StringConcatExA( IN OUT LPSTR pszDest,
                 IN     LPCSTR pszSource )
/*++
 Routine Description:

Appends dynamic ANSI string to a buffer

 Arguments:
         [ in/out ] pszDest  => Destination buffer
         [ in ] pszSource  => Source buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    LONG lSize = 0;

    //
    // for historical reasons we neither clear the error
    // not set the error in this function
    //

    // validate the inputs
    if ( pszDest == NULL || pszSource == NULL )
    {
        // invalid arguments passed to the function
        return FALSE;
    }

    // get the size of the destination buffer
    lSize = GetBufferSize( pszDest );
    if ( lSize < 0 )
    {
        // the source buffer is not allocated on heap
        return FALSE;
    }
    else
    {
        // convert the size into CHARs
        lSize /= sizeof( CHAR );
    }

    // do the concatenation and return
    return StringConcatA( pszDest, pszSource, lSize );
}

BOOL
StringConcatExW( IN OUT LPWSTR pwszDest,
                 IN     LPCWSTR pwszSource )
/*++
 Routine Description:

Appends one dynamic ANSI string to another

 Arguments:
         [ in/out ] pwszDest  => Destination buffer
         [ in ] pwszSource  => Source buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    LONG lSize = 0;

    //
    // for historical reasons we neither clear the error
    // not set the error in this function
    //

    // validate the inputs
    if ( pwszDest == NULL || pwszSource == NULL )
    {
        // invalid arguments passed to the function
        return FALSE;
    }

    // get the size of the destination buffer
    lSize = GetBufferSize( pwszDest );
    if ( lSize < 0 )
    {
        // the source buffer is not allocated on heap
        return FALSE;
    }
    else
    {
        // convert the size into WCHARs
        lSize /= sizeof( WCHAR );
    }

    // do the concatenation and return
    return StringConcatW( pwszDest, pwszSource, lSize );
}


DWORD
StringLengthA( IN LPCSTR pszSource,
               IN DWORD dwReserved )
/*++
 Routine Description:
   Finds the number of bytes in a ANSI string

 Arguments:
         [ in ] pszSource  => String

 Return Value:
       int
--*/
{
    UNREFERENCED_PARAMETER( dwReserved );

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // validate the input
    if ( NULL == pszSource )
    {
        // empty string..return 0..
        return 0;
    }

    // return the length of string
    return ( lstrlenA( pszSource ) );
}


DWORD
StringLengthW( IN LPCWSTR pwszSource,
               IN DWORD dwReserved )
/*++
 Routine Description:

 Finds the number of characters in a UNICODE string

 Arguments:
         [ in ] pszSource  => String

 Return Value:
       int
--*/
{
    UNREFERENCED_PARAMETER( dwReserved );

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // validate the input
    if ( NULL == pwszSource )
    {
        // empty string..return 0..
        return 0;
    }

    // return the length of string
    return ( lstrlenW( pwszSource ) );
}


LONG
StringCompareW( IN LPCWSTR pwszString1,
                IN LPCWSTR pwszString2,
                IN BOOL bIgnoreCase,
                IN DWORD dwCount )
/*++
 Routine Description:

    Compares two character strings, using the specified locale.

 Arguments:
    [in] pwszString1  => first string
    [in] pwszString2  => second string
    [in] bIgnoreCase  => Flag to indicate case sensitive/in-sensitive
    [in] dwCount  => number of characters to be compared

 Return Value:
    FALSE  :   On failure
    TRUE   :   On success
--*/
{
    // local variables
    LONG lResult = 0;
    LONG lLength = 0;
    DWORD dwFlags = 0;

    // check the input value
    if ( pwszString1 == NULL || pwszString2 == NULL )
    {
        INVALID_PARAMETER();
        return 0;
    }

    // determine the flags
    dwFlags = (bIgnoreCase == TRUE) ? NORM_IGNORECASE : 0;

    // determine the length
    lLength = (dwCount == 0) ? -1 : dwCount;

    lResult = CompareStringW( GetThreadLocale(),
        dwFlags, pwszString1, lLength, pwszString2, lLength );

    // now return comparision result
    // to this function in consistent with C-runtime, we need to subtract 2
    // lResult return from CompareString
    return lResult - 2;
}


LONG
StringCompareA( IN LPCSTR pszString1,
                IN LPCSTR pszString2,
                IN BOOL bIgnoreCase,
                IN DWORD dwCount )
/*++
 Routine Description:

Compares two character strings, using the specified locale.

 Arguments:
         [in] pwszString1  => first string
         [in] pwszString2  => second string
         [in] bIgnoreCase  => Flag to indicate case sensitive/in-sensitive
         [in] dwCount  => number of characters to be compared

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    LONG lResult = 0;
    LONG lLength = 0;
    DWORD dwFlags = 0;

    // check the input value
    if ( pszString1 == NULL || pszString2 == NULL )
    {
        INVALID_PARAMETER();
        return 0;
    }

    // determine the flags
    dwFlags = (bIgnoreCase == TRUE) ? NORM_IGNORECASE : 0;

    // determine the length
    lLength = (dwCount == 0) ? -1 : dwCount;

    lResult = CompareStringA( GetThreadLocale(),
        dwFlags, pszString1, lLength, pszString2, lLength );

    // now return comparision result
    // to this function in consistent with C-runtime, we need to subtract 2
    // lResult return from CompareString
    return lResult - 2;
}


LONG
StringCompareExW( IN LPCWSTR pwszString1,
                  IN LPCWSTR pwszString2,
                  IN BOOL bIgnoreCase,
                  IN DWORD dwCount )
/*++
 Routine Description:

Compares two character strings, using the specified locale.

 Arguments:
         [in] pwszString1  => first string
         [in] pwszString2  => second string
         [in] bIgnoreCase  => Flag to indicate case sensitive/in-sensitive
         [in] dwCount  => number of characters to be compared

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    LONG lResult = 0;
    LONG lLength = 0;
    DWORD dwFlags = 0;
    DWORD lcid = 0;

    // check the input value
    if ( pwszString1 == NULL || pwszString2 == NULL )
    {
        INVALID_PARAMETER();
        return 0;
    }

    // determine the flags
    dwFlags = (bIgnoreCase == TRUE) ? NORM_IGNORECASE : 0;

    // determine the length
    lLength = (dwCount == 0) ? -1 : dwCount;

    // prepare the LCID
    // if this tool is designed to work on XP and earlier, then
    // we can use LOCALE_INVARIANT -- otherwise, we need to prepare the lcid
    lcid = LOCALE_INVARIANT;
    if ( g_dwMajorVersion == 5 && g_dwMinorVersion == 0 )
    {
        // tool desgined to work on pre-windows xp
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT );
    }

    lResult = CompareStringW( lcid,
        dwFlags, pwszString1, lLength, pwszString2, lLength );

    // now return comparision result
    // to this function in consistent with C-runtime, we need to subtract 2
    // lResult return from CompareString
    return lResult - 2;
}


LONG
StringCompareExA( IN LPCSTR pszString1,
                  IN LPCSTR pszString2,
                  IN BOOL bIgnoreCase,
                  IN DWORD dwCount )
/*++
 Routine Description:

Compares two character strings, using the specified locale.

 Arguments:
         [in] pszString1  => first string
         [in] pszString2  => second string
         [in] bIgnoreCase  => Flag to indicate case sensitive/in-sensitive
         [in] dwCount  => number of characters to be compared

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    LONG lResult = 0;
    LONG lLength = 0;
    DWORD dwFlags = 0;
    DWORD lcid = 0;

    // check the input value
    if ( pszString1 == NULL || pszString2 == NULL )
    {
        INVALID_PARAMETER();
        return 0;
    }

    // determine the flags
    dwFlags = (bIgnoreCase == TRUE) ? NORM_IGNORECASE : 0;

    // determine the length
    lLength = (dwCount == 0) ? -1 : dwCount;

    // prepare the LCID
    // if this tool is designed to work on XP and earlier, then
    // we can use LOCALE_INVARIANT -- otherwise, we need to prepare the lcid
    lcid = LOCALE_INVARIANT;
    if ( g_dwMajorVersion == 5 && g_dwMinorVersion == 0 )
    {
        // tool desgined to work on pre-windows xp
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT );
    }

    lResult = CompareStringA( lcid,
        dwFlags, pszString1, lLength, pszString2, lLength );

    // now return comparision result
    // to this function in consistent with C-runtime, we need to subtract 2
    // lResult return from CompareString
    return lResult - 2;
}


BOOL
ShowResMessage( IN FILE* fp,
                IN UINT uID )
/*++
 Routine Description:

 Displays the message based on resource ID

 Arguments:
         [in] fp  => file pointer
         [in] uID  => resource ID

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // show the string from the resource table and return
    return ShowMessage( fp, GetResString( uID ) );
}

BOOL
ShowMessage( FILE* fp,
             LPCWSTR pwszMessage )
/*++
 Routine Description:

 Displays the message with the given file pointer

 Arguments:
         [in] fp  => file pointer
         [in] pwszMessage  => Message

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwTemp = 0;
    DWORD dwLength = 0;
    DWORD dwBufferSize = 0;
    DWORD dwSourceBuffer = 0;
    BOOL bResult = FALSE;
    HANDLE hOutput = NULL;
    LPCWSTR pwszTemp = NULL;
    static char szBuffer[ 256 ] = "\0";

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input value
    if ( fp == NULL || pwszMessage == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // determine whether the handle passed is a console file or not
    if ( IsConsoleFile( fp ) == TRUE )
    {
        // determine the file handle
        if ( fp == stdout )
        {
            // handle to stdout
            hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
        }
        else if ( fp == stderr )
        {
            // handle to stderr
            hOutput = GetStdHandle( STD_ERROR_HANDLE );
        }
        else
        {
            // there is no way that fp will not match with
            // stderr and stdout -- but still
            UNEXPECTED_ERROR();
            return FALSE;
        }

        // get the length info.
        dwTemp = 0;
        dwLength = StringLength( pwszMessage, 0 );

        // display the output
        bResult = WriteConsole( hOutput, pwszMessage, dwLength, &dwTemp, NULL );
        if ( bResult == FALSE || dwLength != dwTemp )
        {
            // buffer might not be sufficient -- check it
            if ( GetLastError() == ERROR_NOT_ENOUGH_MEMORY )
            {
                // this is the only error that could occur
                // NOTE: we will display the buffer in chunks of 1024 characters
                dwLength = StringLength( pwszMessage, 0 );
                for( dw = 0; dw < dwLength; dw += 1024 )
                {
                    // write 256 characters at time
                    dwBufferSize = ((dwLength - dw) > 1024 ? 1024 : (dwLength - dw));
                    bResult = WriteConsole( hOutput,
                        pwszMessage + dw, dwBufferSize, &dwTemp, NULL );
                    if ( bResult == FALSE || dwBufferSize != dwTemp )
                    {
                        // can't help -- still the same error -- unexpected behaviour
                        ShowLastError( stderr );
                        ReleaseGlobals();
                        ExitProcess( 1 );
                    }
                }
            }
            else
            {
                // unexpected error occured -- no idea
                ShowLastError( stderr );
                ReleaseGlobals();
                ExitProcess( 1 );
            }
        }
    }
    else
    {
        // determine the length(s)
        // NOTE: we need to the surround all '%' characters with extra '%'
        //       character to show it as it is
        pwszTemp = QuoteMeta( pwszMessage, 1 );
        dwLength = StringLength( pwszTemp, 0 );
        dwBufferSize = SIZE_OF_ARRAY( szBuffer );

        // zero the szBuffer
        ZeroMemory( szBuffer, dwBufferSize * sizeof( CHAR ) );

        // show the text in shunks of buffer size
        dw = 0;
        dwBufferSize--;         // from this point lets assume that the ANSI
                                // buffer is 1 less than its actual size
        while ( dwLength > dw )
        {
            dwTemp = 0;
            dwSourceBuffer = ((dwBufferSize < (dwLength - dw)) ? dwBufferSize : (dwLength - dw));
            while ( dwTemp == 0 )
            {
                // determine the ANSI buffer space required sufficient to
                // transform the current UNICODE string length
                dwTemp = WideCharToMultiByte( GetConsoleOutputCP(), 
                    0, pwszTemp + dw, dwSourceBuffer, NULL, 0, NULL, NULL );

                // if the ANSI buffer space is not sufficient 
                if ( dwTemp == 0 )
                {
                    ShowLastError( stdout );
                    ReleaseGlobals();
                    ExitProcess( 1 );
                }
                else if ( dwTemp > dwBufferSize )
                {
                    if ( (dwTemp - dwBufferSize) > 3 )
                    {
                        dwSourceBuffer -= (dwTemp - dwBufferSize) / 2;
                    }
                    else
                    {
                        dwSourceBuffer--;
                    }

                    // reset the temp variable inorder to continue the loop
                    dwTemp = 0;

                    // check the source buffer contents
                    if ( dwSourceBuffer == 0 )
                    {
                        UNEXPECTED_ERROR();
                        ShowLastError( stdout );
                        ReleaseGlobals();
                        ExitProcess( 1 );
                    }
                } 
                else if ( dwTemp < dwSourceBuffer )
                {
                    dwSourceBuffer = dwTemp;
                }
            }

            // get the string in 'multibyte' format
            ZeroMemory( szBuffer, SIZE_OF_ARRAY( szBuffer ) * sizeof( CHAR ) );
            dwTemp = WideCharToMultiByte( GetConsoleOutputCP(), 0,
                pwszTemp + dw, dwSourceBuffer, szBuffer, dwBufferSize, NULL, NULL );

            // check the result
            if ( dwTemp == 0 )
            {
                ShowLastError( stdout );
                ReleaseGlobals();
                ExitProcess( 1 );
            }

            // determine the remaining buffer length
            dw += dwSourceBuffer;

            // display string onto the specified file
            fprintf( fp, szBuffer );
            fflush( fp );
            // bResult = WriteFile( fp, szBuffer, StringLengthA( szBuffer, 0 ), &dwTemp, NULL );
            // if ( bResult == FALSE ||
            //      StringLengthA( szBuffer, 0 ) != (LONG) dwTemp ||
            //      FlushFileBuffers( fp ) == FALSE )
            // {
            //     UNEXPECTED_ERROR();
            //     ReleaseGlobals();
            //     ExitProcess( 1 );
            // }
        }
    }

    return TRUE;
}


BOOL
ShowMessageEx(
    FILE* fp,
    DWORD dwCount,
    BOOL bStyle,
    LPCWSTR pwszFormat,
    ...)
/*++

Routine Description:

    Replaces a string containing " %1, %2 ... " or "%s, %d, %f ..." with
    appropriate values depending upon the way arguments are given as input.

Arguments:

    [ IN ] FILE* fp           - Contains file on to which message is to be copied.
    [ IN ] DWORD dwCount      - Contains number of arguments for 'va_list'
                                following 'lpszFormat'.
    [ IN ] BOOL bStyle        - If TRUE then formatting is done using "_vstprint",
                                if FALSE then formatting is done using "FormatMessage".
    [ IN ] LPCTSTR lpszFormat - String which needs to formatted.

Return value:

      TRUE  - If successful in displaying message.
      FALSE - If failed to display message or memory is insufficient.

---*/

{
    // local variables
    va_list vargs;                  // Contains start variable of variable arguments.
    BOOL bResult = FALSE;           // Contains return value.
    LPWSTR pwszBuffer = NULL;      // Contains mem location of variable arguments.
    DWORD dwBufferLength = 0;
    LONG lCount = -1;
    HRESULT hr = S_OK;

    // Check for any NULL argument passed as input.
    if( NULL == pwszFormat || NULL == fp )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // check how many variable arguments did caller passed
    // if it is zero, just call the ShowMessage -- no need to proceed furthur
    if ( dwCount == 0 )
    {
        return ShowMessage( fp, pwszFormat );
    }

    // Formatting is done using 'Format message' or '_vstprintf'?
    if ( FALSE == bStyle )
    {
        // init
        lCount = -1;
        dwBufferLength = 0;

        // try the FormatMessage
        do
        {
            // get the variable args start position
            va_start( vargs, pwszFormat );
            if ( vargs == NULL )
            {
                UNEXPECTED_ERROR();
                return FALSE;
            }

            // we will start with buffer length of 4K buffer and then increment
            // the buffer by 2K each time we run thru this loop
            dwBufferLength += (lCount == -1) ? 4096 : 2048;
            if ( (pwszBuffer = GetTempBuffer( INDEX_TEMP_SHOWMESSAGE,
                                              NULL, dwBufferLength, TRUE )) == NULL )
            {
                OUT_OF_MEMORY();
                return FALSE;
            }

            // try the FormatMessage
            lCount = FormatMessageW( FORMAT_MESSAGE_FROM_STRING,
                pwszFormat, 0, 0, pwszBuffer, dwBufferLength - 1, &vargs );

            // check the result
            if ( lCount == 0 )
            {
                if ( GetLastError() == NO_ERROR )
                {
                    // there is nothing to show
                    return TRUE;
                }
                else if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
                {
                    return FALSE;
                }
            }

            // reset the va_list parameter
            va_end( vargs );
        } while ( lCount == 0 );
    }

    // Formatting is done using '_vsnwprintf'.
    else
    {
        // init
        dwBufferLength = 0;

        // try the printf
        do
        {
            // get the variable args start position
            va_start( vargs, pwszFormat );
            if ( vargs == NULL )
            {
                UNEXPECTED_ERROR();
                return FALSE;
            }

            // we will start with buffer length of 4K buffer and then increment
            // the buffer by 2K each time we run thru this loop
            dwBufferLength += (lCount == 0) ? 4096 : 2048;
            if ( (pwszBuffer = GetTempBuffer( INDEX_TEMP_SHOWMESSAGE,
                                              NULL, dwBufferLength, TRUE )) == NULL )
            {
                OUT_OF_MEMORY();
                return FALSE;
            }

            // try the printf
            hr = StringCchVPrintfW( pwszBuffer, dwBufferLength, pwszFormat, vargs );

            // reset the va_list parameter
            va_end( vargs );
        } while ( hr == STRSAFE_E_INSUFFICIENT_BUFFER );

        // check whether we came out of the loop 'coz of the some other error
        if ( FAILED( hr ) )
        {
            SetLastError( HRESULT_CODE( hr ) );
            return FALSE;
        }
    }

    // a safety check
    if ( pwszBuffer == NULL )
    {
        UNEXPECTED_ERROR();
        return FALSE;
    }

    // show the output
    bResult = ShowMessage( fp, pwszBuffer );

    // return
    return bResult;
}

// ***************************************************************************
// Routine Description:
//
// ///////////////////////////////////////////////////////////////////////////
// NOTE:
// ----
// functions which i dont want to support any more -- they are just lying for
// compatiblity sake -- if at all you are facing any problem with these
// functions you better upgrade to version 2.0 -- but absoultely there is no
// support for this function
//
// ///////////////////////////////////////////////////////////////////////////
//
// Arguments:
//
// Return Value:
//
// ***************************************************************************
LPSTR
GetAsMultiByteString( IN     LPCWSTR pwszSource,
                      IN OUT LPSTR pszDestination,
                      IN     DWORD dwLength )
/*++
 Routine Description:
    convert string from UNICODE version to ANSI version

Arguments:
           [IN]          pszSource   : UNICODE version of string
           [IN/OUT]      pwszDestination    : ANSI version of string
           [IN/OUT]      dwLength    : Length of a string

 Return Value:
       NULL_STRING   :   On failure
       LPWSTR    :   On success
--*/
{
    if ( GetAsMultiByteString2( pwszSource,
                                pszDestination,
                                &dwLength ) == FALSE )
    {
        return "";
    }

    // return the destination buffer
    return pszDestination;
}

// ***************************************************************************
//
// ///////////////////////////////////////////////////////////////////////////
// NOTE:
// ----
// functions which i dont want to support any more -- they are just lying for
// compatiblity sake -- if at all you are facing any problem with these
// functions you better upgrade to version 2.0 -- but absoultely there is no
// support for this function
//
// ///////////////////////////////////////////////////////////////////////////
//
// ***************************************************************************

LPWSTR
GetAsUnicodeStringEx( IN     LPCSTR pszSource,
                      IN OUT LPWSTR pwszDestination,
                      IN     DWORD dwLength )
/*++
 Routine Description:
    convert string from ANSI version to UNICODE version

Arguments:
           [IN]          pszSource   : Source string
           [IN/OUT]      pwszDestination    : Unicode version of String
           [IN/OUT]      dwLength    : Length of a string

 Return Value:
       NULL_STRING   :   On failure
       LPWSTR    :   On success
--*/
{
    if ( GetAsUnicodeString2( pszSource,
                              pwszDestination,
                              &dwLength ) == FALSE )
    {
        return L"";
    }

    // return the destination buffer
    return pwszDestination;
}

BOOL
GetAsUnicodeString2( IN     LPCSTR pszSource,
                     IN OUT LPWSTR pwszDestination,
                     IN OUT DWORD* pdwLength )
/*++
 Routine Description:
    convert string from ANSI version to UNICODE version

Arguments:
           [IN]          pszSource   : Source string
           [IN/OUT]      pwszDestination    : Unicode version of String
           [IN/OUT]      dwLength    : Length of a string

 Return Value:
       FALSE   :   On failure
       TRUE    :   On success
--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwLength = 0;
    LONG lSourceLength = 0;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input values
    if ( pszSource == NULL || pdwLength == NULL ||
         ( pwszDestination == NULL && *pdwLength != 0 ) )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // ...
    if ( *pdwLength != 0 )
    {
        if ( *pdwLength > 1 )
        {
            dwLength = (*pdwLength) - 1;
        }
        else
        {
            ZeroMemory( pwszDestination, *pdwLength * sizeof( wchar_t ) );
            return TRUE;
        }
    }

    // initialize the values with zeros
    // NOTE:- MultiByteToWideChar wont null terminate its result so
    //        if its not initialized to nulls, you'll get junk after
    //        the converted string and will result in crashes
    if ( pwszDestination != NULL && dwLength != 0 )
    {
        ZeroMemory( pwszDestination, (dwLength + 1) * sizeof( wchar_t ) );
    }

    // determine the source length to pass to the function call
    lSourceLength = -1;
    if ( dwLength != 0 )
    {
        lSourceLength = StringLengthA( pszSource, 0 );
        if ( lSourceLength > (LONG) dwLength )
        {
            lSourceLength = dwLength;
        }
    }

    // convert string from ANSI version to UNICODE version
    dw = MultiByteToWideChar( _DEFAULT_CODEPAGE, 0,
        pszSource, lSourceLength, pwszDestination, dwLength );
    if ( dw == 0 )
    {
        UNEXPECTED_ERROR();

        // to keep the destination buffer clean and safe
        if ( pwszDestination != NULL && dwLength != 0 )
        {
            ZeroMemory( pwszDestination, (dwLength + 1) * sizeof( wchar_t ) );
        }

        // failure
        return FALSE;
    }
    else
    {
        *pdwLength = dw;
    }

    // success
    return TRUE;
}


BOOL
GetAsMultiByteString2( IN     LPCWSTR pwszSource,
                       IN OUT LPSTR pszDestination,
                       IN OUT DWORD* pdwLength )
/*++
 Routine Description:

      Complex scripts cannot be rendered in the console, so we
      force the English (US) resource.

 Arguments:
           [IN]      pwszSource      : Source string
           [IN|OUT]  pszDestination  : Multibyte string
           [IN]      pdwLength       : length of the text string

 Return Value:
      TRUE      : on Success
      FALSE     : On Failure
--*/

{
    // local variables
    DWORD dw = 0;
    DWORD dwLength = 0;
    LONG lSourceLength = 0;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input values
    if ( pwszSource == NULL || pdwLength == NULL ||
         ( pszDestination == NULL && *pdwLength != 0 ) )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // ...
    if ( *pdwLength != 0 )
    {
        if ( *pdwLength > 1 )
        {
            dwLength = (*pdwLength) - 1;
        }
        else
        {
            ZeroMemory( pszDestination, *pdwLength * sizeof( char ) );
            return TRUE;
        }
    }

    // initialize the values with zeros
    // NOTE:- WideCharToMultiByte wont null terminate its result so
    //        if its not initialized to nulls, you'll get junk after
    //        the converted string and will result in crashes
    if ( pszDestination != NULL && dwLength != 0 )
    {
        ZeroMemory( pszDestination, (dwLength + 1) * sizeof( char ) );
    }

    // determine the source length to pass to the function call
    lSourceLength = -1;
    if ( dwLength != 0 )
    {
        lSourceLength = StringLengthW( pwszSource, 0 );
        if ( lSourceLength > (LONG) dwLength )
        {
            lSourceLength = dwLength;
        }
    }
    // convert string from UNICODE version to ANSI version
    dw = WideCharToMultiByte( _DEFAULT_CODEPAGE, 0, 
        pwszSource, lSourceLength, pszDestination, dwLength, NULL, NULL );
    if ( dw == 0 )
    {
        UNEXPECTED_ERROR();

        // to keep the destination buffer clean and safe
        if ( pszDestination != NULL && dwLength != 0 )
        {
            ZeroMemory( pszDestination, (dwLength + 1) * sizeof( char ) );
        }

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}


BOOL
GetPassword( LPWSTR pwszPassword,
             DWORD dwMaxPasswordSize )
/*++
 Routine Description:

Takes the password from the keyboard. While entering the password it shows
the charecters as '*'

 Arguments:
         [in] pszPassword     --password string to store password
         [in] dwMaxPasswordSize   --Maximun size of the password. MAX_PASSWORD_LENGTH.

 Return Value:
       FALSE   :   On failure
       TRUE    :   On success
--*/
{
    // local variables
    CHAR ch;
    WCHAR wch;
    DWORD dwIndex = 0;
    DWORD dwCharsRead = 0;
    DWORD dwCharsWritten = 0;
    DWORD dwPrevConsoleMode = 0;
    HANDLE hInputConsole = NULL;
    CHAR szBuffer[ 10 ] = "\0";        // actually contains only character at all the times
    WCHAR wszBuffer[ 10 ] = L"\0";     // actually contains only character at all the times
    BOOL bIndirectionInput  = FALSE;

    // check the input value
    if ( pwszPassword == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // get the handle for the standard input
    hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
    if ( hInputConsole == NULL )
    {
        // could not get the handle so return failure
        return FALSE;
    }

    // check for the input redirection on console and telnet session
    if( ( hInputConsole != (HANDLE)0x0000000F ) &&
        ( hInputConsole != (HANDLE)0x00000003 ) &&
        ( hInputConsole != INVALID_HANDLE_VALUE ) )
    {
        bIndirectionInput   = TRUE;
    }

    // redirect the data from StdIn.txt file into the console
    if ( bIndirectionInput  == FALSE )
    {
        // Get the current input mode of the input buffer
        GetConsoleMode( hInputConsole, &dwPrevConsoleMode );

        // Set the mode such that the control keys are processed by the system
        if ( SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) == 0 )
        {
            // could not set the mode, return failure
            return FALSE;
        }
    }

    // init the unicode and ansi buffers to NULL
    ZeroMemory( szBuffer, SIZE_OF_ARRAY( szBuffer ) * sizeof( CHAR ) );
    ZeroMemory( wszBuffer, SIZE_OF_ARRAY( wszBuffer ) * sizeof( WCHAR ) );

    //  Read the characters until a carriage return is hit
    for( ;; )
    {
        if ( bIndirectionInput == TRUE )
        {
            //read the contents of file
            if ( ReadFile( hInputConsole, &ch, 1, &dwCharsRead, NULL ) == FALSE )
            {
                return FALSE;
            }

            // check for end of file
            if ( dwCharsRead == 0 )
            {
                break;
            }
            else
            {
                // convert the ANSI character into UNICODE character
                szBuffer[ 0 ] = ch;
                dwCharsRead = SIZE_OF_ARRAY( wszBuffer );
                GetAsUnicodeString2( szBuffer, wszBuffer, &dwCharsRead );
                wch = wszBuffer[ 0 ];
            }
        }
        else
        {
            if ( ReadConsole( hInputConsole, &wch, 1, &dwCharsRead, NULL ) == 0 )
            {
                // Set the original console settings
                SetConsoleMode( hInputConsole, dwPrevConsoleMode );

                // return failure
                return FALSE;
            }
        }

        // Check for carraige return
        if ( wch == CARRIAGE_RETURN )
        {
            // break from the loop
            break;
        }

        // Check id back space is hit
        if ( wch == BACK_SPACE )
        {
            if ( dwIndex != 0 )
            {
                //
                // Remove a asterix from the console

                // move the cursor one character back
                StringCchPrintfW(
                    wszBuffer,
                    SIZE_OF_ARRAY( wszBuffer ), L"%c", BACK_SPACE );
                WriteConsole(
                    GetStdHandle( STD_OUTPUT_HANDLE ),
                    wszBuffer, 1, &dwCharsWritten, NULL );

                // replace the existing character with space
                StringCchPrintfW(
                    wszBuffer,
                    SIZE_OF_ARRAY( wszBuffer ), L"%c", BLANK_CHAR );
                WriteConsole(
                    GetStdHandle( STD_OUTPUT_HANDLE ),
                    wszBuffer, 1, &dwCharsWritten, NULL );

                // now set the cursor at back position
                StringCchPrintfW(
                    wszBuffer,
                    SIZE_OF_ARRAY( wszBuffer ), L"%c", BACK_SPACE );
                WriteConsole(
                    GetStdHandle( STD_OUTPUT_HANDLE ),
                    wszBuffer, 1, &dwCharsWritten, NULL );

                // decrement the index
                dwIndex--;
            }

            // process the next character
            continue;
        }

        // if the max password length has been reached then sound a beep
        if ( dwIndex == ( dwMaxPasswordSize - 1 ) )
        {
            WriteConsole(
                GetStdHandle( STD_OUTPUT_HANDLE ),
                BEEP_SOUND, 1, &dwCharsWritten, NULL );
        }
        else
        {
            // check for new line character
            if ( wch != L'\n' )
            {
                // store the input character
                *( pwszPassword + dwIndex ) = wch;
                dwIndex++;

                // display asterix onto the console
                WriteConsole(
                    GetStdHandle( STD_OUTPUT_HANDLE ),
                    ASTERIX, 1, &dwCharsWritten, NULL );
            }
        }
    }

    // Add the NULL terminator
    *( pwszPassword + dwIndex ) = cwchNullChar;

    //Set the original console settings
    SetConsoleMode( hInputConsole, dwPrevConsoleMode );

    // display the character ( new line character )
    StringCopy( wszBuffer, L"\n\n", SIZE_OF_ARRAY( wszBuffer ) );
    WriteConsole(
        GetStdHandle( STD_OUTPUT_HANDLE ),
        wszBuffer, 2, &dwCharsWritten, NULL );

    //  Return success
    return TRUE;
}


BOOL
FreeMemory( IN OUT LPVOID* ppv )
/*++
 Routine Description:

    Frees a memory block allocated from a heap

 Arguments:
    [in] ppv  => buffer

 Return Value:
       FALSE   :   On failure
       TRUE    :   On success
--*/
{
    // local variables
    LONG lSize = 0;
    HANDLE hHeap = NULL;
    BOOL bResult = FALSE;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input
    if ( ppv == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }
    else if ( *ppv == NULL )
    {
        // just a NULL pointer -- not an error -- just return
        return TRUE;
    }

    // get the handle to process heap
    hHeap = GetProcessHeap();
    if ( hHeap == NULL )
    {
        // GetProcessHeap will set the error code
        return FALSE;
    }

    // it is a safe technique to clear the contents of the memory being released
    lSize = GetBufferSize( *ppv );
    if ( lSize == -1 )
    {
        // looks like this is not a valid buffer pointer
        SetLastError( (DWORD) E_POINTER );
        return FALSE;
    }

    // ...
    ZeroMemory( *ppv, lSize );

    // release the memory
    bResult = HeapFree( hHeap, 0, *ppv );

    // we need not check the result here
    // ir-respective of whether the function call is successful or not
    // clear the contents of the pointer -- this will help us in eliminating
    // furthur failures
    *ppv = NULL;

    // return
    return bResult;
}


BOOL
CheckMemory( IN OUT LPVOID pv )
/*++
 Routine Description:

Attempts to validate a specified heap.

 Arguments:
         [in/out] ppv  => buffer

 Return Value:
       FALSE   :   On failure
       TRUE    :   On success
--*/
{
    // local variables
    HANDLE hHeap = NULL;
    BOOL bResult = FALSE;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input
    if ( pv == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // get the handle to process heap
    hHeap = GetProcessHeap();
    if ( hHeap == NULL )
    {
        // GetProcessHeap will set the error code
        return FALSE;
    }

    // validate the memory address
    bResult = HeapValidate( hHeap, 0, pv );
    if ( bResult == FALSE )
    {
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    // return
    return bResult;
}


LPVOID
AllocateMemory( IN DWORD dwBytes )
/*++
 Routine Description:

Allocates a block of memory from a heap.


 Arguments:
         [in] dwBytesNew  => number of bytes to reallocate

 Return Value:
       NULL   :   On failure
       pv  :   On success
--*/
{
    // local variables
    LPVOID pv = NULL;
    HANDLE hHeap = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input
    if ( dwBytes <= 0 )
    {
        INVALID_PARAMETER();
        return NULL;
    }

    // get the handle to process heap
    hHeap = GetProcessHeap();
    if ( hHeap == NULL )
    {
        // GetProcessHeap will set the error code
        return NULL;
    }

    //
    // for safe play with heap allocation -- we use structured exception handling
    //

    __try
    {
        // allocate memory
        pv = HeapAlloc( hHeap,
            HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, dwBytes );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        if ( GetExceptionCode() == STATUS_NO_MEMORY )
        {
            OUT_OF_MEMORY();
            return NULL;
        }
        else if ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
        {
            SetLastError( ERROR_FILE_CORRUPT );
            SaveLastError();
            return NULL;
        }
        else
        {
            OUT_OF_MEMORY();
            return NULL;
        }
    }

    // return the allocated the memory pointer
    return pv;
}

BOOL
ReallocateMemory( IN OUT LPVOID* ppv,
                  IN DWORD dwBytesNew )
/*++
 Routine Description:

Reallocates a block of memory from a heap.


 Arguments:
         [in] ppv  => buffer
         [in] dwBytesNew  => number of bytes to reallocate

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    LPVOID pvNew = NULL;
    HANDLE hHeap = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input
    if ( ppv == NULL || *ppv == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }
    else if ( dwBytesNew == 0 )
    {
        // caller wants to free the memory
        return FreeMemory( ppv );
    }
    else if ( CheckMemory( *ppv ) == FALSE )
    {
        // memory handle is invalid
        // set it to NULL -- this is to avoid furthur errors
        *ppv = NULL;
        return FALSE;
    }

    // get the handle to process heap
    hHeap = GetProcessHeap();
    if ( hHeap == NULL )
    {
        // GetProcessHeap will set the error code
        return FALSE;
    }

    //
    // for safe play with heap allocation -- we use structured exception handling
    //

    __try
    {
        // allocate memory
        pvNew = HeapReAlloc( hHeap,
            HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, *ppv, dwBytesNew );
        
        // check for failure case
        if ( pvNew == NULL )
        {
            OUT_OF_MEMORY();
            return FALSE;
        }

        //assign the value ...
        *ppv = pvNew;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // we will not alter the passed memory pointer to this function
        // in case of error -- the pointer will be returned as it is
        //

        if ( GetExceptionCode() == STATUS_NO_MEMORY )
        {
            OUT_OF_MEMORY();
            return FALSE;
        }
        else if ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
        {
            SetLastError( ERROR_FILE_CORRUPT );
            SaveLastError();
            return FALSE;
        }
        else
        {
            OUT_OF_MEMORY();
            return FALSE;
        }
    }

    // return the allocated the memory pointer
    return TRUE;
}

LONG
GetBufferSize( IN OUT LPVOID pv )
/*++
 Routine Description:

Gets the size, in bytes, of a memory block allocated from a heap


 Arguments:
         [in] pv  => buffer

 Return Value:
       FALSE  :   On failure
       TRUE   :   On success
--*/
{
    // local variables
    HANDLE hHeap = NULL;

    //
    // for historical reasons we wont neither clear nor set the error code here
    //

    // check the input
    if ( pv == NULL )
    {
        INVALID_PARAMETER();
        return -1;
    }
    else if ( CheckMemory( pv ) == FALSE )
    {
        return -1;
    }

    // get the handle to process heap
    hHeap = GetProcessHeap();
    if ( hHeap == NULL )
    {
        // GetProcessHeap will set the error code
        return -1;
    }

    // return
    return (DWORD)((DWORD_PTR)(HeapSize( hHeap, 0, pv )));
}

BOOL
MatchPattern(
      IN LPWSTR szPat,
      IN LPWSTR szFile
      )
/*++
        Routine Description     :   This routine is used to check whether file is mathced against
                                    pattern or not.

        [ IN ]  szPat           :   A string variable pattern against which the file name to be matched.

        [ IN ]  szFile          :   A pattern string which specifies the file name to be matched.


        Return Value        :   BOOL
            Returns successfully if function is success other wise return failure.
--*/

{
    switch (*szPat) {
        case '\0':
            return *szFile == L'\0';
        case '?':
            return *szFile != L'\0' && MatchPattern(szPat + 1, szFile + 1);
        case '*':
            do {
                if (MatchPattern(szPat + 1, szFile))
                    return TRUE;
            } while (*szFile++);
            return FALSE;
        default:
            return toupper (*szFile) == toupper (*szPat) && MatchPattern(szPat + 1, szFile + 1);
    }
}


LPCWSTR 
ParsePattern( LPCWSTR pwszPattern )
{
    // local variables
    DWORD dw = 0;
    DWORD dwLength = 0;
    DWORD dwNewIndex = 0;
    LPWSTR pwszNewPattern = NULL;

    // check the pattern
    if( pwszPattern == NULL || 
        (dwLength = StringLength( pwszPattern, 0 )) == 0 )
    {
        INVALID_PARAMETER();
        return NULL;
    }

    // allocate the buffer for the pattern
    pwszNewPattern = GetTempBuffer( INDEX_TEMP_PATTERN, NULL, dwLength + 10, TRUE );
    if ( pwszNewPattern == NULL )
    {
        OUT_OF_MEMORY();
        return NULL;
    }

    //
    // detect the un-necessary wild-card repetitions
    // *, **, *****, *?*, *?*? etc -- all this combinations 
    // will result in just '*'
    dwNewIndex = 0;
    pwszNewPattern[ 0 ] = pwszPattern[ 0 ];
    for( dw = 1; dw < dwLength; dw++ )
    {
        switch( pwszPattern[ dw ] )
        {
            case L'*':
            case L'?':
                {
                    if ( pwszNewPattern[ dwNewIndex ] == L'*' )
                    {
                        // since the pattern already contains the
                        // '*' and having another '*' after the existing
                        // '*' or having '?' after the '*' is of no use
                        // we will skip this character
                        break;
                    }
                }

            default:
                dwNewIndex++;
                pwszNewPattern[ dwNewIndex ] = pwszPattern[ dw ];
                break;
        }
    }

    dwNewIndex++;
    pwszNewPattern[ dwNewIndex ] = L'\0';
    return pwszNewPattern;
}


BOOL 
InternalRecursiveMatchPatternEx( 
    IN LPCWSTR pwszText,
    IN LPCWSTR pwszPattern,
    IN DWORD dwLocale,
    IN DWORD dwCompareFlags,
    IN DWORD dwDepth )
{
    // local variables
    BOOL bResult = FALSE;
    DWORD dwTextIndex = 0;
    DWORD dwPatternIndex = 0;
    DWORD dwTextLength = 0;
    DWORD dwPatternLength = 0;

    // check the input
    if ( pwszText == NULL || pwszPattern == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    //
    // search the string for the specified pattern
    bResult = TRUE;
    dwTextLength = StringLength( pwszText, 0 );
    dwPatternLength = StringLength( pwszPattern, 0 );
    for( dwPatternIndex = 0, dwTextIndex = 0; dwPatternIndex < dwPatternLength; )
    {
        // check the current text position -- 
        // if it reached the end of the string, exit from the loop
        if ( dwTextIndex >= dwTextLength )
        {
            break;
        }

        switch( pwszPattern[ dwPatternIndex ] )
        {
            case L'?':
                {
                    // pattern allows any character at this position
                    // increment the text and pattern index
                    dwTextIndex++;
                    dwPatternIndex++;
                    break;
                }

            case L'*': 
                {
                    // pattern allows sequence of any characters
                    // to be specified from the current text index
                    // until the next character the index is found
                    // if the current '*' itself is the end of the
                    // pattern, then this text matches the pattern
                    if ( dwPatternIndex + 1 < dwPatternLength )
                    {
                        for( ; dwTextIndex < dwTextLength; dwTextIndex++ )
                        {
                            if ( CompareString( dwLocale, 
                                                dwCompareFlags, 
                                                pwszText + dwTextIndex, 1,
                                                pwszPattern + dwPatternIndex + 1, 1 ) == CSTR_EQUAL )
                            {
                                // the current character in the text matched with the
                                // next character in the pattern -- 
                                // now check whether the text from the current index
                                // matches with the rest of the pattern
                                bResult = InternalRecursiveMatchPatternEx( 
                                    pwszText + dwTextIndex, 
                                    pwszPattern + dwPatternIndex + 1,
                                    dwLocale, dwCompareFlags, dwDepth + 1 );
                                if ( bResult == TRUE )
                                {
                                    // text matched with the pattern
                                    // set the text index to its length 
                                    // this makes the end result to give TRUE
                                    dwTextIndex = dwTextLength;
                                    dwPatternIndex = dwPatternLength;

                                    // break from the loop
                                    break;
                                }
                                else
                                {
                                    // looks like pattern is not matching 
                                    // from the current position -- skip some more characters
                                }
                            }
                        }
                    }
                    else
                    {
                        // since we make the entire text matched with the pattern
                        // set the text index also to the length of the text
                        dwTextIndex = dwTextLength;
                        dwPatternIndex = dwPatternLength;
                    }

                    // ...
                    break;
                }

            default:
                {
                    if ( CompareString( dwLocale, 
                                        dwCompareFlags, 
                                        pwszText + dwTextIndex, 1,
                                        pwszPattern + dwPatternIndex, 1 ) == CSTR_EQUAL )
                    {
                        // update the text position by one character
                        dwTextIndex++;
                        dwPatternIndex++;
                    }
                    else
                    {
                        // character didn't match -- we should exit from the loop
                        bResult = FALSE;
                    }

                    // ...
                    break;
                }
        }

        // check if any error is triggered in between or not
        if ( bResult == FALSE )
        {
            // at some place mismatch is found
            break;
        }
    }
    
    // now the final check -- we need to know how we did we come out of the loop
    // this we can determine by checking the pattern index position
    // if the pattern index is equal to the length of the pattern length -- and
    // the text index is equal to the the length of the text then the pattern is
    // matched
    if ( bResult != FALSE )
    {
        bResult = FALSE;
        if ( dwTextIndex == dwTextLength && dwPatternIndex == dwPatternLength )
        {
            // pattern is matched
            bResult = TRUE;
        }
        else
        {
            // still our conclusion might not be correct
            // for ex: the text "abc" perfectly matches with "???*"
            // but our logic says this is not a valid text -- to aovid
            // this sort of conflicts, we will do one more additional
            // final check to confirm whether the text we have is valid or not
            if ( dwTextIndex == dwTextLength &&
                 dwPatternIndex + 1 == dwPatternLength &&
                 StringCompareEx( pwszPattern + dwPatternIndex, L"*", TRUE, 1 ) == 0 )
            {
                // the text matches the pattern
                bResult = TRUE;
            }
        }
    }

    // return the result of the pattern matching
    return bResult;
}


BOOL 
MatchPatternEx( 
    IN LPCWSTR pwszText, 
    IN LPCWSTR pwszPattern, 
    IN DWORD dwFlags )
{
    // local variables
    BOOL bResult = FALSE;

    // text comparision flags
    LCID lcid = 0;
    DWORD dwCompareFlags = 0;

    // check the input
    if ( pwszText == NULL )
    {
        return FALSE;
    }

    // check the pattern
    if ( pwszPattern == NULL )
    {
        // get the parsed pattern information
        pwszPattern = GetTempBuffer( INDEX_TEMP_PATTERN, NULL, 0, FALSE );
        if ( pwszPattern == NULL || StringLength( pwszPattern, 0 ) == 0 )
        {
            INVALID_PARAMETER();
            return FALSE;
        }
    }
    else
    {
        if ( (dwFlags & PATTERN_NOPARSING) == 0 )
        {
            // user passed a new pattern information parse and validate it
            pwszPattern = ParsePattern( pwszPattern );
            if ( pwszPattern == FALSE )
            {
                return FALSE;
            }
        }
    }

    // check whether we have the pattern information or not -- safety check
    if ( pwszPattern == NULL )
    {
        UNEXPECTED_ERROR();
        return FALSE;
    }

    // if the pattern is '*' we dont need to do any thing
    // just pass TRUE to the caller
    // the pattern will match to the any string
    if ( StringCompareEx( pwszPattern, L"*", TRUE, 0 ) == 0 )
    {
        return TRUE;
    }

    //
    // determine the locale
    if ( dwFlags & PATTERN_LOCALE_USENGLISH )
    {
        // prepare the LCID
        // if this tool is designed to work on XP and earlier, then
        // we can use LOCALE_INVARIANT -- otherwise, we need to prepare the lcid
        lcid = LOCALE_INVARIANT;
        if ( g_dwMajorVersion == 5 && g_dwMinorVersion == 0 )
        {
            // tool desgined to work on pre-windows xp
            lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT );
        }
    }
    else
    {
        lcid = GetThreadLocale();
    }

    //
    // determine the comparision flags

    // NORM_IGNORECASE
    if ( dwFlags & PATTERN_COMPARE_IGNORECASE )
    {
        dwCompareFlags |= NORM_IGNORECASE;
    }

    // NORM_IGNOREKANATYPE
    if ( dwFlags & PATTERN_COMPARE_IGNOREKANATYPE )
    {
        dwCompareFlags |= NORM_IGNOREKANATYPE;
    }

    // NORM_IGNORENONSPACE
    if ( dwFlags & PATTERN_COMPARE_IGNORENONSPACE )
    {
        dwCompareFlags |= NORM_IGNORENONSPACE;
    }

    // NORM_IGNORESYMBOLS
    if ( dwFlags & PATTERN_COMPARE_IGNORESYMBOLS )
    {
        dwCompareFlags |= NORM_IGNORESYMBOLS;
    }

    // NORM_IGNOREWIDTH
    if ( dwFlags & PATTERN_COMPARE_IGNOREWIDTH )
    {
        dwCompareFlags |= NORM_IGNOREWIDTH;
    }

    // SORT_STRINGSORT
    if ( dwFlags & PATTERN_COMPARE_STRINGSORT )
    {
        dwCompareFlags |= SORT_STRINGSORT;
    }

    //
    // check the pattern match
    bResult = InternalRecursiveMatchPatternEx( 
        pwszText, pwszPattern, lcid, dwCompareFlags, 0 );

    // return
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\lib\cmdlineparser.c ===
// ****************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//    CmdLineParser.c
//
//  Abstract:
//
//    This modules implements parsing of command line arguments for the
//    specified options
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 1-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 1-Sep-2000 : Created It.
//
// ****************************************************************************
#include "pch.h"
#include "cmdline.h"
#include "CmdLineRes.h"

// permanent indexes to the temporary buffers
#define INDEX_TEMP_NONE                 0
#define INDEX_TEMP_SPLITOPTION          1
#define INDEX_TEMP_SPLITVALUE           2
#define INDEX_TEMP_SAVEDATA             3
#define INDEX_TEMP_USAGEHELPER          4
#define INDEX_TEMP_MAINOPTION           5

//
// defines / constants / enumerations
//

// constants
const WCHAR cwszOptionChars[ 3 ] = L"-/";
const CHAR cszParserSignature[ 8 ] = "PARSER2";

// version resource specific structures
typedef struct __tagLanguageAndCodePage {
  WORD wLanguage;
  WORD wCodePage;
} TTRANSLATE, *PTTRANSLATE;

// error messages
#define ERROR_USAGEHELPER               GetResString( IDS_ERROR_CMDPARSER_USAGEHELPER )
#define ERROR_NULLVALUE                 GetResString( IDS_ERROR_CMDPARSER_NULLVALUE )
#define ERROR_DEFAULT_NULLVALUE         GetResString( IDS_ERROR_CMDPARSER_DEFAULT_NULLVALUE )
#define ERROR_VALUE_EXPECTED            GetResString( IDS_ERROR_CMDPARSER_VALUE_EXPECTED )
#define ERROR_NOTINLIST                 GetResString( IDS_ERROR_CMDPARSER_NOTINLIST )
#define ERROR_DEFAULT_NOTINLIST         GetResString( IDS_ERROR_CMDPARSER_DEFAULT_NOTINLIST )
#define ERROR_INVALID_NUMERIC           GetResString( IDS_ERROR_CMDPARSER_INVALID_NUMERIC )
#define ERROR_DEFAULT_INVALID_NUMERIC   GetResString( IDS_ERROR_CMDPARSER_DEFAULT_INVALID_NUMERIC )
#define ERROR_INVALID_FLOAT             GetResString( IDS_ERROR_CMDPARSER_INVALID_FLOAT )
#define ERROR_DEFAULT_INVALID_FLOAT     GetResString( IDS_ERROR_CMDPARSER_DEFAULT_INVALID_FLOAT )
#define ERROR_LENGTH_EXCEEDED           GetResString( IDS_ERROR_CMDPARSER_LENGTH_EXCEEDED_EX )
#define ERROR_DEFAULT_LENGTH_EXCEEDED   GetResString( IDS_ERROR_CMDPARSER_DEFAULT_LENGTH_EXCEEDED_EX )
#define ERROR_INVALID_OPTION            GetResString( IDS_ERROR_CMDPARSER_INVALID_OPTION )
#define ERROR_OPTION_REPEATED           GetResString( IDS_ERROR_CMDPARSER_OPTION_REPEATED )
#define ERROR_DEFAULT_OPTION_REPEATED   GetResString( IDS_ERROR_CMDPARSER_DEFAULT_OPTION_REPEATED )
#define ERROR_MANDATORY_OPTION_MISSING  GetResString( IDS_ERROR_CMDPARSER_MANDATORY_OPTION_MISSING )
#define ERROR_DEFAULT_OPTION_MISSING    GetResString( IDS_ERROR_CMDPARSER_DEFAULT_OPTION_MISSING )
#define ERROR_VALUENOTALLOWED           GetResString( IDS_ERROR_CMDPARSER_VALUENOTALLOWED )

//
// custom macros
#define REASON_VALUE_NOTINLIST( value, option, helptext )               \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_DEFAULT_NOTINLIST,                                \
                _X( value ), _X2( helptext ) );                         \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 3, ERROR_NOTINLIST,                             \
                _X( value ), _X2( option ), _X3( helptext ) );          \
        }                                                               \
        1

#define REASON_NULLVALUE( option, helptext )                            \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            SetReason2( 1, ERROR_DEFAULT_NULLVALUE, _X( helptext ) );   \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_NULLVALUE, _X( option ), _X2( helptext ) );       \
        }                                                               \
        1

#define REASON_VALUE_EXPECTED( option, helptext )                       \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            UNEXPECTED_ERROR();                                         \
            SaveLastError();                                            \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_VALUE_EXPECTED, _X( option ), _X2( helptext ) );  \
        }                                                               \
        1

#define REASON_INVALID_NUMERIC( option, helptext )                      \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            SetReason2( 1,                                              \
                ERROR_DEFAULT_INVALID_NUMERIC, _X( helptext ) );        \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_INVALID_NUMERIC, _X( option ), _X2( helptext ) ); \
        }                                                               \
        1

#define REASON_INVALID_FLOAT( option, helptext )                        \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            SetReason2( 1,                                              \
                ERROR_DEFAULT_INVALID_FLOAT, _X( helptext ) );          \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_INVALID_FLOAT, _X( option ), _X2( helptext ) );   \
        }                                                               \
        1

#define REASON_LENGTH_EXCEEDED( option, length )                        \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            SetReason2( 1, ERROR_DEFAULT_LENGTH_EXCEEDED, length );     \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_LENGTH_EXCEEDED, _X( option ), length );          \
        }                                                               \
        1

#define REASON_OPTION_REPEATED( option, count, helptext )               \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_DEFAULT_OPTION_REPEATED, count, helptext );       \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 3,                                              \
                ERROR_OPTION_REPEATED, _X( option ), count, helptext ); \
        }                                                               \
        1

#define REASON_MANDATORY_OPTION_MISSING( option, helptext )             \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            SetReason2( 1,                                              \
                ERROR_DEFAULT_OPTION_MISSING, helptext );               \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_MANDATORY_OPTION_MISSING,                         \
                _X( option ), helptext );                               \
        }                                                               \
        1

#define REASON_VALUENOTALLOWED( option, helptext )                      \
        if ( option == NULL || lstrlen( option ) == 0 )                 \
        {                                                               \
            UNEXPECTED_ERROR();                                         \
            SaveLastError();                                            \
        }                                                               \
        else                                                            \
        {                                                               \
            SetReason2( 2,                                              \
                ERROR_VALUENOTALLOWED, _X( option ), _X2( helptext ) ); \
        }                                                               \
        1

//
// internal structures
//
typedef struct __tagMatchOptionInfo
{
    LPWSTR pwszOption;
    LPWSTR pwszValue;
} TMATCHOPTION_INFO;

typedef struct __tagParserSaveData
{
    DWORD dwIncrement;
    LONG lDefaultIndex;
    LPCWSTR pwszUsageHelper;
    PTCMDPARSER2 pcmdparser;
} TPARSERSAVE_DATA;

//
// private functions ... used only within this file
//
BOOL IsOption( LPCWSTR pwszOption );
BOOL IsValueNeeded( DWORD dwType );
LPCWSTR PrepareUsageHelperText( LPCWSTR pwszOption );
LPCWSTR ExtractMainOption( LPCWSTR pwszOptions, DWORD dwReserved );
BOOL VerifyParserOptions( LONG* plDefaultIndex, 
                          DWORD dwCount, PTCMDPARSER2 pcmdOptions );
BOOL ParseAndSaveOptionValue( LPCWSTR pwszOption, 
                              LPCWSTR pwszValue, TPARSERSAVE_DATA* pSaveData );
LONG MatchOption( DWORD dwOptions,
                  PTCMDPARSER2 pcmdOptions, LPCWSTR pwszOption );
LONG MatchOptionEx( DWORD dwOptions, PTCMDPARSER2 pcmdOptions,
                    LPCWSTR pwszOption, TMATCHOPTION_INFO* pMatchInfo );
BOOL Parser1FromParser2Stub( LPCWSTR pwszOption,
                             LPCWSTR pwszValue,
                             LPVOID pData, DWORD* pdwIncrement );
BOOL ReleaseAllocatedMemory( DWORD dwOptionsCount, PTCMDPARSER2 pcmdOptions );

//
// implementation
//

__inline 
LPWSTR 
GetParserTempBuffer( IN DWORD dwIndexNumber,
                     IN LPCWSTR pwszText,
                     IN DWORD dwLength, 
                     IN BOOL bNullify )
/*++
 Routine Description:

    since every file will need the temporary buffers -- in order to see
    that their buffers wont be override with other functions, we are
    creating seperate buffer space a for each file
    this function will provide an access to those internal buffers and also
    safe guards the file buffer boundaries

 Arguments: 
 
    [ in ] dwIndexNumber    -   file specific index number

    [ in ] pwszText         -   default text that needs to be copied into 
                                temporary buffer

    [ in ] dwLength         -   Length of the temporary buffer that is required
                                Ignored when pwszText is specified

    [ in ] bNullify         -   Informs whether to clear the buffer or not
                                before giving the temporary buffer

 Return Value:

    NULL        -   when any failure occurs
                    NOTE: do not rely on GetLastError to know the reason
                          for the failure.

    success     -   return memory address of the requested size

    NOTE:
    ----
    if pwszText and dwLength both are NULL, then we treat that the caller
    is asking for the reference of the buffer and we return the buffer address.
    In this call, there wont be any memory allocations -- if the requested index
    doesn't exist, we return as failure

    Also, the buffer returned by this function need not released by the caller.
    While exiting from the tool, all the memory will be freed automatically by
    the ReleaseGlobals functions.

--*/
{
    if ( dwIndexNumber >= TEMP_CMDLINEPARSER_C_COUNT )
    {
        return NULL;
    }

    // check if caller is requesting existing buffer contents
    if ( pwszText == NULL && dwLength == 0 && bNullify == FALSE )
    {
        // yes -- we need to pass the existing buffer contents
        return GetInternalTemporaryBufferRef( 
            dwIndexNumber + INDEX_TEMP_CMDLINEPARSER_C );
    }

    // ...
    return GetInternalTemporaryBuffer(
        dwIndexNumber + INDEX_TEMP_CMDLINEPARSER_C, pwszText, dwLength, bNullify );
}


BOOL IsOption( IN LPCWSTR pwszOption )
/*++
 Routine Description:

    Checks whether the passed argument starts with the option character
    or not -- currently the we treat the string as option if they start with
    "-" and "/" .

 Arguments: 
 
    [ in ] pwszOption   -   string value

 Return Value:

    FALSE       -   1. if the parameter is invalid 
                    2. if the string doesn't start with option character
                    To differentiate between the case 1 and case 2 call
                    GetLastError() and check for ERROR_INVALID_PARAMETER.

    TRUE        -   if the string starts with option character

--*/
{
    // clear error
    CLEAR_LAST_ERROR();

    // check the input value
    if ( pwszOption == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // check whether the string starts with '-' or '/' character
    if ( lstrlen( pwszOption ) > 1 &&
         FindChar2( cwszOptionChars, pwszOption[ 0 ], TRUE, 0 ) != -1 )
    {
        return TRUE;        // string value is an option
    }

    // this is not an option
    return FALSE;
}


BOOL IsValueNeeded( DWORD dwType )
/*++
 Routine Description:

    Checks whether the supported data type requires argument for the 
    option or not.

 Arguments: 
 
    [ in ] dwType   -   specifies one of the CP_TYPE_xxxx values

 Return Value:

    TRUE    -   if the supported data type requires argument for the option

    FALSE   -   if the data type passed is not supported (or) if the 
                option of the requested type doesn't require argument.
                NOTE: Do not rely on GetLastError() for detecting the reason
                      for the failure.
--*/
{
    switch( dwType )
    {
    case CP_TYPE_TEXT:
    case CP_TYPE_NUMERIC:
    case CP_TYPE_UNUMERIC:
    case CP_TYPE_FLOAT:
    case CP_TYPE_DOUBLE:
        return TRUE;

    case CP_TYPE_DATE:
    case CP_TYPE_TIME:
    case CP_TYPE_DATETIME:
        return FALSE;

    case CP_TYPE_BOOLEAN:
        return FALSE;

    case CP_TYPE_CUSTOM:
        // actually -- we dont know -- but for now, simply say yes
        return TRUE;

    default:
        return FALSE;
    }
}


LPCWSTR PrepareUsageHelperText( LPCWSTR pwszOption )
/*++
 Routine Description:

    Extracts tool name from the executable module's version resource
    and prepares usage help text -- for ex. if the tool name is 
    eventcreate.exe, this function will generate the text as

        Type "EVENTCREATE /?" for usage.

    Since some tools requires option to be displayed along with the
    tool name, this function accepts a parameter which specifies
    that extra option -- if that extra option is present the message looks
    like:

        Type "SCHTASKS /CREATE /?" for usage.

    If the message need not have the extra option information,
    the caller just needs to pass NULL as parameter to this function.

 Arguments: 
 
    [ in ] pwszOption       -   option that needs to be shown along with 
                                the error text. If option need not be shown, 
                                pass NULL for this argument.

 Return Value:

    NULL        -   this will be returned when anything goes wrong. Use
                    GetLastError() to know what went wrong

    on success  -   formatted usage error text will be returned

--*/
{
    // local variables
    DWORD dw = 0;
    UINT dwSize = 0;
    UINT dwTranslateSize = 0;
    LPWSTR pwszTemp = NULL;
    LPWSTR pwszBuffer = NULL;
    LPWSTR pwszUtilityName = NULL;
    LPVOID pVersionInfo = NULL;
    LPWSTR pwszExeName = NULL;
    PTTRANSLATE pTranslate = NULL;
    
    // clear last error
    CLEAR_LAST_ERROR();

    //
    // try to get the current running module name
    //
    // we dont know whether GetModuleFileName will terminate
    // the module name or not -- also, if the length of the buffer is not
    // sufficient, GetModuleFileName will truncate the file name -- keeping
    // all these scenarios in mind, we will loop in the GetModuleFileName
    // until we make sure that we have the complete the executable name
    // which is also null terminated

    // init
    dw = 0;
    dwSize = _MAX_PATH;

    // ...

    do
    {
        // get the buffer
        dwSize += (dw == 0) ? 0 : _MAX_PATH;
        pwszExeName = GetParserTempBuffer( 0, NULL, dwSize, TRUE );
        if ( pwszExeName == NULL )
        {
            OUT_OF_MEMORY();
            return NULL;
        }

        // get the module name
        dw = GetModuleFileName( NULL, pwszExeName, dwSize );
        if ( dw == 0 )
        {
            return NULL;
        }
    } while (dw >= dwSize - 1);

    // get the version information size
    dwSize = GetFileVersionInfoSize( pwszExeName, 0 );
    if ( dwSize == 0 )
    {
        // tool might have encountered error (or)
        // tool doesn't have version information
        // but version information is mandatory for us
        // so, just exit
        if ( GetLastError() == NO_ERROR )
        {
            INVALID_PARAMETER();
        }

        // ...
        return NULL;
    }

    // allocate memory for the version resource
    // take some 10 bytes extra -- for safety purposes
    dwSize += 10;
    pVersionInfo = AllocateMemory( dwSize );
    if ( pVersionInfo == NULL )
    {
        return NULL;
    }

    // now get the version information
    if ( GetFileVersionInfo( pwszExeName, 0,
                             dwSize, pVersionInfo ) == FALSE )
    {
        FreeMemory( &pVersionInfo );
        return NULL;
    }

    // get the translation info
    if ( VerQueryValue( pVersionInfo, 
                        L"\\VarFileInfo\\Translation",
                        (LPVOID*) &pTranslate, &dwTranslateSize ) == FALSE )
    {
        FreeMemory( &pVersionInfo );
        return NULL;
    }

    // get the buffer to store the translation array format string
    pwszBuffer = GetParserTempBuffer( 0, NULL, 64, TRUE );

    // try to get the internal name of the tool for each language and code page.
    pwszUtilityName = NULL;
    for( dw = 0; dw < ( dwTranslateSize / sizeof( TTRANSLATE ) ); dw++ )
    {
        // prepare the format string to get the localized the version info
        StringCchPrintfW( pwszBuffer, 64, 
            L"\\StringFileInfo\\%04x%04x\\InternalName",
            pTranslate[ dw ].wLanguage, pTranslate[ dw ].wCodePage );

        // retrieve file description for language and code page "i". 
        if ( VerQueryValue( pVersionInfo, pwszBuffer,
                            (LPVOID*) &pwszUtilityName, &dwSize ) == FALSE )
        {
            // we cannot decide the failure based on the result of this
            // function failure -- we will decide about this
            // after terminating from the 'for' loop
            // for now, make the pwszExeName to NULL -- this will
            // enable us to decide the result
            pwszUtilityName = NULL;
        }
        else
        {
            // successfully retrieved the internal name
            break;
        }
    }

    // check whether we got the executable name or not -- if not, error 
    if ( pwszUtilityName == NULL )
    {
        FreeMemory( &pVersionInfo );
        return NULL;
    }

    // check whether filename has .EXE as extension or not
    // also the file name should be more than 4 characters (including extension)
    if ( StringLength( pwszUtilityName, 0 ) <= 4 )
    {
        // some thing wrong -- version resource should include the internal name
        FreeMemory( &pVersionInfo );
        UNEXPECTED_ERROR();
        return NULL;
    }
	else if ( FindString2( pwszUtilityName, L".EXE", TRUE, 0 ) != -1 )
	{
	    // now put null character -- this is to trim the extension
	    pwszUtilityName[ lstrlen( pwszUtilityName ) - lstrlen( L".EXE" ) ] = cwchNullChar;
	}

    // determine the size we need for
    if ( pwszOption != NULL )
    {
        // "length of utility name + 1 (space) + length of option" + 10 buffer (for safety)
        dwSize = lstrlen( pwszUtilityName ) + lstrlen( pwszOption ) + 11;

        // get the temporary buffer for that
        if ( (pwszTemp = GetParserTempBuffer( 0, NULL, dwSize, TRUE )) == NULL )
        {
            FreeMemory( &pVersionInfo );
            OUT_OF_MEMORY();
            return NULL;
        }

        // ...
        StringCchPrintfW( pwszTemp, dwSize, L"%s %s", pwszUtilityName, pwszOption );

        // now remap the utility name pointer to the temp pointer
        pwszUtilityName = pwszTemp;
    }
    else
    {
        // get the temporary buffer with this utilty name
        if ( (pwszTemp = GetParserTempBuffer( 0, pwszUtilityName, 0, FALSE )) == NULL )
        {
            FreeMemory( &pVersionInfo );
            OUT_OF_MEMORY();
            return NULL;
        }

        // now remap the utility name pointer to the temp pointer
        pwszUtilityName = pwszTemp;
    }

    // convert the utility name into uppercase
    CharUpper( pwszUtilityName );

    // get the temporary buffer
    // NOTE: we will restrict this to 80 characters only -- this itself is
    //       too high memory for this simple text string
    pwszBuffer = GetParserTempBuffer( INDEX_TEMP_USAGEHELPER, NULL, 80, TRUE );
    if ( pwszBuffer == NULL )
    {
        FreeMemory( &pVersionInfo );
        OUT_OF_MEMORY();
        return FALSE;
    }

    // prepare the text now
    // NOTE: look -- we are passing 79 only in _snwprintf
    StringCchPrintfW( pwszBuffer, 80, ERROR_USAGEHELPER, pwszUtilityName );

    // releast the memory allocated for version information
    FreeMemory( &pVersionInfo );

    // return the text
    return pwszBuffer;
}


LPCWSTR ExtractMainOption( LPCWSTR pwszOptions, DWORD dwReserved )
/*++
 Routine Description:

    Our command line parser can handle multiple names for the single option.
    But while displaying error messages, it will be weird if we display all
    those options when some error occured. To eliminate that, this function
    will identify how many options are present in the given options list and
    if it finds multiple options, it will extract the first option in the list
    and returns to the caller otherwise if it finds only one argument, this 
    function will just return the option as it is.

 Arguments: 
 
    [ in ] pwszOptions      -    List of options seperated by "|" character

    [ in ] dwReserved       -    reserved for future use

 Return Value:

    NULL        -   on failure. Call GetLastError() function to know the
                    cause for the failure.

    on success  -   the first option the list of supplied options will be
                    returned. If there is only one option, then the same will
                    be returned.
--*/
{
    // local variables
    LONG lIndex = 0;
    LPWSTR pwszBuffer = NULL;

    // clear last error
    CLEAR_LAST_ERROR();

    // check the input
    if ( pwszOptions == NULL || dwReserved != 0 )
    {
        INVALID_PARAMETER();
        return NULL;
    }

    // search for the option seperator
    lIndex = FindChar2( pwszOptions, L'|', TRUE, 0 );
    if ( lIndex == -1 )
    {
        // there are no multiple options
        CLEAR_LAST_ERROR();
        lIndex = StringLength( pwszOptions, 0 );
    }

    // get the temporary buffer
    // NOTE: get the buffer with more characters to fit in
    pwszBuffer = GetParserTempBuffer( INDEX_TEMP_MAINOPTION, NULL, lIndex + 5, TRUE );
    if ( pwszBuffer == NULL )
    {
        OUT_OF_MEMORY();
        return NULL;
    }

    // now extract the main option
    // NOTE: observe the (lIndex + 2) in the StringConcat function call
    //       that plays the trick of extracting the main option
    StringCopy( pwszBuffer, L"/", lIndex + 1 );
    StringConcat( pwszBuffer, pwszOptions, lIndex + 2 );

    // return
    return pwszBuffer;
}


BOOL VerifyParserOptions( LONG* plDefaultIndex,
                          DWORD dwCount, 
                          PTCMDPARSER2 pcmdOptions )
/*++
 Routine Description:

    Checks the validity of the parsing instructions passed by the caller.

 Arguments: 

    [ out ] plDefaultIndex      -   Updates the variable with default option
                                    index.

    [ in ] dwCount              -   Specifies the count of parser structures
                                    passed to this function.

    [ in ] pcmdoptions          -   array of parser structures

 Return Value:

    TRUE        -   if all the data passed to this function is valid

    FALSE       -   if any of the data is not correct. This also sets the last
                    error ERROR_INVALID_PARAMETER.

--*/
{
    // local variables
    DWORD dw = 0;
    DWORD64 dwFlags = 0;
    BOOL bUsage = FALSE;
    PTCMDPARSER2 pcmdparser = NULL;

    // clear last error
    CLEAR_LAST_ERROR();

    // check the input
    if ( dwCount != 0 && pcmdOptions == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }

    // ...
    if ( plDefaultIndex == NULL )
    {
        INVALID_PARAMETER();
        return FALSE;
    }
    else
    {
        *plDefaultIndex = -1;
    }

    // loop thru each option data and verify
    for( dw = 0; dw < dwCount; dw++ )
    {
        pcmdparser = pcmdOptions +  dw;

        // safety check
        if ( pcmdparser == NULL )
        {
            UNEXPECTED_ERROR();
            return FALSE;
        }

        // verify the signature
        if ( StringCompareA( pcmdparser->szSignature, 
                             cszParserSignature, TRUE, 0 ) != 0 )
        {
            INVALID_PARAMETER();
            return FALSE;
        }

        // ...
        dwFlags = pcmdparser->dwFlags;

        if ( pcmdparser->dwReserved != 0    ||
             pcmdparser->pReserved1 != NULL ||
             pcmdparser->pReserved2 != NULL ||
             pcmdparser->pReserved3 != NULL )
        {
            INVALID_PARAMETER();
            return FALSE;
        }

        // check the contents of pwszOptions
        // this can be NULL (or) empty only when dwFlags has CP2_DEFAULT
        if ( ((dwFlags & CP2_DEFAULT) == 0) &&
             (pcmdparser->pwszOptions == NULL ||
              lstrlen( pcmdparser->pwszOptions ) == 0) )
        {
            INVALID_PARAMETER();
            return FALSE;
        }

        // usage flag can be specified only for boolean types
        if ( (dwFlags & CP2_USAGE) && pcmdparser->dwType != CP_TYPE_BOOLEAN )
        {
            INVALID_PARAMETER();
            return FALSE;
        }

        // CP2_USAGE can be specified only once
        if ( dwFlags & CP2_USAGE )
        {
            if ( bUsage == TRUE )
            {
                // help switch can be specified only once
                INVALID_PARAMETER();
                return FALSE;
            }
            else
            {
                bUsage = TRUE;
            }
        }

        // CP2_DEFAULT can be specified only once
        if ( dwFlags & CP2_DEFAULT  )
        {
            if ( *plDefaultIndex != -1 )
            {
                // default switch can be specified only once
                INVALID_PARAMETER();
                return FALSE;
            }
            else
            {
                *plDefaultIndex = (LONG) dw;
            }
        }

        // CP2_VALUE_OPTIONAL is not allowed along with
        // CP2_MODE_VALUES
        // if ( (dwFlags & CP2_VALUE_OPTIONAL) && (dwFlags & CP2_MODE_VALUES) )
        // {
        //     INVALID_PARAMETER();
        //     return FALSE;
        // }

        // CP2_USAGE and CP2_DEFAULT cannot be specified on the same index
        if ( (dwFlags & CP2_USAGE) && (dwFlags & CP2_DEFAULT) )
        {
            INVALID_PARAMETER();
            return FALSE;
        }

        // check the data type
        switch( pcmdparser->dwType )
        {
        case CP_TYPE_TEXT:
            {
                if ( dwFlags & CP2_ALLOCMEMORY )
                {
                    // mode should not be any array
                    if ( (dwFlags & CP2_MODE_ARRAY) || pcmdparser->pValue != NULL )
                    {
                        INVALID_PARAMETER();
                        return FALSE;
                    }

                    // check the length attribute
                    if ( pcmdparser->dwLength != 0 && pcmdparser->dwLength < 2 )
                    {
                        INVALID_PARAMETER();
                        return FALSE;
                    }
                }
                else
                {
                    if ( pcmdparser->pValue == NULL )
                    {
                        // invalid memory reference
                        INVALID_PARAMETER();
                        return FALSE;
                    }

                    if ( dwFlags & CP2_MODE_ARRAY )
                    {
                        if ( IsValidArray( *((PTARRAY) pcmdparser->pValue) )== FALSE )
                        {
                             INVALID_PARAMETER();
                             return FALSE;
                        }
                    }
                }

                if ( (dwFlags & CP2_MODE_VALUES) &&
                     (pcmdparser->pwszValues == NULL) )
                {
                    INVALID_PARAMETER();
                    return FALSE;
                }

                if ( (dwFlags & CP2_MODE_ARRAY) == 0 )
                {
                    if ( pcmdparser->dwCount != 1 || 
                         (dwFlags & CP2_VALUE_NODUPLICATES) ||
                         ( ((dwFlags & CP2_ALLOCMEMORY) == 0) &&
                             pcmdparser->dwLength < 2 ) )
                    {
                        INVALID_PARAMETER();
                        return FALSE;
                    }
                }

                // ...
                break;
            }

        case CP_TYPE_NUMERIC:
        case CP_TYPE_UNUMERIC:
        case CP_TYPE_FLOAT:
        case CP_TYPE_DOUBLE:
            {
                // currently not implemented
                if ( dwFlags & CP2_MODE_VALUES )
                {
                    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
                    return FALSE;
                }

                if ( (dwFlags & CP2_ALLOCMEMORY) ||
                     (dwFlags & CP2_VALUE_TRIMINPUT) ||
                     (dwFlags & CP2_VALUE_NONULL) )
                {
                    // memory allocation will not be accepted for
                    // these data types
                    INVALID_PARAMETER();
                    return FALSE;
                }

                // check the pointer
                if ( pcmdparser->pValue == NULL )
                {
                    // invalid memory reference
                    INVALID_PARAMETER();
                    return FALSE;
                }

                // if the value acceptance mode is array, check that
                if ( dwFlags & CP2_MODE_ARRAY )
                {
                    if ( IsValidArray( *((PTARRAY) pcmdparser->pValue) ) == FALSE )
                    {
                        INVALID_PARAMETER();
                        return FALSE;
                    }
                }
                else if ( (pcmdparser->dwCount > 1) ||
                          (dwFlags & CP2_VALUE_NODUPLICATES) )
                {
                    INVALID_PARAMETER();
                    return FALSE;
                }

                if ( (dwFlags & CP2_MODE_VALUES) &&
                     pcmdparser->pwszValues == NULL )
                {
                    INVALID_PARAMETER();
                    return FALSE;
                }

                // ...
                break;
            }

        case CP_TYPE_CUSTOM:
            {
                if ( pcmdparser->pFunction == NULL )
                {
                    INVALID_PARAMETER();
                    return FALSE;
                }

                // if the custom function data is NULL, assign the current
                // object itself to it
                if ( pcmdparser->pFunctionData == NULL )
                {
                    pcmdparser->pFunctionData = pcmdparser;
                }

                // ...
                break;
            }

        case CP_TYPE_DATE:
        case CP_TYPE_TIME:
        case CP_TYPE_DATETIME:
            // currently not supported
            SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
            return FALSE;

        case CP_TYPE_BOOLEAN:
            {
                // no flags are allowed for this type
                if ( (dwFlags & CP2_MODE_MASK) || (dwFlags & CP2_VALUE_MASK) )
                {
                    INVALID_PARAMETER();
                    return FALSE;
                }

                // CP2_USAGE and CP2_CASESENSITIVE
                // are the only two flags that can be associated with this
                // type of options
                if ( dwFlags & ( ~(CP2_USAGE | CP2_CASESENSITIVE) ) )
                {
                    INVALID_PARAMETER();
                    return FALSE;
                }

                // ...
                break;
            }

        default:
            INVALID_PARAMETER();
            return FALSE;
        }

        // init the actuals to 0
        pcmdparser->dwActuals = 0;
    }

    // everything went fine -- success
    return TRUE;
}


BOOL ParseAndSaveOptionValue( LPCWSTR pwszOption,
                              LPCWSTR pwszValue,
                              TPARSERSAVE_DATA* pSaveData )
/*++
 Routine Description:

    Processes the value and saves the data back into the memory location
    passed by the caller via PARSER structure.

 Arguments: 

    [ in ] pwszOption       -   option specified at the command prompt

    [ in ] pwszValue        -   value that needs to be assciated with option.
 

 Return Value:


--*/
{
    // local variables
    LONG lIndex = 0, lValue = 0;
    DWORD dwLength = 0, dwValue = 0;
    float fValue = 0.0f;
    double dblValue = 0.0f;
    BOOL bSigned = FALSE;
    DWORD64 dwFlags = 0;
    LPVOID pvData = NULL;
    LPWSTR pwszBuffer = NULL;
    LPCWSTR pwszOptionValues = NULL;
    LPCWSTR pwszUsageHelper = NULL;
    PTCMDPARSER2 pcmdparser = NULL;

    // clear last error
    CLEAR_LAST_ERROR();

    // check the input
    if ( pSaveData == NULL )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return FALSE;
    }

    // extract the structure data into local variables
    pcmdparser = pSaveData->pcmdparser;
    pwszUsageHelper = pSaveData->pwszUsageHelper;

    if ( pcmdparser == NULL || pwszUsageHelper == NULL )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return FALSE;
    }

    // ...
    pvData = pcmdparser->pValue;
    dwFlags = pcmdparser->dwFlags;
    dwLength = pcmdparser->dwLength;
    pwszOptionValues = pcmdparser->pwszValues;

    // except for the boolean types, for all the other types,
    // the value for an option is mandatory except when optional flag is
    // explicitly specified
    if ( pcmdparser->dwType != CP_TYPE_BOOLEAN )
    {
        if ( pwszValue == NULL &&
             (dwFlags & CP2_VALUE_OPTIONAL) == 0 )
        {
            REASON_VALUE_EXPECTED( pwszOption, pwszUsageHelper );
            INVALID_SYNTAX();
            return FALSE;
        }
    }

    // pwszOption can be NULL only if dwFlags contains CP2_DEFAULT
    if ( pwszOption == NULL && ((dwFlags & CP2_DEFAULT) == 0) )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return FALSE;
    }

    // determine whether we can make use of the friendly name
    if ( pwszOption == NULL ||
        (pcmdparser->pwszFriendlyName != NULL &&
         pcmdparser->dwType != CP_TYPE_CUSTOM) )
    {
        pwszOption = pcmdparser->pwszFriendlyName;
    }

    switch( pcmdparser->dwType )
    {
    case CP_TYPE_TEXT:
        {
            // check whether we need to trim the string
            if ( pwszValue != NULL && 
                 (dwFlags & (CP2_MODE_VALUES | CP2_VALUE_TRIMINPUT)) )
            {
                if ( (pwszBuffer = GetParserTempBuffer(
                                            INDEX_TEMP_SAVEDATA,
                                            pwszValue, 0, FALSE )) == NULL )
                {
                    OUT_OF_MEMORY();
                    SaveLastError();
                    return FALSE;
                }

                // trim the contents
                pwszValue = TrimString2( pwszBuffer, L" \t", TRIM_ALL );
                if ( GetLastError() != NO_ERROR )
                {
                    // unexpected error occured
                    SaveLastError();
                    return FALSE;
                }
            }

            // check whether the value is in the allowed list -- if needed
            if ( dwFlags & CP2_MODE_VALUES )
            {
                // check the value for NULL
                if ( pwszValue == NULL )
                {
                    // CP2_MODE_VALUES takes the precedence over CP2_VALUE_OPTIONAL
                    // INVALID_SYNTAX();
                    // SaveLastError();
                    return TRUE;
                }

                if ( InString( pwszValue, pwszOptionValues, TRUE ) == FALSE )
                {
                    REASON_VALUE_NOTINLIST( pwszValue, pwszOption, pwszUsageHelper );
                    INVALID_SYNTAX();
                    return FALSE;
                }
            }

            // check the pwszValue argument -- if it is null,
            // just return as success -- this is 'coz the current argument
            // has value optional flag
            if ( pwszValue == NULL )
            {
                return TRUE;
            }

            
            // check for non-null (if requested)
            if ( (dwFlags & CP2_VALUE_NONULL) && lstrlen( pwszValue ) == 0 )
            {
                REASON_NULLVALUE( pwszOption, pwszUsageHelper );
                INVALID_SYNTAX();
                return FALSE;
            }

            // check the mode of the input
            if ( dwFlags & CP2_MODE_ARRAY )
            {
                // if the mode is array, add to the array
                // but before adding check whether duplicates
                // has to be eliminated or not
                lIndex = -1;
                if ( pcmdparser->dwFlags & CP_VALUE_NODUPLICATES )
                {
                    // check whether current value already exists in the list or not
                    lIndex =
                        DynArrayFindString(
                        *((PTARRAY) pvData), pwszValue, TRUE, 0 );
                }

                // now add the value to array only if the item doesn't exist in list
                if ( lIndex == -1 )
                {
                    if ( DynArrayAppendString( *((PTARRAY) pvData),
                                                pwszValue, 0 ) == -1 )
                    {
                        OUT_OF_MEMORY();
                        SaveLastError();
                        return FALSE;
                    }
                }
            }
            else
            {
                // do the length check
                // NOTE: user should specify the value which is one character
                //       less than the length allowed
                if ( dwLength != 0 && lstrlen( pwszValue ) >= (LONG) dwLength )
                {
                    REASON_LENGTH_EXCEEDED( pwszOption, dwLength - 1 );
                    INVALID_SYNTAX();
                    return FALSE;
                }

                // allocate memory if requested
                if ( dwFlags & CP2_ALLOCMEMORY )
                {
                    dwLength = lstrlen( pwszValue ) + 1;
                    pvData = AllocateMemory( dwLength * sizeof( WCHAR ) );
                    if ( pvData == NULL )
                    {
                        OUT_OF_MEMORY();
                        SaveLastError();
                        return FALSE;
                    }

                    // ...
                    pcmdparser->pValue = pvData;
                }

                // else just do copy
                StringCopy( ( LPWSTR ) pvData, pwszValue, dwLength );
            }

            // break from the switch ... case
            break;
        }

    case CP_TYPE_NUMERIC:
    case CP_TYPE_UNUMERIC:
        {
            // ...
            bSigned = (pcmdparser->dwType == CP_TYPE_NUMERIC);

            // check the pwszValue argument -- if it is null,
            // just return as success -- this is 'coz the current argument
            // has value optional flag
            if ( pwszValue == NULL )
            {
                return TRUE;
            }

            // check whether the value is numeric or not
            if ( StringLength(pwszValue,0) == 0 || IsNumeric( pwszValue, 10, bSigned ) == FALSE )
            {
                //
                // error ... non numeric value
                // but, this option might have an optional value
                // check that flag
                if ( dwFlags & CP2_VALUE_OPTIONAL )
                {
                    // yes -- this option takes an optional value
                    // so, the next one could be possibly a default
                    // option -- we need to confirm this -- 'coz this is
                    // very very rare occassion -- but we still need to handle it
                    if ( pSaveData->lDefaultIndex != -1 )
                    {
                        // yes -- the value might be a default argument
                        // update the increment accordingly
                        pSaveData->dwIncrement = 1;
                        return TRUE;
                    }
                }

                // all the tests failed -- so
                // set the reason for the failure and return
                REASON_INVALID_NUMERIC( pwszOption, pwszUsageHelper );
                INVALID_SYNTAX();
                return FALSE;
            }

            // convert the values
            if ( bSigned == TRUE )
            {
                lValue = AsLong( pwszValue, 10 );
            }
            else
            {
                dwValue = AsLong( pwszValue, 10 );
            }

            // ***************************************************
            // ***  NEED TO ADD THE RANGE CHECKING LOGIC HERE  ***
            // ***************************************************

            // check the mode of the input
            if ( dwFlags & CP2_MODE_ARRAY )
            {
                // if the mode is array, add to the array
                // but before adding check whether duplicates
                // has to be eliminated or not
                lIndex = -1;
                if ( pcmdparser->dwFlags & CP_VALUE_NODUPLICATES )
                {
                    // check whether current value already exists in the list or not
                    if ( bSigned == TRUE )
                    {
                        lIndex = DynArrayFindLong( *((PTARRAY) pvData), lValue );
                    }
                    else
                    {
                        lIndex = DynArrayFindDWORD( *((PTARRAY) pvData), dwValue );
                    }
                }

                // now add the value to array only if the item doesn't exist in list
                if ( lIndex == -1 )
                {
                    if ( bSigned == TRUE )
                    {
                        lIndex = DynArrayAppendLong( *((PTARRAY) pvData), lValue );
                    }
                    else
                    {
                        lIndex = DynArrayAppendDWORD( *((PTARRAY) pvData), dwValue );
                    }

                    if ( lIndex == -1 )
                    {
                        OUT_OF_MEMORY();
                        SaveLastError();
                        return FALSE;
                    }
                }
            }
            else
            {
                // else just assign
                if ( bSigned == TRUE )
                {
                    *( ( LONG* ) pvData ) = lValue;
                }
                else
                {
                    *( ( DWORD* ) pvData ) = dwValue;
                }
            }

            // break from the switch ... case
            break;
        }

    case CP_TYPE_FLOAT:
    case CP_TYPE_DOUBLE:
        {
            // check the pwszValue argument -- if it is null,
            // just return as success -- this is 'coz the current argument
            // has value optional flag
            if ( pwszValue == NULL )
            {
                return TRUE;
            }

            // check whether the value is numeric or not
            if ( IsFloatingPoint( pwszValue ) == FALSE )
            {
                //
                // error ... non floating point value
                // but, this option might have an optional value
                // check that flag
                if ( dwFlags & CP2_VALUE_OPTIONAL )
                {
                    // yes -- this option takes an optional value
                    // so, the next one could be possibly a default
                    // option -- we need to confirm this -- 'coz this is
                    // very very rare occassion -- but we still need to handle it
                    if ( pSaveData->lDefaultIndex != -1 )
                    {
                        // yes -- the value might be a default argument
                        // update the increment accordingly
                        pSaveData->dwIncrement = 1;
                        return TRUE;
                    }
                }

                // all the tests failed -- so
                // set the reason for the failure and return
                REASON_INVALID_FLOAT( pwszOption, pwszUsageHelper );
                INVALID_SYNTAX();
                return FALSE;
            }

            // convert the values
            if ( pcmdparser->dwType == CP_TYPE_FLOAT )
            {
                fValue = (float) AsFloat( pwszValue );
            }
            else
            {
                dblValue = AsFloat( pwszValue );
            }

            // ***************************************************
            // ***  NEED TO ADD THE RANGE CHECKING LOGIC HERE  ***
            // ***************************************************

            // check the mode of the input
            if ( dwFlags & CP2_MODE_ARRAY )
            {
                // if the mode is array, add to the array
                // but before adding check whether duplicates
                // has to be eliminated or not
                lIndex = -1;
                if ( pcmdparser->dwFlags & CP_VALUE_NODUPLICATES )
                {
                    // check whether current value already exists in the list or not
                    if ( pcmdparser->dwType == CP_TYPE_FLOAT )
                    {
                        lIndex = DynArrayFindFloat( *((PTARRAY) pvData), fValue );
                    }
                    else
                    {
                        lIndex = DynArrayFindDouble( *((PTARRAY) pvData), dblValue );
                    }
                }

                // now add the value to array only if the item doesn't exist in list
                if ( lIndex == -1 )
                {
                    if ( pcmdparser->dwType == CP_TYPE_FLOAT )
                    {
                        lIndex = DynArrayAppendFloat( *((PTARRAY) pvData), fValue );
                    }
                    else
                    {
                        lIndex = DynArrayAppendDouble( *((PTARRAY) pvData), dblValue );
                    }

                    if ( lIndex == -1 )
                    {
                        OUT_OF_MEMORY();
                        SaveLastError();
                        return FALSE;
                    }
                }
            }
            else
            {
                // else just assign
                if ( pcmdparser->dwType == CP_TYPE_FLOAT )
                {
                    *( ( float* ) pvData ) = fValue;
                }
                else
                {
                    *( ( double* ) pvData ) = dblValue;
                }
            }

            // break from the switch ... case
            break;
        }

    case CP_TYPE_CUSTOM:
        {
            // call the custom function
            // and result itself is return value of this function
            return ( *pcmdparser->pFunction)( pwszOption, 
                pwszValue, pcmdparser->pFunctionData, &pSaveData->dwIncrement );

            // ...
            break;
        }

    case CP_TYPE_DATE:
    case CP_TYPE_TIME:
    case CP_TYPE_DATETIME:
        {
            // break from the switch ... case
            break;
        }

    case CP_TYPE_BOOLEAN:
        {
            // it is compulsory that the pwszValue should point to NULL
            if ( pwszValue != NULL )
            {
                REASON_VALUENOTALLOWED( pwszOption, pwszUsageHelper );
                INVALID_SYNTAX();
                return FALSE;
            }

            *( ( BOOL* ) pvData ) = TRUE;

            // break from the switch ... case
            break;
        }

    default:
        // nothing -- but should be failure
        {
            INVALID_PARAMETER();
            SaveLastError();
            return FALSE;
        }
    }

    // everything went fine -- success
    return TRUE;
}


LONG MatchOption( DWORD dwOptions,
                  PTCMDPARSER2 pcmdOptions,
                  LPCWSTR pwszOption )
/*++
 Routine Description:


 Arguments: 
 

 Return Value:


--*/
{
    // local variables
    DWORD dw = 0;
    BOOL bIgnoreCase = FALSE;
    PTCMDPARSER2 pcmdparser = NULL;

    // clear last error
    CLEAR_LAST_ERROR();

    // check the input value
    if ( dwOptions == 0 || pcmdOptions == NULL || pwszOption == NULL )
    {
        INVALID_PARAMETER();
        return -1;
    }

    // check whether the passed argument is an option or not.
    // option : starts with '-' or '/'
    if ( IsOption( pwszOption ) == FALSE )
    {
        SetLastError( ERROR_NOT_FOUND );
        return -1;
    }

    // parse thru the list of options and return the appropriate option id
    for( dw = 0; dw < dwOptions; dw++ )
    {
        pcmdparser = pcmdOptions + dw;

        // safety check
        if ( pcmdparser == NULL )
        {
            UNEXPECTED_ERROR();
            SaveLastError();
            return FALSE;
        }

        // determine the case-sensitivity choice
        bIgnoreCase = (pcmdparser->dwFlags & CP2_CASESENSITIVE) ? FALSE : TRUE;

        // ...
        if ( pcmdparser->pwszOptions != NULL && 
             lstrlen( pcmdparser->pwszOptions ) > 0 )
        {
            // find the appropriate option entry in parser list
            if ( InString( pwszOption + 1,
                           pcmdparser->pwszOptions, bIgnoreCase) == TRUE )
            {
                return dw;     // option matched
            }
        }
    }

    // here we know that option is not found
    SetLastError( ERROR_NOT_FOUND );
    return -1;
}


LONG MatchOptionEx( DWORD dwOptions, PTCMDPARSER2 pcmdOptions,
                    LPCWSTR pwszOption, TMATCHOPTION_INFO* pMatchInfo )
/*++
 Routine Description:


 Arguments: 
 

 Return Value:


--*/
{
    // local variables
    LONG lValueLength = 0;
    LONG lOptionLength = 0;

    // clear the last error
    CLEAR_LAST_ERROR();

    // check input
    if ( dwOptions == 0 || pcmdOptions == NULL ||
         pwszOption == NULL || pMatchInfo == NULL )
    {
        INVALID_PARAMETER();
        return -1;
    }

    // init
    pMatchInfo->pwszOption = NULL;
    pMatchInfo->pwszValue = NULL;

    // search for ':' seperator
    lOptionLength = FindChar2( pwszOption, L':', TRUE, 0 );
    if ( lOptionLength == -1 )
    {
        return -1;
    }

    // determine the length of value argument
    lValueLength = lstrlen( pwszOption ) - lOptionLength - 1;

    //
    // get the buffers for option and value
    // ( while taking memory, add some buffer to the required length )

    // option
    pMatchInfo->pwszOption = GetParserTempBuffer(
        INDEX_TEMP_SPLITOPTION, NULL, lOptionLength + 5, TRUE );
    if ( pMatchInfo->pwszOption == NULL )
    {
        OUT_OF_MEMORY();
        return -1;
    }

    // value
    pMatchInfo->pwszValue = GetParserTempBuffer(
        INDEX_TEMP_SPLITVALUE, NULL, lValueLength + 5, TRUE );
    if ( pMatchInfo->pwszValue == NULL )
    {
        OUT_OF_MEMORY();
        return -1;
    }

    // copy the values into appropriate buffers (+1 for null character)
    StringCopy( pMatchInfo->pwszOption, pwszOption, lOptionLength + 1 );

    if ( lValueLength != 0 )
    {
        StringCopy( pMatchInfo->pwszValue,
            pwszOption + lOptionLength + 1, lValueLength + 1 );
    }

    // search for the match and return the same result
    return MatchOption( dwOptions, pcmdOptions, pMatchInfo->pwszOption );
}


BOOL Parser1FromParser2Stub( LPCWSTR pwszOption,
                             LPCWSTR pwszValue,
                             LPVOID pData, DWORD* pdwIncrement )
/*++
 Routine Description:


 Arguments: 
 

 Return Value:


--*/
{
    // local variables
    LPCWSTR pwszUsageText = NULL;
    PTCMDPARSER pcmdparser = NULL;

    // check the input
    // NOTE: we dont care about the pwszOption and pwszValue
    if ( pData == NULL || pdwIncrement == NULL )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return FALSE;
    }

    // both pwszOption and pwszValue cannot be NULL at the same time
    if ( pwszOption == NULL && pwszValue == NULL )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return FALSE;
    }

    // extract the "version 1" structure
    pcmdparser = (PTCMDPARSER) pData;

    // in "version 1" of command line parsing, pwszValue and pwszOption
    // should not be NULL -- that means, those both should point to some data
    // but "version 2", pwszOption and pwszValue can be NULL -- but whether 
    // they can be NULL or not depends on the data type and the requirement
    // so, in order to port the old code successfully, we need to do the 
    // necessary substitutions

    // check the option
    if ( pwszOption == NULL )
    {
        // this means the value is of CP_DEFAULT -- check that 
        if ( (pcmdparser->dwFlags & CP_DEFAULT) == 0 )
        {
            // this case -- since the option is not marked as default
            // the option should not be NULL
            INVALID_PARAMETER();
            SaveLastError();
            return FALSE;
        }

        // let value and option point to the same contents(address)
        // this is how the "version 1" used to treat
        pwszOption = pwszValue;
    }
    
    // now check the value
    else if ( pwszValue == NULL )
    {
        // in "version 1" the value field should never to NULL 
        // especially when dealing with CUSTOM types
        // but to be on safe side, check whether user informed that
        // the value is optional
        if ( pcmdparser->dwFlags & CP_VALUE_MANDATORY )
        {
            // get the usage help text
            pwszUsageText = GetParserTempBuffer( 
                INDEX_TEMP_USAGEHELPER, NULL, 0, FALSE );
            if ( pwszUsageText == NULL )
            {
                UNEXPECTED_ERROR();
                SaveLastError();
                return FALSE;
            }

            // set the error
            REASON_VALUE_EXPECTED( pwszOption, pwszUsageText );
            INVALID_SYNTAX();
            return FALSE;
        }
    }

    // update the incrementer as 2 --
    // this is default for custom function in "version 1"
    *pdwIncrement = 2;

    // call the custom function and return the value
    return ( *pcmdparser->pFunction)( pwszOption, pwszValue, pcmdparser->pFunctionData );
}


BOOL ReleaseAllocatedMemory( DWORD dwOptionsCount, 
                             PTCMDPARSER2 pcmdOptions )
/*++
 Routine Description:

 Arguments: 
 
 Return Value:

--*/
{
    // local variables
    DWORD dw = 0;
    DWORD dwLastError = 0;
    LPCWSTR pwszReason = NULL;
    PTCMDPARSER2 pcmdparser = NULL;

    // check the input
    if ( dwOptionsCount == 0 || pcmdOptions == NULL )
    {
        return FALSE;
    }

    // save the last error and error text
    dwLastError = GetLastError();
    pwszReason = GetParserTempBuffer( 0, GetReason(), 0, FALSE );
    if ( pwszReason == NULL )
    {
        return FALSE;
    }

    // free the memory allocated by parser for CP2_ALLOCMEMORY
    for( dw = 0; dw < dwOptionsCount; dw++ )
    {
        pcmdparser = pcmdOptions + dw;
        if ( pcmdparser->pValue != NULL &&
             (pcmdparser->dwFlags & CP2_ALLOCMEMORY) )
        {
            FreeMemory( &pcmdparser->pValue );
        }
    }

    // ...
    SetReason( pwszReason );
    SetLastError( dwLastError );

    // return success
    return TRUE;
}


//
// public functions ... exposed to external world
//


BOOL DoParseParam2( DWORD dwCount,
                    LPCWSTR argv[],
                    LONG lSubOptionIndex,
                    DWORD dwOptionsCount,
                    PTCMDPARSER2 pcmdOptions,
                    DWORD dwReserved )
/*++
 Routine Description:


 Arguments: 
 

 Return Value:


--*/
{
    // local variables
    DWORD dw = 0;
    BOOL bUsage = FALSE;
    BOOL bResult = FALSE;
    DWORD dwIncrement = 0;
    LONG lIndex = 0;
    LONG lDefaultIndex = 0;
    LPCWSTR pwszValue = NULL;
    LPCWSTR pwszOption = NULL;
    LPCWSTR pwszUsageText = NULL;
    PTCMDPARSER2 pcmdparser = NULL;
    TMATCHOPTION_INFO matchoptioninfo;
    TPARSERSAVE_DATA parsersavedata;

    // clear the last error
    CLEAR_LAST_ERROR();

    // check the input value
    if ( dwCount == 0 || argv == NULL ||
         dwOptionsCount == 0 || pcmdOptions == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return FALSE;
    }

    // dwReserved should be 0 ( ZERO )
    if ( dwReserved != 0 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return FALSE;
    }

    // check for version compatibility
    if ( IsWin2KOrLater() == FALSE )
    {
        SetReason( ERROR_OS_INCOMPATIBLE );
        SetLastError( ERROR_OLD_WIN_VERSION );
        return FALSE;
    }

    // initialize the global data structure
    if ( InitGlobals() == FALSE )
    {
        SaveLastError();
        return FALSE;
    }

    // utility name retrieval block -- also, prepares the usage helper text
    // TYPE "<utility name> <option> -?" for usage."
    if ( lSubOptionIndex != -1 )
    {
        // validate the sub-option index value
        if ( lSubOptionIndex >= (LONG) dwOptionsCount )
        {
            INVALID_PARAMETER();
            SaveLastError();
            return FALSE;
        }

        // extract the main option
        pwszOption = ExtractMainOption( pcmdOptions[ lSubOptionIndex ].pwszOptions, 0 );
        if ( pwszOption == NULL )
        {
            SaveLastError();
            return FALSE;
        }
    }

    // prepare the usage helper text
    pwszUsageText = PrepareUsageHelperText( pwszOption );
    if ( pwszUsageText == NULL )
    {
        SaveLastError();
        return FALSE;
    }

    // verify the options information
    if ( VerifyParserOptions( &lDefaultIndex, dwOptionsCount, pcmdOptions ) == FALSE )
    {
        SaveLastError();
        return FALSE;
    }

    // Note: though the array starts at index 0 in C, the value at the array
    //       index 0 in a command line is the executable name ... so leave
    //       and parse the command line from the second parameter
    //       i.e; array index 1
    bUsage = FALSE;
    for( dw = 1; dw < dwCount; dw += dwIncrement )
    {
        // init
        dwIncrement = 2;
        pwszOption = argv[ dw ];
        pwszValue = ( (dw + 1) < dwCount ) ? argv[ dw + 1 ] : NULL;

        // find the appropriate the option match
        lIndex = MatchOption( dwOptionsCount, pcmdOptions, pwszOption );

        // check the result
        if ( lIndex == -1 )
        {
            // value might have specified along with the option
            // with ':' as seperator -- check that out
            lIndex = MatchOptionEx( dwOptionsCount,
                pcmdOptions, pwszOption, &matchoptioninfo );

            // check the result 
            if ( lIndex == -1 )
            {
                // option is not found - now check atleast 
                // default option is present or not -- if it is not found, then error
                if ( lDefaultIndex == -1 )
                {
                    SetReason2( 2, ERROR_INVALID_OPTION, pwszOption, pwszUsageText );
                    ReleaseAllocatedMemory( dwOptionsCount, pcmdOptions );
                    INVALID_SYNTAX();
                    return FALSE;
                }
                else
                {
                    // this should be default argument
                    lIndex = lDefaultIndex;

                    // since we know that the current argument
                    // is a default argumen 
                    // treat the option as value and option as NULL
                    pwszValue = pwszOption;
                    pwszOption = NULL;
                }
            }
            else
            {
                // option is matched -- it is seperated with ':'
                // so, extract the information from the structure
                pwszOption = matchoptioninfo.pwszOption;
                pwszValue = matchoptioninfo.pwszValue;
            }

            // since the value is in-directly specified along with the option 
            // (or as default) we need to process the next argument -- so, update the
            // incrementer accordingly
            dwIncrement = 1;
        }

        // ...
        pcmdparser = pcmdOptions + lIndex;

        // safety check
        if ( pcmdparser == NULL )
        {
            UNEXPECTED_ERROR();
            SaveLastError();
            return FALSE;
        }

        // scoop into the next argument which we are assuming as
        // as the value for the current -- but do this only if the
        // current option type needs that
        if ( pwszValue != NULL && dwIncrement == 2 )
        {
            if ( IsValueNeeded( pcmdparser->dwType ) == TRUE )
            {
                lIndex = MatchOption( dwOptionsCount, pcmdOptions, pwszValue );
                if ( lIndex == -1 )
                {
                    lIndex = MatchOptionEx( dwOptionsCount,
                        pcmdOptions, pwszValue, &matchoptioninfo );
                }

                // check the result
                if ( lIndex != -1 )
                {
                    // so, the next argument cannot be the value for this
                    // option -- so ...
                    pwszValue = NULL;
                    dwIncrement = 1;
                }
            }
            else
            {
                pwszValue = NULL;
                dwIncrement = 1;
            }
        }

        // update the parser data structure
        parsersavedata.pcmdparser = pcmdparser;
        parsersavedata.dwIncrement = dwIncrement;
        parsersavedata.lDefaultIndex = lDefaultIndex;
        parsersavedata.pwszUsageHelper = pwszUsageText;

        // try to save the data
        bResult = ParseAndSaveOptionValue( pwszOption, pwszValue, &parsersavedata );

        // get the increment value -- it might have changed by the data parser
        dwIncrement = parsersavedata.dwIncrement;

        // now check the result
        if (  bResult == FALSE )
        {
            // return
            ReleaseAllocatedMemory( dwOptionsCount, pcmdOptions );
            return FALSE;
        }

        // check the current option repetition trigger
        if ( pcmdparser->dwCount != 0 &&
             pcmdparser->dwCount == pcmdparser->dwActuals )
        {
            REASON_OPTION_REPEATED( pwszOption,
                pcmdparser->dwCount, pwszUsageText );
            ReleaseAllocatedMemory( dwOptionsCount, pcmdOptions );
            INVALID_SYNTAX();
            return FALSE;
        }

        // update the option repetition count
        pcmdparser->dwActuals++;

        // check if the usage option is choosed
        if ( pcmdparser->dwFlags & CP2_USAGE )
        {
            bUsage = TRUE;
        }
    }

    // atlast check whether the mandatory options has come or not
    // NOTE: checking of mandatory options will be done only if help is not requested
    if ( bUsage == FALSE )
    {
        for( dw = 0; dw < dwOptionsCount; dw++ )
        {
            // check whether the option has come or not if it is mandatory
            pcmdparser = pcmdOptions + dw;

            // safety check
            if ( pcmdparser == NULL )
            {
                UNEXPECTED_ERROR();
                SaveLastError();
                ReleaseAllocatedMemory( dwOptionsCount, pcmdOptions );
                return FALSE;
            }

            if ( (pcmdparser->dwFlags & CP2_MANDATORY) && pcmdparser->dwActuals == 0 )
            {
                //
                // mandatory option not exist ... fail

                // ...
                pwszOption = pcmdparser->pwszOptions;
                if ( pwszOption == NULL )
                {
                    if ( (pcmdparser->dwFlags & CP2_DEFAULT) == 0 )
                    {
                        UNEXPECTED_ERROR();
                        SaveLastError();
                        ReleaseAllocatedMemory( dwOptionsCount, pcmdOptions );
                        return FALSE;
                    }
                    else
                    {
                        pwszOption = pcmdparser->pwszFriendlyName;
                    }
                }
                else
                {
                    // check if user specified any friendly name for this option
                    if ( pcmdparser->pwszFriendlyName == NULL )
                    {
                        pwszOption = ExtractMainOption( pwszOption, 0 );
                        if ( pwszOption == NULL )
                        {
                            SaveLastError();
                            ReleaseAllocatedMemory( dwOptionsCount, pcmdOptions );
                            return FALSE;
                        }
                    }
                    else
                    {
                        pwszOption = pcmdparser->pwszFriendlyName;
                    }
                }

                // set the reason for the failure and return
                REASON_MANDATORY_OPTION_MISSING( pwszOption, pwszUsageText );
                ReleaseAllocatedMemory( dwOptionsCount, pcmdOptions );
                INVALID_SYNTAX();
                return FALSE;
            }
        }
    }

    // parsing complete -- success
    CLEAR_LAST_ERROR();
    return TRUE;
}


BOOL DoParseParam( DWORD dwCount,
                   LPCTSTR argv[],
                   DWORD dwOptionsCount,
                   PTCMDPARSER pcmdOptions )
/*++
 Routine Description:


 Arguments: 
 

 Return Value:


--*/
{
    // local variables
    DWORD dw = 0;
    BOOL bResult = FALSE;
    LONG lMainOption = -1;
    DWORD dwLastError = 0;
    LPCWSTR pwszReason = NULL;
    PTCMDPARSER pcmdparser = NULL;
    PTCMDPARSER2 pcmdparser2 = NULL;
    PTCMDPARSER2 pcmdOptions2 = NULL;

    // check the input
    if ( dwCount == 0 || argv == NULL ||
         dwOptionsCount == 0 || pcmdOptions == NULL )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return FALSE;
    }

    // allocate new structure
    pcmdOptions2 = (PTCMDPARSER2) AllocateMemory( dwOptionsCount * sizeof( TCMDPARSER2 ) );
    if ( pcmdOptions2 == NULL )
    {
        OUT_OF_MEMORY();
        SaveLastError();
        return FALSE;
    }

    // update the new structure with the data we have
    for( dw = 0; dw < dwOptionsCount; dw++ )
    {
        // version 1
        pcmdparser = pcmdOptions + dw;
        if ( pcmdparser == NULL )
        {
            UNEXPECTED_ERROR();
            SaveLastError();
            return FALSE;
        }

        // version 2
        pcmdparser2 = pcmdOptions2 + dw;
        if ( pcmdparser2 == NULL )
        {
            UNEXPECTED_ERROR();
            SaveLastError();
            return FALSE;
        }

        // copy the signature
        StringCopyA( pcmdparser2->szSignature,
            cszParserSignature, SIZE_OF_ARRAY( pcmdparser2->szSignature ) );

        // first init the version 2 structure with defaults (except signature)
        pcmdparser2->dwType = 0;
        pcmdparser2->dwFlags = 0;
        pcmdparser2->dwCount = 0;
        pcmdparser2->dwActuals = 0;
        pcmdparser2->pwszOptions = NULL;
        pcmdparser2->pwszFriendlyName = NULL;
        pcmdparser2->pwszValues = NULL;
        pcmdparser2->pValue = NULL;
        pcmdparser2->pFunction = NULL;
        pcmdparser2->pFunctionData = NULL;
        pcmdparser2->dwReserved = 0;
        pcmdparser2->pReserved1 = NULL;
        pcmdparser2->pReserved2 = NULL;
        pcmdparser2->pReserved3 = NULL;

        //
        // option information
        pcmdparser2->pwszOptions = pcmdparser->szOption;

        //
        // value information
        pcmdparser2->pValue = pcmdparser->pValue;

        //
        // type information
        pcmdparser2->dwType = (pcmdparser->dwFlags & CP_TYPE_MASK);
        if ( pcmdparser2->dwType == 0 )
        {
            // NONE
            // this is how BOOLEAN type is specified in version 1
            pcmdparser2->dwType = CP_TYPE_BOOLEAN;
        }

        //
        // length information
        if ( pcmdparser2->dwType == CP_TYPE_TEXT )
        {
            // MAX_STRING_LENGTH is what users assumed
            // as maximum length allowed
            pcmdparser2->dwLength = MAX_STRING_LENGTH;
        }

        //
        // option values
        if ( pcmdparser->dwFlags & CP_MODE_VALUES )
        {
            pcmdparser2->pwszValues = pcmdparser->szValues;
        }

        //
        // count
        pcmdparser2->dwCount = pcmdparser->dwCount;

        //
        // function
        if ( pcmdparser2->dwType == CP_TYPE_CUSTOM )
        {
            //
            // we play bit trick here
            // since the prototype of call back function for version 2 is
            // changed, we can't pass the version 1 prototype directly to
            // the version 2 -- to handle this special case, we will write
            // intermediate function as part of this migration which will
            // act a stub and pass the version 1 structure as data parameter to
            // the version 2 structure
            pcmdparser2->pFunction = Parser1FromParser2Stub;
            pcmdparser2->pFunctionData = pcmdparser;

            // if the "version 1" structure has its data as NULL
            // assign it as its own -- that is how "version 1" used to do
            if ( pcmdparser->pFunctionData == NULL )
            {
                pcmdparser->pFunctionData = pcmdparser;
            }
        }

        //
        // flags
        // CP_VALUE_MANDATORY, CP_IGNOREVALUE flags are discarded
        if ( pcmdparser->dwFlags & CP_MODE_ARRAY )
        {
            pcmdparser2->dwFlags |= CP2_MODE_ARRAY;
        }

        if ( pcmdparser->dwFlags & CP_MODE_VALUES )
        {
            pcmdparser2->dwFlags |= CP2_MODE_VALUES;
        }

        if ( pcmdparser->dwFlags & CP_VALUE_OPTIONAL )
        {
            pcmdparser2->dwFlags |= CP2_VALUE_OPTIONAL;
        }

        if ( pcmdparser->dwFlags & CP_VALUE_NODUPLICATES )
        {
            pcmdparser2->dwFlags |= CP2_VALUE_NODUPLICATES;
        }

        if ( pcmdparser->dwFlags & CP_VALUE_NOLENGTHCHECK )
        {
            // actually, in "version 2" this is flag is discarded
            // but make sure that the type for this flag is specified
            // with data type as custom (or) mode array
            if ( ( pcmdparser2->dwType != CP_TYPE_CUSTOM ) &&
                 ( pcmdparser2->dwFlags & CP2_MODE_ARRAY ) == 0 )
            {
                INVALID_PARAMETER();
                SaveLastError();
                return FALSE;
            }
        }

        if ( pcmdparser->dwFlags & CP_MAIN_OPTION )
        {
            // the functionality of this flag is handled differently
            // in "version 2" -- so memorize the index of the current option
            lMainOption = dw;
        }

        if ( pcmdparser->dwFlags & CP_USAGE )
        {
            pcmdparser2->dwFlags |= CP2_USAGE;
        }

        if ( pcmdparser->dwFlags & CP_DEFAULT )
        {
            pcmdparser2->dwFlags |= CP2_DEFAULT;
        }

        if ( pcmdparser->dwFlags & CP_MANDATORY )
        {
            pcmdparser2->dwFlags |= CP2_MANDATORY;
        }

        if ( pcmdparser->dwFlags & CP_CASESENSITIVE )
        {
            pcmdparser2->dwFlags |= CP2_CASESENSITIVE;
        }
    }

    // "version 2" structure is ready to use --
    // call the "version 2" of parser
    bResult = DoParseParam2( dwCount, argv, lMainOption,
                             dwOptionsCount, pcmdOptions2, 0 );

    // update the "version 1" structure with "version 2" structure data
    for( dw = 0; dw < dwOptionsCount; dw++ )
    {
        // version 1
        pcmdparser = pcmdOptions + dw;
        if ( pcmdparser == NULL )
        {
            UNEXPECTED_ERROR();
            SaveLastError();
            return FALSE;
        }

        // version 2
        pcmdparser2 = pcmdOptions2 + dw;
        if ( pcmdparser2 == NULL )
        {
            UNEXPECTED_ERROR();
            SaveLastError();
            return FALSE;
        }

        // update the actuals
        pcmdparser->dwActuals = pcmdparser2->dwActuals;
    }

    // release the memory that is allocated for "version 2" structure
    // but since the "FreeMemory" will clear the last error
    // we need to save that information before releasing the memory
    dwLastError = GetLastError();
    pwszReason = GetParserTempBuffer( 0, GetReason(), 0, FALSE );

    // now free the memory
    FreeMemory( &pcmdOptions2 );

    // now, check whether we successfully saved the last error or not
    // if not, return out of memory
    if ( pwszReason != NULL )
    {
        SetReason( pwszReason );
        SetLastError( dwLastError );
    }
    else
    {
        bResult = FALSE;
        OUT_OF_MEMORY();
        SaveLastError();
    }

    // return
    return bResult;
}


LONG GetOptionCount( LPCWSTR pwszOption, 
                     DWORD dwCount, 
                     PTCMDPARSER pcmdOptions )
/*++
 Routine Description:


 Arguments: 
 

 Return Value:


--*/
{
    // local variables
    DWORD dw;
    PTCMDPARSER pcp = NULL;

    // check the input value
    if ( pwszOption == NULL || pcmdOptions == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return -1;
    }

    // traverse thru the loop and find out how many times, the option has repeated at cmd prompt
    for( dw = 0; dw < dwCount; dw++ )
    {
        // get the option information and check whether we are looking for this option or not
        // if the option is matched, return the no. of times the option is repeated at the command prompt
        pcp = pcmdOptions + dw;
        if ( StringCompare( pcp->szOption, pwszOption, TRUE, 0 ) == 0 )
            return pcp->dwActuals;
    }

    // this will / shouldn't occur
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\lib\pch.h ===
// *********************************************************************************
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//
//    pch.h
//
//  Abstract:
//
//    This module is a precompiled header file for the common functionality
//
//  Author:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 1-Sep-2000
//
//  Revision History:
//
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 1-Sep-2000 : Created It.
//
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef __cplusplus
extern "C" {
#endif

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <Security.h>
#include <SecExt.h>
#include <shlwapi.h>

//
// public Windows header files
//
#include <tchar.h>
#include <windows.h>
#include <winsock2.h>
#include <lm.h>
#include <io.h>
#include <limits.h>
#include <strsafe.h>

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <errno.h>

//
// private headers
// 
#include "cmdlineres.h"
#include "cmdline.h"

//
// externs
//
extern BOOL g_bInitialized;

//
// custom purpose macros
//
#define CLEAR_LAST_ERROR()                          \
    SetLastError( NO_ERROR );                       \
    1

#define OUT_OF_MEMORY()                             \
    if ( GetLastError() == NO_ERROR )               \
    {                                               \
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );    \
    }                                               \
    1

#define INVALID_PARAMETER()                         \
    if ( GetLastError() == NO_ERROR )               \
    {                                               \
        SetLastError( ERROR_INVALID_PARAMETER );    \
    }                                               \
    1

#define UNEXPECTED_ERROR()                          \
    if ( GetLastError() == NO_ERROR )               \
    {                                               \
        SetLastError( ERROR_PROCESS_ABORTED );      \
    }                                               \
    1

#define INVALID_SYNTAX()                            \
    SetLastError( (DWORD) MK_E_SYNTAX );            \
    1

//
// internal functions
//
LPWSTR GetInternalTemporaryBufferRef( IN DWORD dwIndexNumber );
LPWSTR GetInternalTemporaryBuffer( DWORD dwIndexNumber, 
                                   LPCWSTR pwszText,
                                   DWORD dwLength, BOOL bNullify );

//
// temporary buffer index start positions -- file wise
#define INDEX_TEMP_CMDLINE_C            0
#define TEMP_CMDLINE_C_COUNT            7

#define INDEX_TEMP_CMDLINEPARSER_C      (INDEX_TEMP_CMDLINE_C + TEMP_CMDLINE_C_COUNT)
#define TEMP_CMDLINEPARSER_C_COUNT      6

#define INDEX_TEMP_RMTCONNECTIVITY_C    (INDEX_TEMP_CMDLINEPARSER_C + TEMP_CMDLINEPARSER_C_COUNT)
#define TEMP_RMTCONNECTIVITY_C_COUNT    6

#define INDEX_TEMP_SHOWRESULTS_C        (INDEX_TEMP_RMTCONNECTIVITY_C + TEMP_RMTCONNECTIVITY_C_COUNT)
#define TEMP_SHOWRESULTS_C_COUNT        4

#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\lib\filterresults.c ===
/**********************************************************************************

 Copyright (c) Microsoft Corporation

 Module Name:

    FilterResults.c

 Abstract:

 This modules  has functions which are  required to parse Command Line options.

 Author:

  G.V.N.Murali Sunil

 Revision History:

   None


 **********************************************************************************/

#include "pch.h"
#include "cmdline.h"

//
//  constants / definitions / enumerations
//

#define OPERATOR_DELIMITER      _T( "|" )
#define CHAR_ASTERISK           _T( '*' )

#define OPERATOR_EQ         _T( "=| eq " )
#define OPERATOR_NE         _T( "!=| ne " )
#define OPERATOR_GT         _T( ">| gt " )
#define OPERATOR_LT         _T( "<| lt " )
#define OPERATOR_GE         _T( ">=| ge " )
#define OPERATOR_LE         _T( "<=| le " )


//
// private user-defined types ... for internal usage only
//
typedef struct ___tagOperator
{
    DWORD dwMask;
    OPERATORS szOperator;
} TOPERATOR;

typedef TOPERATOR* PTOPERATOR;

//
// private functions ... used only within this file
//

/***************************************************************************
 Routine Description:

 Arguments:
     [ in ] dwCount:
     [ in ] optInfo[]:
     [ in ] szOperator:


 Return Value:


***************************************************************************/
DWORD
__FindOperatorMask(
                    IN DWORD dwCount,
                    IN OUT TOPERATOR optInfo[],
                    IN LPCTSTR szOperator
                   )
/*++
 Routine Description:
      Finds operator mask

 Arguments:
           [IN]      dwCount      : number of characters
           [IN]      optInfo      : Array of operator structure
           [IN]      szOperator    : Seperator

 Return Value:
       FALSE    :   On failure
       TRUE     :   On success
--*/
{
    // local variables
    DWORD dw = 0;   // looping variable

    // check the input value
    if ( optInfo == NULL || szOperator == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return 0;
    }

    // traverse thru the list of operators list
    for( dw = 0; dw < dwCount; dw++ )
    {
        // check whether the current operator information matches
        if ( InString( szOperator, optInfo[ dw ].szOperator, TRUE ) )
            return optInfo[ dw ].dwMask;        // operator matched ... return its mask
    }

    // operator not found
    return 0;
}

DWORD
__StringCompare(
                IN LPCTSTR szValue1,
                IN LPCTSTR szValue2,
                IN BOOL bIgnoreCase,
                IN LONG lCount
                )
/*++
 Routine Description:
    Compares Two Strings in two ways  with and without case sensitivily,

 Arguments:
  [ in ] szValue1 = First String
  [ in ] szValue2 = Second String
  [ in ] bIgnoreCase = Case Sensitivity or not
  [ in ] lCount = no. of characters to be compare


 Return Value:

     MASK_EQ - if both strings are equal
     MASK_LT - First string is less
     MASK_GT - Second String is less
--*/
{
    // local variables
    LONG lResult = 0;           // hold the string comparision result

    // check the input value
    if ( szValue1 == NULL || szValue2 == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return 0;
    }

    // if the no. of characters that needs to checked is -1, just return
    if ( lCount == -1 )
        return MASK_ALL;        // that strings are equal

    // compare the two strings and get the result of comparision
    lResult = StringCompare( szValue1, szValue2, bIgnoreCase, lCount );

    //
    // now determine the result value
    if ( lResult == 0 )
        return MASK_EQ;
    else if ( lResult < 0 )
        return MASK_LT;
    else if ( lResult > 0 )
        return MASK_GT;

    // never come across this situation ... still
    return 0;
}

DWORD
__LongCompare(
                    IN LONG lValue1,
                    IN LONG lValue2
              )
/*++
 Routine Description:
      compares two long data type values

 Arguments:
      [ in ] lvalue1: First  value
      [ in ] lvalue2: Second  Value

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    //
    // determine the result value
    if ( lValue1 == lValue2 )
        return MASK_EQ;
    else if ( lValue1 < lValue2 )
        return MASK_LT;
    else if ( lValue1 > lValue2 )
        return MASK_GT;

    // never come across this situation ... still
    return 0;
}

DWORD
__DWORDCompare(
                IN DWORD dwValue1,
                IN DWORD dwValue2
               )
/*++
 Routine Description:
      compares two DWORD data type values

 Arguments:
      [ in ] dwValue1: First  value
      [ in ] dwValue2: Second  Value

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    //
    // determine the result value
    if ( dwValue1 == dwValue2 )
        return MASK_EQ;
    else if ( dwValue1 < dwValue2 )
        return MASK_LT;
    else if ( dwValue1 > dwValue2 )
        return MASK_GT;

    // never come across this situation ... still
    return 0;
}

DWORD
__FloatCompare(
                        IN float fValue1,
                        IN float fValue2
               )
/*++
 Routine Description:
      compares two float data type values

 Arguments:
      [ in ] fValue1: First  value
      [ in ] fValue2: Second  Value

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    //
    // determine the result value
    if ( fValue1 == fValue2 )
        return MASK_EQ;
    else if ( fValue1 < fValue2 )
        return MASK_LT;
    else if ( fValue1 > fValue2 )
        return MASK_GT;

    // never come across this situation ... still
    return 0;
}


DWORD
__DoubleCompare(
                   IN double dblValue1,
                   IN double dblValue2
                )
/*++
 Routine Description:
      compares two double data type values

 Arguments:
      [ in ] dblValue1: First  value
      [ in ] dblValue2: Second  Value

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    //
    // determine the result value
    if ( dblValue1 == dblValue2 )
        return MASK_EQ;
    else if ( dblValue1 < dblValue2 )
        return MASK_LT;
    else if ( dblValue1 > dblValue2 )
        return MASK_GT;

    // never come across this situation ... still
    return 0;
}

DWORD
__DateCompare(
                IN LPCTSTR szValue1,
                IN LPCTSTR szValue2
              )
/*++
 Routine Description:
      compares two date  data type values

 Arguments:
      [ in ] szValue1: First  value
      [ in ] szValue2: Second  Value

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    // check the input value
    if ( szValue1 == NULL || szValue2 == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return 0;
    }

    // never come across this situation ... still
    return 0;
}


DWORD
__TimeCompare(
                IN LPCTSTR szValue1,
                IN LPCTSTR szValue2
             )
/*--
 Routine Description:
      compares two time data type values

 Arguments:
      szValue1: First  value
      szValue2: Second  Value

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    // check the input value
    if ( szValue1 == NULL || szValue2 == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return 0;
    }

    // never come across this situation ... still
    return 0;
}


DWORD
__DateTimeCompare(
                    IN LPCTSTR szValue1,
                    IN LPCTSTR szValue2
                 )
/*++
 Routine Description:
      compares two date+time  data type values

 Arguments:
      [ in ] szValue1: First  value
      [ in ] szValue2: Second  Value

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    // check the input value
    if ( szValue1 == NULL || szValue2 == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return 0;
    }

    // never come across this situation ... still
    return 0;
}

DWORD
__DoComparision(
                   IN TARRAY arrRecord,
                   IN TARRAY arrFilter,
                   IN TFILTERCONFIG filter
               )
/*++
 Routine Description:
      compares value stored in arrRecords and arrFilter array depending on
      filterConfig structure

 Arguments:
      [ in ] arrRecord: First  value
      [ in ] arrFilter: Second  Value
      [ in ] filterConfig: Compare criteria.

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    // local variables
    LONG lLength = 0;                   // used for pattern matched strings
    LPTSTR pszTemp = NULL;
    DWORD dwCompareResult = 0;
    __MAX_SIZE_STRING szValue = NULL_STRING;

    // variables used for comparision
    LONG lValue1 = 0, lValue2 = 0;
    DWORD dwValue1 = 0, dwValue2 = 0;
    float fValue1 = 0.0f, fValue2 = 0.0f;
    double dblValue1 = 0.0f, dblValue2 = 0.0f;
    LPCTSTR pszValue1 = NULL, pszValue2 = NULL;
    LPCTSTR pszProperty = NULL, pszOperator = NULL, pszValue = NULL;

    // check the input value
    if ( arrRecord == NULL || arrFilter == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return 0;
    }

    // do the comparision
    switch( filter.dwFlags & F_TYPE_MASK )
    {
    case F_TYPE_TEXT:
        {
            //
            // string comparision

            // get the value at the specified column and filter value
            pszValue1 = DynArrayItemAsString( arrRecord, filter.dwColumn );
            pszValue2 = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );

            // check the values we got from the dynamic array
            if ( pszValue1 == NULL || pszValue2 == NULL )
                return F_RESULT_REMOVE;

            // determine the length of the string that has to be compared
            lLength = 0;
            if ( filter.dwFlags & F_MODE_PATTERN )
            {
                // needs to do the pattern matching
                // identify till which part string should be compared
                StringCopy( szValue, pszValue2, MAX_STRING_LENGTH );
                pszTemp = _tcschr( szValue, CHAR_ASTERISK );
                if ( pszTemp != NULL )
                {
                    lLength = lstrlen( szValue ) - lstrlen( pszTemp );

                    // special case:
                    // if the pattern is just asterisk, which means that all the
                    // information needs to passed thru the filter
                    if ( lLength == 0 )
                        lLength = -1;       // match all values
                }
            }

            // do the comparision and get the result
            dwCompareResult = __StringCompare( pszValue1, pszValue2, TRUE, lLength );

            // break from the switch case
            break;
        }

    case F_TYPE_NUMERIC:
        {
            //
            // numeric comparision

            // get the value into buffer - PREFIX PURPOSE
            pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
            if ( pszValue == NULL )
                return 0;

            // get the value at the specified column and filter value
            lValue1 = DynArrayItemAsLong( arrRecord, filter.dwColumn );
            lValue2 = AsLong( pszValue, 10 );

            // do the comparision and get the result
            dwCompareResult = __LongCompare( lValue1, lValue2 );

            // break from the switch case
            break;
        }

    case F_TYPE_UNUMERIC:
        {
            //
            // unsigned numeric comparision

            // get the value into buffer - PREFIX PURPOSE
            pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
            if ( pszValue == NULL )
                return 0;

            // get the value at the specified column and filter value
            dwValue1 = DynArrayItemAsLong( arrRecord, filter.dwColumn );
            dwValue2 = (DWORD) AsLong( pszValue, 10 );

            // do the comparision and get the result
            dwCompareResult = __DWORDCompare( dwValue1, dwValue2 );

            // break from the switch case
            break;
        }

    case F_TYPE_DATE:
    case F_TYPE_TIME:
    case F_TYPE_DATETIME:
        {
            // not yet implemented
            dwCompareResult = F_RESULT_KEEP;

            // break from the switch case
            break;
        }

    case F_TYPE_FLOAT:
        {
            //
            // float comparision

            // get the value into buffer - PREFIX PURPOSE
            pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
            if ( pszValue == NULL )
                return 0;

            // get the value at the specified column and filter value
            fValue1 = DynArrayItemAsFloat( arrRecord, filter.dwColumn );
            fValue2 = (float) AsFloat( pszValue );

            // do the comparision and get the result
            dwCompareResult = __FloatCompare( fValue1, fValue2 );

            // break from the switch case
            break;
        }

    case F_TYPE_DOUBLE:
        {
            //
            // double comparision

            // get the value into buffer - PREFIX PURPOSE
            pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
            if ( pszValue == NULL )
                return 0;

            // get the value at the specified column and filter value
            dblValue1 = DynArrayItemAsDouble( arrRecord, filter.dwColumn );
            dblValue2 = AsFloat( pszValue );

            // do the comparision and get the result
            dwCompareResult = __DoubleCompare( dblValue1, dblValue2 );

            // break from the switch case
            break;
        }

    case F_TYPE_CUSTOM:
        {
            //
            // custom comparision

            // get the filter values
            pszProperty = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_PROPERTY );
            pszOperator = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_OPERATOR );
            pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );

            // check ...
            if ( pszProperty == NULL || pszOperator == NULL || pszValue == NULL )
                return 0;

            // call the custom function
            dwCompareResult = (filter.pFunction)( pszProperty, pszOperator, pszValue,
                filter.pFunctionData == NULL ? &filter : filter.pFunctionData, arrRecord );

            // break from the switch case
            break;
        }

    default:
        {
            // not yet implemented
            dwCompareResult = F_RESULT_KEEP;

            // break from the switch case
            break;
        }
    }

    // return the result
    return dwCompareResult;
}


DWORD
__DoArrayComparision(
                        IN TARRAY arrRecord,
                        IN TARRAY arrFilter,
                        IN TFILTERCONFIG filterConfig
                    )
/*++
 Routine Description:
      compares two arrays

 Arguments:
      [ in ] arrRecord: First  Value
      [ in ] arrFilter: Second  Value
      [ in ] filterConfig: Comperison Criteria

 Return Value:
       MASK_EQ: both are equal
       MASK_LT: First is less than second
       MASK_GT: First is geater than second
--*/
{
    // local variables
    LONG lIndex = 0;
    LONG lLength = 0;                   // used for pattern matched strings
    DWORD dwCompareResult = 0;
    LPCTSTR pszTemp = NULL;
    __MAX_SIZE_STRING szValue = NULL_STRING;

    // variables used for comparision
    TARRAY arrValues = NULL;
    LPCTSTR pszFilterValue = NULL;

    // check the input value
    if ( arrRecord == NULL || arrFilter == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return F_RESULT_REMOVE;
    }

    // array data in the record
    arrValues = DynArrayItem( arrRecord, filterConfig.dwColumn );
    if ( arrValues == NULL )
        return F_RESULT_REMOVE;

    switch( filterConfig.dwFlags & F_TYPE_MASK )
    {
    case F_TYPE_TEXT:
        {
            //
            // string comparision

            // get the value at the specified column and filter value
            pszFilterValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
            if ( pszFilterValue == NULL )
                return F_RESULT_REMOVE;

            // determine the length of the string that has to be compared
            lLength = 0;
            if ( filterConfig.dwFlags & F_MODE_PATTERN )
            {
                // needs to do the pattern matching
                // identify till which part string should be compared
                StringCopy( szValue, pszFilterValue, MAX_STRING_LENGTH );
                pszTemp = _tcschr( szValue, CHAR_ASTERISK );
                if ( pszTemp != NULL )
                {
                    lLength = lstrlen( szValue ) - lstrlen( pszTemp );

                    // special case:
                    // if the pattern is just asterisk, which means that all the
                    // information needs to passed thru the filter
                    if ( lLength == 0 )
                        lLength = -1;       // match all values
                }
            }

            // do the comparision and get the result
            if ( lLength == -1 )
            {
                // filter has to be passed
                dwCompareResult = MASK_ALL;
            }
            else
            {
                // find the string in the array and check the result
                lIndex = DynArrayFindString( arrValues, pszFilterValue, TRUE, lLength );
                if ( lIndex == -1 )
                {
                    // value not found
                    dwCompareResult = MASK_NE;
                }
                else
                {
                    pszTemp = DynArrayItemAsString( arrValues, lIndex );
                    if ( pszTemp == NULL )
                        return F_RESULT_REMOVE;

                    // comparision ...
                    dwCompareResult = __StringCompare(pszTemp, pszFilterValue, TRUE, lLength);
                }
            }

            // break from the switch case
            break;
        }
    }

    // return the result
    return dwCompareResult;
}

VOID
__PrepareOperators(
                    IN DWORD dwCount,
                    IN PTFILTERCONFIG pfilterConfigs,
                    OUT TARRAY arrOperators
                  )
/*++
 Routine Description:
    Prepares a two dimensional array(arrOperators)based on Operator information
    supplied with pfilterConfigs variable

 Arguments:
      [ in]  dwCount          =  No. of operatores
      [ in]  pfilterConfigs   =  Pointer to TFILTERCONFIG structure
      [out]  arrOperators     =  Array of operators.

 Return Value:
      NONE
--*/
{
    // local variables
    DWORD i = 0;                            // looping varible
    LONG lIndex = 0;                        // holds the result of find operation
    LPTSTR pszOperator = NULL;              // operator specified in filter
    PTFILTERCONFIG pFilter = NULL;          // temporary filter configuration
    __MAX_SIZE_STRING szTemp = NULL_STRING; // temporary string buffer

    // check the input value
    if ( pfilterConfigs == NULL || arrOperators == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return;
    }

    // NOTE:- Here in this logic, we are compromising on the memory Vs time
    //        At the cost of using more memory, the time taken by the validating
    //        functionality is improved.
    //

    // collect all the operators that are supported and save them in the local array
    // Idea:-
    //      => This is a two-dimensional array
    //      => In all rows, the first column will have the operator
    //      => operator column is followed by the index of the filter property supporting
    //         this operator, and this column is followed by filter property name
    //      => This filter property index and its name's can be any number
    //      => The operator is being treated as key field in the array
    //
    // SAMPLE:
    //      0       1   2           3   4           5   6
    //      -------------------------------------------------------------------
    //      =       1   property1   2   property2
    //      !=      0   property0   2   property2
    //      <=      0   property0   3   property3
    //      >=      1   property1   3   property3   4   property4
    //
    for( i = 0; i < dwCount; i++ )
    {
        // get the filter info at the specified index into local memory
        pFilter = pfilterConfigs + i;

        // collect operators and prepare with all the available operators
        StringCopy( szTemp, pFilter->szOperators, MAX_STRING_LENGTH );  // IMP. get the local copy.
        pszOperator = _tcstok( szTemp, OPERATOR_DELIMITER );    // get the first token
        while ( pszOperator != NULL )
        {
            // check whether this operator exists in the operators array
            lIndex = DynArrayFindStringEx( arrOperators, 0, pszOperator, TRUE, 0 );
            if ( lIndex == -1 )
            {
                //
                // operator is not in the list

                // add the new operator to the list and set the index to the row added
                // for this operator
                lIndex = DynArrayAppendRow( arrOperators, 0 );
                if ( lIndex == -1 )
                    return;

                // now add the operator as the first column to the newly added row
                DynArrayAppendString2( arrOperators, lIndex, pszOperator, 0 );
            }

            // add the filter property info and its index to the operator row
            DynArrayAppendLong2( arrOperators, lIndex, i );
            DynArrayAppendString2( arrOperators, lIndex, pFilter->szProperty, 0 );

            // fetch the next token
            pszOperator = _tcstok( NULL, OPERATOR_DELIMITER );
        }
    }
}


BOOL
__CheckValue(
                IN TFILTERCONFIG fcInfo,
                IN LPCTSTR pszProperty,
                IN LPCTSTR pszOperator,
                IN LPCTSTR pszValue
            )
/*++
 Routine Description:
      Checks the type of pszValue string for the criteria given by fcInfo
      filters.

 Arguments:
      [ in ]  fcInfo =   filter stucture.
      [ in ]  pszProperty = property string
      [ in ]  pszOperator = operator
      [ in ]  pszValue = string to be checked

 Return Value:
       TRUE =   valid line
       FALSE =  not a valid line
--*/
{
    // local variables
    DWORD dwResult = 0;
    LPTSTR pszTemp = NULL;
    __MAX_SIZE_STRING szValue = NULL_STRING;

    // check the input value
    if ( pszProperty == NULL || pszOperator == NULL || pszValue == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return FALSE;
    }

    // check the length of the value string ... it should not be empty
    if ( lstrlen( pszValue ) == 0 )
        return FALSE;       // value string is empty

    // start validating the data
    switch( fcInfo.dwFlags & F_TYPE_MASK )
    {
    case F_TYPE_TEXT:
        {
            // check if the pattern is supported
            // if supported, see the '*' is appearing only at the end. if not error
            if ( fcInfo.dwFlags & F_MODE_PATTERN )
            {
                // copy the current value to the local buffer
                StringCopy( szValue, pszValue, MAX_STRING_LENGTH );

                // search for the wild card character
                pszTemp = _tcschr( szValue, CHAR_ASTERISK );

                // if the wild card character was found and if it is not the last character
                // (or) wild card is the only character specified, then invalid filter
                if ( pszTemp != NULL && ( lstrlen( pszTemp ) != 1 || pszTemp == szValue ) )
                    return FALSE;       // error ... invalid pattern string
            }

            // for all these types, no need to do any special checking
            // provided, they need not be checked with the list of values
            if ( ! ( fcInfo.dwFlags & F_MODE_VALUES ) )
                return TRUE;            // no special validation

            // check for the value in the list and return the result
            return ( InString( pszValue, fcInfo.szValues, TRUE ) );

            // break from the switch
            break;
        }

    case F_TYPE_NUMERIC:
        {
            // if the value is not of numeric type, invalid value
            if ( ! IsNumeric( pszValue, 10, TRUE ) )
                return FALSE;

            // check for the value in the list and return the result
            // if values are pre-defined
            if ( fcInfo.dwFlags & F_MODE_VALUES )
                return ( InString( fcInfo.szValues, pszValue, TRUE ) );

            // value is valid
            return TRUE;

            // break from the switch
            break;
        }

    case F_TYPE_UNUMERIC:
        {
            // if the value is not of unsigned numeric type, invalid value
            if ( ! IsNumeric( pszValue, 10, FALSE ) )
                return FALSE;

            // check for the value in the list and return the result
            // if values are pre-defined
            if ( fcInfo.dwFlags & F_MODE_VALUES )
                return ( InString( fcInfo.szValues, pszValue, TRUE ) );

            // value is valid
            return TRUE;

            // break from the switch
            break;
        }

    case F_TYPE_FLOAT:
    case F_TYPE_DOUBLE:
        {
            // NOTE: Values attribute is ignored for this data type

            // return the result of the type validation function itself
            return ( IsFloatingPoint( pszValue ) );

            // break from the switch
            break;
        }

    case F_TYPE_DATE:
    case F_TYPE_TIME:
    case F_TYPE_DATETIME:
        {
            // break from the switch
            break;
        }

    case F_TYPE_CUSTOM:
        {
            // check whether function pointer is specified or not
            // if not specified, error
            if ( fcInfo.pFunction == NULL )
                return FALSE;       // function ptr not specified ... error

            // call the custom function
            dwResult = (*fcInfo.pFunction)( pszProperty, pszOperator, pszValue,
                fcInfo.pFunctionData == NULL ? &fcInfo : fcInfo.pFunctionData, NULL );

            // check the result and return appropriately
            if ( dwResult == F_FILTER_INVALID )
                return FALSE;
            else
                return TRUE;

            // break from the switch
            break;
        }

    default:
        {
            // invalid configuration information
            return FALSE;

            // break from the switch
            break;
        }
    }

    // not a valid value
    return FALSE;
}


LONG
__IdentifyFilterConfig(
                        IN LPCTSTR szFilter,
                        IN TARRAY arrOperators,
                        IN PTFILTERCONFIG pfilterConfigs,
                        IN LPTSTR pszProperty,
                        IN LPTSTR pszOperator,
                        IN LPTSTR pszValue )
/*++
 Routine Description:
 Gets the filter configuration index

 Arguments:
      [ in] szFilter = filter
      [  in ] arrOperators = Array of Operators
      [  in ] pfilterConfigs = filter configurations
      [ in  ] pszProperty =property
      [ in  ] pszOperator = operator
      [  in ] pszValue - value

 Return Value: Returns a long value
--*/
{
    // local variables
    DWORD dw = 0;                           // looping variable
    LONG lPosition = 0;                     // used to result of 'find' function
    LONG lIndex = 0;
    DWORD dwOperators = 0;                  // holds the count of operators supported
    LPTSTR pszBuffer = NULL;
    __MAX_SIZE_STRING szTemp = NULL_STRING; // temporary string buffer
    __MAX_SIZE_STRING szFmtFilter = NULL_STRING;
    __MAX_SIZE_STRING szFmtOperator = NULL_STRING;

    // check the input value
    if ( szFilter == NULL || arrOperators == NULL || pfilterConfigs == NULL ||
         pszProperty == NULL || pszOperator == NULL || pszValue == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return -1;
    }

    // get the filter info into local format buffer and change the case
    StringCopy( szFmtFilter, szFilter, MAX_STRING_LENGTH );
    CharUpper( szFmtFilter );

    // initially assume the filter is unknown and set the message
    SetLastError( ERROR_DS_FILTER_UNKNOWN );
    SaveLastError();

    // traverse thru the list of operators available and check
    // whether the filter is having any of the supported operator
    dwOperators = DynArrayGetCount( arrOperators );     // no. of operators supported
    for( dw = 0; dw < dwOperators; dw++ )
    {
        // get the operator
        pszBuffer = ( LPTSTR ) DynArrayItemAsString2( arrOperators, dw, 0 );
        if ( pszBuffer == NULL )
        {
            UNEXPECTED_ERROR();
            SaveLastError();
            return -1;
        }

        // ...
        StringCopy( pszOperator, pszBuffer, MAX_STRING_LENGTH );
        StringCopy( szFmtOperator, pszOperator, MAX_STRING_LENGTH );      // also get the operator
        CharUpper( szFmtOperator );                 // into format buffer and chane the case

        // search for the current operator in the filter
        // check whether the operator was found or not
        // before processing, copy to the temp buffer and do manipulations on that
        StringCopy( szTemp, szFmtFilter, MAX_STRING_LENGTH );
        if ( ( pszBuffer = _tcsstr( szTemp, szFmtOperator ) ) != NULL )
        {
            //
            // operator was found

            // extract the property, and value information
            // => property name
            //    ( total length of the string -  position where the operator starts )
            // => value
            //    ( start position of operator + length of operator )
            szTemp[ lstrlen( szTemp ) - lstrlen( pszBuffer ) ] = NULL_CHAR;
            StringCopy( pszProperty, szTemp, MAX_STRING_LENGTH );

            // value might not have specified at all ... so be careful
            if ( (pszBuffer + lstrlen(pszOperator)) != NULL )
            {
                // copy the value part
                StringCopy( pszValue, (pszBuffer + lstrlen(pszOperator)), MAX_STRING_LENGTH );

                //
                // now cross-check whether the property name exists or not for the current
                // operator.

                // remove the leading and trailing spaces ( if any )
                // in the property name and value
                StringCopy( pszValue, TrimString( pszValue, TRIM_ALL ), MAX_STRING_LENGTH );
                StringCopy( pszProperty, TrimString( pszProperty, TRIM_ALL ), MAX_STRING_LENGTH );

                // check whether this property exists or not
                // if found, return to the caller, else continue furthur
                // this might match with some with some other operator
                lPosition = DynArrayFindString2( arrOperators, dw, pszProperty, TRUE, 0 );
                if ( lPosition > 1 )
                {
                    // NOTE:
                    // we know that the property name if exist, starts from index number
                    // 2 only that is the reason why, the condition is > 1 is only valid

                    // get the corresponding filter config. info
                    lIndex = DynArrayItemAsLong2( arrOperators, dw, lPosition - 1 );

                    // now check whether the filter is having appropriate value
                    if ( __CheckValue( pfilterConfigs[ lIndex ], pszProperty, pszOperator, pszValue) )
                    {
                        //
                        // filter is having valid value
                        SetLastError( NOERROR );
                        SetReason( NULL_STRING );

                        // return the filter configuration index
                        return lIndex;
                    }
                }
            }
        }
    }

    // filter is not valid
    return -1;
}

//
// public functions ... exposed to external world
//


BOOL
ParseAndValidateFilter(
                        IN DWORD dwCount,
                        IN PTFILTERCONFIG pfilterConfigs,
                        IN TARRAY arrFilterArgs,
                        IN PTARRAY parrParsedFilters
                       )
/*++
 Routine Description:
     Parse and validate filter

 Arguments:
      [ in ] dwCount = Count
      [ in ] pfilterConfigs = filter configurations
      [ in ] arrFilterArgs = filter arguments
      [ in ] parrParsedFilters = array of parsed filters

 Return Value:
            FALSE: On failure
            TRUE: On success
--*/
{
    // local variables
    DWORD dw = 0;                               // looping variables
    DWORD dwFilters = 0;                        // holds the count of filters
    LONG lIndex = 0;                            // index variable
    LONG lNewIndex = 0;                         // index variable
    BOOL bResult = FALSE;                       // holds the result of the filter validation
    __MAX_SIZE_STRING szValue = NULL_STRING;    // value specified in filter
    __MAX_SIZE_STRING szOperator = NULL_STRING; // operator specified in filter
    __MAX_SIZE_STRING szProperty = NULL_STRING; // property specified in filter
    LPCTSTR pszFilter = NULL;
    TARRAY arrOperators = NULL;                 // operator-wise filter configuration

    // check the input value
    if ( pfilterConfigs == NULL || arrFilterArgs == NULL )
    {
        INVALID_PARAMETER();
        SaveLastError();
        return FALSE;
    }

    //
    // parse the filter configuration information and customize the information
    // to fasten the performance of the validating functionality
    //
    // create the dynamic array and prepare
    arrOperators = CreateDynamicArray();
    if ( arrOperators == NULL )
    {
        OUT_OF_MEMORY();
        SaveLastError();
        return FALSE;
    }

    // ...
    __PrepareOperators( dwCount, pfilterConfigs, arrOperators );

    // check whether filters ( parsed ) needs to initialized
    if ( parrParsedFilters != NULL && *parrParsedFilters == NULL )
    {
        *parrParsedFilters = CreateDynamicArray();      // create a dynamic array
        if ( *parrParsedFilters == NULL )
        {
            OUT_OF_MEMORY();
            SaveLastError();
            return FALSE;
        }
    }

    //
    // now start validating the filter
    //

    // traverse through the filters information and validate them
    bResult = TRUE;         // assume that filter validation is passed
    dwFilters = DynArrayGetCount( arrFilterArgs );      // count of filter specified
    for( dw = 0; dw < dwFilters; dw++ )
    {
        // reset all the needed variables
        StringCopy( szValue, NULL_STRING, MAX_STRING_LENGTH );
        StringCopy( szOperator, NULL_STRING, MAX_STRING_LENGTH );
        StringCopy( szProperty, NULL_STRING, MAX_STRING_LENGTH );

        // get the filter
        pszFilter = DynArrayItemAsString( arrFilterArgs, dw );
        if ( pszFilter == NULL )
        {
            // error occured
            bResult = FALSE;
            break;              // break from the loop ... no need of furthur processing
        }

        // identify the filter config for the current filter
        lIndex = __IdentifyFilterConfig( pszFilter,
            arrOperators, pfilterConfigs, szProperty, szOperator, szValue );

        // check whether the filter is found or not
        if ( lIndex == -1 )
        {
            // filter found to be invalid
            bResult = FALSE;
            break;              // break from the loop ... no need of furthur processing
        }

        // now that we found, current filter is having
        // valid property name, operator and valid value
        // save the parsed filter info and its corresponding filter configuration index
        // in global dynamic array if it is available
        if ( parrParsedFilters != NULL )
        {
            // append the filter info at the end of the array
            lNewIndex = DynArrayAppendRow( *parrParsedFilters, F_PARSED_INFO_COUNT );
            if ( lNewIndex == -1 )
            {
                OUT_OF_MEMORY();
                SaveLastError();
                return FALSE;
            }

            // ...
            DynArraySetDWORD2( *parrParsedFilters, lNewIndex, F_PARSED_INDEX_FILTER, lIndex );
            DynArraySetString2( *parrParsedFilters, lNewIndex, F_PARSED_INDEX_PROPERTY, szProperty, 0 );
            DynArraySetString2( *parrParsedFilters, lNewIndex, F_PARSED_INDEX_OPERATOR, szOperator, 0 );
            DynArraySetString2( *parrParsedFilters, lNewIndex, F_PARSED_INDEX_VALUE, szValue, 0 );
        }
    }

    // destroy the operators array
    DestroyDynamicArray( &arrOperators );

    // return the filter validation result
    return bResult;
}


BOOL CanFilterRecord( IN DWORD dwCount,
                      IN TFILTERCONFIG filterConfigs[],
                      IN TARRAY arrRecord,
                      IN TARRAY arrParsedFilters )
/*++
 Routine Description:
        checks for the records need to be deleted or not

 Arguments:
      [ in ] dwCount = count
      [ in ] filterConfigs[] = filter configurations
      [ in ] arrRecord = array of records
      [ in ] arrParsedFilters = array of parsed filters
 Return Value:
            FALSE: On failure
            TRUE: On success
--*/
{
    // local variables
    DWORD dw = 0;                   // looping variables
    DWORD dwFilters = 0;            // holds the total no. of filter available
    DWORD dwOperator = 0;           // holds the mask of the current filter
    DWORD dwFilterIndex = 0;
    DWORD dwCompareResult = 0;      // holds the result of comparision
    LPCTSTR pszTemp = NULL;
    TARRAY arrTemp = NULL;

    // prepare the operators mappings
    DWORD dwOperatorsCount = 0;
    TOPERATOR operators[] = {
        { MASK_EQ, OPERATOR_EQ },
        { MASK_NE, OPERATOR_NE },
        { MASK_GT, OPERATOR_GT },
        { MASK_LT, OPERATOR_LT },
        { MASK_GE, OPERATOR_GE },
        { MASK_LE, OPERATOR_LE }
    };

    UNREFERENCED_PARAMETER( dwCount );

    // check the input value
    if ( filterConfigs == NULL || arrRecord == NULL || arrParsedFilters == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return FALSE;
    }

    // traverse thru all the filters
    dwFilters = DynArrayGetCount( arrParsedFilters );
    dwOperatorsCount = sizeof( operators ) / sizeof( operators[ 0 ] );
    for( dw = 0; dw < dwFilters; dw++ )
    {
        // get the current filter configuration index
        dwFilterIndex = DynArrayItemAsDWORD2( arrParsedFilters, dw, F_PARSED_INDEX_FILTER );

        // get the appropriate operator mask
        pszTemp = DynArrayItemAsString2( arrParsedFilters, dw, F_PARSED_INDEX_OPERATOR );
        if ( pszTemp == NULL )
            continue;

        // ...
        dwOperator = __FindOperatorMask( dwOperatorsCount, operators, pszTemp );

        // if the operator is undefined, the filter should have
        // custom validation mask
        if ( dwOperator == 0 &&
              ( filterConfigs[ dwFilterIndex ].dwFlags & F_TYPE_MASK ) != F_TYPE_CUSTOM )
            return FALSE;       // invalid filter configuration

        // get the parsed filter info into local buffer
        arrTemp = DynArrayItem( arrParsedFilters, dw );
        if ( arrTemp == NULL )
            return FALSE;

        // do the comparision and get the result
        if ( filterConfigs[ dwFilterIndex ].dwFlags & F_MODE_ARRAY )
        {
            dwCompareResult = __DoArrayComparision(
                arrRecord, arrTemp, filterConfigs[ dwFilterIndex ] );
        }
        else
        {
            dwCompareResult = __DoComparision( arrRecord, arrTemp, filterConfigs[ dwFilterIndex ] );
        }

        // now check whether the current can be kept or not
        // if the filter is failed, break from the loop so that this row can be deleted
        if ( ( dwCompareResult & dwOperator ) == 0 )
            break;      // filter failed
    }

    // return the result of filter operation
    return ( dw != dwFilters );     // TRUE : delete record, FALSE : keep record
}


DWORD FilterResults( DWORD dwCount,
                     TFILTERCONFIG filterConfigs[],
                     TARRAY arrData, TARRAY arrParsedFilters )
/*++
 Routine Description:
        Get the filters and records and checks for the records to be
        deleted .

 Arguments:
      [ in ] dwCount = count
      [ in ] filterConfigs[] = filter configurations
      [ in ] arrData = array of data
      [ in ] arrParsedFilters = array of parsed filters

 Return Value: DWORD
--*/
{
    // local variables
    DWORD dw = 0;                   // looping variables
    DWORD dwDeleted = 0;
    DWORD dwRecords = 0;            // holds the total no. of records
    TARRAY arrRecord = NULL;

    // check the input value
    if ( filterConfigs == NULL || arrData == NULL || arrParsedFilters == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return 0;
    }

    //
    // start filtering the data

    // get the count of filters and records
    dwRecords = DynArrayGetCount( arrData );

    // traverse thru all thru the data
    for( dw = 0; dw < dwRecords; dw++ )
    {
        // get the current row ... this is just to increase fastness
        arrRecord = DynArrayItem( arrData, dw );
        if ( arrRecord == NULL )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            SaveLastError();
            return 0;
        }

        // check whether this record needs to be deleted or not
        if ( CanFilterRecord( dwCount, filterConfigs, arrRecord, arrParsedFilters ) )
        {
            DynArrayRemove( arrData, dw );  // delete record
            dw--;               // adjust the next record position
            dwRecords--;        // also adjust the total no. of records information
            dwDeleted++;
        }
    }

    // return no. of records deleted
    return dwDeleted;
}


LPCTSTR
FindOperator(
                IN LPCTSTR szOperator
            )
/*++
 Routine Description:
      retuns the mathematical operator from english operator

 Arguments:
      [ in ] szOperator = mathematical (or) english operator

 Return Value:
      Return a mathematical operator

--*/
{
    // local variables
    DWORD dwMask = 0;
    DWORD dwOperatorsCount = 0;
    TOPERATOR operators[] = {
        { MASK_EQ, OPERATOR_EQ },
        { MASK_NE, OPERATOR_NE },
        { MASK_GT, OPERATOR_GT },
        { MASK_LT, OPERATOR_LT },
        { MASK_GE, OPERATOR_GE },
        { MASK_LE, OPERATOR_LE }
    };

    // check the input value
    if ( szOperator == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return MATH_EQ;
    }

    // find the operator mask
    dwOperatorsCount = sizeof( operators ) / sizeof( operators[ 0 ] );
    dwMask = __FindOperatorMask( dwOperatorsCount, operators, szOperator );
    switch ( dwMask )
    {
    case MASK_EQ:
        return MATH_EQ;

    case MASK_NE:
        return MATH_NE;

    case MASK_LT:
        return MATH_LT;

    case MASK_GT:
        return MATH_GT;

    case MASK_LE:
        return MATH_LE;

    case MASK_GE:
        return MATH_GE;

    default:
        // default to be on safe side ... return '=' operator
        return MATH_EQ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\lib\dynarray.c ===
/***************************************************************************************
Copyright (c) Microsoft Corporation

Module Name:

   DynArray.C

Abstract:
   This module deals with the various functionalities such as creation of DynamicArrays, deletion of Dynamic Arrays,insertion
   of elements into Dynamic Arrays  and various other related functionalities.

Author:

    G.V.N Murali Sunil. 1-9-2000

Revision History :
***************************************************************************************/


#include "pch.h"
#include "cmdline.h"

//
// constants / compiler defines / enumerations
//

// signatures
#define _SIGNATURE_ARRAY        9
#define _SIGNATURE_ITEM     99

// hidden item types
#define _TYPE_NEEDINIT      DA_TYPE_NONE

//
// private structures ... structures declared in this area are not exposed to
// the external world ... hidden structures
//

// represents array item
typedef struct __tagItem
{
    DWORD dwSignature;          // signature ... used for validation
    DWORD dwType;               // says the type of the current item
    DWORD dwSize;               // size of the memory allocated
    LPVOID pValue;              // value of the item ( address )
    struct __tagItem* pNext;    // pointer to the next item
} __TITEM;

typedef __TITEM* __PTITEM;              // pointer typedefintion

// represents the array
typedef struct __tagArray
{
    DWORD dwSignature;      // signature ... for validating pointer
    DWORD dwCount;          // count of items in the array
    __PTITEM pStart;        // pointer to the first item
    __PTITEM pLast;         // pointer to the last item
} __TARRAY;

typedef __TARRAY* __PTARRAY;                // pointer typedefintion

//
// private function(s) ... used only in this file
//

__PTITEM
__DynArrayGetItem(
    TARRAY pArray,
    DWORD dwIndex,
    __PTITEM* ppPreviousItem
    )
/*++
Routine Description:
      To append any type of item into the Dynamic Array

Arguments:
      [ in ] pArray           - Dynamic Array containing the result
      [ in ] dwIndex          - Index of the  item
      [ in ] ppPreviousItem   - pointer to the previous item.

Return Value:
      Pointer to the structure containing the Item.
--*/
{
    // local variables
    DWORD i = 0 ;
    __PTITEM pItem = NULL;
    __PTITEM pPrevItem = NULL;
    __PTARRAY pArrayEx = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return NULL;
    }
    // convert the passed memory location info into appropriate structure
    pArrayEx = ( __PTARRAY ) pArray;

    // check the size of the array with the position of the item required
    // if the size is less, return NULL
    if ( pArrayEx->dwCount <= dwIndex )
    {
        return NULL;
    }
    // traverse thru the list and find the appropriate item
    pPrevItem = NULL;
    pItem = pArrayEx->pStart;
    for( i = 1; i <= dwIndex; i++ )
    {
        // store the current pointer and fetch the next pointer
        pPrevItem = pItem;
        pItem = pItem->pNext;
    }

    // if the previous pointer is also requested, update the previous pointer
    if ( NULL != ppPreviousItem ) { *ppPreviousItem = pPrevItem; }

    // now return the __TITEM pointer
    return pItem;
}


LONG
__DynArrayAppend(
    TARRAY pArray,
    DWORD dwType,
    DWORD dwSize,
    LPVOID pValue
    )
/*++
Routine Description:
     To append any type of item into the Dynamic Array.

Arguments:
     [ in ] pArray           - Dynamic Array containing the result.
     [ in ] dwType           - type of the  item.
     [ in ] dwSize           - Size of the item.
     [ in ] pValue           - pointer to the Item.

Return Value:
     If successfully added the item to the list then return index else -1.
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    __PTARRAY pArrayEx = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }

    // convert the passed memory location info into appropriate structure
    pArrayEx = ( __PTARRAY ) pArray;

    // Check for overflow condition.
    if( ULONG_MAX == pArrayEx->dwCount )
    {
        return -1;
    }

    // create an item and check the result. if memory allocation failed, error
    pItem = ( __PTITEM ) AllocateMemory( sizeof( __TITEM ) );
    if ( NULL == pItem )
    {
        return -1;
    }
    // initialize the newly allocated item structure with appropriate data
    pItem->pNext = NULL;
    pItem->dwType = dwType;
    pItem->dwSize = dwSize;
    pItem->pValue = pValue;
    pItem->dwSignature = _SIGNATURE_ITEM;

    pArrayEx->dwCount++;    // update the count of items in array info

    // now add the newly created item to the array at the end of the list
    if ( NULL == pArrayEx->pStart )
    {
        // first item in the array
        pArrayEx->pStart = pArrayEx->pLast = pItem;
    }
    else
    {
        // appending to the existing list
        pArrayEx->pLast->pNext = pItem;
        pArrayEx->pLast = pItem;
    }

    // successfully added the item to the list ... return index
    return ( pArrayEx->dwCount - 1 );       // count - 1 = index
}


LONG
__DynArrayInsert(
    TARRAY pArray,
    DWORD dwIndex,
    DWORD dwType,
    DWORD dwSize,
    LPVOID pValue
    )
/*++
Routine Description:
     To insert  an item into the Dynamic Array

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] dwIndex          - index of the  item
     [ in ] dwType           - type of the item
     [ in ] dwSize           - Size to the Item.
     [ in ] pValue           - pointer to the item.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // local variables
    DWORD i = 0;
    __PTITEM pItem = NULL;
    __PTITEM pBeforeInsert = NULL;
    __PTARRAY pArrayEx = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }

    // convert the passed memory location info into appropriate structure
    pArrayEx = ( __PTARRAY ) pArray;

    // Check for overflow condition.
    if( ULONG_MAX == pArrayEx->dwCount )
    {
        return -1;
    }

    // check the size of the array with the position of the insertion that has to be done
    // if the size is less, treat this call as just a call to Append function
    if ( pArrayEx->dwCount <= dwIndex )
    {
        return __DynArrayAppend( pArray, dwType, dwSize, pValue );
    }
    // create an item and check the result. if memory allocation failed, error
    pItem = ( __PTITEM ) AllocateMemory( sizeof( __TITEM ) );
    if ( NULL == pItem )
    {
        return -1;
    }
    // initialize the newly allocated item structure with appropriate data
    pItem->pNext = NULL;
    pItem->dwType = dwType;
    pItem->dwSize = dwSize;
    pItem->pValue = pValue;
    pItem->dwSignature = _SIGNATURE_ITEM;

    // update the count of the array items
    pArrayEx->dwCount++;

    // check whether the new item has to be added at the begining of the list
    if ( 0 == dwIndex )
    {
        // put the new item at the begining of the list
        pItem->pNext = pArrayEx->pStart;
        pArrayEx->pStart = pItem;

        // return as the operation is completed
        return TRUE;
    }

    // traverse thru the list and find the location where the insertion of
    // new element has to be done
    pBeforeInsert = pArrayEx->pStart;
    for( i = 0; i < dwIndex - 1; i++ )
    {
        pBeforeInsert = pBeforeInsert->pNext;
    }
    // insert the new item at the new location and update the chain
    pItem->pNext = pBeforeInsert->pNext;
    pBeforeInsert->pNext = pItem;

    // return as the operation is completed ... return index position
    return dwIndex;         // passed index itself is return value
}


VOID
__DynArrayFreeItemValue(
    __PTITEM pItem
    )
/*++
// ***************************************************************************
Routine Description:
     Frees the items present in a Dynamic array

Arguments:
     [ in ] pItem            - pointer to the item to be freed

Return Value:
     none
--*/
{
    // validate the pointer
    if ( NULL == pItem )
    {
        return;
    }
    // now free the items value based on its type
    switch( pItem->dwType )
    {
    case DA_TYPE_STRING:
    case DA_TYPE_LONG:
    case DA_TYPE_DWORD:
    case DA_TYPE_BOOL:
    case DA_TYPE_FLOAT:
    case DA_TYPE_DOUBLE:
    case DA_TYPE_HANDLE:
    case DA_TYPE_SYSTEMTIME:
    case DA_TYPE_FILETIME:
        FreeMemory( &( pItem->pValue ) );            // free the value
        break;

    case DA_TYPE_GENERAL:
        break;              // user program itself should de-allocate memory for this item

    case _TYPE_NEEDINIT:
        break;              // memory is not yet allocated for value of this item

    case DA_TYPE_ARRAY:
        // destroy the dynamic array
        DestroyDynamicArray( &pItem->pValue );
        pItem->pValue = NULL;
        break;

    default:
        break;
    }

    // return
    return;
}


LONG
__DynArrayFind(
    TARRAY pArray,
    DWORD dwType,
    LPVOID pValue,
    BOOL bIgnoreCase,
    DWORD dwCount
    )
/*++
Routine Description:
     To find  an item in the Dynamic Array

Arguments:
     [ in ] pArray               - Dynamic Array containing the result
     [ in ] dwType               - type of the item
     [ in ] pValue               - Conatains value of the new item.
     [ in ] bIgnoreCase          - boolean indicating if the search is
                                   case-insensitive
     [ in ] dwCount              - Contains number characters to compare
                                   for a string item.

Return Value:
     If successfully found the item in the DynamicArray then return index
     -1 in case of error.
--*/
{
    // local variables
    DWORD dw = 0;
    __PTITEM pItem = NULL;
    __PTARRAY pArrayEx = NULL;

    // temp variables
    FILETIME* pFTime1 = NULL;
    FILETIME* pFTime2 = NULL;
    SYSTEMTIME* pSTime1 = NULL;
    SYSTEMTIME* pSTime2 = NULL;

    // validate the array
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;              // array is not valid
    }
    // get the reference to the actual array
    pArrayEx = ( __PTARRAY ) pArray;

    // now traverse thru the array and search for the requested value
    pItem = pArrayEx->pStart;
    for ( dw = 0; dw < pArrayEx->dwCount; pItem = pItem->pNext, dw++ )
    {
        // before checking the value, check the data type of the item
        if ( pItem->dwType != dwType )
        {
            continue;           // item is not of needed type, skip this item
        }
        // now check the value of the item with the needed value
        switch ( dwType )
        {
        case DA_TYPE_LONG:
            {
                // value of type LONG
                if ( *( ( LONG* ) pItem->pValue ) == *( ( LONG* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_DWORD:
            {
                // value of type DWORD
                if ( *( ( DWORD* ) pItem->pValue ) == *( ( DWORD* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_FLOAT:
            {
                // value of type float
                if ( *( ( float* ) pItem->pValue ) == *( ( float* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_DOUBLE:
            {
                // value of type double
                if ( *( ( double* ) pItem->pValue ) == *( ( double* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_HANDLE:
            {
                // value of type HANDLE
                if ( *( ( HANDLE* ) pItem->pValue ) == *( ( HANDLE* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_STRING:
            {
                // value of type string
                if ( StringCompare( (LPCWSTR) pItem->pValue,
                                            (LPCWSTR) pValue, bIgnoreCase, dwCount ) == 0 )
                {
                    return dw;  // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_FILETIME:
            {
                // get the values ( for readability sake )
                pFTime1 = ( FILETIME* ) pValue;
                pFTime2 = ( FILETIME* ) pItem->pValue;
                if ( pFTime1->dwHighDateTime == pFTime2->dwHighDateTime &&
                     pFTime1->dwLowDateTime == pFTime2->dwLowDateTime )
                {
                    return dw;  // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_SYSTEMTIME:
            {
                // get the values ( for readability sake )
                pSTime1 = ( SYSTEMTIME* ) pValue;
                pSTime2 = ( SYSTEMTIME* ) pItem->pValue;
                if ( pSTime1->wDay == pSTime2->wDay &&
                     pSTime1->wDayOfWeek == pSTime1->wDayOfWeek &&
                     pSTime1->wHour == pSTime1->wHour &&
                     pSTime1->wMilliseconds == pSTime2->wMilliseconds &&
                     pSTime1->wMinute == pSTime2->wMinute &&
                     pSTime1->wMonth == pSTime2->wMonth &&
                     pSTime1->wSecond == pSTime2->wSecond &&
                     pSTime1->wYear == pSTime2->wYear )
                {
                    return dw;  // value matched
                }
                // break the case
                break;
            }

        default:
            {
                // just break ... nothin special to do
                break;
            }
        }
    }

    // value not found
    return -1;
}

LONG
__DynArrayFindEx(
    TARRAY pArray,
    DWORD dwColumn,
    DWORD dwType,
    LPVOID pValue,
    BOOL bIgnoreCase,
    DWORD dwCount
    )
/*++
Routine Description:
     To find  an item in the a 2 dimensional Dynamic Array .
     this function is private to this module only.
Arguments:
     [ in ] pArray               - Dynamic Array containing the result
     [ in ] dwColumn             - The number of columns
     [ in ] dwType               - type of the item
     [ in ] pValue               - Size to the Item.
     [ in ] bIgnoreCase          - boolean indicating if the search is case-insensitive
     [ in ] dwCount              - used in case of string type comparisions. The number of
                                   characters that have to be compared in a  particular column.

Return Value:
     If successfully found the item in the DynamicArray then return index
     -1 in case of error.
--*/
{
    // local variables
    DWORD dw = 0;
    __PTITEM pItem = NULL;
    __PTITEM pColumn = NULL;
    __PTARRAY pArrayEx = NULL;

    // temp variables
    FILETIME* pFTime1 = NULL;
    FILETIME* pFTime2 = NULL;
    SYSTEMTIME* pSTime1 = NULL;
    SYSTEMTIME* pSTime2 = NULL;

    // validate the array
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;              // array is not valid
    }

    // get the reference to the actual array
    pArrayEx = ( __PTARRAY ) pArray;

    // now traverse thru the array and search for the requested value
    pItem = pArrayEx->pStart;
    for ( dw = 0; dw < pArrayEx->dwCount; pItem = pItem->pNext, dw++ )
    {
        // check whether the current value is of ARRAY type or not
        if ( DA_TYPE_ARRAY != pItem->dwType )
        {
            continue;           // item is not of ARRAY type, skip this item
        }
        // now get the item at the required column
        pColumn = __DynArrayGetItem( pItem->pValue, dwColumn, NULL );
        if ( NULL == pColumn )
        {
            continue;           // column not found ... skip this item
        }
        // get the type of the column value
        if ( pColumn->dwType != dwType )
        {
            continue;           // column is not of needed type, skip this item also
        }
        // now check the value of the column with the needed value
        switch ( dwType )
        {
        case DA_TYPE_LONG:
            {
                // value of type LONG
                if ( *( ( LONG* ) pColumn->pValue ) == *( ( LONG* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_DWORD:
            {
                // value of type DWORD
                if ( *( ( DWORD* ) pColumn->pValue ) == *( ( DWORD* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_FLOAT:
            {
                // value of type float
                if ( *( ( float* ) pColumn->pValue ) == *( ( float* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_DOUBLE:
            {
                // value of type double
                if ( *( ( double* ) pColumn->pValue ) == *( ( double* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_HANDLE:
            {
                // value of type HANDLE
                if ( *( ( HANDLE* ) pColumn->pValue ) == *( ( HANDLE* ) pValue ) )
                {
                    return dw;          // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_STRING:
            {
                // value of type string
                if ( 0 == StringCompare( (LPCWSTR) pColumn->pValue,
                                            (LPCWSTR) pValue, bIgnoreCase, dwCount ) )
                {
                    return dw;  // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_FILETIME:
            {
                // get the values ( for readability sake )
                pFTime1 = ( FILETIME* ) pValue;
                pFTime2 = ( FILETIME* ) pItem->pValue;
                if ( pFTime1->dwHighDateTime == pFTime2->dwHighDateTime &&
                     pFTime1->dwLowDateTime == pFTime2->dwLowDateTime )
                {
                    return dw;  // value matched
                }
                // break the case
                break;
            }

        case DA_TYPE_SYSTEMTIME:
            {
                // get the values ( for readability sake )
                pSTime1 = ( SYSTEMTIME* ) pValue;
                pSTime2 = ( SYSTEMTIME* ) pItem->pValue;
                if ( pSTime1->wDay == pSTime2->wDay &&
                     pSTime1->wDayOfWeek == pSTime1->wDayOfWeek &&
                     pSTime1->wHour == pSTime1->wHour &&
                     pSTime1->wMilliseconds == pSTime2->wMilliseconds &&
                     pSTime1->wMinute == pSTime2->wMinute &&
                     pSTime1->wMonth == pSTime2->wMonth &&
                     pSTime1->wSecond == pSTime2->wSecond &&
                     pSTime1->wYear == pSTime2->wYear )
                {
                    return dw;  // value matched
                }
                // break the case
                break;
            }

        default:
            {
                // just break ... nothing special to do
                break;
            }
        }
    }

    // value not found
    return -1;
}

/*******************************************/
/***  IMPLEMENTATION OF PUBLIC FUNCTIONS ***/
/*******************************************/

BOOL
IsValidArray(
    TARRAY pArray
    )
/*++
Routine Description:
      Validate the array

Arguments:
     [ in ] pArray               - Dynamic Array

Return Value:
     TRUE - if it is a valid array else FALSE
--*/
{
    // check the signature
    return ( ( NULL != pArray ) &&
             ( _SIGNATURE_ARRAY == ( ( __PTARRAY ) pArray )->dwSignature ) );
}

TARRAY
CreateDynamicArray()
/*++
Routine Description:
      This function creates a dynamic array.

Arguments:
       None.

Return Value:
       pointer to the newly created array
--*/
{
    // local variables
    __PTARRAY pArray;

    // memory allocation ... array is being created
    pArray = ( __PTARRAY ) AllocateMemory( 1 * sizeof( __TARRAY ) );

    // check the allocation result
    if ( NULL == pArray )
    {
        return NULL;
    }
    // initialize the structure variables
    pArray->dwCount = 0;
    pArray->pStart = NULL;
    pArray->pLast = NULL;
    pArray->dwSignature = _SIGNATURE_ARRAY;

    // return array reference
    return pArray;
}


VOID
DynArrayRemoveAll(
    TARRAY pArray
    )
/*++
Routine Description:
        traverse thru the Dynamic Array and delete elements one by one

Arguments:
       [in]  pArray  - pointer to an array

Return Value:
       None.
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    __PTITEM pNextItem = NULL;
    __PTARRAY pArrayEx = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return;
    }
    // convert the passed memory location info into appropriate structure
    pArrayEx = ( __PTARRAY ) pArray;

    // traverse thru the list and delete elements one by one
    pItem = pArrayEx->pStart;
    while ( NULL != pItem )
    {
        pNextItem = pItem->pNext;               // get the next item in the list
        __DynArrayFreeItemValue( pItem );       // free memory allocated for data
        FreeMemory( &pItem );    // now free the memory allocated for the current item
        pItem = pNextItem;  // make the previously fetched next item as the current item
    }

    // as all the items are removed, reset the contents
    pArrayEx->dwCount = 0;
    pArrayEx->pStart = NULL;
    pArrayEx->pLast = NULL;

    // return
    return;
}


VOID
DestroyDynamicArray(
    PTARRAY pArray
    )
/*++
Routine Description:
     Destory the Dynamic array and free the memory.

Arguments:
     [in] pArray  - Pointer to the Dynamic array.

Return Value:
     none.
--*/
{
    // check whether the array is valid or not
    if ( FALSE == IsValidArray( *pArray ) )
    {
        return;
    }
    // remove all the elements in the array
    DynArrayRemoveAll( *pArray );

    // now free the memory allocated
    FreeMemory( pArray );
}

LONG
DynArrayAppend(
    TARRAY pArray,
    LPVOID pValue
    )
/*++
Routine Description:
     To append any type of item into the Dynamic Array

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] pValue           - pointer to the Item.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // validate the pointer value
    if ( NULL == pValue )
    {
        return -1;          // invalid memory address passed
    }
    // append the value and return the result
    return __DynArrayAppend( pArray, DA_TYPE_GENERAL, sizeof( LPVOID ), pValue );
}

LONG
DynArrayAppendString(
    TARRAY pArray,
    LPCWSTR szValue,
    DWORD dwLength
    )
/*++
// ***************************************************************************
Routine Description:
     To append a string into the Dynamic Array

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] szValue          - pointer to the string
     [ in ] dwLength         - Length of the String to be passed.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // local variables
    LONG lIndex = -1;
    LPWSTR pszValue = NULL;
    __PTARRAY pArrayEx = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // convert the passed memory location info into appropriate structure
    pArrayEx = ( __PTARRAY ) pArray;

    // determine the length of string ( memory ) that has to be allocated
    if ( 0 == dwLength )
    {
        dwLength = lstrlen( szValue );
    }
    // accomodate space for storing NULL character
    dwLength += 1;

    // allocate memory for value and check the result of memory allocation
    pszValue = ( LPWSTR ) AllocateMemory( dwLength * sizeof( WCHAR ) );
    if ( NULL == pszValue )
    {
        return -1;
    }
    // copy the contents of the string ( copy should be based on the length )
    StringCopy( pszValue, szValue, dwLength );

    // now add this item to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_STRING, dwLength * sizeof( WCHAR ), pszValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pszValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayAppendLong(
    TARRAY pArray,
    LONG lValue
    )
/*++
Routine Description:
     To append a variable of type Long  into the Dynamic Array.

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] lValue           - Variable to be appended.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // local variables
    LONG lIndex = -1;
    PLONG plValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    plValue = ( LONG* ) AllocateMemory( sizeof( LONG ) );
    if ( NULL == plValue )
    {
        return -1;
    }
    // set the value
    *plValue = lValue;

    // now add this item value to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_LONG, sizeof( LONG ), plValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &plValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayAppendDWORD(
    TARRAY pArray,
    DWORD dwValue
    )
/*++
Routine Description:
     To append a variable of type DWORD  into the Dynamic Array.

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] dwValue          - DWORD type Variable to be appended.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // local variables
    LONG lIndex = -1;
    PDWORD pdwValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pdwValue = ( DWORD* ) AllocateMemory( sizeof( DWORD ) );
    if ( NULL == pdwValue )
    {
        return -1;
    }
    // set the value
    *pdwValue = dwValue;

    // now add this item value to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_DWORD, sizeof( DWORD ), pdwValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pdwValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}

LONG
DynArrayAppendBOOL(
    TARRAY pArray,
    BOOL bValue
    )
/*++
Routine Description:
     To append a variable of type BOOL  into the Dynamic Array

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] bValue           - BOOL type Variable to be appended.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // local variables
    LONG lIndex = -1;
    PBOOL pbValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pbValue = ( PBOOL ) AllocateMemory( sizeof( BOOL ) );
    if ( NULL == pbValue )
    {
        return -1;
    }
    // set the value
    *pbValue = bValue;

    // now add this item value to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_BOOL, sizeof( BOOL ), pbValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pbValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}

LONG
DynArrayAppendFloat(
    TARRAY pArray,
    float fValue
    )
/*++
Routine Description:
     To append a variable of type Float  into the Dynamic Array.

Arguments:
     [ in ] pArray           - Dynamic Array containing the result.
     [ in ] fValue           - Float type Variable to be appended.

Return Value:
     If successfully added the item to the list then return index else -1.
--*/
{
    // local variables
    LONG lIndex = -1;
    float* pfValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pfValue = ( float* ) AllocateMemory( sizeof( float ) );
    if ( NULL == pfValue )
    {
        return -1;
    }
    // set the value
    *pfValue = fValue;

    // now add this item value to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_FLOAT, sizeof( float ), pfValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pfValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}

LONG
DynArrayAppendDouble(
    TARRAY pArray,
    double dblValue
    )
/*++
Routine Description:
     To append a variable of type Double  into the Dynamic Array

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] dblValue         - Double type Variable to be appended.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // local variables
    LONG lIndex = -1;
    double* pdblValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pdblValue = ( double* ) AllocateMemory( sizeof( double ) );
    if ( NULL == pdblValue )
    {
        return -1;
    }
    // set the value
    *pdblValue = dblValue;

    // now add this item value to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_DOUBLE, sizeof( double ), pdblValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pdblValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}

LONG
DynArrayAppendHandle(
    TARRAY pArray,
    HANDLE hValue
    )
/*++
Routine Description:
     To append a variable of type HANDLE  into the Dynamic Array

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] hValue           - HANDLE to be appended.

Return Value:
     If successfully added the item to the list then return index else -1.
--*/
{
    // local variables
    LONG lIndex = -1;
    HANDLE* phValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    phValue = ( HANDLE* ) AllocateMemory( sizeof( HANDLE ) );
    if ( NULL == phValue )
    {
        return -1;
    }
    // set the value
    *phValue = hValue;

    // now add this item value to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_HANDLE, sizeof( HANDLE ), phValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( ( LPVOID * )&phValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}

LONG
DynArrayAppendFileTime(
    TARRAY pArray,
    FILETIME ftValue
    )
/*++
Routine Description:
     To append a variable of type FILETIME  into the Dynamic Array

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] ftValue          - FILETIME to be appended.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // local variables
    LONG lIndex = -1;
    FILETIME* pftValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pftValue = ( FILETIME* ) AllocateMemory( sizeof( FILETIME ) );
    if ( NULL == pftValue )
    {
        return -1;
    }
    // set the value
    *pftValue = ftValue;

    // now add this item value to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_FILETIME, sizeof( FILETIME ), pftValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pftValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayAppendSystemTime(
    TARRAY pArray,
    SYSTEMTIME stValue
    )
/*++
Routine Description:
     To append a variable of type SYSTEMTIME  into the Dynamic Array

Arguments:
     [ in ] pArray           - Dynamic Array containing the result
     [ in ] stValue          - variable of type SYSTEMTIME to be appended.

Return Value:
     If successfully added the item to the list then return index else -1
--*/
{
    // local variables
    LONG lIndex = -1;
    SYSTEMTIME* pstValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pstValue = ( SYSTEMTIME* ) AllocateMemory( sizeof( SYSTEMTIME ) );
    if ( NULL == pstValue )
    {
        return -1;
    }
    // set the value
    *pstValue = stValue;

    // now add this item value to the array
    lIndex = __DynArrayAppend( pArray, DA_TYPE_SYSTEMTIME, sizeof( SYSTEMTIME ), pstValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pstValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}

LONG
DynArrayAppendRow(
    TARRAY pArray,
    DWORD dwColumns
    )
/*++
Routine Description:
     To add a empty Row to the 2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwColumns        - No of columns the Row contains.

Return Value:
     return the row number of the newly added row if successful else -1.
--*/
{
    // local variables
    DWORD dw = 0;
    LONG lIndex = -1;
    TARRAY arrSubArray = NULL;

    // validate the array
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;              // array is not valid
    }

    // create the dynamic array
    arrSubArray = CreateDynamicArray();
    if ( FALSE == IsValidArray( arrSubArray ) )
    {
        return -1;              // failed in creating the dynamic array
    }

    // add the required no. of columns to the sub array
    for( dw = 0; dw < dwColumns; dw++ )
    {
        // add the dummy item to the array and check the result
        // if operation failed, break
        if ( -1 == __DynArrayAppend( arrSubArray, _TYPE_NEEDINIT, 0, NULL ) )
        {
            break;
        }
    }

    // check whether the operation is successfull or not
    if ( dw != dwColumns )
    {
        // adding of columns failed
        // destroy the dynamic array and return
        DestroyDynamicArray( &arrSubArray );
        return -1;
    }

    // now add this sub array to the main array and check the result
    lIndex = __DynArrayAppend( pArray, DA_TYPE_ARRAY, sizeof( TARRAY ), arrSubArray );
    if ( -1 == lIndex )
    {
        // failed in attaching the sub array to the main array
        // destroy the dynamic array and return failure
        DestroyDynamicArray( &arrSubArray );
        return -1;
    }

    // operation is successfull
    return lIndex;
}

LONG
DynArrayAddColumns(
    TARRAY pArray,
    DWORD dwColumns
    )
/*++
Routine Description:
     To add 'n' no. of columns to the array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwColumns        - No of columns the Row contains.

Return Value:
     returns the no. of columns added
--*/
{
    // local variables
    DWORD dw = 0;

    // validate the array
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;              // array is not valid
    }
    // add the required no. of columns to the sub array
    for( dw = 0; dw < dwColumns; dw++ )
    {
        // add the dummy item to the array and check the result
        // if operation failed, break
        if ( -1 == __DynArrayAppend( pArray, _TYPE_NEEDINIT, 0, NULL ) )
        {
            break;
        }
    }

    // finish ...
    return dw;
}

LONG
DynArrayInsertColumns(
    TARRAY pArray,
    DWORD dwIndex,
    DWORD dwColumns
    )
/*++
Routine Description:
     inserts 'n' no. of columns to the array at the n'th location
Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwColumns        - No of columns the Row contains.

Return Value:
     returns the no. of columns added
--*/
{
    // local variables
    DWORD dw = 0;

    // validate the array
    if ( FALSE ==  IsValidArray( pArray ) )
    {
        return -1;              // array is not valid
    }
    // add the required no. of columns to the sub array
    for( dw = 0; dw < dwColumns; dw++ )
    {
        // add the dummy item to the array and check the result
        // if operation failed, break
        if ( -1 == __DynArrayInsert( pArray, dwIndex, _TYPE_NEEDINIT, 0, NULL ) )
        {
            break;
        }
    }

    // finish ...
    return dw;
}

LONG
DynArrayAppend2(
    TARRAY pArray,
    DWORD dwRow,
    LPVOID pValue
    )
/*++
Routine Description:
     To append a variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] pValue           - pointer to the value
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the value to the sub array and return the result to the caller
    return DynArrayAppend( pItem->pValue, pValue );
}


LONG
DynArrayAppendString2(
    TARRAY pArray,
    DWORD dwRow,
    LPCWSTR szValue,
    DWORD dwLength
    )
/*++
Routine Description:
     To append a string variable to a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] szValue          - pointer to the string value
     [ in ] dwLength         - length of the string.

Return Value:
     LONG value on success -1 on failure.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendString( pItem->pValue, szValue, dwLength );
}

LONG
DynArrayAppendLong2(
    TARRAY pArray,
    DWORD dwRow,
    LONG lValue
    )
/*++
Routine Description:
     To append a long type variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] lValue           - long type value to be appended.
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendLong( pItem->pValue, lValue );
}

LONG
DynArrayAppendDWORD2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwValue
    )
/*++
Routine Description:
     To append a DWORD type variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] dwValue          - DWORD type value to be appended.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendDWORD( pItem->pValue, dwValue );
}

LONG
DynArrayAppendBOOL2(
    TARRAY pArray,
    DWORD dwRow,
    BOOL bValue
    )
/*++
Routine Description:
     To append a BOOL type variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] bValue           - BOOL type value to be appended.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendBOOL( pItem->pValue, bValue );
}


LONG
DynArrayAppendFloat2(
    TARRAY pArray,
    DWORD dwRow,
    float fValue
    )

/*++
Routine Description:
     To append a Float type variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] fValue           - Float type value to be appended.
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendFloat( pItem->pValue, fValue );
}


LONG
DynArrayAppendDouble2(
    TARRAY pArray,
    DWORD dwRow,
    double dblValue
    )
/*++
Routine Description:
     To append a double type variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] dblValue         - dblValue type value to be appended.
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendDouble( pItem->pValue, dblValue );
}

LONG
DynArrayAppendHandle2(
    TARRAY pArray,
    DWORD dwRow,
    HANDLE hValue
    )
/*++
Routine Description:
     To append a Handle type variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] hValue           - Handle value to be appended.
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendHandle( pItem->pValue, hValue );
}


LONG
DynArrayAppendFileTime2(
    TARRAY pArray,
    DWORD dwRow,
    FILETIME ftValue
    )
/*++
Routine Description:
     To append a FILETIME type variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] ftValue          - variable of type FILETIME to be appended.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendFileTime( pItem->pValue, ftValue );
}


LONG
DynArrayAppendSystemTime2(
    TARRAY pArray,
    DWORD dwRow,
    SYSTEMTIME stValue
    )
/*++
Routine Description:
     To append a SYSTEMTIME type variable to a row in a  2-dimensional Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row posn for which the new value
                               is to be added.
     [ in ] stValue          - variable of type SYSTEMTIME to be appended.
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayAppendSystemTime( pItem->pValue, stValue );
}


LONG
DynArrayInsert(
    TARRAY pArray,
    DWORD dwIndex,
    LPVOID pValue
    )
/*++
Routine Description:
     To insert a variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] pValue           - value to be inserted.
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // validate the pointer value
    if ( NULL == pValue )
    {
        return -1;          // invalid memory address passed
    }
    // append the value and return the result
    return __DynArrayInsert( pArray, dwIndex, DA_TYPE_GENERAL, sizeof( LPVOID ), pValue );
}


LONG
DynArrayInsertString(
    TARRAY pArray,
    DWORD dwIndex,
    LPCWSTR szValue,
    DWORD dwLength
    )
/*++
Routine Description:
     To insert a string type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] szValue          - pointer to the string
     [ in ] dwLength         - length of the string.
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    LPWSTR pszValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // determine the length of string ( memory ) that has to be allocated
    if ( 0 == dwLength )
    {
        dwLength = lstrlen( szValue );
    }
    // accomodate space for storing NULL character
    dwLength += 1;

    // allocate memory for and check the result of memory allocation
    pszValue = ( LPWSTR ) AllocateMemory( dwLength * sizeof( WCHAR ) );
    if ( NULL == pszValue )
    {
        return -1;
    }
    // copy the contents of the string ( copy should be based on the length )
    StringCopy( pszValue, szValue, dwLength );

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex,
        DA_TYPE_STRING, dwLength * sizeof( WCHAR ), pszValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pszValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayInsertLong(
    TARRAY pArray,
    DWORD dwIndex,
    LONG lValue
    )
/*++
Routine Description:
     To insert a string type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] lValue           - pointer to the string.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    PLONG plValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    plValue = ( LONG* ) AllocateMemory( sizeof( LONG ) );
    if ( NULL == plValue )
    {
        return -1;
    }
    // set the value
    *plValue = lValue;

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_LONG, sizeof( LONG ), plValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &plValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}

LONG
DynArrayInsertDWORD(
    TARRAY pArray,
    DWORD dwIndex,
    DWORD dwValue
    )
/*++
Routine Description:
     To insert a DWORD type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] dwValue          - specifies the variable to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    PDWORD pdwValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pdwValue = ( PDWORD ) AllocateMemory( sizeof( DWORD ) );
    if ( NULL == pdwValue )
    {
        return -1;
    }
    // set the value
    *pdwValue = dwValue;

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_DWORD, sizeof( DWORD ), pdwValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pdwValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}

LONG
DynArrayInsertBOOL(
    TARRAY pArray,
    DWORD dwIndex,
    BOOL bValue
    )
/*++
Routine Description:
    To insert a BOOL type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] bValue           - specifies the  BOOL variable to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    PBOOL pbValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pbValue = ( PBOOL ) AllocateMemory( sizeof( BOOL ) );
    if ( NULL == pbValue )
    {
        return -1;
    }
    // set the value
    *pbValue = bValue;

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_BOOL, sizeof( BOOL ), pbValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pbValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayInsertFloat(
    TARRAY pArray,
    DWORD dwIndex,
    float fValue
    )
/*++
Routine Description:
     To insert a float type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] fValue           - specifies the  float type  variable to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    float* pfValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pfValue = ( float* ) AllocateMemory( sizeof( float ) );
    if ( NULL == pfValue )
    {
        return -1;
    }
    // set the value
    *pfValue = fValue;

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_FLOAT, sizeof( float ), pfValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pfValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayInsertDouble(
    TARRAY pArray,
    DWORD dwIndex,
    double dblValue
    )
/*++
Routine Description:
     To insert a double type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] dblValue         - specifies the  double type  variable to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    double* pdblValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pdblValue = ( double* ) AllocateMemory( sizeof( double ) );
    if ( NULL == pdblValue )
    {
        return -1;
    }
    // set the value
    *pdblValue = dblValue;

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_DOUBLE, sizeof( double ), pdblValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pdblValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayInsertHandle(
    TARRAY pArray,
    DWORD dwIndex,
    HANDLE hValue
    )
/*++
Routine Description:
     To insert a HANDLE type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] hValue           - specifies the  HANDLE type  variable to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    HANDLE* phValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    phValue = ( HANDLE* ) AllocateMemory( sizeof( HANDLE ) );
    if ( NULL == phValue )
    {
        return -1;
    }
    // set the value
    *phValue = hValue;

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_HANDLE, sizeof( HANDLE ), phValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( (LPVOID * )&phValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayInsertSystemTime(
    TARRAY pArray,
    DWORD dwIndex,
    SYSTEMTIME stValue
    )
/*++
Routine Description:
     To insert a SYSTEMTIME type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] stValue          - specifies the  SYSTEMTIME type  variable to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    SYSTEMTIME* pstValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pstValue = ( SYSTEMTIME* ) AllocateMemory( sizeof( SYSTEMTIME ) );
    if ( NULL == pstValue )
    {
        return -1;
    }
    // set the value
    *pstValue = stValue;

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_SYSTEMTIME,
        sizeof( SYSTEMTIME ), pstValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pstValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayInsertFileTime(
    TARRAY pArray,
    DWORD dwIndex,
    FILETIME ftValue
    )
/*++
Routine Description:
     To insert a SYSTEMTIME type variable into a  Dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] ftValue          - specifies the  SYSTEMTIME type  variable to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    LONG lIndex = -1;
    FILETIME* pftValue = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;
    }
    // allocate memory for value and check the result of memory allocation
    pftValue = ( FILETIME* ) AllocateMemory( sizeof( FILETIME ) );
    if ( NULL == pftValue )
    {
        return -1;
    }
    // set the value
    *pftValue = ftValue;

    // now add this item value to the array
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_FILETIME,
        sizeof( FILETIME ), pftValue );
    if ( -1 == lIndex )
    {
        // failed in adding this item to the array
        // so, free the memory allocated and return from the function
        FreeMemory( &pftValue );
        return -1;
    }

    // added the item to the array
    return lIndex;
}


LONG
DynArrayInsertRow(
    TARRAY pArray,
    DWORD dwIndex,
    DWORD dwColumns
    )
/*++
Routine Description:
     this funtion insert a new row to a dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - Specifies the index.
     [ in ] dwColumns        - specifies the  number of columns to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    DWORD dw = 0;
    LONG lIndex = -1;
    TARRAY arrSubArray = NULL;

    // validate the array
    if ( FALSE == IsValidArray( pArray ) )
    {
        return -1;              // array is not valid
    }
    // create the dynamic array
    arrSubArray = CreateDynamicArray();
    if ( FALSE == IsValidArray( arrSubArray ) )
    {
        return -1;              // failed in creating the dynamic array
    }
    // add the required no. of columns to the sub array
    for( dw = 0; dw < dwColumns; dw++ )
    {
        // add the dummy item to the array and check the result
        // if operation failed, break
        if ( -1 == __DynArrayAppend( arrSubArray, _TYPE_NEEDINIT, 0, NULL ) )
        {
            break;
        }
    }

    // check whether the operation is successfull or not
    if ( dw != dwColumns )
    {
        // adding of columns failed
        // destroy the dynamic array and return
        DestroyDynamicArray( &arrSubArray );
        return -1;
    }

    // now add this sub array to the main array and check the result
    lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_ARRAY,
                               sizeof( TARRAY ), arrSubArray );
    if ( -1 == lIndex )
    {
        // failed in attaching the sub array to the main array
        // destroy the dynamic array and return failure
        DestroyDynamicArray( &arrSubArray );
        return -1;
    }

    // operation is successfull
    return lIndex;
}

LONG
DynArrayInsert2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    LPVOID pValue
    )
/*++
Routine Description:
     this funtion insert a new row to a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] pValue           - pointer to the value.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the value to the sub array and return the result to the caller
    return DynArrayInsert( pItem->pValue, dwColIndex, pValue );
}


LONG
DynArrayInsertString2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    LPCWSTR szValue,
    DWORD dwLength
    )
/*++
Routine Description:
     this funtion insert a new string into a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] szValue          - pointer to the value.
     [ in ] dwLength         - string length.
Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertString( pItem->pValue, dwColIndex, szValue, dwLength );
}


LONG
DynArrayInsertLong2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    LONG lValue
    )
/*++
Routine Description:
     this funtion insert a new long type varaible into a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] lValue           - long type value to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertLong( pItem->pValue, dwColIndex, lValue );
}

LONG
DynArrayInsertDWORD2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    DWORD dwValue
    )
/*++
Routine Description:
     this funtion insert a new DWORD type varaible into a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] dwValue          - DWORD value to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertDWORD( pItem->pValue, dwColIndex, dwValue );
}

LONG
DynArrayInsertBOOL2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    BOOL bValue
    )
/*++
Routine Description:
     this funtion insert a new BOOL type variable into a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] bValue           - BOOL type value to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertBOOL( pItem->pValue, dwColIndex, bValue );
}

LONG
DynArrayInsertFloat2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    float fValue
    )
/*++
Routine Description:
     this funtion insert a new float type variable into a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] fValue           - float type value to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertFloat( pItem->pValue, dwColIndex, fValue );
}


LONG
DynArrayInsertDouble2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    double dblValue
    )
/*++
Routine Description:
     this funtion insert a new double type variable into a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] dblValue         - double type value to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertDouble( pItem->pValue, dwColIndex, dblValue );
}

LONG
DynArrayInsertHandle2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    HANDLE hValue
    )
/*++
Routine Description:
     this funtion insert a new double type variable into a 2-dimensional  dynamic array.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] hValue           - HANDLE type value to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertHandle( pItem->pValue, dwColIndex, hValue );
}


LONG
DynArrayInsertSystemTime2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    SYSTEMTIME stValue
    )
/*++
Routine Description:
     This funtion insert a new  SYSTEMTIME type variable into a 2-dimensional  dynamic array.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] stValue          - SYSTEMTIME type value to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertSystemTime( pItem->pValue, dwColIndex, stValue );
}


LONG
DynArrayInsertFileTime2(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColIndex,
    FILETIME ftValue
    )
/*++
Routine Description:
     this funtion insert a new  FILETIME type variable into a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - Specifies the row.
     [ in ] dwColIndex       - specifies the column
     [ in ] ftValue          - FILETIME type value to be inserted.

Return Value:
     -1 on failure
     index in the case of success.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return -1;  // no item exists at the specified row or item is not of type array
    }
    // now add the string to the sub array and return the result to the caller
    return DynArrayInsertFileTime( pItem->pValue, dwColIndex, ftValue );
}


BOOL
DynArrayRemove(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     This funtion empties the contents of the dynamic array.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex      - specifies the column

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    __PTITEM pPrevItem = NULL;
    __PTARRAY pArrayEx = NULL;

    // convert the passed memory location info into appropriate structure
    pArrayEx = ( __PTARRAY ) pArray;

    // get the pointer to the item that has to be removed and also its previous item
    pItem = __DynArrayGetItem( pArrayEx, dwIndex, &pPrevItem );
    if ( NULL == pItem )
    {
        return FALSE;   // index or array is invalid ... cannot proceed
    }
    // unlink the item from the list first
    // before unlinking, check whether item which is going to deleted
    //      is the first item in the list
    //      is the last item in the list
    //      is the middle item in the list
    // Control should not come here if no items are present in the ARRAY.

    // If middle item or last item.
    if ( pPrevItem != NULL ) { pPrevItem->pNext = pItem->pNext; }

    // If first item of the array.
    if ( pPrevItem == NULL ) { pArrayEx->pStart = pItem->pNext; }

    // If last item of the array.
    if ( pItem == pArrayEx->pLast ) { pArrayEx->pLast = pPrevItem; }

    // update the count of the array item
    pArrayEx->dwCount--;

    // free the memory being used by the currently unlinked item and return success
    __DynArrayFreeItemValue( pItem );   // free the memory allocated for storing data
    FreeMemory( &pItem );        // finally free the memory allocated for item itself
    return TRUE;
}



BOOL
DynArrayRemoveColumn(
    TARRAY pArray,
    DWORD dwRow,
    DWORD dwColumn
    )
/*++
Routine Description:
     this funtion REMOVES a column from a  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - specifies the row.
     [ in ] dwColumn         - specifies the column

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }

    // now add the string to the sub array and return the result to the caller
    return DynArrayRemove( pItem->pValue, dwColumn );
}


DWORD
DynArrayGetCount(
    TARRAY pArray
    )
/*++
Routine Description:
     this function retreives the number of rows in a 1-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTARRAY pArrayEx = NULL;

    // check whether the array is valid or not
    if ( FALSE == IsValidArray( pArray ) )
    {
        return 0;
    }
    // convert the passed memory location info into appropriate structure
    pArrayEx = ( __PTARRAY ) pArray;

    // return the size of the array
    return pArrayEx->dwCount;
}

DWORD
DynArrayGetCount2(
    TARRAY pArray,
    DWORD dwRow
    )
/*++
Routine Description:
     this function retreives the number of columns in a 2-dimensional  dynamic array

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwRow            - row for which the number of columns have to be got.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required row
    pItem = __DynArrayGetItem( pArray, dwRow, NULL );
    if ( ( NULL == pItem ) ||
         ( DA_TYPE_ARRAY != pItem->dwType ) )
    {
        return FALSE;   // no item exists at the specified row or item is not of type array
    }

    // now add the string to the sub array and return the result to the caller
    return DynArrayGetCount( pItem->pValue );
}

LPVOID
DynArrayItem(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.
Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return NULL;       // index / array is not valid
    }

    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_GENERAL != pItem->dwType && DA_TYPE_ARRAY != pItem->dwType )
    {
        return NULL;
    }
    // now return the contents of the __TITEM structure
    return pItem->pValue;
}

LPCWSTR
DynArrayItemAsString(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a string.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return NULL;        // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_STRING != pItem->dwType )
    {
        return NULL;
    }
    // now return the contents of the __TITEM structure
    return ( ( LPCWSTR ) pItem->pValue );
}


LONG
DynArrayItemAsLong(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a Long varaible.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return -1;                 // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_DWORD != pItem->dwType && DA_TYPE_LONG != pItem->dwType )
    {
        return -1;
    }
    // now return the contents of the __TITEM structure
    return ( *( PLONG ) pItem->pValue );
}


DWORD
DynArrayItemAsDWORD(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a DWORD varaible.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.
Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return 0;                  // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_DWORD != pItem->dwType && DA_TYPE_LONG != pItem->dwType )
    {
        return 0;
    }
    // now return the contents of the __TITEM structure
    return *( ( PDWORD ) pItem->pValue );
}


BOOL
DynArrayItemAsBOOL(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a bool type varaible.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return FALSE;                   // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_BOOL != pItem->dwType )
    {
        return FALSE;
    }
    // now return the contents of the __TITEM structure
    return *( ( PBOOL ) pItem->pValue );
}


float
DynArrayItemAsFloat(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a float type varaible.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return -1.0f;                   // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_FLOAT != pItem->dwType )
    {
        return -1.0f;
    }
    // now return the contents of the __TITEM structure
    return *( ( float* ) pItem->pValue );
}


double
DynArrayItemAsDouble(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a double type varaible.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return -1.0;                    // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_DOUBLE != pItem->dwType )
    {
        return -1.0;
    }
    // now return the contents of the __TITEM structure
    return *( ( double* ) pItem->pValue );
}


HANDLE
DynArrayItemAsHandle(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     This function retreives the item from a dynamic array as a handle type varaible.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return NULL;                    // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_HANDLE != pItem->dwType )
    {
        return NULL;
    }
    // now return the contents of the __TITEM structure
    return *( ( HANDLE* ) pItem->pValue );
}


SYSTEMTIME
DynArrayItemAsSystemTime(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a SYSTEMTIME type varaible.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    FILETIME ftTemp;
    SYSTEMTIME stTemp;           // dummy

    ZeroMemory( &ftTemp, sizeof( FILETIME ) );
    ZeroMemory( &stTemp, sizeof( SYSTEMTIME ) );
    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return stTemp;                  // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_SYSTEMTIME != pItem->dwType && DA_TYPE_FILETIME != pItem->dwType )
    {
        return stTemp;
    }
    // now do the needed manipulations ( if needed )
    if ( pItem->dwType == DA_TYPE_SYSTEMTIME )
    {
        // value itself is of required type
        stTemp = *( ( SYSTEMTIME* ) pItem->pValue );
    }
    else
    {
        // need to do conversions
        ftTemp = *( ( FILETIME* ) pItem->pValue );
        // Intentionally return value is not checked.
        FileTimeToSystemTime( &ftTemp, &stTemp );
    }

    // now return the contents of the __TITEM structure
    return stTemp;
}

FILETIME
DynArrayItemAsFileTime(
    TARRAY pArray,
    DWORD dwIndex
    )
/*++
Routine Description:
     this function retreives the item from a dynamic array as a FILETIME type varaible.

Arguments:
     [ in ] pArray           - Dynamic Array
     [ in ] dwIndex          - index.

Return Value:
     false on failure
     true ON SUCCESS.
--*/
{
    // local variables
    __PTITEM pItem = NULL;
    FILETIME ftTemp;         // dummy
    SYSTEMTIME stTemp;           // dummy

    ZeroMemory( &ftTemp, sizeof( FILETIME ) );
    ZeroMemory( &stTemp, sizeof( SYSTEMTIME ) );

    // get the item at the required index
    pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
    if ( NULL == pItem )
    {
        return ftTemp;                  // index / array is not valid
    }
    // check the type of the item first
    // if the type doesn't match, return some default value
    if ( DA_TYPE_SYSTEMTIME != pItem->dwType && DA_TYPE_FILETIME != pItem->dwType )
    {
        return ftTemp;
    }
    // now do the needed manipulations ( if needed )
    if ( 